(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.adapter = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */

'use strict';

var _adapter_factory = require('./adapter_factory.js');

var adapter = (0, _adapter_factory.adapterFactory)({ window: window });
module.exports = adapter; // this is the difference from adapter_core.

},{"./adapter_factory.js":2}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adapterFactory = adapterFactory;

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _chrome_shim = require('./chrome/chrome_shim');

var chromeShim = _interopRequireWildcard(_chrome_shim);

var _edge_shim = require('./edge/edge_shim');

var edgeShim = _interopRequireWildcard(_edge_shim);

var _firefox_shim = require('./firefox/firefox_shim');

var firefoxShim = _interopRequireWildcard(_firefox_shim);

var _safari_shim = require('./safari/safari_shim');

var safariShim = _interopRequireWildcard(_safari_shim);

var _common_shim = require('./common_shim');

var commonShim = _interopRequireWildcard(_common_shim);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Shimming starts here.
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
function adapterFactory() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      window = _ref.window;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    shimChrome: true,
    shimFirefox: true,
    shimEdge: true,
    shimSafari: true
  };

  // Utils.
  var logging = utils.log;
  var browserDetails = utils.detectBrowser(window);

  var adapter = {
    browserDetails: browserDetails,
    commonShim: commonShim,
    extractVersion: utils.extractVersion,
    disableLog: utils.disableLog,
    disableWarnings: utils.disableWarnings
  };

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
        logging('Chrome shim is not included in this adapter release.');
        return adapter;
      }
      if (browserDetails.version === null) {
        logging('Chrome shim can not determine version, not shimming.');
        return adapter;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = chromeShim;

      chromeShim.shimGetUserMedia(window);
      chromeShim.shimMediaStream(window);
      chromeShim.shimPeerConnection(window);
      chromeShim.shimOnTrack(window);
      chromeShim.shimAddTrackRemoveTrack(window);
      chromeShim.shimGetSendersWithDtmf(window);
      chromeShim.shimGetStats(window);
      chromeShim.shimSenderReceiverGetStats(window);
      chromeShim.fixNegotiationNeeded(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimConnectionState(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      commonShim.removeAllowExtmapMixed(window);
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
        logging('Firefox shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = firefoxShim;

      firefoxShim.shimGetUserMedia(window);
      firefoxShim.shimPeerConnection(window);
      firefoxShim.shimOnTrack(window);
      firefoxShim.shimRemoveStream(window);
      firefoxShim.shimSenderGetStats(window);
      firefoxShim.shimReceiverGetStats(window);
      firefoxShim.shimRTCDataChannel(window);
      firefoxShim.shimAddTransceiver(window);
      firefoxShim.shimCreateOffer(window);
      firefoxShim.shimCreateAnswer(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimConnectionState(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
        logging('MS edge shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = edgeShim;

      edgeShim.shimGetUserMedia(window);
      edgeShim.shimGetDisplayMedia(window);
      edgeShim.shimPeerConnection(window);
      edgeShim.shimReplaceTrack(window);

      // the edge shim implements the full RTCIceCandidate object.

      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'safari':
      if (!safariShim || !options.shimSafari) {
        logging('Safari shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = safariShim;

      safariShim.shimRTCIceServerUrls(window);
      safariShim.shimCreateOfferLegacy(window);
      safariShim.shimCallbacksAPI(window);
      safariShim.shimLocalStreamsAPI(window);
      safariShim.shimRemoteStreamsAPI(window);
      safariShim.shimTrackEventTransceiver(window);
      safariShim.shimGetUserMedia(window);
      safariShim.shimAudioContext(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      commonShim.removeAllowExtmapMixed(window);
      break;
    default:
      logging('Unsupported browser!');
      break;
  }

  return adapter;
}

// Browser shims.

},{"./chrome/chrome_shim":3,"./common_shim":6,"./edge/edge_shim":7,"./firefox/firefox_shim":11,"./safari/safari_shim":14,"./utils":15}],3:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _getusermedia = require('./getusermedia');

Object.defineProperty(exports, 'shimGetUserMedia', {
  enumerable: true,
  get: function get() {
    return _getusermedia.shimGetUserMedia;
  }
});

var _getdisplaymedia = require('./getdisplaymedia');

Object.defineProperty(exports, 'shimGetDisplayMedia', {
  enumerable: true,
  get: function get() {
    return _getdisplaymedia.shimGetDisplayMedia;
  }
});
exports.shimMediaStream = shimMediaStream;
exports.shimOnTrack = shimOnTrack;
exports.shimGetSendersWithDtmf = shimGetSendersWithDtmf;
exports.shimGetStats = shimGetStats;
exports.shimSenderReceiverGetStats = shimSenderReceiverGetStats;
exports.shimAddTrackRemoveTrackWithNative = shimAddTrackRemoveTrackWithNative;
exports.shimAddTrackRemoveTrack = shimAddTrackRemoveTrack;
exports.shimPeerConnection = shimPeerConnection;
exports.fixNegotiationNeeded = fixNegotiationNeeded;

var _utils = require('../utils.js');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function shimMediaStream(window) {
  window.MediaStream = window.MediaStream || window.webkitMediaStream;
}

function shimOnTrack(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
      get: function get() {
        return this._ontrack;
      },
      set: function set(f) {
        if (this._ontrack) {
          this.removeEventListener('track', this._ontrack);
        }
        this.addEventListener('track', this._ontrack = f);
      },

      enumerable: true,
      configurable: true
    });
    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      var _this = this;

      if (!this._ontrackpoly) {
        this._ontrackpoly = function (e) {
          // onaddstream does not fire when a track is added to an existing
          // stream. But stream.onaddtrack is implemented so we use that.
          e.stream.addEventListener('addtrack', function (te) {
            var receiver = void 0;
            if (window.RTCPeerConnection.prototype.getReceivers) {
              receiver = _this.getReceivers().find(function (r) {
                return r.track && r.track.id === te.track.id;
              });
            } else {
              receiver = { track: te.track };
            }

            var event = new Event('track');
            event.track = te.track;
            event.receiver = receiver;
            event.transceiver = { receiver: receiver };
            event.streams = [e.stream];
            _this.dispatchEvent(event);
          });
          e.stream.getTracks().forEach(function (track) {
            var receiver = void 0;
            if (window.RTCPeerConnection.prototype.getReceivers) {
              receiver = _this.getReceivers().find(function (r) {
                return r.track && r.track.id === track.id;
              });
            } else {
              receiver = { track: track };
            }
            var event = new Event('track');
            event.track = track;
            event.receiver = receiver;
            event.transceiver = { receiver: receiver };
            event.streams = [e.stream];
            _this.dispatchEvent(event);
          });
        };
        this.addEventListener('addstream', this._ontrackpoly);
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  } else {
    // even if RTCRtpTransceiver is in window, it is only used and
    // emitted in unified-plan. Unfortunately this means we need
    // to unconditionally wrap the event.
    utils.wrapPeerConnectionEvent(window, 'track', function (e) {
      if (!e.transceiver) {
        Object.defineProperty(e, 'transceiver', { value: { receiver: e.receiver } });
      }
      return e;
    });
  }
}

function shimGetSendersWithDtmf(window) {
  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
    var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {
      return {
        track: track,
        get dtmf() {
          if (this._dtmf === undefined) {
            if (track.kind === 'audio') {
              this._dtmf = pc.createDTMFSender(track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        },
        _pc: pc
      };
    };

    // augment addTrack when getSenders is not available.
    if (!window.RTCPeerConnection.prototype.getSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        this._senders = this._senders || [];
        return this._senders.slice(); // return a copy of the internal state.
      };
      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
        var sender = origAddTrack.apply(this, arguments);
        if (!sender) {
          sender = shimSenderWithDtmf(this, track);
          this._senders.push(sender);
        }
        return sender;
      };

      var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
        origRemoveTrack.apply(this, arguments);
        var idx = this._senders.indexOf(sender);
        if (idx !== -1) {
          this._senders.splice(idx, 1);
        }
      };
    }
    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      var _this2 = this;

      this._senders = this._senders || [];
      origAddStream.apply(this, [stream]);
      stream.getTracks().forEach(function (track) {
        _this2._senders.push(shimSenderWithDtmf(_this2, track));
      });
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      var _this3 = this;

      this._senders = this._senders || [];
      origRemoveStream.apply(this, [stream]);

      stream.getTracks().forEach(function (track) {
        var sender = _this3._senders.find(function (s) {
          return s.track === track;
        });
        if (sender) {
          // remove sender
          _this3._senders.splice(_this3._senders.indexOf(sender), 1);
        }
      });
    };
  } else if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
      var _this4 = this;

      var senders = origGetSenders.apply(this, []);
      senders.forEach(function (sender) {
        return sender._pc = _this4;
      });
      return senders;
    };

    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
      get: function get() {
        if (this._dtmf === undefined) {
          if (this.track.kind === 'audio') {
            this._dtmf = this._pc.createDTMFSender(this.track);
          } else {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
}

function shimGetStats(window) {
  if (!window.RTCPeerConnection) {
    return;
  }

  var origGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    var _this5 = this;

    var _arguments = Array.prototype.slice.call(arguments),
        selector = _arguments[0],
        onSucc = _arguments[1],
        onErr = _arguments[2];

    // If selector is a function then we are in the old style stats so just
    // pass back the original getStats format to avoid breaking old users.


    if (arguments.length > 0 && typeof selector === 'function') {
      return origGetStats.apply(this, arguments);
    }

    // When spec-style getStats is supported, return those when called with
    // either no arguments or the selector argument is null.
    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {
      return origGetStats.apply(this, []);
    }

    var fixChromeStats_ = function fixChromeStats_(response) {
      var standardReport = {};
      var reports = response.result();
      reports.forEach(function (report) {
        var standardStats = {
          id: report.id,
          timestamp: report.timestamp,
          type: {
            localcandidate: 'local-candidate',
            remotecandidate: 'remote-candidate'
          }[report.type] || report.type
        };
        report.names().forEach(function (name) {
          standardStats[name] = report.stat(name);
        });
        standardReport[standardStats.id] = standardStats;
      });

      return standardReport;
    };

    // shim getStats with maplike support
    var makeMapStats = function makeMapStats(stats) {
      return new Map(Object.keys(stats).map(function (key) {
        return [key, stats[key]];
      }));
    };

    if (arguments.length >= 2) {
      var successCallbackWrapper_ = function successCallbackWrapper_(response) {
        onSucc(makeMapStats(fixChromeStats_(response)));
      };

      return origGetStats.apply(this, [successCallbackWrapper_, selector]);
    }

    // promise-support
    return new Promise(function (resolve, reject) {
      origGetStats.apply(_this5, [function (response) {
        resolve(makeMapStats(fixChromeStats_(response)));
      }, reject]);
    }).then(onSucc, onErr);
  };
}

function shimSenderReceiverGetStats(window) {
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {
    return;
  }

  // shim sender stats.
  if (!('getStats' in window.RTCRtpSender.prototype)) {
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        var _this6 = this;

        var senders = origGetSenders.apply(this, []);
        senders.forEach(function (sender) {
          return sender._pc = _this6;
        });
        return senders;
      };
    }

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function addTrack() {
        var sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function getStats() {
      var sender = this;
      return this._pc.getStats().then(function (result) {
        return (
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          utils.filterStats(result, sender.track, true)
        );
      });
    };
  }

  // shim receiver stats.
  if (!('getStats' in window.RTCRtpReceiver.prototype)) {
    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        var _this7 = this;

        var receivers = origGetReceivers.apply(this, []);
        receivers.forEach(function (receiver) {
          return receiver._pc = _this7;
        });
        return receivers;
      };
    }
    utils.wrapPeerConnectionEvent(window, 'track', function (e) {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function getStats() {
      var receiver = this;
      return this._pc.getStats().then(function (result) {
        return utils.filterStats(result, receiver.track, false);
      });
    };
  }

  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {
    return;
  }

  // shim RTCPeerConnection.getStats(track).
  var origGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
      var track = arguments[0];
      var sender = void 0;
      var receiver = void 0;
      var err = void 0;
      this.getSenders().forEach(function (s) {
        if (s.track === track) {
          if (sender) {
            err = true;
          } else {
            sender = s;
          }
        }
      });
      this.getReceivers().forEach(function (r) {
        if (r.track === track) {
          if (receiver) {
            err = true;
          } else {
            receiver = r;
          }
        }
        return r.track === track;
      });
      if (err || sender && receiver) {
        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));
      } else if (sender) {
        return sender.getStats();
      } else if (receiver) {
        return receiver.getStats();
      }
      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));
    }
    return origGetStats.apply(this, arguments);
  };
}

function shimAddTrackRemoveTrackWithNative(window) {
  // shim addTrack/removeTrack with native variants in order to make
  // the interactions with legacy getLocalStreams behave as in other browsers.
  // Keeps a mapping stream.id => [stream, rtpsenders...]
  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    var _this8 = this;

    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    return Object.keys(this._shimmedLocalStreams).map(function (streamId) {
      return _this8._shimmedLocalStreams[streamId][0];
    });
  };

  var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    if (!stream) {
      return origAddTrack.apply(this, arguments);
    }
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};

    var sender = origAddTrack.apply(this, arguments);
    if (!this._shimmedLocalStreams[stream.id]) {
      this._shimmedLocalStreams[stream.id] = [stream, sender];
    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
      this._shimmedLocalStreams[stream.id].push(sender);
    }
    return sender;
  };

  var origAddStream = window.RTCPeerConnection.prototype.addStream;
  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    var _this9 = this;

    this._shimmedLocalStreams = this._shimmedLocalStreams || {};

    stream.getTracks().forEach(function (track) {
      var alreadyExists = _this9.getSenders().find(function (s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.', 'InvalidAccessError');
      }
    });
    var existingSenders = this.getSenders();
    origAddStream.apply(this, arguments);
    var newSenders = this.getSenders().filter(function (newSender) {
      return existingSenders.indexOf(newSender) === -1;
    });
    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
  };

  var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    delete this._shimmedLocalStreams[stream.id];
    return origRemoveStream.apply(this, arguments);
  };

  var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    var _this10 = this;

    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    if (sender) {
      Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {
        var idx = _this10._shimmedLocalStreams[streamId].indexOf(sender);
        if (idx !== -1) {
          _this10._shimmedLocalStreams[streamId].splice(idx, 1);
        }
        if (_this10._shimmedLocalStreams[streamId].length === 1) {
          delete _this10._shimmedLocalStreams[streamId];
        }
      });
    }
    return origRemoveTrack.apply(this, arguments);
  };
}

function shimAddTrackRemoveTrack(window) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var browserDetails = utils.detectBrowser(window);
  // shim addTrack and removeTrack.
  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
    return shimAddTrackRemoveTrackWithNative(window);
  }

  // also shim pc.getLocalStreams when addTrack is shimmed
  // to return the original streams.
  var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;
  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    var _this11 = this;

    var nativeStreams = origGetLocalStreams.apply(this);
    this._reverseStreams = this._reverseStreams || {};
    return nativeStreams.map(function (stream) {
      return _this11._reverseStreams[stream.id];
    });
  };

  var origAddStream = window.RTCPeerConnection.prototype.addStream;
  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    var _this12 = this;

    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};

    stream.getTracks().forEach(function (track) {
      var alreadyExists = _this12.getSenders().find(function (s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.', 'InvalidAccessError');
      }
    });
    // Add identity mapping for consistency with addTrack.
    // Unless this is being used with a stream from addTrack.
    if (!this._reverseStreams[stream.id]) {
      var newStream = new window.MediaStream(stream.getTracks());
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      stream = newStream;
    }
    origAddStream.apply(this, [stream]);
  };

  var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};

    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
    delete this._streams[stream.id];
  };

  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    var _this13 = this;

    if (this.signalingState === 'closed') {
      throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
    }
    var streams = [].slice.call(arguments, 1);
    if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {
      return t === track;
    })) {
      // this is not fully correct but all we can manage without
      // [[associated MediaStreams]] internal slot.
      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
    }

    var alreadyExists = this.getSenders().find(function (s) {
      return s.track === track;
    });
    if (alreadyExists) {
      throw new DOMException('Track already exists.', 'InvalidAccessError');
    }

    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    var oldStream = this._streams[stream.id];
    if (oldStream) {
      // this is using odd Chrome behaviour, use with caution:
      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
      // Note: we rely on the high-level addTrack/dtmf shim to
      // create the sender with a dtmf sender.
      oldStream.addTrack(track);

      // Trigger ONN async.
      Promise.resolve().then(function () {
        _this13.dispatchEvent(new Event('negotiationneeded'));
      });
    } else {
      var newStream = new window.MediaStream([track]);
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      this.addStream(newStream);
    }
    return this.getSenders().find(function (s) {
      return s.track === track;
    });
  };

  // replace the internal stream id with the external one and
  // vice versa.
  function replaceInternalStreamId(pc, description) {
    var sdp = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
      var externalStream = pc._reverseStreams[internalId];
      var internalStream = pc._streams[externalStream.id];
      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp
    });
  }
  function replaceExternalStreamId(pc, description) {
    var sdp = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
      var externalStream = pc._reverseStreams[internalId];
      var internalStream = pc._streams[externalStream.id];
      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp
    });
  }
  ['createOffer', 'createAnswer'].forEach(function (method) {
    var nativeMethod = window.RTCPeerConnection.prototype[method];
    var methodObj = _defineProperty({}, method, function () {
      var _this14 = this;

      var args = arguments;
      var isLegacyCall = arguments.length && typeof arguments[0] === 'function';
      if (isLegacyCall) {
        return nativeMethod.apply(this, [function (description) {
          var desc = replaceInternalStreamId(_this14, description);
          args[0].apply(null, [desc]);
        }, function (err) {
          if (args[1]) {
            args[1].apply(null, err);
          }
        }, arguments[2]]);
      }
      return nativeMethod.apply(this, arguments).then(function (description) {
        return replaceInternalStreamId(_this14, description);
      });
    });
    window.RTCPeerConnection.prototype[method] = methodObj[method];
  });

  var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    if (!arguments.length || !arguments[0].type) {
      return origSetLocalDescription.apply(this, arguments);
    }
    arguments[0] = replaceExternalStreamId(this, arguments[0]);
    return origSetLocalDescription.apply(this, arguments);
  };

  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

  var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');
  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
    get: function get() {
      var description = origLocalDescription.get.apply(this);
      if (description.type === '') {
        return description;
      }
      return replaceInternalStreamId(this, description);
    }
  });

  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    var _this15 = this;

    if (this.signalingState === 'closed') {
      throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
    }
    // We can not yet check for sender instanceof RTCRtpSender
    // since we shim RTPSender. So we check if sender._pc is set.
    if (!sender._pc) {
      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
    }
    var isLocal = sender._pc === this;
    if (!isLocal) {
      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
    }

    // Search for the native stream the senders track belongs to.
    this._streams = this._streams || {};
    var stream = void 0;
    Object.keys(this._streams).forEach(function (streamid) {
      var hasTrack = _this15._streams[streamid].getTracks().find(function (track) {
        return sender.track === track;
      });
      if (hasTrack) {
        stream = _this15._streams[streamid];
      }
    });

    if (stream) {
      if (stream.getTracks().length === 1) {
        // if this is the last track of the stream, remove the stream. This
        // takes care of any shimmed _senders.
        this.removeStream(this._reverseStreams[stream.id]);
      } else {
        // relying on the same odd chrome behaviour as above.
        stream.removeTrack(sender.track);
      }
      this.dispatchEvent(new Event('negotiationneeded'));
    }
  };
}

function shimPeerConnection(window) {
  var browserDetails = utils.detectBrowser(window);

  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
    // very basic support for old versions.
    window.RTCPeerConnection = window.webkitRTCPeerConnection;
  }
  if (!window.RTCPeerConnection) {
    return;
  }

  var addIceCandidateNullSupported = window.RTCPeerConnection.prototype.addIceCandidate.length === 0;

  // shim implicit creation of RTCSessionDescription/RTCIceCandidate
  if (browserDetails.version < 53) {
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      var methodObj = _defineProperty({}, method, function () {
        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      });
      window.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }

  // support for addIceCandidate(null or undefined)
  var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
    if (!addIceCandidateNullSupported && !arguments[0]) {
      if (arguments[1]) {
        arguments[1].apply(null);
      }
      return Promise.resolve();
    }
    // Firefox 68+ emits and processes {candidate: "", ...}, ignore
    // in older versions. Native support planned for Chrome M77.
    if (browserDetails.version < 78 && arguments[0] && arguments[0].candidate === '') {
      return Promise.resolve();
    }
    return nativeAddIceCandidate.apply(this, arguments);
  };
}

// Attempt to fix ONN in plan-b mode.
function fixNegotiationNeeded(window) {
  var browserDetails = utils.detectBrowser(window);
  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function (e) {
    var pc = e.target;
    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {
      if (pc.signalingState !== 'stable') {
        return;
      }
    }
    return e;
  });
}

},{"../utils.js":15,"./getdisplaymedia":4,"./getusermedia":5}],4:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = shimGetDisplayMedia;
function shimGetDisplayMedia(window, getSourceId) {
  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  if (!window.navigator.mediaDevices) {
    return;
  }
  // getSourceId is a function that returns a promise resolving with
  // the sourceId of the screen/window/tab to be shared.
  if (typeof getSourceId !== 'function') {
    console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    return getSourceId(constraints).then(function (sourceId) {
      var widthSpecified = constraints.video && constraints.video.width;
      var heightSpecified = constraints.video && constraints.video.height;
      var frameRateSpecified = constraints.video && constraints.video.frameRate;
      constraints.video = {
        mandatory: {
          chromeMediaSource: 'desktop',
          chromeMediaSourceId: sourceId,
          maxFrameRate: frameRateSpecified || 3
        }
      };
      if (widthSpecified) {
        constraints.video.mandatory.maxWidth = widthSpecified;
      }
      if (heightSpecified) {
        constraints.video.mandatory.maxHeight = heightSpecified;
      }
      return window.navigator.mediaDevices.getUserMedia(constraints);
    });
  };
}

},{}],5:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimGetUserMedia = shimGetUserMedia;

var _utils = require('../utils.js');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var logging = utils.log;

function shimGetUserMedia(window) {
  var navigator = window && window.navigator;

  if (!navigator.mediaDevices) {
    return;
  }

  var browserDetails = utils.detectBrowser(window);

  var constraintsToChrome_ = function constraintsToChrome_(c) {
    if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function (key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = _typeof(c[key]) === 'object' ? c[key] : { ideal: c[key] };
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function oldname_(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return name === 'deviceId' ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function (mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function shimConstraints_(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && _typeof(constraints.audio) === 'object') {
      var remap = function remap(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && _typeof(constraints.video) === 'object') {
      // Shim facingMode for mobile & surface pro.
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'undefined' ? 'undefined' : _typeof(face)) === 'object' ? face : { ideal: face });
      var getSupportedFacingModeLies = browserDetails.version < 66;

      if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        var matches = void 0;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          matches = ['back', 'rear'];
        } else if (face.exact === 'user' || face.ideal === 'user') {
          matches = ['front'];
        }
        if (matches) {
          // Look for matches in label, or use last cam for back (typical).
          return navigator.mediaDevices.enumerateDevices().then(function (devices) {
            devices = devices.filter(function (d) {
              return d.kind === 'videoinput';
            });
            var dev = devices.find(function (d) {
              return matches.some(function (match) {
                return d.label.toLowerCase().includes(match);
              });
            });
            if (!dev && devices.length && matches.includes('back')) {
              dev = devices[devices.length - 1]; // more likely the back cam
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function shimError_(e) {
    if (browserDetails.version >= 64) {
      return e;
    }
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        PermissionDismissedError: 'NotAllowedError',
        InvalidStateError: 'NotAllowedError',
        DevicesNotFoundError: 'NotFoundError',
        ConstraintNotSatisfiedError: 'OverconstrainedError',
        TrackStartError: 'NotReadableError',
        MediaDeviceFailedDueToShutdown: 'NotAllowedError',
        MediaDeviceKillSwitchOn: 'NotAllowedError',
        TabCaptureError: 'AbortError',
        ScreenCaptureError: 'AbortError',
        DeviceCaptureError: 'AbortError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint || e.constraintName,
      toString: function toString() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function (c) {
      navigator.webkitGetUserMedia(c, onSuccess, function (e) {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };
  navigator.getUserMedia = getUserMedia_.bind(navigator);

  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
  // function which returns a Promise, it does not accept spec-style
  // constraints.
  if (navigator.mediaDevices.getUserMedia) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function (cs) {
      return shimConstraints_(cs, function (c) {
        return origGetUserMedia(c).then(function (stream) {
          if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function (track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function (e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }
}

},{"../utils.js":15}],6:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimRTCIceCandidate = shimRTCIceCandidate;
exports.shimMaxMessageSize = shimMaxMessageSize;
exports.shimSendThrowTypeError = shimSendThrowTypeError;
exports.shimConnectionState = shimConnectionState;
exports.removeAllowExtmapMixed = removeAllowExtmapMixed;

var _sdp = require('sdp');

var _sdp2 = _interopRequireDefault(_sdp);

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function shimRTCIceCandidate(window) {
  // foundation is arbitrarily chosen as an indicator for full support for
  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
    return;
  }

  var NativeRTCIceCandidate = window.RTCIceCandidate;
  window.RTCIceCandidate = function RTCIceCandidate(args) {
    // Remove the a= which shouldn't be part of the candidate string.
    if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
      args = JSON.parse(JSON.stringify(args));
      args.candidate = args.candidate.substr(2);
    }

    if (args.candidate && args.candidate.length) {
      // Augment the native candidate with the parsed fields.
      var nativeCandidate = new NativeRTCIceCandidate(args);
      var parsedCandidate = _sdp2.default.parseCandidate(args.candidate);
      var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);

      // Add a serializer that does not serialize the extra attributes.
      augmentedCandidate.toJSON = function toJSON() {
        return {
          candidate: augmentedCandidate.candidate,
          sdpMid: augmentedCandidate.sdpMid,
          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
          usernameFragment: augmentedCandidate.usernameFragment
        };
      };
      return augmentedCandidate;
    }
    return new NativeRTCIceCandidate(args);
  };
  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

  // Hook up the augmented candidate in onicecandidate and
  // addEventListener('icecandidate', ...)
  utils.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {
    if (e.candidate) {
      Object.defineProperty(e, 'candidate', {
        value: new window.RTCIceCandidate(e.candidate),
        writable: 'false'
      });
    }
    return e;
  });
}

function shimMaxMessageSize(window) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var browserDetails = utils.detectBrowser(window);

  if (!('sctp' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
      get: function get() {
        return typeof this._sctp === 'undefined' ? null : this._sctp;
      }
    });
  }

  var sctpInDescription = function sctpInDescription(description) {
    if (!description || !description.sdp) {
      return false;
    }
    var sections = _sdp2.default.splitSections(description.sdp);
    sections.shift();
    return sections.some(function (mediaSection) {
      var mLine = _sdp2.default.parseMLine(mediaSection);
      return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
    });
  };

  var getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {
    // TODO: Is there a better solution for detecting Firefox?
    var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (match === null || match.length < 2) {
      return -1;
    }
    var version = parseInt(match[1], 10);
    // Test for NaN (yes, this is ugly)
    return version !== version ? -1 : version;
  };

  var getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {
    // Every implementation we know can send at least 64 KiB.
    // Note: Although Chrome is technically able to send up to 256 KiB, the
    //       data does not reach the other peer reliably.
    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
    var canSendMaxMessageSize = 65536;
    if (browserDetails.browser === 'firefox') {
      if (browserDetails.version < 57) {
        if (remoteIsFirefox === -1) {
          // FF < 57 will send in 16 KiB chunks using the deprecated PPID
          // fragmentation.
          canSendMaxMessageSize = 16384;
        } else {
          // However, other FF (and RAWRTC) can reassemble PPID-fragmented
          // messages. Thus, supporting ~2 GiB when sending.
          canSendMaxMessageSize = 2147483637;
        }
      } else if (browserDetails.version < 60) {
        // Currently, all FF >= 57 will reset the remote maximum message size
        // to the default value when a data channel is created at a later
        // stage. :(
        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
      } else {
        // FF >= 60 supports sending ~2 GiB
        canSendMaxMessageSize = 2147483637;
      }
    }
    return canSendMaxMessageSize;
  };

  var getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {
    // Note: 65536 bytes is the default value from the SDP spec. Also,
    //       every implementation we know supports receiving 65536 bytes.
    var maxMessageSize = 65536;

    // FF 57 has a slightly incorrect default remote max message size, so
    // we need to adjust it here to avoid a failure when sending.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
    if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
      maxMessageSize = 65535;
    }

    var match = _sdp2.default.matchPrefix(description.sdp, 'a=max-message-size:');
    if (match.length > 0) {
      maxMessageSize = parseInt(match[0].substr(19), 10);
    } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
      // If the maximum message size is not present in the remote SDP and
      // both local and remote are Firefox, the remote peer can receive
      // ~2 GiB.
      maxMessageSize = 2147483637;
    }
    return maxMessageSize;
  };

  var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
    this._sctp = null;
    // Chrome decided to not expose .sctp in plan-b mode.
    // As usual, adapter.js has to do an 'ugly worakaround'
    // to cover up the mess.
    if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
      var _getConfiguration = this.getConfiguration(),
          sdpSemantics = _getConfiguration.sdpSemantics;

      if (sdpSemantics === 'plan-b') {
        Object.defineProperty(this, 'sctp', {
          get: function get() {
            return typeof this._sctp === 'undefined' ? null : this._sctp;
          },

          enumerable: true,
          configurable: true
        });
      }
    }

    if (sctpInDescription(arguments[0])) {
      // Check if the remote is FF.
      var isFirefox = getRemoteFirefoxVersion(arguments[0]);

      // Get the maximum message size the local peer is capable of sending
      var canSendMMS = getCanSendMaxMessageSize(isFirefox);

      // Get the maximum message size of the remote peer.
      var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

      // Determine final maximum message size
      var maxMessageSize = void 0;
      if (canSendMMS === 0 && remoteMMS === 0) {
        maxMessageSize = Number.POSITIVE_INFINITY;
      } else if (canSendMMS === 0 || remoteMMS === 0) {
        maxMessageSize = Math.max(canSendMMS, remoteMMS);
      } else {
        maxMessageSize = Math.min(canSendMMS, remoteMMS);
      }

      // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
      // attribute.
      var sctp = {};
      Object.defineProperty(sctp, 'maxMessageSize', {
        get: function get() {
          return maxMessageSize;
        }
      });
      this._sctp = sctp;
    }

    return origSetRemoteDescription.apply(this, arguments);
  };
}

function shimSendThrowTypeError(window) {
  if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
    return;
  }

  // Note: Although Firefox >= 57 has a native implementation, the maximum
  //       message size can be reset for all data channels at a later stage.
  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

  function wrapDcSend(dc, pc) {
    var origDataChannelSend = dc.send;
    dc.send = function send() {
      var data = arguments[0];
      var length = data.length || data.size || data.byteLength;
      if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
        throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');
      }
      return origDataChannelSend.apply(dc, arguments);
    };
  }
  var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;
  window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
    var dataChannel = origCreateDataChannel.apply(this, arguments);
    wrapDcSend(dataChannel, this);
    return dataChannel;
  };
  utils.wrapPeerConnectionEvent(window, 'datachannel', function (e) {
    wrapDcSend(e.channel, e.target);
    return e;
  });
}

/* shims RTCConnectionState by pretending it is the same as iceConnectionState.
 * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
 * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
 * since DTLS failures would be hidden. See
 * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
 * for the Firefox tracking bug.
 */
function shimConnectionState(window) {
  if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  Object.defineProperty(proto, 'connectionState', {
    get: function get() {
      return {
        completed: 'connected',
        checking: 'connecting'
      }[this.iceConnectionState] || this.iceConnectionState;
    },

    enumerable: true,
    configurable: true
  });
  Object.defineProperty(proto, 'onconnectionstatechange', {
    get: function get() {
      return this._onconnectionstatechange || null;
    },
    set: function set(cb) {
      if (this._onconnectionstatechange) {
        this.removeEventListener('connectionstatechange', this._onconnectionstatechange);
        delete this._onconnectionstatechange;
      }
      if (cb) {
        this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);
      }
    },

    enumerable: true,
    configurable: true
  });

  ['setLocalDescription', 'setRemoteDescription'].forEach(function (method) {
    var origMethod = proto[method];
    proto[method] = function () {
      if (!this._connectionstatechangepoly) {
        this._connectionstatechangepoly = function (e) {
          var pc = e.target;
          if (pc._lastConnectionState !== pc.connectionState) {
            pc._lastConnectionState = pc.connectionState;
            var newEvent = new Event('connectionstatechange', e);
            pc.dispatchEvent(newEvent);
          }
          return e;
        };
        this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);
      }
      return origMethod.apply(this, arguments);
    };
  });
}

function removeAllowExtmapMixed(window) {
  /* remove a=extmap-allow-mixed for Chrome < M71 */
  if (!window.RTCPeerConnection) {
    return;
  }
  var browserDetails = utils.detectBrowser(window);
  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
    return;
  }
  var nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
    if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
      desc.sdp = desc.sdp.split('\n').filter(function (line) {
        return line.trim() !== 'a=extmap-allow-mixed';
      }).join('\n');
    }
    return nativeSRD.apply(this, arguments);
  };
}

},{"./utils":15,"sdp":17}],7:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

var _getusermedia = require('./getusermedia');

Object.defineProperty(exports, 'shimGetUserMedia', {
  enumerable: true,
  get: function get() {
    return _getusermedia.shimGetUserMedia;
  }
});

var _getdisplaymedia = require('./getdisplaymedia');

Object.defineProperty(exports, 'shimGetDisplayMedia', {
  enumerable: true,
  get: function get() {
    return _getdisplaymedia.shimGetDisplayMedia;
  }
});
exports.shimPeerConnection = shimPeerConnection;
exports.shimReplaceTrack = shimReplaceTrack;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _filtericeservers = require('./filtericeservers');

var _rtcpeerconnectionShim = require('rtcpeerconnection-shim');

var _rtcpeerconnectionShim2 = _interopRequireDefault(_rtcpeerconnectionShim);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function shimPeerConnection(window) {
  var browserDetails = utils.detectBrowser(window);

  if (window.RTCIceGatherer) {
    if (!window.RTCIceCandidate) {
      window.RTCIceCandidate = function RTCIceCandidate(args) {
        return args;
      };
    }
    if (!window.RTCSessionDescription) {
      window.RTCSessionDescription = function RTCSessionDescription(args) {
        return args;
      };
    }
    // this adds an additional event listener to MediaStrackTrack that signals
    // when a tracks enabled property was changed. Workaround for a bug in
    // addStream, see below. No longer required in 15025+
    if (browserDetails.version < 15025) {
      var origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, 'enabled');
      Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
        set: function set(value) {
          origMSTEnabled.set.call(this, value);
          var ev = new Event('enabled');
          ev.enabled = value;
          this.dispatchEvent(ev);
        }
      });
    }
  }

  // ORTC defines the DTMF sender a bit different.
  // https://github.com/w3c/ortc/issues/714
  if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
      get: function get() {
        if (this._dtmf === undefined) {
          if (this.track.kind === 'audio') {
            this._dtmf = new window.RTCDtmfSender(this);
          } else if (this.track.kind === 'video') {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
  // Edge currently only implements the RTCDtmfSender, not the
  // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
  if (window.RTCDtmfSender && !window.RTCDTMFSender) {
    window.RTCDTMFSender = window.RTCDtmfSender;
  }

  var RTCPeerConnectionShim = (0, _rtcpeerconnectionShim2.default)(window, browserDetails.version);
  window.RTCPeerConnection = function RTCPeerConnection(config) {
    if (config && config.iceServers) {
      config.iceServers = (0, _filtericeservers.filterIceServers)(config.iceServers, browserDetails.version);
      utils.log('ICE servers after filtering:', config.iceServers);
    }
    return new RTCPeerConnectionShim(config);
  };
  window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
}

function shimReplaceTrack(window) {
  // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
  if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {
    window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;
  }
}

},{"../utils":15,"./filtericeservers":8,"./getdisplaymedia":9,"./getusermedia":10,"rtcpeerconnection-shim":16}],8:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filterIceServers = filterIceServers;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function (server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function (url) {
        // filter STUN unconditionally.
        if (url.indexOf('stun:') === 0) {
          return false;
        }

        var validTurn = url.startsWith('turn') && !url.startsWith('turn:[') && url.includes('transport=udp');
        if (validTurn && !hasTurn) {
          hasTurn = true;
          return true;
        }
        return validTurn && !hasTurn;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
}

},{"../utils":15}],9:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = shimGetDisplayMedia;
function shimGetDisplayMedia(window) {
  if (!('getDisplayMedia' in window.navigator)) {
    return;
  }
  if (!window.navigator.mediaDevices) {
    return;
  }
  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia = window.navigator.getDisplayMedia.bind(window.navigator);
}

},{}],10:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetUserMedia = shimGetUserMedia;
function shimGetUserMedia(window) {
  var navigator = window && window.navigator;

  var shimError_ = function shimError_(e) {
    return {
      name: { PermissionDeniedError: 'NotAllowedError' }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function toString() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function (c) {
    return origGetUserMedia(c).catch(function (e) {
      return Promise.reject(shimError_(e));
    });
  };
}

},{}],11:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _getusermedia = require('./getusermedia');

Object.defineProperty(exports, 'shimGetUserMedia', {
  enumerable: true,
  get: function get() {
    return _getusermedia.shimGetUserMedia;
  }
});

var _getdisplaymedia = require('./getdisplaymedia');

Object.defineProperty(exports, 'shimGetDisplayMedia', {
  enumerable: true,
  get: function get() {
    return _getdisplaymedia.shimGetDisplayMedia;
  }
});
exports.shimOnTrack = shimOnTrack;
exports.shimPeerConnection = shimPeerConnection;
exports.shimSenderGetStats = shimSenderGetStats;
exports.shimReceiverGetStats = shimReceiverGetStats;
exports.shimRemoveStream = shimRemoveStream;
exports.shimRTCDataChannel = shimRTCDataChannel;
exports.shimAddTransceiver = shimAddTransceiver;
exports.shimCreateOffer = shimCreateOffer;
exports.shimCreateAnswer = shimCreateAnswer;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function shimOnTrack(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
      get: function get() {
        return { receiver: this.receiver };
      }
    });
  }
}

function shimPeerConnection(window) {
  var browserDetails = utils.detectBrowser(window);

  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
    return; // probably media.peerconnection.enabled=false in about:config
  }
  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
    // very basic support for old versions.
    window.RTCPeerConnection = window.mozRTCPeerConnection;
  }

  if (browserDetails.version < 53) {
    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      var methodObj = _defineProperty({}, method, function () {
        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      });
      window.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }

  // support for addIceCandidate(null or undefined)
  // as well as ignoring {sdpMid, candidate: ""}
  if (browserDetails.version < 68) {
    var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      // Firefox 68+ emits and processes {candidate: "", ...}, ignore
      // in older versions.
      if (arguments[0] && arguments[0].candidate === '') {
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }

  var modernStatsTypes = {
    inboundrtp: 'inbound-rtp',
    outboundrtp: 'outbound-rtp',
    candidatepair: 'candidate-pair',
    localcandidate: 'local-candidate',
    remotecandidate: 'remote-candidate'
  };

  var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    var _arguments = Array.prototype.slice.call(arguments),
        selector = _arguments[0],
        onSucc = _arguments[1],
        onErr = _arguments[2];

    return nativeGetStats.apply(this, [selector || null]).then(function (stats) {
      if (browserDetails.version < 53 && !onSucc) {
        // Shim only promise getStats with spec-hyphens in type names
        // Leave callback version alone; misc old uses of forEach before Map
        try {
          stats.forEach(function (stat) {
            stat.type = modernStatsTypes[stat.type] || stat.type;
          });
        } catch (e) {
          if (e.name !== 'TypeError') {
            throw e;
          }
          // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
          stats.forEach(function (stat, i) {
            stats.set(i, Object.assign({}, stat, {
              type: modernStatsTypes[stat.type] || stat.type
            }));
          });
        }
      }
      return stats;
    }).then(onSucc, onErr);
  };
}

function shimSenderGetStats(window) {
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
    return;
  }
  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
    return;
  }
  var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
  if (origGetSenders) {
    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
      var _this = this;

      var senders = origGetSenders.apply(this, []);
      senders.forEach(function (sender) {
        return sender._pc = _this;
      });
      return senders;
    };
  }

  var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
  if (origAddTrack) {
    window.RTCPeerConnection.prototype.addTrack = function addTrack() {
      var sender = origAddTrack.apply(this, arguments);
      sender._pc = this;
      return sender;
    };
  }
  window.RTCRtpSender.prototype.getStats = function getStats() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
  };
}

function shimReceiverGetStats(window) {
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
    return;
  }
  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
    return;
  }
  var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
  if (origGetReceivers) {
    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
      var _this2 = this;

      var receivers = origGetReceivers.apply(this, []);
      receivers.forEach(function (receiver) {
        return receiver._pc = _this2;
      });
      return receivers;
    };
  }
  utils.wrapPeerConnectionEvent(window, 'track', function (e) {
    e.receiver._pc = e.srcElement;
    return e;
  });
  window.RTCRtpReceiver.prototype.getStats = function getStats() {
    return this._pc.getStats(this.track);
  };
}

function shimRemoveStream(window) {
  if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
    return;
  }
  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    var _this3 = this;

    utils.deprecated('removeStream', 'removeTrack');
    this.getSenders().forEach(function (sender) {
      if (sender.track && stream.getTracks().includes(sender.track)) {
        _this3.removeTrack(sender);
      }
    });
  };
}

function shimRTCDataChannel(window) {
  // rename DataChannel to RTCDataChannel (native fix in FF60):
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
  if (window.DataChannel && !window.RTCDataChannel) {
    window.RTCDataChannel = window.DataChannel;
  }
}

function shimAddTransceiver(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
    return;
  }
  var origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;
  if (origAddTransceiver) {
    window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
      this.setParametersPromises = [];
      var initParameters = arguments[1];
      var shouldPerformCheck = initParameters && 'sendEncodings' in initParameters;
      if (shouldPerformCheck) {
        // If sendEncodings params are provided, validate grammar
        initParameters.sendEncodings.forEach(function (encodingParam) {
          if ('rid' in encodingParam) {
            var ridRegex = /^[a-z0-9]{0,16}$/i;
            if (!ridRegex.test(encodingParam.rid)) {
              throw new TypeError('Invalid RID value provided.');
            }
          }
          if ('scaleResolutionDownBy' in encodingParam) {
            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {
              throw new RangeError('scale_resolution_down_by must be >= 1.0');
            }
          }
          if ('maxFramerate' in encodingParam) {
            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
              throw new RangeError('max_framerate must be >= 0.0');
            }
          }
        });
      }
      var transceiver = origAddTransceiver.apply(this, arguments);
      if (shouldPerformCheck) {
        // Check if the init options were applied. If not we do this in an
        // asynchronous way and save the promise reference in a global object.
        // This is an ugly hack, but at the same time is way more robust than
        // checking the sender parameters before and after the createOffer
        // Also note that after the createoffer we are not 100% sure that
        // the params were asynchronously applied so we might miss the
        // opportunity to recreate offer.
        var sender = transceiver.sender;

        var params = sender.getParameters();
        if (!('encodings' in params)) {
          params.encodings = initParameters.sendEncodings;
          this.setParametersPromises.push(sender.setParameters(params).catch(function () {}));
        }
      }
      return transceiver;
    };
  }
}

function shimCreateOffer(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
    return;
  }
  var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
  window.RTCPeerConnection.prototype.createOffer = function createOffer() {
    var _this4 = this,
        _arguments2 = arguments;

    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(function () {
        return origCreateOffer.apply(_this4, _arguments2);
      }).finally(function () {
        _this4.setParametersPromises = [];
      });
    }
    return origCreateOffer.apply(this, arguments);
  };
}

function shimCreateAnswer(window) {
  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
  // Firefox ignores the init sendEncodings options passed to addTransceiver
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
    return;
  }
  var origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;
  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
    var _this5 = this,
        _arguments3 = arguments;

    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(function () {
        return origCreateAnswer.apply(_this5, _arguments3);
      }).finally(function () {
        _this5.setParametersPromises = [];
      });
    }
    return origCreateAnswer.apply(this, arguments);
  };
}

},{"../utils":15,"./getdisplaymedia":12,"./getusermedia":13}],12:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = shimGetDisplayMedia;
function shimGetDisplayMedia(window, preferredMediaSource) {
  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  if (!window.navigator.mediaDevices) {
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    if (!(constraints && constraints.video)) {
      var err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');
      err.name = 'NotFoundError';
      // from https://heycam.github.io/webidl/#idl-DOMException-error-names
      err.code = 8;
      return Promise.reject(err);
    }
    if (constraints.video === true) {
      constraints.video = { mediaSource: preferredMediaSource };
    } else {
      constraints.video.mediaSource = preferredMediaSource;
    }
    return window.navigator.mediaDevices.getUserMedia(constraints);
  };
}

},{}],13:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimGetUserMedia = shimGetUserMedia;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function shimGetUserMedia(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;
  var MediaStreamTrack = window && window.MediaStreamTrack;

  navigator.getUserMedia = function (constraints, onSuccess, onError) {
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };

  if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
    var remap = function remap(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };

    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function (c) {
      if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object' && _typeof(c.audio) === 'object') {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
      }
      return nativeGetUserMedia(c);
    };

    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function () {
        var obj = nativeGetSettings.apply(this, arguments);
        remap(obj, 'mozAutoGainControl', 'autoGainControl');
        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
        return obj;
      };
    }

    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function (c) {
        if (this.kind === 'audio' && (typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c, 'autoGainControl', 'mozAutoGainControl');
          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
}

},{"../utils":15}],14:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimLocalStreamsAPI = shimLocalStreamsAPI;
exports.shimRemoteStreamsAPI = shimRemoteStreamsAPI;
exports.shimCallbacksAPI = shimCallbacksAPI;
exports.shimGetUserMedia = shimGetUserMedia;
exports.shimConstraints = shimConstraints;
exports.shimRTCIceServerUrls = shimRTCIceServerUrls;
exports.shimTrackEventTransceiver = shimTrackEventTransceiver;
exports.shimCreateOfferLegacy = shimCreateOfferLegacy;
exports.shimAudioContext = shimAudioContext;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function shimLocalStreamsAPI(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      return this._localStreams;
    };
  }
  if (!('addStream' in window.RTCPeerConnection.prototype)) {
    var _addTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      var _this = this;

      if (!this._localStreams) {
        this._localStreams = [];
      }
      if (!this._localStreams.includes(stream)) {
        this._localStreams.push(stream);
      }
      // Try to emulate Chrome's behaviour of adding in audio-video order.
      // Safari orders by track id.
      stream.getAudioTracks().forEach(function (track) {
        return _addTrack.call(_this, track, stream);
      });
      stream.getVideoTracks().forEach(function (track) {
        return _addTrack.call(_this, track, stream);
      });
    };

    window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
      var _this2 = this;

      for (var _len = arguments.length, streams = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        streams[_key - 1] = arguments[_key];
      }

      if (streams) {
        streams.forEach(function (stream) {
          if (!_this2._localStreams) {
            _this2._localStreams = [stream];
          } else if (!_this2._localStreams.includes(stream)) {
            _this2._localStreams.push(stream);
          }
        });
      }
      return _addTrack.apply(this, arguments);
    };
  }
  if (!('removeStream' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      var _this3 = this;

      if (!this._localStreams) {
        this._localStreams = [];
      }
      var index = this._localStreams.indexOf(stream);
      if (index === -1) {
        return;
      }
      this._localStreams.splice(index, 1);
      var tracks = stream.getTracks();
      this.getSenders().forEach(function (sender) {
        if (tracks.includes(sender.track)) {
          _this3.removeTrack(sender);
        }
      });
    };
  }
}

function shimRemoteStreamsAPI(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
      return this._remoteStreams ? this._remoteStreams : [];
    };
  }
  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
      get: function get() {
        return this._onaddstream;
      },
      set: function set(f) {
        var _this4 = this;

        if (this._onaddstream) {
          this.removeEventListener('addstream', this._onaddstream);
          this.removeEventListener('track', this._onaddstreampoly);
        }
        this.addEventListener('addstream', this._onaddstream = f);
        this.addEventListener('track', this._onaddstreampoly = function (e) {
          e.streams.forEach(function (stream) {
            if (!_this4._remoteStreams) {
              _this4._remoteStreams = [];
            }
            if (_this4._remoteStreams.includes(stream)) {
              return;
            }
            _this4._remoteStreams.push(stream);
            var event = new Event('addstream');
            event.stream = stream;
            _this4.dispatchEvent(event);
          });
        });
      }
    });
    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      var pc = this;
      if (!this._onaddstreampoly) {
        this.addEventListener('track', this._onaddstreampoly = function (e) {
          e.streams.forEach(function (stream) {
            if (!pc._remoteStreams) {
              pc._remoteStreams = [];
            }
            if (pc._remoteStreams.indexOf(stream) >= 0) {
              return;
            }
            pc._remoteStreams.push(stream);
            var event = new Event('addstream');
            event.stream = stream;
            pc.dispatchEvent(event);
          });
        });
      }
      return origSetRemoteDescription.apply(pc, arguments);
    };
  }
}

function shimCallbacksAPI(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  var prototype = window.RTCPeerConnection.prototype;
  var origCreateOffer = prototype.createOffer;
  var origCreateAnswer = prototype.createAnswer;
  var setLocalDescription = prototype.setLocalDescription;
  var setRemoteDescription = prototype.setRemoteDescription;
  var addIceCandidate = prototype.addIceCandidate;

  prototype.createOffer = function createOffer(successCallback, failureCallback) {
    var options = arguments.length >= 2 ? arguments[2] : arguments[0];
    var promise = origCreateOffer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };

  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
    var options = arguments.length >= 2 ? arguments[2] : arguments[0];
    var promise = origCreateAnswer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };

  var withCallback = function withCallback(description, successCallback, failureCallback) {
    var promise = setLocalDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setLocalDescription = withCallback;

  withCallback = function withCallback(description, successCallback, failureCallback) {
    var promise = setRemoteDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setRemoteDescription = withCallback;

  withCallback = function withCallback(candidate, successCallback, failureCallback) {
    var promise = addIceCandidate.apply(this, [candidate]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.addIceCandidate = withCallback;
}

function shimGetUserMedia(window) {
  var navigator = window && window.navigator;

  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    // shim not needed in Safari 12.1
    var mediaDevices = navigator.mediaDevices;
    var _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
    navigator.mediaDevices.getUserMedia = function (constraints) {
      return _getUserMedia(shimConstraints(constraints));
    };
  }

  if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
      navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
    }.bind(navigator);
  }
}

function shimConstraints(constraints) {
  if (constraints && constraints.video !== undefined) {
    return Object.assign({}, constraints, { video: utils.compactObject(constraints.video) });
  }

  return constraints;
}

function shimRTCIceServerUrls(window) {
  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
  var OrigPeerConnection = window.RTCPeerConnection;
  window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {
    if (pcConfig && pcConfig.iceServers) {
      var newIceServers = [];
      for (var i = 0; i < pcConfig.iceServers.length; i++) {
        var server = pcConfig.iceServers[i];
        if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
          utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
          server = JSON.parse(JSON.stringify(server));
          server.urls = server.url;
          delete server.url;
          newIceServers.push(server);
        } else {
          newIceServers.push(pcConfig.iceServers[i]);
        }
      }
      pcConfig.iceServers = newIceServers;
    }
    return new OrigPeerConnection(pcConfig, pcConstraints);
  };
  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
  // wrap static methods. Currently just generateCertificate.
  if ('generateCertificate' in window.RTCPeerConnection) {
    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
      get: function get() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }
}

function shimTrackEventTransceiver(window) {
  // Add event.transceiver member over deprecated event.receiver
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
      get: function get() {
        return { receiver: this.receiver };
      }
    });
  }
}

function shimCreateOfferLegacy(window) {
  var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
  window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
    if (offerOptions) {
      if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
        // support bit values
        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
      }
      var audioTransceiver = this.getTransceivers().find(function (transceiver) {
        return transceiver.receiver.track.kind === 'audio';
      });
      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
        if (audioTransceiver.direction === 'sendrecv') {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection('sendonly');
          } else {
            audioTransceiver.direction = 'sendonly';
          }
        } else if (audioTransceiver.direction === 'recvonly') {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection('inactive');
          } else {
            audioTransceiver.direction = 'inactive';
          }
        }
      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
        this.addTransceiver('audio');
      }

      if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
        // support bit values
        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
      }
      var videoTransceiver = this.getTransceivers().find(function (transceiver) {
        return transceiver.receiver.track.kind === 'video';
      });
      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
        if (videoTransceiver.direction === 'sendrecv') {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection('sendonly');
          } else {
            videoTransceiver.direction = 'sendonly';
          }
        } else if (videoTransceiver.direction === 'recvonly') {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection('inactive');
          } else {
            videoTransceiver.direction = 'inactive';
          }
        }
      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
        this.addTransceiver('video');
      }
    }
    return origCreateOffer.apply(this, arguments);
  };
}

function shimAudioContext(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || window.AudioContext) {
    return;
  }
  window.AudioContext = window.webkitAudioContext;
}

},{"../utils":15}],15:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.extractVersion = extractVersion;
exports.wrapPeerConnectionEvent = wrapPeerConnectionEvent;
exports.disableLog = disableLog;
exports.disableWarnings = disableWarnings;
exports.log = log;
exports.deprecated = deprecated;
exports.detectBrowser = detectBrowser;
exports.compactObject = compactObject;
exports.walkStats = walkStats;
exports.filterStats = filterStats;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var logDisabled_ = true;
var deprecationWarnings_ = true;

/**
 * Extract browser version out of the provided user agent string.
 *
 * @param {!string} uastring userAgent string.
 * @param {!string} expr Regular expression used as match criteria.
 * @param {!number} pos position in the version string to be returned.
 * @return {!number} browser version.
 */
function extractVersion(uastring, expr, pos) {
  var match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}

// Wraps the peerconnection event eventNameToWrap in a function
// which returns the modified event object (or false to prevent
// the event).
function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  var nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function (nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    var wrappedCallback = function wrappedCallback(e) {
      var modifiedEvent = wrapper(e);
      if (modifiedEvent) {
        cb(modifiedEvent);
      }
    };
    this._eventMap = this._eventMap || {};
    this._eventMap[cb] = wrappedCallback;
    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
  };

  var nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function (nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    var unwrappedCb = this._eventMap[cb];
    delete this._eventMap[cb];
    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
  };

  Object.defineProperty(proto, 'on' + eventNameToWrap, {
    get: function get() {
      return this['_on' + eventNameToWrap];
    },
    set: function set(cb) {
      if (this['_on' + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
        delete this['_on' + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);
      }
    },

    enumerable: true,
    configurable: true
  });
}

function disableLog(bool) {
  if (typeof bool !== 'boolean') {
    return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
  }
  logDisabled_ = bool;
  return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
}

/**
 * Disable or enable deprecation warnings
 * @param {!boolean} bool set to true to disable warnings.
 */
function disableWarnings(bool) {
  if (typeof bool !== 'boolean') {
    return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
  }
  deprecationWarnings_ = !bool;
  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
}

function log() {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {
    if (logDisabled_) {
      return;
    }
    if (typeof console !== 'undefined' && typeof console.log === 'function') {
      console.log.apply(console, arguments);
    }
  }
}

/**
 * Shows a deprecation warning suggesting the modern and spec-compatible API.
 */
function deprecated(oldMethod, newMethod) {
  if (!deprecationWarnings_) {
    return;
  }
  console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
}

/**
 * Browser detector.
 *
 * @return {object} result containing browser and version
 *     properties.
 */
function detectBrowser(window) {
  var navigator = window.navigator;

  // Returned result object.

  var result = { browser: null, version: null };

  // Fail early if it's not a browser
  if (typeof window === 'undefined' || !window.navigator) {
    result.browser = 'Not a browser.';
    return result;
  }

  if (navigator.mozGetUserMedia) {
    // Firefox.
    result.browser = 'firefox';
    result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
  } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {
    // Chrome, Chromium, Webview, Opera.
    // Version matches Chrome/WebRTC version.
    // Chrome 74 removed webkitGetUserMedia on http as well so we need the
    // more complicated fallback to webkitRTCPeerConnection.
    result.browser = 'chrome';
    result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
    // Edge.
    result.browser = 'edge';
    result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
  } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
    // Safari.
    result.browser = 'safari';
    result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
    result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;
  } else {
    // Default fallthrough: not supported.
    result.browser = 'Not a supported browser.';
    return result;
  }

  return result;
}

/**
 * Checks if something is an object.
 *
 * @param {*} val The something you want to check.
 * @return true if val is an object, false otherwise.
 */
function isObject(val) {
  return Object.prototype.toString.call(val) === '[object Object]';
}

/**
 * Remove all empty objects and undefined values
 * from a nested object -- an enhanced and vanilla version
 * of Lodash's `compact`.
 */
function compactObject(data) {
  if (!isObject(data)) {
    return data;
  }

  return Object.keys(data).reduce(function (accumulator, key) {
    var isObj = isObject(data[key]);
    var value = isObj ? compactObject(data[key]) : data[key];
    var isEmptyObject = isObj && !Object.keys(value).length;
    if (value === undefined || isEmptyObject) {
      return accumulator;
    }
    return Object.assign(accumulator, _defineProperty({}, key, value));
  }, {});
}

/* iterates the stats graph recursively. */
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach(function (name) {
    if (name.endsWith('Id')) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith('Ids')) {
      base[name].forEach(function (id) {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}

/* filter getStats for a sender/receiver track. */
function filterStats(result, track, outbound) {
  var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
  var filteredResult = new Map();
  if (track === null) {
    return filteredResult;
  }
  var trackStats = [];
  result.forEach(function (value) {
    if (value.type === 'track' && value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach(function (trackStat) {
    result.forEach(function (stats) {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}

},{}],16:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');

function fixStatsType(stat) {
  return {
    inboundrtp: 'inbound-rtp',
    outboundrtp: 'outbound-rtp',
    candidatepair: 'candidate-pair',
    localcandidate: 'local-candidate',
    remotecandidate: 'remote-candidate'
  }[stat.type] || stat.type;
}

function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : dtlsRole || 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    var trackId = transceiver.rtpSender._initialTrackId ||
        transceiver.rtpSender.track.id;
    transceiver.rtpSender._initialTrackId = trackId;
    // spec.
    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +
        trackId + '\r\n';
    sdp += 'a=' + msid;
    // for Chrome. Legacy should no longer be required.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;

    // RTX
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
}

// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        console.warn('RTCIceServer.url is deprecated! Use urls instead.');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
            url.indexOf('?transport=udp') === -1;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
}

// Determines the intersection of local and remote capabilities.
function getCommonCapabilities(localCapabilities, remoteCapabilities) {
  var commonCapabilities = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: []
  };

  var findCodecByPayloadType = function(pt, codecs) {
    pt = parseInt(pt, 10);
    for (var i = 0; i < codecs.length; i++) {
      if (codecs[i].payloadType === pt ||
          codecs[i].preferredPayloadType === pt) {
        return codecs[i];
      }
    }
  };

  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
    return lCodec && rCodec &&
        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
  };

  localCapabilities.codecs.forEach(function(lCodec) {
    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
      var rCodec = remoteCapabilities.codecs[i];
      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
          lCodec.clockRate === rCodec.clockRate) {
        if (lCodec.name.toLowerCase() === 'rtx' &&
            lCodec.parameters && rCodec.parameters.apt) {
          // for RTX we need to find the local rtx that has a apt
          // which points to the same local codec as the remote one.
          if (!rtxCapabilityMatches(lCodec, rCodec,
              localCapabilities.codecs, remoteCapabilities.codecs)) {
            continue;
          }
        }
        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
        // number of channels is the highest common number of channels
        rCodec.numChannels = Math.min(lCodec.numChannels,
            rCodec.numChannels);
        // push rCodec so we reply with offerer payload type
        commonCapabilities.codecs.push(rCodec);

        // determine common feedback mechanisms
        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
            if (lCodec.rtcpFeedback[j].type === fb.type &&
                lCodec.rtcpFeedback[j].parameter === fb.parameter) {
              return true;
            }
          }
          return false;
        });
        // FIXME: also need to determine .parameters
        //  see https://github.com/openpeer/ortc/issues/569
        break;
      }
    }
  });

  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
    for (var i = 0; i < remoteCapabilities.headerExtensions.length;
         i++) {
      var rHeaderExtension = remoteCapabilities.headerExtensions[i];
      if (lHeaderExtension.uri === rHeaderExtension.uri) {
        commonCapabilities.headerExtensions.push(rHeaderExtension);
        break;
      }
    }
  });

  // FIXME: fecMechanisms
  return commonCapabilities;
}

// is action=setLocalDescription with type allowed in signalingState
function isActionAllowedInSignalingState(action, type, signalingState) {
  return {
    offer: {
      setLocalDescription: ['stable', 'have-local-offer'],
      setRemoteDescription: ['stable', 'have-remote-offer']
    },
    answer: {
      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
    }
  }[type][action].indexOf(signalingState) !== -1;
}

function maybeAddCandidate(iceTransport, candidate) {
  // Edge's internal representation adds some fields therefore
  // not all field are taken into account.
  var alreadyAdded = iceTransport.getRemoteCandidates()
      .find(function(remoteCandidate) {
        return candidate.foundation === remoteCandidate.foundation &&
            candidate.ip === remoteCandidate.ip &&
            candidate.port === remoteCandidate.port &&
            candidate.priority === remoteCandidate.priority &&
            candidate.protocol === remoteCandidate.protocol &&
            candidate.type === remoteCandidate.type;
      });
  if (!alreadyAdded) {
    iceTransport.addRemoteCandidate(candidate);
  }
  return !alreadyAdded;
}


function makeError(name, description) {
  var e = new Error(description);
  e.name = name;
  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
  e.code = {
    NotSupportedError: 9,
    InvalidStateError: 11,
    InvalidAccessError: 15,
    TypeError: undefined,
    OperationError: undefined
  }[name];
  return e;
}

module.exports = function(window, edgeVersion) {
  // https://w3c.github.io/mediacapture-main/#mediastream
  // Helper function to add the track to the stream and
  // dispatch the event ourselves.
  function addTrackToStreamAndFireEvent(track, stream) {
    stream.addTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',
        {track: track}));
  }

  function removeTrackFromStreamAndFireEvent(track, stream) {
    stream.removeTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',
        {track: track}));
  }

  function fireAddTrack(pc, track, receiver, streams) {
    var trackEvent = new Event('track');
    trackEvent.track = track;
    trackEvent.receiver = receiver;
    trackEvent.transceiver = {receiver: receiver};
    trackEvent.streams = streams;
    window.setTimeout(function() {
      pc._dispatchEvent('track', trackEvent);
    });
  }

  var RTCPeerConnection = function(config) {
    var pc = this;

    var _eventTarget = document.createDocumentFragment();
    ['addEventListener', 'removeEventListener', 'dispatchEvent']
        .forEach(function(method) {
          pc[method] = _eventTarget[method].bind(_eventTarget);
        });

    this.canTrickleIceCandidates = null;

    this.needNegotiation = false;

    this.localStreams = [];
    this.remoteStreams = [];

    this._localDescription = null;
    this._remoteDescription = null;

    this.signalingState = 'stable';
    this.iceConnectionState = 'new';
    this.connectionState = 'new';
    this.iceGatheringState = 'new';

    config = JSON.parse(JSON.stringify(config || {}));

    this.usingBundle = config.bundlePolicy === 'max-bundle';
    if (config.rtcpMuxPolicy === 'negotiate') {
      throw(makeError('NotSupportedError',
          'rtcpMuxPolicy \'negotiate\' is not supported'));
    } else if (!config.rtcpMuxPolicy) {
      config.rtcpMuxPolicy = 'require';
    }

    switch (config.iceTransportPolicy) {
      case 'all':
      case 'relay':
        break;
      default:
        config.iceTransportPolicy = 'all';
        break;
    }

    switch (config.bundlePolicy) {
      case 'balanced':
      case 'max-compat':
      case 'max-bundle':
        break;
      default:
        config.bundlePolicy = 'balanced';
        break;
    }

    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

    this._iceGatherers = [];
    if (config.iceCandidatePoolSize) {
      for (var i = config.iceCandidatePoolSize; i > 0; i--) {
        this._iceGatherers.push(new window.RTCIceGatherer({
          iceServers: config.iceServers,
          gatherPolicy: config.iceTransportPolicy
        }));
      }
    } else {
      config.iceCandidatePoolSize = 0;
    }

    this._config = config;

    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
    // everything that is needed to describe a SDP m-line.
    this.transceivers = [];

    this._sdpSessionId = SDPUtils.generateSessionId();
    this._sdpSessionVersion = 0;

    this._dtlsRole = undefined; // role for a=setup to use in answers.

    this._isClosed = false;
  };

  Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
    configurable: true,
    get: function() {
      return this._localDescription;
    }
  });
  Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
    configurable: true,
    get: function() {
      return this._remoteDescription;
    }
  });

  // set up event handlers on prototype
  RTCPeerConnection.prototype.onicecandidate = null;
  RTCPeerConnection.prototype.onaddstream = null;
  RTCPeerConnection.prototype.ontrack = null;
  RTCPeerConnection.prototype.onremovestream = null;
  RTCPeerConnection.prototype.onsignalingstatechange = null;
  RTCPeerConnection.prototype.oniceconnectionstatechange = null;
  RTCPeerConnection.prototype.onconnectionstatechange = null;
  RTCPeerConnection.prototype.onicegatheringstatechange = null;
  RTCPeerConnection.prototype.onnegotiationneeded = null;
  RTCPeerConnection.prototype.ondatachannel = null;

  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
    if (this._isClosed) {
      return;
    }
    this.dispatchEvent(event);
    if (typeof this['on' + name] === 'function') {
      this['on' + name](event);
    }
  };

  RTCPeerConnection.prototype._emitGatheringStateChange = function() {
    var event = new Event('icegatheringstatechange');
    this._dispatchEvent('icegatheringstatechange', event);
  };

  RTCPeerConnection.prototype.getConfiguration = function() {
    return this._config;
  };

  RTCPeerConnection.prototype.getLocalStreams = function() {
    return this.localStreams;
  };

  RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this.remoteStreams;
  };

  // internal helper to create a transceiver object.
  // (which is not yet the same as the WebRTC 1.0 transceiver)
  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
    var hasBundleTransport = this.transceivers.length > 0;
    var transceiver = {
      track: null,
      iceGatherer: null,
      iceTransport: null,
      dtlsTransport: null,
      localCapabilities: null,
      remoteCapabilities: null,
      rtpSender: null,
      rtpReceiver: null,
      kind: kind,
      mid: null,
      sendEncodingParameters: null,
      recvEncodingParameters: null,
      stream: null,
      associatedRemoteMediaStreams: [],
      wantReceive: true
    };
    if (this.usingBundle && hasBundleTransport) {
      transceiver.iceTransport = this.transceivers[0].iceTransport;
      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
    } else {
      var transports = this._createIceAndDtlsTransports();
      transceiver.iceTransport = transports.iceTransport;
      transceiver.dtlsTransport = transports.dtlsTransport;
    }
    if (!doNotAdd) {
      this.transceivers.push(transceiver);
    }
    return transceiver;
  };

  RTCPeerConnection.prototype.addTrack = function(track, stream) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call addTrack on a closed peerconnection.');
    }

    var alreadyExists = this.transceivers.find(function(s) {
      return s.track === track;
    });

    if (alreadyExists) {
      throw makeError('InvalidAccessError', 'Track already exists.');
    }

    var transceiver;
    for (var i = 0; i < this.transceivers.length; i++) {
      if (!this.transceivers[i].track &&
          this.transceivers[i].kind === track.kind) {
        transceiver = this.transceivers[i];
      }
    }
    if (!transceiver) {
      transceiver = this._createTransceiver(track.kind);
    }

    this._maybeFireNegotiationNeeded();

    if (this.localStreams.indexOf(stream) === -1) {
      this.localStreams.push(stream);
    }

    transceiver.track = track;
    transceiver.stream = stream;
    transceiver.rtpSender = new window.RTCRtpSender(track,
        transceiver.dtlsTransport);
    return transceiver.rtpSender;
  };

  RTCPeerConnection.prototype.addStream = function(stream) {
    var pc = this;
    if (edgeVersion >= 15025) {
      stream.getTracks().forEach(function(track) {
        pc.addTrack(track, stream);
      });
    } else {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      // Fixed in 15025 (or earlier)
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      clonedStream.getTracks().forEach(function(track) {
        pc.addTrack(track, clonedStream);
      });
    }
  };

  RTCPeerConnection.prototype.removeTrack = function(sender) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call removeTrack on a closed peerconnection.');
    }

    if (!(sender instanceof window.RTCRtpSender)) {
      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
          'does not implement interface RTCRtpSender.');
    }

    var transceiver = this.transceivers.find(function(t) {
      return t.rtpSender === sender;
    });

    if (!transceiver) {
      throw makeError('InvalidAccessError',
          'Sender was not created by this connection.');
    }
    var stream = transceiver.stream;

    transceiver.rtpSender.stop();
    transceiver.rtpSender = null;
    transceiver.track = null;
    transceiver.stream = null;

    // remove the stream from the set of local streams
    var localStreams = this.transceivers.map(function(t) {
      return t.stream;
    });
    if (localStreams.indexOf(stream) === -1 &&
        this.localStreams.indexOf(stream) > -1) {
      this.localStreams.splice(this.localStreams.indexOf(stream), 1);
    }

    this._maybeFireNegotiationNeeded();
  };

  RTCPeerConnection.prototype.removeStream = function(stream) {
    var pc = this;
    stream.getTracks().forEach(function(track) {
      var sender = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (sender) {
        pc.removeTrack(sender);
      }
    });
  };

  RTCPeerConnection.prototype.getSenders = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpSender;
    })
    .map(function(transceiver) {
      return transceiver.rtpSender;
    });
  };

  RTCPeerConnection.prototype.getReceivers = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpReceiver;
    })
    .map(function(transceiver) {
      return transceiver.rtpReceiver;
    });
  };


  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,
      usingBundle) {
    var pc = this;
    if (usingBundle && sdpMLineIndex > 0) {
      return this.transceivers[0].iceGatherer;
    } else if (this._iceGatherers.length) {
      return this._iceGatherers.shift();
    }
    var iceGatherer = new window.RTCIceGatherer({
      iceServers: this._config.iceServers,
      gatherPolicy: this._config.iceTransportPolicy
    });
    Object.defineProperty(iceGatherer, 'state',
        {value: 'new', writable: true}
    );

    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
      var end = !event.candidate || Object.keys(event.candidate).length === 0;
      // polyfill since RTCIceGatherer.state is not implemented in
      // Edge 10547 yet.
      iceGatherer.state = end ? 'completed' : 'gathering';
      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
      }
    };
    iceGatherer.addEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    return iceGatherer;
  };

  // start gathering from an RTCIceGatherer.
  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
    var pc = this;
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer.onlocalcandidate) {
      return;
    }
    var bufferedCandidateEvents =
      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
    iceGatherer.removeEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    iceGatherer.onlocalcandidate = function(evt) {
      if (pc.usingBundle && sdpMLineIndex > 0) {
        // if we know that we use bundle we can drop candidates with
        // dpMLineIndex > 0. If we don't do this then our state gets
        // confused since we dispose the extra ice gatherer.
        return;
      }
      var event = new Event('icecandidate');
      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

      var cand = evt.candidate;
      // Edge emits an empty object for RTCIceCandidateComplete
      var end = !cand || Object.keys(cand).length === 0;
      if (end) {
        // polyfill since RTCIceGatherer.state is not implemented in
        // Edge 10547 yet.
        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
          iceGatherer.state = 'completed';
        }
      } else {
        if (iceGatherer.state === 'new') {
          iceGatherer.state = 'gathering';
        }
        // RTCIceCandidate doesn't have a component, needs to be added
        cand.component = 1;
        // also the usernameFragment. TODO: update SDP to take both variants.
        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

        var serializedCandidate = SDPUtils.writeCandidate(cand);
        event.candidate = Object.assign(event.candidate,
            SDPUtils.parseCandidate(serializedCandidate));

        event.candidate.candidate = serializedCandidate;
        event.candidate.toJSON = function() {
          return {
            candidate: event.candidate.candidate,
            sdpMid: event.candidate.sdpMid,
            sdpMLineIndex: event.candidate.sdpMLineIndex,
            usernameFragment: event.candidate.usernameFragment
          };
        };
      }

      // update local description.
      var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);
      if (!end) {
        sections[event.candidate.sdpMLineIndex] +=
            'a=' + event.candidate.candidate + '\r\n';
      } else {
        sections[event.candidate.sdpMLineIndex] +=
            'a=end-of-candidates\r\n';
      }
      pc._localDescription.sdp =
          SDPUtils.getDescription(pc._localDescription.sdp) +
          sections.join('');
      var complete = pc.transceivers.every(function(transceiver) {
        return transceiver.iceGatherer &&
            transceiver.iceGatherer.state === 'completed';
      });

      if (pc.iceGatheringState !== 'gathering') {
        pc.iceGatheringState = 'gathering';
        pc._emitGatheringStateChange();
      }

      // Emit candidate. Also emit null candidate when all gatherers are
      // complete.
      if (!end) {
        pc._dispatchEvent('icecandidate', event);
      }
      if (complete) {
        pc._dispatchEvent('icecandidate', new Event('icecandidate'));
        pc.iceGatheringState = 'complete';
        pc._emitGatheringStateChange();
      }
    };

    // emit already gathered candidates.
    window.setTimeout(function() {
      bufferedCandidateEvents.forEach(function(e) {
        iceGatherer.onlocalcandidate(e);
      });
    }, 0);
  };

  // Create ICE transport and DTLS transport.
  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
    var pc = this;
    var iceTransport = new window.RTCIceTransport(null);
    iceTransport.onicestatechange = function() {
      pc._updateIceConnectionState();
      pc._updateConnectionState();
    };

    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
    dtlsTransport.ondtlsstatechange = function() {
      pc._updateConnectionState();
    };
    dtlsTransport.onerror = function() {
      // onerror does not set state to failed by itself.
      Object.defineProperty(dtlsTransport, 'state',
          {value: 'failed', writable: true});
      pc._updateConnectionState();
    };

    return {
      iceTransport: iceTransport,
      dtlsTransport: dtlsTransport
    };
  };

  // Destroy ICE gatherer, ICE transport and DTLS transport.
  // Without triggering the callbacks.
  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
      sdpMLineIndex) {
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer) {
      delete iceGatherer.onlocalcandidate;
      delete this.transceivers[sdpMLineIndex].iceGatherer;
    }
    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
    if (iceTransport) {
      delete iceTransport.onicestatechange;
      delete this.transceivers[sdpMLineIndex].iceTransport;
    }
    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
    if (dtlsTransport) {
      delete dtlsTransport.ondtlsstatechange;
      delete dtlsTransport.onerror;
      delete this.transceivers[sdpMLineIndex].dtlsTransport;
    }
  };

  // Start the RTP Sender and Receiver for a transceiver.
  RTCPeerConnection.prototype._transceive = function(transceiver,
      send, recv) {
    var params = getCommonCapabilities(transceiver.localCapabilities,
        transceiver.remoteCapabilities);
    if (send && transceiver.rtpSender) {
      params.encodings = transceiver.sendEncodingParameters;
      params.rtcp = {
        cname: SDPUtils.localCName,
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.recvEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
      }
      transceiver.rtpSender.send(params);
    }
    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
      // remove RTX field in Edge 14942
      if (transceiver.kind === 'video'
          && transceiver.recvEncodingParameters
          && edgeVersion < 15019) {
        transceiver.recvEncodingParameters.forEach(function(p) {
          delete p.rtx;
        });
      }
      if (transceiver.recvEncodingParameters.length) {
        params.encodings = transceiver.recvEncodingParameters;
      } else {
        params.encodings = [{}];
      }
      params.rtcp = {
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.rtcpParameters.cname) {
        params.rtcp.cname = transceiver.rtcpParameters.cname;
      }
      if (transceiver.sendEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
      }
      transceiver.rtpReceiver.receive(params);
    }
  };

  RTCPeerConnection.prototype.setLocalDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setLocalDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set local ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var sections;
    var sessionpart;
    if (description.type === 'offer') {
      // VERY limited support for SDP munging. Limited to:
      // * changing the order of codecs
      sections = SDPUtils.splitSections(description.sdp);
      sessionpart = sections.shift();
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var caps = SDPUtils.parseRtpParameters(mediaSection);
        pc.transceivers[sdpMLineIndex].localCapabilities = caps;
      });

      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        pc._gather(transceiver.mid, sdpMLineIndex);
      });
    } else if (description.type === 'answer') {
      sections = SDPUtils.splitSections(pc._remoteDescription.sdp);
      sessionpart = sections.shift();
      var isIceLite = SDPUtils.matchPrefix(sessionpart,
          'a=ice-lite').length > 0;
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var transceiver = pc.transceivers[sdpMLineIndex];
        var iceGatherer = transceiver.iceGatherer;
        var iceTransport = transceiver.iceTransport;
        var dtlsTransport = transceiver.dtlsTransport;
        var localCapabilities = transceiver.localCapabilities;
        var remoteCapabilities = transceiver.remoteCapabilities;

        // treat bundle-only as not-rejected.
        var rejected = SDPUtils.isRejected(mediaSection) &&
            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

        if (!rejected && !transceiver.rejected) {
          var remoteIceParameters = SDPUtils.getIceParameters(
              mediaSection, sessionpart);
          var remoteDtlsParameters = SDPUtils.getDtlsParameters(
              mediaSection, sessionpart);
          if (isIceLite) {
            remoteDtlsParameters.role = 'server';
          }

          if (!pc.usingBundle || sdpMLineIndex === 0) {
            pc._gather(transceiver.mid, sdpMLineIndex);
            if (iceTransport.state === 'new') {
              iceTransport.start(iceGatherer, remoteIceParameters,
                  isIceLite ? 'controlling' : 'controlled');
            }
            if (dtlsTransport.state === 'new') {
              dtlsTransport.start(remoteDtlsParameters);
            }
          }

          // Calculate intersection of capabilities.
          var params = getCommonCapabilities(localCapabilities,
              remoteCapabilities);

          // Start the RTCRtpSender. The RTCRtpReceiver for this
          // transceiver has already been started in setRemoteDescription.
          pc._transceive(transceiver,
              params.codecs.length > 0,
              false);
        }
      });
    }

    pc._localDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-local-offer');
    } else {
      pc._updateSignalingState('stable');
    }

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.setRemoteDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setRemoteDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set remote ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var streams = {};
    pc.remoteStreams.forEach(function(stream) {
      streams[stream.id] = stream;
    });
    var receiverList = [];
    var sections = SDPUtils.splitSections(description.sdp);
    var sessionpart = sections.shift();
    var isIceLite = SDPUtils.matchPrefix(sessionpart,
        'a=ice-lite').length > 0;
    var usingBundle = SDPUtils.matchPrefix(sessionpart,
        'a=group:BUNDLE ').length > 0;
    pc.usingBundle = usingBundle;
    var iceOptions = SDPUtils.matchPrefix(sessionpart,
        'a=ice-options:')[0];
    if (iceOptions) {
      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
          .indexOf('trickle') >= 0;
    } else {
      pc.canTrickleIceCandidates = false;
    }

    sections.forEach(function(mediaSection, sdpMLineIndex) {
      var lines = SDPUtils.splitLines(mediaSection);
      var kind = SDPUtils.getKind(mediaSection);
      // treat bundle-only as not-rejected.
      var rejected = SDPUtils.isRejected(mediaSection) &&
          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
      var protocol = lines[0].substr(2).split(' ')[2];

      var direction = SDPUtils.getDirection(mediaSection, sessionpart);
      var remoteMsid = SDPUtils.parseMsid(mediaSection);

      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

      // Reject datachannels which are not implemented yet.
      if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||
          protocol === 'UDP/DTLS/SCTP'))) {
        // TODO: this is dangerous in the case where a non-rejected m-line
        //     becomes rejected.
        pc.transceivers[sdpMLineIndex] = {
          mid: mid,
          kind: kind,
          protocol: protocol,
          rejected: true
        };
        return;
      }

      if (!rejected && pc.transceivers[sdpMLineIndex] &&
          pc.transceivers[sdpMLineIndex].rejected) {
        // recycle a rejected transceiver.
        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
      }

      var transceiver;
      var iceGatherer;
      var iceTransport;
      var dtlsTransport;
      var rtpReceiver;
      var sendEncodingParameters;
      var recvEncodingParameters;
      var localCapabilities;

      var track;
      // FIXME: ensure the mediaSection has rtcp-mux set.
      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
      var remoteIceParameters;
      var remoteDtlsParameters;
      if (!rejected) {
        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters.role = 'client';
      }
      recvEncodingParameters =
          SDPUtils.parseRtpEncodingParameters(mediaSection);

      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

      var isComplete = SDPUtils.matchPrefix(mediaSection,
          'a=end-of-candidates', sessionpart).length > 0;
      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
          .map(function(cand) {
            return SDPUtils.parseCandidate(cand);
          })
          .filter(function(cand) {
            return cand.component === 1;
          });

      // Check if we can use BUNDLE and dispose transports.
      if ((description.type === 'offer' || description.type === 'answer') &&
          !rejected && usingBundle && sdpMLineIndex > 0 &&
          pc.transceivers[sdpMLineIndex]) {
        pc._disposeIceAndDtlsTransports(sdpMLineIndex);
        pc.transceivers[sdpMLineIndex].iceGatherer =
            pc.transceivers[0].iceGatherer;
        pc.transceivers[sdpMLineIndex].iceTransport =
            pc.transceivers[0].iceTransport;
        pc.transceivers[sdpMLineIndex].dtlsTransport =
            pc.transceivers[0].dtlsTransport;
        if (pc.transceivers[sdpMLineIndex].rtpSender) {
          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
      }
      if (description.type === 'offer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex] ||
            pc._createTransceiver(kind);
        transceiver.mid = mid;

        if (!transceiver.iceGatherer) {
          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
              usingBundle);
        }

        if (cands.length && transceiver.iceTransport.state === 'new') {
          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
            transceiver.iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        if (edgeVersion < 15019) {
          localCapabilities.codecs = localCapabilities.codecs.filter(
              function(codec) {
                return codec.name !== 'rtx';
              });
        }

        sendEncodingParameters = transceiver.sendEncodingParameters || [{
          ssrc: (2 * sdpMLineIndex + 2) * 1001
        }];

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        var isNewTrack = false;
        if (direction === 'sendrecv' || direction === 'sendonly') {
          isNewTrack = !transceiver.rtpReceiver;
          rtpReceiver = transceiver.rtpReceiver ||
              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

          if (isNewTrack) {
            var stream;
            track = rtpReceiver.track;
            // FIXME: does not work with Plan B.
            if (remoteMsid && remoteMsid.stream === '-') {
              // no-op. a stream id of '-' means: no associated stream.
            } else if (remoteMsid) {
              if (!streams[remoteMsid.stream]) {
                streams[remoteMsid.stream] = new window.MediaStream();
                Object.defineProperty(streams[remoteMsid.stream], 'id', {
                  get: function() {
                    return remoteMsid.stream;
                  }
                });
              }
              Object.defineProperty(track, 'id', {
                get: function() {
                  return remoteMsid.track;
                }
              });
              stream = streams[remoteMsid.stream];
            } else {
              if (!streams.default) {
                streams.default = new window.MediaStream();
              }
              stream = streams.default;
            }
            if (stream) {
              addTrackToStreamAndFireEvent(track, stream);
              transceiver.associatedRemoteMediaStreams.push(stream);
            }
            receiverList.push([track, rtpReceiver, stream]);
          }
        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
          transceiver.associatedRemoteMediaStreams.forEach(function(s) {
            var nativeTrack = s.getTracks().find(function(t) {
              return t.id === transceiver.rtpReceiver.track.id;
            });
            if (nativeTrack) {
              removeTrackFromStreamAndFireEvent(nativeTrack, s);
            }
          });
          transceiver.associatedRemoteMediaStreams = [];
        }

        transceiver.localCapabilities = localCapabilities;
        transceiver.remoteCapabilities = remoteCapabilities;
        transceiver.rtpReceiver = rtpReceiver;
        transceiver.rtcpParameters = rtcpParameters;
        transceiver.sendEncodingParameters = sendEncodingParameters;
        transceiver.recvEncodingParameters = recvEncodingParameters;

        // Start the RTCRtpReceiver now. The RTPSender is started in
        // setLocalDescription.
        pc._transceive(pc.transceivers[sdpMLineIndex],
            false,
            isNewTrack);
      } else if (description.type === 'answer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex];
        iceGatherer = transceiver.iceGatherer;
        iceTransport = transceiver.iceTransport;
        dtlsTransport = transceiver.dtlsTransport;
        rtpReceiver = transceiver.rtpReceiver;
        sendEncodingParameters = transceiver.sendEncodingParameters;
        localCapabilities = transceiver.localCapabilities;

        pc.transceivers[sdpMLineIndex].recvEncodingParameters =
            recvEncodingParameters;
        pc.transceivers[sdpMLineIndex].remoteCapabilities =
            remoteCapabilities;
        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

        if (cands.length && iceTransport.state === 'new') {
          if ((isIceLite || isComplete) &&
              (!usingBundle || sdpMLineIndex === 0)) {
            iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        if (!usingBundle || sdpMLineIndex === 0) {
          if (iceTransport.state === 'new') {
            iceTransport.start(iceGatherer, remoteIceParameters,
                'controlling');
          }
          if (dtlsTransport.state === 'new') {
            dtlsTransport.start(remoteDtlsParameters);
          }
        }

        // If the offer contained RTX but the answer did not,
        // remove RTX from sendEncodingParameters.
        var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

        var hasRtx = commonCapabilities.codecs.filter(function(c) {
          return c.name.toLowerCase() === 'rtx';
        }).length;
        if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
          delete transceiver.sendEncodingParameters[0].rtx;
        }

        pc._transceive(transceiver,
            direction === 'sendrecv' || direction === 'recvonly',
            direction === 'sendrecv' || direction === 'sendonly');

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        if (rtpReceiver &&
            (direction === 'sendrecv' || direction === 'sendonly')) {
          track = rtpReceiver.track;
          if (remoteMsid) {
            if (!streams[remoteMsid.stream]) {
              streams[remoteMsid.stream] = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
          } else {
            if (!streams.default) {
              streams.default = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams.default);
            receiverList.push([track, rtpReceiver, streams.default]);
          }
        } else {
          // FIXME: actually the receiver should be created later.
          delete transceiver.rtpReceiver;
        }
      }
    });

    if (pc._dtlsRole === undefined) {
      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
    }

    pc._remoteDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-remote-offer');
    } else {
      pc._updateSignalingState('stable');
    }
    Object.keys(streams).forEach(function(sid) {
      var stream = streams[sid];
      if (stream.getTracks().length) {
        if (pc.remoteStreams.indexOf(stream) === -1) {
          pc.remoteStreams.push(stream);
          var event = new Event('addstream');
          event.stream = stream;
          window.setTimeout(function() {
            pc._dispatchEvent('addstream', event);
          });
        }

        receiverList.forEach(function(item) {
          var track = item[0];
          var receiver = item[1];
          if (stream.id !== item[2].id) {
            return;
          }
          fireAddTrack(pc, track, receiver, [stream]);
        });
      }
    });
    receiverList.forEach(function(item) {
      if (item[2]) {
        return;
      }
      fireAddTrack(pc, item[0], item[1], []);
    });

    // check whether addIceCandidate({}) was called within four seconds after
    // setRemoteDescription.
    window.setTimeout(function() {
      if (!(pc && pc.transceivers)) {
        return;
      }
      pc.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport &&
            transceiver.iceTransport.state === 'new' &&
            transceiver.iceTransport.getRemoteCandidates().length > 0) {
          console.warn('Timeout for addRemoteCandidate. Consider sending ' +
              'an end-of-candidates notification');
          transceiver.iceTransport.addRemoteCandidate({});
        }
      });
    }, 4000);

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.close = function() {
    this.transceivers.forEach(function(transceiver) {
      /* not yet
      if (transceiver.iceGatherer) {
        transceiver.iceGatherer.close();
      }
      */
      if (transceiver.iceTransport) {
        transceiver.iceTransport.stop();
      }
      if (transceiver.dtlsTransport) {
        transceiver.dtlsTransport.stop();
      }
      if (transceiver.rtpSender) {
        transceiver.rtpSender.stop();
      }
      if (transceiver.rtpReceiver) {
        transceiver.rtpReceiver.stop();
      }
    });
    // FIXME: clean up tracks, local streams, remote streams, etc
    this._isClosed = true;
    this._updateSignalingState('closed');
  };

  // Update the signaling state.
  RTCPeerConnection.prototype._updateSignalingState = function(newState) {
    this.signalingState = newState;
    var event = new Event('signalingstatechange');
    this._dispatchEvent('signalingstatechange', event);
  };

  // Determine whether to fire the negotiationneeded event.
  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
    var pc = this;
    if (this.signalingState !== 'stable' || this.needNegotiation === true) {
      return;
    }
    this.needNegotiation = true;
    window.setTimeout(function() {
      if (pc.needNegotiation) {
        pc.needNegotiation = false;
        var event = new Event('negotiationneeded');
        pc._dispatchEvent('negotiationneeded', event);
      }
    }, 0);
  };

  // Update the ice connection state.
  RTCPeerConnection.prototype._updateIceConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      checking: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      if (transceiver.iceTransport && !transceiver.rejected) {
        states[transceiver.iceTransport.state]++;
      }
    });

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.checking > 0) {
      newState = 'checking';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    } else if (states.completed > 0) {
      newState = 'completed';
    }

    if (newState !== this.iceConnectionState) {
      this.iceConnectionState = newState;
      var event = new Event('iceconnectionstatechange');
      this._dispatchEvent('iceconnectionstatechange', event);
    }
  };

  // Update the connection state.
  RTCPeerConnection.prototype._updateConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      connecting: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      if (transceiver.iceTransport && transceiver.dtlsTransport &&
          !transceiver.rejected) {
        states[transceiver.iceTransport.state]++;
        states[transceiver.dtlsTransport.state]++;
      }
    });
    // ICETransport.completed and connected are the same for this purpose.
    states.connected += states.completed;

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.connecting > 0) {
      newState = 'connecting';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    }

    if (newState !== this.connectionState) {
      this.connectionState = newState;
      var event = new Event('connectionstatechange');
      this._dispatchEvent('connectionstatechange', event);
    }
  };

  RTCPeerConnection.prototype.createOffer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createOffer after close'));
    }

    var numAudioTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'audio';
    }).length;
    var numVideoTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'video';
    }).length;

    // Determine number of audio and video tracks we need to send/recv.
    var offerOptions = arguments[0];
    if (offerOptions) {
      // Reject Chrome legacy constraints.
      if (offerOptions.mandatory || offerOptions.optional) {
        throw new TypeError(
            'Legacy mandatory/optional constraints not supported.');
      }
      if (offerOptions.offerToReceiveAudio !== undefined) {
        if (offerOptions.offerToReceiveAudio === true) {
          numAudioTracks = 1;
        } else if (offerOptions.offerToReceiveAudio === false) {
          numAudioTracks = 0;
        } else {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
      }
      if (offerOptions.offerToReceiveVideo !== undefined) {
        if (offerOptions.offerToReceiveVideo === true) {
          numVideoTracks = 1;
        } else if (offerOptions.offerToReceiveVideo === false) {
          numVideoTracks = 0;
        } else {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
    }

    pc.transceivers.forEach(function(transceiver) {
      if (transceiver.kind === 'audio') {
        numAudioTracks--;
        if (numAudioTracks < 0) {
          transceiver.wantReceive = false;
        }
      } else if (transceiver.kind === 'video') {
        numVideoTracks--;
        if (numVideoTracks < 0) {
          transceiver.wantReceive = false;
        }
      }
    });

    // Create M-lines for recvonly streams.
    while (numAudioTracks > 0 || numVideoTracks > 0) {
      if (numAudioTracks > 0) {
        pc._createTransceiver('audio');
        numAudioTracks--;
      }
      if (numVideoTracks > 0) {
        pc._createTransceiver('video');
        numVideoTracks--;
      }
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      // For each track, create an ice gatherer, ice transport,
      // dtls transport, potentially rtpsender and rtpreceiver.
      var track = transceiver.track;
      var kind = transceiver.kind;
      var mid = transceiver.mid || SDPUtils.generateIdentifier();
      transceiver.mid = mid;

      if (!transceiver.iceGatherer) {
        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
            pc.usingBundle);
      }

      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
      // filter RTX until additional stuff needed for RTX is implemented
      // in adapter.js
      if (edgeVersion < 15019) {
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
      }
      localCapabilities.codecs.forEach(function(codec) {
        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
        // by adding level-asymmetry-allowed=1
        if (codec.name === 'H264' &&
            codec.parameters['level-asymmetry-allowed'] === undefined) {
          codec.parameters['level-asymmetry-allowed'] = '1';
        }

        // for subsequent offers, we might have to re-use the payload
        // type of the last offer.
        if (transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.codecs) {
          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
                codec.clockRate === remoteCodec.clockRate) {
              codec.preferredPayloadType = remoteCodec.payloadType;
            }
          });
        }
      });
      localCapabilities.headerExtensions.forEach(function(hdrExt) {
        var remoteExtensions = transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.headerExtensions || [];
        remoteExtensions.forEach(function(rHdrExt) {
          if (hdrExt.uri === rHdrExt.uri) {
            hdrExt.id = rHdrExt.id;
          }
        });
      });

      // generate an ssrc now, to be used later in rtpSender.send
      var sendEncodingParameters = transceiver.sendEncodingParameters || [{
        ssrc: (2 * sdpMLineIndex + 1) * 1001
      }];
      if (track) {
        // add RTX
        if (edgeVersion >= 15019 && kind === 'video' &&
            !sendEncodingParameters[0].rtx) {
          sendEncodingParameters[0].rtx = {
            ssrc: sendEncodingParameters[0].ssrc + 1
          };
        }
      }

      if (transceiver.wantReceive) {
        transceiver.rtpReceiver = new window.RTCRtpReceiver(
            transceiver.dtlsTransport, kind);
      }

      transceiver.localCapabilities = localCapabilities;
      transceiver.sendEncodingParameters = sendEncodingParameters;
    });

    // always offer BUNDLE and dispose on return if not supported.
    if (pc._config.bundlePolicy !== 'max-compat') {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,
          'offer', transceiver.stream, pc._dtlsRole);
      sdp += 'a=rtcp-rsize\r\n';

      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
          (sdpMLineIndex === 0 || !pc.usingBundle)) {
        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
          cand.component = 1;
          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
        });

        if (transceiver.iceGatherer.state === 'completed') {
          sdp += 'a=end-of-candidates\r\n';
        }
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'offer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.createAnswer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer after close'));
    }

    if (!(pc.signalingState === 'have-remote-offer' ||
        pc.signalingState === 'have-local-pranswer')) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer in signalingState ' + pc.signalingState));
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    if (pc.usingBundle) {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    var mediaSectionsInOffer = SDPUtils.getMediaSections(
        pc._remoteDescription.sdp).length;
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
        return;
      }
      if (transceiver.rejected) {
        if (transceiver.kind === 'application') {
          if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt
            sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
          } else {
            sdp += 'm=application 0 ' + transceiver.protocol +
                ' webrtc-datachannel\r\n';
          }
        } else if (transceiver.kind === 'audio') {
          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
              'a=rtpmap:0 PCMU/8000\r\n';
        } else if (transceiver.kind === 'video') {
          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
              'a=rtpmap:120 VP8/90000\r\n';
        }
        sdp += 'c=IN IP4 0.0.0.0\r\n' +
            'a=inactive\r\n' +
            'a=mid:' + transceiver.mid + '\r\n';
        return;
      }

      // FIXME: look at direction.
      if (transceiver.stream) {
        var localTrack;
        if (transceiver.kind === 'audio') {
          localTrack = transceiver.stream.getAudioTracks()[0];
        } else if (transceiver.kind === 'video') {
          localTrack = transceiver.stream.getVideoTracks()[0];
        }
        if (localTrack) {
          // add RTX
          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
              !transceiver.sendEncodingParameters[0].rtx) {
            transceiver.sendEncodingParameters[0].rtx = {
              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
            };
          }
        }
      }

      // Calculate intersection of capabilities.
      var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

      var hasRtx = commonCapabilities.codecs.filter(function(c) {
        return c.name.toLowerCase() === 'rtx';
      }).length;
      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
        delete transceiver.sendEncodingParameters[0].rtx;
      }

      sdp += writeMediaSection(transceiver, commonCapabilities,
          'answer', transceiver.stream, pc._dtlsRole);
      if (transceiver.rtcpParameters &&
          transceiver.rtcpParameters.reducedSize) {
        sdp += 'a=rtcp-rsize\r\n';
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'answer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
    var pc = this;
    var sections;
    if (candidate && !(candidate.sdpMLineIndex !== undefined ||
        candidate.sdpMid)) {
      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
    }

    // TODO: needs to go into ops queue.
    return new Promise(function(resolve, reject) {
      if (!pc._remoteDescription) {
        return reject(makeError('InvalidStateError',
            'Can not add ICE candidate without a remote description'));
      } else if (!candidate || candidate.candidate === '') {
        for (var j = 0; j < pc.transceivers.length; j++) {
          if (pc.transceivers[j].rejected) {
            continue;
          }
          pc.transceivers[j].iceTransport.addRemoteCandidate({});
          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
          sections[j] += 'a=end-of-candidates\r\n';
          pc._remoteDescription.sdp =
              SDPUtils.getDescription(pc._remoteDescription.sdp) +
              sections.join('');
          if (pc.usingBundle) {
            break;
          }
        }
      } else {
        var sdpMLineIndex = candidate.sdpMLineIndex;
        if (candidate.sdpMid) {
          for (var i = 0; i < pc.transceivers.length; i++) {
            if (pc.transceivers[i].mid === candidate.sdpMid) {
              sdpMLineIndex = i;
              break;
            }
          }
        }
        var transceiver = pc.transceivers[sdpMLineIndex];
        if (transceiver) {
          if (transceiver.rejected) {
            return resolve();
          }
          var cand = Object.keys(candidate.candidate).length > 0 ?
              SDPUtils.parseCandidate(candidate.candidate) : {};
          // Ignore Chrome's invalid candidates since Edge does not like them.
          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
            return resolve();
          }
          // Ignore RTCP candidates, we assume RTCP-MUX.
          if (cand.component && cand.component !== 1) {
            return resolve();
          }
          // when using bundle, avoid adding candidates to the wrong
          // ice transport. And avoid adding candidates added in the SDP.
          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
              return reject(makeError('OperationError',
                  'Can not add ICE candidate'));
            }
          }

          // update the remoteDescription.
          var candidateString = candidate.candidate.trim();
          if (candidateString.indexOf('a=') === 0) {
            candidateString = candidateString.substr(2);
          }
          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
          sections[sdpMLineIndex] += 'a=' +
              (cand.type ? candidateString : 'end-of-candidates')
              + '\r\n';
          pc._remoteDescription.sdp =
              SDPUtils.getDescription(pc._remoteDescription.sdp) +
              sections.join('');
        } else {
          return reject(makeError('OperationError',
              'Can not add ICE candidate'));
        }
      }
      resolve();
    });
  };

  RTCPeerConnection.prototype.getStats = function(selector) {
    if (selector && selector instanceof window.MediaStreamTrack) {
      var senderOrReceiver = null;
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.rtpSender &&
            transceiver.rtpSender.track === selector) {
          senderOrReceiver = transceiver.rtpSender;
        } else if (transceiver.rtpReceiver &&
            transceiver.rtpReceiver.track === selector) {
          senderOrReceiver = transceiver.rtpReceiver;
        }
      });
      if (!senderOrReceiver) {
        throw makeError('InvalidAccessError', 'Invalid selector.');
      }
      return senderOrReceiver.getStats();
    }

    var promises = [];
    this.transceivers.forEach(function(transceiver) {
      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
          'dtlsTransport'].forEach(function(method) {
            if (transceiver[method]) {
              promises.push(transceiver[method].getStats());
            }
          });
    });
    return Promise.all(promises).then(function(allStats) {
      var results = new Map();
      allStats.forEach(function(stats) {
        stats.forEach(function(stat) {
          results.set(stat.id, stat);
        });
      });
      return results;
    });
  };

  // fix low-level stat names and return Map instead of object.
  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',
    'RTCIceTransport', 'RTCDtlsTransport'];
  ortcObjects.forEach(function(ortcObjectName) {
    var obj = window[ortcObjectName];
    if (obj && obj.prototype && obj.prototype.getStats) {
      var nativeGetstats = obj.prototype.getStats;
      obj.prototype.getStats = function() {
        return nativeGetstats.apply(this)
        .then(function(nativeStats) {
          var mapStats = new Map();
          Object.keys(nativeStats).forEach(function(id) {
            nativeStats[id].type = fixStatsType(nativeStats[id]);
            mapStats.set(id, nativeStats[id]);
          });
          return mapStats;
        });
      };
    }
  });

  // legacy callback shims. Should be moved to adapter.js some days.
  var methods = ['createOffer', 'createAnswer'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[0] === 'function' ||
          typeof args[1] === 'function') { // legacy
        return nativeMethod.apply(this, [arguments[2]])
        .then(function(description) {
          if (typeof args[0] === 'function') {
            args[0].apply(null, [description]);
          }
        }, function(error) {
          if (typeof args[1] === 'function') {
            args[1].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function' ||
          typeof args[2] === 'function') { // legacy
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        }, function(error) {
          if (typeof args[2] === 'function') {
            args[2].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  // getStats is special. It doesn't have a spec legacy method yet we support
  // getStats(something, cb) without error callbacks.
  ['getStats'].forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function') {
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  return RTCPeerConnection;
};

},{"sdp":17}],17:[function(require,module,exports){
/* eslint-env node */
'use strict';

// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// returns the session description.
SDPUtils.getDescription = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parseInt(parts[1], 10),
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    address: parts[4], // address is an alias for ip.
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compability.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.address || candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
};

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  var channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
        ? '/' + headerExtension.direction
        : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      if (codec.parameters[param]) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

SDPUtils.parseSsrcGroup = function(line) {
  var parts = line.substr(13).split(' ');
  return {
    semantics: parts.shift(),
    ssrcs: parts.map(function(ssrc) {
      return parseInt(ssrc, 10);
    })
  };
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
};

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};

// Parses a=crypto lines into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
SDPUtils.parseCryptoLine = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    tag: parseInt(parts[0], 10),
    cryptoSuite: parts[1],
    keyParams: parts[2],
    sessionParams: parts.slice(3),
  };
};

SDPUtils.writeCryptoLine = function(parameters) {
  return 'a=crypto:' + parameters.tag + ' ' +
    parameters.cryptoSuite + ' ' +
    (typeof parameters.keyParams === 'object'
      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)
      : parameters.keyParams) +
    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +
    '\r\n';
};

// Parses the crypto key parameters into
//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
SDPUtils.parseCryptoKeyParams = function(keyParams) {
  if (keyParams.indexOf('inline:') !== 0) {
    return null;
  }
  var parts = keyParams.substr(7).split('|');
  return {
    keyMethod: 'inline',
    keySalt: parts[0],
    lifeTime: parts[1],
    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,
  };
};

SDPUtils.writeCryptoKeyParams = function(keyParams) {
  return keyParams.keyMethod + ':'
    + keyParams.keySalt +
    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +
    (keyParams.mkiValue && keyParams.mkiLength
      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength
      : '');
};

// Extracts all SDES paramters.
SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=crypto:');
  return lines.map(SDPUtils.parseCryptoLine);
};

// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-ufrag:')[0];
  var pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,
    'a=ice-pwd:')[0];
  if (!(ufrag && pwd)) {
    return null;
  }
  return {
    usernameFragment: ufrag.substr(12),
    password: pwd.substr(10),
  };
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
      mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
        mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
        mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(function(extension) {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(parts) {
      return parts.attribute === 'cname';
    });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
    .map(function(line) {
      var parts = line.substr(17).split(' ');
      return parts.map(function(part) {
        return parseInt(part, 10);
      });
    });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10)
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: primarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  // Gets the first SSRC. Note tha with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(obj) {
      return obj.attribute === 'cname';
    })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(msidParts) {
      return msidParts.attribute === 'msid';
    });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// SCTP
// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
// to draft-ietf-mmusic-sctp-sdp-05
SDPUtils.parseSctpDescription = function(mediaSection) {
  var mline = SDPUtils.parseMLine(mediaSection);
  var maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
  var maxMessageSize;
  if (maxSizeLine.length > 0) {
    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
  }
  if (isNaN(maxMessageSize)) {
    maxMessageSize = 65536;
  }
  var sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
  if (sctpPort.length > 0) {
    return {
      port: parseInt(sctpPort[0].substr(12), 10),
      protocol: mline.fmt,
      maxMessageSize: maxMessageSize
    };
  }
  var sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
  if (sctpMapLines.length > 0) {
    var parts = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:')[0]
      .substr(10)
      .split(' ');
    return {
      port: parseInt(parts[0], 10),
      protocol: parts[1],
      maxMessageSize: maxMessageSize
    };
  }
};

// SCTP
// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
// support by now receiving in this format, unless we originally parsed
// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
// protocol of DTLS/SCTP -- without UDP/ or TCP/)
SDPUtils.writeSctpDescription = function(media, sctp) {
  var output = [];
  if (media.protocol !== 'DTLS/SCTP') {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctp-port:' + sctp.port + '\r\n'
    ];
  } else {
    output = [
      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
      'c=IN IP4 0.0.0.0\r\n',
      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n'
    ];
  }
  if (sctp.maxMessageSize !== undefined) {
    output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
  }
  return output.join('');
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
// sessUser is optional and defaults to 'thisisadapterortc'
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
  var sessionId;
  var version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  var user = sessUser || 'thisisadapterortc';
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=' + user + ' ' + sessionId + ' ' + version +
        ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
    transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
    transceiver.dtlsTransport.getLocalParameters(),
    type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var parts = lines[0].substr(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' ')
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  var parts = line.substr(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5]
  };
};

// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
  if (typeof blob !== 'string' || blob.length === 0) {
    return false;
  }
  var lines = SDPUtils.splitLines(blob);
  for (var i = 0; i < lines.length; i++) {
    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
      return false;
    }
    // TODO: check the modifier a bit more.
  }
  return true;
};

// Expose public methods.
if (typeof module === 'object') {
  module.exports = SDPUtils;
}

},{}]},{},[1])(1)
});
;(function(){function l(){function n(a){return a?"object"===typeof a||"function"===typeof a:!1}var p=null;var g=function(a,b){function f(){}if(!n(a)||!n(b))throw new TypeError("Cannot create proxy with a non-object as target or handler");p=function(){f=function(a){throw new TypeError("Cannot perform '"+a+"' on a proxy that has been revoked");}};var e=b;b={get:null,set:null,apply:null,construct:null};for(var k in e){if(!(k in b))throw new TypeError("Proxy polyfill does not support trap '"+k+"'");b[k]=e[k]}"function"===
typeof e&&(b.apply=e.apply.bind(e));var c=this,g=!1,q=!1;"function"===typeof a?(c=function(){var h=this&&this.constructor===c,d=Array.prototype.slice.call(arguments);f(h?"construct":"apply");return h&&b.construct?b.construct.call(this,a,d):!h&&b.apply?b.apply(a,this,d):h?(d.unshift(a),new (a.bind.apply(a,d))):a.apply(this,d)},g=!0):a instanceof Array&&(c=[],q=!0);var r=b.get?function(a){f("get");return b.get(this,a,c)}:function(a){f("get");return this[a]},v=b.set?function(a,d){f("set");b.set(this,
a,d,c)}:function(a,b){f("set");this[a]=b},t={};Object.getOwnPropertyNames(a).forEach(function(b){if(!((g||q)&&b in c)){var d={enumerable:!!Object.getOwnPropertyDescriptor(a,b).enumerable,get:r.bind(a,b),set:v.bind(a,b)};Object.defineProperty(c,b,d);t[b]=!0}});e=!0;Object.setPrototypeOf?Object.setPrototypeOf(c,Object.getPrototypeOf(a)):c.__proto__?c.__proto__=a.__proto__:e=!1;if(b.get||!e)for(var m in a)t[m]||Object.defineProperty(c,m,{get:r.bind(a,m)});Object.seal(a);Object.seal(c);return c};g.revocable=
function(a,b){return{proxy:new g(a,b),revoke:p}};return g};var u="undefined"!==typeof process&&"[object process]"==={}.toString.call(process)||"undefined"!==typeof navigator&&"ReactNative"===navigator.product?global:self;u.Proxy||(u.Proxy=l(),u.Proxy.revocable=u.Proxy.revocable);})()
;/*! https://mths.be/he v1.2.0 by @mathias | MIT license */
;(function(root) {

	// Detect free variables `exports`.
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`.
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`.
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	// All astral symbols.
	var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	// All ASCII symbols (not just printable ASCII) except those listed in the
	// first column of the overrides table.
	// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides
	var regexAsciiWhitelist = /[\x01-\x7F]/g;
	// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
	// code points listed in the first column of the overrides table on
	// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.
	var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;

	var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
	var encodeMap = {'\xAD':'shy','\u200C':'zwnj','\u200D':'zwj','\u200E':'lrm','\u2063':'ic','\u2062':'it','\u2061':'af','\u200F':'rlm','\u200B':'ZeroWidthSpace','\u2060':'NoBreak','\u0311':'DownBreve','\u20DB':'tdot','\u20DC':'DotDot','\t':'Tab','\n':'NewLine','\u2008':'puncsp','\u205F':'MediumSpace','\u2009':'thinsp','\u200A':'hairsp','\u2004':'emsp13','\u2002':'ensp','\u2005':'emsp14','\u2003':'emsp','\u2007':'numsp','\xA0':'nbsp','\u205F\u200A':'ThickSpace','\u203E':'oline','_':'lowbar','\u2010':'dash','\u2013':'ndash','\u2014':'mdash','\u2015':'horbar',',':'comma',';':'semi','\u204F':'bsemi',':':'colon','\u2A74':'Colone','!':'excl','\xA1':'iexcl','?':'quest','\xBF':'iquest','.':'period','\u2025':'nldr','\u2026':'mldr','\xB7':'middot','\'':'apos','\u2018':'lsquo','\u2019':'rsquo','\u201A':'sbquo','\u2039':'lsaquo','\u203A':'rsaquo','"':'quot','\u201C':'ldquo','\u201D':'rdquo','\u201E':'bdquo','\xAB':'laquo','\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\u2308':'lceil','\u2309':'rceil','\u230A':'lfloor','\u230B':'rfloor','\u2985':'lopar','\u2986':'ropar','\u298B':'lbrke','\u298C':'rbrke','\u298D':'lbrkslu','\u298E':'rbrksld','\u298F':'lbrksld','\u2990':'rbrkslu','\u2991':'langd','\u2992':'rangd','\u2993':'lparlt','\u2994':'rpargt','\u2995':'gtlPar','\u2996':'ltrPar','\u27E6':'lobrk','\u27E7':'robrk','\u27E8':'lang','\u27E9':'rang','\u27EA':'Lang','\u27EB':'Rang','\u27EC':'loang','\u27ED':'roang','\u2772':'lbbrk','\u2773':'rbbrk','\u2016':'Vert','\xA7':'sect','\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\u2030':'permil','\u2031':'pertenk','\u2020':'dagger','\u2021':'Dagger','\u2022':'bull','\u2043':'hybull','\u2032':'prime','\u2033':'Prime','\u2034':'tprime','\u2057':'qprime','\u2035':'bprime','\u2041':'caret','`':'grave','\xB4':'acute','\u02DC':'tilde','^':'Hat','\xAF':'macr','\u02D8':'breve','\u02D9':'dot','\xA8':'die','\u02DA':'ring','\u02DD':'dblac','\xB8':'cedil','\u02DB':'ogon','\u02C6':'circ','\u02C7':'caron','\xB0':'deg','\xA9':'copy','\xAE':'reg','\u2117':'copysr','\u2118':'wp','\u211E':'rx','\u2127':'mho','\u2129':'iiota','\u2190':'larr','\u219A':'nlarr','\u2192':'rarr','\u219B':'nrarr','\u2191':'uarr','\u2193':'darr','\u2194':'harr','\u21AE':'nharr','\u2195':'varr','\u2196':'nwarr','\u2197':'nearr','\u2198':'searr','\u2199':'swarr','\u219D':'rarrw','\u219D\u0338':'nrarrw','\u219E':'Larr','\u219F':'Uarr','\u21A0':'Rarr','\u21A1':'Darr','\u21A2':'larrtl','\u21A3':'rarrtl','\u21A4':'mapstoleft','\u21A5':'mapstoup','\u21A6':'map','\u21A7':'mapstodown','\u21A9':'larrhk','\u21AA':'rarrhk','\u21AB':'larrlp','\u21AC':'rarrlp','\u21AD':'harrw','\u21B0':'lsh','\u21B1':'rsh','\u21B2':'ldsh','\u21B3':'rdsh','\u21B5':'crarr','\u21B6':'cularr','\u21B7':'curarr','\u21BA':'olarr','\u21BB':'orarr','\u21BC':'lharu','\u21BD':'lhard','\u21BE':'uharr','\u21BF':'uharl','\u21C0':'rharu','\u21C1':'rhard','\u21C2':'dharr','\u21C3':'dharl','\u21C4':'rlarr','\u21C5':'udarr','\u21C6':'lrarr','\u21C7':'llarr','\u21C8':'uuarr','\u21C9':'rrarr','\u21CA':'ddarr','\u21CB':'lrhar','\u21CC':'rlhar','\u21D0':'lArr','\u21CD':'nlArr','\u21D1':'uArr','\u21D2':'rArr','\u21CF':'nrArr','\u21D3':'dArr','\u21D4':'iff','\u21CE':'nhArr','\u21D5':'vArr','\u21D6':'nwArr','\u21D7':'neArr','\u21D8':'seArr','\u21D9':'swArr','\u21DA':'lAarr','\u21DB':'rAarr','\u21DD':'zigrarr','\u21E4':'larrb','\u21E5':'rarrb','\u21F5':'duarr','\u21FD':'loarr','\u21FE':'roarr','\u21FF':'hoarr','\u2200':'forall','\u2201':'comp','\u2202':'part','\u2202\u0338':'npart','\u2203':'exist','\u2204':'nexist','\u2205':'empty','\u2207':'Del','\u2208':'in','\u2209':'notin','\u220B':'ni','\u220C':'notni','\u03F6':'bepsi','\u220F':'prod','\u2210':'coprod','\u2211':'sum','+':'plus','\xB1':'pm','\xF7':'div','\xD7':'times','<':'lt','\u226E':'nlt','<\u20D2':'nvlt','=':'equals','\u2260':'ne','=\u20E5':'bne','\u2A75':'Equal','>':'gt','\u226F':'ngt','>\u20D2':'nvgt','\xAC':'not','|':'vert','\xA6':'brvbar','\u2212':'minus','\u2213':'mp','\u2214':'plusdo','\u2044':'frasl','\u2216':'setmn','\u2217':'lowast','\u2218':'compfn','\u221A':'Sqrt','\u221D':'prop','\u221E':'infin','\u221F':'angrt','\u2220':'ang','\u2220\u20D2':'nang','\u2221':'angmsd','\u2222':'angsph','\u2223':'mid','\u2224':'nmid','\u2225':'par','\u2226':'npar','\u2227':'and','\u2228':'or','\u2229':'cap','\u2229\uFE00':'caps','\u222A':'cup','\u222A\uFE00':'cups','\u222B':'int','\u222C':'Int','\u222D':'tint','\u2A0C':'qint','\u222E':'oint','\u222F':'Conint','\u2230':'Cconint','\u2231':'cwint','\u2232':'cwconint','\u2233':'awconint','\u2234':'there4','\u2235':'becaus','\u2236':'ratio','\u2237':'Colon','\u2238':'minusd','\u223A':'mDDot','\u223B':'homtht','\u223C':'sim','\u2241':'nsim','\u223C\u20D2':'nvsim','\u223D':'bsim','\u223D\u0331':'race','\u223E':'ac','\u223E\u0333':'acE','\u223F':'acd','\u2240':'wr','\u2242':'esim','\u2242\u0338':'nesim','\u2243':'sime','\u2244':'nsime','\u2245':'cong','\u2247':'ncong','\u2246':'simne','\u2248':'ap','\u2249':'nap','\u224A':'ape','\u224B':'apid','\u224B\u0338':'napid','\u224C':'bcong','\u224D':'CupCap','\u226D':'NotCupCap','\u224D\u20D2':'nvap','\u224E':'bump','\u224E\u0338':'nbump','\u224F':'bumpe','\u224F\u0338':'nbumpe','\u2250':'doteq','\u2250\u0338':'nedot','\u2251':'eDot','\u2252':'efDot','\u2253':'erDot','\u2254':'colone','\u2255':'ecolon','\u2256':'ecir','\u2257':'cire','\u2259':'wedgeq','\u225A':'veeeq','\u225C':'trie','\u225F':'equest','\u2261':'equiv','\u2262':'nequiv','\u2261\u20E5':'bnequiv','\u2264':'le','\u2270':'nle','\u2264\u20D2':'nvle','\u2265':'ge','\u2271':'nge','\u2265\u20D2':'nvge','\u2266':'lE','\u2266\u0338':'nlE','\u2267':'gE','\u2267\u0338':'ngE','\u2268\uFE00':'lvnE','\u2268':'lnE','\u2269':'gnE','\u2269\uFE00':'gvnE','\u226A':'ll','\u226A\u0338':'nLtv','\u226A\u20D2':'nLt','\u226B':'gg','\u226B\u0338':'nGtv','\u226B\u20D2':'nGt','\u226C':'twixt','\u2272':'lsim','\u2274':'nlsim','\u2273':'gsim','\u2275':'ngsim','\u2276':'lg','\u2278':'ntlg','\u2277':'gl','\u2279':'ntgl','\u227A':'pr','\u2280':'npr','\u227B':'sc','\u2281':'nsc','\u227C':'prcue','\u22E0':'nprcue','\u227D':'sccue','\u22E1':'nsccue','\u227E':'prsim','\u227F':'scsim','\u227F\u0338':'NotSucceedsTilde','\u2282':'sub','\u2284':'nsub','\u2282\u20D2':'vnsub','\u2283':'sup','\u2285':'nsup','\u2283\u20D2':'vnsup','\u2286':'sube','\u2288':'nsube','\u2287':'supe','\u2289':'nsupe','\u228A\uFE00':'vsubne','\u228A':'subne','\u228B\uFE00':'vsupne','\u228B':'supne','\u228D':'cupdot','\u228E':'uplus','\u228F':'sqsub','\u228F\u0338':'NotSquareSubset','\u2290':'sqsup','\u2290\u0338':'NotSquareSuperset','\u2291':'sqsube','\u22E2':'nsqsube','\u2292':'sqsupe','\u22E3':'nsqsupe','\u2293':'sqcap','\u2293\uFE00':'sqcaps','\u2294':'sqcup','\u2294\uFE00':'sqcups','\u2295':'oplus','\u2296':'ominus','\u2297':'otimes','\u2298':'osol','\u2299':'odot','\u229A':'ocir','\u229B':'oast','\u229D':'odash','\u229E':'plusb','\u229F':'minusb','\u22A0':'timesb','\u22A1':'sdotb','\u22A2':'vdash','\u22AC':'nvdash','\u22A3':'dashv','\u22A4':'top','\u22A5':'bot','\u22A7':'models','\u22A8':'vDash','\u22AD':'nvDash','\u22A9':'Vdash','\u22AE':'nVdash','\u22AA':'Vvdash','\u22AB':'VDash','\u22AF':'nVDash','\u22B0':'prurel','\u22B2':'vltri','\u22EA':'nltri','\u22B3':'vrtri','\u22EB':'nrtri','\u22B4':'ltrie','\u22EC':'nltrie','\u22B4\u20D2':'nvltrie','\u22B5':'rtrie','\u22ED':'nrtrie','\u22B5\u20D2':'nvrtrie','\u22B6':'origof','\u22B7':'imof','\u22B8':'mumap','\u22B9':'hercon','\u22BA':'intcal','\u22BB':'veebar','\u22BD':'barvee','\u22BE':'angrtvb','\u22BF':'lrtri','\u22C0':'Wedge','\u22C1':'Vee','\u22C2':'xcap','\u22C3':'xcup','\u22C4':'diam','\u22C5':'sdot','\u22C6':'Star','\u22C7':'divonx','\u22C8':'bowtie','\u22C9':'ltimes','\u22CA':'rtimes','\u22CB':'lthree','\u22CC':'rthree','\u22CD':'bsime','\u22CE':'cuvee','\u22CF':'cuwed','\u22D0':'Sub','\u22D1':'Sup','\u22D2':'Cap','\u22D3':'Cup','\u22D4':'fork','\u22D5':'epar','\u22D6':'ltdot','\u22D7':'gtdot','\u22D8':'Ll','\u22D8\u0338':'nLl','\u22D9':'Gg','\u22D9\u0338':'nGg','\u22DA\uFE00':'lesg','\u22DA':'leg','\u22DB':'gel','\u22DB\uFE00':'gesl','\u22DE':'cuepr','\u22DF':'cuesc','\u22E6':'lnsim','\u22E7':'gnsim','\u22E8':'prnsim','\u22E9':'scnsim','\u22EE':'vellip','\u22EF':'ctdot','\u22F0':'utdot','\u22F1':'dtdot','\u22F2':'disin','\u22F3':'isinsv','\u22F4':'isins','\u22F5':'isindot','\u22F5\u0338':'notindot','\u22F6':'notinvc','\u22F7':'notinvb','\u22F9':'isinE','\u22F9\u0338':'notinE','\u22FA':'nisd','\u22FB':'xnis','\u22FC':'nis','\u22FD':'notnivc','\u22FE':'notnivb','\u2305':'barwed','\u2306':'Barwed','\u230C':'drcrop','\u230D':'dlcrop','\u230E':'urcrop','\u230F':'ulcrop','\u2310':'bnot','\u2312':'profline','\u2313':'profsurf','\u2315':'telrec','\u2316':'target','\u231C':'ulcorn','\u231D':'urcorn','\u231E':'dlcorn','\u231F':'drcorn','\u2322':'frown','\u2323':'smile','\u232D':'cylcty','\u232E':'profalar','\u2336':'topbot','\u233D':'ovbar','\u233F':'solbar','\u237C':'angzarr','\u23B0':'lmoust','\u23B1':'rmoust','\u23B4':'tbrk','\u23B5':'bbrk','\u23B6':'bbrktbrk','\u23DC':'OverParenthesis','\u23DD':'UnderParenthesis','\u23DE':'OverBrace','\u23DF':'UnderBrace','\u23E2':'trpezium','\u23E7':'elinters','\u2423':'blank','\u2500':'boxh','\u2502':'boxv','\u250C':'boxdr','\u2510':'boxdl','\u2514':'boxur','\u2518':'boxul','\u251C':'boxvr','\u2524':'boxvl','\u252C':'boxhd','\u2534':'boxhu','\u253C':'boxvh','\u2550':'boxH','\u2551':'boxV','\u2552':'boxdR','\u2553':'boxDr','\u2554':'boxDR','\u2555':'boxdL','\u2556':'boxDl','\u2557':'boxDL','\u2558':'boxuR','\u2559':'boxUr','\u255A':'boxUR','\u255B':'boxuL','\u255C':'boxUl','\u255D':'boxUL','\u255E':'boxvR','\u255F':'boxVr','\u2560':'boxVR','\u2561':'boxvL','\u2562':'boxVl','\u2563':'boxVL','\u2564':'boxHd','\u2565':'boxhD','\u2566':'boxHD','\u2567':'boxHu','\u2568':'boxhU','\u2569':'boxHU','\u256A':'boxvH','\u256B':'boxVh','\u256C':'boxVH','\u2580':'uhblk','\u2584':'lhblk','\u2588':'block','\u2591':'blk14','\u2592':'blk12','\u2593':'blk34','\u25A1':'squ','\u25AA':'squf','\u25AB':'EmptyVerySmallSquare','\u25AD':'rect','\u25AE':'marker','\u25B1':'fltns','\u25B3':'xutri','\u25B4':'utrif','\u25B5':'utri','\u25B8':'rtrif','\u25B9':'rtri','\u25BD':'xdtri','\u25BE':'dtrif','\u25BF':'dtri','\u25C2':'ltrif','\u25C3':'ltri','\u25CA':'loz','\u25CB':'cir','\u25EC':'tridot','\u25EF':'xcirc','\u25F8':'ultri','\u25F9':'urtri','\u25FA':'lltri','\u25FB':'EmptySmallSquare','\u25FC':'FilledSmallSquare','\u2605':'starf','\u2606':'star','\u260E':'phone','\u2640':'female','\u2642':'male','\u2660':'spades','\u2663':'clubs','\u2665':'hearts','\u2666':'diams','\u266A':'sung','\u2713':'check','\u2717':'cross','\u2720':'malt','\u2736':'sext','\u2758':'VerticalSeparator','\u27C8':'bsolhsub','\u27C9':'suphsol','\u27F5':'xlarr','\u27F6':'xrarr','\u27F7':'xharr','\u27F8':'xlArr','\u27F9':'xrArr','\u27FA':'xhArr','\u27FC':'xmap','\u27FF':'dzigrarr','\u2902':'nvlArr','\u2903':'nvrArr','\u2904':'nvHarr','\u2905':'Map','\u290C':'lbarr','\u290D':'rbarr','\u290E':'lBarr','\u290F':'rBarr','\u2910':'RBarr','\u2911':'DDotrahd','\u2912':'UpArrowBar','\u2913':'DownArrowBar','\u2916':'Rarrtl','\u2919':'latail','\u291A':'ratail','\u291B':'lAtail','\u291C':'rAtail','\u291D':'larrfs','\u291E':'rarrfs','\u291F':'larrbfs','\u2920':'rarrbfs','\u2923':'nwarhk','\u2924':'nearhk','\u2925':'searhk','\u2926':'swarhk','\u2927':'nwnear','\u2928':'toea','\u2929':'tosa','\u292A':'swnwar','\u2933':'rarrc','\u2933\u0338':'nrarrc','\u2935':'cudarrr','\u2936':'ldca','\u2937':'rdca','\u2938':'cudarrl','\u2939':'larrpl','\u293C':'curarrm','\u293D':'cularrp','\u2945':'rarrpl','\u2948':'harrcir','\u2949':'Uarrocir','\u294A':'lurdshar','\u294B':'ldrushar','\u294E':'LeftRightVector','\u294F':'RightUpDownVector','\u2950':'DownLeftRightVector','\u2951':'LeftUpDownVector','\u2952':'LeftVectorBar','\u2953':'RightVectorBar','\u2954':'RightUpVectorBar','\u2955':'RightDownVectorBar','\u2956':'DownLeftVectorBar','\u2957':'DownRightVectorBar','\u2958':'LeftUpVectorBar','\u2959':'LeftDownVectorBar','\u295A':'LeftTeeVector','\u295B':'RightTeeVector','\u295C':'RightUpTeeVector','\u295D':'RightDownTeeVector','\u295E':'DownLeftTeeVector','\u295F':'DownRightTeeVector','\u2960':'LeftUpTeeVector','\u2961':'LeftDownTeeVector','\u2962':'lHar','\u2963':'uHar','\u2964':'rHar','\u2965':'dHar','\u2966':'luruhar','\u2967':'ldrdhar','\u2968':'ruluhar','\u2969':'rdldhar','\u296A':'lharul','\u296B':'llhard','\u296C':'rharul','\u296D':'lrhard','\u296E':'udhar','\u296F':'duhar','\u2970':'RoundImplies','\u2971':'erarr','\u2972':'simrarr','\u2973':'larrsim','\u2974':'rarrsim','\u2975':'rarrap','\u2976':'ltlarr','\u2978':'gtrarr','\u2979':'subrarr','\u297B':'suplarr','\u297C':'lfisht','\u297D':'rfisht','\u297E':'ufisht','\u297F':'dfisht','\u299A':'vzigzag','\u299C':'vangrt','\u299D':'angrtvbd','\u29A4':'ange','\u29A5':'range','\u29A6':'dwangle','\u29A7':'uwangle','\u29A8':'angmsdaa','\u29A9':'angmsdab','\u29AA':'angmsdac','\u29AB':'angmsdad','\u29AC':'angmsdae','\u29AD':'angmsdaf','\u29AE':'angmsdag','\u29AF':'angmsdah','\u29B0':'bemptyv','\u29B1':'demptyv','\u29B2':'cemptyv','\u29B3':'raemptyv','\u29B4':'laemptyv','\u29B5':'ohbar','\u29B6':'omid','\u29B7':'opar','\u29B9':'operp','\u29BB':'olcross','\u29BC':'odsold','\u29BE':'olcir','\u29BF':'ofcir','\u29C0':'olt','\u29C1':'ogt','\u29C2':'cirscir','\u29C3':'cirE','\u29C4':'solb','\u29C5':'bsolb','\u29C9':'boxbox','\u29CD':'trisb','\u29CE':'rtriltri','\u29CF':'LeftTriangleBar','\u29CF\u0338':'NotLeftTriangleBar','\u29D0':'RightTriangleBar','\u29D0\u0338':'NotRightTriangleBar','\u29DC':'iinfin','\u29DD':'infintie','\u29DE':'nvinfin','\u29E3':'eparsl','\u29E4':'smeparsl','\u29E5':'eqvparsl','\u29EB':'lozf','\u29F4':'RuleDelayed','\u29F6':'dsol','\u2A00':'xodot','\u2A01':'xoplus','\u2A02':'xotime','\u2A04':'xuplus','\u2A06':'xsqcup','\u2A0D':'fpartint','\u2A10':'cirfnint','\u2A11':'awint','\u2A12':'rppolint','\u2A13':'scpolint','\u2A14':'npolint','\u2A15':'pointint','\u2A16':'quatint','\u2A17':'intlarhk','\u2A22':'pluscir','\u2A23':'plusacir','\u2A24':'simplus','\u2A25':'plusdu','\u2A26':'plussim','\u2A27':'plustwo','\u2A29':'mcomma','\u2A2A':'minusdu','\u2A2D':'loplus','\u2A2E':'roplus','\u2A2F':'Cross','\u2A30':'timesd','\u2A31':'timesbar','\u2A33':'smashp','\u2A34':'lotimes','\u2A35':'rotimes','\u2A36':'otimesas','\u2A37':'Otimes','\u2A38':'odiv','\u2A39':'triplus','\u2A3A':'triminus','\u2A3B':'tritime','\u2A3C':'iprod','\u2A3F':'amalg','\u2A40':'capdot','\u2A42':'ncup','\u2A43':'ncap','\u2A44':'capand','\u2A45':'cupor','\u2A46':'cupcap','\u2A47':'capcup','\u2A48':'cupbrcap','\u2A49':'capbrcup','\u2A4A':'cupcup','\u2A4B':'capcap','\u2A4C':'ccups','\u2A4D':'ccaps','\u2A50':'ccupssm','\u2A53':'And','\u2A54':'Or','\u2A55':'andand','\u2A56':'oror','\u2A57':'orslope','\u2A58':'andslope','\u2A5A':'andv','\u2A5B':'orv','\u2A5C':'andd','\u2A5D':'ord','\u2A5F':'wedbar','\u2A66':'sdote','\u2A6A':'simdot','\u2A6D':'congdot','\u2A6D\u0338':'ncongdot','\u2A6E':'easter','\u2A6F':'apacir','\u2A70':'apE','\u2A70\u0338':'napE','\u2A71':'eplus','\u2A72':'pluse','\u2A73':'Esim','\u2A77':'eDDot','\u2A78':'equivDD','\u2A79':'ltcir','\u2A7A':'gtcir','\u2A7B':'ltquest','\u2A7C':'gtquest','\u2A7D':'les','\u2A7D\u0338':'nles','\u2A7E':'ges','\u2A7E\u0338':'nges','\u2A7F':'lesdot','\u2A80':'gesdot','\u2A81':'lesdoto','\u2A82':'gesdoto','\u2A83':'lesdotor','\u2A84':'gesdotol','\u2A85':'lap','\u2A86':'gap','\u2A87':'lne','\u2A88':'gne','\u2A89':'lnap','\u2A8A':'gnap','\u2A8B':'lEg','\u2A8C':'gEl','\u2A8D':'lsime','\u2A8E':'gsime','\u2A8F':'lsimg','\u2A90':'gsiml','\u2A91':'lgE','\u2A92':'glE','\u2A93':'lesges','\u2A94':'gesles','\u2A95':'els','\u2A96':'egs','\u2A97':'elsdot','\u2A98':'egsdot','\u2A99':'el','\u2A9A':'eg','\u2A9D':'siml','\u2A9E':'simg','\u2A9F':'simlE','\u2AA0':'simgE','\u2AA1':'LessLess','\u2AA1\u0338':'NotNestedLessLess','\u2AA2':'GreaterGreater','\u2AA2\u0338':'NotNestedGreaterGreater','\u2AA4':'glj','\u2AA5':'gla','\u2AA6':'ltcc','\u2AA7':'gtcc','\u2AA8':'lescc','\u2AA9':'gescc','\u2AAA':'smt','\u2AAB':'lat','\u2AAC':'smte','\u2AAC\uFE00':'smtes','\u2AAD':'late','\u2AAD\uFE00':'lates','\u2AAE':'bumpE','\u2AAF':'pre','\u2AAF\u0338':'npre','\u2AB0':'sce','\u2AB0\u0338':'nsce','\u2AB3':'prE','\u2AB4':'scE','\u2AB5':'prnE','\u2AB6':'scnE','\u2AB7':'prap','\u2AB8':'scap','\u2AB9':'prnap','\u2ABA':'scnap','\u2ABB':'Pr','\u2ABC':'Sc','\u2ABD':'subdot','\u2ABE':'supdot','\u2ABF':'subplus','\u2AC0':'supplus','\u2AC1':'submult','\u2AC2':'supmult','\u2AC3':'subedot','\u2AC4':'supedot','\u2AC5':'subE','\u2AC5\u0338':'nsubE','\u2AC6':'supE','\u2AC6\u0338':'nsupE','\u2AC7':'subsim','\u2AC8':'supsim','\u2ACB\uFE00':'vsubnE','\u2ACB':'subnE','\u2ACC\uFE00':'vsupnE','\u2ACC':'supnE','\u2ACF':'csub','\u2AD0':'csup','\u2AD1':'csube','\u2AD2':'csupe','\u2AD3':'subsup','\u2AD4':'supsub','\u2AD5':'subsub','\u2AD6':'supsup','\u2AD7':'suphsub','\u2AD8':'supdsub','\u2AD9':'forkv','\u2ADA':'topfork','\u2ADB':'mlcp','\u2AE4':'Dashv','\u2AE6':'Vdashl','\u2AE7':'Barv','\u2AE8':'vBar','\u2AE9':'vBarv','\u2AEB':'Vbar','\u2AEC':'Not','\u2AED':'bNot','\u2AEE':'rnmid','\u2AEF':'cirmid','\u2AF0':'midcir','\u2AF1':'topcir','\u2AF2':'nhpar','\u2AF3':'parsim','\u2AFD':'parsl','\u2AFD\u20E5':'nparsl','\u266D':'flat','\u266E':'natur','\u266F':'sharp','\xA4':'curren','\xA2':'cent','$':'dollar','\xA3':'pound','\xA5':'yen','\u20AC':'euro','\xB9':'sup1','\xBD':'half','\u2153':'frac13','\xBC':'frac14','\u2155':'frac15','\u2159':'frac16','\u215B':'frac18','\xB2':'sup2','\u2154':'frac23','\u2156':'frac25','\xB3':'sup3','\xBE':'frac34','\u2157':'frac35','\u215C':'frac38','\u2158':'frac45','\u215A':'frac56','\u215D':'frac58','\u215E':'frac78','\uD835\uDCB6':'ascr','\uD835\uDD52':'aopf','\uD835\uDD1E':'afr','\uD835\uDD38':'Aopf','\uD835\uDD04':'Afr','\uD835\uDC9C':'Ascr','\xAA':'ordf','\xE1':'aacute','\xC1':'Aacute','\xE0':'agrave','\xC0':'Agrave','\u0103':'abreve','\u0102':'Abreve','\xE2':'acirc','\xC2':'Acirc','\xE5':'aring','\xC5':'angst','\xE4':'auml','\xC4':'Auml','\xE3':'atilde','\xC3':'Atilde','\u0105':'aogon','\u0104':'Aogon','\u0101':'amacr','\u0100':'Amacr','\xE6':'aelig','\xC6':'AElig','\uD835\uDCB7':'bscr','\uD835\uDD53':'bopf','\uD835\uDD1F':'bfr','\uD835\uDD39':'Bopf','\u212C':'Bscr','\uD835\uDD05':'Bfr','\uD835\uDD20':'cfr','\uD835\uDCB8':'cscr','\uD835\uDD54':'copf','\u212D':'Cfr','\uD835\uDC9E':'Cscr','\u2102':'Copf','\u0107':'cacute','\u0106':'Cacute','\u0109':'ccirc','\u0108':'Ccirc','\u010D':'ccaron','\u010C':'Ccaron','\u010B':'cdot','\u010A':'Cdot','\xE7':'ccedil','\xC7':'Ccedil','\u2105':'incare','\uD835\uDD21':'dfr','\u2146':'dd','\uD835\uDD55':'dopf','\uD835\uDCB9':'dscr','\uD835\uDC9F':'Dscr','\uD835\uDD07':'Dfr','\u2145':'DD','\uD835\uDD3B':'Dopf','\u010F':'dcaron','\u010E':'Dcaron','\u0111':'dstrok','\u0110':'Dstrok','\xF0':'eth','\xD0':'ETH','\u2147':'ee','\u212F':'escr','\uD835\uDD22':'efr','\uD835\uDD56':'eopf','\u2130':'Escr','\uD835\uDD08':'Efr','\uD835\uDD3C':'Eopf','\xE9':'eacute','\xC9':'Eacute','\xE8':'egrave','\xC8':'Egrave','\xEA':'ecirc','\xCA':'Ecirc','\u011B':'ecaron','\u011A':'Ecaron','\xEB':'euml','\xCB':'Euml','\u0117':'edot','\u0116':'Edot','\u0119':'eogon','\u0118':'Eogon','\u0113':'emacr','\u0112':'Emacr','\uD835\uDD23':'ffr','\uD835\uDD57':'fopf','\uD835\uDCBB':'fscr','\uD835\uDD09':'Ffr','\uD835\uDD3D':'Fopf','\u2131':'Fscr','\uFB00':'fflig','\uFB03':'ffilig','\uFB04':'ffllig','\uFB01':'filig','fj':'fjlig','\uFB02':'fllig','\u0192':'fnof','\u210A':'gscr','\uD835\uDD58':'gopf','\uD835\uDD24':'gfr','\uD835\uDCA2':'Gscr','\uD835\uDD3E':'Gopf','\uD835\uDD0A':'Gfr','\u01F5':'gacute','\u011F':'gbreve','\u011E':'Gbreve','\u011D':'gcirc','\u011C':'Gcirc','\u0121':'gdot','\u0120':'Gdot','\u0122':'Gcedil','\uD835\uDD25':'hfr','\u210E':'planckh','\uD835\uDCBD':'hscr','\uD835\uDD59':'hopf','\u210B':'Hscr','\u210C':'Hfr','\u210D':'Hopf','\u0125':'hcirc','\u0124':'Hcirc','\u210F':'hbar','\u0127':'hstrok','\u0126':'Hstrok','\uD835\uDD5A':'iopf','\uD835\uDD26':'ifr','\uD835\uDCBE':'iscr','\u2148':'ii','\uD835\uDD40':'Iopf','\u2110':'Iscr','\u2111':'Im','\xED':'iacute','\xCD':'Iacute','\xEC':'igrave','\xCC':'Igrave','\xEE':'icirc','\xCE':'Icirc','\xEF':'iuml','\xCF':'Iuml','\u0129':'itilde','\u0128':'Itilde','\u0130':'Idot','\u012F':'iogon','\u012E':'Iogon','\u012B':'imacr','\u012A':'Imacr','\u0133':'ijlig','\u0132':'IJlig','\u0131':'imath','\uD835\uDCBF':'jscr','\uD835\uDD5B':'jopf','\uD835\uDD27':'jfr','\uD835\uDCA5':'Jscr','\uD835\uDD0D':'Jfr','\uD835\uDD41':'Jopf','\u0135':'jcirc','\u0134':'Jcirc','\u0237':'jmath','\uD835\uDD5C':'kopf','\uD835\uDCC0':'kscr','\uD835\uDD28':'kfr','\uD835\uDCA6':'Kscr','\uD835\uDD42':'Kopf','\uD835\uDD0E':'Kfr','\u0137':'kcedil','\u0136':'Kcedil','\uD835\uDD29':'lfr','\uD835\uDCC1':'lscr','\u2113':'ell','\uD835\uDD5D':'lopf','\u2112':'Lscr','\uD835\uDD0F':'Lfr','\uD835\uDD43':'Lopf','\u013A':'lacute','\u0139':'Lacute','\u013E':'lcaron','\u013D':'Lcaron','\u013C':'lcedil','\u013B':'Lcedil','\u0142':'lstrok','\u0141':'Lstrok','\u0140':'lmidot','\u013F':'Lmidot','\uD835\uDD2A':'mfr','\uD835\uDD5E':'mopf','\uD835\uDCC2':'mscr','\uD835\uDD10':'Mfr','\uD835\uDD44':'Mopf','\u2133':'Mscr','\uD835\uDD2B':'nfr','\uD835\uDD5F':'nopf','\uD835\uDCC3':'nscr','\u2115':'Nopf','\uD835\uDCA9':'Nscr','\uD835\uDD11':'Nfr','\u0144':'nacute','\u0143':'Nacute','\u0148':'ncaron','\u0147':'Ncaron','\xF1':'ntilde','\xD1':'Ntilde','\u0146':'ncedil','\u0145':'Ncedil','\u2116':'numero','\u014B':'eng','\u014A':'ENG','\uD835\uDD60':'oopf','\uD835\uDD2C':'ofr','\u2134':'oscr','\uD835\uDCAA':'Oscr','\uD835\uDD12':'Ofr','\uD835\uDD46':'Oopf','\xBA':'ordm','\xF3':'oacute','\xD3':'Oacute','\xF2':'ograve','\xD2':'Ograve','\xF4':'ocirc','\xD4':'Ocirc','\xF6':'ouml','\xD6':'Ouml','\u0151':'odblac','\u0150':'Odblac','\xF5':'otilde','\xD5':'Otilde','\xF8':'oslash','\xD8':'Oslash','\u014D':'omacr','\u014C':'Omacr','\u0153':'oelig','\u0152':'OElig','\uD835\uDD2D':'pfr','\uD835\uDCC5':'pscr','\uD835\uDD61':'popf','\u2119':'Popf','\uD835\uDD13':'Pfr','\uD835\uDCAB':'Pscr','\uD835\uDD62':'qopf','\uD835\uDD2E':'qfr','\uD835\uDCC6':'qscr','\uD835\uDCAC':'Qscr','\uD835\uDD14':'Qfr','\u211A':'Qopf','\u0138':'kgreen','\uD835\uDD2F':'rfr','\uD835\uDD63':'ropf','\uD835\uDCC7':'rscr','\u211B':'Rscr','\u211C':'Re','\u211D':'Ropf','\u0155':'racute','\u0154':'Racute','\u0159':'rcaron','\u0158':'Rcaron','\u0157':'rcedil','\u0156':'Rcedil','\uD835\uDD64':'sopf','\uD835\uDCC8':'sscr','\uD835\uDD30':'sfr','\uD835\uDD4A':'Sopf','\uD835\uDD16':'Sfr','\uD835\uDCAE':'Sscr','\u24C8':'oS','\u015B':'sacute','\u015A':'Sacute','\u015D':'scirc','\u015C':'Scirc','\u0161':'scaron','\u0160':'Scaron','\u015F':'scedil','\u015E':'Scedil','\xDF':'szlig','\uD835\uDD31':'tfr','\uD835\uDCC9':'tscr','\uD835\uDD65':'topf','\uD835\uDCAF':'Tscr','\uD835\uDD17':'Tfr','\uD835\uDD4B':'Topf','\u0165':'tcaron','\u0164':'Tcaron','\u0163':'tcedil','\u0162':'Tcedil','\u2122':'trade','\u0167':'tstrok','\u0166':'Tstrok','\uD835\uDCCA':'uscr','\uD835\uDD66':'uopf','\uD835\uDD32':'ufr','\uD835\uDD4C':'Uopf','\uD835\uDD18':'Ufr','\uD835\uDCB0':'Uscr','\xFA':'uacute','\xDA':'Uacute','\xF9':'ugrave','\xD9':'Ugrave','\u016D':'ubreve','\u016C':'Ubreve','\xFB':'ucirc','\xDB':'Ucirc','\u016F':'uring','\u016E':'Uring','\xFC':'uuml','\xDC':'Uuml','\u0171':'udblac','\u0170':'Udblac','\u0169':'utilde','\u0168':'Utilde','\u0173':'uogon','\u0172':'Uogon','\u016B':'umacr','\u016A':'Umacr','\uD835\uDD33':'vfr','\uD835\uDD67':'vopf','\uD835\uDCCB':'vscr','\uD835\uDD19':'Vfr','\uD835\uDD4D':'Vopf','\uD835\uDCB1':'Vscr','\uD835\uDD68':'wopf','\uD835\uDCCC':'wscr','\uD835\uDD34':'wfr','\uD835\uDCB2':'Wscr','\uD835\uDD4E':'Wopf','\uD835\uDD1A':'Wfr','\u0175':'wcirc','\u0174':'Wcirc','\uD835\uDD35':'xfr','\uD835\uDCCD':'xscr','\uD835\uDD69':'xopf','\uD835\uDD4F':'Xopf','\uD835\uDD1B':'Xfr','\uD835\uDCB3':'Xscr','\uD835\uDD36':'yfr','\uD835\uDCCE':'yscr','\uD835\uDD6A':'yopf','\uD835\uDCB4':'Yscr','\uD835\uDD1C':'Yfr','\uD835\uDD50':'Yopf','\xFD':'yacute','\xDD':'Yacute','\u0177':'ycirc','\u0176':'Ycirc','\xFF':'yuml','\u0178':'Yuml','\uD835\uDCCF':'zscr','\uD835\uDD37':'zfr','\uD835\uDD6B':'zopf','\u2128':'Zfr','\u2124':'Zopf','\uD835\uDCB5':'Zscr','\u017A':'zacute','\u0179':'Zacute','\u017E':'zcaron','\u017D':'Zcaron','\u017C':'zdot','\u017B':'Zdot','\u01B5':'imped','\xFE':'thorn','\xDE':'THORN','\u0149':'napos','\u03B1':'alpha','\u0391':'Alpha','\u03B2':'beta','\u0392':'Beta','\u03B3':'gamma','\u0393':'Gamma','\u03B4':'delta','\u0394':'Delta','\u03B5':'epsi','\u03F5':'epsiv','\u0395':'Epsilon','\u03DD':'gammad','\u03DC':'Gammad','\u03B6':'zeta','\u0396':'Zeta','\u03B7':'eta','\u0397':'Eta','\u03B8':'theta','\u03D1':'thetav','\u0398':'Theta','\u03B9':'iota','\u0399':'Iota','\u03BA':'kappa','\u03F0':'kappav','\u039A':'Kappa','\u03BB':'lambda','\u039B':'Lambda','\u03BC':'mu','\xB5':'micro','\u039C':'Mu','\u03BD':'nu','\u039D':'Nu','\u03BE':'xi','\u039E':'Xi','\u03BF':'omicron','\u039F':'Omicron','\u03C0':'pi','\u03D6':'piv','\u03A0':'Pi','\u03C1':'rho','\u03F1':'rhov','\u03A1':'Rho','\u03C3':'sigma','\u03A3':'Sigma','\u03C2':'sigmaf','\u03C4':'tau','\u03A4':'Tau','\u03C5':'upsi','\u03A5':'Upsilon','\u03D2':'Upsi','\u03C6':'phi','\u03D5':'phiv','\u03A6':'Phi','\u03C7':'chi','\u03A7':'Chi','\u03C8':'psi','\u03A8':'Psi','\u03C9':'omega','\u03A9':'ohm','\u0430':'acy','\u0410':'Acy','\u0431':'bcy','\u0411':'Bcy','\u0432':'vcy','\u0412':'Vcy','\u0433':'gcy','\u0413':'Gcy','\u0453':'gjcy','\u0403':'GJcy','\u0434':'dcy','\u0414':'Dcy','\u0452':'djcy','\u0402':'DJcy','\u0435':'iecy','\u0415':'IEcy','\u0451':'iocy','\u0401':'IOcy','\u0454':'jukcy','\u0404':'Jukcy','\u0436':'zhcy','\u0416':'ZHcy','\u0437':'zcy','\u0417':'Zcy','\u0455':'dscy','\u0405':'DScy','\u0438':'icy','\u0418':'Icy','\u0456':'iukcy','\u0406':'Iukcy','\u0457':'yicy','\u0407':'YIcy','\u0439':'jcy','\u0419':'Jcy','\u0458':'jsercy','\u0408':'Jsercy','\u043A':'kcy','\u041A':'Kcy','\u045C':'kjcy','\u040C':'KJcy','\u043B':'lcy','\u041B':'Lcy','\u0459':'ljcy','\u0409':'LJcy','\u043C':'mcy','\u041C':'Mcy','\u043D':'ncy','\u041D':'Ncy','\u045A':'njcy','\u040A':'NJcy','\u043E':'ocy','\u041E':'Ocy','\u043F':'pcy','\u041F':'Pcy','\u0440':'rcy','\u0420':'Rcy','\u0441':'scy','\u0421':'Scy','\u0442':'tcy','\u0422':'Tcy','\u045B':'tshcy','\u040B':'TSHcy','\u0443':'ucy','\u0423':'Ucy','\u045E':'ubrcy','\u040E':'Ubrcy','\u0444':'fcy','\u0424':'Fcy','\u0445':'khcy','\u0425':'KHcy','\u0446':'tscy','\u0426':'TScy','\u0447':'chcy','\u0427':'CHcy','\u045F':'dzcy','\u040F':'DZcy','\u0448':'shcy','\u0428':'SHcy','\u0449':'shchcy','\u0429':'SHCHcy','\u044A':'hardcy','\u042A':'HARDcy','\u044B':'ycy','\u042B':'Ycy','\u044C':'softcy','\u042C':'SOFTcy','\u044D':'ecy','\u042D':'Ecy','\u044E':'yucy','\u042E':'YUcy','\u044F':'yacy','\u042F':'YAcy','\u2135':'aleph','\u2136':'beth','\u2137':'gimel','\u2138':'daleth'};

	var regexEscape = /["&'<>`]/g;
	var escapeMap = {
		'"': '&quot;',
		'&': '&amp;',
		'\'': '&#x27;',
		'<': '&lt;',
		// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
		// following is not strictly necessary unless its part of a tag or an
		// unquoted attribute value. Were only escaping it to support those
		// situations, and for XML support.
		'>': '&gt;',
		// In Internet Explorer  8, the backtick character can be used
		// to break out of (un)quoted attribute values or HTML comments.
		// See http://html5sec.org/#102, http://html5sec.org/#108, and
		// http://html5sec.org/#133.
		'`': '&#x60;'
	};

	var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
	var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
	var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
	var decodeMap = {'aacute':'\xE1','Aacute':'\xC1','abreve':'\u0103','Abreve':'\u0102','ac':'\u223E','acd':'\u223F','acE':'\u223E\u0333','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','acy':'\u0430','Acy':'\u0410','aelig':'\xE6','AElig':'\xC6','af':'\u2061','afr':'\uD835\uDD1E','Afr':'\uD835\uDD04','agrave':'\xE0','Agrave':'\xC0','alefsym':'\u2135','aleph':'\u2135','alpha':'\u03B1','Alpha':'\u0391','amacr':'\u0101','Amacr':'\u0100','amalg':'\u2A3F','amp':'&','AMP':'&','and':'\u2227','And':'\u2A53','andand':'\u2A55','andd':'\u2A5C','andslope':'\u2A58','andv':'\u2A5A','ang':'\u2220','ange':'\u29A4','angle':'\u2220','angmsd':'\u2221','angmsdaa':'\u29A8','angmsdab':'\u29A9','angmsdac':'\u29AA','angmsdad':'\u29AB','angmsdae':'\u29AC','angmsdaf':'\u29AD','angmsdag':'\u29AE','angmsdah':'\u29AF','angrt':'\u221F','angrtvb':'\u22BE','angrtvbd':'\u299D','angsph':'\u2222','angst':'\xC5','angzarr':'\u237C','aogon':'\u0105','Aogon':'\u0104','aopf':'\uD835\uDD52','Aopf':'\uD835\uDD38','ap':'\u2248','apacir':'\u2A6F','ape':'\u224A','apE':'\u2A70','apid':'\u224B','apos':'\'','ApplyFunction':'\u2061','approx':'\u2248','approxeq':'\u224A','aring':'\xE5','Aring':'\xC5','ascr':'\uD835\uDCB6','Ascr':'\uD835\uDC9C','Assign':'\u2254','ast':'*','asymp':'\u2248','asympeq':'\u224D','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','awconint':'\u2233','awint':'\u2A11','backcong':'\u224C','backepsilon':'\u03F6','backprime':'\u2035','backsim':'\u223D','backsimeq':'\u22CD','Backslash':'\u2216','Barv':'\u2AE7','barvee':'\u22BD','barwed':'\u2305','Barwed':'\u2306','barwedge':'\u2305','bbrk':'\u23B5','bbrktbrk':'\u23B6','bcong':'\u224C','bcy':'\u0431','Bcy':'\u0411','bdquo':'\u201E','becaus':'\u2235','because':'\u2235','Because':'\u2235','bemptyv':'\u29B0','bepsi':'\u03F6','bernou':'\u212C','Bernoullis':'\u212C','beta':'\u03B2','Beta':'\u0392','beth':'\u2136','between':'\u226C','bfr':'\uD835\uDD1F','Bfr':'\uD835\uDD05','bigcap':'\u22C2','bigcirc':'\u25EF','bigcup':'\u22C3','bigodot':'\u2A00','bigoplus':'\u2A01','bigotimes':'\u2A02','bigsqcup':'\u2A06','bigstar':'\u2605','bigtriangledown':'\u25BD','bigtriangleup':'\u25B3','biguplus':'\u2A04','bigvee':'\u22C1','bigwedge':'\u22C0','bkarow':'\u290D','blacklozenge':'\u29EB','blacksquare':'\u25AA','blacktriangle':'\u25B4','blacktriangledown':'\u25BE','blacktriangleleft':'\u25C2','blacktriangleright':'\u25B8','blank':'\u2423','blk12':'\u2592','blk14':'\u2591','blk34':'\u2593','block':'\u2588','bne':'=\u20E5','bnequiv':'\u2261\u20E5','bnot':'\u2310','bNot':'\u2AED','bopf':'\uD835\uDD53','Bopf':'\uD835\uDD39','bot':'\u22A5','bottom':'\u22A5','bowtie':'\u22C8','boxbox':'\u29C9','boxdl':'\u2510','boxdL':'\u2555','boxDl':'\u2556','boxDL':'\u2557','boxdr':'\u250C','boxdR':'\u2552','boxDr':'\u2553','boxDR':'\u2554','boxh':'\u2500','boxH':'\u2550','boxhd':'\u252C','boxhD':'\u2565','boxHd':'\u2564','boxHD':'\u2566','boxhu':'\u2534','boxhU':'\u2568','boxHu':'\u2567','boxHU':'\u2569','boxminus':'\u229F','boxplus':'\u229E','boxtimes':'\u22A0','boxul':'\u2518','boxuL':'\u255B','boxUl':'\u255C','boxUL':'\u255D','boxur':'\u2514','boxuR':'\u2558','boxUr':'\u2559','boxUR':'\u255A','boxv':'\u2502','boxV':'\u2551','boxvh':'\u253C','boxvH':'\u256A','boxVh':'\u256B','boxVH':'\u256C','boxvl':'\u2524','boxvL':'\u2561','boxVl':'\u2562','boxVL':'\u2563','boxvr':'\u251C','boxvR':'\u255E','boxVr':'\u255F','boxVR':'\u2560','bprime':'\u2035','breve':'\u02D8','Breve':'\u02D8','brvbar':'\xA6','bscr':'\uD835\uDCB7','Bscr':'\u212C','bsemi':'\u204F','bsim':'\u223D','bsime':'\u22CD','bsol':'\\','bsolb':'\u29C5','bsolhsub':'\u27C8','bull':'\u2022','bullet':'\u2022','bump':'\u224E','bumpe':'\u224F','bumpE':'\u2AAE','bumpeq':'\u224F','Bumpeq':'\u224E','cacute':'\u0107','Cacute':'\u0106','cap':'\u2229','Cap':'\u22D2','capand':'\u2A44','capbrcup':'\u2A49','capcap':'\u2A4B','capcup':'\u2A47','capdot':'\u2A40','CapitalDifferentialD':'\u2145','caps':'\u2229\uFE00','caret':'\u2041','caron':'\u02C7','Cayleys':'\u212D','ccaps':'\u2A4D','ccaron':'\u010D','Ccaron':'\u010C','ccedil':'\xE7','Ccedil':'\xC7','ccirc':'\u0109','Ccirc':'\u0108','Cconint':'\u2230','ccups':'\u2A4C','ccupssm':'\u2A50','cdot':'\u010B','Cdot':'\u010A','cedil':'\xB8','Cedilla':'\xB8','cemptyv':'\u29B2','cent':'\xA2','centerdot':'\xB7','CenterDot':'\xB7','cfr':'\uD835\uDD20','Cfr':'\u212D','chcy':'\u0447','CHcy':'\u0427','check':'\u2713','checkmark':'\u2713','chi':'\u03C7','Chi':'\u03A7','cir':'\u25CB','circ':'\u02C6','circeq':'\u2257','circlearrowleft':'\u21BA','circlearrowright':'\u21BB','circledast':'\u229B','circledcirc':'\u229A','circleddash':'\u229D','CircleDot':'\u2299','circledR':'\xAE','circledS':'\u24C8','CircleMinus':'\u2296','CirclePlus':'\u2295','CircleTimes':'\u2297','cire':'\u2257','cirE':'\u29C3','cirfnint':'\u2A10','cirmid':'\u2AEF','cirscir':'\u29C2','ClockwiseContourIntegral':'\u2232','CloseCurlyDoubleQuote':'\u201D','CloseCurlyQuote':'\u2019','clubs':'\u2663','clubsuit':'\u2663','colon':':','Colon':'\u2237','colone':'\u2254','Colone':'\u2A74','coloneq':'\u2254','comma':',','commat':'@','comp':'\u2201','compfn':'\u2218','complement':'\u2201','complexes':'\u2102','cong':'\u2245','congdot':'\u2A6D','Congruent':'\u2261','conint':'\u222E','Conint':'\u222F','ContourIntegral':'\u222E','copf':'\uD835\uDD54','Copf':'\u2102','coprod':'\u2210','Coproduct':'\u2210','copy':'\xA9','COPY':'\xA9','copysr':'\u2117','CounterClockwiseContourIntegral':'\u2233','crarr':'\u21B5','cross':'\u2717','Cross':'\u2A2F','cscr':'\uD835\uDCB8','Cscr':'\uD835\uDC9E','csub':'\u2ACF','csube':'\u2AD1','csup':'\u2AD0','csupe':'\u2AD2','ctdot':'\u22EF','cudarrl':'\u2938','cudarrr':'\u2935','cuepr':'\u22DE','cuesc':'\u22DF','cularr':'\u21B6','cularrp':'\u293D','cup':'\u222A','Cup':'\u22D3','cupbrcap':'\u2A48','cupcap':'\u2A46','CupCap':'\u224D','cupcup':'\u2A4A','cupdot':'\u228D','cupor':'\u2A45','cups':'\u222A\uFE00','curarr':'\u21B7','curarrm':'\u293C','curlyeqprec':'\u22DE','curlyeqsucc':'\u22DF','curlyvee':'\u22CE','curlywedge':'\u22CF','curren':'\xA4','curvearrowleft':'\u21B6','curvearrowright':'\u21B7','cuvee':'\u22CE','cuwed':'\u22CF','cwconint':'\u2232','cwint':'\u2231','cylcty':'\u232D','dagger':'\u2020','Dagger':'\u2021','daleth':'\u2138','darr':'\u2193','dArr':'\u21D3','Darr':'\u21A1','dash':'\u2010','dashv':'\u22A3','Dashv':'\u2AE4','dbkarow':'\u290F','dblac':'\u02DD','dcaron':'\u010F','Dcaron':'\u010E','dcy':'\u0434','Dcy':'\u0414','dd':'\u2146','DD':'\u2145','ddagger':'\u2021','ddarr':'\u21CA','DDotrahd':'\u2911','ddotseq':'\u2A77','deg':'\xB0','Del':'\u2207','delta':'\u03B4','Delta':'\u0394','demptyv':'\u29B1','dfisht':'\u297F','dfr':'\uD835\uDD21','Dfr':'\uD835\uDD07','dHar':'\u2965','dharl':'\u21C3','dharr':'\u21C2','DiacriticalAcute':'\xB4','DiacriticalDot':'\u02D9','DiacriticalDoubleAcute':'\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\u02DC','diam':'\u22C4','diamond':'\u22C4','Diamond':'\u22C4','diamondsuit':'\u2666','diams':'\u2666','die':'\xA8','DifferentialD':'\u2146','digamma':'\u03DD','disin':'\u22F2','div':'\xF7','divide':'\xF7','divideontimes':'\u22C7','divonx':'\u22C7','djcy':'\u0452','DJcy':'\u0402','dlcorn':'\u231E','dlcrop':'\u230D','dollar':'$','dopf':'\uD835\uDD55','Dopf':'\uD835\uDD3B','dot':'\u02D9','Dot':'\xA8','DotDot':'\u20DC','doteq':'\u2250','doteqdot':'\u2251','DotEqual':'\u2250','dotminus':'\u2238','dotplus':'\u2214','dotsquare':'\u22A1','doublebarwedge':'\u2306','DoubleContourIntegral':'\u222F','DoubleDot':'\xA8','DoubleDownArrow':'\u21D3','DoubleLeftArrow':'\u21D0','DoubleLeftRightArrow':'\u21D4','DoubleLeftTee':'\u2AE4','DoubleLongLeftArrow':'\u27F8','DoubleLongLeftRightArrow':'\u27FA','DoubleLongRightArrow':'\u27F9','DoubleRightArrow':'\u21D2','DoubleRightTee':'\u22A8','DoubleUpArrow':'\u21D1','DoubleUpDownArrow':'\u21D5','DoubleVerticalBar':'\u2225','downarrow':'\u2193','Downarrow':'\u21D3','DownArrow':'\u2193','DownArrowBar':'\u2913','DownArrowUpArrow':'\u21F5','DownBreve':'\u0311','downdownarrows':'\u21CA','downharpoonleft':'\u21C3','downharpoonright':'\u21C2','DownLeftRightVector':'\u2950','DownLeftTeeVector':'\u295E','DownLeftVector':'\u21BD','DownLeftVectorBar':'\u2956','DownRightTeeVector':'\u295F','DownRightVector':'\u21C1','DownRightVectorBar':'\u2957','DownTee':'\u22A4','DownTeeArrow':'\u21A7','drbkarow':'\u2910','drcorn':'\u231F','drcrop':'\u230C','dscr':'\uD835\uDCB9','Dscr':'\uD835\uDC9F','dscy':'\u0455','DScy':'\u0405','dsol':'\u29F6','dstrok':'\u0111','Dstrok':'\u0110','dtdot':'\u22F1','dtri':'\u25BF','dtrif':'\u25BE','duarr':'\u21F5','duhar':'\u296F','dwangle':'\u29A6','dzcy':'\u045F','DZcy':'\u040F','dzigrarr':'\u27FF','eacute':'\xE9','Eacute':'\xC9','easter':'\u2A6E','ecaron':'\u011B','Ecaron':'\u011A','ecir':'\u2256','ecirc':'\xEA','Ecirc':'\xCA','ecolon':'\u2255','ecy':'\u044D','Ecy':'\u042D','eDDot':'\u2A77','edot':'\u0117','eDot':'\u2251','Edot':'\u0116','ee':'\u2147','efDot':'\u2252','efr':'\uD835\uDD22','Efr':'\uD835\uDD08','eg':'\u2A9A','egrave':'\xE8','Egrave':'\xC8','egs':'\u2A96','egsdot':'\u2A98','el':'\u2A99','Element':'\u2208','elinters':'\u23E7','ell':'\u2113','els':'\u2A95','elsdot':'\u2A97','emacr':'\u0113','Emacr':'\u0112','empty':'\u2205','emptyset':'\u2205','EmptySmallSquare':'\u25FB','emptyv':'\u2205','EmptyVerySmallSquare':'\u25AB','emsp':'\u2003','emsp13':'\u2004','emsp14':'\u2005','eng':'\u014B','ENG':'\u014A','ensp':'\u2002','eogon':'\u0119','Eogon':'\u0118','eopf':'\uD835\uDD56','Eopf':'\uD835\uDD3C','epar':'\u22D5','eparsl':'\u29E3','eplus':'\u2A71','epsi':'\u03B5','epsilon':'\u03B5','Epsilon':'\u0395','epsiv':'\u03F5','eqcirc':'\u2256','eqcolon':'\u2255','eqsim':'\u2242','eqslantgtr':'\u2A96','eqslantless':'\u2A95','Equal':'\u2A75','equals':'=','EqualTilde':'\u2242','equest':'\u225F','Equilibrium':'\u21CC','equiv':'\u2261','equivDD':'\u2A78','eqvparsl':'\u29E5','erarr':'\u2971','erDot':'\u2253','escr':'\u212F','Escr':'\u2130','esdot':'\u2250','esim':'\u2242','Esim':'\u2A73','eta':'\u03B7','Eta':'\u0397','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','euro':'\u20AC','excl':'!','exist':'\u2203','Exists':'\u2203','expectation':'\u2130','exponentiale':'\u2147','ExponentialE':'\u2147','fallingdotseq':'\u2252','fcy':'\u0444','Fcy':'\u0424','female':'\u2640','ffilig':'\uFB03','fflig':'\uFB00','ffllig':'\uFB04','ffr':'\uD835\uDD23','Ffr':'\uD835\uDD09','filig':'\uFB01','FilledSmallSquare':'\u25FC','FilledVerySmallSquare':'\u25AA','fjlig':'fj','flat':'\u266D','fllig':'\uFB02','fltns':'\u25B1','fnof':'\u0192','fopf':'\uD835\uDD57','Fopf':'\uD835\uDD3D','forall':'\u2200','ForAll':'\u2200','fork':'\u22D4','forkv':'\u2AD9','Fouriertrf':'\u2131','fpartint':'\u2A0D','frac12':'\xBD','frac13':'\u2153','frac14':'\xBC','frac15':'\u2155','frac16':'\u2159','frac18':'\u215B','frac23':'\u2154','frac25':'\u2156','frac34':'\xBE','frac35':'\u2157','frac38':'\u215C','frac45':'\u2158','frac56':'\u215A','frac58':'\u215D','frac78':'\u215E','frasl':'\u2044','frown':'\u2322','fscr':'\uD835\uDCBB','Fscr':'\u2131','gacute':'\u01F5','gamma':'\u03B3','Gamma':'\u0393','gammad':'\u03DD','Gammad':'\u03DC','gap':'\u2A86','gbreve':'\u011F','Gbreve':'\u011E','Gcedil':'\u0122','gcirc':'\u011D','Gcirc':'\u011C','gcy':'\u0433','Gcy':'\u0413','gdot':'\u0121','Gdot':'\u0120','ge':'\u2265','gE':'\u2267','gel':'\u22DB','gEl':'\u2A8C','geq':'\u2265','geqq':'\u2267','geqslant':'\u2A7E','ges':'\u2A7E','gescc':'\u2AA9','gesdot':'\u2A80','gesdoto':'\u2A82','gesdotol':'\u2A84','gesl':'\u22DB\uFE00','gesles':'\u2A94','gfr':'\uD835\uDD24','Gfr':'\uD835\uDD0A','gg':'\u226B','Gg':'\u22D9','ggg':'\u22D9','gimel':'\u2137','gjcy':'\u0453','GJcy':'\u0403','gl':'\u2277','gla':'\u2AA5','glE':'\u2A92','glj':'\u2AA4','gnap':'\u2A8A','gnapprox':'\u2A8A','gne':'\u2A88','gnE':'\u2269','gneq':'\u2A88','gneqq':'\u2269','gnsim':'\u22E7','gopf':'\uD835\uDD58','Gopf':'\uD835\uDD3E','grave':'`','GreaterEqual':'\u2265','GreaterEqualLess':'\u22DB','GreaterFullEqual':'\u2267','GreaterGreater':'\u2AA2','GreaterLess':'\u2277','GreaterSlantEqual':'\u2A7E','GreaterTilde':'\u2273','gscr':'\u210A','Gscr':'\uD835\uDCA2','gsim':'\u2273','gsime':'\u2A8E','gsiml':'\u2A90','gt':'>','Gt':'\u226B','GT':'>','gtcc':'\u2AA7','gtcir':'\u2A7A','gtdot':'\u22D7','gtlPar':'\u2995','gtquest':'\u2A7C','gtrapprox':'\u2A86','gtrarr':'\u2978','gtrdot':'\u22D7','gtreqless':'\u22DB','gtreqqless':'\u2A8C','gtrless':'\u2277','gtrsim':'\u2273','gvertneqq':'\u2269\uFE00','gvnE':'\u2269\uFE00','Hacek':'\u02C7','hairsp':'\u200A','half':'\xBD','hamilt':'\u210B','hardcy':'\u044A','HARDcy':'\u042A','harr':'\u2194','hArr':'\u21D4','harrcir':'\u2948','harrw':'\u21AD','Hat':'^','hbar':'\u210F','hcirc':'\u0125','Hcirc':'\u0124','hearts':'\u2665','heartsuit':'\u2665','hellip':'\u2026','hercon':'\u22B9','hfr':'\uD835\uDD25','Hfr':'\u210C','HilbertSpace':'\u210B','hksearow':'\u2925','hkswarow':'\u2926','hoarr':'\u21FF','homtht':'\u223B','hookleftarrow':'\u21A9','hookrightarrow':'\u21AA','hopf':'\uD835\uDD59','Hopf':'\u210D','horbar':'\u2015','HorizontalLine':'\u2500','hscr':'\uD835\uDCBD','Hscr':'\u210B','hslash':'\u210F','hstrok':'\u0127','Hstrok':'\u0126','HumpDownHump':'\u224E','HumpEqual':'\u224F','hybull':'\u2043','hyphen':'\u2010','iacute':'\xED','Iacute':'\xCD','ic':'\u2063','icirc':'\xEE','Icirc':'\xCE','icy':'\u0438','Icy':'\u0418','Idot':'\u0130','iecy':'\u0435','IEcy':'\u0415','iexcl':'\xA1','iff':'\u21D4','ifr':'\uD835\uDD26','Ifr':'\u2111','igrave':'\xEC','Igrave':'\xCC','ii':'\u2148','iiiint':'\u2A0C','iiint':'\u222D','iinfin':'\u29DC','iiota':'\u2129','ijlig':'\u0133','IJlig':'\u0132','Im':'\u2111','imacr':'\u012B','Imacr':'\u012A','image':'\u2111','ImaginaryI':'\u2148','imagline':'\u2110','imagpart':'\u2111','imath':'\u0131','imof':'\u22B7','imped':'\u01B5','Implies':'\u21D2','in':'\u2208','incare':'\u2105','infin':'\u221E','infintie':'\u29DD','inodot':'\u0131','int':'\u222B','Int':'\u222C','intcal':'\u22BA','integers':'\u2124','Integral':'\u222B','intercal':'\u22BA','Intersection':'\u22C2','intlarhk':'\u2A17','intprod':'\u2A3C','InvisibleComma':'\u2063','InvisibleTimes':'\u2062','iocy':'\u0451','IOcy':'\u0401','iogon':'\u012F','Iogon':'\u012E','iopf':'\uD835\uDD5A','Iopf':'\uD835\uDD40','iota':'\u03B9','Iota':'\u0399','iprod':'\u2A3C','iquest':'\xBF','iscr':'\uD835\uDCBE','Iscr':'\u2110','isin':'\u2208','isindot':'\u22F5','isinE':'\u22F9','isins':'\u22F4','isinsv':'\u22F3','isinv':'\u2208','it':'\u2062','itilde':'\u0129','Itilde':'\u0128','iukcy':'\u0456','Iukcy':'\u0406','iuml':'\xEF','Iuml':'\xCF','jcirc':'\u0135','Jcirc':'\u0134','jcy':'\u0439','Jcy':'\u0419','jfr':'\uD835\uDD27','Jfr':'\uD835\uDD0D','jmath':'\u0237','jopf':'\uD835\uDD5B','Jopf':'\uD835\uDD41','jscr':'\uD835\uDCBF','Jscr':'\uD835\uDCA5','jsercy':'\u0458','Jsercy':'\u0408','jukcy':'\u0454','Jukcy':'\u0404','kappa':'\u03BA','Kappa':'\u039A','kappav':'\u03F0','kcedil':'\u0137','Kcedil':'\u0136','kcy':'\u043A','Kcy':'\u041A','kfr':'\uD835\uDD28','Kfr':'\uD835\uDD0E','kgreen':'\u0138','khcy':'\u0445','KHcy':'\u0425','kjcy':'\u045C','KJcy':'\u040C','kopf':'\uD835\uDD5C','Kopf':'\uD835\uDD42','kscr':'\uD835\uDCC0','Kscr':'\uD835\uDCA6','lAarr':'\u21DA','lacute':'\u013A','Lacute':'\u0139','laemptyv':'\u29B4','lagran':'\u2112','lambda':'\u03BB','Lambda':'\u039B','lang':'\u27E8','Lang':'\u27EA','langd':'\u2991','langle':'\u27E8','lap':'\u2A85','Laplacetrf':'\u2112','laquo':'\xAB','larr':'\u2190','lArr':'\u21D0','Larr':'\u219E','larrb':'\u21E4','larrbfs':'\u291F','larrfs':'\u291D','larrhk':'\u21A9','larrlp':'\u21AB','larrpl':'\u2939','larrsim':'\u2973','larrtl':'\u21A2','lat':'\u2AAB','latail':'\u2919','lAtail':'\u291B','late':'\u2AAD','lates':'\u2AAD\uFE00','lbarr':'\u290C','lBarr':'\u290E','lbbrk':'\u2772','lbrace':'{','lbrack':'[','lbrke':'\u298B','lbrksld':'\u298F','lbrkslu':'\u298D','lcaron':'\u013E','Lcaron':'\u013D','lcedil':'\u013C','Lcedil':'\u013B','lceil':'\u2308','lcub':'{','lcy':'\u043B','Lcy':'\u041B','ldca':'\u2936','ldquo':'\u201C','ldquor':'\u201E','ldrdhar':'\u2967','ldrushar':'\u294B','ldsh':'\u21B2','le':'\u2264','lE':'\u2266','LeftAngleBracket':'\u27E8','leftarrow':'\u2190','Leftarrow':'\u21D0','LeftArrow':'\u2190','LeftArrowBar':'\u21E4','LeftArrowRightArrow':'\u21C6','leftarrowtail':'\u21A2','LeftCeiling':'\u2308','LeftDoubleBracket':'\u27E6','LeftDownTeeVector':'\u2961','LeftDownVector':'\u21C3','LeftDownVectorBar':'\u2959','LeftFloor':'\u230A','leftharpoondown':'\u21BD','leftharpoonup':'\u21BC','leftleftarrows':'\u21C7','leftrightarrow':'\u2194','Leftrightarrow':'\u21D4','LeftRightArrow':'\u2194','leftrightarrows':'\u21C6','leftrightharpoons':'\u21CB','leftrightsquigarrow':'\u21AD','LeftRightVector':'\u294E','LeftTee':'\u22A3','LeftTeeArrow':'\u21A4','LeftTeeVector':'\u295A','leftthreetimes':'\u22CB','LeftTriangle':'\u22B2','LeftTriangleBar':'\u29CF','LeftTriangleEqual':'\u22B4','LeftUpDownVector':'\u2951','LeftUpTeeVector':'\u2960','LeftUpVector':'\u21BF','LeftUpVectorBar':'\u2958','LeftVector':'\u21BC','LeftVectorBar':'\u2952','leg':'\u22DA','lEg':'\u2A8B','leq':'\u2264','leqq':'\u2266','leqslant':'\u2A7D','les':'\u2A7D','lescc':'\u2AA8','lesdot':'\u2A7F','lesdoto':'\u2A81','lesdotor':'\u2A83','lesg':'\u22DA\uFE00','lesges':'\u2A93','lessapprox':'\u2A85','lessdot':'\u22D6','lesseqgtr':'\u22DA','lesseqqgtr':'\u2A8B','LessEqualGreater':'\u22DA','LessFullEqual':'\u2266','LessGreater':'\u2276','lessgtr':'\u2276','LessLess':'\u2AA1','lesssim':'\u2272','LessSlantEqual':'\u2A7D','LessTilde':'\u2272','lfisht':'\u297C','lfloor':'\u230A','lfr':'\uD835\uDD29','Lfr':'\uD835\uDD0F','lg':'\u2276','lgE':'\u2A91','lHar':'\u2962','lhard':'\u21BD','lharu':'\u21BC','lharul':'\u296A','lhblk':'\u2584','ljcy':'\u0459','LJcy':'\u0409','ll':'\u226A','Ll':'\u22D8','llarr':'\u21C7','llcorner':'\u231E','Lleftarrow':'\u21DA','llhard':'\u296B','lltri':'\u25FA','lmidot':'\u0140','Lmidot':'\u013F','lmoust':'\u23B0','lmoustache':'\u23B0','lnap':'\u2A89','lnapprox':'\u2A89','lne':'\u2A87','lnE':'\u2268','lneq':'\u2A87','lneqq':'\u2268','lnsim':'\u22E6','loang':'\u27EC','loarr':'\u21FD','lobrk':'\u27E6','longleftarrow':'\u27F5','Longleftarrow':'\u27F8','LongLeftArrow':'\u27F5','longleftrightarrow':'\u27F7','Longleftrightarrow':'\u27FA','LongLeftRightArrow':'\u27F7','longmapsto':'\u27FC','longrightarrow':'\u27F6','Longrightarrow':'\u27F9','LongRightArrow':'\u27F6','looparrowleft':'\u21AB','looparrowright':'\u21AC','lopar':'\u2985','lopf':'\uD835\uDD5D','Lopf':'\uD835\uDD43','loplus':'\u2A2D','lotimes':'\u2A34','lowast':'\u2217','lowbar':'_','LowerLeftArrow':'\u2199','LowerRightArrow':'\u2198','loz':'\u25CA','lozenge':'\u25CA','lozf':'\u29EB','lpar':'(','lparlt':'\u2993','lrarr':'\u21C6','lrcorner':'\u231F','lrhar':'\u21CB','lrhard':'\u296D','lrm':'\u200E','lrtri':'\u22BF','lsaquo':'\u2039','lscr':'\uD835\uDCC1','Lscr':'\u2112','lsh':'\u21B0','Lsh':'\u21B0','lsim':'\u2272','lsime':'\u2A8D','lsimg':'\u2A8F','lsqb':'[','lsquo':'\u2018','lsquor':'\u201A','lstrok':'\u0142','Lstrok':'\u0141','lt':'<','Lt':'\u226A','LT':'<','ltcc':'\u2AA6','ltcir':'\u2A79','ltdot':'\u22D6','lthree':'\u22CB','ltimes':'\u22C9','ltlarr':'\u2976','ltquest':'\u2A7B','ltri':'\u25C3','ltrie':'\u22B4','ltrif':'\u25C2','ltrPar':'\u2996','lurdshar':'\u294A','luruhar':'\u2966','lvertneqq':'\u2268\uFE00','lvnE':'\u2268\uFE00','macr':'\xAF','male':'\u2642','malt':'\u2720','maltese':'\u2720','map':'\u21A6','Map':'\u2905','mapsto':'\u21A6','mapstodown':'\u21A7','mapstoleft':'\u21A4','mapstoup':'\u21A5','marker':'\u25AE','mcomma':'\u2A29','mcy':'\u043C','Mcy':'\u041C','mdash':'\u2014','mDDot':'\u223A','measuredangle':'\u2221','MediumSpace':'\u205F','Mellintrf':'\u2133','mfr':'\uD835\uDD2A','Mfr':'\uD835\uDD10','mho':'\u2127','micro':'\xB5','mid':'\u2223','midast':'*','midcir':'\u2AF0','middot':'\xB7','minus':'\u2212','minusb':'\u229F','minusd':'\u2238','minusdu':'\u2A2A','MinusPlus':'\u2213','mlcp':'\u2ADB','mldr':'\u2026','mnplus':'\u2213','models':'\u22A7','mopf':'\uD835\uDD5E','Mopf':'\uD835\uDD44','mp':'\u2213','mscr':'\uD835\uDCC2','Mscr':'\u2133','mstpos':'\u223E','mu':'\u03BC','Mu':'\u039C','multimap':'\u22B8','mumap':'\u22B8','nabla':'\u2207','nacute':'\u0144','Nacute':'\u0143','nang':'\u2220\u20D2','nap':'\u2249','napE':'\u2A70\u0338','napid':'\u224B\u0338','napos':'\u0149','napprox':'\u2249','natur':'\u266E','natural':'\u266E','naturals':'\u2115','nbsp':'\xA0','nbump':'\u224E\u0338','nbumpe':'\u224F\u0338','ncap':'\u2A43','ncaron':'\u0148','Ncaron':'\u0147','ncedil':'\u0146','Ncedil':'\u0145','ncong':'\u2247','ncongdot':'\u2A6D\u0338','ncup':'\u2A42','ncy':'\u043D','Ncy':'\u041D','ndash':'\u2013','ne':'\u2260','nearhk':'\u2924','nearr':'\u2197','neArr':'\u21D7','nearrow':'\u2197','nedot':'\u2250\u0338','NegativeMediumSpace':'\u200B','NegativeThickSpace':'\u200B','NegativeThinSpace':'\u200B','NegativeVeryThinSpace':'\u200B','nequiv':'\u2262','nesear':'\u2928','nesim':'\u2242\u0338','NestedGreaterGreater':'\u226B','NestedLessLess':'\u226A','NewLine':'\n','nexist':'\u2204','nexists':'\u2204','nfr':'\uD835\uDD2B','Nfr':'\uD835\uDD11','nge':'\u2271','ngE':'\u2267\u0338','ngeq':'\u2271','ngeqq':'\u2267\u0338','ngeqslant':'\u2A7E\u0338','nges':'\u2A7E\u0338','nGg':'\u22D9\u0338','ngsim':'\u2275','ngt':'\u226F','nGt':'\u226B\u20D2','ngtr':'\u226F','nGtv':'\u226B\u0338','nharr':'\u21AE','nhArr':'\u21CE','nhpar':'\u2AF2','ni':'\u220B','nis':'\u22FC','nisd':'\u22FA','niv':'\u220B','njcy':'\u045A','NJcy':'\u040A','nlarr':'\u219A','nlArr':'\u21CD','nldr':'\u2025','nle':'\u2270','nlE':'\u2266\u0338','nleftarrow':'\u219A','nLeftarrow':'\u21CD','nleftrightarrow':'\u21AE','nLeftrightarrow':'\u21CE','nleq':'\u2270','nleqq':'\u2266\u0338','nleqslant':'\u2A7D\u0338','nles':'\u2A7D\u0338','nless':'\u226E','nLl':'\u22D8\u0338','nlsim':'\u2274','nlt':'\u226E','nLt':'\u226A\u20D2','nltri':'\u22EA','nltrie':'\u22EC','nLtv':'\u226A\u0338','nmid':'\u2224','NoBreak':'\u2060','NonBreakingSpace':'\xA0','nopf':'\uD835\uDD5F','Nopf':'\u2115','not':'\xAC','Not':'\u2AEC','NotCongruent':'\u2262','NotCupCap':'\u226D','NotDoubleVerticalBar':'\u2226','NotElement':'\u2209','NotEqual':'\u2260','NotEqualTilde':'\u2242\u0338','NotExists':'\u2204','NotGreater':'\u226F','NotGreaterEqual':'\u2271','NotGreaterFullEqual':'\u2267\u0338','NotGreaterGreater':'\u226B\u0338','NotGreaterLess':'\u2279','NotGreaterSlantEqual':'\u2A7E\u0338','NotGreaterTilde':'\u2275','NotHumpDownHump':'\u224E\u0338','NotHumpEqual':'\u224F\u0338','notin':'\u2209','notindot':'\u22F5\u0338','notinE':'\u22F9\u0338','notinva':'\u2209','notinvb':'\u22F7','notinvc':'\u22F6','NotLeftTriangle':'\u22EA','NotLeftTriangleBar':'\u29CF\u0338','NotLeftTriangleEqual':'\u22EC','NotLess':'\u226E','NotLessEqual':'\u2270','NotLessGreater':'\u2278','NotLessLess':'\u226A\u0338','NotLessSlantEqual':'\u2A7D\u0338','NotLessTilde':'\u2274','NotNestedGreaterGreater':'\u2AA2\u0338','NotNestedLessLess':'\u2AA1\u0338','notni':'\u220C','notniva':'\u220C','notnivb':'\u22FE','notnivc':'\u22FD','NotPrecedes':'\u2280','NotPrecedesEqual':'\u2AAF\u0338','NotPrecedesSlantEqual':'\u22E0','NotReverseElement':'\u220C','NotRightTriangle':'\u22EB','NotRightTriangleBar':'\u29D0\u0338','NotRightTriangleEqual':'\u22ED','NotSquareSubset':'\u228F\u0338','NotSquareSubsetEqual':'\u22E2','NotSquareSuperset':'\u2290\u0338','NotSquareSupersetEqual':'\u22E3','NotSubset':'\u2282\u20D2','NotSubsetEqual':'\u2288','NotSucceeds':'\u2281','NotSucceedsEqual':'\u2AB0\u0338','NotSucceedsSlantEqual':'\u22E1','NotSucceedsTilde':'\u227F\u0338','NotSuperset':'\u2283\u20D2','NotSupersetEqual':'\u2289','NotTilde':'\u2241','NotTildeEqual':'\u2244','NotTildeFullEqual':'\u2247','NotTildeTilde':'\u2249','NotVerticalBar':'\u2224','npar':'\u2226','nparallel':'\u2226','nparsl':'\u2AFD\u20E5','npart':'\u2202\u0338','npolint':'\u2A14','npr':'\u2280','nprcue':'\u22E0','npre':'\u2AAF\u0338','nprec':'\u2280','npreceq':'\u2AAF\u0338','nrarr':'\u219B','nrArr':'\u21CF','nrarrc':'\u2933\u0338','nrarrw':'\u219D\u0338','nrightarrow':'\u219B','nRightarrow':'\u21CF','nrtri':'\u22EB','nrtrie':'\u22ED','nsc':'\u2281','nsccue':'\u22E1','nsce':'\u2AB0\u0338','nscr':'\uD835\uDCC3','Nscr':'\uD835\uDCA9','nshortmid':'\u2224','nshortparallel':'\u2226','nsim':'\u2241','nsime':'\u2244','nsimeq':'\u2244','nsmid':'\u2224','nspar':'\u2226','nsqsube':'\u22E2','nsqsupe':'\u22E3','nsub':'\u2284','nsube':'\u2288','nsubE':'\u2AC5\u0338','nsubset':'\u2282\u20D2','nsubseteq':'\u2288','nsubseteqq':'\u2AC5\u0338','nsucc':'\u2281','nsucceq':'\u2AB0\u0338','nsup':'\u2285','nsupe':'\u2289','nsupE':'\u2AC6\u0338','nsupset':'\u2283\u20D2','nsupseteq':'\u2289','nsupseteqq':'\u2AC6\u0338','ntgl':'\u2279','ntilde':'\xF1','Ntilde':'\xD1','ntlg':'\u2278','ntriangleleft':'\u22EA','ntrianglelefteq':'\u22EC','ntriangleright':'\u22EB','ntrianglerighteq':'\u22ED','nu':'\u03BD','Nu':'\u039D','num':'#','numero':'\u2116','numsp':'\u2007','nvap':'\u224D\u20D2','nvdash':'\u22AC','nvDash':'\u22AD','nVdash':'\u22AE','nVDash':'\u22AF','nvge':'\u2265\u20D2','nvgt':'>\u20D2','nvHarr':'\u2904','nvinfin':'\u29DE','nvlArr':'\u2902','nvle':'\u2264\u20D2','nvlt':'<\u20D2','nvltrie':'\u22B4\u20D2','nvrArr':'\u2903','nvrtrie':'\u22B5\u20D2','nvsim':'\u223C\u20D2','nwarhk':'\u2923','nwarr':'\u2196','nwArr':'\u21D6','nwarrow':'\u2196','nwnear':'\u2927','oacute':'\xF3','Oacute':'\xD3','oast':'\u229B','ocir':'\u229A','ocirc':'\xF4','Ocirc':'\xD4','ocy':'\u043E','Ocy':'\u041E','odash':'\u229D','odblac':'\u0151','Odblac':'\u0150','odiv':'\u2A38','odot':'\u2299','odsold':'\u29BC','oelig':'\u0153','OElig':'\u0152','ofcir':'\u29BF','ofr':'\uD835\uDD2C','Ofr':'\uD835\uDD12','ogon':'\u02DB','ograve':'\xF2','Ograve':'\xD2','ogt':'\u29C1','ohbar':'\u29B5','ohm':'\u03A9','oint':'\u222E','olarr':'\u21BA','olcir':'\u29BE','olcross':'\u29BB','oline':'\u203E','olt':'\u29C0','omacr':'\u014D','Omacr':'\u014C','omega':'\u03C9','Omega':'\u03A9','omicron':'\u03BF','Omicron':'\u039F','omid':'\u29B6','ominus':'\u2296','oopf':'\uD835\uDD60','Oopf':'\uD835\uDD46','opar':'\u29B7','OpenCurlyDoubleQuote':'\u201C','OpenCurlyQuote':'\u2018','operp':'\u29B9','oplus':'\u2295','or':'\u2228','Or':'\u2A54','orarr':'\u21BB','ord':'\u2A5D','order':'\u2134','orderof':'\u2134','ordf':'\xAA','ordm':'\xBA','origof':'\u22B6','oror':'\u2A56','orslope':'\u2A57','orv':'\u2A5B','oS':'\u24C8','oscr':'\u2134','Oscr':'\uD835\uDCAA','oslash':'\xF8','Oslash':'\xD8','osol':'\u2298','otilde':'\xF5','Otilde':'\xD5','otimes':'\u2297','Otimes':'\u2A37','otimesas':'\u2A36','ouml':'\xF6','Ouml':'\xD6','ovbar':'\u233D','OverBar':'\u203E','OverBrace':'\u23DE','OverBracket':'\u23B4','OverParenthesis':'\u23DC','par':'\u2225','para':'\xB6','parallel':'\u2225','parsim':'\u2AF3','parsl':'\u2AFD','part':'\u2202','PartialD':'\u2202','pcy':'\u043F','Pcy':'\u041F','percnt':'%','period':'.','permil':'\u2030','perp':'\u22A5','pertenk':'\u2031','pfr':'\uD835\uDD2D','Pfr':'\uD835\uDD13','phi':'\u03C6','Phi':'\u03A6','phiv':'\u03D5','phmmat':'\u2133','phone':'\u260E','pi':'\u03C0','Pi':'\u03A0','pitchfork':'\u22D4','piv':'\u03D6','planck':'\u210F','planckh':'\u210E','plankv':'\u210F','plus':'+','plusacir':'\u2A23','plusb':'\u229E','pluscir':'\u2A22','plusdo':'\u2214','plusdu':'\u2A25','pluse':'\u2A72','PlusMinus':'\xB1','plusmn':'\xB1','plussim':'\u2A26','plustwo':'\u2A27','pm':'\xB1','Poincareplane':'\u210C','pointint':'\u2A15','popf':'\uD835\uDD61','Popf':'\u2119','pound':'\xA3','pr':'\u227A','Pr':'\u2ABB','prap':'\u2AB7','prcue':'\u227C','pre':'\u2AAF','prE':'\u2AB3','prec':'\u227A','precapprox':'\u2AB7','preccurlyeq':'\u227C','Precedes':'\u227A','PrecedesEqual':'\u2AAF','PrecedesSlantEqual':'\u227C','PrecedesTilde':'\u227E','preceq':'\u2AAF','precnapprox':'\u2AB9','precneqq':'\u2AB5','precnsim':'\u22E8','precsim':'\u227E','prime':'\u2032','Prime':'\u2033','primes':'\u2119','prnap':'\u2AB9','prnE':'\u2AB5','prnsim':'\u22E8','prod':'\u220F','Product':'\u220F','profalar':'\u232E','profline':'\u2312','profsurf':'\u2313','prop':'\u221D','Proportion':'\u2237','Proportional':'\u221D','propto':'\u221D','prsim':'\u227E','prurel':'\u22B0','pscr':'\uD835\uDCC5','Pscr':'\uD835\uDCAB','psi':'\u03C8','Psi':'\u03A8','puncsp':'\u2008','qfr':'\uD835\uDD2E','Qfr':'\uD835\uDD14','qint':'\u2A0C','qopf':'\uD835\uDD62','Qopf':'\u211A','qprime':'\u2057','qscr':'\uD835\uDCC6','Qscr':'\uD835\uDCAC','quaternions':'\u210D','quatint':'\u2A16','quest':'?','questeq':'\u225F','quot':'"','QUOT':'"','rAarr':'\u21DB','race':'\u223D\u0331','racute':'\u0155','Racute':'\u0154','radic':'\u221A','raemptyv':'\u29B3','rang':'\u27E9','Rang':'\u27EB','rangd':'\u2992','range':'\u29A5','rangle':'\u27E9','raquo':'\xBB','rarr':'\u2192','rArr':'\u21D2','Rarr':'\u21A0','rarrap':'\u2975','rarrb':'\u21E5','rarrbfs':'\u2920','rarrc':'\u2933','rarrfs':'\u291E','rarrhk':'\u21AA','rarrlp':'\u21AC','rarrpl':'\u2945','rarrsim':'\u2974','rarrtl':'\u21A3','Rarrtl':'\u2916','rarrw':'\u219D','ratail':'\u291A','rAtail':'\u291C','ratio':'\u2236','rationals':'\u211A','rbarr':'\u290D','rBarr':'\u290F','RBarr':'\u2910','rbbrk':'\u2773','rbrace':'}','rbrack':']','rbrke':'\u298C','rbrksld':'\u298E','rbrkslu':'\u2990','rcaron':'\u0159','Rcaron':'\u0158','rcedil':'\u0157','Rcedil':'\u0156','rceil':'\u2309','rcub':'}','rcy':'\u0440','Rcy':'\u0420','rdca':'\u2937','rdldhar':'\u2969','rdquo':'\u201D','rdquor':'\u201D','rdsh':'\u21B3','Re':'\u211C','real':'\u211C','realine':'\u211B','realpart':'\u211C','reals':'\u211D','rect':'\u25AD','reg':'\xAE','REG':'\xAE','ReverseElement':'\u220B','ReverseEquilibrium':'\u21CB','ReverseUpEquilibrium':'\u296F','rfisht':'\u297D','rfloor':'\u230B','rfr':'\uD835\uDD2F','Rfr':'\u211C','rHar':'\u2964','rhard':'\u21C1','rharu':'\u21C0','rharul':'\u296C','rho':'\u03C1','Rho':'\u03A1','rhov':'\u03F1','RightAngleBracket':'\u27E9','rightarrow':'\u2192','Rightarrow':'\u21D2','RightArrow':'\u2192','RightArrowBar':'\u21E5','RightArrowLeftArrow':'\u21C4','rightarrowtail':'\u21A3','RightCeiling':'\u2309','RightDoubleBracket':'\u27E7','RightDownTeeVector':'\u295D','RightDownVector':'\u21C2','RightDownVectorBar':'\u2955','RightFloor':'\u230B','rightharpoondown':'\u21C1','rightharpoonup':'\u21C0','rightleftarrows':'\u21C4','rightleftharpoons':'\u21CC','rightrightarrows':'\u21C9','rightsquigarrow':'\u219D','RightTee':'\u22A2','RightTeeArrow':'\u21A6','RightTeeVector':'\u295B','rightthreetimes':'\u22CC','RightTriangle':'\u22B3','RightTriangleBar':'\u29D0','RightTriangleEqual':'\u22B5','RightUpDownVector':'\u294F','RightUpTeeVector':'\u295C','RightUpVector':'\u21BE','RightUpVectorBar':'\u2954','RightVector':'\u21C0','RightVectorBar':'\u2953','ring':'\u02DA','risingdotseq':'\u2253','rlarr':'\u21C4','rlhar':'\u21CC','rlm':'\u200F','rmoust':'\u23B1','rmoustache':'\u23B1','rnmid':'\u2AEE','roang':'\u27ED','roarr':'\u21FE','robrk':'\u27E7','ropar':'\u2986','ropf':'\uD835\uDD63','Ropf':'\u211D','roplus':'\u2A2E','rotimes':'\u2A35','RoundImplies':'\u2970','rpar':')','rpargt':'\u2994','rppolint':'\u2A12','rrarr':'\u21C9','Rrightarrow':'\u21DB','rsaquo':'\u203A','rscr':'\uD835\uDCC7','Rscr':'\u211B','rsh':'\u21B1','Rsh':'\u21B1','rsqb':']','rsquo':'\u2019','rsquor':'\u2019','rthree':'\u22CC','rtimes':'\u22CA','rtri':'\u25B9','rtrie':'\u22B5','rtrif':'\u25B8','rtriltri':'\u29CE','RuleDelayed':'\u29F4','ruluhar':'\u2968','rx':'\u211E','sacute':'\u015B','Sacute':'\u015A','sbquo':'\u201A','sc':'\u227B','Sc':'\u2ABC','scap':'\u2AB8','scaron':'\u0161','Scaron':'\u0160','sccue':'\u227D','sce':'\u2AB0','scE':'\u2AB4','scedil':'\u015F','Scedil':'\u015E','scirc':'\u015D','Scirc':'\u015C','scnap':'\u2ABA','scnE':'\u2AB6','scnsim':'\u22E9','scpolint':'\u2A13','scsim':'\u227F','scy':'\u0441','Scy':'\u0421','sdot':'\u22C5','sdotb':'\u22A1','sdote':'\u2A66','searhk':'\u2925','searr':'\u2198','seArr':'\u21D8','searrow':'\u2198','sect':'\xA7','semi':';','seswar':'\u2929','setminus':'\u2216','setmn':'\u2216','sext':'\u2736','sfr':'\uD835\uDD30','Sfr':'\uD835\uDD16','sfrown':'\u2322','sharp':'\u266F','shchcy':'\u0449','SHCHcy':'\u0429','shcy':'\u0448','SHcy':'\u0428','ShortDownArrow':'\u2193','ShortLeftArrow':'\u2190','shortmid':'\u2223','shortparallel':'\u2225','ShortRightArrow':'\u2192','ShortUpArrow':'\u2191','shy':'\xAD','sigma':'\u03C3','Sigma':'\u03A3','sigmaf':'\u03C2','sigmav':'\u03C2','sim':'\u223C','simdot':'\u2A6A','sime':'\u2243','simeq':'\u2243','simg':'\u2A9E','simgE':'\u2AA0','siml':'\u2A9D','simlE':'\u2A9F','simne':'\u2246','simplus':'\u2A24','simrarr':'\u2972','slarr':'\u2190','SmallCircle':'\u2218','smallsetminus':'\u2216','smashp':'\u2A33','smeparsl':'\u29E4','smid':'\u2223','smile':'\u2323','smt':'\u2AAA','smte':'\u2AAC','smtes':'\u2AAC\uFE00','softcy':'\u044C','SOFTcy':'\u042C','sol':'/','solb':'\u29C4','solbar':'\u233F','sopf':'\uD835\uDD64','Sopf':'\uD835\uDD4A','spades':'\u2660','spadesuit':'\u2660','spar':'\u2225','sqcap':'\u2293','sqcaps':'\u2293\uFE00','sqcup':'\u2294','sqcups':'\u2294\uFE00','Sqrt':'\u221A','sqsub':'\u228F','sqsube':'\u2291','sqsubset':'\u228F','sqsubseteq':'\u2291','sqsup':'\u2290','sqsupe':'\u2292','sqsupset':'\u2290','sqsupseteq':'\u2292','squ':'\u25A1','square':'\u25A1','Square':'\u25A1','SquareIntersection':'\u2293','SquareSubset':'\u228F','SquareSubsetEqual':'\u2291','SquareSuperset':'\u2290','SquareSupersetEqual':'\u2292','SquareUnion':'\u2294','squarf':'\u25AA','squf':'\u25AA','srarr':'\u2192','sscr':'\uD835\uDCC8','Sscr':'\uD835\uDCAE','ssetmn':'\u2216','ssmile':'\u2323','sstarf':'\u22C6','star':'\u2606','Star':'\u22C6','starf':'\u2605','straightepsilon':'\u03F5','straightphi':'\u03D5','strns':'\xAF','sub':'\u2282','Sub':'\u22D0','subdot':'\u2ABD','sube':'\u2286','subE':'\u2AC5','subedot':'\u2AC3','submult':'\u2AC1','subne':'\u228A','subnE':'\u2ACB','subplus':'\u2ABF','subrarr':'\u2979','subset':'\u2282','Subset':'\u22D0','subseteq':'\u2286','subseteqq':'\u2AC5','SubsetEqual':'\u2286','subsetneq':'\u228A','subsetneqq':'\u2ACB','subsim':'\u2AC7','subsub':'\u2AD5','subsup':'\u2AD3','succ':'\u227B','succapprox':'\u2AB8','succcurlyeq':'\u227D','Succeeds':'\u227B','SucceedsEqual':'\u2AB0','SucceedsSlantEqual':'\u227D','SucceedsTilde':'\u227F','succeq':'\u2AB0','succnapprox':'\u2ABA','succneqq':'\u2AB6','succnsim':'\u22E9','succsim':'\u227F','SuchThat':'\u220B','sum':'\u2211','Sum':'\u2211','sung':'\u266A','sup':'\u2283','Sup':'\u22D1','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','supdot':'\u2ABE','supdsub':'\u2AD8','supe':'\u2287','supE':'\u2AC6','supedot':'\u2AC4','Superset':'\u2283','SupersetEqual':'\u2287','suphsol':'\u27C9','suphsub':'\u2AD7','suplarr':'\u297B','supmult':'\u2AC2','supne':'\u228B','supnE':'\u2ACC','supplus':'\u2AC0','supset':'\u2283','Supset':'\u22D1','supseteq':'\u2287','supseteqq':'\u2AC6','supsetneq':'\u228B','supsetneqq':'\u2ACC','supsim':'\u2AC8','supsub':'\u2AD4','supsup':'\u2AD6','swarhk':'\u2926','swarr':'\u2199','swArr':'\u21D9','swarrow':'\u2199','swnwar':'\u292A','szlig':'\xDF','Tab':'\t','target':'\u2316','tau':'\u03C4','Tau':'\u03A4','tbrk':'\u23B4','tcaron':'\u0165','Tcaron':'\u0164','tcedil':'\u0163','Tcedil':'\u0162','tcy':'\u0442','Tcy':'\u0422','tdot':'\u20DB','telrec':'\u2315','tfr':'\uD835\uDD31','Tfr':'\uD835\uDD17','there4':'\u2234','therefore':'\u2234','Therefore':'\u2234','theta':'\u03B8','Theta':'\u0398','thetasym':'\u03D1','thetav':'\u03D1','thickapprox':'\u2248','thicksim':'\u223C','ThickSpace':'\u205F\u200A','thinsp':'\u2009','ThinSpace':'\u2009','thkap':'\u2248','thksim':'\u223C','thorn':'\xFE','THORN':'\xDE','tilde':'\u02DC','Tilde':'\u223C','TildeEqual':'\u2243','TildeFullEqual':'\u2245','TildeTilde':'\u2248','times':'\xD7','timesb':'\u22A0','timesbar':'\u2A31','timesd':'\u2A30','tint':'\u222D','toea':'\u2928','top':'\u22A4','topbot':'\u2336','topcir':'\u2AF1','topf':'\uD835\uDD65','Topf':'\uD835\uDD4B','topfork':'\u2ADA','tosa':'\u2929','tprime':'\u2034','trade':'\u2122','TRADE':'\u2122','triangle':'\u25B5','triangledown':'\u25BF','triangleleft':'\u25C3','trianglelefteq':'\u22B4','triangleq':'\u225C','triangleright':'\u25B9','trianglerighteq':'\u22B5','tridot':'\u25EC','trie':'\u225C','triminus':'\u2A3A','TripleDot':'\u20DB','triplus':'\u2A39','trisb':'\u29CD','tritime':'\u2A3B','trpezium':'\u23E2','tscr':'\uD835\uDCC9','Tscr':'\uD835\uDCAF','tscy':'\u0446','TScy':'\u0426','tshcy':'\u045B','TSHcy':'\u040B','tstrok':'\u0167','Tstrok':'\u0166','twixt':'\u226C','twoheadleftarrow':'\u219E','twoheadrightarrow':'\u21A0','uacute':'\xFA','Uacute':'\xDA','uarr':'\u2191','uArr':'\u21D1','Uarr':'\u219F','Uarrocir':'\u2949','ubrcy':'\u045E','Ubrcy':'\u040E','ubreve':'\u016D','Ubreve':'\u016C','ucirc':'\xFB','Ucirc':'\xDB','ucy':'\u0443','Ucy':'\u0423','udarr':'\u21C5','udblac':'\u0171','Udblac':'\u0170','udhar':'\u296E','ufisht':'\u297E','ufr':'\uD835\uDD32','Ufr':'\uD835\uDD18','ugrave':'\xF9','Ugrave':'\xD9','uHar':'\u2963','uharl':'\u21BF','uharr':'\u21BE','uhblk':'\u2580','ulcorn':'\u231C','ulcorner':'\u231C','ulcrop':'\u230F','ultri':'\u25F8','umacr':'\u016B','Umacr':'\u016A','uml':'\xA8','UnderBar':'_','UnderBrace':'\u23DF','UnderBracket':'\u23B5','UnderParenthesis':'\u23DD','Union':'\u22C3','UnionPlus':'\u228E','uogon':'\u0173','Uogon':'\u0172','uopf':'\uD835\uDD66','Uopf':'\uD835\uDD4C','uparrow':'\u2191','Uparrow':'\u21D1','UpArrow':'\u2191','UpArrowBar':'\u2912','UpArrowDownArrow':'\u21C5','updownarrow':'\u2195','Updownarrow':'\u21D5','UpDownArrow':'\u2195','UpEquilibrium':'\u296E','upharpoonleft':'\u21BF','upharpoonright':'\u21BE','uplus':'\u228E','UpperLeftArrow':'\u2196','UpperRightArrow':'\u2197','upsi':'\u03C5','Upsi':'\u03D2','upsih':'\u03D2','upsilon':'\u03C5','Upsilon':'\u03A5','UpTee':'\u22A5','UpTeeArrow':'\u21A5','upuparrows':'\u21C8','urcorn':'\u231D','urcorner':'\u231D','urcrop':'\u230E','uring':'\u016F','Uring':'\u016E','urtri':'\u25F9','uscr':'\uD835\uDCCA','Uscr':'\uD835\uDCB0','utdot':'\u22F0','utilde':'\u0169','Utilde':'\u0168','utri':'\u25B5','utrif':'\u25B4','uuarr':'\u21C8','uuml':'\xFC','Uuml':'\xDC','uwangle':'\u29A7','vangrt':'\u299C','varepsilon':'\u03F5','varkappa':'\u03F0','varnothing':'\u2205','varphi':'\u03D5','varpi':'\u03D6','varpropto':'\u221D','varr':'\u2195','vArr':'\u21D5','varrho':'\u03F1','varsigma':'\u03C2','varsubsetneq':'\u228A\uFE00','varsubsetneqq':'\u2ACB\uFE00','varsupsetneq':'\u228B\uFE00','varsupsetneqq':'\u2ACC\uFE00','vartheta':'\u03D1','vartriangleleft':'\u22B2','vartriangleright':'\u22B3','vBar':'\u2AE8','Vbar':'\u2AEB','vBarv':'\u2AE9','vcy':'\u0432','Vcy':'\u0412','vdash':'\u22A2','vDash':'\u22A8','Vdash':'\u22A9','VDash':'\u22AB','Vdashl':'\u2AE6','vee':'\u2228','Vee':'\u22C1','veebar':'\u22BB','veeeq':'\u225A','vellip':'\u22EE','verbar':'|','Verbar':'\u2016','vert':'|','Vert':'\u2016','VerticalBar':'\u2223','VerticalLine':'|','VerticalSeparator':'\u2758','VerticalTilde':'\u2240','VeryThinSpace':'\u200A','vfr':'\uD835\uDD33','Vfr':'\uD835\uDD19','vltri':'\u22B2','vnsub':'\u2282\u20D2','vnsup':'\u2283\u20D2','vopf':'\uD835\uDD67','Vopf':'\uD835\uDD4D','vprop':'\u221D','vrtri':'\u22B3','vscr':'\uD835\uDCCB','Vscr':'\uD835\uDCB1','vsubne':'\u228A\uFE00','vsubnE':'\u2ACB\uFE00','vsupne':'\u228B\uFE00','vsupnE':'\u2ACC\uFE00','Vvdash':'\u22AA','vzigzag':'\u299A','wcirc':'\u0175','Wcirc':'\u0174','wedbar':'\u2A5F','wedge':'\u2227','Wedge':'\u22C0','wedgeq':'\u2259','weierp':'\u2118','wfr':'\uD835\uDD34','Wfr':'\uD835\uDD1A','wopf':'\uD835\uDD68','Wopf':'\uD835\uDD4E','wp':'\u2118','wr':'\u2240','wreath':'\u2240','wscr':'\uD835\uDCCC','Wscr':'\uD835\uDCB2','xcap':'\u22C2','xcirc':'\u25EF','xcup':'\u22C3','xdtri':'\u25BD','xfr':'\uD835\uDD35','Xfr':'\uD835\uDD1B','xharr':'\u27F7','xhArr':'\u27FA','xi':'\u03BE','Xi':'\u039E','xlarr':'\u27F5','xlArr':'\u27F8','xmap':'\u27FC','xnis':'\u22FB','xodot':'\u2A00','xopf':'\uD835\uDD69','Xopf':'\uD835\uDD4F','xoplus':'\u2A01','xotime':'\u2A02','xrarr':'\u27F6','xrArr':'\u27F9','xscr':'\uD835\uDCCD','Xscr':'\uD835\uDCB3','xsqcup':'\u2A06','xuplus':'\u2A04','xutri':'\u25B3','xvee':'\u22C1','xwedge':'\u22C0','yacute':'\xFD','Yacute':'\xDD','yacy':'\u044F','YAcy':'\u042F','ycirc':'\u0177','Ycirc':'\u0176','ycy':'\u044B','Ycy':'\u042B','yen':'\xA5','yfr':'\uD835\uDD36','Yfr':'\uD835\uDD1C','yicy':'\u0457','YIcy':'\u0407','yopf':'\uD835\uDD6A','Yopf':'\uD835\uDD50','yscr':'\uD835\uDCCE','Yscr':'\uD835\uDCB4','yucy':'\u044E','YUcy':'\u042E','yuml':'\xFF','Yuml':'\u0178','zacute':'\u017A','Zacute':'\u0179','zcaron':'\u017E','Zcaron':'\u017D','zcy':'\u0437','Zcy':'\u0417','zdot':'\u017C','Zdot':'\u017B','zeetrf':'\u2128','ZeroWidthSpace':'\u200B','zeta':'\u03B6','Zeta':'\u0396','zfr':'\uD835\uDD37','Zfr':'\u2128','zhcy':'\u0436','ZHcy':'\u0416','zigrarr':'\u21DD','zopf':'\uD835\uDD6B','Zopf':'\u2124','zscr':'\uD835\uDCCF','Zscr':'\uD835\uDCB5','zwj':'\u200D','zwnj':'\u200C'};
	var decodeMapLegacy = {'aacute':'\xE1','Aacute':'\xC1','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','aelig':'\xE6','AElig':'\xC6','agrave':'\xE0','Agrave':'\xC0','amp':'&','AMP':'&','aring':'\xE5','Aring':'\xC5','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','brvbar':'\xA6','ccedil':'\xE7','Ccedil':'\xC7','cedil':'\xB8','cent':'\xA2','copy':'\xA9','COPY':'\xA9','curren':'\xA4','deg':'\xB0','divide':'\xF7','eacute':'\xE9','Eacute':'\xC9','ecirc':'\xEA','Ecirc':'\xCA','egrave':'\xE8','Egrave':'\xC8','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','frac12':'\xBD','frac14':'\xBC','frac34':'\xBE','gt':'>','GT':'>','iacute':'\xED','Iacute':'\xCD','icirc':'\xEE','Icirc':'\xCE','iexcl':'\xA1','igrave':'\xEC','Igrave':'\xCC','iquest':'\xBF','iuml':'\xEF','Iuml':'\xCF','laquo':'\xAB','lt':'<','LT':'<','macr':'\xAF','micro':'\xB5','middot':'\xB7','nbsp':'\xA0','not':'\xAC','ntilde':'\xF1','Ntilde':'\xD1','oacute':'\xF3','Oacute':'\xD3','ocirc':'\xF4','Ocirc':'\xD4','ograve':'\xF2','Ograve':'\xD2','ordf':'\xAA','ordm':'\xBA','oslash':'\xF8','Oslash':'\xD8','otilde':'\xF5','Otilde':'\xD5','ouml':'\xF6','Ouml':'\xD6','para':'\xB6','plusmn':'\xB1','pound':'\xA3','quot':'"','QUOT':'"','raquo':'\xBB','reg':'\xAE','REG':'\xAE','sect':'\xA7','shy':'\xAD','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','szlig':'\xDF','thorn':'\xFE','THORN':'\xDE','times':'\xD7','uacute':'\xFA','Uacute':'\xDA','ucirc':'\xFB','Ucirc':'\xDB','ugrave':'\xF9','Ugrave':'\xD9','uml':'\xA8','uuml':'\xFC','Uuml':'\xDC','yacute':'\xFD','Yacute':'\xDD','yen':'\xA5','yuml':'\xFF'};
	var decodeMapNumeric = {'0':'\uFFFD','128':'\u20AC','130':'\u201A','131':'\u0192','132':'\u201E','133':'\u2026','134':'\u2020','135':'\u2021','136':'\u02C6','137':'\u2030','138':'\u0160','139':'\u2039','140':'\u0152','142':'\u017D','145':'\u2018','146':'\u2019','147':'\u201C','148':'\u201D','149':'\u2022','150':'\u2013','151':'\u2014','152':'\u02DC','153':'\u2122','154':'\u0161','155':'\u203A','156':'\u0153','158':'\u017E','159':'\u0178'};
	var invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	var object = {};
	var hasOwnProperty = object.hasOwnProperty;
	var has = function(object, propertyName) {
		return hasOwnProperty.call(object, propertyName);
	};

	var contains = function(array, value) {
		var index = -1;
		var length = array.length;
		while (++index < length) {
			if (array[index] == value) {
				return true;
			}
		}
		return false;
	};

	var merge = function(options, defaults) {
		if (!options) {
			return defaults;
		}
		var result = {};
		var key;
		for (key in defaults) {
			// A `hasOwnProperty` check is not needed here, since only recognized
			// option names are used anyway. Any others are ignored.
			result[key] = has(options, key) ? options[key] : defaults[key];
		}
		return result;
	};

	// Modified version of `ucs2encode`; see https://mths.be/punycode.
	var codePointToSymbol = function(codePoint, strict) {
		var output = '';
		if ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {
			// See issue #4:
			// Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
			// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
			// REPLACEMENT CHARACTER.
			if (strict) {
				parseError('character reference outside the permissible Unicode range');
			}
			return '\uFFFD';
		}
		if (has(decodeMapNumeric, codePoint)) {
			if (strict) {
				parseError('disallowed character reference');
			}
			return decodeMapNumeric[codePoint];
		}
		if (strict && contains(invalidReferenceCodePoints, codePoint)) {
			parseError('disallowed character reference');
		}
		if (codePoint > 0xFFFF) {
			codePoint -= 0x10000;
			output += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
			codePoint = 0xDC00 | codePoint & 0x3FF;
		}
		output += stringFromCharCode(codePoint);
		return output;
	};

	var hexEscape = function(codePoint) {
		return '&#x' + codePoint.toString(16).toUpperCase() + ';';
	};

	var decEscape = function(codePoint) {
		return '&#' + codePoint + ';';
	};

	var parseError = function(message) {
		throw Error('Parse error: ' + message);
	};

	/*--------------------------------------------------------------------------*/

	var encode = function(string, options) {
		options = merge(options, encode.options);
		var strict = options.strict;
		if (strict && regexInvalidRawCodePoint.test(string)) {
			parseError('forbidden code point');
		}
		var encodeEverything = options.encodeEverything;
		var useNamedReferences = options.useNamedReferences;
		var allowUnsafeSymbols = options.allowUnsafeSymbols;
		var escapeCodePoint = options.decimal ? decEscape : hexEscape;

		var escapeBmpSymbol = function(symbol) {
			return escapeCodePoint(symbol.charCodeAt(0));
		};

		if (encodeEverything) {
			// Encode ASCII symbols.
			string = string.replace(regexAsciiWhitelist, function(symbol) {
				// Use named references if requested & possible.
				if (useNamedReferences && has(encodeMap, symbol)) {
					return '&' + encodeMap[symbol] + ';';
				}
				return escapeBmpSymbol(symbol);
			});
			// Shorten a few escapes that represent two symbols, of which at least one
			// is within the ASCII range.
			if (useNamedReferences) {
				string = string
					.replace(/&gt;\u20D2/g, '&nvgt;')
					.replace(/&lt;\u20D2/g, '&nvlt;')
					.replace(/&#x66;&#x6A;/g, '&fjlig;');
			}
			// Encode non-ASCII symbols.
			if (useNamedReferences) {
				// Encode non-ASCII symbols that can be replaced with a named reference.
				string = string.replace(regexEncodeNonAscii, function(string) {
					// Note: there is no need to check `has(encodeMap, string)` here.
					return '&' + encodeMap[string] + ';';
				});
			}
			// Note: any remaining non-ASCII symbols are handled outside of the `if`.
		} else if (useNamedReferences) {
			// Apply named character references.
			// Encode `<>"'&` using named character references.
			if (!allowUnsafeSymbols) {
				string = string.replace(regexEscape, function(string) {
					return '&' + encodeMap[string] + ';'; // no need to check `has()` here
				});
			}
			// Shorten escapes that represent two symbols, of which at least one is
			// `<>"'&`.
			string = string
				.replace(/&gt;\u20D2/g, '&nvgt;')
				.replace(/&lt;\u20D2/g, '&nvlt;');
			// Encode non-ASCII symbols that can be replaced with a named reference.
			string = string.replace(regexEncodeNonAscii, function(string) {
				// Note: there is no need to check `has(encodeMap, string)` here.
				return '&' + encodeMap[string] + ';';
			});
		} else if (!allowUnsafeSymbols) {
			// Encode `<>"'&` using hexadecimal escapes, now that theyre not handled
			// using named character references.
			string = string.replace(regexEscape, escapeBmpSymbol);
		}
		return string
			// Encode astral symbols.
			.replace(regexAstralSymbols, function($0) {
				// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
				var high = $0.charCodeAt(0);
				var low = $0.charCodeAt(1);
				var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
				return escapeCodePoint(codePoint);
			})
			// Encode any remaining BMP symbols that are not printable ASCII symbols
			// using a hexadecimal escape.
			.replace(regexBmpWhitelist, escapeBmpSymbol);
	};
	// Expose default options (so they can be overridden globally).
	encode.options = {
		'allowUnsafeSymbols': false,
		'encodeEverything': false,
		'strict': false,
		'useNamedReferences': false,
		'decimal' : false
	};

	var decode = function(html, options) {
		options = merge(options, decode.options);
		var strict = options.strict;
		if (strict && regexInvalidEntity.test(html)) {
			parseError('malformed character reference');
		}
		return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
			var codePoint;
			var semicolon;
			var decDigits;
			var hexDigits;
			var reference;
			var next;

			if ($1) {
				reference = $1;
				// Note: there is no need to check `has(decodeMap, reference)`.
				return decodeMap[reference];
			}

			if ($2) {
				// Decode named character references without trailing `;`, e.g. `&amp`.
				// This is only a parse error if it gets converted to `&`, or if it is
				// followed by `=` in an attribute context.
				reference = $2;
				next = $3;
				if (next && options.isAttributeValue) {
					if (strict && next == '=') {
						parseError('`&` did not start a character reference');
					}
					return $0;
				} else {
					if (strict) {
						parseError(
							'named character reference was not terminated by a semicolon'
						);
					}
					// Note: there is no need to check `has(decodeMapLegacy, reference)`.
					return decodeMapLegacy[reference] + (next || '');
				}
			}

			if ($4) {
				// Decode decimal escapes, e.g. `&#119558;`.
				decDigits = $4;
				semicolon = $5;
				if (strict && !semicolon) {
					parseError('character reference was not terminated by a semicolon');
				}
				codePoint = parseInt(decDigits, 10);
				return codePointToSymbol(codePoint, strict);
			}

			if ($6) {
				// Decode hexadecimal escapes, e.g. `&#x1D306;`.
				hexDigits = $6;
				semicolon = $7;
				if (strict && !semicolon) {
					parseError('character reference was not terminated by a semicolon');
				}
				codePoint = parseInt(hexDigits, 16);
				return codePointToSymbol(codePoint, strict);
			}

			// If were still here, `if ($7)` is implied; its an ambiguous
			// ampersand for sure. https://mths.be/notes/ambiguous-ampersands
			if (strict) {
				parseError(
					'named character reference was not terminated by a semicolon'
				);
			}
			return $0;
		});
	};
	// Expose default options (so they can be overridden globally).
	decode.options = {
		'isAttributeValue': false,
		'strict': false
	};

	var escape = function(string) {
		return string.replace(regexEscape, function($0) {
			// Note: there is no need to check `has(escapeMap, $0)` here.
			return escapeMap[$0];
		});
	};

	/*--------------------------------------------------------------------------*/

	var he = {
		'version': '1.2.0',
		'encode': encode,
		'decode': decode,
		'escape': escape,
		'unescape': decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return he;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = he;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (var key in he) {
				has(he, key) && (freeExports[key] = he[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.he = he;
	}

}(this));
;!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.rrule=e():t.rrule=e()}("undefined"!=typeof self?self:this,function(){return r={},i.m=n=[function(t,e,n){"use strict";n.d(e,"f",function(){return i}),n.d(e,"e",function(){return a}),n.d(e,"g",function(){return o}),n.d(e,"d",function(){return s}),n.d(e,"k",function(){return u}),n.d(e,"l",function(){return c}),n.d(e,"n",function(){return h}),n.d(e,"i",function(){return d}),n.d(e,"m",function(){return y}),n.d(e,"j",function(){return l}),n.d(e,"a",function(){return f}),n.d(e,"b",function(){return b}),n.d(e,"h",function(){return p}),n.d(e,"c",function(){return m});var r=n(2),i=function(t){return null!=t},a=function(t){return"number"==typeof t},o=function(t){return 0<=r.a.indexOf(t)},s=Array.isArray,u=function(t,e){void 0===e&&(e=t),1===arguments.length&&(e=t,t=0);for(var n=[],r=t;r<e;r++)n.push(r);return n},c=function(t,e){var n=0,r=[];if(s(t))for(;n<e;n++)r[n]=[].concat(t);else for(;n<e;n++)r[n]=t;return r},h=function(t){return s(t)?t:[t]};function d(t,e,n){void 0===n&&(n=" ");var r=String(t);return e>>=0,r.length>e?String(r):((e-=r.length)>n.length&&(n+=c(n,e/n.length)),n.slice(0,e)+String(r))}var y=function(t,e,n){var r=t.split(e);return n?r.slice(0,n).concat([r.slice(n).join(e)]):r},l=function(t,e){var n=t%e;return n*e<0?n+e:n},f=function(t,e){return{div:Math.floor(t/e),mod:l(t,e)}},b=function(t){return!i(t)||0===t.length},p=function(t){return!b(t)},m=function(t,e){return p(t)&&-1!==t.indexOf(e)}},function(t,e,n){"use strict";n.r(e);var r,i,x=n(0);(i=r=r||{}).MONTH_DAYS=[31,28,31,30,31,30,31,31,30,31,30,31],i.ONE_DAY=864e5,i.MAXYEAR=9999,i.ORDINAL_BASE=new Date(Date.UTC(1970,0,1)),i.PY_WEEKDAYS=[6,0,1,2,3,4,5],i.getYearDay=function(t){var e=new Date(t.getUTCFullYear(),t.getUTCMonth(),t.getUTCDate());return Math.ceil((e.valueOf()-new Date(t.getUTCFullYear(),0,1).valueOf())/i.ONE_DAY)+1},i.isLeapYear=function(t){return t%4==0&&t%100!=0||t%400==0},i.isDate=function(t){return t instanceof Date},i.isValidDate=function(t){return i.isDate(t)&&!isNaN(t.getTime())},i.tzOffset=function(t){return 60*t.getTimezoneOffset()*1e3},i.daysBetween=function(t,e){var n=t.getTime()-i.tzOffset(t)-(e.getTime()-i.tzOffset(e));return Math.round(n/i.ONE_DAY)},i.toOrdinal=function(t){return i.daysBetween(t,i.ORDINAL_BASE)},i.fromOrdinal=function(t){return new Date(i.ORDINAL_BASE.getTime()+t*i.ONE_DAY)},i.getMonthDays=function(t){var e=t.getUTCMonth();return 1===e&&i.isLeapYear(t.getUTCFullYear())?29:i.MONTH_DAYS[e]},i.getWeekday=function(t){return i.PY_WEEKDAYS[t.getUTCDay()]},i.monthRange=function(t,e){var n=new Date(Date.UTC(t,e,1));return[i.getWeekday(n),i.getMonthDays(n)]},i.combine=function(t,e){return e=e||t,new Date(Date.UTC(t.getUTCFullYear(),t.getUTCMonth(),t.getUTCDate(),e.getHours(),e.getMinutes(),e.getSeconds(),e.getMilliseconds()))},i.clone=function(t){return new Date(t.getTime())},i.cloneDates=function(t){for(var e=[],n=0;n<t.length;n++)e.push(i.clone(t[n]));return e},i.sort=function(t){t.sort(function(t,e){return t.getTime()-e.getTime()})},i.timeToUntilString=function(t,e){void 0===e&&(e=!0);var n=new Date(t);return[Object(x.i)(n.getUTCFullYear().toString(),4,"0"),Object(x.i)(n.getUTCMonth()+1,2,"0"),Object(x.i)(n.getUTCDate(),2,"0"),"T",Object(x.i)(n.getUTCHours(),2,"0"),Object(x.i)(n.getUTCMinutes(),2,"0"),Object(x.i)(n.getUTCSeconds(),2,"0"),e?"Z":""].join("")},i.untilStringToDate=function(t){var e=/^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/.exec(t);if(!e)throw new Error("Invalid UNTIL value: "+t);return new Date(Date.UTC(parseInt(e[1],10),parseInt(e[2],10)-1,parseInt(e[3],10),parseInt(e[5],10)||0,parseInt(e[6],10)||0,parseInt(e[7],10)||0))};var Y=r;function a(t,e){this.minDate=null,this.maxDate=null,this._result=[],this.total=0,this.method=t,this.args=e,"between"===t?(this.maxDate=e.inc?e.before:new Date(e.before.getTime()-1),this.minDate=e.inc?e.after:new Date(e.after.getTime()+1)):"before"===t?this.maxDate=e.inc?e.dt:new Date(e.dt.getTime()-1):"after"===t&&(this.minDate=e.inc?e.dt:new Date(e.dt.getTime()+1))}var c=(a.prototype.accept=function(t){++this.total;var e=this.minDate&&t<this.minDate,n=this.maxDate&&t>this.maxDate;if("between"===this.method){if(e)return!0;if(n)return!1}else if("before"===this.method){if(n)return!1}else if("after"===this.method)return!!e||(this.add(t),!1);return this.add(t)},a.prototype.add=function(t){return this._result.push(t),!0},a.prototype.getValue=function(){var t=this._result;switch(this.method){case"all":case"between":return t;case"before":case"after":default:return t.length?t[t.length-1]:null}},a.prototype.clone=function(){return new a(this.method,this.args)},a),o=function(t,e){return(o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(t,e)};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */function s(t,e){function n(){this.constructor=t}o(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}var u,S=function(){return(S=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var i in e=arguments[n])Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);return t}).apply(this,arguments)};function h(){for(var t=0,e=0,n=arguments.length;e<n;e++)t+=arguments[e].length;var r=Array(t),i=0;for(e=0;e<n;e++)for(var a=arguments[e],o=0,s=a.length;o<s;o++,i++)r[i]=a[o];return r}function d(t,e,n){var r=u.call(this,t,e)||this;return r.iterator=n,r}var y,l,f=(s(d,u=c),d.prototype.add=function(t){return!!this.iterator(t,this._result.length)&&(this._result.push(t),!0)},d);function j(t){return t<y.HOURLY}(l=y=y||{})[l.YEARLY=0]="YEARLY",l[l.MONTHLY=1]="MONTHLY",l[l.WEEKLY=2]="WEEKLY",l[l.DAILY=3]="DAILY",l[l.HOURLY=4]="HOURLY",l[l.MINUTELY=5]="MINUTELY",l[l.SECONDLY=6]="SECONDLY";var b=n(2),T=(p.prototype.getHours=function(){return this.hour},p.prototype.getMinutes=function(){return this.minute},p.prototype.getSeconds=function(){return this.second},p.prototype.getMilliseconds=function(){return this.millisecond},p.prototype.getTime=function(){return 1e3*(60*this.hour*60+60*this.minute+this.second)+this.millisecond},p);function p(t,e,n,r){this.hour=t,this.minute=e,this.second=n,this.millisecond=r||0}var m,D=(s(w,m=T),w.fromDate=function(t){return new this(t.getUTCFullYear(),t.getUTCMonth()+1,t.getUTCDate(),t.getUTCHours(),t.getUTCMinutes(),t.getUTCSeconds(),t.valueOf()%1e3)},w.prototype.getWeekday=function(){return r.getWeekday(new Date(this.getTime()))},w.prototype.getTime=function(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond)).getTime()},w.prototype.getDay=function(){return this.day},w.prototype.getMonth=function(){return this.month},w.prototype.getYear=function(){return this.year},w.prototype.addYears=function(t){this.year+=t},w.prototype.addMonths=function(t){if(this.month+=t,12<this.month){var e=Math.floor(this.month/12),n=Object(x.j)(this.month,12);this.month=n,this.year+=e,0===this.month&&(this.month=12,--this.year)}},w.prototype.addWeekly=function(t,e){e>this.getWeekday()?this.day+=-(this.getWeekday()+1+(6-e))+7*t:this.day+=-(this.getWeekday()-e)+7*t,this.fixDay()},w.prototype.addDaily=function(t){this.day+=t,this.fixDay()},w.prototype.addHours=function(t,e,n){for(e&&(this.hour+=Math.floor((23-this.hour)/t)*t);;){this.hour+=t;var r=Object(x.a)(this.hour,24),i=r.div,a=r.mod;if(i&&(this.hour=a,this.addDaily(i)),Object(x.b)(n)||Object(x.c)(n,this.hour))break}},w.prototype.addMinutes=function(t,e,n,r){for(e&&(this.minute+=Math.floor((1439-(60*this.hour+this.minute))/t)*t);;){this.minute+=t;var i=Object(x.a)(this.minute,60),a=i.div,o=i.mod;if(a&&(this.minute=o,this.addHours(a,!1,n)),(Object(x.b)(n)||Object(x.c)(n,this.hour))&&(Object(x.b)(r)||Object(x.c)(r,this.minute)))break}},w.prototype.addSeconds=function(t,e,n,r,i){for(e&&(this.second+=Math.floor((86399-(3600*this.hour+60*this.minute+this.second))/t)*t);;){this.second+=t;var a=Object(x.a)(this.second,60),o=a.div,s=a.mod;if(o&&(this.second=s,this.addMinutes(o,!1,n,r)),(Object(x.b)(n)||Object(x.c)(n,this.hour))&&(Object(x.b)(r)||Object(x.c)(r,this.minute))&&(Object(x.b)(i)||Object(x.c)(i,this.second)))break}},w.prototype.fixDay=function(){if(!(this.day<=28)){var t=r.monthRange(this.year,this.month-1)[1];if(!(this.day<=t))for(;this.day>t;){if(this.day-=t,++this.month,13===this.month&&(this.month=1,++this.year,this.year>r.MAXYEAR))return;t=r.monthRange(this.year,this.month-1)[1]}}},w.prototype.add=function(t,e){var n=t.freq,r=t.interval,i=t.wkst,a=t.byhour,o=t.byminute,s=t.bysecond;switch(n){case y.YEARLY:return this.addYears(r);case y.MONTHLY:return this.addMonths(r);case y.WEEKLY:return this.addWeekly(r,i);case y.DAILY:return this.addDaily(r);case y.HOURLY:return this.addHours(r,e,a);case y.MINUTELY:return this.addMinutes(r,e,a,o);case y.SECONDLY:return this.addSeconds(r,e,a,o,s)}},w);function w(t,e,n,r,i,a,o){var s=m.call(this,r,i,a,o)||this;return s.year=t,s.month=e,s.day=n,s}function v(t){for(var e=[],n=0,r=Object.keys(t);n<r.length;n++){var i=r[n];Object(x.c)(yt,i)||e.push(i),Y.isDate(t[i])&&!Y.isValidDate(t[i])&&e.push(i)}if(e.length)throw new Error("Invalid options: "+e.join(", "));return S({},t)}function O(t){var e=t.split("\n").map(k).filter(function(t){return null!==t});return S(S({},e[0]),e[1])}function g(t){var e={},n=/DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(t);if(!n)return e;n[0];var r=n[1],i=n[2];return r&&(e.tzid=r),e.dtstart=Y.untilStringToDate(i),e}function k(t){if(!(t=t.replace(/^\s+|\s+$/,"")).length)return null;var e=/^([A-Z]+?)[:;]/.exec(t.toUpperCase());if(!e)return E(t);e[0];var n=e[1];switch(n.toUpperCase()){case"RRULE":case"EXRULE":return E(t);case"DTSTART":return g(t);default:throw new Error("Unsupported RFC prop "+n+" in "+t)}}function E(u){var c=g(u.replace(/^RRULE:/i,""));return u.replace(/^(?:RRULE|EXRULE):/i,"").split(";").forEach(function(t){var e,n=t.split("="),r=n[0],i=n[1];switch(r.toUpperCase()){case"FREQ":c.freq=y[i.toUpperCase()];break;case"WKST":c.wkst=ht[i.toUpperCase()];break;case"COUNT":case"INTERVAL":case"BYSETPOS":case"BYMONTH":case"BYMONTHDAY":case"BYYEARDAY":case"BYWEEKNO":case"BYHOUR":case"BYMINUTE":case"BYSECOND":var a=-1===(e=i).indexOf(",")?U(e):e.split(",").map(U),o=r.toLowerCase();c[o]=a;break;case"BYWEEKDAY":case"BYDAY":c.byweekday=i.split(",").map(function(t){if(2===t.length)return ht[t];var e=t.match(/^([+-]?\d{1,2})([A-Z]{2})$/),n=Number(e[1]),r=e[2],i=ht[r].weekday;return new b.b(i,n)});break;case"DTSTART":case"TZID":var s=g(u);c.tzid=s.tzid,c.dtstart=s.dtstart;break;case"UNTIL":c.until=Y.untilStringToDate(i);break;case"BYEASTER":c.byeaster=Number(i);break;default:throw new Error("Unknown RRULE property '"+r+"'")}}),c}function U(t){return/^[+-]?\d+$/.test(t)?Number(t):t}var L=function(){throw new TypeError},M=(Object.defineProperty(_.prototype,"isUTC",{get:function(){return!this.tzid||"UTC"===this.tzid.toUpperCase()},enumerable:!0,configurable:!0}),_.prototype.toString=function(){var t=Y.timeToUntilString(this.date.getTime(),this.isUTC);return this.isUTC?":"+t:";TZID="+this.tzid+":"+t},_.prototype.getTime=function(){return this.date.getTime()},_.prototype.rezonedDate=function(){if(this.isUTC)return this.date;try{return L(this.date).setZone(this.tzid,{keepLocalTime:!0}).toJSDate()}catch(t){return t instanceof TypeError&&console.error("Using TZID without Luxon available is unsupported. Returned times are in UTC, not the requested time zone"),this.date}},_);function _(t,e){this.date=t,this.tzid=e}function R(t){for(var e=[],n="",r=Object.keys(t),i=Object.keys(dt),a=0;a<r.length;a++)if("tzid"!==r[a]&&Object(x.c)(i,r[a])){var o=r[a].toUpperCase(),s=t[r[a]],u="";if(Object(x.f)(s)&&(!Object(x.d)(s)||s.length)){switch(o){case"FREQ":u=ft.FREQUENCIES[t.freq];break;case"WKST":u=Object(x.e)(s)?new b.b(s).toString():s.toString();break;case"BYWEEKDAY":o="BYDAY",u=Object(x.n)(s).map(function(t){return t instanceof b.b?t:Object(x.d)(t)?new b.b(t[0],t[1]):new b.b(t)}).toString();break;case"DTSTART":n=N(s,t.tzid);break;case"UNTIL":u=Y.timeToUntilString(s,!t.tzid);break;default:if(Object(x.d)(s)){for(var c=[],h=0;h<s.length;h++)c[h]=String(s[h]);u=c.toString()}else u=String(s)}u&&e.push([o,u])}}var d=e.map(function(t){return t[0]+"="+t[1].toString()}).join(";"),y="";return""!==d&&(y="RRULE:"+d),[n,y].filter(function(t){return!!t}).join("\n")}function N(t,e){return t?"DTSTART"+new M(new Date(t),e).toString():""}var A=(C.prototype._cacheAdd=function(t,e,n){e=e&&(e instanceof Date?Y.clone(e):Y.cloneDates(e)),"all"===t?this.all=e:(n._value=e,this[t].push(n))},C.prototype._cacheGet=function(t,r){function e(t){for(var e=0;e<i.length;e++){var n=i[e];if(String(r[n])!==String(t[n]))return!0}return!1}var n=!1,i=r?Object.keys(r):[],a=this[t];if("all"===t)n=this.all;else if(Object(x.d)(a))for(var o=0;o<a.length;o++){var s=a[o];if(!i.length||!e(s)){n=s._value;break}}if(!n&&this.all){var u=new c(t,r);for(o=0;o<this.all.length&&u.accept(this.all[o]);o++);n=u.getValue(),this._cacheAdd(t,n,r)}return Object(x.d)(n)?Y.cloneDates(n):n instanceof Date?Y.clone(n):n},C);function C(){this.all=!1,this.before=[],this.after=[],this.between=[]}var I=h(Object(x.l)(1,31),Object(x.l)(2,28),Object(x.l)(3,31),Object(x.l)(4,30),Object(x.l)(5,31),Object(x.l)(6,30),Object(x.l)(7,31),Object(x.l)(8,31),Object(x.l)(9,30),Object(x.l)(10,31),Object(x.l)(11,30),Object(x.l)(12,31),Object(x.l)(1,7)),W=h(Object(x.l)(1,31),Object(x.l)(2,29),Object(x.l)(3,31),Object(x.l)(4,30),Object(x.l)(5,31),Object(x.l)(6,30),Object(x.l)(7,31),Object(x.l)(8,31),Object(x.l)(9,30),Object(x.l)(10,31),Object(x.l)(11,30),Object(x.l)(12,31),Object(x.l)(1,7)),H=Object(x.k)(1,29),q=Object(x.k)(1,30),P=Object(x.k)(1,31),z=Object(x.k)(1,32),F=h(z,q,z,P,z,P,z,z,P,z,P,z,z.slice(0,7)),K=h(z,H,z,P,z,P,z,z,P,z,P,z,z.slice(0,7)),B=Object(x.k)(-28,0),Z=Object(x.k)(-29,0),V=Object(x.k)(-30,0),X=Object(x.k)(-31,0),G=h(X,Z,X,V,X,V,X,X,V,X,V,X,X.slice(0,7)),J=h(X,B,X,V,X,V,X,X,V,X,V,X,X.slice(0,7)),Q=[0,31,60,91,121,152,182,213,244,274,305,335,366],$=[0,31,59,90,120,151,181,212,243,273,304,334,365],tt=function(){for(var t=[],e=0;e<55;e++)t=t.concat(Object(x.k)(7));return t}();function et(t,e){var n,r,i,a,o,s,u=new Date(Date.UTC(t,0,1)),c=Y.isLeapYear(t)?366:365,h=Y.isLeapYear(t+1)?366:365,d=Y.toOrdinal(u),y=Y.getWeekday(u),l=S(S({yearlen:c,nextyearlen:h,yearordinal:d,yearweekday:y},(n=t,r=Y.isLeapYear(n)?366:365,i=new Date(Date.UTC(n,0,1)),a=Y.getWeekday(i),365!=r?{mmask:W,mdaymask:F,nmdaymask:G,wdaymask:tt.slice(a),mrange:Q}:{mmask:I,mdaymask:K,nmdaymask:J,wdaymask:tt.slice(a),mrange:$})),{wnomask:null});if(Object(x.b)(e.byweekno))return l;l.wnomask=Object(x.l)(0,7+c);var f=o=Object(x.j)(7-y+e.wkst,7);s=4<=f?(f=0,l.yearlen+Object(x.j)(y-e.wkst,7)):c-f;for(var b=Math.floor(s/7),p=Object(x.j)(s,7),m=Math.floor(b+p/4),w=0;w<e.byweekno.length;w++){var v=e.byweekno[w];if(v<0&&(v+=m+1),0<v&&v<=m){var O=void 0;1<v?(O=f+7*(v-1),f!==o&&(O-=7-o)):O=f;for(var g=0;g<7&&(l.wnomask[O]=1,O++,l.wdaymask[O]!==e.wkst);g++);}}if(Object(x.c)(e.byweekno,1)){O=f+7*m;if(f!==o&&(O-=7-o),O<c)for(w=0;w<7&&(O+=l.wnomask[O]=1,l.wdaymask[O]!==e.wkst);w++);}if(f){var k=void 0;if(Object(x.c)(e.byweekno,-1))k=-1;else{var E=Y.getWeekday(new Date(Date.UTC(t-1,0,1))),j=Object(x.j)(7-E.valueOf()+e.wkst,7),T=Y.isLeapYear(t-1)?366:365,D=void 0;D=4<=j?(j=0,T+Object(x.j)(E-e.wkst,7)):c-f,k=Math.floor(52+Object(x.j)(D,7)/4)}if(Object(x.c)(e.byweekno,k))for(O=0;O<f;O++)l.wnomask[O]=1}return l}function nt(t){this.options=t}var rt=(nt.prototype.rebuild=function(t,e){var n=this.options;if(t!==this.lastyear&&(this.yearinfo=et(t,n)),Object(x.h)(n.bynweekday)&&(e!==this.lastmonth||t!==this.lastyear)){var r=this.yearinfo,i=r.yearlen,a=r.mrange,o=r.wdaymask;this.monthinfo=function(t,e,n,r,i,a){var o={lastyear:t,lastmonth:e,nwdaymask:[]},s=[];if(a.freq===ft.YEARLY)if(Object(x.b)(a.bymonth))s=[[0,n]];else for(var u=0;u<a.bymonth.length;u++)e=a.bymonth[u],s.push(r.slice(e-1,e+1));else a.freq===ft.MONTHLY&&(s=[r.slice(e-1,e+1)]);if(Object(x.b)(s))return o;for(o.nwdaymask=Object(x.l)(0,n),u=0;u<s.length;u++)for(var c=s[u],h=c[0],d=c[1]-1,y=0;y<a.bynweekday.length;y++){var l=void 0,f=a.bynweekday[y],b=f[0],p=f[1];p<0?(l=d+7*(p+1),l-=Object(x.j)(i[l]-b,7)):(l=h+7*(p-1),l+=Object(x.j)(7-i[l]+b,7)),h<=l&&l<=d&&(o.nwdaymask[l]=1)}return o}(t,e,i,a,o,n)}Object(x.f)(n.byeaster)&&(this.eastermask=function(t,e){void 0===e&&(e=0);var n=t%19,r=Math.floor(t/100),i=t%100,a=Math.floor(r/4),o=r%4,s=Math.floor((r+8)/25),u=Math.floor((r-s+1)/3),c=Math.floor(19*n+r-a-u+15)%30,h=Math.floor(i/4),d=i%4,y=Math.floor(32+2*o+2*h-c-d)%7,l=Math.floor((n+11*c+22*y)/451),f=Math.floor((c+y-7*l+114)/31),b=(c+y-7*l+114)%31+1,p=Date.UTC(t,f-1,b+e),m=Date.UTC(t,0,1);return[Math.ceil((p-m)/864e5)]}(t,n.byeaster))},Object.defineProperty(nt.prototype,"lastyear",{get:function(){return this.monthinfo?this.monthinfo.lastyear:null},enumerable:!0,configurable:!0}),Object.defineProperty(nt.prototype,"lastmonth",{get:function(){return this.monthinfo?this.monthinfo.lastmonth:null},enumerable:!0,configurable:!0}),Object.defineProperty(nt.prototype,"yearlen",{get:function(){return this.yearinfo.yearlen},enumerable:!0,configurable:!0}),Object.defineProperty(nt.prototype,"yearordinal",{get:function(){return this.yearinfo.yearordinal},enumerable:!0,configurable:!0}),Object.defineProperty(nt.prototype,"mrange",{get:function(){return this.yearinfo.mrange},enumerable:!0,configurable:!0}),Object.defineProperty(nt.prototype,"wdaymask",{get:function(){return this.yearinfo.wdaymask},enumerable:!0,configurable:!0}),Object.defineProperty(nt.prototype,"mmask",{get:function(){return this.yearinfo.mmask},enumerable:!0,configurable:!0}),Object.defineProperty(nt.prototype,"wnomask",{get:function(){return this.yearinfo.wnomask},enumerable:!0,configurable:!0}),Object.defineProperty(nt.prototype,"nwdaymask",{get:function(){return this.monthinfo?this.monthinfo.nwdaymask:[]},enumerable:!0,configurable:!0}),Object.defineProperty(nt.prototype,"nextyearlen",{get:function(){return this.yearinfo.nextyearlen},enumerable:!0,configurable:!0}),Object.defineProperty(nt.prototype,"mdaymask",{get:function(){return this.yearinfo.mdaymask},enumerable:!0,configurable:!0}),Object.defineProperty(nt.prototype,"nmdaymask",{get:function(){return this.yearinfo.nmdaymask},enumerable:!0,configurable:!0}),nt.prototype.ydayset=function(){return[Object(x.k)(this.yearlen),0,this.yearlen]},nt.prototype.mdayset=function(t,e,n){for(var r=this.mrange[e-1],i=this.mrange[e],a=Object(x.l)(null,this.yearlen),o=r;o<i;o++)a[o]=o;return[a,r,i]},nt.prototype.wdayset=function(t,e,n){for(var r=Object(x.l)(null,this.yearlen+7),i=Y.toOrdinal(new Date(Date.UTC(t,e-1,n)))-this.yearordinal,a=i,o=0;o<7&&(r[i]=i,++i,this.wdaymask[i]!==this.options.wkst);o++);return[r,a,i]},nt.prototype.ddayset=function(t,e,n){var r=Object(x.l)(null,this.yearlen),i=Y.toOrdinal(new Date(Date.UTC(t,e-1,n)))-this.yearordinal;return r[i]=i,[r,i,1+i]},nt.prototype.htimeset=function(e,t,n,r){var i=this,a=[];return this.options.byminute.forEach(function(t){a=a.concat(i.mtimeset(e,t,n,r))}),Y.sort(a),a},nt.prototype.mtimeset=function(e,n,t,r){var i=this.options.bysecond.map(function(t){return new T(e,n,t,r)});return Y.sort(i),i},nt.prototype.stimeset=function(t,e,n,r){return[new T(t,e,n,r)]},nt.prototype.getdayset=function(t){switch(t){case y.YEARLY:return this.ydayset.bind(this);case y.MONTHLY:return this.mdayset.bind(this);case y.WEEKLY:return this.wdayset.bind(this);case y.DAILY:default:return this.ddayset.bind(this)}},nt.prototype.gettimeset=function(t){switch(t){case y.HOURLY:return this.htimeset.bind(this);case y.MINUTELY:return this.mtimeset.bind(this);case y.SECONDLY:return this.stimeset.bind(this)}},nt);function it(t,e,n,r,i,a){for(var o=[],s=0;s<t.length;s++){var u=void 0,c=void 0,h=t[s];c=h<0?(u=Math.floor(h/e.length),Object(x.j)(h,e.length)):(u=Math.floor((h-1)/e.length),Object(x.j)(h-1,e.length));for(var d=[],y=n;y<r;y++){var l=a[y];Object(x.f)(l)&&d.push(l)}var f=void 0;f=u<0?d.slice(u)[0]:d[u];var b=e[c],p=Y.fromOrdinal(i.yearordinal+f),m=Y.combine(p,b);Object(x.c)(o,m)||o.push(m)}return Y.sort(o),o}function at(t,e){var n=e.dtstart,r=e.freq,i=e.interval,a=e.until,o=e.bysetpos,s=e.count;if(0===s||0===i)return st(t);var u=D.fromDate(n),c=new rt(e);c.rebuild(u.year,u.month);for(var h=function(t,e,n){var r=n.freq,i=n.byhour,a=n.byminute,o=n.bysecond;if(j(r))return function(t){var r=t.dtstart.getTime()%1e3;if(!j(t.freq))return[];var i=[];return t.byhour.forEach(function(n){t.byminute.forEach(function(e){t.bysecond.forEach(function(t){i.push(new T(n,e,t,r))})})}),i}(n);if(r>=ft.HOURLY&&Object(x.h)(i)&&!Object(x.c)(i,e.hour)||r>=ft.MINUTELY&&Object(x.h)(a)&&!Object(x.c)(a,e.minute)||r>=ft.SECONDLY&&Object(x.h)(o)&&!Object(x.c)(o,e.second))return[];return t.gettimeset(r)(e.hour,e.minute,e.second,e.millisecond)}(c,u,e);;){var d=c.getdayset(r)(u.year,u.month,u.day),y=d[0],l=d[1],f=d[2],b=ut(y,l,f,c,e);if(Object(x.h)(o))for(var p=it(o,h,l,f,c,y),m=0;m<p.length;m++){var w=p[m];if(a&&a<w)return st(t);if(n<=w){var v=ot(w,e);if(!t.accept(v))return st(t);if(s&&!--s)return st(t)}}else for(m=l;m<f;m++){var O=y[m];if(Object(x.f)(O))for(var g=Y.fromOrdinal(c.yearordinal+O),k=0;k<h.length;k++){var E=h[k];w=Y.combine(g,E);if(a&&a<w)return st(t);if(n<=w){v=ot(w,e);if(!t.accept(v))return st(t);if(s&&!--s)return st(t)}}}if(0===e.interval)return st(t);if(u.add(e,b),u.year>Y.MAXYEAR)return st(t);j(r)||(h=c.gettimeset(r)(u.hour,u.minute,u.second,0)),c.rebuild(u.year,u.month)}}function ot(t,e){return new M(t,e.tzid).rezonedDate()}function st(t){return t.getValue()}function ut(t,e,n,r,i){for(var a,o,s,u,c,h,d,y,l,f,b=!1,p=e;p<n;p++){var m=t[p];a=r,o=m,void 0,u=(s=i).bymonth,c=s.byweekno,h=s.byweekday,d=s.byeaster,y=s.bymonthday,l=s.bynmonthday,f=s.byyearday,(b=Object(x.h)(u)&&!Object(x.c)(u,a.mmask[o])||Object(x.h)(c)&&!a.wnomask[o]||Object(x.h)(h)&&!Object(x.c)(h,a.wdaymask[o])||Object(x.h)(a.nwdaymask)&&!a.nwdaymask[o]||null!==d&&!Object(x.c)(a.eastermask,o)||(Object(x.h)(y)||Object(x.h)(l))&&!Object(x.c)(y,a.mdaymask[o])&&!Object(x.c)(l,a.nmdaymask[o])||Object(x.h)(f)&&(o<a.yearlen&&!Object(x.c)(f,o+1)&&!Object(x.c)(f,-a.yearlen+o)||o>=a.yearlen&&!Object(x.c)(f,o+1-a.yearlen)&&!Object(x.c)(f,-a.nextyearlen+o-a.yearlen)))&&(t[m]=null)}return b}var ct=function(){return ct._nlp||(ct._nlp=n(3)),ct._nlp},ht={MO:new b.b(0),TU:new b.b(1),WE:new b.b(2),TH:new b.b(3),FR:new b.b(4),SA:new b.b(5),SU:new b.b(6)},dt={freq:y.YEARLY,dtstart:null,interval:1,wkst:ht.MO,count:null,until:null,tzid:null,bysetpos:null,bymonth:null,bymonthday:null,bynmonthday:null,byyearday:null,byweekno:null,byweekday:null,bynweekday:null,byhour:null,byminute:null,bysecond:null,byeaster:null},yt=Object.keys(dt);function lt(t,e){void 0===t&&(t={}),void 0===e&&(e=!1),this._cache=e?null:new A,this.origOptions=v(t);var n=function(t){var e=S(S({},dt),v(t));if(Object(x.f)(e.byeaster)&&(e.freq=ft.YEARLY),!Object(x.f)(e.freq)||!ft.FREQUENCIES[e.freq])throw new Error("Invalid frequency: "+e.freq+" "+t.freq);if(e.dtstart||(e.dtstart=new Date((new Date).setMilliseconds(0))),Object(x.f)(e.wkst)?Object(x.e)(e.wkst)||(e.wkst=e.wkst.weekday):e.wkst=ft.MO.weekday,Object(x.f)(e.bysetpos)){Object(x.e)(e.bysetpos)&&(e.bysetpos=[e.bysetpos]);for(var n=0;n<e.bysetpos.length;n++){if(0===(a=e.bysetpos[n])||!(-366<=a&&a<=366))throw new Error("bysetpos must be between 1 and 366, or between -366 and -1")}}if(!(Boolean(e.byweekno)||Object(x.h)(e.byweekno)||Object(x.h)(e.byyearday)||Boolean(e.bymonthday)||Object(x.h)(e.bymonthday)||Object(x.f)(e.byweekday)||Object(x.f)(e.byeaster)))switch(e.freq){case ft.YEARLY:e.bymonth||(e.bymonth=e.dtstart.getUTCMonth()+1),e.bymonthday=e.dtstart.getUTCDate();break;case ft.MONTHLY:e.bymonthday=e.dtstart.getUTCDate();break;case ft.WEEKLY:e.byweekday=[Y.getWeekday(e.dtstart)]}if(Object(x.f)(e.bymonth)&&!Object(x.d)(e.bymonth)&&(e.bymonth=[e.bymonth]),Object(x.f)(e.byyearday)&&!Object(x.d)(e.byyearday)&&Object(x.e)(e.byyearday)&&(e.byyearday=[e.byyearday]),Object(x.f)(e.bymonthday))if(Object(x.d)(e.bymonthday)){var r=[],i=[];for(n=0;n<e.bymonthday.length;n++){var a;0<(a=e.bymonthday[n])?r.push(a):a<0&&i.push(a)}e.bymonthday=r,e.bynmonthday=i}else e.bymonthday<0?(e.bynmonthday=[e.bymonthday],e.bymonthday=[]):(e.bynmonthday=[],e.bymonthday=[e.bymonthday]);else e.bymonthday=[],e.bynmonthday=[];if(Object(x.f)(e.byweekno)&&!Object(x.d)(e.byweekno)&&(e.byweekno=[e.byweekno]),Object(x.f)(e.byweekday))if(Object(x.e)(e.byweekday))e.byweekday=[e.byweekday],e.bynweekday=null;else if(Object(x.g)(e.byweekday))e.byweekday=[b.b.fromStr(e.byweekday).weekday],e.bynweekday=null;else if(e.byweekday instanceof b.b)!e.byweekday.n||e.freq>ft.MONTHLY?(e.byweekday=[e.byweekday.weekday],e.bynweekday=null):(e.bynweekday=[[e.byweekday.weekday,e.byweekday.n]],e.byweekday=null);else{var o=[],s=[];for(n=0;n<e.byweekday.length;n++){var u=e.byweekday[n];Object(x.e)(u)?o.push(u):Object(x.g)(u)?o.push(b.b.fromStr(u).weekday):!u.n||e.freq>ft.MONTHLY?o.push(u.weekday):s.push([u.weekday,u.n])}e.byweekday=Object(x.h)(o)?o:null,e.bynweekday=Object(x.h)(s)?s:null}else e.bynweekday=null;return Object(x.f)(e.byhour)?Object(x.e)(e.byhour)&&(e.byhour=[e.byhour]):e.byhour=e.freq<ft.HOURLY?[e.dtstart.getUTCHours()]:null,Object(x.f)(e.byminute)?Object(x.e)(e.byminute)&&(e.byminute=[e.byminute]):e.byminute=e.freq<ft.MINUTELY?[e.dtstart.getUTCMinutes()]:null,Object(x.f)(e.bysecond)?Object(x.e)(e.bysecond)&&(e.bysecond=[e.bysecond]):e.bysecond=e.freq<ft.SECONDLY?[e.dtstart.getUTCSeconds()]:null,{parsedOptions:e}}(t).parsedOptions;this.options=n}var ft=(lt.parseText=function(t,e){return ct().parseText(t,e)},lt.fromText=function(t,e){return ct().fromText(t,e)},lt.fromString=function(t){return new lt(lt.parseString(t)||void 0)},lt.prototype._iter=function(t){return at(t,this.options)},lt.prototype._cacheGet=function(t,e){return!!this._cache&&this._cache._cacheGet(t,e)},lt.prototype._cacheAdd=function(t,e,n){if(this._cache)return this._cache._cacheAdd(t,e,n)},lt.prototype.all=function(t){if(t)return this._iter(new f("all",{},t));var e=this._cacheGet("all");return!1===e&&(e=this._iter(new c("all",{})),this._cacheAdd("all",e)),e},lt.prototype.between=function(t,e,n,r){if(void 0===n&&(n=!1),!Y.isValidDate(t)||!Y.isValidDate(e))throw new Error("Invalid date passed in to RRule.between");var i={before:e,after:t,inc:n};if(r)return this._iter(new f("between",i,r));var a=this._cacheGet("between",i);return!1===a&&(a=this._iter(new c("between",i)),this._cacheAdd("between",a,i)),a},lt.prototype.before=function(t,e){if(void 0===e&&(e=!1),!Y.isValidDate(t))throw new Error("Invalid date passed in to RRule.before");var n={dt:t,inc:e},r=this._cacheGet("before",n);return!1===r&&(r=this._iter(new c("before",n)),this._cacheAdd("before",r,n)),r},lt.prototype.after=function(t,e){if(void 0===e&&(e=!1),!Y.isValidDate(t))throw new Error("Invalid date passed in to RRule.after");var n={dt:t,inc:e},r=this._cacheGet("after",n);return!1===r&&(r=this._iter(new c("after",n)),this._cacheAdd("after",r,n)),r},lt.prototype.count=function(){return this.all().length},lt.prototype.toString=function(){return R(this.origOptions)},lt.prototype.toText=function(t,e,n){return ct().toText(this,t,e,n)},lt.prototype.isFullyConvertibleToText=function(){return ct().isFullyConvertible(this)},lt.prototype.clone=function(){return new lt(this.origOptions)},lt.FREQUENCIES=["YEARLY","MONTHLY","WEEKLY","DAILY","HOURLY","MINUTELY","SECONDLY"],lt.YEARLY=y.YEARLY,lt.MONTHLY=y.MONTHLY,lt.WEEKLY=y.WEEKLY,lt.DAILY=y.DAILY,lt.HOURLY=y.HOURLY,lt.MINUTELY=y.MINUTELY,lt.SECONDLY=y.SECONDLY,lt.MO=ht.MO,lt.TU=ht.TU,lt.WE=ht.WE,lt.TH=ht.TH,lt.FR=ht.FR,lt.SA=ht.SA,lt.SU=ht.SU,lt.parseString=O,lt.optionsToString=R,lt);var bt,pt={dtstart:null,cache:!1,unfold:!1,forceset:!1,compatible:!1,tzid:null};function mt(t,e){var s=[],u=[],c=[],h=[],n=g(t),r=n.dtstart,d=n.tzid;return function(t,e){void 0===e&&(e=!1);if(!(t=t&&t.trim()))throw new Error("Invalid empty string");if(!e)return t.split(/\s/);var n=t.split("\n"),r=0;for(;r<n.length;){var i=n[r]=n[r].replace(/\s+$/g,"");i?0<r&&" "===i[0]?(n[r-1]+=i.slice(1),n.splice(r,1)):r+=1:n.splice(r,1)}return n}(t,e.unfold).forEach(function(t){if(t){var e=function(t){var e=function(t){if(-1===t.indexOf(":"))return{name:"RRULE",value:t};var e=Object(x.m)(t,":",1),n=e[0],r=e[1];return{name:n,value:r}}(t),n=e.name,r=e.value,i=n.split(";");if(!i)throw new Error("empty property name");return{name:i[0].toUpperCase(),parms:i.slice(1),value:r}}(t),n=e.name,r=e.parms,i=e.value;switch(n.toUpperCase()){case"RRULE":if(r.length)throw new Error("unsupported RRULE parm: "+r.join(","));s.push(O(t));break;case"RDATE":var a=/RDATE(?:;TZID=([^:=]+))?/i.exec(t),o=(a[0],a[1]);o&&!d&&(d=o),u=u.concat(Ot(i,r));break;case"EXRULE":if(r.length)throw new Error("unsupported EXRULE parm: "+r.join(","));c.push(O(i));break;case"EXDATE":h=h.concat(Ot(i,r));break;case"DTSTART":break;default:throw new Error("unsupported property: "+n)}}}),{dtstart:r,tzid:d,rrulevals:s,rdatevals:u,exrulevals:c,exdatevals:h}}function wt(t,e){return void 0===e&&(e={}),function(t,e){var n=mt(t,e),r=n.rrulevals,i=n.rdatevals,a=n.exrulevals,o=n.exdatevals,s=n.dtstart,u=n.tzid,c=!1===e.cache;if(e.compatible&&(e.forceset=!0,e.unfold=!0),e.forceset||1<r.length||i.length||a.length||o.length){var h=new Et(c);return h.dtstart(s),h.tzid(u||void 0),r.forEach(function(t){h.rrule(new ft(vt(t,s,u),c))}),i.forEach(function(t){h.rdate(t)}),a.forEach(function(t){h.exrule(new ft(vt(t,s,u),c))}),o.forEach(function(t){h.exdate(t)}),e.compatible&&e.dtstart&&h.rdate(s),h}var d=r[0]||{};return new ft(vt(d,d.dtstart||e.dtstart||s,d.tzid||e.tzid||u),c)}(t,function(t){var e=[],n=Object.keys(t),r=Object.keys(pt);if(n.forEach(function(t){Object(x.c)(r,t)||e.push(t)}),e.length)throw new Error("Invalid options: "+e.join(", "));return S(S({},pt),t)}(e))}function vt(t,e,n){return S(S({},t),{dtstart:e,tzid:n})}function Ot(t,e){return e.forEach(function(t){if(!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(t))throw new Error("unsupported RDATE/EXDATE parm: "+t)}),t.split(",").map(function(t){return Y.untilStringToDate(t)})}function gt(r){var i=this;return function(t){if(void 0!==t&&(i["_"+r]=t),void 0!==i["_"+r])return i["_"+r];for(var e=0;e<i._rrule.length;e++){var n=i._rrule[e].origOptions[r];if(n)return n}}}function kt(t){void 0===t&&(t=!1);var e=bt.call(this,{},t)||this;return e.dtstart=gt.apply(e,["dtstart"]),e.tzid=gt.apply(e,["tzid"]),e._rrule=[],e._rdate=[],e._exrule=[],e._exdate=[],e}var Et=(s(kt,bt=ft),kt.prototype._iter=function(t){return function(e,t,r,n,i,a){var o={},s=e.accept;function u(e,n){r.forEach(function(t){t.between(e,n,!0).forEach(function(t){o[Number(t)]=!0})})}i.forEach(function(t){var e=new M(t,a).rezonedDate();o[Number(e)]=!0}),e.accept=function(t){var e=Number(t);return isNaN(e)?s.call(this,t):!(!o[e]&&(u(new Date(e-1),new Date(e+1)),!o[e]))||(o[e]=!0,s.call(this,t))},"between"===e.method&&(u(e.args.after,e.args.before),e.accept=function(t){var e=Number(t);return!!o[e]||(o[e]=!0,s.call(this,t))});for(var c=0;c<n.length;c++){var h=new M(n[c],a).rezonedDate();if(!e.accept(new Date(h.getTime())))break}t.forEach(function(t){at(e,t.options)});var d=e._result;switch(Y.sort(d),e.method){case"all":case"between":return d;case"before":return d.length&&d[d.length-1]||null;case"after":default:return d.length&&d[0]||null}}(t,this._rrule,this._exrule,this._rdate,this._exdate,this.tzid())},kt.prototype.rrule=function(t){jt(t,this._rrule)},kt.prototype.exrule=function(t){jt(t,this._exrule)},kt.prototype.rdate=function(t){Tt(t,this._rdate)},kt.prototype.exdate=function(t){Tt(t,this._exdate)},kt.prototype.rrules=function(){return this._rrule.map(function(t){return wt(t.toString())})},kt.prototype.exrules=function(){return this._exrule.map(function(t){return wt(t.toString())})},kt.prototype.rdates=function(){return this._rdate.map(function(t){return new Date(t.getTime())})},kt.prototype.exdates=function(){return this._exdate.map(function(t){return new Date(t.getTime())})},kt.prototype.valueOf=function(){var e=[];return!this._rrule.length&&this._dtstart&&(e=e.concat(R({dtstart:this._dtstart}))),this._rrule.forEach(function(t){e=e.concat(t.toString().split("\n"))}),this._exrule.forEach(function(t){e=e.concat(t.toString().split("\n").map(function(t){return t.replace(/^RRULE:/,"EXRULE:")}).filter(function(t){return!/^DTSTART/.test(t)}))}),this._rdate.length&&e.push(Dt("RDATE",this._rdate,this.tzid())),this._exdate.length&&e.push(Dt("EXDATE",this._exdate,this.tzid())),e},kt.prototype.toString=function(){return this.valueOf().join("\n")},kt.prototype.clone=function(){var e=new kt(!!this._cache);return this._rrule.forEach(function(t){return e.rrule(t.clone())}),this._exrule.forEach(function(t){return e.exrule(t.clone())}),this._rdate.forEach(function(t){return e.rdate(new Date(t.getTime()))}),this._exdate.forEach(function(t){return e.exdate(new Date(t.getTime()))}),e},kt);function jt(t,e){if(!(t instanceof ft))throw new TypeError(String(t)+" is not RRule instance");Object(x.c)(e.map(String),String(t))||e.push(t)}function Tt(t,e){if(!(t instanceof Date))throw new TypeError(String(t)+" is not Date instance");Object(x.c)(e.map(Number),Number(t))||(e.push(t),Y.sort(e))}function Dt(t,e,n){var r=!n||"UTC"===n.toUpperCase();return(r?t+":":t+";TZID="+n+":")+e.map(function(t){return Y.timeToUntilString(t.valueOf(),r)}).join(",")}n.d(e,"rrulestr",function(){return wt}),n.d(e,"Frequency",function(){return y}),n.d(e,"Weekday",function(){return b.b}),n.d(e,"RRule",function(){return ft}),n.d(e,"RRuleSet",function(){return Et});
/*!
 * rrule.js - Library for working with recurrence rules for calendar dates.
 * https://github.com/jakubroztocil/rrule
 *
 * Copyright 2010, Jakub Roztocil and Lars Schoning
 * Licenced under the BSD licence.
 * https://github.com/jakubroztocil/rrule/blob/master/LICENCE
 *
 * Based on:
 * python-dateutil - Extensions to the standard Python datetime module.
 * Copyright (c) 2003-2011 - Gustavo Niemeyer <gustavo@niemeyer.net>
 * Copyright (c) 2012 - Tomi Pievilinen <tomi.pievilainen@iki.fi>
 * https://github.com/jakubroztocil/rrule/blob/master/LICENCE
 *
 */e.default=ft},function(t,e,n){"use strict";n.d(e,"a",function(){return r}),n.d(e,"b",function(){return i});var r=["MO","TU","WE","TH","FR","SA","SU"],i=(a.fromStr=function(t){return new a(r.indexOf(t))},a.prototype.nth=function(t){return this.n===t?this:new a(this.weekday,t)},a.prototype.equals=function(t){return this.weekday===t.weekday&&this.n===t.n},a.prototype.toString=function(){var t=r[this.weekday];return this.n&&(t=(0<this.n?"+":"")+String(this.n)+t),t},a.prototype.getJsWeekday=function(){return 6===this.weekday?0:this.weekday+1},a);function a(t,e){if(0===e)throw new Error("Can't create weekday with n == 0");this.weekday=t,this.n=e}},function(t,e,n){"use strict";n.r(e);function r(t,e){return-1!==t.indexOf(e)}function c(t){return t.toString()}function h(t,e,n){return e+" "+n+", "+t}var d={dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],tokens:{SKIP:/^[ \r\n\t]+|^\.$/,number:/^[1-9][0-9]*/,numberAsText:/^(one|two|three)/i,every:/^every/i,"day(s)":/^days?/i,"weekday(s)":/^weekdays?/i,"week(s)":/^weeks?/i,"hour(s)":/^hours?/i,"minute(s)":/^minutes?/i,"month(s)":/^months?/i,"year(s)":/^years?/i,on:/^(on|in)/i,at:/^(at)/i,the:/^the/i,first:/^first/i,second:/^second/i,third:/^third/i,nth:/^([1-9][0-9]*)(\.|th|nd|rd|st)/i,last:/^last/i,for:/^for/i,"time(s)":/^times?/i,until:/^(un)?til/i,monday:/^mo(n(day)?)?/i,tuesday:/^tu(e(s(day)?)?)?/i,wednesday:/^we(d(n(esday)?)?)?/i,thursday:/^th(u(r(sday)?)?)?/i,friday:/^fr(i(day)?)?/i,saturday:/^sa(t(urday)?)?/i,sunday:/^su(n(day)?)?/i,january:/^jan(uary)?/i,february:/^feb(ruary)?/i,march:/^mar(ch)?/i,april:/^apr(il)?/i,may:/^may/i,june:/^june?/i,july:/^july?/i,august:/^aug(ust)?/i,september:/^sep(t(ember)?)?/i,october:/^oct(ober)?/i,november:/^nov(ember)?/i,december:/^dec(ember)?/i,comma:/^(,\s*|(and|or)\s*)+/i}},y=n(1),l=n(0);function i(t,e,n,r){if(void 0===e&&(e=c),void 0===n&&(n=d),void 0===r&&(r=h),this.text=[],this.language=n||d,this.gettext=e,this.dateFormatter=r,this.rrule=t,this.options=t.options,this.origOptions=t.origOptions,this.origOptions.bymonthday){var i=[].concat(this.options.bymonthday),a=[].concat(this.options.bynmonthday);i.sort(function(t,e){return t-e}),a.sort(function(t,e){return e-t}),this.bymonthday=i.concat(a),this.bymonthday.length||(this.bymonthday=null)}if(Object(l.f)(this.origOptions.byweekday)){var o=Object(l.d)(this.origOptions.byweekday)?this.origOptions.byweekday:[this.origOptions.byweekday],s=String(o);this.byweekday={allWeeks:o.filter(function(t){return!t.n}),someWeeks:o.filter(function(t){return Boolean(t.n)}),isWeekdays:-1!==s.indexOf("MO")&&-1!==s.indexOf("TU")&&-1!==s.indexOf("WE")&&-1!==s.indexOf("TH")&&-1!==s.indexOf("FR")&&-1===s.indexOf("SA")&&-1===s.indexOf("SU"),isEveryDay:-1!==s.indexOf("MO")&&-1!==s.indexOf("TU")&&-1!==s.indexOf("WE")&&-1!==s.indexOf("TH")&&-1!==s.indexOf("FR")&&-1!==s.indexOf("SA")&&-1!==s.indexOf("SU")};var u=function(t,e){return t.weekday-e.weekday};this.byweekday.allWeeks.sort(u),this.byweekday.someWeeks.sort(u),this.byweekday.allWeeks.length||(this.byweekday.allWeeks=null),this.byweekday.someWeeks.length||(this.byweekday.someWeeks=null)}else this.byweekday=null}var a=(i.isFullyConvertible=function(t){if(!(t.options.freq in i.IMPLEMENTED))return!1;if(t.origOptions.until&&t.origOptions.count)return!1;for(var e in t.origOptions){if(r(["dtstart","wkst","freq"],e))return!0;if(!r(i.IMPLEMENTED[t.options.freq],e))return!1}return!0},i.prototype.isFullyConvertible=function(){return i.isFullyConvertible(this.rrule)},i.prototype.toString=function(){var t=this.gettext;if(!(this.options.freq in i.IMPLEMENTED))return t("RRule error: Unable to fully convert this rrule to text");if(this.text=[t("every")],this[y.default.FREQUENCIES[this.options.freq]](),this.options.until){this.add(t("until"));var e=this.options.until;this.add(this.dateFormatter(e.getUTCFullYear(),this.language.monthNames[e.getUTCMonth()],e.getUTCDate()))}else this.options.count&&this.add(t("for")).add(this.options.count.toString()).add(this.plural(this.options.count)?t("times"):t("time"));return this.isFullyConvertible()||this.add(t("(~ approximate)")),this.text.join("")},i.prototype.HOURLY=function(){var t=this.gettext;1!==this.options.interval&&this.add(this.options.interval.toString()),this.add(this.plural(this.options.interval)?t("hours"):t("hour"))},i.prototype.MINUTELY=function(){var t=this.gettext;1!==this.options.interval&&this.add(this.options.interval.toString()),this.add(this.plural(this.options.interval)?t("minutes"):t("minute"))},i.prototype.DAILY=function(){var t=this.gettext;1!==this.options.interval&&this.add(this.options.interval.toString()),this.byweekday&&this.byweekday.isWeekdays?this.add(this.plural(this.options.interval)?t("weekdays"):t("weekday")):this.add(this.plural(this.options.interval)?t("days"):t("day")),this.origOptions.bymonth&&(this.add(t("in")),this._bymonth()),this.bymonthday?this._bymonthday():this.byweekday?this._byweekday():this.origOptions.byhour&&this._byhour()},i.prototype.WEEKLY=function(){var t=this.gettext;1!==this.options.interval&&this.add(this.options.interval.toString()).add(this.plural(this.options.interval)?t("weeks"):t("week")),this.byweekday&&this.byweekday.isWeekdays?1===this.options.interval?this.add(this.plural(this.options.interval)?t("weekdays"):t("weekday")):this.add(t("on")).add(t("weekdays")):this.byweekday&&this.byweekday.isEveryDay?this.add(this.plural(this.options.interval)?t("days"):t("day")):(1===this.options.interval&&this.add(t("week")),this.origOptions.bymonth&&(this.add(t("in")),this._bymonth()),this.bymonthday?this._bymonthday():this.byweekday&&this._byweekday())},i.prototype.MONTHLY=function(){var t=this.gettext;this.origOptions.bymonth?(1!==this.options.interval&&(this.add(this.options.interval.toString()).add(t("months")),this.plural(this.options.interval)&&this.add(t("in"))),this._bymonth()):(1!==this.options.interval&&this.add(this.options.interval.toString()),this.add(this.plural(this.options.interval)?t("months"):t("month"))),this.bymonthday?this._bymonthday():this.byweekday&&this.byweekday.isWeekdays?this.add(t("on")).add(t("weekdays")):this.byweekday&&this._byweekday()},i.prototype.YEARLY=function(){var t=this.gettext;this.origOptions.bymonth?(1!==this.options.interval&&(this.add(this.options.interval.toString()),this.add(t("years"))),this._bymonth()):(1!==this.options.interval&&this.add(this.options.interval.toString()),this.add(this.plural(this.options.interval)?t("years"):t("year"))),this.bymonthday?this._bymonthday():this.byweekday&&this._byweekday(),this.options.byyearday&&this.add(t("on the")).add(this.list(this.options.byyearday,this.nth,t("and"))).add(t("day")),this.options.byweekno&&this.add(t("in")).add(this.plural(this.options.byweekno.length)?t("weeks"):t("week")).add(this.list(this.options.byweekno,void 0,t("and")))},i.prototype._bymonthday=function(){var t=this.gettext;this.byweekday&&this.byweekday.allWeeks?this.add(t("on")).add(this.list(this.byweekday.allWeeks,this.weekdaytext,t("or"))).add(t("the")).add(this.list(this.bymonthday,this.nth,t("or"))):this.add(t("on the")).add(this.list(this.bymonthday,this.nth,t("and")))},i.prototype._byweekday=function(){var t=this.gettext;this.byweekday.allWeeks&&!this.byweekday.isWeekdays&&this.add(t("on")).add(this.list(this.byweekday.allWeeks,this.weekdaytext)),this.byweekday.someWeeks&&(this.byweekday.allWeeks&&this.add(t("and")),this.add(t("on the")).add(this.list(this.byweekday.someWeeks,this.weekdaytext,t("and"))))},i.prototype._byhour=function(){var t=this.gettext;this.add(t("at")).add(this.list(this.origOptions.byhour,void 0,t("and")))},i.prototype._bymonth=function(){this.add(this.list(this.options.bymonth,this.monthtext,this.gettext("and")))},i.prototype.nth=function(t){var e,n;t=parseInt(t.toString(),10);var r=this.gettext;if(-1===t)return r("last");switch(n=Math.abs(t)){case 1:case 21:case 31:e=n+r("st");break;case 2:case 22:e=n+r("nd");break;case 3:case 23:e=n+r("rd");break;default:e=n+r("th")}return t<0?e+" "+r("last"):e},i.prototype.monthtext=function(t){return this.language.monthNames[t-1]},i.prototype.weekdaytext=function(t){var e=Object(l.e)(t)?(t+1)%7:t.getJsWeekday();return(t.n?this.nth(t.n)+" ":"")+this.language.dayNames[e]},i.prototype.plural=function(t){return t%100!=1},i.prototype.add=function(t){return this.text.push(" "),this.text.push(t),this},i.prototype.list=function(t,e,n,r){function i(t){return e&&e.call(a,t)}void 0===r&&(r=","),Object(l.d)(t)||(t=[t]),e=e||function(t){return t.toString()};var a=this;return n?function(t,e,n){for(var r="",i=0;i<t.length;i++)0!==i&&(i===t.length-1?r+=" "+n+" ":r+=e+" "),r+=t[i];return r}(t.map(i),r,n):t.map(i).join(r+" ")},i),f=(o.prototype.start=function(t){return this.text=t,this.done=!1,this.nextSymbol()},o.prototype.isDone=function(){return this.done&&null===this.symbol},o.prototype.nextSymbol=function(){var t,e;this.symbol=null,this.value=null;do{if(this.done)return!1;for(var n in t=null,this.rules){var r=this.rules[n].exec(this.text);r&&(null===t||r[0].length>t[0].length)&&(t=r,e=n)}if(null!=t&&(this.text=this.text.substr(t[0].length),""===this.text&&(this.done=!0)),null==t)return this.done=!0,this.symbol=null,void(this.value=null)}while("SKIP"===e);return this.symbol=e,this.value=t,!0},o.prototype.accept=function(t){if(this.symbol!==t)return!1;if(this.value){var e=this.value;return this.nextSymbol(),e}return this.nextSymbol(),!0},o.prototype.acceptNumber=function(){return this.accept("number")},o.prototype.expect=function(t){if(this.accept(t))return!0;throw new Error("expected "+t+" but found "+this.symbol)},o);function o(t){this.done=!0,this.rules=t}function s(t,e){void 0===e&&(e=d);var o={},s=new f(e.tokens);return s.start(t)?(function(){s.expect("every");var t=s.acceptNumber();t&&(o.interval=parseInt(t[0],10));if(s.isDone())throw new Error("Unexpected end");switch(s.symbol){case"day(s)":o.freq=y.default.DAILY,s.nextSymbol()&&(function(){if(!s.accept("at"))return;do{var t=s.acceptNumber();if(!t)throw new Error("Unexpected symbol "+s.symbol+", expected hour");for(o.byhour=[parseInt(t[0],10)];s.accept("comma");){if(!(t=s.acceptNumber()))throw new Error("Unexpected symbol "+s.symbol+"; expected hour");o.byhour.push(parseInt(t[0],10))}}while(s.accept("comma")||s.accept("at"))}(),a());break;case"weekday(s)":o.freq=y.default.WEEKLY,o.byweekday=[y.default.MO,y.default.TU,y.default.WE,y.default.TH,y.default.FR],s.nextSymbol(),a();break;case"week(s)":o.freq=y.default.WEEKLY,s.nextSymbol()&&(i(),a());break;case"hour(s)":o.freq=y.default.HOURLY,s.nextSymbol()&&(i(),a());break;case"minute(s)":o.freq=y.default.MINUTELY,s.nextSymbol()&&(i(),a());break;case"month(s)":o.freq=y.default.MONTHLY,s.nextSymbol()&&(i(),a());break;case"year(s)":o.freq=y.default.YEARLY,s.nextSymbol()&&(i(),a());break;case"monday":case"tuesday":case"wednesday":case"thursday":case"friday":case"saturday":case"sunday":o.freq=y.default.WEEKLY;var e=s.symbol.substr(0,2).toUpperCase();if(o.byweekday=[y.default[e]],!s.nextSymbol())return;for(;s.accept("comma");){if(s.isDone())throw new Error("Unexpected end");var n=c();if(!n)throw new Error("Unexpected symbol "+s.symbol+", expected weekday");o.byweekday.push(y.default[n]),s.nextSymbol()}!function(){s.accept("on"),s.accept("the");var t=h();if(!t)return;o.bymonthday=[t],s.nextSymbol();for(;s.accept("comma");){if(!(t=h()))throw new Error("Unexpected symbol "+s.symbol+"; expected monthday");o.bymonthday.push(t),s.nextSymbol()}}(),a();break;case"january":case"february":case"march":case"april":case"may":case"june":case"july":case"august":case"september":case"october":case"november":case"december":if(o.freq=y.default.YEARLY,o.bymonth=[u()],!s.nextSymbol())return;for(;s.accept("comma");){if(s.isDone())throw new Error("Unexpected end");var r=u();if(!r)throw new Error("Unexpected symbol "+s.symbol+", expected month");o.bymonth.push(r),s.nextSymbol()}i(),a();break;default:throw new Error("Unknown symbol")}}(),o):null;function i(){var t=s.accept("on"),e=s.accept("the");if(t||e)do{var n=h(),r=c(),i=u();if(n)r?(s.nextSymbol(),o.byweekday||(o.byweekday=[]),o.byweekday.push(y.default[r].nth(n))):(o.bymonthday||(o.bymonthday=[]),o.bymonthday.push(n),s.accept("day(s)"));else if(r)s.nextSymbol(),o.byweekday||(o.byweekday=[]),o.byweekday.push(y.default[r]);else if("weekday(s)"===s.symbol)s.nextSymbol(),o.byweekday||(o.byweekday=[y.default.MO,y.default.TU,y.default.WE,y.default.TH,y.default.FR]);else if("week(s)"===s.symbol){s.nextSymbol();var a=s.acceptNumber();if(!a)throw new Error("Unexpected symbol "+s.symbol+", expected week number");for(o.byweekno=[parseInt(a[0],10)];s.accept("comma");){if(!(a=s.acceptNumber()))throw new Error("Unexpected symbol "+s.symbol+"; expected monthday");o.byweekno.push(parseInt(a[0],10))}}else{if(!i)return;s.nextSymbol(),o.bymonth||(o.bymonth=[]),o.bymonth.push(i)}}while(s.accept("comma")||s.accept("the")||s.accept("on"))}function u(){switch(s.symbol){case"january":return 1;case"february":return 2;case"march":return 3;case"april":return 4;case"may":return 5;case"june":return 6;case"july":return 7;case"august":return 8;case"september":return 9;case"october":return 10;case"november":return 11;case"december":return 12;default:return!1}}function c(){switch(s.symbol){case"monday":case"tuesday":case"wednesday":case"thursday":case"friday":case"saturday":case"sunday":return s.symbol.substr(0,2).toUpperCase();default:return!1}}function h(){switch(s.symbol){case"last":return s.nextSymbol(),-1;case"first":return s.nextSymbol(),1;case"second":return s.nextSymbol(),s.accept("last")?-2:2;case"third":return s.nextSymbol(),s.accept("last")?-3:3;case"nth":var t=parseInt(s.value[1],10);if(t<-366||366<t)throw new Error("Nth out of range: "+t);return s.nextSymbol(),s.accept("last")?-t:t;default:return!1}}function a(){if("until"===s.symbol){var t=Date.parse(s.text);if(!t)throw new Error("Cannot parse until date:"+s.text);o.until=new Date(t)}else s.accept("for")&&(o.count=parseInt(s.value[0],10),s.expect("number"))}}n.d(e,"fromText",function(){return u}),n.d(e,"isFullyConvertible",function(){return m}),n.d(e,"toText",function(){return p}),n.d(e,"parseText",function(){return s});
/*!
* rrule.js - Library for working with recurrence rules for calendar dates.
* https://github.com/jakubroztocil/rrule
*
* Copyright 2010, Jakub Roztocil and Lars Schoning
* Licenced under the BSD licence.
* https://github.com/jakubroztocil/rrule/blob/master/LICENCE
*
*/
var u=function(t,e){return void 0===e&&(e=d),new y.default(s(t,e)||void 0)},b=["count","until","interval","byweekday","bymonthday","bymonth"];a.IMPLEMENTED=[],a.IMPLEMENTED[y.default.HOURLY]=b,a.IMPLEMENTED[y.default.MINUTELY]=b,a.IMPLEMENTED[y.default.DAILY]=["byhour"].concat(b),a.IMPLEMENTED[y.default.WEEKLY]=b,a.IMPLEMENTED[y.default.MONTHLY]=b,a.IMPLEMENTED[y.default.YEARLY]=["byweekno","byyearday"].concat(b);var p=function(t,e,n,r){return new a(t,e,n,r).toString()},m=a.isFullyConvertible}],i.c=r,i.d=function(t,e,n){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)i.d(n,r,function(t){return e[t]}.bind(null,r));return n},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=1);function i(t){if(r[t])return r[t].exports;var e=r[t]={i:t,l:!1,exports:{}};return n[t].call(e.exports,e,e.exports,i),e.l=!0,e.exports}var n,r});;/// <reference path="./es6.d.ts" />
/// <reference path="./Reflect.d.ts" />
// Harmony Reflect
// (C) 2015 Alex Mattrick. MIT License.
var hasOwnProperty = Object.prototype.hasOwnProperty;
var Reflect;
(function (Reflect) {
    // 26.1.1
    function apply(target, thisArgument, argumentsList) {
        // 1. If IsCallable(target) is false, throw a TypeError exception.
        if (!IsCallable(target)) {
            throw new TypeError(target + ' is not callable.');
        }
        // 2. Let args be CreateListFromArrayLike(argumentsList).
        var args = CreateListFromArrayLike(argumentsList);
        // 3. ReturnIfAbrupt(args)
        // 4. Perform PrepareForTailCall().
        // 5. Return Call(target, thisArgument, args)
        return target.apply(thisArgument, args);
    }
    Reflect.apply = apply;
    // 26.1.2
    function construct(target, argumentsList, newTarget) {
        // 1. If IsConstructor(target) is false, throw a TypeError exception.
        // if (!IsConstructor(target)) {
        //  throw new TypeError();
        // }
        // 2. If newTarget is not present, let newTarget be target.
        if (newTarget === void 0) { newTarget = target; }
        // 3. Else, if IsConstructor(newTarget) is false, throw a TypeError exception.
        // if (!IsConstructor(newTarget)) {
        //   throw new TypeError();
        // }
        // 4. Let args be CreateListFromArrayLike(argumentsList).
        var args = CreateListFromArrayLike(argumentsList);
        // 5. ReturnIfAbrupt(args).
        // 6. Return Construct(target, args, newTarget).
        return Construct(target, args, newTarget);
    }
    Reflect.construct = construct;
    construct.length = 2;
    // 26.1.3
    function defineProperty(target, propertyKey, attributes) {
        // 1. If Type(target) is not Object, throw a TypeError exception.
        if (typeof target !== 'object') {
            throw new TypeError();
        }
        // 2. Let key be ToPropertyKey(propertyKey).
        var key = ToPropertyKey(propertyKey);
        // 3. ReturnIfAbrupt(key).
        // 4. Let desc be ToPropertyDescriptor(attributes).
        var desc = attributes;
        // 5. ReturnIfAbrupt(desc).
        // 6. Return target.[[DefineOwnProperty]](key, desc).
        try {
            Object.defineProperty(target, key, desc);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    Reflect.defineProperty = defineProperty;
    function deleteProperty(target, propertyKey) {
        if (typeof target !== 'object') {
            throw new TypeError();
        }
        var key = ToPropertyKey(propertyKey);
        try {
            return delete target[key];
        }
        catch (e) {
            return false;
        }
    }
    Reflect.deleteProperty = deleteProperty;
    function enumerate(target) {
        if (typeof target !== 'object') {
            throw new TypeError();
        }
        var keys = [];
        for (var key_1 in target) {
            keys.push(key_1);
        }
        return createArrayIterator(keys);
    }
    Reflect.enumerate = enumerate;
    function get(target, propertyKey, receiver) {
        if (receiver === void 0) { receiver = target; }
        if (typeof target !== 'object') {
            throw new TypeError('Reflect.get: target must be an object.');
        }
        var desc = Object.getOwnPropertyDescriptor(target, propertyKey);
        if (typeof desc.get === 'function') {
            return desc.get.call(receiver);
        }
        else {
            return target[propertyKey];
        }
    }
    Reflect.get = get;
    get.length = 2;
    function getOwnPropertyDescriptor(target, propertyKey) {
        if (typeof target !== 'object') {
            throw new TypeError();
        }
        var key = ToPropertyKey(propertyKey);
        // let desc = GetOwnProperty(target, key);
        return Object.getOwnPropertyDescriptor(target, key);
    }
    Reflect.getOwnPropertyDescriptor = getOwnPropertyDescriptor;
    function getPrototypeOf(target) {
        if (typeof target !== 'object') {
            throw new TypeError();
        }
        return Object.getPrototypeOf(target);
    }
    Reflect.getPrototypeOf = getPrototypeOf;
    function has(target, propertyKey) {
        if (typeof target !== 'object') {
            throw new TypeError();
        }
        var key = ToPropertyKey(propertyKey);
        return HasProperty(target, key);
    }
    Reflect.has = has;
    function isExtensible(target) {
        if (typeof target !== 'object') {
            throw new TypeError();
        }
        return Object.isExtensible(target);
    }
    Reflect.isExtensible = isExtensible;
    function ownKeys(target) {
        if (typeof target !== 'object') {
            throw new TypeError();
        }
        var keys = OwnPropertyKeys(target);
        return CreateListFromArrayLike(keys);
    }
    Reflect.ownKeys = ownKeys;
    function preventExtensions(target) {
        if (typeof target !== 'object') {
            throw new TypeError();
        }
        try {
            Object.preventExtensions(target);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    Reflect.preventExtensions = preventExtensions;
    function set(target, propertyKey, value, receiver) {
        if (receiver === void 0) { receiver = target; }
        if (typeof target !== 'object') {
            throw new TypeError();
        }
        var key = ToPropertyKey(propertyKey);
        try {
            target[key] = value;
            return true;
        }
        catch (e) {
            return false;
        }
    }
    Reflect.set = set;
    set.length = 3;
    function setPrototypeOf(target, proto) {
        if (typeof target !== 'object') {
            throw new TypeError();
        }
        if (typeof proto !== 'object' && proto !== null) {
            throw new TypeError();
        }
        try {
            if (typeof Object.setPrototypeOf === 'function') {
                Object.setPrototypeOf(target, proto);
            }
            else {
                target.__proto__ = proto;
            }
            return true;
        }
        catch (e) {
            return false;
        }
    }
    Reflect.setPrototypeOf = setPrototypeOf;
})(Reflect || (Reflect = {}));
;
var context = typeof global !== 'undefined' ? global : window;
if (typeof context.Reflect !== 'object') {
    context.Reflect = Reflect;
}
else {
    for (var key in Reflect) {
        if (Reflect.hasOwnProperty(key) && typeof context.Reflect[key] === 'undefined') {
            context.Reflect[key] = Reflect[key];
        }
    }
}
// Specs Internal Methods
// 7.2.3 IsCallable (argument)
function IsCallable(obj) {
    return (typeof obj !== 'object') && (typeof obj.call === 'function');
}
// 7.3.17 CreateListFromArrayLike (obj [, elementTypes])
var defaultElementTypes = ['undefined', 'null', 'boolean', 'string', 'symbol', 'number', 'object'];
function CreateListFromArrayLike(obj, elementTypes) {
    if (elementTypes === void 0) { elementTypes = defaultElementTypes; }
    if (typeof obj !== 'object') {
        throw new TypeError();
    }
    var len = Number(obj.length);
    var list = [], index = 0;
    while (index < len) {
        var indexName = ToString(index);
        var next = obj[indexName];
        if (elementTypes.indexOf(Type(next)) === -1) {
            throw new TypeError();
        }
        list.push(next);
        index++;
    }
    return list;
}
function Type(obj) {
    return (obj === null) ? 'null' : typeof obj;
}
// 7.1.12 ToString
function ToString(arg) {
    if (typeof arg === 'symbol') {
        throw new TypeError();
    }
    else {
        return String(arg);
    }
}
function Construct(F, argumentsList, newTarget) {
    if (argumentsList === void 0) { argumentsList = []; }
    if (newTarget === void 0) { newTarget = F; }
    // assert(IsConstructor(F));
    // assert(IsConstructor(newTarget));
    return new ((_a = Function.prototype.bind).call.apply(_a, [F, newTarget].concat(argumentsList)));
    var _a;
}
function assert(condition) {
    if (!condition)
        throw new Error();
}
// 7.1.14
function ToPropertyKey(arg) {
    return (typeof arg === 'symbol') ? arg : String(arg);
}
// 7.2.7
function IsPropertyKey(arg) {
    return (typeof arg === 'string' || typeof arg === 'symbol');
}
// 7.3.10
function HasProperty(O, P) {
    assert(Type(O) === 'object');
    assert(IsPropertyKey(P));
    return P in O;
}
// 9.1.12 [[]]
function OwnPropertyKeys(obj) {
    var keys = [];
    var propertyNames = Object.getOwnPropertyNames(obj);
    for (var P = 0; propertyNames.indexOf(String(P)) !== -1; P++) {
        keys.push(P);
    }
    keys = keys.concat(propertyNames.filter(function (name) { return isNaN(Number(name)); }));
    if (typeof Object.getOwnPropertySymbols === 'function') {
        keys = keys.concat(Object.getOwnPropertySymbols(obj));
    }
    return keys;
}
function createArrayIterator(arr) {
    var index = 0;
    return (_a = {},
        _a[Symbol.iterator] = function () {
            return this;
        },
        _a.next = function () {
            if (index < arr.length) {
                return { done: false, value: arr[index++] };
            }
            else {
                return { done: true };
            }
        },
        _a
    );
    var _a;
}
;!function r(e,t,n){function o(u,f){if(!t[u]){if(!e[u]){var c="function"==typeof require&&require;if(!f&&c)return c(u,!0);if(i)return i(u,!0);var a=new Error("Cannot find module '"+u+"'");throw a.code="MODULE_NOT_FOUND",a}var l=t[u]={exports:{}};e[u][0].call(l.exports,function(r){var t=e[u][1][r];return o(t?t:r)},l,l.exports,r,e,t,n)}return t[u].exports}for(var i="function"==typeof require&&require,u=0;u<n.length;u++)o(n[u]);return o}({1:[function(r,e,t){"use strict";r("./index").polyfill()},{"./index":2}],2:[function(r,e,t){"use strict";function n(r,e){if(void 0===r||null===r)throw new TypeError("Cannot convert first argument to object");for(var t=Object(r),n=1;n<arguments.length;n++){var o=arguments[n];if(void 0!==o&&null!==o)for(var i=Object.keys(Object(o)),u=0,f=i.length;u<f;u++){var c=i[u],a=Object.getOwnPropertyDescriptor(o,c);void 0!==a&&a.enumerable&&(t[c]=o[c])}}return t}function o(){Object.assign||Object.defineProperty(Object,"assign",{enumerable:!1,configurable:!0,writable:!0,value:n})}e.exports={assign:n,polyfill:o}},{}]},{},[1]);
;/*! https://mths.be/startswith v0.2.0 by @mathias */
if (!String.prototype.startsWith) {
	(function() {
		'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
		var defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var toString = {}.toString;
		var startsWith = function(search) {
			if (this == null) {
				throw TypeError();
			}
			var string = String(this);
			if (search && toString.call(search) == '[object RegExp]') {
				throw TypeError();
			}
			var stringLength = string.length;
			var searchString = String(search);
			var searchLength = searchString.length;
			var position = arguments.length > 1 ? arguments[1] : undefined;
			// `ToInteger`
			var pos = position ? Number(position) : 0;
			if (pos != pos) { // better `isNaN`
				pos = 0;
			}
			var start = Math.min(Math.max(pos, 0), stringLength);
			// Avoid the `indexOf` call if no match is possible
			if (searchLength + start > stringLength) {
				return false;
			}
			var index = -1;
			while (++index < searchLength) {
				if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
					return false;
				}
			}
			return true;
		};
		if (defineProperty) {
			defineProperty(String.prototype, 'startsWith', {
				'value': startsWith,
				'configurable': true,
				'writable': true
			});
		} else {
			String.prototype.startsWith = startsWith;
		}
	}());
}
;/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2020 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */
(function(t,r){"use strict";if(typeof define==="function"&&define.amd){define(r)}else if(typeof exports==="object"){module.exports=r()}else{t.returnExports=r()}})(this,function(){var t=Array;var r=t.prototype;var e=Object;var n=e.prototype;var i=Function;var a=i.prototype;var o=String;var f=o.prototype;var u=Number;var l=u.prototype;var s=r.slice;var c=r.splice;var v=r.push;var h=r.unshift;var p=r.concat;var y=r.join;var d=a.call;var g=a.apply;var w=Math.max;var b=Math.min;var T=n.toString;var m=typeof Symbol==="function"&&typeof Symbol.toStringTag==="symbol";var D;var S=Function.prototype.toString,x=/^\s*class /,O=function isES6ClassFn(t){try{var r=S.call(t);var e=r.replace(/\/\/.*\n/g,"");var n=e.replace(/\/\*[.\s\S]*\*\//g,"");var i=n.replace(/\n/gm," ").replace(/ {2}/g," ");return x.test(i)}catch(a){return false}},E=function tryFunctionObject(t){try{if(O(t)){return false}S.call(t);return true}catch(r){return false}},j="[object Function]",I="[object GeneratorFunction]",D=function isCallable(t){if(!t){return false}if(typeof t!=="function"&&typeof t!=="object"){return false}if(m){return E(t)}if(O(t)){return false}var r=T.call(t);return r===j||r===I};var M;var U=RegExp.prototype.exec,$=function tryRegexExec(t){try{U.call(t);return true}catch(r){return false}},F="[object RegExp]";M=function isRegex(t){if(typeof t!=="object"){return false}return m?$(t):T.call(t)===F};var N;var C=String.prototype.valueOf,k=function tryStringObject(t){try{C.call(t);return true}catch(r){return false}},A="[object String]";N=function isString(t){if(typeof t==="string"){return true}if(typeof t!=="object"){return false}return m?k(t):T.call(t)===A};var R=e.defineProperty&&function(){try{var t={};e.defineProperty(t,"x",{enumerable:false,value:t});for(var r in t){return false}return t.x===t}catch(n){return false}}();var P=function(t){var r;if(R){r=function(t,r,n,i){if(!i&&r in t){return}e.defineProperty(t,r,{configurable:true,enumerable:false,writable:true,value:n})}}else{r=function(t,r,e,n){if(!n&&r in t){return}t[r]=e}}return function defineProperties(e,n,i){for(var a in n){if(t.call(n,a)){r(e,a,n[a],i)}}}}(n.hasOwnProperty);var J=function isPrimitive(t){var r=typeof t;return t===null||r!=="object"&&r!=="function"};var Y=u.isNaN||function isActualNaN(t){return t!==t};var z={ToInteger:function ToInteger(t){var r=+t;if(Y(r)){r=0}else if(r!==0&&r!==1/0&&r!==-(1/0)){r=(r>0||-1)*Math.floor(Math.abs(r))}return r},ToPrimitive:function ToPrimitive(t){var r,e,n;if(J(t)){return t}e=t.valueOf;if(D(e)){r=e.call(t);if(J(r)){return r}}n=t.toString;if(D(n)){r=n.call(t);if(J(r)){return r}}throw new TypeError},ToObject:function(t){if(t==null){throw new TypeError("can't convert "+t+" to object")}return e(t)},ToUint32:function ToUint32(t){return t>>>0}};var Z=function Empty(){};P(a,{bind:function bind(t){var r=this;if(!D(r)){throw new TypeError("Function.prototype.bind called on incompatible "+r)}var n=s.call(arguments,1);var a;var o=function(){if(this instanceof a){var i=g.call(r,this,p.call(n,s.call(arguments)));if(e(i)===i){return i}return this}else{return g.call(r,t,p.call(n,s.call(arguments)))}};var f=w(0,r.length-n.length);var u=[];for(var l=0;l<f;l++){v.call(u,"$"+l)}a=i("binder","return function ("+y.call(u,",")+"){ return binder.apply(this, arguments); }")(o);if(r.prototype){Z.prototype=r.prototype;a.prototype=new Z;Z.prototype=null}return a}});var G=d.bind(n.hasOwnProperty);var H=d.bind(n.toString);var W=d.bind(s);var B=g.bind(s);if(typeof document==="object"&&document&&document.documentElement){try{W(document.documentElement.childNodes)}catch(X){var L=W;var q=B;W=function arraySliceIE(t){var r=[];var e=t.length;while(e-- >0){r[e]=t[e]}return q(r,L(arguments,1))};B=function arraySliceApplyIE(t,r){return q(W(t),r)}}}var K=d.bind(f.slice);var Q=d.bind(f.split);var V=d.bind(f.indexOf);var _=d.bind(v);var tt=d.bind(n.propertyIsEnumerable);var rt=d.bind(r.sort);var et=t.isArray||function isArray(t){return H(t)==="[object Array]"};var nt=[].unshift(0)!==1;P(r,{unshift:function(){h.apply(this,arguments);return this.length}},nt);P(t,{isArray:et});var it=e("a");var at=it[0]!=="a"||!(0 in it);var ot=function properlyBoxed(t){var r=true;var e=true;var n=false;if(t){try{t.call("foo",function(t,e,n){if(typeof n!=="object"){r=false}});t.call([1],function(){"use strict";e=typeof this==="string"},"x")}catch(i){n=true}}return!!t&&!n&&r&&e};P(r,{forEach:function forEach(t){var r=z.ToObject(this);var e=at&&N(this)?Q(this,""):r;var n=-1;var i=z.ToUint32(e.length);var a;if(arguments.length>1){a=arguments[1]}if(!D(t)){throw new TypeError("Array.prototype.forEach callback must be a function")}while(++n<i){if(n in e){if(typeof a==="undefined"){t(e[n],n,r)}else{t.call(a,e[n],n,r)}}}}},!ot(r.forEach));P(r,{map:function map(r){var e=z.ToObject(this);var n=at&&N(this)?Q(this,""):e;var i=z.ToUint32(n.length);var a=t(i);var o;if(arguments.length>1){o=arguments[1]}if(!D(r)){throw new TypeError("Array.prototype.map callback must be a function")}for(var f=0;f<i;f++){if(f in n){if(typeof o==="undefined"){a[f]=r(n[f],f,e)}else{a[f]=r.call(o,n[f],f,e)}}}return a}},!ot(r.map));P(r,{filter:function filter(t){var r=z.ToObject(this);var e=at&&N(this)?Q(this,""):r;var n=z.ToUint32(e.length);var i=[];var a;var o;if(arguments.length>1){o=arguments[1]}if(!D(t)){throw new TypeError("Array.prototype.filter callback must be a function")}for(var f=0;f<n;f++){if(f in e){a=e[f];if(typeof o==="undefined"?t(a,f,r):t.call(o,a,f,r)){_(i,a)}}}return i}},!ot(r.filter));P(r,{every:function every(t){var r=z.ToObject(this);var e=at&&N(this)?Q(this,""):r;var n=z.ToUint32(e.length);var i;if(arguments.length>1){i=arguments[1]}if(!D(t)){throw new TypeError("Array.prototype.every callback must be a function")}for(var a=0;a<n;a++){if(a in e&&!(typeof i==="undefined"?t(e[a],a,r):t.call(i,e[a],a,r))){return false}}return true}},!ot(r.every));P(r,{some:function some(t){var r=z.ToObject(this);var e=at&&N(this)?Q(this,""):r;var n=z.ToUint32(e.length);var i;if(arguments.length>1){i=arguments[1]}if(!D(t)){throw new TypeError("Array.prototype.some callback must be a function")}for(var a=0;a<n;a++){if(a in e&&(typeof i==="undefined"?t(e[a],a,r):t.call(i,e[a],a,r))){return true}}return false}},!ot(r.some));var ft=false;if(r.reduce){ft=typeof r.reduce.call("es5",function(t,r,e,n){return n})==="object"}P(r,{reduce:function reduce(t){var r=z.ToObject(this);var e=at&&N(this)?Q(this,""):r;var n=z.ToUint32(e.length);if(!D(t)){throw new TypeError("Array.prototype.reduce callback must be a function")}if(n===0&&arguments.length===1){throw new TypeError("reduce of empty array with no initial value")}var i=0;var a;if(arguments.length>=2){a=arguments[1]}else{do{if(i in e){a=e[i++];break}if(++i>=n){throw new TypeError("reduce of empty array with no initial value")}}while(true)}for(;i<n;i++){if(i in e){a=t(a,e[i],i,r)}}return a}},!ft);var ut=false;if(r.reduceRight){ut=typeof r.reduceRight.call("es5",function(t,r,e,n){return n})==="object"}P(r,{reduceRight:function reduceRight(t){var r=z.ToObject(this);var e=at&&N(this)?Q(this,""):r;var n=z.ToUint32(e.length);if(!D(t)){throw new TypeError("Array.prototype.reduceRight callback must be a function")}if(n===0&&arguments.length===1){throw new TypeError("reduceRight of empty array with no initial value")}var i;var a=n-1;if(arguments.length>=2){i=arguments[1]}else{do{if(a in e){i=e[a--];break}if(--a<0){throw new TypeError("reduceRight of empty array with no initial value")}}while(true)}if(a<0){return i}do{if(a in e){i=t(i,e[a],a,r)}}while(a--);return i}},!ut);var lt=r.indexOf&&[0,1].indexOf(1,2)!==-1;P(r,{indexOf:function indexOf(t){var r=at&&N(this)?Q(this,""):z.ToObject(this);var e=z.ToUint32(r.length);if(e===0){return-1}var n=0;if(arguments.length>1){n=z.ToInteger(arguments[1])}n=n>=0?n:w(0,e+n);for(;n<e;n++){if(n in r&&r[n]===t){return n}}return-1}},lt);var st=r.lastIndexOf&&[0,1].lastIndexOf(0,-3)!==-1;P(r,{lastIndexOf:function lastIndexOf(t){var r=at&&N(this)?Q(this,""):z.ToObject(this);var e=z.ToUint32(r.length);if(e===0){return-1}var n=e-1;if(arguments.length>1){n=b(n,z.ToInteger(arguments[1]))}n=n>=0?n:e-Math.abs(n);for(;n>=0;n--){if(n in r&&t===r[n]){return n}}return-1}},st);var ct=function(){var t=[1,2];var r=t.splice();return t.length===2&&et(r)&&r.length===0}();P(r,{splice:function splice(t,r){if(arguments.length===0){return[]}else{return c.apply(this,arguments)}}},!ct);var vt=function(){var t={};r.splice.call(t,0,0,1);return t.length===1}();P(r,{splice:function splice(t,r){if(arguments.length===0){return[]}var e=arguments;this.length=w(z.ToInteger(this.length),0);if(arguments.length>0&&typeof r!=="number"){e=W(arguments);if(e.length<2){_(e,this.length-t)}else{e[1]=z.ToInteger(r)}}return c.apply(this,e)}},!vt);var ht=function(){var r=new t(1e5);r[8]="x";r.splice(1,1);return r.indexOf("x")===7}();var pt=function(){var t=256;var r=[];r[t]="a";r.splice(t+1,0,"b");return r[t]==="a"}();P(r,{splice:function splice(t,r){var e=z.ToObject(this);var n=[];var i=z.ToUint32(e.length);var a=z.ToInteger(t);var f=a<0?w(i+a,0):b(a,i);var u=arguments.length===0?0:arguments.length===1?i-f:b(w(z.ToInteger(r),0),i-f);var l=0;var s;while(l<u){s=o(f+l);if(G(e,s)){n[l]=e[s]}l+=1}var c=W(arguments,2);var v=c.length;var h;if(v<u){l=f;var p=i-u;while(l<p){s=o(l+u);h=o(l+v);if(G(e,s)){e[h]=e[s]}else{delete e[h]}l+=1}l=i;var y=i-u+v;while(l>y){delete e[l-1];l-=1}}else if(v>u){l=i-u;while(l>f){s=o(l+u-1);h=o(l+v-1);if(G(e,s)){e[h]=e[s]}else{delete e[h]}l-=1}}l=f;for(var d=0;d<c.length;++d){e[l]=c[d];l+=1}e.length=i-u+v;return n}},!ht||!pt);var yt=r.join;var dt;try{dt=Array.prototype.join.call("123",",")!=="1,2,3"}catch(X){dt=true}if(dt){P(r,{join:function join(t){var r=typeof t==="undefined"?",":t;return yt.call(N(this)?Q(this,""):this,r)}},dt)}var gt=[1,2].join(undefined)!=="1,2";if(gt){P(r,{join:function join(t){var r=typeof t==="undefined"?",":t;return yt.call(this,r)}},gt)}var wt=function push(t){var r=z.ToObject(this);var e=z.ToUint32(r.length);var n=0;while(n<arguments.length){r[e+n]=arguments[n];n+=1}r.length=e+n;return e+n};var bt=function(){var t={};var r=Array.prototype.push.call(t,undefined);return r!==1||t.length!==1||typeof t[0]!=="undefined"||!G(t,0)}();P(r,{push:function push(t){if(et(this)){return v.apply(this,arguments)}return wt.apply(this,arguments)}},bt);var Tt=function(){var t=[];var r=t.push(undefined);return r!==1||t.length!==1||typeof t[0]!=="undefined"||!G(t,0)}();P(r,{push:wt},Tt);P(r,{slice:function(t,r){var e=N(this)?Q(this,""):this;return B(e,arguments)}},at);var mt=function(){try{[1,2].sort(null)}catch(t){try{[1,2].sort({})}catch(r){return false}}return true}();var Dt=function(){try{[1,2].sort(/a/);return false}catch(t){}return true}();var St=function(){try{[1,2].sort(undefined);return true}catch(t){}return false}();P(r,{sort:function sort(t){if(typeof t==="undefined"){return rt(this)}if(!D(t)){throw new TypeError("Array.prototype.sort callback must be a function")}return rt(this,t)}},mt||!St||!Dt);var xt=!tt({toString:null},"toString");var Ot=tt(function(){},"prototype");var Et=!G("x","0");var jt=function(t){var r=t.constructor;return r&&r.prototype===t};var It={$applicationCache:true,$console:true,$external:true,$frame:true,$frameElement:true,$frames:true,$innerHeight:true,$innerWidth:true,$onmozfullscreenchange:true,$onmozfullscreenerror:true,$outerHeight:true,$outerWidth:true,$pageXOffset:true,$pageYOffset:true,$parent:true,$scrollLeft:true,$scrollTop:true,$scrollX:true,$scrollY:true,$self:true,$webkitIndexedDB:true,$webkitStorageInfo:true,$window:true,$width:true,$height:true,$top:true,$localStorage:true};var Mt=function(){if(typeof window==="undefined"){return false}for(var t in window){try{if(!It["$"+t]&&G(window,t)&&window[t]!==null&&typeof window[t]==="object"){jt(window[t])}}catch(r){return true}}return false}();var Ut=function(t){if(typeof window==="undefined"||!Mt){return jt(t)}try{return jt(t)}catch(r){return false}};var $t=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"];var Ft=$t.length;var Nt=function isArguments(t){return H(t)==="[object Arguments]"};var Ct=function isArguments(t){return t!==null&&typeof t==="object"&&typeof t.length==="number"&&t.length>=0&&!et(t)&&D(t.callee)};var kt=Nt(arguments)?Nt:Ct;P(e,{keys:function keys(t){var r=D(t);var e=kt(t);var n=t!==null&&typeof t==="object";var i=n&&N(t);if(!n&&!r&&!e){throw new TypeError("Object.keys called on a non-object")}var a=[];var f=Ot&&r;if(i&&Et||e){for(var u=0;u<t.length;++u){_(a,o(u))}}if(!e){for(var l in t){if(!(f&&l==="prototype")&&G(t,l)){_(a,o(l))}}}if(xt){var s=Ut(t);for(var c=0;c<Ft;c++){var v=$t[c];if(!(s&&v==="constructor")&&G(t,v)){_(a,v)}}}return a}});var At=e.keys&&function(){return e.keys(arguments).length===2}(1,2);var Rt=e.keys&&function(){var t=e.keys(arguments);return arguments.length!==1||t.length!==1||t[0]!==1}(1);var Pt=e.keys;P(e,{keys:function keys(t){if(kt(t)){return Pt(W(t))}else{return Pt(t)}}},!At||Rt);var Jt=new Date(-0xc782b5b342b24).getUTCMonth()!==0;var Yt=new Date(-0x55d318d56a724);var zt=new Date(14496624e5);var Zt=Yt.toUTCString()!=="Mon, 01 Jan -45875 11:59:59 GMT";var Gt;var Ht;var Wt=Yt.getTimezoneOffset();if(Wt<-720){Gt=Yt.toDateString()!=="Tue Jan 02 -45875";Ht=!/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/.test(String(zt))}else{Gt=Yt.toDateString()!=="Mon Jan 01 -45875";Ht=!/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/.test(String(zt))}var Bt=d.bind(Date.prototype.getFullYear);var Xt=d.bind(Date.prototype.getMonth);var Lt=d.bind(Date.prototype.getDate);var qt=d.bind(Date.prototype.getUTCFullYear);var Kt=d.bind(Date.prototype.getUTCMonth);var Qt=d.bind(Date.prototype.getUTCDate);var Vt=d.bind(Date.prototype.getUTCDay);var _t=d.bind(Date.prototype.getUTCHours);var tr=d.bind(Date.prototype.getUTCMinutes);var rr=d.bind(Date.prototype.getUTCSeconds);var er=d.bind(Date.prototype.getUTCMilliseconds);var nr=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];var ir=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];var ar=function daysInMonth(t,r){return Lt(new Date(r,t,0))};P(Date.prototype,{getFullYear:function getFullYear(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Bt(this);if(t<0&&Xt(this)>11){return t+1}return t},getMonth:function getMonth(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Bt(this);var r=Xt(this);if(t<0&&r>11){return 0}return r},getDate:function getDate(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Bt(this);var r=Xt(this);var e=Lt(this);if(t<0&&r>11){if(r===12){return e}var n=ar(0,t+1);return n-e+1}return e},getUTCFullYear:function getUTCFullYear(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=qt(this);if(t<0&&Kt(this)>11){return t+1}return t},getUTCMonth:function getUTCMonth(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=qt(this);var r=Kt(this);if(t<0&&r>11){return 0}return r},getUTCDate:function getUTCDate(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=qt(this);var r=Kt(this);var e=Qt(this);if(t<0&&r>11){if(r===12){return e}var n=ar(0,t+1);return n-e+1}return e}},Jt);P(Date.prototype,{toUTCString:function toUTCString(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=Vt(this);var r=Qt(this);var e=Kt(this);var n=qt(this);var i=_t(this);var a=tr(this);var o=rr(this);return nr[t]+", "+(r<10?"0"+r:r)+" "+ir[e]+" "+n+" "+(i<10?"0"+i:i)+":"+(a<10?"0"+a:a)+":"+(o<10?"0"+o:o)+" GMT"}},Jt||Zt);P(Date.prototype,{toDateString:function toDateString(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=this.getDay();var r=this.getDate();var e=this.getMonth();var n=this.getFullYear();return nr[t]+" "+ir[e]+" "+(r<10?"0"+r:r)+" "+n}},Jt||Gt);if(Jt||Ht){Date.prototype.toString=function toString(){if(!this||!(this instanceof Date)){throw new TypeError("this is not a Date object.")}var t=this.getDay();var r=this.getDate();var e=this.getMonth();var n=this.getFullYear();var i=this.getHours();var a=this.getMinutes();var o=this.getSeconds();var f=this.getTimezoneOffset();var u=Math.floor(Math.abs(f)/60);var l=Math.floor(Math.abs(f)%60);return nr[t]+" "+ir[e]+" "+(r<10?"0"+r:r)+" "+n+" "+(i<10?"0"+i:i)+":"+(a<10?"0"+a:a)+":"+(o<10?"0"+o:o)+" GMT"+(f>0?"-":"+")+(u<10?"0"+u:u)+(l<10?"0"+l:l)};if(R){e.defineProperty(Date.prototype,"toString",{configurable:true,enumerable:false,writable:true})}}var or=-621987552e5;var fr="-000001";var ur=Date.prototype.toISOString&&new Date(or).toISOString().indexOf(fr)===-1;var lr=Date.prototype.toISOString&&new Date(-1).toISOString()!=="1969-12-31T23:59:59.999Z";var sr=d.bind(Date.prototype.getTime);P(Date.prototype,{toISOString:function toISOString(){if(!isFinite(this)||!isFinite(sr(this))){throw new RangeError("Date.prototype.toISOString called on non-finite value.")}var t=qt(this);var r=Kt(this);t+=Math.floor(r/12);r=(r%12+12)%12;var e=[r+1,Qt(this),_t(this),tr(this),rr(this)];t=(t<0?"-":t>9999?"+":"")+K("00000"+Math.abs(t),0<=t&&t<=9999?-4:-6);for(var n=0;n<e.length;++n){e[n]=K("00"+e[n],-2)}return t+"-"+W(e,0,2).join("-")+"T"+W(e,2).join(":")+"."+K("000"+er(this),-3)+"Z"}},ur||lr);var cr=function(){try{return Date.prototype.toJSON&&new Date(NaN).toJSON()===null&&new Date(or).toJSON().indexOf(fr)!==-1&&Date.prototype.toJSON.call({toISOString:function(){return true}})}catch(t){return false}}();if(!cr){Date.prototype.toJSON=function toJSON(t){var r=e(this);var n=z.ToPrimitive(r);if(typeof n==="number"&&!isFinite(n)){return null}var i=r.toISOString;if(!D(i)){throw new TypeError("toISOString property is not callable")}return i.call(r)}}var vr=Date.parse("+033658-09-27T01:46:40.000Z")===1e15;var hr=!isNaN(Date.parse("2012-04-04T24:00:00.500Z"))||!isNaN(Date.parse("2012-11-31T23:59:59.000Z"))||!isNaN(Date.parse("2012-12-31T23:59:60.000Z"));var pr=isNaN(Date.parse("2000-01-01T00:00:00.000Z"));if(pr||hr||!vr){var yr=Math.pow(2,31)-1;var dr=Y(new Date(1970,0,1,0,0,0,yr+1).getTime());Date=function(t){var r=function Date(e,n,i,a,f,u,l){var s=arguments.length;var c;if(this instanceof t){var v=u;var h=l;if(dr&&s>=7&&l>yr){var p=Math.floor(l/yr)*yr;var y=Math.floor(p/1e3);v+=y;h-=y*1e3}c=s===1&&o(e)===e?new t(r.parse(e)):s>=7?new t(e,n,i,a,f,v,h):s>=6?new t(e,n,i,a,f,v):s>=5?new t(e,n,i,a,f):s>=4?new t(e,n,i,a):s>=3?new t(e,n,i):s>=2?new t(e,n):s>=1?new t(e instanceof t?+e:e):new t}else{c=t.apply(this,arguments)}if(!J(c)){P(c,{constructor:r},true)}return c};var e=new RegExp("^"+"(\\d{4}|[+-]\\d{6})"+"(?:-(\\d{2})"+"(?:-(\\d{2})"+"(?:"+"T(\\d{2})"+":(\\d{2})"+"(?:"+":(\\d{2})"+"(?:(\\.\\d{1,}))?"+")?"+"("+"Z|"+"(?:"+"([-+])"+"(\\d{2})"+":(\\d{2})"+")"+")?)?)?)?"+"$");var n=[0,31,59,90,120,151,181,212,243,273,304,334,365];var i=function dayFromMonth(t,r){var e=r>1?1:0;return n[r]+Math.floor((t-1969+e)/4)-Math.floor((t-1901+e)/100)+Math.floor((t-1601+e)/400)+365*(t-1970)};var a=function toUTC(r){var e=0;var n=r;if(dr&&n>yr){var i=Math.floor(n/yr)*yr;var a=Math.floor(i/1e3);e+=a;n-=a*1e3}return u(new t(1970,0,1,0,0,e,n))};for(var f in t){if(G(t,f)){r[f]=t[f]}}P(r,{now:t.now,UTC:t.UTC},true);r.prototype=t.prototype;P(r.prototype,{constructor:r},true);var l=function parse(r){var n=e.exec(r);if(n){var o=u(n[1]),f=u(n[2]||1)-1,l=u(n[3]||1)-1,s=u(n[4]||0),c=u(n[5]||0),v=u(n[6]||0),h=Math.floor(u(n[7]||0)*1e3),p=Boolean(n[4]&&!n[8]),y=n[9]==="-"?1:-1,d=u(n[10]||0),g=u(n[11]||0),w;var b=c>0||v>0||h>0;if(s<(b?24:25)&&c<60&&v<60&&h<1e3&&f>-1&&f<12&&d<24&&g<60&&l>-1&&l<i(o,f+1)-i(o,f)){w=((i(o,f)+l)*24+s+d*y)*60;w=((w+c+g*y)*60+v)*1e3+h;if(p){w=a(w)}if(-864e13<=w&&w<=864e13){return w}}return NaN}return t.parse.apply(this,arguments)};P(r,{parse:l});return r}(Date)}if(!Date.now){Date.now=function now(){return(new Date).getTime()}}var gr=l.toFixed&&(8e-5.toFixed(3)!=="0.000"||.9.toFixed(0)!=="1"||1.255.toFixed(2)!=="1.25"||(1000000000000000128).toFixed(0)!=="1000000000000000128");var wr={base:1e7,size:6,data:[0,0,0,0,0,0],multiply:function multiply(t,r){var e=-1;var n=r;while(++e<wr.size){n+=t*wr.data[e];wr.data[e]=n%wr.base;n=Math.floor(n/wr.base)}},divide:function divide(t){var r=wr.size;var e=0;while(--r>=0){e+=wr.data[r];wr.data[r]=Math.floor(e/t);e=e%t*wr.base}},numToString:function numToString(){var t=wr.size;var r="";while(--t>=0){if(r!==""||t===0||wr.data[t]!==0){var e=o(wr.data[t]);if(r===""){r=e}else{r+=K("0000000",0,7-e.length)+e}}}return r},pow:function pow(t,r,e){return r===0?e:r%2===1?pow(t,r-1,e*t):pow(t*t,r/2,e)},log:function log(t){var r=0;var e=t;while(e>=4096){r+=12;e/=4096}while(e>=2){r+=1;e/=2}return r}};var br=function toFixed(t){var r,e,n,i,a,f,l,s;r=u(t);r=Y(r)?0:Math.floor(r);if(r<0||r>20){throw new RangeError("Number.toFixed called with invalid number of decimals")}e=u(this);if(Y(e)){return"NaN"}if(e<=-1e21||e>=1e21){return o(e)}n="";if(e<0){n="-";e=-e}i="0";if(e>1e-21){a=wr.log(e*wr.pow(2,69,1))-69;f=a<0?e*wr.pow(2,-a,1):e/wr.pow(2,a,1);f*=4503599627370496;a=52-a;if(a>0){wr.multiply(0,f);l=r;while(l>=7){wr.multiply(1e7,0);l-=7}wr.multiply(wr.pow(10,l,1),0);l=a-1;while(l>=23){wr.divide(1<<23);l-=23}wr.divide(1<<l);wr.multiply(1,1);wr.divide(2);i=wr.numToString()}else{wr.multiply(0,f);wr.multiply(1<<-a,0);i=wr.numToString()+K("0.00000000000000000000",2,2+r)}}if(r>0){s=i.length;if(s<=r){i=n+K("0.0000000000000000000",0,r-s+2)+i}else{i=n+K(i,0,s-r)+"."+K(i,s-r)}}else{i=n+i}return i};P(l,{toFixed:br},gr);var Tr=function(){try{return 1..toPrecision(undefined)==="1"}catch(t){return true}}();var mr=l.toPrecision;P(l,{toPrecision:function toPrecision(t){return typeof t==="undefined"?mr.call(this):mr.call(this,t)}},Tr);if("ab".split(/(?:ab)*/).length!==2||".".split(/(.?)(.?)/).length!==4||"tesst".split(/(s)*/)[1]==="t"||"test".split(/(?:)/,-1).length!==4||"".split(/.?/).length||".".split(/()()/).length>1){(function(){var t=typeof/()??/.exec("")[1]==="undefined";var r=Math.pow(2,32)-1;f.split=function(e,n){var i=String(this);if(typeof e==="undefined"&&n===0){return[]}if(!M(e)){return Q(this,e,n)}var a=[];var o=(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.unicode?"u":"")+(e.sticky?"y":""),f=0,u,l,s,c;var h=new RegExp(e.source,o+"g");if(!t){u=new RegExp("^"+h.source+"$(?!\\s)",o)}var p=typeof n==="undefined"?r:z.ToUint32(n);l=h.exec(i);while(l){s=l.index+l[0].length;if(s>f){_(a,K(i,f,l.index));if(!t&&l.length>1){l[0].replace(u,function(){for(var t=1;t<arguments.length-2;t++){if(typeof arguments[t]==="undefined"){l[t]=void 0}}})}if(l.length>1&&l.index<i.length){v.apply(a,W(l,1))}c=l[0].length;f=s;if(a.length>=p){break}}if(h.lastIndex===l.index){h.lastIndex++}l=h.exec(i)}if(f===i.length){if(c||!h.test("")){_(a,"")}}else{_(a,K(i,f))}return a.length>p?W(a,0,p):a}})()}else if("0".split(void 0,0).length){f.split=function split(t,r){if(typeof t==="undefined"&&r===0){return[]}return Q(this,t,r)}}var Dr=f.replace;var Sr=function(){var t=[];"x".replace(/x(.)?/g,function(r,e){_(t,e)});return t.length===1&&typeof t[0]==="undefined"}();if(!Sr){f.replace=function replace(t,r){var e=D(r);var n=M(t)&&/\)[*?]/.test(t.source);if(!e||!n){return Dr.call(this,t,r)}else{var i=function(e){var n=arguments.length;var i=t.lastIndex;t.lastIndex=0;var a=t.exec(e)||[];t.lastIndex=i;_(a,arguments[n-2],arguments[n-1]);return r.apply(this,a)};return Dr.call(this,t,i)}}}var xr=f.substr;var Or="".substr&&"0b".substr(-1)!=="b";P(f,{substr:function substr(t,r){var e=t;if(t<0){e=w(this.length+t,0)}return xr.call(this,e,r)}},Or);var Er="\t\n\x0B\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003"+"\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028"+"\u2029\ufeff";var jr="\u200b";var Ir="["+Er+"]";var Mr=new RegExp("^"+Ir+Ir+"*");var Ur=new RegExp(Ir+Ir+"*$");var $r=f.trim&&(Er.trim()||!jr.trim());P(f,{trim:function trim(){if(typeof this==="undefined"||this===null){throw new TypeError("can't convert "+this+" to object")}return o(this).replace(Mr,"").replace(Ur,"")}},$r);var Fr=d.bind(String.prototype.trim);var Nr=f.lastIndexOf&&"abc\u3042\u3044".lastIndexOf("\u3042\u3044",2)!==-1;P(f,{lastIndexOf:function lastIndexOf(t){if(typeof this==="undefined"||this===null){throw new TypeError("can't convert "+this+" to object")}var r=o(this);var e=o(t);var n=arguments.length>1?u(arguments[1]):NaN;var i=Y(n)?Infinity:z.ToInteger(n);var a=b(w(i,0),r.length);var f=e.length;var l=a+f;while(l>0){l=w(0,l-f);var s=V(K(r,l,a+f),e);if(s!==-1){return l+s}}return-1}},Nr);var Cr=f.lastIndexOf;P(f,{lastIndexOf:function lastIndexOf(t){return Cr.apply(this,arguments)}},f.lastIndexOf.length!==1);if(parseInt(Er+"08")!==8||parseInt(Er+"0x16")!==22){parseInt=function(t){var r=/^[-+]?0[xX]/;return function parseInt(e,n){if(typeof e==="symbol"){""+e}var i=Fr(String(e));var a=u(n)||(r.test(i)?16:10);return t(i,a)}}(parseInt)}if(1/parseFloat("-0")!==-Infinity){parseFloat=function(t){return function parseFloat(r){var e=Fr(String(r));var n=t(e);return n===0&&K(e,0,1)==="-"?-0:n}}(parseFloat)}if(String(new RangeError("test"))!=="RangeError: test"){var kr=function toString(){if(typeof this==="undefined"||this===null){throw new TypeError("can't convert "+this+" to object")}var t=this.name;if(typeof t==="undefined"){t="Error"}else if(typeof t!=="string"){t=o(t)}var r=this.message;if(typeof r==="undefined"){r=""}else if(typeof r!=="string"){r=o(r)}if(!t){return r}if(!r){return t}return t+": "+r};Error.prototype.toString=kr}if(R){var Ar=function(t,r){if(tt(t,r)){var e=Object.getOwnPropertyDescriptor(t,r);if(e.configurable){e.enumerable=false;Object.defineProperty(t,r,e)}}};Ar(Error.prototype,"message");if(Error.prototype.message!==""){Error.prototype.message=""}Ar(Error.prototype,"name")}if(String(/a/gim)!=="/a/gim"){var Rr=function toString(){var t="/"+this.source+"/";if(this.global){t+="g"}if(this.ignoreCase){t+="i"}if(this.multiline){t+="m"}return t};RegExp.prototype.toString=Rr}});
//# sourceMappingURL=es5-shim.map
;/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2020 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */
(function(e,t){"use strict";if(typeof define==="function"&&define.amd){define(t)}else if(typeof exports==="object"){module.exports=t()}else{e.returnExports=t()}})(this,function(){var e=Function.call;var t=Object.prototype;var r=e.bind(t.hasOwnProperty);var n=e.bind(t.propertyIsEnumerable);var o=e.bind(t.toString);var i;var c;var f;var a;var l=r(t,"__defineGetter__");if(l){i=e.bind(t.__defineGetter__);c=e.bind(t.__defineSetter__);f=e.bind(t.__lookupGetter__);a=e.bind(t.__lookupSetter__)}var u=function isPrimitive(e){return e==null||typeof e!=="object"&&typeof e!=="function"};if(!Object.getPrototypeOf){Object.getPrototypeOf=function getPrototypeOf(e){var r=e.__proto__;if(r||r===null){return r}else if(o(e.constructor)==="[object Function]"){return e.constructor.prototype}else if(e instanceof Object){return t}else{return null}}}if(Object.defineProperty){var s=function doesGetOwnPropertyDescriptorWork(e){try{e.sentinel=0;return Object.getOwnPropertyDescriptor(e,"sentinel").value===0}catch(t){return false}};var p=s({});var b=typeof document==="undefined"||s(document.createElement("div"));if(!b||!p){var O=Object.getOwnPropertyDescriptor}}if(!Object.getOwnPropertyDescriptor||O){var d="Object.getOwnPropertyDescriptor called on a non-object: ";Object.getOwnPropertyDescriptor=function getOwnPropertyDescriptor(e,o){if(u(e)){throw new TypeError(d+e)}if(O){try{return O.call(Object,e,o)}catch(i){}}var c;if(!r(e,o)){return c}c={enumerable:n(e,o),configurable:true};if(l){var s=e.__proto__;var p=e!==t;if(p){e.__proto__=t}var b=f(e,o);var y=a(e,o);if(p){e.__proto__=s}if(b||y){if(b){c.get=b}if(y){c.set=y}return c}}c.value=e[o];c.writable=true;return c}}if(!Object.getOwnPropertyNames){Object.getOwnPropertyNames=function getOwnPropertyNames(e){return Object.keys(e)}}if(!Object.create){var y;var j=!({__proto__:null}instanceof Object);var v=function shouldUseActiveX(){if(!document.domain){return false}try{return!!new ActiveXObject("htmlfile")}catch(e){return false}};var _=function getEmptyViaActiveX(){var e;var t;t=new ActiveXObject("htmlfile");var r="script";t.write("<"+r+"></"+r+">");t.close();e=t.parentWindow.Object.prototype;t=null;return e};var w=function getEmptyViaIFrame(){var e=document.createElement("iframe");var t=document.body||document.documentElement;var r;e.style.display="none";t.appendChild(e);e.src="javascript:";r=e.contentWindow.Object.prototype;t.removeChild(e);e=null;return r};if(j||typeof document==="undefined"){y=function(){return{__proto__:null}}}else{y=function(){var e=v()?_():w();delete e.constructor;delete e.hasOwnProperty;delete e.propertyIsEnumerable;delete e.isPrototypeOf;delete e.toLocaleString;delete e.toString;delete e.valueOf;var t=function Empty(){};t.prototype=e;y=function(){return new t};return new t}}Object.create=function create(e,t){var r;var n=function Type(){};if(e===null){r=y()}else if(u(e)){throw new TypeError("Object prototype may only be an Object or null")}else{n.prototype=e;r=new n;r.__proto__=e}if(t!==void 0){Object.defineProperties(r,t)}return r}}var m=function doesDefinePropertyWork(e){try{Object.defineProperty(e,"sentinel",{});return"sentinel"in e}catch(t){return false}};if(Object.defineProperty){var P=m({});var E=typeof document==="undefined"||m(document.createElement("div"));if(!P||!E){var h=Object.defineProperty,g=Object.defineProperties}}if(!Object.defineProperty||h){var z="Property description must be an object: ";var T="Object.defineProperty called on non-object: ";var x="getters & setters can not be defined on this javascript engine";Object.defineProperty=function defineProperty(e,r,n){if(u(e)){throw new TypeError(T+e)}if(u(n)){throw new TypeError(z+n)}if(h){try{return h.call(Object,e,r,n)}catch(o){}}if("value"in n){if(l&&(f(e,r)||a(e,r))){var s=e.__proto__;e.__proto__=t;delete e[r];e[r]=n.value;e.__proto__=s}else{e[r]=n.value}}else{var p="get"in n;var b="set"in n;if(!l&&(p||b)){throw new TypeError(x)}if(p){i(e,r,n.get)}if(b){c(e,r,n.set)}}return e}}if(!Object.defineProperties||g){Object.defineProperties=function defineProperties(e,t){if(g){try{return g.call(Object,e,t)}catch(r){}}Object.keys(t).forEach(function(r){if(r!=="__proto__"){Object.defineProperty(e,r,t[r])}});return e}}if(!Object.seal){Object.seal=function seal(e){if(Object(e)!==e){throw new TypeError("Object.seal can only be called on Objects.")}return e}}if(!Object.freeze){Object.freeze=function freeze(e){if(Object(e)!==e){throw new TypeError("Object.freeze can only be called on Objects.")}return e}}try{Object.freeze(function(){})}catch(S){Object.freeze=function(e){return function freeze(t){if(typeof t==="function"){return t}else{return e(t)}}}(Object.freeze)}if(!Object.preventExtensions){Object.preventExtensions=function preventExtensions(e){if(Object(e)!==e){throw new TypeError("Object.preventExtensions can only be called on Objects.")}return e}}if(!Object.isSealed){Object.isSealed=function isSealed(e){if(Object(e)!==e){throw new TypeError("Object.isSealed can only be called on Objects.")}return false}}if(!Object.isFrozen){Object.isFrozen=function isFrozen(e){if(Object(e)!==e){throw new TypeError("Object.isFrozen can only be called on Objects.")}return false}}if(!Object.isExtensible){Object.isExtensible=function isExtensible(e){if(Object(e)!==e){throw new TypeError("Object.isExtensible can only be called on Objects.")}var t="";while(r(e,t)){t+="?"}e[t]=true;var n=r(e,t);delete e[t];return n}}});
//# sourceMappingURL=es5-sham.map
;/*!
 * https://github.com/paulmillr/es6-shim
 * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
 *   and contributors,  MIT License
 * es6-shim: v0.35.4
 * see https://github.com/paulmillr/es6-shim/blob/0.35.3/LICENSE
 * Details and documentation:
 * https://github.com/paulmillr/es6-shim/
 */
(function(e,t){if(typeof define==="function"&&define.amd){define(t)}else if(typeof exports==="object"){module.exports=t()}else{e.returnExports=t()}})(this,function(){"use strict";var e=Function.call.bind(Function.apply);var t=Function.call.bind(Function.call);var r=Array.isArray;var n=Object.keys;var o=function notThunker(t){return function notThunk(){return!e(t,this,arguments)}};var i=function(e){try{e();return false}catch(t){return true}};var a=function valueOrFalseIfThrows(e){try{return e()}catch(t){return false}};var u=o(i);var f=function(){return!i(function(){return Object.defineProperty({},"x",{get:function(){}})})};var s=!!Object.defineProperty&&f();var c=function foo(){}.name==="foo";var l=Function.call.bind(Array.prototype.forEach);var p=Function.call.bind(Array.prototype.reduce);var v=Function.call.bind(Array.prototype.filter);var y=Function.call.bind(Array.prototype.some);var h=function(e,t,r,n){if(!n&&t in e){return}if(s){Object.defineProperty(e,t,{configurable:true,enumerable:false,writable:true,value:r})}else{e[t]=r}};var b=function(e,t,r){l(n(t),function(n){var o=t[n];h(e,n,o,!!r)})};var g=Function.call.bind(Object.prototype.toString);var d=typeof/abc/==="function"?function IsCallableSlow(e){return typeof e==="function"&&g(e)==="[object Function]"}:function IsCallableFast(e){return typeof e==="function"};var m={getter:function(e,t,r){if(!s){throw new TypeError("getters require true ES5 support")}Object.defineProperty(e,t,{configurable:true,enumerable:false,get:r})},proxy:function(e,t,r){if(!s){throw new TypeError("getters require true ES5 support")}var n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(r,t,{configurable:n.configurable,enumerable:n.enumerable,get:function getKey(){return e[t]},set:function setKey(r){e[t]=r}})},redefine:function(e,t,r){if(s){var n=Object.getOwnPropertyDescriptor(e,t);n.value=r;Object.defineProperty(e,t,n)}else{e[t]=r}},defineByDescriptor:function(e,t,r){if(s){Object.defineProperty(e,t,r)}else if("value"in r){e[t]=r.value}},preserveToString:function(e,t){if(t&&d(t.toString)){h(e,"toString",t.toString.bind(t),true)}}};var O=Object.create||function(e,t){var r=function Prototype(){};r.prototype=e;var o=new r;if(typeof t!=="undefined"){n(t).forEach(function(e){m.defineByDescriptor(o,e,t[e])})}return o};var w=function(e,t){if(!Object.setPrototypeOf){return false}return a(function(){var r=function Subclass(t){var r=new e(t);Object.setPrototypeOf(r,Subclass.prototype);return r};Object.setPrototypeOf(r,e);r.prototype=O(e.prototype,{constructor:{value:r}});return t(r)})};var j=function(){if(typeof self!=="undefined"){return self}if(typeof window!=="undefined"){return window}if(typeof global!=="undefined"){return global}throw new Error("unable to locate global object")};var S=j();var T=S.isFinite;var I=Function.call.bind(String.prototype.indexOf);var E=Function.apply.bind(Array.prototype.indexOf);var P=Function.call.bind(Array.prototype.concat);var C=Function.call.bind(String.prototype.slice);var M=Function.call.bind(Array.prototype.push);var x=Function.apply.bind(Array.prototype.push);var N=Function.call.bind(Array.prototype.shift);var A=Math.max;var R=Math.min;var _=Math.floor;var k=Math.abs;var L=Math.exp;var F=Math.log;var D=Math.sqrt;var z=Function.call.bind(Object.prototype.hasOwnProperty);var q;var W=function(){};var G=S.Map;var H=G&&G.prototype["delete"];var V=G&&G.prototype.get;var B=G&&G.prototype.has;var U=G&&G.prototype.set;var $=S.Symbol||{};var J=$.species||"@@species";var X=Number.isNaN||function isNaN(e){return e!==e};var K=Number.isFinite||function isFinite(e){return typeof e==="number"&&T(e)};var Z=d(Math.sign)?Math.sign:function sign(e){var t=Number(e);if(t===0){return t}if(X(t)){return t}return t<0?-1:1};var Y=function log1p(e){var t=Number(e);if(t<-1||X(t)){return NaN}if(t===0||t===Infinity){return t}if(t===-1){return-Infinity}return 1+t-1===0?t:t*(F(1+t)/(1+t-1))};var Q=function isArguments(e){return g(e)==="[object Arguments]"};var ee=function isArguments(e){return e!==null&&typeof e==="object"&&typeof e.length==="number"&&e.length>=0&&g(e)!=="[object Array]"&&g(e.callee)==="[object Function]"};var te=Q(arguments)?Q:ee;var re={primitive:function(e){return e===null||typeof e!=="function"&&typeof e!=="object"},string:function(e){return g(e)==="[object String]"},regex:function(e){return g(e)==="[object RegExp]"},symbol:function(e){return typeof S.Symbol==="function"&&typeof e==="symbol"}};var ne=function overrideNative(e,t,r){var n=e[t];h(e,t,r,true);m.preserveToString(e[t],n)};var oe=typeof $==="function"&&typeof $["for"]==="function"&&re.symbol($());var ie=re.symbol($.iterator)?$.iterator:"_es6-shim iterator_";if(S.Set&&typeof(new S.Set)["@@iterator"]==="function"){ie="@@iterator"}if(!S.Reflect){h(S,"Reflect",{},true)}var ae=S.Reflect;var ue=String;var fe=typeof document==="undefined"||!document?null:document.all;var se=fe==null?function isNullOrUndefined(e){return e==null}:function isNullOrUndefinedAndNotDocumentAll(e){return e==null&&e!==fe};var ce={Call:function Call(t,r){var n=arguments.length>2?arguments[2]:[];if(!ce.IsCallable(t)){throw new TypeError(t+" is not a function")}return e(t,r,n)},RequireObjectCoercible:function(e,t){if(se(e)){throw new TypeError(t||"Cannot call method on "+e)}return e},TypeIsObject:function(e){if(e===void 0||e===null||e===true||e===false){return false}return typeof e==="function"||typeof e==="object"||e===fe},ToObject:function(e,t){return Object(ce.RequireObjectCoercible(e,t))},IsCallable:d,IsConstructor:function(e){return ce.IsCallable(e)},ToInt32:function(e){return ce.ToNumber(e)>>0},ToUint32:function(e){return ce.ToNumber(e)>>>0},ToNumber:function(e){if(g(e)==="[object Symbol]"){throw new TypeError("Cannot convert a Symbol value to a number")}return+e},ToInteger:function(e){var t=ce.ToNumber(e);if(X(t)){return 0}if(t===0||!K(t)){return t}return(t>0?1:-1)*_(k(t))},ToLength:function(e){var t=ce.ToInteger(e);if(t<=0){return 0}if(t>Number.MAX_SAFE_INTEGER){return Number.MAX_SAFE_INTEGER}return t},SameValue:function(e,t){if(e===t){if(e===0){return 1/e===1/t}return true}return X(e)&&X(t)},SameValueZero:function(e,t){return e===t||X(e)&&X(t)},IsIterable:function(e){return ce.TypeIsObject(e)&&(typeof e[ie]!=="undefined"||te(e))},GetIterator:function(e){if(te(e)){return new q(e,"value")}var t=ce.GetMethod(e,ie);if(!ce.IsCallable(t)){throw new TypeError("value is not an iterable")}var r=ce.Call(t,e);if(!ce.TypeIsObject(r)){throw new TypeError("bad iterator")}return r},GetMethod:function(e,t){var r=ce.ToObject(e)[t];if(se(r)){return void 0}if(!ce.IsCallable(r)){throw new TypeError("Method not callable: "+t)}return r},IteratorComplete:function(e){return!!e.done},IteratorClose:function(e,t){var r=ce.GetMethod(e,"return");if(r===void 0){return}var n,o;try{n=ce.Call(r,e)}catch(i){o=i}if(t){return}if(o){throw o}if(!ce.TypeIsObject(n)){throw new TypeError("Iterator's return method returned a non-object.")}},IteratorNext:function(e){var t=arguments.length>1?e.next(arguments[1]):e.next();if(!ce.TypeIsObject(t)){throw new TypeError("bad iterator")}return t},IteratorStep:function(e){var t=ce.IteratorNext(e);var r=ce.IteratorComplete(t);return r?false:t},Construct:function(e,t,r,n){var o=typeof r==="undefined"?e:r;if(!n&&ae.construct){return ae.construct(e,t,o)}var i=o.prototype;if(!ce.TypeIsObject(i)){i=Object.prototype}var a=O(i);var u=ce.Call(e,a,t);return ce.TypeIsObject(u)?u:a},SpeciesConstructor:function(e,t){var r=e.constructor;if(r===void 0){return t}if(!ce.TypeIsObject(r)){throw new TypeError("Bad constructor")}var n=r[J];if(se(n)){return t}if(!ce.IsConstructor(n)){throw new TypeError("Bad @@species")}return n},CreateHTML:function(e,t,r,n){var o=ce.ToString(e);var i="<"+t;if(r!==""){var a=ce.ToString(n);var u=a.replace(/"/g,"&quot;");i+=" "+r+'="'+u+'"'}var f=i+">";var s=f+o;return s+"</"+t+">"},IsRegExp:function IsRegExp(e){if(!ce.TypeIsObject(e)){return false}var t=e[$.match];if(typeof t!=="undefined"){return!!t}return re.regex(e)},ToString:function ToString(e){return ue(e)}};if(s&&oe){var le=function defineWellKnownSymbol(e){if(re.symbol($[e])){return $[e]}var t=$["for"]("Symbol."+e);Object.defineProperty($,e,{configurable:false,enumerable:false,writable:false,value:t});return t};if(!re.symbol($.search)){var pe=le("search");var ve=String.prototype.search;h(RegExp.prototype,pe,function search(e){return ce.Call(ve,e,[this])});var ye=function search(e){var t=ce.RequireObjectCoercible(this);if(!se(e)){var r=ce.GetMethod(e,pe);if(typeof r!=="undefined"){return ce.Call(r,e,[t])}}return ce.Call(ve,t,[ce.ToString(e)])};ne(String.prototype,"search",ye)}if(!re.symbol($.replace)){var he=le("replace");var be=String.prototype.replace;h(RegExp.prototype,he,function replace(e,t){return ce.Call(be,e,[this,t])});var ge=function replace(e,t){var r=ce.RequireObjectCoercible(this);if(!se(e)){var n=ce.GetMethod(e,he);if(typeof n!=="undefined"){return ce.Call(n,e,[r,t])}}return ce.Call(be,r,[ce.ToString(e),t])};ne(String.prototype,"replace",ge)}if(!re.symbol($.split)){var de=le("split");var me=String.prototype.split;h(RegExp.prototype,de,function split(e,t){return ce.Call(me,e,[this,t])});var Oe=function split(e,t){var r=ce.RequireObjectCoercible(this);if(!se(e)){var n=ce.GetMethod(e,de);if(typeof n!=="undefined"){return ce.Call(n,e,[r,t])}}return ce.Call(me,r,[ce.ToString(e),t])};ne(String.prototype,"split",Oe)}var we=re.symbol($.match);var je=we&&function(){var e={};e[$.match]=function(){return 42};return"a".match(e)!==42}();if(!we||je){var Se=le("match");var Te=String.prototype.match;h(RegExp.prototype,Se,function match(e){return ce.Call(Te,e,[this])});var Ie=function match(e){var t=ce.RequireObjectCoercible(this);if(!se(e)){var r=ce.GetMethod(e,Se);if(typeof r!=="undefined"){return ce.Call(r,e,[t])}}return ce.Call(Te,t,[ce.ToString(e)])};ne(String.prototype,"match",Ie)}}var Ee=function wrapConstructor(e,t,r){m.preserveToString(t,e);if(Object.setPrototypeOf){Object.setPrototypeOf(e,t)}if(s){l(Object.getOwnPropertyNames(e),function(n){if(n in W||r[n]){return}m.proxy(e,n,t)})}else{l(Object.keys(e),function(n){if(n in W||r[n]){return}t[n]=e[n]})}t.prototype=e.prototype;m.redefine(e.prototype,"constructor",t)};var Pe=function(){return this};var Ce=function(e){if(s&&!z(e,J)){m.getter(e,J,Pe)}};var Me=function(e,t){var r=t||function iterator(){return this};h(e,ie,r);if(!e[ie]&&re.symbol(ie)){e[ie]=r}};var xe=function createDataProperty(e,t,r){if(s){Object.defineProperty(e,t,{configurable:true,enumerable:true,writable:true,value:r})}else{e[t]=r}};var Ne=function createDataPropertyOrThrow(e,t,r){xe(e,t,r);if(!ce.SameValue(e[t],r)){throw new TypeError("property is nonconfigurable")}};var Ae=function(e,t,r,n){if(!ce.TypeIsObject(e)){throw new TypeError("Constructor requires `new`: "+t.name)}var o=t.prototype;if(!ce.TypeIsObject(o)){o=r}var i=O(o);for(var a in n){if(z(n,a)){var u=n[a];h(i,a,u,true)}}return i};if(String.fromCodePoint&&String.fromCodePoint.length!==1){var Re=String.fromCodePoint;ne(String,"fromCodePoint",function fromCodePoint(e){return ce.Call(Re,this,arguments)})}var _e={fromCodePoint:function fromCodePoint(e){var t=[];var r;for(var n=0,o=arguments.length;n<o;n++){r=Number(arguments[n]);if(!ce.SameValue(r,ce.ToInteger(r))||r<0||r>1114111){throw new RangeError("Invalid code point "+r)}if(r<65536){M(t,String.fromCharCode(r))}else{r-=65536;M(t,String.fromCharCode((r>>10)+55296));M(t,String.fromCharCode(r%1024+56320))}}return t.join("")},raw:function raw(e){var t=ce.ToObject(e,"bad callSite");var r=ce.ToObject(t.raw,"bad raw value");var n=r.length;var o=ce.ToLength(n);if(o<=0){return""}var i=[];var a=0;var u,f,s,c;while(a<o){u=ce.ToString(a);s=ce.ToString(r[u]);M(i,s);if(a+1>=o){break}f=a+1<arguments.length?arguments[a+1]:"";c=ce.ToString(f);M(i,c);a+=1}return i.join("")}};if(String.raw&&String.raw({raw:{0:"x",1:"y",length:2}})!=="xy"){ne(String,"raw",_e.raw)}b(String,_e);var ke=function repeat(e,t){if(t<1){return""}if(t%2){return repeat(e,t-1)+e}var r=repeat(e,t/2);return r+r};var Le=Infinity;var Fe={repeat:function repeat(e){var t=ce.ToString(ce.RequireObjectCoercible(this));var r=ce.ToInteger(e);if(r<0||r>=Le){throw new RangeError("repeat count must be less than infinity and not overflow maximum string size")}return ke(t,r)},startsWith:function startsWith(e){var t=ce.ToString(ce.RequireObjectCoercible(this));if(ce.IsRegExp(e)){throw new TypeError('Cannot call method "startsWith" with a regex')}var r=ce.ToString(e);var n;if(arguments.length>1){n=arguments[1]}var o=A(ce.ToInteger(n),0);return C(t,o,o+r.length)===r},endsWith:function endsWith(e){var t=ce.ToString(ce.RequireObjectCoercible(this));if(ce.IsRegExp(e)){throw new TypeError('Cannot call method "endsWith" with a regex')}var r=ce.ToString(e);var n=t.length;var o;if(arguments.length>1){o=arguments[1]}var i=typeof o==="undefined"?n:ce.ToInteger(o);var a=R(A(i,0),n);return C(t,a-r.length,a)===r},includes:function includes(e){if(ce.IsRegExp(e)){throw new TypeError('"includes" does not accept a RegExp')}var t=ce.ToString(e);var r;if(arguments.length>1){r=arguments[1]}return I(this,t,r)!==-1},codePointAt:function codePointAt(e){var t=ce.ToString(ce.RequireObjectCoercible(this));var r=ce.ToInteger(e);var n=t.length;if(r>=0&&r<n){var o=t.charCodeAt(r);var i=r+1===n;if(o<55296||o>56319||i){return o}var a=t.charCodeAt(r+1);if(a<56320||a>57343){return o}return(o-55296)*1024+(a-56320)+65536}}};if(String.prototype.includes&&"a".includes("a",Infinity)!==false){ne(String.prototype,"includes",Fe.includes)}if(String.prototype.startsWith&&String.prototype.endsWith){var De=i(function(){return"/a/".startsWith(/a/)});var ze=a(function(){return"abc".startsWith("a",Infinity)===false});if(!De||!ze){ne(String.prototype,"startsWith",Fe.startsWith);ne(String.prototype,"endsWith",Fe.endsWith)}}if(oe){var qe=a(function(){var e=/a/;e[$.match]=false;return"/a/".startsWith(e)});if(!qe){ne(String.prototype,"startsWith",Fe.startsWith)}var We=a(function(){var e=/a/;e[$.match]=false;return"/a/".endsWith(e)});if(!We){ne(String.prototype,"endsWith",Fe.endsWith)}var Ge=a(function(){var e=/a/;e[$.match]=false;return"/a/".includes(e)});if(!Ge){ne(String.prototype,"includes",Fe.includes)}}b(String.prototype,Fe);var He=["\t\n\x0B\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003","\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028","\u2029\ufeff"].join("");var Ve=new RegExp("(^["+He+"]+)|(["+He+"]+$)","g");var Be=function trim(){return ce.ToString(ce.RequireObjectCoercible(this)).replace(Ve,"")};var Ue=["\x85","\u200b","\ufffe"].join("");var $e=new RegExp("["+Ue+"]","g");var Je=/^[-+]0x[0-9a-f]+$/i;var Xe=Ue.trim().length!==Ue.length;h(String.prototype,"trim",Be,Xe);var Ke=function(e){return{value:e,done:arguments.length===0}};var Ze=function(e){ce.RequireObjectCoercible(e);this._s=ce.ToString(e);this._i=0};Ze.prototype.next=function(){var e=this._s;var t=this._i;if(typeof e==="undefined"||t>=e.length){this._s=void 0;return Ke()}var r=e.charCodeAt(t);var n,o;if(r<55296||r>56319||t+1===e.length){o=1}else{n=e.charCodeAt(t+1);o=n<56320||n>57343?1:2}this._i=t+o;return Ke(e.substr(t,o))};Me(Ze.prototype);Me(String.prototype,function(){return new Ze(this)});var Ye={from:function from(e){var r=this;var n;if(arguments.length>1){n=arguments[1]}var o,i;if(typeof n==="undefined"){o=false}else{if(!ce.IsCallable(n)){throw new TypeError("Array.from: when provided, the second argument must be a function")}if(arguments.length>2){i=arguments[2]}o=true}var a=typeof(te(e)||ce.GetMethod(e,ie))!=="undefined";var u,f,s;if(a){f=ce.IsConstructor(r)?Object(new r):[];var c=ce.GetIterator(e);var l,p;s=0;while(true){l=ce.IteratorStep(c);if(l===false){break}p=l.value;try{if(o){p=typeof i==="undefined"?n(p,s):t(n,i,p,s)}f[s]=p}catch(v){ce.IteratorClose(c,true);throw v}s+=1}u=s}else{var y=ce.ToObject(e);u=ce.ToLength(y.length);f=ce.IsConstructor(r)?Object(new r(u)):new Array(u);var h;for(s=0;s<u;++s){h=y[s];if(o){h=typeof i==="undefined"?n(h,s):t(n,i,h,s)}Ne(f,s,h)}}f.length=u;return f},of:function of(){var e=arguments.length;var t=this;var n=r(t)||!ce.IsCallable(t)?new Array(e):ce.Construct(t,[e]);for(var o=0;o<e;++o){Ne(n,o,arguments[o])}n.length=e;return n}};b(Array,Ye);Ce(Array);q=function(e,t){this.i=0;this.array=e;this.kind=t};b(q.prototype,{next:function(){var e=this.i;var t=this.array;if(!(this instanceof q)){throw new TypeError("Not an ArrayIterator")}if(typeof t!=="undefined"){var r=ce.ToLength(t.length);for(;e<r;e++){var n=this.kind;var o;if(n==="key"){o=e}else if(n==="value"){o=t[e]}else if(n==="entry"){o=[e,t[e]]}this.i=e+1;return Ke(o)}}this.array=void 0;return Ke()}});Me(q.prototype);var Qe=Array.of===Ye.of||function(){var e=function Foo(e){this.length=e};e.prototype=[];var t=Array.of.apply(e,[1,2]);return t instanceof e&&t.length===2}();if(!Qe){ne(Array,"of",Ye.of)}var et={copyWithin:function copyWithin(e,t){var r=ce.ToObject(this);var n=ce.ToLength(r.length);var o=ce.ToInteger(e);var i=ce.ToInteger(t);var a=o<0?A(n+o,0):R(o,n);var u=i<0?A(n+i,0):R(i,n);var f;if(arguments.length>2){f=arguments[2]}var s=typeof f==="undefined"?n:ce.ToInteger(f);var c=s<0?A(n+s,0):R(s,n);var l=R(c-u,n-a);var p=1;if(u<a&&a<u+l){p=-1;u+=l-1;a+=l-1}while(l>0){if(u in r){r[a]=r[u]}else{delete r[a]}u+=p;a+=p;l-=1}return r},fill:function fill(e){var t;if(arguments.length>1){t=arguments[1]}var r;if(arguments.length>2){r=arguments[2]}var n=ce.ToObject(this);var o=ce.ToLength(n.length);t=ce.ToInteger(typeof t==="undefined"?0:t);r=ce.ToInteger(typeof r==="undefined"?o:r);var i=t<0?A(o+t,0):R(t,o);var a=r<0?o+r:r;for(var u=i;u<o&&u<a;++u){n[u]=e}return n},find:function find(e){var r=ce.ToObject(this);var n=ce.ToLength(r.length);if(!ce.IsCallable(e)){throw new TypeError("Array#find: predicate must be a function")}var o=arguments.length>1?arguments[1]:null;for(var i=0,a;i<n;i++){a=r[i];if(o){if(t(e,o,a,i,r)){return a}}else if(e(a,i,r)){return a}}},findIndex:function findIndex(e){var r=ce.ToObject(this);var n=ce.ToLength(r.length);if(!ce.IsCallable(e)){throw new TypeError("Array#findIndex: predicate must be a function")}var o=arguments.length>1?arguments[1]:null;for(var i=0;i<n;i++){if(o){if(t(e,o,r[i],i,r)){return i}}else if(e(r[i],i,r)){return i}}return-1},keys:function keys(){return new q(this,"key")},values:function values(){return new q(this,"value")},entries:function entries(){return new q(this,"entry")}};if(Array.prototype.keys&&!ce.IsCallable([1].keys().next)){delete Array.prototype.keys}if(Array.prototype.entries&&!ce.IsCallable([1].entries().next)){delete Array.prototype.entries}if(Array.prototype.keys&&Array.prototype.entries&&!Array.prototype.values&&Array.prototype[ie]){b(Array.prototype,{values:Array.prototype[ie]});if(re.symbol($.unscopables)){Array.prototype[$.unscopables].values=true}}if(c&&Array.prototype.values&&Array.prototype.values.name!=="values"){var tt=Array.prototype.values;ne(Array.prototype,"values",function values(){return ce.Call(tt,this,arguments)});h(Array.prototype,ie,Array.prototype.values,true)}b(Array.prototype,et);if(1/[true].indexOf(true,-0)<0){h(Array.prototype,"indexOf",function indexOf(e){var t=E(this,arguments);if(t===0&&1/t<0){return 0}return t},true)}Me(Array.prototype,function(){return this.values()});if(Object.getPrototypeOf){Me(Object.getPrototypeOf([].values()))}var rt=function(){return a(function(){return Array.from({length:-1}).length===0})}();var nt=function(){var e=Array.from([0].entries());return e.length===1&&r(e[0])&&e[0][0]===0&&e[0][1]===0}();if(!rt||!nt){ne(Array,"from",Ye.from)}var ot=function(){return a(function(){return Array.from([0],void 0)})}();if(!ot){var it=Array.from;ne(Array,"from",function from(e){if(arguments.length>1&&typeof arguments[1]!=="undefined"){return ce.Call(it,this,arguments)}else{return t(it,this,e)}})}var at=-(Math.pow(2,32)-1);var ut=function(e,r){var n={length:at};n[r?(n.length>>>0)-1:0]=true;return a(function(){t(e,n,function(){throw new RangeError("should not reach here")},[]);return true})};if(!ut(Array.prototype.forEach)){var ft=Array.prototype.forEach;ne(Array.prototype,"forEach",function forEach(e){return ce.Call(ft,this.length>=0?this:[],arguments)},true)}if(!ut(Array.prototype.map)){var st=Array.prototype.map;ne(Array.prototype,"map",function map(e){return ce.Call(st,this.length>=0?this:[],arguments)},true)}if(!ut(Array.prototype.filter)){var ct=Array.prototype.filter;ne(Array.prototype,"filter",function filter(e){return ce.Call(ct,this.length>=0?this:[],arguments)},true)}if(!ut(Array.prototype.some)){var lt=Array.prototype.some;ne(Array.prototype,"some",function some(e){return ce.Call(lt,this.length>=0?this:[],arguments)},true)}if(!ut(Array.prototype.every)){var pt=Array.prototype.every;ne(Array.prototype,"every",function every(e){return ce.Call(pt,this.length>=0?this:[],arguments)},true)}if(!ut(Array.prototype.reduce)){var vt=Array.prototype.reduce;ne(Array.prototype,"reduce",function reduce(e){return ce.Call(vt,this.length>=0?this:[],arguments)},true)}if(!ut(Array.prototype.reduceRight,true)){var yt=Array.prototype.reduceRight;ne(Array.prototype,"reduceRight",function reduceRight(e){return ce.Call(yt,this.length>=0?this:[],arguments)},true)}var ht=Number("0o10")!==8;var bt=Number("0b10")!==2;var gt=y(Ue,function(e){return Number(e+0+e)===0});if(ht||bt||gt){var dt=Number;var mt=/^0b[01]+$/i;var Ot=/^0o[0-7]+$/i;var wt=mt.test.bind(mt);var jt=Ot.test.bind(Ot);var St=function(e){var t;if(typeof e.valueOf==="function"){t=e.valueOf();if(re.primitive(t)){return t}}if(typeof e.toString==="function"){t=e.toString();if(re.primitive(t)){return t}}throw new TypeError("No default value")};var Tt=$e.test.bind($e);var It=Je.test.bind(Je);var Et=function(){var e=function Number(t){var r;if(arguments.length>0){r=re.primitive(t)?t:St(t,"number")}else{r=0}if(typeof r==="string"){r=ce.Call(Be,r);if(wt(r)){r=parseInt(C(r,2),2)}else if(jt(r)){r=parseInt(C(r,2),8)}else if(Tt(r)||It(r)){r=NaN}}var n=this;var o=a(function(){dt.prototype.valueOf.call(n);return true});if(n instanceof e&&!o){return new dt(r)}return dt(r)};return e}();Ee(dt,Et,{});b(Et,{NaN:dt.NaN,MAX_VALUE:dt.MAX_VALUE,MIN_VALUE:dt.MIN_VALUE,NEGATIVE_INFINITY:dt.NEGATIVE_INFINITY,POSITIVE_INFINITY:dt.POSITIVE_INFINITY});Number=Et;m.redefine(S,"Number",Et)}var Pt=Math.pow(2,53)-1;b(Number,{MAX_SAFE_INTEGER:Pt,MIN_SAFE_INTEGER:-Pt,EPSILON:2.220446049250313e-16,parseInt:S.parseInt,parseFloat:S.parseFloat,isFinite:K,isInteger:function isInteger(e){return K(e)&&ce.ToInteger(e)===e},isSafeInteger:function isSafeInteger(e){return Number.isInteger(e)&&k(e)<=Number.MAX_SAFE_INTEGER},isNaN:X});h(Number,"parseInt",S.parseInt,Number.parseInt!==S.parseInt);if([,1].find(function(){return true})===1){ne(Array.prototype,"find",et.find)}if([,1].findIndex(function(){return true})!==0){ne(Array.prototype,"findIndex",et.findIndex)}var Ct=Function.bind.call(Function.bind,Object.prototype.propertyIsEnumerable);var Mt=function ensureEnumerable(e,t){if(s&&Ct(e,t)){Object.defineProperty(e,t,{enumerable:false})}};var xt=function sliceArgs(){var e=Number(this);var t=arguments.length;var r=t-e;var n=new Array(r<0?0:r);for(var o=e;o<t;++o){n[o-e]=arguments[o]}return n};var Nt=function assignTo(e){return function assignToSource(t,r){t[r]=e[r];return t}};var At=function(e,t){var r=n(Object(t));var o;if(ce.IsCallable(Object.getOwnPropertySymbols)){o=v(Object.getOwnPropertySymbols(Object(t)),Ct(t))}return p(P(r,o||[]),Nt(t),e)};var Rt={assign:function(e,t){var r=ce.ToObject(e,"Cannot convert undefined or null to object");return p(ce.Call(xt,1,arguments),At,r)},is:function is(e,t){return ce.SameValue(e,t)}};var _t=Object.assign&&Object.preventExtensions&&function(){var e=Object.preventExtensions({1:2});try{Object.assign(e,"xy")}catch(t){return e[1]==="y"}}();if(_t){ne(Object,"assign",Rt.assign)}b(Object,Rt);if(s){var kt={setPrototypeOf:function(e,r){var n;var o=function(e,t){if(!ce.TypeIsObject(e)){throw new TypeError("cannot set prototype on a non-object")}if(!(t===null||ce.TypeIsObject(t))){throw new TypeError("can only set prototype to an object or null"+t)}};var i=function(e,r){o(e,r);t(n,e,r);return e};try{n=e.getOwnPropertyDescriptor(e.prototype,r).set;t(n,{},null)}catch(a){if(e.prototype!=={}[r]){return}n=function(e){this[r]=e};i.polyfill=i(i({},null),e.prototype)instanceof e}return i}(Object,"__proto__")};b(Object,kt)}if(Object.setPrototypeOf&&Object.getPrototypeOf&&Object.getPrototypeOf(Object.setPrototypeOf({},null))!==null&&Object.getPrototypeOf(Object.create(null))===null){(function(){var e=Object.create(null);var t=Object.getPrototypeOf;var r=Object.setPrototypeOf;Object.getPrototypeOf=function(r){var n=t(r);return n===e?null:n};Object.setPrototypeOf=function(t,n){var o=n===null?e:n;return r(t,o)};Object.setPrototypeOf.polyfill=false})()}var Lt=!i(function(){return Object.keys("foo")});if(!Lt){var Ft=Object.keys;ne(Object,"keys",function keys(e){return Ft(ce.ToObject(e))});n=Object.keys}var Dt=i(function(){return Object.keys(/a/g)});if(Dt){var zt=Object.keys;ne(Object,"keys",function keys(e){if(re.regex(e)){var t=[];for(var r in e){if(z(e,r)){M(t,r)}}return t}return zt(e)});n=Object.keys}if(Object.getOwnPropertyNames){var qt=!i(function(){return Object.getOwnPropertyNames("foo")});if(!qt){var Wt=typeof window==="object"?Object.getOwnPropertyNames(window):[];var Gt=Object.getOwnPropertyNames;ne(Object,"getOwnPropertyNames",function getOwnPropertyNames(e){var t=ce.ToObject(e);if(g(t)==="[object Window]"){try{return Gt(t)}catch(r){return P([],Wt)}}return Gt(t)})}}if(Object.getOwnPropertyDescriptor){var Ht=!i(function(){return Object.getOwnPropertyDescriptor("foo","bar")});if(!Ht){var Vt=Object.getOwnPropertyDescriptor;ne(Object,"getOwnPropertyDescriptor",function getOwnPropertyDescriptor(e,t){return Vt(ce.ToObject(e),t)})}}if(Object.seal){var Bt=!i(function(){return Object.seal("foo")});if(!Bt){var Ut=Object.seal;ne(Object,"seal",function seal(e){if(!ce.TypeIsObject(e)){return e}return Ut(e)})}}if(Object.isSealed){var $t=!i(function(){return Object.isSealed("foo")});if(!$t){var Jt=Object.isSealed;ne(Object,"isSealed",function isSealed(e){if(!ce.TypeIsObject(e)){return true}return Jt(e)})}}if(Object.freeze){var Xt=!i(function(){return Object.freeze("foo")});if(!Xt){var Kt=Object.freeze;ne(Object,"freeze",function freeze(e){if(!ce.TypeIsObject(e)){return e}return Kt(e)})}}if(Object.isFrozen){var Zt=!i(function(){return Object.isFrozen("foo")});if(!Zt){var Yt=Object.isFrozen;ne(Object,"isFrozen",function isFrozen(e){if(!ce.TypeIsObject(e)){return true}return Yt(e)})}}if(Object.preventExtensions){var Qt=!i(function(){return Object.preventExtensions("foo")});if(!Qt){var er=Object.preventExtensions;ne(Object,"preventExtensions",function preventExtensions(e){if(!ce.TypeIsObject(e)){return e}return er(e)})}}if(Object.isExtensible){var tr=!i(function(){return Object.isExtensible("foo")});if(!tr){var rr=Object.isExtensible;ne(Object,"isExtensible",function isExtensible(e){if(!ce.TypeIsObject(e)){return false}return rr(e)})}}if(Object.getPrototypeOf){var nr=!i(function(){return Object.getPrototypeOf("foo")});if(!nr){var or=Object.getPrototypeOf;ne(Object,"getPrototypeOf",function getPrototypeOf(e){return or(ce.ToObject(e))})}}var ir=s&&function(){var e=Object.getOwnPropertyDescriptor(RegExp.prototype,"flags");return e&&ce.IsCallable(e.get)}();if(s&&!ir){var ar=function flags(){if(!ce.TypeIsObject(this)){throw new TypeError("Method called on incompatible type: must be an object.")}var e="";if(this.global){e+="g"}if(this.ignoreCase){e+="i"}if(this.multiline){e+="m"}if(this.unicode){e+="u"}if(this.sticky){e+="y"}return e};m.getter(RegExp.prototype,"flags",ar)}var ur=s&&a(function(){return String(new RegExp(/a/g,"i"))==="/a/i"});var fr=oe&&s&&function(){var e=/./;e[$.match]=false;return RegExp(e)===e}();var sr=a(function(){return RegExp.prototype.toString.call({source:"abc"})==="/abc/"});var cr=sr&&a(function(){return RegExp.prototype.toString.call({source:"a",flags:"b"})==="/a/b"});if(!sr||!cr){var lr=RegExp.prototype.toString;h(RegExp.prototype,"toString",function toString(){var e=ce.RequireObjectCoercible(this);if(re.regex(e)){return t(lr,e)}var r=ue(e.source);var n=ue(e.flags);return"/"+r+"/"+n},true);m.preserveToString(RegExp.prototype.toString,lr)}if(s&&(!ur||fr)){var pr=Object.getOwnPropertyDescriptor(RegExp.prototype,"flags").get;var vr=Object.getOwnPropertyDescriptor(RegExp.prototype,"source")||{};var yr=function(){return this.source};var hr=ce.IsCallable(vr.get)?vr.get:yr;var br=RegExp;var gr=function(){return function RegExp(e,t){var r=ce.IsRegExp(e);var n=this instanceof RegExp;if(!n&&r&&typeof t==="undefined"&&e.constructor===RegExp){return e}var o=e;var i=t;if(re.regex(e)){o=ce.Call(hr,e);i=typeof t==="undefined"?ce.Call(pr,e):t;return new RegExp(o,i)}else if(r){o=e.source;i=typeof t==="undefined"?e.flags:t}return new br(e,t)}}();Ee(br,gr,{$input:true});RegExp=gr;m.redefine(S,"RegExp",gr)}if(s){var dr={input:"$_",lastMatch:"$&",lastParen:"$+",leftContext:"$`",rightContext:"$'"};l(n(dr),function(e){if(e in RegExp&&!(dr[e]in RegExp)){m.getter(RegExp,dr[e],function get(){return RegExp[e]})}})}Ce(RegExp);var mr=1/Number.EPSILON;var Or=function roundTiesToEven(e){return e+mr-mr};var wr=Math.pow(2,-23);var jr=Math.pow(2,127)*(2-wr);var Sr=Math.pow(2,-126);var Tr=Math.E;var Ir=Math.LOG2E;var Er=Math.LOG10E;var Pr=Number.prototype.clz;delete Number.prototype.clz;var Cr={acosh:function acosh(e){var t=Number(e);if(X(t)||e<1){return NaN}if(t===1){return 0}if(t===Infinity){return t}var r=1/(t*t);if(t<2){return Y(t-1+D(1-r)*t)}var n=t/2;return Y(n+D(1-r)*n-1)+1/Ir},asinh:function asinh(e){var t=Number(e);if(t===0||!T(t)){return t}var r=k(t);var n=r*r;var o=Z(t);if(r<1){return o*Y(r+n/(D(n+1)+1))}return o*(Y(r/2+D(1+1/n)*r/2-1)+1/Ir)},atanh:function atanh(e){var t=Number(e);if(t===0){return t}if(t===-1){return-Infinity}if(t===1){return Infinity}if(X(t)||t<-1||t>1){return NaN}var r=k(t);return Z(t)*Y(2*r/(1-r))/2},cbrt:function cbrt(e){var t=Number(e);if(t===0){return t}var r=t<0;var n;if(r){t=-t}if(t===Infinity){n=Infinity}else{n=L(F(t)/3);n=(t/(n*n)+2*n)/3}return r?-n:n},clz32:function clz32(e){var t=Number(e);var r=ce.ToUint32(t);if(r===0){return 32}return Pr?ce.Call(Pr,r):31-_(F(r+.5)*Ir)},cosh:function cosh(e){var t=Number(e);if(t===0){return 1}if(X(t)){return NaN}if(!T(t)){return Infinity}var r=L(k(t)-1);return(r+1/(r*Tr*Tr))*(Tr/2)},expm1:function expm1(e){var t=Number(e);if(t===-Infinity){return-1}if(!T(t)||t===0){return t}if(k(t)>.5){return L(t)-1}var r=t;var n=0;var o=1;while(n+r!==n){n+=r;o+=1;r*=t/o}return n},hypot:function hypot(e,t){var r=0;var n=0;for(var o=0;o<arguments.length;++o){var i=k(Number(arguments[o]));if(n<i){r*=n/i*(n/i);r+=1;n=i}else{r+=i>0?i/n*(i/n):i}}return n===Infinity?Infinity:n*D(r)},log2:function log2(e){return F(e)*Ir},log10:function log10(e){return F(e)*Er},log1p:Y,sign:Z,sinh:function sinh(e){var t=Number(e);if(!T(t)||t===0){return t}var r=k(t);if(r<1){var n=Math.expm1(r);return Z(t)*n*(1+1/(n+1))/2}var o=L(r-1);return Z(t)*(o-1/(o*Tr*Tr))*(Tr/2)},tanh:function tanh(e){var t=Number(e);if(X(t)||t===0){return t}if(t>=20){return 1}if(t<=-20){return-1}return(Math.expm1(t)-Math.expm1(-t))/(L(t)+L(-t))},trunc:function trunc(e){var t=Number(e);return t<0?-_(-t):_(t)},imul:function imul(e,t){var r=ce.ToUint32(e);var n=ce.ToUint32(t);var o=r>>>16&65535;var i=r&65535;var a=n>>>16&65535;var u=n&65535;return i*u+(o*u+i*a<<16>>>0)|0},fround:function fround(e){var t=Number(e);if(t===0||t===Infinity||t===-Infinity||X(t)){return t}var r=Z(t);var n=k(t);if(n<Sr){return r*Or(n/Sr/wr)*Sr*wr}var o=(1+wr/Number.EPSILON)*n;var i=o-(o-n);if(i>jr||X(i)){return r*Infinity}return r*i}};var Mr=function withinULPDistance(e,t,r){return k(1-e/t)/Number.EPSILON<(r||8)};b(Math,Cr);h(Math,"sinh",Cr.sinh,Math.sinh(710)===Infinity);h(Math,"cosh",Cr.cosh,Math.cosh(710)===Infinity);h(Math,"log1p",Cr.log1p,Math.log1p(-1e-17)!==-1e-17);h(Math,"asinh",Cr.asinh,Math.asinh(-1e7)!==-Math.asinh(1e7));h(Math,"asinh",Cr.asinh,Math.asinh(1e300)===Infinity);h(Math,"atanh",Cr.atanh,Math.atanh(1e-300)===0);h(Math,"tanh",Cr.tanh,Math.tanh(-2e-17)!==-2e-17);
h(Math,"acosh",Cr.acosh,Math.acosh(Number.MAX_VALUE)===Infinity);h(Math,"acosh",Cr.acosh,!Mr(Math.acosh(1+Number.EPSILON),Math.sqrt(2*Number.EPSILON)));h(Math,"cbrt",Cr.cbrt,!Mr(Math.cbrt(1e-300),1e-100));h(Math,"sinh",Cr.sinh,Math.sinh(-2e-17)!==-2e-17);var xr=Math.expm1(10);h(Math,"expm1",Cr.expm1,xr>22025.465794806718||xr<22025.465794806718);var Nr=Math.round;var Ar=Math.round(.5-Number.EPSILON/4)===0&&Math.round(-.5+Number.EPSILON/3.99)===1;var Rr=mr+1;var _r=2*mr-1;var kr=[Rr,_r].every(function(e){return Math.round(e)===e});h(Math,"round",function round(e){var t=_(e);var r=t===-1?-0:t+1;return e-t<.5?t:r},!Ar||!kr);m.preserveToString(Math.round,Nr);var Lr=Math.imul;if(Math.imul(4294967295,5)!==-5){Math.imul=Cr.imul;m.preserveToString(Math.imul,Lr)}if(Math.imul.length!==2){ne(Math,"imul",function imul(e,t){return ce.Call(Lr,Math,arguments)})}var Fr=function(){var e=S.setTimeout;if(typeof e!=="function"&&typeof e!=="object"){return}ce.IsPromise=function(e){if(!ce.TypeIsObject(e)){return false}if(typeof e._promise==="undefined"){return false}return true};var r=function(e){if(!ce.IsConstructor(e)){throw new TypeError("Bad promise constructor")}var t=this;var r=function(e,r){if(t.resolve!==void 0||t.reject!==void 0){throw new TypeError("Bad Promise implementation!")}t.resolve=e;t.reject=r};t.resolve=void 0;t.reject=void 0;t.promise=new e(r);if(!(ce.IsCallable(t.resolve)&&ce.IsCallable(t.reject))){throw new TypeError("Bad promise constructor")}};var n;if(typeof window!=="undefined"&&ce.IsCallable(window.postMessage)){n=function(){var e=[];var t="zero-timeout-message";var r=function(r){M(e,r);window.postMessage(t,"*")};var n=function(r){if(r.source===window&&r.data===t){r.stopPropagation();if(e.length===0){return}var n=N(e);n()}};window.addEventListener("message",n,true);return r}}var o=function(){var e=S.Promise;var t=e&&e.resolve&&e.resolve();return t&&function(e){return t.then(e)}};var i=ce.IsCallable(S.setImmediate)?S.setImmediate:typeof process==="object"&&process.nextTick?process.nextTick:o()||(ce.IsCallable(n)?n():function(t){e(t,0)});var a=function(e){return e};var u=function(e){throw e};var f=0;var s=1;var c=2;var l=0;var p=1;var v=2;var y={};var h=function(e,t,r){i(function(){g(e,t,r)})};var g=function(e,t,r){var n,o;if(t===y){return e(r)}try{n=e(r);o=t.resolve}catch(i){n=i;o=t.reject}o(n)};var d=function(e,t){var r=e._promise;var n=r.reactionLength;if(n>0){h(r.fulfillReactionHandler0,r.reactionCapability0,t);r.fulfillReactionHandler0=void 0;r.rejectReactions0=void 0;r.reactionCapability0=void 0;if(n>1){for(var o=1,i=0;o<n;o++,i+=3){h(r[i+l],r[i+v],t);e[i+l]=void 0;e[i+p]=void 0;e[i+v]=void 0}}}r.result=t;r.state=s;r.reactionLength=0};var m=function(e,t){var r=e._promise;var n=r.reactionLength;if(n>0){h(r.rejectReactionHandler0,r.reactionCapability0,t);r.fulfillReactionHandler0=void 0;r.rejectReactions0=void 0;r.reactionCapability0=void 0;if(n>1){for(var o=1,i=0;o<n;o++,i+=3){h(r[i+p],r[i+v],t);e[i+l]=void 0;e[i+p]=void 0;e[i+v]=void 0}}}r.result=t;r.state=c;r.reactionLength=0};var O=function(e){var t=false;var r=function(r){var n;if(t){return}t=true;if(r===e){return m(e,new TypeError("Self resolution"))}if(!ce.TypeIsObject(r)){return d(e,r)}try{n=r.then}catch(o){return m(e,o)}if(!ce.IsCallable(n)){return d(e,r)}i(function(){j(e,r,n)})};var n=function(r){if(t){return}t=true;return m(e,r)};return{resolve:r,reject:n}};var w=function(e,r,n,o){if(e===I){t(e,r,n,o,y)}else{t(e,r,n,o)}};var j=function(e,t,r){var n=O(e);var o=n.resolve;var i=n.reject;try{w(r,t,o,i)}catch(a){i(a)}};var T,I;var E=function(){var e=function Promise(t){if(!(this instanceof e)){throw new TypeError('Constructor Promise requires "new"')}if(this&&this._promise){throw new TypeError("Bad construction")}if(!ce.IsCallable(t)){throw new TypeError("not a valid resolver")}var r=Ae(this,e,T,{_promise:{result:void 0,state:f,reactionLength:0,fulfillReactionHandler0:void 0,rejectReactionHandler0:void 0,reactionCapability0:void 0}});var n=O(r);var o=n.reject;try{t(n.resolve,o)}catch(i){o(i)}return r};return e}();T=E.prototype;var P=function(e,t,r,n){var o=false;return function(i){if(o){return}o=true;t[e]=i;if(--n.count===0){var a=r.resolve;a(t)}}};var C=function(e,t,r){var n=e.iterator;var o=[];var i={count:1};var a,u;var f=0;while(true){try{a=ce.IteratorStep(n);if(a===false){e.done=true;break}u=a.value}catch(s){e.done=true;throw s}o[f]=void 0;var c=t.resolve(u);var l=P(f,o,r,i);i.count+=1;w(c.then,c,l,r.reject);f+=1}if(--i.count===0){var p=r.resolve;p(o)}return r.promise};var x=function(e,t,r){var n=e.iterator;var o,i,a;while(true){try{o=ce.IteratorStep(n);if(o===false){e.done=true;break}i=o.value}catch(u){e.done=true;throw u}a=t.resolve(i);w(a.then,a,r.resolve,r.reject)}return r.promise};b(E,{all:function all(e){var t=this;if(!ce.TypeIsObject(t)){throw new TypeError("Promise is not object")}var n=new r(t);var o,i;try{o=ce.GetIterator(e);i={iterator:o,done:false};return C(i,t,n)}catch(a){var u=a;if(i&&!i.done){try{ce.IteratorClose(o,true)}catch(f){u=f}}var s=n.reject;s(u);return n.promise}},race:function race(e){var t=this;if(!ce.TypeIsObject(t)){throw new TypeError("Promise is not object")}var n=new r(t);var o,i;try{o=ce.GetIterator(e);i={iterator:o,done:false};return x(i,t,n)}catch(a){var u=a;if(i&&!i.done){try{ce.IteratorClose(o,true)}catch(f){u=f}}var s=n.reject;s(u);return n.promise}},reject:function reject(e){var t=this;if(!ce.TypeIsObject(t)){throw new TypeError("Bad promise constructor")}var n=new r(t);var o=n.reject;o(e);return n.promise},resolve:function resolve(e){var t=this;if(!ce.TypeIsObject(t)){throw new TypeError("Bad promise constructor")}if(ce.IsPromise(e)){var n=e.constructor;if(n===t){return e}}var o=new r(t);var i=o.resolve;i(e);return o.promise}});b(T,{"catch":function(e){return this.then(null,e)},then:function then(e,t){var n=this;if(!ce.IsPromise(n)){throw new TypeError("not a promise")}var o=ce.SpeciesConstructor(n,E);var i;var b=arguments.length>2&&arguments[2]===y;if(b&&o===E){i=y}else{i=new r(o)}var g=ce.IsCallable(e)?e:a;var d=ce.IsCallable(t)?t:u;var m=n._promise;var O;if(m.state===f){if(m.reactionLength===0){m.fulfillReactionHandler0=g;m.rejectReactionHandler0=d;m.reactionCapability0=i}else{var w=3*(m.reactionLength-1);m[w+l]=g;m[w+p]=d;m[w+v]=i}m.reactionLength+=1}else if(m.state===s){O=m.result;h(g,i,O)}else if(m.state===c){O=m.result;h(d,i,O)}else{throw new TypeError("unexpected Promise state")}return i.promise}});y=new r(E);I=T.then;return E}();if(S.Promise){delete S.Promise.accept;delete S.Promise.defer;delete S.Promise.prototype.chain}if(typeof Fr==="function"){b(S,{Promise:Fr});var Dr=w(S.Promise,function(e){return e.resolve(42).then(function(){})instanceof e});var zr=!i(function(){return S.Promise.reject(42).then(null,5).then(null,W)});var qr=i(function(){return S.Promise.call(3,W)});var Wr=function(e){var t=e.resolve(5);t.constructor={};var r=e.resolve(t);try{r.then(null,W).then(null,W)}catch(n){return true}return t===r}(S.Promise);var Gr=s&&function(){var e=0;var t=Object.defineProperty({},"then",{get:function(){e+=1}});Promise.resolve(t);return e===1}();var Hr=function BadResolverPromise(e){var t=new Promise(e);e(3,function(){});this.then=t.then;this.constructor=BadResolverPromise};Hr.prototype=Promise.prototype;Hr.all=Promise.all;var Vr=a(function(){return!!Hr.all([1,2])});if(!Dr||!zr||!qr||Wr||!Gr||Vr){Promise=Fr;ne(S,"Promise",Fr)}if(Promise.all.length!==1){var Br=Promise.all;ne(Promise,"all",function all(e){return ce.Call(Br,this,arguments)})}if(Promise.race.length!==1){var Ur=Promise.race;ne(Promise,"race",function race(e){return ce.Call(Ur,this,arguments)})}if(Promise.resolve.length!==1){var $r=Promise.resolve;ne(Promise,"resolve",function resolve(e){return ce.Call($r,this,arguments)})}if(Promise.reject.length!==1){var Jr=Promise.reject;ne(Promise,"reject",function reject(e){return ce.Call(Jr,this,arguments)})}Mt(Promise,"all");Mt(Promise,"race");Mt(Promise,"resolve");Mt(Promise,"reject");Ce(Promise)}var Xr=function(e){var t=n(p(e,function(e,t){e[t]=true;return e},{}));return e.join(":")===t.join(":")};var Kr=Xr(["z","a","bb"]);var Zr=Xr(["z",1,"a","3",2]);if(s){var Yr=function fastkey(e,t){if(!t&&!Kr){return null}if(se(e)){return"^"+ce.ToString(e)}else if(typeof e==="string"){return"$"+e}else if(typeof e==="number"){if(!Zr){return"n"+e}return e}else if(typeof e==="boolean"){return"b"+e}return null};var Qr=function emptyObject(){return Object.create?Object.create(null):{}};var en=function addIterableToMap(e,n,o){if(r(o)||re.string(o)){l(o,function(e){if(!ce.TypeIsObject(e)){throw new TypeError("Iterator value "+e+" is not an entry object")}n.set(e[0],e[1])})}else if(o instanceof e){t(e.prototype.forEach,o,function(e,t){n.set(t,e)})}else{var i,a;if(!se(o)){a=n.set;if(!ce.IsCallable(a)){throw new TypeError("bad map")}i=ce.GetIterator(o)}if(typeof i!=="undefined"){while(true){var u=ce.IteratorStep(i);if(u===false){break}var f=u.value;try{if(!ce.TypeIsObject(f)){throw new TypeError("Iterator value "+f+" is not an entry object")}t(a,n,f[0],f[1])}catch(s){ce.IteratorClose(i,true);throw s}}}}};var tn=function addIterableToSet(e,n,o){if(r(o)||re.string(o)){l(o,function(e){n.add(e)})}else if(o instanceof e){t(e.prototype.forEach,o,function(e){n.add(e)})}else{var i,a;if(!se(o)){a=n.add;if(!ce.IsCallable(a)){throw new TypeError("bad set")}i=ce.GetIterator(o)}if(typeof i!=="undefined"){while(true){var u=ce.IteratorStep(i);if(u===false){break}var f=u.value;try{t(a,n,f)}catch(s){ce.IteratorClose(i,true);throw s}}}}};var rn={Map:function(){var e={};var r=function MapEntry(e,t){this.key=e;this.value=t;this.next=null;this.prev=null};r.prototype.isRemoved=function isRemoved(){return this.key===e};var n=function isMap(e){return!!e._es6map};var o=function requireMapSlot(e,t){if(!ce.TypeIsObject(e)||!n(e)){throw new TypeError("Method Map.prototype."+t+" called on incompatible receiver "+ce.ToString(e))}};var i=function MapIterator(e,t){o(e,"[[MapIterator]]");this.head=e._head;this.i=this.head;this.kind=t};i.prototype={isMapIterator:true,next:function next(){if(!this.isMapIterator){throw new TypeError("Not a MapIterator")}var e=this.i;var t=this.kind;var r=this.head;if(typeof this.i==="undefined"){return Ke()}while(e.isRemoved()&&e!==r){e=e.prev}var n;while(e.next!==r){e=e.next;if(!e.isRemoved()){if(t==="key"){n=e.key}else if(t==="value"){n=e.value}else{n=[e.key,e.value]}this.i=e;return Ke(n)}}this.i=void 0;return Ke()}};Me(i.prototype);var a;var u=function Map(){if(!(this instanceof Map)){throw new TypeError('Constructor Map requires "new"')}if(this&&this._es6map){throw new TypeError("Bad construction")}var e=Ae(this,Map,a,{_es6map:true,_head:null,_map:G?new G:null,_size:0,_storage:Qr()});var t=new r(null,null);t.next=t.prev=t;e._head=t;if(arguments.length>0){en(Map,e,arguments[0])}return e};a=u.prototype;m.getter(a,"size",function(){if(typeof this._size==="undefined"){throw new TypeError("size method called on incompatible Map")}return this._size});b(a,{get:function get(e){o(this,"get");var t;var r=Yr(e,true);if(r!==null){t=this._storage[r];if(t){return t.value}else{return}}if(this._map){t=V.call(this._map,e);if(t){return t.value}else{return}}var n=this._head;var i=n;while((i=i.next)!==n){if(ce.SameValueZero(i.key,e)){return i.value}}},has:function has(e){o(this,"has");var t=Yr(e,true);if(t!==null){return typeof this._storage[t]!=="undefined"}if(this._map){return B.call(this._map,e)}var r=this._head;var n=r;while((n=n.next)!==r){if(ce.SameValueZero(n.key,e)){return true}}return false},set:function set(e,t){o(this,"set");var n=this._head;var i=n;var a;var u=Yr(e,true);if(u!==null){if(typeof this._storage[u]!=="undefined"){this._storage[u].value=t;return this}else{a=this._storage[u]=new r(e,t);i=n.prev}}else if(this._map){if(B.call(this._map,e)){V.call(this._map,e).value=t}else{a=new r(e,t);U.call(this._map,e,a);i=n.prev}}while((i=i.next)!==n){if(ce.SameValueZero(i.key,e)){i.value=t;return this}}a=a||new r(e,t);if(ce.SameValue(-0,e)){a.key=+0}a.next=this._head;a.prev=this._head.prev;a.prev.next=a;a.next.prev=a;this._size+=1;return this},"delete":function(t){o(this,"delete");var r=this._head;var n=r;var i=Yr(t,true);if(i!==null){if(typeof this._storage[i]==="undefined"){return false}n=this._storage[i].prev;delete this._storage[i]}else if(this._map){if(!B.call(this._map,t)){return false}n=V.call(this._map,t).prev;H.call(this._map,t)}while((n=n.next)!==r){if(ce.SameValueZero(n.key,t)){n.key=e;n.value=e;n.prev.next=n.next;n.next.prev=n.prev;this._size-=1;return true}}return false},clear:function clear(){o(this,"clear");this._map=G?new G:null;this._size=0;this._storage=Qr();var t=this._head;var r=t;var n=r.next;while((r=n)!==t){r.key=e;r.value=e;n=r.next;r.next=r.prev=t}t.next=t.prev=t},keys:function keys(){o(this,"keys");return new i(this,"key")},values:function values(){o(this,"values");return new i(this,"value")},entries:function entries(){o(this,"entries");return new i(this,"key+value")},forEach:function forEach(e){o(this,"forEach");var r=arguments.length>1?arguments[1]:null;var n=this.entries();for(var i=n.next();!i.done;i=n.next()){if(r){t(e,r,i.value[1],i.value[0],this)}else{e(i.value[1],i.value[0],this)}}}});Me(a,a.entries);return u}(),Set:function(){var e=function isSet(e){return e._es6set&&typeof e._storage!=="undefined"};var r=function requireSetSlot(t,r){if(!ce.TypeIsObject(t)||!e(t)){throw new TypeError("Set.prototype."+r+" called on incompatible receiver "+ce.ToString(t))}};var o;var i=function Set(){if(!(this instanceof Set)){throw new TypeError('Constructor Set requires "new"')}if(this&&this._es6set){throw new TypeError("Bad construction")}var e=Ae(this,Set,o,{_es6set:true,"[[SetData]]":null,_storage:Qr()});if(!e._es6set){throw new TypeError("bad set")}if(arguments.length>0){tn(Set,e,arguments[0])}return e};o=i.prototype;var a=function(e){var t=e;if(t==="^null"){return null}else if(t==="^undefined"){return void 0}else{var r=t.charAt(0);if(r==="$"){return C(t,1)}else if(r==="n"){return+C(t,1)}else if(r==="b"){return t==="btrue"}}return+t};var u=function ensureMap(e){if(!e["[[SetData]]"]){var t=new rn.Map;e["[[SetData]]"]=t;l(n(e._storage),function(e){var r=a(e);t.set(r,r)});e["[[SetData]]"]=t}e._storage=null};m.getter(i.prototype,"size",function(){r(this,"size");if(this._storage){return n(this._storage).length}u(this);return this["[[SetData]]"].size});b(i.prototype,{has:function has(e){r(this,"has");var t;if(this._storage&&(t=Yr(e))!==null){return!!this._storage[t]}u(this);return this["[[SetData]]"].has(e)},add:function add(e){r(this,"add");var t;if(this._storage&&(t=Yr(e))!==null){this._storage[t]=true;return this}u(this);this["[[SetData]]"].set(e,e);return this},"delete":function(e){r(this,"delete");var t;if(this._storage&&(t=Yr(e))!==null){var n=z(this._storage,t);return delete this._storage[t]&&n}u(this);return this["[[SetData]]"]["delete"](e)},clear:function clear(){r(this,"clear");if(this._storage){this._storage=Qr()}if(this["[[SetData]]"]){this["[[SetData]]"].clear()}},values:function values(){r(this,"values");u(this);return new f(this["[[SetData]]"].values())},entries:function entries(){r(this,"entries");u(this);return new f(this["[[SetData]]"].entries())},forEach:function forEach(e){r(this,"forEach");var n=arguments.length>1?arguments[1]:null;var o=this;u(o);this["[[SetData]]"].forEach(function(r,i){if(n){t(e,n,i,i,o)}else{e(i,i,o)}})}});h(i.prototype,"keys",i.prototype.values,true);Me(i.prototype,i.prototype.values);var f=function SetIterator(e){this.it=e};f.prototype={isSetIterator:true,next:function next(){if(!this.isSetIterator){throw new TypeError("Not a SetIterator")}return this.it.next()}};Me(f.prototype);return i}()};var nn=S.Set&&!Set.prototype["delete"]&&Set.prototype.remove&&Set.prototype.items&&Set.prototype.map&&Array.isArray((new Set).keys);if(nn){S.Set=rn.Set}if(S.Map||S.Set){var on=a(function(){return new Map([[1,2]]).get(1)===2});if(!on){S.Map=function Map(){if(!(this instanceof Map)){throw new TypeError('Constructor Map requires "new"')}var e=new G;if(arguments.length>0){en(Map,e,arguments[0])}delete e.constructor;Object.setPrototypeOf(e,S.Map.prototype);return e};S.Map.prototype=O(G.prototype);h(S.Map.prototype,"constructor",S.Map,true);m.preserveToString(S.Map,G)}var an=new Map;var un=function(){var e=new Map([[1,0],[2,0],[3,0],[4,0]]);e.set(-0,e);return e.get(0)===e&&e.get(-0)===e&&e.has(0)&&e.has(-0)}();var fn=an.set(1,2)===an;if(!un||!fn){ne(Map.prototype,"set",function set(e,r){t(U,this,e===0?0:e,r);return this})}if(!un){b(Map.prototype,{get:function get(e){return t(V,this,e===0?0:e)},has:function has(e){return t(B,this,e===0?0:e)}},true);m.preserveToString(Map.prototype.get,V);m.preserveToString(Map.prototype.has,B)}var sn=new Set;var cn=Set.prototype["delete"]&&Set.prototype.add&&Set.prototype.has&&function(e){e["delete"](0);e.add(-0);return!e.has(0)}(sn);var ln=sn.add(1)===sn;if(!cn||!ln){var pn=Set.prototype.add;Set.prototype.add=function add(e){t(pn,this,e===0?0:e);return this};m.preserveToString(Set.prototype.add,pn)}if(!cn){var vn=Set.prototype.has;Set.prototype.has=function has(e){return t(vn,this,e===0?0:e)};m.preserveToString(Set.prototype.has,vn);var yn=Set.prototype["delete"];Set.prototype["delete"]=function SetDelete(e){return t(yn,this,e===0?0:e)};m.preserveToString(Set.prototype["delete"],yn)}var hn=w(S.Map,function(e){var t=new e([]);t.set(42,42);return t instanceof e});var bn=Object.setPrototypeOf&&!hn;var gn=function(){try{return!(S.Map()instanceof S.Map)}catch(e){return e instanceof TypeError}}();if(S.Map.length!==0||bn||!gn){S.Map=function Map(){if(!(this instanceof Map)){throw new TypeError('Constructor Map requires "new"')}var e=new G;if(arguments.length>0){en(Map,e,arguments[0])}delete e.constructor;Object.setPrototypeOf(e,Map.prototype);return e};S.Map.prototype=G.prototype;h(S.Map.prototype,"constructor",S.Map,true);m.preserveToString(S.Map,G)}var dn=w(S.Set,function(e){var t=new e([]);t.add(42,42);return t instanceof e});var mn=Object.setPrototypeOf&&!dn;var On=function(){try{return!(S.Set()instanceof S.Set)}catch(e){return e instanceof TypeError}}();if(S.Set.length!==0||mn||!On){var wn=S.Set;S.Set=function Set(){if(!(this instanceof Set)){throw new TypeError('Constructor Set requires "new"')}var e=new wn;if(arguments.length>0){tn(Set,e,arguments[0])}delete e.constructor;Object.setPrototypeOf(e,Set.prototype);return e};S.Set.prototype=wn.prototype;h(S.Set.prototype,"constructor",S.Set,true);m.preserveToString(S.Set,wn)}var jn=new S.Map;var Sn=!a(function(){return jn.keys().next().done});if(typeof S.Map.prototype.clear!=="function"||(new S.Set).size!==0||jn.size!==0||typeof S.Map.prototype.keys!=="function"||typeof S.Set.prototype.keys!=="function"||typeof S.Map.prototype.forEach!=="function"||typeof S.Set.prototype.forEach!=="function"||u(S.Map)||u(S.Set)||typeof jn.keys().next!=="function"||Sn||!hn){b(S,{Map:rn.Map,Set:rn.Set},true)}if(S.Set.prototype.keys!==S.Set.prototype.values){h(S.Set.prototype,"keys",S.Set.prototype.values,true)}Me(Object.getPrototypeOf((new S.Map).keys()));Me(Object.getPrototypeOf((new S.Set).keys()));if(c&&S.Set.prototype.has.name!=="has"){var Tn=S.Set.prototype.has;ne(S.Set.prototype,"has",function has(e){return t(Tn,this,e)})}}b(S,rn);Ce(S.Map);Ce(S.Set)}var In=function throwUnlessTargetIsObject(e){if(!ce.TypeIsObject(e)){throw new TypeError("target must be an object")}};var En={apply:function apply(){return ce.Call(ce.Call,null,arguments)},construct:function construct(e,t){if(!ce.IsConstructor(e)){throw new TypeError("First argument must be a constructor.")}var r=arguments.length>2?arguments[2]:e;if(!ce.IsConstructor(r)){throw new TypeError("new.target must be a constructor.")}return ce.Construct(e,t,r,"internal")},deleteProperty:function deleteProperty(e,t){In(e);if(s){var r=Object.getOwnPropertyDescriptor(e,t);if(r&&!r.configurable){return false}}return delete e[t]},has:function has(e,t){In(e);return t in e}};if(Object.getOwnPropertyNames){Object.assign(En,{ownKeys:function ownKeys(e){In(e);var t=Object.getOwnPropertyNames(e);if(ce.IsCallable(Object.getOwnPropertySymbols)){x(t,Object.getOwnPropertySymbols(e))}return t}})}var Pn=function ConvertExceptionToBoolean(e){return!i(e)};if(Object.preventExtensions){Object.assign(En,{isExtensible:function isExtensible(e){In(e);return Object.isExtensible(e)},preventExtensions:function preventExtensions(e){In(e);return Pn(function(){return Object.preventExtensions(e)})}})}if(s){var Cn=function get(e,t,r){var n=Object.getOwnPropertyDescriptor(e,t);if(!n){var o=Object.getPrototypeOf(e);if(o===null){return void 0}return Cn(o,t,r)}if("value"in n){return n.value}if(n.get){return ce.Call(n.get,r)}return void 0};var Mn=function set(e,r,n,o){var i=Object.getOwnPropertyDescriptor(e,r);if(!i){var a=Object.getPrototypeOf(e);if(a!==null){return Mn(a,r,n,o)}i={value:void 0,writable:true,enumerable:true,configurable:true}}if("value"in i){if(!i.writable){return false}if(!ce.TypeIsObject(o)){return false}var u=Object.getOwnPropertyDescriptor(o,r);if(u){return ae.defineProperty(o,r,{value:n})}else{return ae.defineProperty(o,r,{value:n,writable:true,enumerable:true,configurable:true})}}if(i.set){t(i.set,o,n);return true}return false};Object.assign(En,{defineProperty:function defineProperty(e,t,r){In(e);return Pn(function(){return Object.defineProperty(e,t,r)})},getOwnPropertyDescriptor:function getOwnPropertyDescriptor(e,t){In(e);return Object.getOwnPropertyDescriptor(e,t)},get:function get(e,t){In(e);var r=arguments.length>2?arguments[2]:e;return Cn(e,t,r)},set:function set(e,t,r){In(e);var n=arguments.length>3?arguments[3]:e;return Mn(e,t,r,n)}})}if(Object.getPrototypeOf){var xn=Object.getPrototypeOf;En.getPrototypeOf=function getPrototypeOf(e){In(e);return xn(e)}}if(Object.setPrototypeOf&&En.getPrototypeOf){var Nn=function(e,t){var r=t;while(r){if(e===r){return true}r=En.getPrototypeOf(r)}return false};Object.assign(En,{setPrototypeOf:function setPrototypeOf(e,t){In(e);if(t!==null&&!ce.TypeIsObject(t)){throw new TypeError("proto must be an object or null")}if(t===ae.getPrototypeOf(e)){return true}if(ae.isExtensible&&!ae.isExtensible(e)){return false}if(Nn(e,t)){return false}Object.setPrototypeOf(e,t);return true}})}var An=function(e,t){if(!ce.IsCallable(S.Reflect[e])){h(S.Reflect,e,t)}else{var r=a(function(){S.Reflect[e](1);S.Reflect[e](NaN);S.Reflect[e](true);return true});if(r){ne(S.Reflect,e,t)}}};Object.keys(En).forEach(function(e){An(e,En[e])});var Rn=S.Reflect.getPrototypeOf;if(c&&Rn&&Rn.name!=="getPrototypeOf"){ne(S.Reflect,"getPrototypeOf",function getPrototypeOf(e){return t(Rn,S.Reflect,e)})}if(S.Reflect.setPrototypeOf){if(a(function(){S.Reflect.setPrototypeOf(1,{});return true})){ne(S.Reflect,"setPrototypeOf",En.setPrototypeOf)}}if(S.Reflect.defineProperty){if(!a(function(){var e=!S.Reflect.defineProperty(1,"test",{value:1});var t=typeof Object.preventExtensions!=="function"||!S.Reflect.defineProperty(Object.preventExtensions({}),"test",{});return e&&t})){ne(S.Reflect,"defineProperty",En.defineProperty)}}if(S.Reflect.construct){if(!a(function(){var e=function F(){};return S.Reflect.construct(function(){},[],e)instanceof e})){ne(S.Reflect,"construct",En.construct)}}if(String(new Date(NaN))!=="Invalid Date"){var _n=Date.prototype.toString;var kn=function toString(){var e=+this;if(e!==e){return"Invalid Date"}return ce.Call(_n,this)};ne(Date.prototype,"toString",kn)}var Ln={anchor:function anchor(e){return ce.CreateHTML(this,"a","name",e)},big:function big(){return ce.CreateHTML(this,"big","","")},blink:function blink(){return ce.CreateHTML(this,"blink","","")},bold:function bold(){return ce.CreateHTML(this,"b","","")},fixed:function fixed(){return ce.CreateHTML(this,"tt","","")},fontcolor:function fontcolor(e){return ce.CreateHTML(this,"font","color",e)},fontsize:function fontsize(e){return ce.CreateHTML(this,"font","size",e)},italics:function italics(){return ce.CreateHTML(this,"i","","")},link:function link(e){return ce.CreateHTML(this,"a","href",e)},small:function small(){return ce.CreateHTML(this,"small","","")},strike:function strike(){return ce.CreateHTML(this,"strike","","")},sub:function sub(){return ce.CreateHTML(this,"sub","","")},sup:function sub(){return ce.CreateHTML(this,"sup","","")}};l(Object.keys(Ln),function(e){var r=String.prototype[e];var n=false;if(ce.IsCallable(r)){var o=t(r,"",' " ');var i=P([],o.match(/"/g)).length;n=o!==o.toLowerCase()||i>2}else{n=true}if(n){ne(String.prototype,e,Ln[e])}});var Fn=function(){if(!oe){return false}var e=typeof JSON==="object"&&typeof JSON.stringify==="function"?JSON.stringify:null;if(!e){return false}if(typeof e($())!=="undefined"){return true}if(e([$()])!=="[null]"){return true}var t={a:$()};t[$()]=true;if(e(t)!=="{}"){return true}return false}();var Dn=a(function(){if(!oe){return true}return JSON.stringify(Object($()))==="{}"&&JSON.stringify([Object($())])==="[{}]"});if(Fn||!Dn){var zn=JSON.stringify;ne(JSON,"stringify",function stringify(e){if(typeof e==="symbol"){return}var n;if(arguments.length>1){n=arguments[1]}var o=[e];if(!r(n)){var i=ce.IsCallable(n)?n:null;var a=function(e,r){var n=i?t(i,this,e,r):r;if(typeof n!=="symbol"){if(re.symbol(n)){return Nt({})(n)}else{return n}}};o.push(a)}else{o.push(n)}if(arguments.length>2){o.push(arguments[2])}return zn.apply(this,o)})}return S});
//# sourceMappingURL=es6-shim.map
;/*!
 * https://github.com/paulmillr/es6-shim
 * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
 *   and contributors,  MIT License
 * es6-sham: v0.35.4
 * see https://github.com/paulmillr/es6-shim/blob/0.35.3/LICENSE
 * Details and documentation:
 * https://github.com/paulmillr/es6-shim/
 */
(function(t,e){if(typeof define==="function"&&define.amd){define(e)}else if(typeof exports==="object"){module.exports=e()}else{t.returnExports=e()}})(this,function(){"use strict";var t=new Function("return this;");var e=t();var r=e.Object;var n=Function.call.bind(Function.call);var o=Function.toString;var i=String.prototype.match;var f=function(t){try{t();return false}catch(e){return true}};var u=function(){return!f(function(){r.defineProperty({},"x",{get:function(){}})})};var a=!!r.defineProperty&&u();(function(){if(r.setPrototypeOf){return}var t=r.getOwnPropertyNames;var e=r.getOwnPropertyDescriptor;var n=r.create;var o=r.defineProperty;var i=r.getPrototypeOf;var f=r.prototype;var u=function(r,n){t(n).forEach(function(t){o(r,t,e(n,t))});return r};var a=function(t,e){return u(n(e),t)};var c,s;try{c=e(f,"__proto__").set;c.call({},null);s=function(t,e){c.call(t,e);return t}}catch(p){c={__proto__:null};if(c instanceof r){s=a}else{c.__proto__=f;if(c instanceof r){s=function(t,e){t.__proto__=e;return t}}else{s=function(t,e){if(i(t)){t.__proto__=e;return t}else{return a(t,e)}}}}}r.setPrototypeOf=s})();if(a&&function foo(){}.name!=="foo"){r.defineProperty(Function.prototype,"name",{configurable:true,enumerable:false,get:function(){if(this===Function.prototype){return""}var t=n(o,this);var e=n(i,t,/\s*function\s+([^(\s]*)\s*/);var f=e&&e[1];r.defineProperty(this,"name",{configurable:true,enumerable:false,writable:false,value:f});return f}})}});
//# sourceMappingURL=es6-sham.map
;/*! jQuery v1.9.1 | (c) 2005, 2012 jQuery Foundation, Inc. | jquery.org/license
//@ sourceMappingURL=jquery.min.map
*/(function(e,t){var n,r,i=typeof t,o=e.document,a=e.location,s=e.jQuery,u=e.$,l={},c=[],p="1.9.1",f=c.concat,d=c.push,h=c.slice,g=c.indexOf,m=l.toString,y=l.hasOwnProperty,v=p.trim,b=function(e,t){return new b.fn.init(e,t,r)},x=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,w=/\S+/g,T=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,N=/^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,C=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,k=/^[\],:{}\s]*$/,E=/(?:^|:|,)(?:\s*\[)+/g,S=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,A=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,j=/^-ms-/,D=/-([\da-z])/gi,L=function(e,t){return t.toUpperCase()},H=function(e){(o.addEventListener||"load"===e.type||"complete"===o.readyState)&&(q(),b.ready())},q=function(){o.addEventListener?(o.removeEventListener("DOMContentLoaded",H,!1),e.removeEventListener("load",H,!1)):(o.detachEvent("onreadystatechange",H),e.detachEvent("onload",H))};b.fn=b.prototype={jquery:p,constructor:b,init:function(e,n,r){var i,a;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof b?n[0]:n,b.merge(this,b.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:o,!0)),C.test(i[1])&&b.isPlainObject(n))for(i in n)b.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(a=o.getElementById(i[2]),a&&a.parentNode){if(a.id!==i[2])return r.find(e);this.length=1,this[0]=a}return this.context=o,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):b.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),b.makeArray(e,this))},selector:"",length:0,size:function(){return this.length},toArray:function(){return h.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=b.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return b.each(this,e,t)},ready:function(e){return b.ready.promise().done(e),this},slice:function(){return this.pushStack(h.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(b.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:d,sort:[].sort,splice:[].splice},b.fn.init.prototype=b.fn,b.extend=b.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},u=1,l=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},u=2),"object"==typeof s||b.isFunction(s)||(s={}),l===u&&(s=this,--u);l>u;u++)if(null!=(o=arguments[u]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(b.isPlainObject(r)||(n=b.isArray(r)))?(n?(n=!1,a=e&&b.isArray(e)?e:[]):a=e&&b.isPlainObject(e)?e:{},s[i]=b.extend(c,a,r)):r!==t&&(s[i]=r));return s},b.extend({noConflict:function(t){return e.$===b&&(e.$=u),t&&e.jQuery===b&&(e.jQuery=s),b},isReady:!1,readyWait:1,holdReady:function(e){e?b.readyWait++:b.ready(!0)},ready:function(e){if(e===!0?!--b.readyWait:!b.isReady){if(!o.body)return setTimeout(b.ready);b.isReady=!0,e!==!0&&--b.readyWait>0||(n.resolveWith(o,[b]),b.fn.trigger&&b(o).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===b.type(e)},isArray:Array.isArray||function(e){return"array"===b.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?l[m.call(e)]||"object":typeof e},isPlainObject:function(e){if(!e||"object"!==b.type(e)||e.nodeType||b.isWindow(e))return!1;try{if(e.constructor&&!y.call(e,"constructor")&&!y.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(n){return!1}var r;for(r in e);return r===t||y.call(e,r)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||o;var r=C.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=b.buildFragment([e],t,i),i&&b(i).remove(),b.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=b.trim(n),n&&k.test(n.replace(S,"@").replace(A,"]").replace(E,"")))?Function("return "+n)():(b.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||b.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&b.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(j,"ms-").replace(D,L)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:v&&!v.call("\ufeff\u00a0")?function(e){return null==e?"":v.call(e)}:function(e){return null==e?"":(e+"").replace(T,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?b.merge(n,"string"==typeof e?[e]:e):d.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(g)return g.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return f.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(o=e[n],n=e,e=o),b.isFunction(e)?(r=h.call(arguments,2),i=function(){return e.apply(n||this,r.concat(h.call(arguments)))},i.guid=e.guid=e.guid||b.guid++,i):t},access:function(e,n,r,i,o,a,s){var u=0,l=e.length,c=null==r;if("object"===b.type(r)){o=!0;for(u in r)b.access(e,n,u,r[u],!0,a,s)}else if(i!==t&&(o=!0,b.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(b(e),n)})),n))for(;l>u;u++)n(e[u],r,s?i:i.call(e[u],u,n(e[u],r)));return o?e:c?n.call(e):l?n(e[0],r):a},now:function(){return(new Date).getTime()}}),b.ready.promise=function(t){if(!n)if(n=b.Deferred(),"complete"===o.readyState)setTimeout(b.ready);else if(o.addEventListener)o.addEventListener("DOMContentLoaded",H,!1),e.addEventListener("load",H,!1);else{o.attachEvent("onreadystatechange",H),e.attachEvent("onload",H);var r=!1;try{r=null==e.frameElement&&o.documentElement}catch(i){}r&&r.doScroll&&function a(){if(!b.isReady){try{r.doScroll("left")}catch(e){return setTimeout(a,50)}q(),b.ready()}}()}return n.promise(t)},b.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){l["[object "+t+"]"]=t.toLowerCase()});function M(e){var t=e.length,n=b.type(e);return b.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}r=b(o);var _={};function F(e){var t=_[e]={};return b.each(e.match(w)||[],function(e,n){t[n]=!0}),t}b.Callbacks=function(e){e="string"==typeof e?_[e]||F(e):b.extend({},e);var n,r,i,o,a,s,u=[],l=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=u.length,n=!0;u&&o>a;a++)if(u[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,u&&(l?l.length&&c(l.shift()):r?u=[]:p.disable())},p={add:function(){if(u){var t=u.length;(function i(t){b.each(t,function(t,n){var r=b.type(n);"function"===r?e.unique&&p.has(n)||u.push(n):n&&n.length&&"string"!==r&&i(n)})})(arguments),n?o=u.length:r&&(s=t,c(r))}return this},remove:function(){return u&&b.each(arguments,function(e,t){var r;while((r=b.inArray(t,u,r))>-1)u.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?b.inArray(e,u)>-1:!(!u||!u.length)},empty:function(){return u=[],this},disable:function(){return u=l=r=t,this},disabled:function(){return!u},lock:function(){return l=t,r||p.disable(),this},locked:function(){return!l},fireWith:function(e,t){return t=t||[],t=[e,t.slice?t.slice():t],!u||i&&!l||(n?l.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},b.extend({Deferred:function(e){var t=[["resolve","done",b.Callbacks("once memory"),"resolved"],["reject","fail",b.Callbacks("once memory"),"rejected"],["notify","progress",b.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return b.Deferred(function(n){b.each(t,function(t,o){var a=o[0],s=b.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&b.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?b.extend(e,r):r}},i={};return r.pipe=r.then,b.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=h.call(arguments),r=n.length,i=1!==r||e&&b.isFunction(e.promise)?r:0,o=1===i?e:b.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?h.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,u,l;if(r>1)for(s=Array(r),u=Array(r),l=Array(r);r>t;t++)n[t]&&b.isFunction(n[t].promise)?n[t].promise().done(a(t,l,n)).fail(o.reject).progress(a(t,u,s)):--i;return i||o.resolveWith(l,n),o.promise()}}),b.support=function(){var t,n,r,a,s,u,l,c,p,f,d=o.createElement("div");if(d.setAttribute("className","t"),d.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=d.getElementsByTagName("*"),r=d.getElementsByTagName("a")[0],!n||!r||!n.length)return{};s=o.createElement("select"),l=s.appendChild(o.createElement("option")),a=d.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t={getSetAttribute:"t"!==d.className,leadingWhitespace:3===d.firstChild.nodeType,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/top/.test(r.getAttribute("style")),hrefNormalized:"/a"===r.getAttribute("href"),opacity:/^0.5/.test(r.style.opacity),cssFloat:!!r.style.cssFloat,checkOn:!!a.value,optSelected:l.selected,enctype:!!o.createElement("form").enctype,html5Clone:"<:nav></:nav>"!==o.createElement("nav").cloneNode(!0).outerHTML,boxModel:"CSS1Compat"===o.compatMode,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,boxSizingReliable:!0,pixelPosition:!1},a.checked=!0,t.noCloneChecked=a.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!l.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}a=o.createElement("input"),a.setAttribute("value",""),t.input=""===a.getAttribute("value"),a.value="t",a.setAttribute("type","radio"),t.radioValue="t"===a.value,a.setAttribute("checked","t"),a.setAttribute("name","t"),u=o.createDocumentFragment(),u.appendChild(a),t.appendChecked=a.checked,t.checkClone=u.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent("onclick",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c="on"+f,"t"),t[f+"Bubbles"]=c in e||d.attributes[c].expando===!1;return d.style.backgroundClip="content-box",d.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===d.style.backgroundClip,b(function(){var n,r,a,s="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",u=o.getElementsByTagName("body")[0];u&&(n=o.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",u.appendChild(n).appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",a=d.getElementsByTagName("td"),a[0].style.cssText="padding:0;margin:0;border:0;display:none",p=0===a[0].offsetHeight,a[0].style.display="",a[1].style.display="none",t.reliableHiddenOffsets=p&&0===a[0].offsetHeight,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",t.boxSizing=4===d.offsetWidth,t.doesNotIncludeMarginInBodyOffset=1!==u.offsetTop,e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(d,null)||{width:"4px"}).width,r=d.appendChild(o.createElement("div")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width="0",d.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML="",d.style.cssText=s+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display="block",d.innerHTML="<div></div>",d.firstChild.style.width="5px",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(u.style.zoom=1)),u.removeChild(n),n=d=a=r=null)}),n=s=u=l=r=a=null,t}();var O=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,B=/([A-Z])/g;function P(e,n,r,i){if(b.acceptData(e)){var o,a,s=b.expando,u="string"==typeof n,l=e.nodeType,p=l?b.cache:e,f=l?e[s]:e[s]&&s;if(f&&p[f]&&(i||p[f].data)||!u||r!==t)return f||(l?e[s]=f=c.pop()||b.guid++:f=s),p[f]||(p[f]={},l||(p[f].toJSON=b.noop)),("object"==typeof n||"function"==typeof n)&&(i?p[f]=b.extend(p[f],n):p[f].data=b.extend(p[f].data,n)),o=p[f],i||(o.data||(o.data={}),o=o.data),r!==t&&(o[b.camelCase(n)]=r),u?(a=o[n],null==a&&(a=o[b.camelCase(n)])):a=o,a}}function R(e,t,n){if(b.acceptData(e)){var r,i,o,a=e.nodeType,s=a?b.cache:e,u=a?e[b.expando]:b.expando;if(s[u]){if(t&&(o=n?s[u]:s[u].data)){b.isArray(t)?t=t.concat(b.map(t,b.camelCase)):t in o?t=[t]:(t=b.camelCase(t),t=t in o?[t]:t.split(" "));for(r=0,i=t.length;i>r;r++)delete o[t[r]];if(!(n?$:b.isEmptyObject)(o))return}(n||(delete s[u].data,$(s[u])))&&(a?b.cleanData([e],!0):b.support.deleteExpando||s!=s.window?delete s[u]:s[u]=null)}}}b.extend({cache:{},expando:"jQuery"+(p+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(e){return e=e.nodeType?b.cache[e[b.expando]]:e[b.expando],!!e&&!$(e)},data:function(e,t,n){return P(e,t,n)},removeData:function(e,t){return R(e,t)},_data:function(e,t,n){return P(e,t,n,!0)},_removeData:function(e,t){return R(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&b.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),b.fn.extend({data:function(e,n){var r,i,o=this[0],a=0,s=null;if(e===t){if(this.length&&(s=b.data(o),1===o.nodeType&&!b._data(o,"parsedAttrs"))){for(r=o.attributes;r.length>a;a++)i=r[a].name,i.indexOf("data-")||(i=b.camelCase(i.slice(5)),W(o,i,s[i]));b._data(o,"parsedAttrs",!0)}return s}return"object"==typeof e?this.each(function(){b.data(this,e)}):b.access(this,function(n){return n===t?o?W(o,e,b.data(o,e)):null:(this.each(function(){b.data(this,e,n)}),t)},null,n,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){b.removeData(this,e)})}});function W(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(B,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:O.test(r)?b.parseJSON(r):r}catch(o){}b.data(e,n,r)}else r=t}return r}function $(e){var t;for(t in e)if(("data"!==t||!b.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}b.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=b._data(e,n),r&&(!i||b.isArray(r)?i=b._data(e,n,b.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=b.queue(e,t),r=n.length,i=n.shift(),o=b._queueHooks(e,t),a=function(){b.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),o.cur=i,i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return b._data(e,n)||b._data(e,n,{empty:b.Callbacks("once memory").add(function(){b._removeData(e,t+"queue"),b._removeData(e,n)})})}}),b.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?b.queue(this[0],e):n===t?this:this.each(function(){var t=b.queue(this,e,n);b._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&b.dequeue(this,e)})},dequeue:function(e){return this.each(function(){b.dequeue(this,e)})},delay:function(e,t){return e=b.fx?b.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=b.Deferred(),a=this,s=this.length,u=function(){--i||o.resolveWith(a,[a])};"string"!=typeof e&&(n=e,e=t),e=e||"fx";while(s--)r=b._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(u));return u(),o.promise(n)}});var I,z,X=/[\t\r\n]/g,U=/\r/g,V=/^(?:input|select|textarea|button|object)$/i,Y=/^(?:a|area)$/i,J=/^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,G=/^(?:checked|selected)$/i,Q=b.support.getSetAttribute,K=b.support.input;b.fn.extend({attr:function(e,t){return b.access(this,b.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){b.removeAttr(this,e)})},prop:function(e,t){return b.access(this,b.prop,e,t,arguments.length>1)},removeProp:function(e){return e=b.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,u="string"==typeof e&&e;if(b.isFunction(e))return this.each(function(t){b(this).addClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(X," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=b.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,u=0===arguments.length||"string"==typeof e&&e;if(b.isFunction(e))return this.each(function(t){b(this).removeClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(X," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?b.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e,r="boolean"==typeof t;return b.isFunction(e)?this.each(function(n){b(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var o,a=0,s=b(this),u=t,l=e.match(w)||[];while(o=l[a++])u=r?u:!s.hasClass(o),s[u?"addClass":"removeClass"](o)}else(n===i||"boolean"===n)&&(this.className&&b._data(this,"__className__",this.className),this.className=this.className||e===!1?"":b._data(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(X," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=b.isFunction(e),this.each(function(n){var o,a=b(this);1===this.nodeType&&(o=i?e.call(this,n,a.val()):e,null==o?o="":"number"==typeof o?o+="":b.isArray(o)&&(o=b.map(o,function(e){return null==e?"":e+""})),r=b.valHooks[this.type]||b.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,o,"value")!==t||(this.value=o))});if(o)return r=b.valHooks[o.type]||b.valHooks[o.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(o,"value"))!==t?n:(n=o.value,"string"==typeof n?n.replace(U,""):null==n?"":n)}}}),b.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,u=0>i?s:o?i:0;for(;s>u;u++)if(n=r[u],!(!n.selected&&u!==i||(b.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&b.nodeName(n.parentNode,"optgroup"))){if(t=b(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n=b.makeArray(t);return b(e).find("option").each(function(){this.selected=b.inArray(b(this).val(),n)>=0}),n.length||(e.selectedIndex=-1),n}}},attr:function(e,n,r){var o,a,s,u=e.nodeType;if(e&&3!==u&&8!==u&&2!==u)return typeof e.getAttribute===i?b.prop(e,n,r):(a=1!==u||!b.isXMLDoc(e),a&&(n=n.toLowerCase(),o=b.attrHooks[n]||(J.test(n)?z:I)),r===t?o&&a&&"get"in o&&null!==(s=o.get(e,n))?s:(typeof e.getAttribute!==i&&(s=e.getAttribute(n)),null==s?t:s):null!==r?o&&a&&"set"in o&&(s=o.set(e,r,n))!==t?s:(e.setAttribute(n,r+""),r):(b.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(w);if(o&&1===e.nodeType)while(n=o[i++])r=b.propFix[n]||n,J.test(n)?!Q&&G.test(n)?e[b.camelCase("default-"+n)]=e[r]=!1:e[r]=!1:b.attr(e,n,""),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!b.support.radioValue&&"radio"===t&&b.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!b.isXMLDoc(e),a&&(n=b.propFix[n]||n,o=b.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var n=e.getAttributeNode("tabindex");return n&&n.specified?parseInt(n.value,10):V.test(e.nodeName)||Y.test(e.nodeName)&&e.href?0:t}}}}),z={get:function(e,n){var r=b.prop(e,n),i="boolean"==typeof r&&e.getAttribute(n),o="boolean"==typeof r?K&&Q?null!=i:G.test(n)?e[b.camelCase("default-"+n)]:!!i:e.getAttributeNode(n);return o&&o.value!==!1?n.toLowerCase():t},set:function(e,t,n){return t===!1?b.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&b.propFix[n]||n,n):e[b.camelCase("default-"+n)]=e[n]=!0,n}},K&&Q||(b.attrHooks.value={get:function(e,n){var r=e.getAttributeNode(n);return b.nodeName(e,"input")?e.defaultValue:r&&r.specified?r.value:t},set:function(e,n,r){return b.nodeName(e,"input")?(e.defaultValue=n,t):I&&I.set(e,n,r)}}),Q||(I=b.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&("id"===n||"name"===n||"coords"===n?""!==r.value:r.specified)?r.value:t},set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},b.attrHooks.contenteditable={get:I.get,set:function(e,t,n){I.set(e,""===t?!1:t,n)}},b.each(["width","height"],function(e,n){b.attrHooks[n]=b.extend(b.attrHooks[n],{set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}})})),b.support.hrefNormalized||(b.each(["href","src","width","height"],function(e,n){b.attrHooks[n]=b.extend(b.attrHooks[n],{get:function(e){var r=e.getAttribute(n,2);return null==r?t:r}})}),b.each(["href","src"],function(e,t){b.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}})),b.support.style||(b.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),b.support.optSelected||(b.propHooks.selected=b.extend(b.propHooks.selected,{get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}})),b.support.enctype||(b.propFix.enctype="encoding"),b.support.checkOn||b.each(["radio","checkbox"],function(){b.valHooks[this]={get:function(e){return null===e.getAttribute("value")?"on":e.value}}}),b.each(["radio","checkbox"],function(){b.valHooks[this]=b.extend(b.valHooks[this],{set:function(e,n){return b.isArray(n)?e.checked=b.inArray(b(e).val(),n)>=0:t}})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\.(.+)|)$/;function it(){return!0}function ot(){return!1}b.event={global:{},add:function(e,n,r,o,a){var s,u,l,c,p,f,d,h,g,m,y,v=b._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=b.guid++),(u=v.events)||(u=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof b===i||e&&b.event.triggered===e.type?t:b.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||"").match(w)||[""],l=n.length;while(l--)s=rt.exec(n[l])||[],g=y=s[1],m=(s[2]||"").split(".").sort(),p=b.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=b.event.special[g]||{},d=b.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&b.expr.match.needsContext.test(a),namespace:m.join(".")},c),(h=u[g])||(h=u[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent("on"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),b.event.global[g]=!0;e=null}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,p,f,d,h,g,m=b.hasData(e)&&b._data(e);if(m&&(c=m.events)){t=(t||"").match(w)||[""],l=t.length;while(l--)if(s=rt.exec(t[l])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){p=b.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),u=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&("**"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));u&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||b.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)b.event.remove(e,d+t[l],n,r,!0);b.isEmptyObject(c)&&(delete m.handle,b._removeData(e,"events"))}},trigger:function(n,r,i,a){var s,u,l,c,p,f,d,h=[i||o],g=y.call(n,"type")?n.type:n,m=y.call(n,"namespace")?n.namespace.split("."):[];if(l=f=i=i||o,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+b.event.triggered)&&(g.indexOf(".")>=0&&(m=g.split("."),g=m.shift(),m.sort()),u=0>g.indexOf(":")&&"on"+g,n=n[b.expando]?n:new b.Event(g,"object"==typeof n&&n),n.isTrigger=!0,n.namespace=m.join("."),n.namespace_re=n.namespace?RegExp("(^|\\.)"+m.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:b.makeArray(r,[n]),p=b.event.special[g]||{},a||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!a&&!p.noBubble&&!b.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(l=l.parentNode);l;l=l.parentNode)h.push(l),f=l;f===(i.ownerDocument||o)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((l=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(b._data(l,"events")||{})[n.type]&&b._data(l,"handle"),s&&s.apply(l,r),s=u&&l[u],s&&b.acceptData(l)&&s.apply&&s.apply(l,r)===!1&&n.preventDefault();if(n.type=g,!(a||n.isDefaultPrevented()||p._default&&p._default.apply(i.ownerDocument,r)!==!1||"click"===g&&b.nodeName(i,"a")||!b.acceptData(i)||!u||!i[g]||b.isWindow(i))){f=i[u],f&&(i[u]=null),b.event.triggered=g;try{i[g]()}catch(v){}b.event.triggered=t,f&&(i[u]=f)}return n.result}},dispatch:function(e){e=b.event.fix(e);var n,r,i,o,a,s=[],u=h.call(arguments),l=(b._data(this,"events")||{})[e.type]||[],c=b.event.special[e.type]||{};if(u[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=b.event.handlers.call(this,e,l),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((b.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,u),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],u=n.delegateCount,l=e.target;if(u&&l.nodeType&&(!e.button||"click"!==e.type))for(;l!=this;l=l.parentNode||this)if(1===l.nodeType&&(l.disabled!==!0||"click"!==e.type)){for(o=[],a=0;u>a;a++)i=n[a],r=i.selector+" ",o[r]===t&&(o[r]=i.needsContext?b(r,this).index(l)>=0:b.find(r,this,null,[l]).length),o[r]&&o.push(i);o.length&&s.push({elem:l,handlers:o})}return n.length>u&&s.push({elem:this,handlers:n.slice(u)}),s},fix:function(e){if(e[b.expando])return e;var t,n,r,i=e.type,a=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new b.Event(a),t=r.length;while(t--)n=r[t],e[n]=a[n];return e.target||(e.target=a.srcElement||o),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,a):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,a,s=n.button,u=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||o,a=i.documentElement,r=i.body,e.pageX=n.clientX+(a&&a.scrollLeft||r&&r.scrollLeft||0)-(a&&a.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(a&&a.scrollTop||r&&r.scrollTop||0)-(a&&a.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&u&&(e.relatedTarget=u===e.target?n.toElement:u),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},click:{trigger:function(){return b.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t}},focus:{trigger:function(){if(this!==o.activeElement&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===o.activeElement&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=b.extend(new b.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?b.event.trigger(i,null,t):b.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},b.removeEvent=o.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},b.Event=function(e,n){return this instanceof b.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&b.extend(this,n),this.timeStamp=e&&e.timeStamp||b.now(),this[b.expando]=!0,t):new b.Event(e,n)},b.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},b.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){b.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;
return(!i||i!==r&&!b.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),b.support.submitBubbles||(b.event.special.submit={setup:function(){return b.nodeName(this,"form")?!1:(b.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=b.nodeName(n,"input")||b.nodeName(n,"button")?n.form:t;r&&!b._data(r,"submitBubbles")&&(b.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),b._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&b.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return b.nodeName(this,"form")?!1:(b.event.remove(this,"._submit"),t)}}),b.support.changeBubbles||(b.event.special.change={setup:function(){return Z.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(b.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),b.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),b.event.simulate("change",this,e,!0)})),!1):(b.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!b._data(t,"changeBubbles")&&(b.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||b.event.simulate("change",this.parentNode,e,!0)}),b._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return b.event.remove(this,"._change"),!Z.test(this.nodeName)}}),b.support.focusinBubbles||b.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){b.event.simulate(t,e.target,b.event.fix(e),!0)};b.event.special[t]={setup:function(){0===n++&&o.addEventListener(e,r,!0)},teardown:function(){0===--n&&o.removeEventListener(e,r,!0)}}}),b.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return b().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=b.guid++)),this.each(function(){b.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,b(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){b.event.remove(this,e,r,n)})},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},trigger:function(e,t){return this.each(function(){b.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?b.event.trigger(e,n,r,!0):t}}),function(e,t){var n,r,i,o,a,s,u,l,c,p,f,d,h,g,m,y,v,x="sizzle"+-new Date,w=e.document,T={},N=0,C=0,k=it(),E=it(),S=it(),A=typeof t,j=1<<31,D=[],L=D.pop,H=D.push,q=D.slice,M=D.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},_="[\\x20\\t\\r\\n\\f]",F="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",O=F.replace("w","w#"),B="([*^$|!~]?=)",P="\\["+_+"*("+F+")"+_+"*(?:"+B+_+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+O+")|)|)"+_+"*\\]",R=":("+F+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+P.replace(3,8)+")*)|.*)\\)|)",W=RegExp("^"+_+"+|((?:^|[^\\\\])(?:\\\\.)*)"+_+"+$","g"),$=RegExp("^"+_+"*,"+_+"*"),I=RegExp("^"+_+"*([\\x20\\t\\r\\n\\f>+~])"+_+"*"),z=RegExp(R),X=RegExp("^"+O+"$"),U={ID:RegExp("^#("+F+")"),CLASS:RegExp("^\\.("+F+")"),NAME:RegExp("^\\[name=['\"]?("+F+")['\"]?\\]"),TAG:RegExp("^("+F.replace("w","w*")+")"),ATTR:RegExp("^"+P),PSEUDO:RegExp("^"+R),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+_+"*(even|odd|(([+-]|)(\\d*)n|)"+_+"*(?:([+-]|)"+_+"*(\\d+)|))"+_+"*\\)|)","i"),needsContext:RegExp("^"+_+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+_+"*((?:-\\d)?\\d*)"+_+"*\\)|)(?=[^-]|$)","i")},V=/[\x20\t\r\n\f]*[+~]/,Y=/^[^{]+\{\s*\[native code/,J=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,G=/^(?:input|select|textarea|button)$/i,Q=/^h\d$/i,K=/'|\\/g,Z=/\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,et=/\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,tt=function(e,t){var n="0x"+t-65536;return n!==n?t:0>n?String.fromCharCode(n+65536):String.fromCharCode(55296|n>>10,56320|1023&n)};try{q.call(w.documentElement.childNodes,0)[0].nodeType}catch(nt){q=function(e){var t,n=[];while(t=this[e++])n.push(t);return n}}function rt(e){return Y.test(e+"")}function it(){var e,t=[];return e=function(n,r){return t.push(n+=" ")>i.cacheLength&&delete e[t.shift()],e[n]=r}}function ot(e){return e[x]=!0,e}function at(e){var t=p.createElement("div");try{return e(t)}catch(n){return!1}finally{t=null}}function st(e,t,n,r){var i,o,a,s,u,l,f,g,m,v;if((t?t.ownerDocument||t:w)!==p&&c(t),t=t||p,n=n||[],!e||"string"!=typeof e)return n;if(1!==(s=t.nodeType)&&9!==s)return[];if(!d&&!r){if(i=J.exec(e))if(a=i[1]){if(9===s){if(o=t.getElementById(a),!o||!o.parentNode)return n;if(o.id===a)return n.push(o),n}else if(t.ownerDocument&&(o=t.ownerDocument.getElementById(a))&&y(t,o)&&o.id===a)return n.push(o),n}else{if(i[2])return H.apply(n,q.call(t.getElementsByTagName(e),0)),n;if((a=i[3])&&T.getByClassName&&t.getElementsByClassName)return H.apply(n,q.call(t.getElementsByClassName(a),0)),n}if(T.qsa&&!h.test(e)){if(f=!0,g=x,m=t,v=9===s&&e,1===s&&"object"!==t.nodeName.toLowerCase()){l=ft(e),(f=t.getAttribute("id"))?g=f.replace(K,"\\$&"):t.setAttribute("id",g),g="[id='"+g+"'] ",u=l.length;while(u--)l[u]=g+dt(l[u]);m=V.test(e)&&t.parentNode||t,v=l.join(",")}if(v)try{return H.apply(n,q.call(m.querySelectorAll(v),0)),n}catch(b){}finally{f||t.removeAttribute("id")}}}return wt(e.replace(W,"$1"),t,n,r)}a=st.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},c=st.setDocument=function(e){var n=e?e.ownerDocument||e:w;return n!==p&&9===n.nodeType&&n.documentElement?(p=n,f=n.documentElement,d=a(n),T.tagNameNoComments=at(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),T.attributes=at(function(e){e.innerHTML="<select></select>";var t=typeof e.lastChild.getAttribute("multiple");return"boolean"!==t&&"string"!==t}),T.getByClassName=at(function(e){return e.innerHTML="<div class='hidden e'></div><div class='hidden'></div>",e.getElementsByClassName&&e.getElementsByClassName("e").length?(e.lastChild.className="e",2===e.getElementsByClassName("e").length):!1}),T.getByName=at(function(e){e.id=x+0,e.innerHTML="<a name='"+x+"'></a><div name='"+x+"'></div>",f.insertBefore(e,f.firstChild);var t=n.getElementsByName&&n.getElementsByName(x).length===2+n.getElementsByName(x+0).length;return T.getIdNotName=!n.getElementById(x),f.removeChild(e),t}),i.attrHandle=at(function(e){return e.innerHTML="<a href='#'></a>",e.firstChild&&typeof e.firstChild.getAttribute!==A&&"#"===e.firstChild.getAttribute("href")})?{}:{href:function(e){return e.getAttribute("href",2)},type:function(e){return e.getAttribute("type")}},T.getIdNotName?(i.find.ID=function(e,t){if(typeof t.getElementById!==A&&!d){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},i.filter.ID=function(e){var t=e.replace(et,tt);return function(e){return e.getAttribute("id")===t}}):(i.find.ID=function(e,n){if(typeof n.getElementById!==A&&!d){var r=n.getElementById(e);return r?r.id===e||typeof r.getAttributeNode!==A&&r.getAttributeNode("id").value===e?[r]:t:[]}},i.filter.ID=function(e){var t=e.replace(et,tt);return function(e){var n=typeof e.getAttributeNode!==A&&e.getAttributeNode("id");return n&&n.value===t}}),i.find.TAG=T.tagNameNoComments?function(e,n){return typeof n.getElementsByTagName!==A?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},i.find.NAME=T.getByName&&function(e,n){return typeof n.getElementsByName!==A?n.getElementsByName(name):t},i.find.CLASS=T.getByClassName&&function(e,n){return typeof n.getElementsByClassName===A||d?t:n.getElementsByClassName(e)},g=[],h=[":focus"],(T.qsa=rt(n.querySelectorAll))&&(at(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||h.push("\\["+_+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)"),e.querySelectorAll(":checked").length||h.push(":checked")}),at(function(e){e.innerHTML="<input type='hidden' i=''/>",e.querySelectorAll("[i^='']").length&&h.push("[*^$]="+_+"*(?:\"\"|'')"),e.querySelectorAll(":enabled").length||h.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),h.push(",.*:")})),(T.matchesSelector=rt(m=f.matchesSelector||f.mozMatchesSelector||f.webkitMatchesSelector||f.oMatchesSelector||f.msMatchesSelector))&&at(function(e){T.disconnectedMatch=m.call(e,"div"),m.call(e,"[s!='']:x"),g.push("!=",R)}),h=RegExp(h.join("|")),g=RegExp(g.join("|")),y=rt(f.contains)||f.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},v=f.compareDocumentPosition?function(e,t){var r;return e===t?(u=!0,0):(r=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t))?1&r||e.parentNode&&11===e.parentNode.nodeType?e===n||y(w,e)?-1:t===n||y(w,t)?1:0:4&r?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return u=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:0;if(o===a)return ut(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?ut(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},u=!1,[0,0].sort(v),T.detectDuplicates=u,p):p},st.matches=function(e,t){return st(e,null,null,t)},st.matchesSelector=function(e,t){if((e.ownerDocument||e)!==p&&c(e),t=t.replace(Z,"='$1']"),!(!T.matchesSelector||d||g&&g.test(t)||h.test(t)))try{var n=m.call(e,t);if(n||T.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(r){}return st(t,p,null,[e]).length>0},st.contains=function(e,t){return(e.ownerDocument||e)!==p&&c(e),y(e,t)},st.attr=function(e,t){var n;return(e.ownerDocument||e)!==p&&c(e),d||(t=t.toLowerCase()),(n=i.attrHandle[t])?n(e):d||T.attributes?e.getAttribute(t):((n=e.getAttributeNode(t))||e.getAttribute(t))&&e[t]===!0?t:n&&n.specified?n.value:null},st.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},st.uniqueSort=function(e){var t,n=[],r=1,i=0;if(u=!T.detectDuplicates,e.sort(v),u){for(;t=e[r];r++)t===e[r-1]&&(i=n.push(r));while(i--)e.splice(n[i],1)}return e};function ut(e,t){var n=t&&e,r=n&&(~t.sourceIndex||j)-(~e.sourceIndex||j);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function lt(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function ct(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function pt(e){return ot(function(t){return t=+t,ot(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}o=st.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=o(t);return n},i=st.selectors={cacheLength:50,createPseudo:ot,match:U,find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(et,tt),e[3]=(e[4]||e[5]||"").replace(et,tt),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||st.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&st.error(e[0]),e},PSEUDO:function(e){var t,n=!e[5]&&e[2];return U.CHILD.test(e[0])?null:(e[4]?e[2]=e[4]:n&&z.test(n)&&(t=ft(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){return"*"===e?function(){return!0}:(e=e.replace(et,tt).toLowerCase(),function(t){return t.nodeName&&t.nodeName.toLowerCase()===e})},CLASS:function(e){var t=k[e+" "];return t||(t=RegExp("(^|"+_+")"+e+"("+_+"|$)"))&&k(e,function(e){return t.test(e.className||typeof e.getAttribute!==A&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=st.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,p,f,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!u&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[x]||(m[x]={}),l=c[e]||[],d=l[0]===N&&l[1],f=l[0]===N&&l[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[N,d,f];break}}else if(v&&(l=(t[x]||(t[x]={}))[e])&&l[0]===N)f=l[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[x]||(p[x]={}))[e]=[N,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=i.pseudos[e]||i.setFilters[e.toLowerCase()]||st.error("unsupported pseudo: "+e);return r[x]?r(t):r.length>1?(n=[e,e,"",t],i.setFilters.hasOwnProperty(e.toLowerCase())?ot(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=M.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:ot(function(e){var t=[],n=[],r=s(e.replace(W,"$1"));return r[x]?ot(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:ot(function(e){return function(t){return st(e,t).length>0}}),contains:ot(function(e){return function(t){return(t.textContent||t.innerText||o(t)).indexOf(e)>-1}}),lang:ot(function(e){return X.test(e||"")||st.error("unsupported lang: "+e),e=e.replace(et,tt).toLowerCase(),function(t){var n;do if(n=d?t.getAttribute("xml:lang")||t.getAttribute("lang"):t.lang)return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===f},focus:function(e){return e===p.activeElement&&(!p.hasFocus||p.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!i.pseudos.empty(e)},header:function(e){return Q.test(e.nodeName)},input:function(e){return G.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:pt(function(){return[0]}),last:pt(function(e,t){return[t-1]}),eq:pt(function(e,t,n){return[0>n?n+t:n]}),even:pt(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:pt(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:pt(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:pt(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}};for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})i.pseudos[n]=lt(n);for(n in{submit:!0,reset:!0})i.pseudos[n]=ct(n);function ft(e,t){var n,r,o,a,s,u,l,c=E[e+" "];if(c)return t?0:c.slice(0);s=e,u=[],l=i.preFilter;while(s){(!n||(r=$.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),u.push(o=[])),n=!1,(r=I.exec(s))&&(n=r.shift(),o.push({value:n,type:r[0].replace(W," ")}),s=s.slice(n.length));for(a in i.filter)!(r=U[a].exec(s))||l[a]&&!(r=l[a](r))||(n=r.shift(),o.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?st.error(e):E(e,u).slice(0)}function dt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function ht(e,t,n){var i=t.dir,o=n&&"parentNode"===i,a=C++;return t.first?function(t,n,r){while(t=t[i])if(1===t.nodeType||o)return e(t,n,r)}:function(t,n,s){var u,l,c,p=N+" "+a;if(s){while(t=t[i])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[i])if(1===t.nodeType||o)if(c=t[x]||(t[x]={}),(l=c[i])&&l[0]===p){if((u=l[1])===!0||u===r)return u===!0}else if(l=c[i]=[p],l[1]=e(t,n,s)||r,l[1]===!0)return!0}}function gt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function mt(e,t,n,r,i){var o,a=[],s=0,u=e.length,l=null!=t;for(;u>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),l&&t.push(s));return a}function yt(e,t,n,r,i,o){return r&&!r[x]&&(r=yt(r)),i&&!i[x]&&(i=yt(i,o)),ot(function(o,a,s,u){var l,c,p,f=[],d=[],h=a.length,g=o||xt(t||"*",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:mt(g,f,e,s,u),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,u),r){l=mt(y,d),r(l,[],s,u),c=l.length;while(c--)(p=l[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){l=[],c=y.length;while(c--)(p=y[c])&&l.push(m[c]=p);i(null,y=[],l,u)}c=y.length;while(c--)(p=y[c])&&(l=i?M.call(o,p):f[c])>-1&&(o[l]=!(a[l]=p))}}else y=mt(y===a?y.splice(h,y.length):y),i?i(null,a,y,u):H.apply(a,y)})}function vt(e){var t,n,r,o=e.length,a=i.relative[e[0].type],s=a||i.relative[" "],u=a?1:0,c=ht(function(e){return e===t},s,!0),p=ht(function(e){return M.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==l)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;o>u;u++)if(n=i.relative[e[u].type])f=[ht(gt(f),n)];else{if(n=i.filter[e[u].type].apply(null,e[u].matches),n[x]){for(r=++u;o>r;r++)if(i.relative[e[r].type])break;return yt(u>1&&gt(f),u>1&&dt(e.slice(0,u-1)).replace(W,"$1"),n,r>u&&vt(e.slice(u,r)),o>r&&vt(e=e.slice(r)),o>r&&dt(e))}f.push(n)}return gt(f)}function bt(e,t){var n=0,o=t.length>0,a=e.length>0,s=function(s,u,c,f,d){var h,g,m,y=[],v=0,b="0",x=s&&[],w=null!=d,T=l,C=s||a&&i.find.TAG("*",d&&u.parentNode||u),k=N+=null==T?1:Math.random()||.1;for(w&&(l=u!==p&&u,r=n);null!=(h=C[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,u,c)){f.push(h);break}w&&(N=k,r=++n)}o&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,o&&b!==v){g=0;while(m=t[g++])m(x,y,u,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=L.call(f));y=mt(y)}H.apply(f,y),w&&!s&&y.length>0&&v+t.length>1&&st.uniqueSort(f)}return w&&(N=k,l=T),x};return o?ot(s):s}s=st.compile=function(e,t){var n,r=[],i=[],o=S[e+" "];if(!o){t||(t=ft(e)),n=t.length;while(n--)o=vt(t[n]),o[x]?r.push(o):i.push(o);o=S(e,bt(i,r))}return o};function xt(e,t,n){var r=0,i=t.length;for(;i>r;r++)st(e,t[r],n);return n}function wt(e,t,n,r){var o,a,u,l,c,p=ft(e);if(!r&&1===p.length){if(a=p[0]=p[0].slice(0),a.length>2&&"ID"===(u=a[0]).type&&9===t.nodeType&&!d&&i.relative[a[1].type]){if(t=i.find.ID(u.matches[0].replace(et,tt),t)[0],!t)return n;e=e.slice(a.shift().value.length)}o=U.needsContext.test(e)?0:a.length;while(o--){if(u=a[o],i.relative[l=u.type])break;if((c=i.find[l])&&(r=c(u.matches[0].replace(et,tt),V.test(a[0].type)&&t.parentNode||t))){if(a.splice(o,1),e=r.length&&dt(a),!e)return H.apply(n,q.call(r,0)),n;break}}}return s(e,p)(r,t,d,n,V.test(e)),n}i.pseudos.nth=i.pseudos.eq;function Tt(){}i.filters=Tt.prototype=i.pseudos,i.setFilters=new Tt,c(),st.attr=b.attr,b.find=st,b.expr=st.selectors,b.expr[":"]=b.expr.pseudos,b.unique=st.uniqueSort,b.text=st.getText,b.isXMLDoc=st.isXML,b.contains=st.contains}(e);var at=/Until$/,st=/^(?:parents|prev(?:Until|All))/,ut=/^.[^:#\[\.,]*$/,lt=b.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};b.fn.extend({find:function(e){var t,n,r,i=this.length;if("string"!=typeof e)return r=this,this.pushStack(b(e).filter(function(){for(t=0;i>t;t++)if(b.contains(r[t],this))return!0}));for(n=[],t=0;i>t;t++)b.find(e,this[t],n);return n=this.pushStack(i>1?b.unique(n):n),n.selector=(this.selector?this.selector+" ":"")+e,n},has:function(e){var t,n=b(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(b.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e,!1))},filter:function(e){return this.pushStack(ft(this,e,!0))},is:function(e){return!!e&&("string"==typeof e?lt.test(e)?b(e,this.context).index(this[0])>=0:b.filter(e,this).length>0:this.filter(e).length>0)},closest:function(e,t){var n,r=0,i=this.length,o=[],a=lt.test(e)||"string"!=typeof e?b(e,t||this.context):0;for(;i>r;r++){n=this[r];while(n&&n.ownerDocument&&n!==t&&11!==n.nodeType){if(a?a.index(n)>-1:b.find.matchesSelector(n,e)){o.push(n);break}n=n.parentNode}}return this.pushStack(o.length>1?b.unique(o):o)},index:function(e){return e?"string"==typeof e?b.inArray(this[0],b(e)):b.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?b(e,t):b.makeArray(e&&e.nodeType?[e]:e),r=b.merge(this.get(),n);return this.pushStack(b.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),b.fn.andSelf=b.fn.addBack;function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}b.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return b.dir(e,"parentNode")},parentsUntil:function(e,t,n){return b.dir(e,"parentNode",n)},next:function(e){return pt(e,"nextSibling")},prev:function(e){return pt(e,"previousSibling")},nextAll:function(e){return b.dir(e,"nextSibling")},prevAll:function(e){return b.dir(e,"previousSibling")},nextUntil:function(e,t,n){return b.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return b.dir(e,"previousSibling",n)},siblings:function(e){return b.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return b.sibling(e.firstChild)},contents:function(e){return b.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:b.merge([],e.childNodes)}},function(e,t){b.fn[e]=function(n,r){var i=b.map(this,t,n);return at.test(e)||(r=n),r&&"string"==typeof r&&(i=b.filter(r,i)),i=this.length>1&&!ct[e]?b.unique(i):i,this.length>1&&st.test(e)&&(i=i.reverse()),this.pushStack(i)}}),b.extend({filter:function(e,t,n){return n&&(e=":not("+e+")"),1===t.length?b.find.matchesSelector(t[0],e)?[t[0]]:[]:b.find.matches(e,t)},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!b(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(t=t||0,b.isFunction(t))return b.grep(e,function(e,r){var i=!!t.call(e,r,e);return i===n});if(t.nodeType)return b.grep(e,function(e){return e===t===n});if("string"==typeof t){var r=b.grep(e,function(e){return 1===e.nodeType});if(ut.test(t))return b.filter(t,r,!n);t=b.filter(t,r)}return b.grep(e,function(e){return b.inArray(e,t)>=0===n})}function dt(e){var t=ht.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gt=/ jQuery\d+="(?:null|\d+)"/g,mt=RegExp("<(?:"+ht+")[\\s/>]","i"),yt=/^\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bt=/<([\w:]+)/,xt=/<tbody/i,wt=/<|&#?\w+;/,Tt=/<(?:script|style|link)/i,Nt=/^(?:checkbox|radio)$/i,Ct=/checked\s*(?:[^=]|=\s*.checked.)/i,kt=/^$|\/(?:java|ecma)script/i,Et=/^true\/(.*)/,St=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,At={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:b.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},jt=dt(o),Dt=jt.appendChild(o.createElement("div"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,b.fn.extend({text:function(e){return b.access(this,function(e){return e===t?b.text(this):this.empty().append((this[0]&&this[0].ownerDocument||o).createTextNode(e))},null,e,arguments.length)},wrapAll:function(e){if(b.isFunction(e))return this.each(function(t){b(this).wrapAll(e.call(this,t))});if(this[0]){var t=b(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return b.isFunction(e)?this.each(function(t){b(this).wrapInner(e.call(this,t))}):this.each(function(){var t=b(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=b.isFunction(e);return this.each(function(n){b(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){b.nodeName(this,"body")||b(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(e){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&this.appendChild(e)})},prepend:function(){return this.domManip(arguments,!0,function(e){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&this.insertBefore(e,this.firstChild)})},before:function(){return this.domManip(arguments,!1,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,!1,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=0;for(;null!=(n=this[r]);r++)(!e||b.filter(e,[n]).length>0)&&(t||1!==n.nodeType||b.cleanData(Ot(n)),n.parentNode&&(t&&b.contains(n.ownerDocument,n)&&Mt(Ot(n,"script")),n.parentNode.removeChild(n)));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&b.cleanData(Ot(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&b.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return b.clone(this,e,t)})},html:function(e){return b.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,""):t;if(!("string"!=typeof e||Tt.test(e)||!b.support.htmlSerialize&&mt.test(e)||!b.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(vt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(b.cleanData(Ot(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(e){var t=b.isFunction(e);return t||"string"==typeof e||(e=b(e).not(this).detach()),this.domManip([e],!0,function(e){var t=this.nextSibling,n=this.parentNode;n&&(b(this).remove(),n.insertBefore(e,t))})},detach:function(e){return this.remove(e,!0)},domManip:function(e,n,r){e=f.apply([],e);var i,o,a,s,u,l,c=0,p=this.length,d=this,h=p-1,g=e[0],m=b.isFunction(g);if(m||!(1>=p||"string"!=typeof g||b.support.checkClone)&&Ct.test(g))return this.each(function(i){var o=d.eq(i);m&&(e[0]=g.call(this,i,n?o.html():t)),o.domManip(e,n,r)});if(p&&(l=b.buildFragment(e,this[0].ownerDocument,!1,this),i=l.firstChild,1===l.childNodes.length&&(l=i),i)){for(n=n&&b.nodeName(i,"tr"),s=b.map(Ot(l,"script"),Ht),a=s.length;p>c;c++)o=l,c!==h&&(o=b.clone(o,!0,!0),a&&b.merge(s,Ot(o,"script"))),r.call(n&&b.nodeName(this[c],"table")?Lt(this[c],"tbody"):this[c],o,c);if(a)for(u=s[s.length-1].ownerDocument,b.map(s,qt),c=0;a>c;c++)o=s[c],kt.test(o.type||"")&&!b._data(o,"globalEval")&&b.contains(u,o)&&(o.src?b.ajax({url:o.src,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0}):b.globalEval((o.text||o.textContent||o.innerHTML||"").replace(St,"")));l=i=null}return this}});function Lt(e,t){return e.getElementsByTagName(t)[0]||e.appendChild(e.ownerDocument.createElement(t))}function Ht(e){var t=e.getAttributeNode("type");return e.type=(t&&t.specified)+"/"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function Mt(e,t){var n,r=0;for(;null!=(n=e[r]);r++)b._data(n,"globalEval",!t||b._data(t[r],"globalEval"))}function _t(e,t){if(1===t.nodeType&&b.hasData(e)){var n,r,i,o=b._data(e),a=b._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)b.event.add(t,n,s[n][r])}a.data&&(a.data=b.extend({},a.data))}}function Ft(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!b.support.noCloneEvent&&t[b.expando]){i=b._data(t);for(r in i.events)b.removeEvent(t,r,i.handle);t.removeAttribute(b.expando)}"script"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),b.support.html5Clone&&e.innerHTML&&!b.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Nt.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}b.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){b.fn[e]=function(e){var n,r=0,i=[],o=b(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),b(o[r])[t](n),d.apply(i,n.get());return this.pushStack(i)}});function Ot(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||b.nodeName(o,n)?s.push(o):b.merge(s,Ot(o,n));return n===t||n&&b.nodeName(e,n)?b.merge([e],s):s}function Bt(e){Nt.test(e.type)&&(e.defaultChecked=e.checked)}b.extend({clone:function(e,t,n){var r,i,o,a,s,u=b.contains(e.ownerDocument,e);if(b.support.html5Clone||b.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(b.support.noCloneEvent&&b.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||b.isXMLDoc(e)))for(r=Ot(o),s=Ot(e),a=0;null!=(i=s[a]);++a)r[a]&&Ft(i,r[a]);if(t)if(n)for(s=s||Ot(e),r=r||Ot(o),a=0;null!=(i=s[a]);a++)_t(i,r[a]);else _t(e,o);return r=Ot(o,"script"),r.length>0&&Mt(r,!u&&Ot(e,"script")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,u,l,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if("object"===b.type(o))b.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement("div")),u=(bt.exec(o)||["",""])[1].toLowerCase(),c=At[u]||At._default,s.innerHTML=c[1]+o.replace(vt,"<$1></$2>")+c[2],i=c[0];while(i--)s=s.lastChild;if(!b.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!b.support.tbody){o="table"!==u||xt.test(o)?"<table>"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)b.nodeName(l=o.childNodes[i],"tbody")&&!l.childNodes.length&&o.removeChild(l)
}b.merge(d,s.childNodes),s.textContent="";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),b.support.appendChecked||b.grep(Ot(d,"input"),Bt),h=0;while(o=d[h++])if((!r||-1===b.inArray(o,r))&&(a=b.contains(o.ownerDocument,o),s=Ot(f.appendChild(o),"script"),a&&Mt(s),n)){i=0;while(o=s[i++])kt.test(o.type||"")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,u=b.expando,l=b.cache,p=b.support.deleteExpando,f=b.event.special;for(;null!=(n=e[s]);s++)if((t||b.acceptData(n))&&(o=n[u],a=o&&l[o])){if(a.events)for(r in a.events)f[r]?b.event.remove(n,r):b.removeEvent(n,r,a.handle);l[o]&&(delete l[o],p?delete n[u]:typeof n.removeAttribute!==i?n.removeAttribute(u):n[u]=null,c.push(o))}}});var Pt,Rt,Wt,$t=/alpha\([^)]*\)/i,It=/opacity\s*=\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp("^("+x+")(.*)$","i"),Yt=RegExp("^("+x+")(?!px)[a-z%]+$","i"),Jt=RegExp("^([+-])=("+x+")","i"),Gt={BODY:"block"},Qt={position:"absolute",visibility:"hidden",display:"block"},Kt={letterSpacing:0,fontWeight:400},Zt=["Top","Right","Bottom","Left"],en=["Webkit","O","Moz","ms"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,"none"===b.css(e,"display")||!b.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=b._data(r,"olddisplay"),n=r.style.display,t?(o[a]||"none"!==n||(r.style.display=""),""===r.style.display&&nn(r)&&(o[a]=b._data(r,"olddisplay",un(r.nodeName)))):o[a]||(i=nn(r),(n&&"none"!==n||!i)&&b._data(r,"olddisplay",i?n:b.css(r,"display"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[a]||"":"none"));return e}b.fn.extend({css:function(e,n){return b.access(this,function(e,n,r){var i,o,a={},s=0;if(b.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=b.css(e,n[s],!1,o);return a}return r!==t?b.style(e,n,r):b.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){var t="boolean"==typeof e;return this.each(function(){(t?e:nn(this))?b(this).show():b(this).hide()})}}),b.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":b.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,u=b.camelCase(n),l=e.style;if(n=b.cssProps[u]||(b.cssProps[u]=tn(l,u)),s=b.cssHooks[n]||b.cssHooks[u],r===t)return s&&"get"in s&&(o=s.get(e,!1,i))!==t?o:l[n];if(a=typeof r,"string"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(b.css(e,n)),a="number"),!(null==r||"number"===a&&isNaN(r)||("number"!==a||b.cssNumber[u]||(r+="px"),b.support.clearCloneStyle||""!==r||0!==n.indexOf("background")||(l[n]="inherit"),s&&"set"in s&&(r=s.set(e,r,i))===t)))try{l[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,u=b.camelCase(n);return n=b.cssProps[u]||(b.cssProps[u]=tn(e.style,u)),s=b.cssHooks[n]||b.cssHooks[u],s&&"get"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),"normal"===a&&n in Kt&&(a=Kt[n]),""===r||r?(o=parseFloat(a),r===!0||b.isNumeric(o)?o||0:a):a},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),u=s?s.getPropertyValue(n)||s[n]:t,l=e.style;return s&&(""!==u||b.contains(e.ownerDocument,e)||(u=b.style(e,n)),Yt.test(u)&&Ut.test(n)&&(i=l.width,o=l.minWidth,a=l.maxWidth,l.minWidth=l.maxWidth=l.width=u,u=s.width,l.width=i,l.minWidth=o,l.maxWidth=a)),u}):o.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),u=s?s[n]:t,l=e.style;return null==u&&l&&l[n]&&(u=l[n]),Yt.test(u)&&!zt.test(n)&&(i=l.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),l.left="fontSize"===n?"1em":u,u=l.pixelLeft+"px",l.left=i,a&&(o.left=a)),""===u?"auto":u});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function an(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;for(;4>o;o+=2)"margin"===n&&(a+=b.css(e,n+Zt[o],!0,i)),r?("content"===n&&(a-=b.css(e,"padding"+Zt[o],!0,i)),"margin"!==n&&(a-=b.css(e,"border"+Zt[o]+"Width",!0,i))):(a+=b.css(e,"padding"+Zt[o],!0,i),"padding"!==n&&(a+=b.css(e,"border"+Zt[o]+"Width",!0,i)));return a}function sn(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=b.support.boxSizing&&"border-box"===b.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(b.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?"border":"content"),r,o)+"px"}function un(e){var t=o,n=Gt[e];return n||(n=ln(e,t),"none"!==n&&n||(Pt=(Pt||b("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=ln(e,t),Pt.detach()),Gt[e]=n),n}function ln(e,t){var n=b(t.createElement(e)).appendTo(t.body),r=b.css(n[0],"display");return n.remove(),r}b.each(["height","width"],function(e,n){b.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(b.css(e,"display"))?b.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,b.support.boxSizing&&"border-box"===b.css(e,"boxSizing",!1,i),i):0)}}}),b.support.opacity||(b.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=b.isNumeric(t)?"alpha(opacity="+100*t+")":"",o=r&&r.filter||n.filter||"";n.zoom=1,(t>=1||""===t)&&""===b.trim(o.replace($t,""))&&n.removeAttribute&&(n.removeAttribute("filter"),""===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+" "+i)}}),b(function(){b.support.reliableMarginRight||(b.cssHooks.marginRight={get:function(e,n){return n?b.swap(e,{display:"inline-block"},Wt,[e,"marginRight"]):t}}),!b.support.pixelPosition&&b.fn.position&&b.each(["top","left"],function(e,n){b.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?b(e).position()[n]+"px":r):t}}})}),b.expr&&b.expr.filters&&(b.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!b.support.reliableHiddenOffsets&&"none"===(e.style&&e.style.display||b.css(e,"display"))},b.expr.filters.visible=function(e){return!b.expr.filters.hidden(e)}),b.each({margin:"",padding:"",border:"Width"},function(e,t){b.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(b.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\[\]$/,fn=/\r?\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;b.fn.extend({serialize:function(){return b.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=b.prop(this,"elements");return e?b.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!b(this).is(":disabled")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Nt.test(e))}).map(function(e,t){var n=b(this).val();return null==n?null:b.isArray(n)?b.map(n,function(e){return{name:t.name,value:e.replace(fn,"\r\n")}}):{name:t.name,value:n.replace(fn,"\r\n")}}).get()}}),b.param=function(e,n){var r,i=[],o=function(e,t){t=b.isFunction(t)?t():null==t?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(n===t&&(n=b.ajaxSettings&&b.ajaxSettings.traditional),b.isArray(e)||e.jquery&&!b.isPlainObject(e))b.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join("&").replace(cn,"+")};function gn(e,t,n,r){var i;if(b.isArray(t))b.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==b.type(t))r(e,t);else for(i in t)gn(e+"["+i+"]",t[i],n,r)}b.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){b.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),b.fn.hover=function(e,t){return this.mouseenter(e).mouseleave(t||e)};var mn,yn,vn=b.now(),bn=/\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Nn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Cn=/^(?:GET|HEAD)$/,kn=/^\/\//,En=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,Sn=b.fn.load,An={},jn={},Dn="*/".concat("*");try{yn=a.href}catch(Ln){yn=o.createElement("a"),yn.href="",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(w)||[];if(b.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(u){var l;return o[u]=!0,b.each(e[u]||[],function(e,u){var c=u(n,r,i);return"string"!=typeof c||a||o[c]?a?!(l=c):t:(n.dataTypes.unshift(c),s(c),!1)}),l}return s(n.dataTypes[0])||!o["*"]&&s("*")}function Mn(e,n){var r,i,o=b.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&b.extend(!0,e,r),e}b.fn.load=function(e,n,r){if("string"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,u=e.indexOf(" ");return u>=0&&(i=e.slice(u,e.length),e=e.slice(0,u)),b.isFunction(n)?(r=n,n=t):n&&"object"==typeof n&&(a="POST"),s.length>0&&b.ajax({url:e,type:a,dataType:"html",data:n}).done(function(e){o=arguments,s.html(i?b("<div>").append(b.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},b.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){b.fn[t]=function(e){return this.on(t,e)}}),b.each(["get","post"],function(e,n){b[n]=function(e,r,i,o){return b.isFunction(r)&&(o=o||i,i=r,r=t),b.ajax({url:e,type:n,dataType:o,data:r,success:i})}}),b.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:"GET",isLocal:Nn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Dn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":e.String,"text html":!0,"text json":b.parseJSON,"text xml":b.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Mn(Mn(e,b.ajaxSettings),t):Mn(b.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){"object"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,u,l,c,p=b.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?b(f):b.event,h=b.Deferred(),g=b.Callbacks("once memory"),m=p.statusCode||{},y={},v={},x=0,T="canceled",N={readyState:0,getResponseHeader:function(e){var t;if(2===x){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===x?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return x||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return x||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>x)for(t in e)m[t]=[m[t],e[t]];else N.always(e[N.status]);return this},abort:function(e){var t=e||T;return l&&l.abort(t),k(0,t),this}};if(h.promise(N).complete=g.add,N.success=N.done,N.error=N.fail,p.url=((e||p.url||yn)+"").replace(xn,"").replace(kn,mn[1]+"//"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=b.trim(p.dataType||"*").toLowerCase().match(w)||[""],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||("http:"===r[1]?80:443))==(mn[3]||("http:"===mn[1]?80:443)))),p.data&&p.processData&&"string"!=typeof p.data&&(p.data=b.param(p.data,p.traditional)),qn(An,p,n,N),2===x)return N;u=p.global,u&&0===b.active++&&b.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!Cn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?"&":"?")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,"$1_="+vn++):o+(bn.test(o)?"&":"?")+"_="+vn++)),p.ifModified&&(b.lastModified[o]&&N.setRequestHeader("If-Modified-Since",b.lastModified[o]),b.etag[o]&&N.setRequestHeader("If-None-Match",b.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&N.setRequestHeader("Content-Type",p.contentType),N.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+Dn+"; q=0.01":""):p.accepts["*"]);for(i in p.headers)N.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,N,p)===!1||2===x))return N.abort();T="abort";for(i in{success:1,error:1,complete:1})N[i](p[i]);if(l=qn(jn,p,n,N)){N.readyState=1,u&&d.trigger("ajaxSend",[N,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){N.abort("timeout")},p.timeout));try{x=1,l.send(y,k)}catch(C){if(!(2>x))throw C;k(-1,C)}}else k(-1,"No Transport");function k(e,n,r,i){var c,y,v,w,T,C=n;2!==x&&(x=2,s&&clearTimeout(s),l=t,a=i||"",N.readyState=e>0?4:0,r&&(w=_n(p,N,r)),e>=200&&300>e||304===e?(p.ifModified&&(T=N.getResponseHeader("Last-Modified"),T&&(b.lastModified[o]=T),T=N.getResponseHeader("etag"),T&&(b.etag[o]=T)),204===e?(c=!0,C="nocontent"):304===e?(c=!0,C="notmodified"):(c=Fn(p,w),C=c.state,y=c.data,v=c.error,c=!v)):(v=C,(e||!C)&&(C="error",0>e&&(e=0))),N.status=e,N.statusText=(n||C)+"",c?h.resolveWith(f,[y,C,N]):h.rejectWith(f,[N,C,v]),N.statusCode(m),m=t,u&&d.trigger(c?"ajaxSuccess":"ajaxError",[N,p,c?y:v]),g.fireWith(f,[N,C]),u&&(d.trigger("ajaxComplete",[N,p]),--b.active||b.event.trigger("ajaxStop")))}return N},getScript:function(e,n){return b.get(e,t,n,"script")},getJSON:function(e,t,n){return b.get(e,t,n,"json")}});function _n(e,n,r){var i,o,a,s,u=e.contents,l=e.dataTypes,c=e.responseFields;for(s in c)s in r&&(n[c[s]]=r[s]);while("*"===l[0])l.shift(),o===t&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(s in u)if(u[s]&&u[s].test(o)){l.unshift(s);break}if(l[0]in r)a=l[0];else{for(s in r){if(!l[0]||e.converters[s+" "+l[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==l[0]&&l.unshift(a),r[a]):t}function Fn(e,t){var n,r,i,o,a={},s=0,u=e.dataTypes.slice(),l=u[0];if(e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u[1])for(i in e.converters)a[i.toLowerCase()]=e.converters[i];for(;r=u[++s];)if("*"!==r){if("*"!==l&&l!==r){if(i=a[l+" "+r]||a["* "+r],!i)for(n in a)if(o=n.split(" "),o[1]===r&&(i=a[l+" "+o[0]]||a["* "+o[0]])){i===!0?i=a[n]:a[n]!==!0&&(r=o[0],u.splice(s--,0,r));break}if(i!==!0)if(i&&e["throws"])t=i(t);else try{t=i(t)}catch(c){return{state:"parsererror",error:i?c:"No conversion from "+l+" to "+r}}}l=r}return{state:"success",data:t}}b.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return b.globalEval(e),e}}}),b.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),b.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=o.head||b("head")[0]||o.documentElement;return{send:function(t,i){n=o.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var On=[],Bn=/(=)\?(?=&|$)|\?\?/;b.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=On.pop()||b.expando+"_"+vn++;return this[e]=!0,e}}),b.ajaxPrefilter("json jsonp",function(n,r,i){var o,a,s,u=n.jsonp!==!1&&(Bn.test(n.url)?"url":"string"==typeof n.data&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Bn.test(n.data)&&"data");return u||"jsonp"===n.dataTypes[0]?(o=n.jsonpCallback=b.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,u?n[u]=n[u].replace(Bn,"$1"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?"&":"?")+n.jsonp+"="+o),n.converters["script json"]=function(){return s||b.error(o+" was not called"),s[0]},n.dataTypes[0]="json",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,On.push(o)),s&&b.isFunction(a)&&a(s[0]),s=a=t}),"script"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}b.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=b.ajaxSettings.xhr(),b.support.cors=!!Rn&&"withCredentials"in Rn,Rn=b.support.ajax=!!Rn,Rn&&b.ajaxTransport(function(n){if(!n.crossDomain||b.support.cors){var r;return{send:function(i,o){var a,s,u=n.xhr();if(n.username?u.open(n.type,n.url,n.async,n.username,n.password):u.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)u[s]=n.xhrFields[s];n.mimeType&&u.overrideMimeType&&u.overrideMimeType(n.mimeType),n.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");try{for(s in i)u.setRequestHeader(s,i[s])}catch(l){}u.send(n.hasContent&&n.data||null),r=function(e,i){var s,l,c,p;try{if(r&&(i||4===u.readyState))if(r=t,a&&(u.onreadystatechange=b.noop,$n&&delete Pn[a]),i)4!==u.readyState&&u.abort();else{p={},s=u.status,l=u.getAllResponseHeaders(),"string"==typeof u.responseText&&(p.text=u.responseText);try{c=u.statusText}catch(f){c=""}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,l)},n.async?4===u.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},b(e).unload($n)),Pn[a]=r),u.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp("^(?:([+-])=|)("+x+")([a-z%]*)$","i"),Jn=/queueHooks$/,Gn=[nr],Qn={"*":[function(e,t){var n,r,i=this.createTween(e,t),o=Yn.exec(t),a=i.cur(),s=+a||0,u=1,l=20;if(o){if(n=+o[2],r=o[3]||(b.cssNumber[e]?"":"px"),"px"!==r&&s){s=b.css(i.elem,e,!0)||n||1;do u=u||".5",s/=u,b.style(i.elem,e,s+r);while(u!==(u=i.cur()/a)&&1!==u&&--l)}i.unit=r,i.start=s,i.end=o[1]?s+(o[1]+1)*n:n}return i}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=b.now()}function Zn(e,t){b.each(t,function(t,n){var r=(Qn[t]||[]).concat(Qn["*"]),i=0,o=r.length;for(;o>i;i++)if(r[i].call(e,t,n))return})}function er(e,t,n){var r,i,o=0,a=Gn.length,s=b.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,l.startTime+l.duration-t),r=n/l.duration||0,o=1-r,a=0,u=l.tweens.length;for(;u>a;a++)l.tweens[a].run(o);return s.notifyWith(e,[l,o,n]),1>o&&u?n:(s.resolveWith(e,[l]),!1)},l=s.promise({elem:e,props:b.extend({},t),opts:b.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=b.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)l.tweens[n].run(1);return t?s.resolveWith(e,[l,t]):s.rejectWith(e,[l,t]),this}}),c=l.props;for(tr(c,l.opts.specialEasing);a>o;o++)if(r=Gn[o].call(l,e,c,l.opts))return r;return Zn(l,c),b.isFunction(l.opts.start)&&l.opts.start.call(e,l),b.fx.timer(b.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always)}function tr(e,t){var n,r,i,o,a;for(i in e)if(r=b.camelCase(i),o=t[r],n=e[i],b.isArray(n)&&(o=n[1],n=e[i]=n[0]),i!==r&&(e[r]=n,delete e[i]),a=b.cssHooks[r],a&&"expand"in a){n=a.expand(n),delete e[r];for(i in n)i in e||(e[i]=n[i],t[i]=o)}else t[r]=o}b.Animation=b.extend(er,{tweener:function(e,t){b.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,u,l,c,p,f=this,d=e.style,h={},g=[],m=e.nodeType&&nn(e);n.queue||(c=b._queueHooks(e,"fx"),null==c.unqueued&&(c.unqueued=0,p=c.empty.fire,c.empty.fire=function(){c.unqueued||p()}),c.unqueued++,f.always(function(){f.always(function(){c.unqueued--,b.queue(e,"fx").length||c.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[d.overflow,d.overflowX,d.overflowY],"inline"===b.css(e,"display")&&"none"===b.css(e,"float")&&(b.support.inlineBlockNeedsLayout&&"inline"!==un(e.nodeName)?d.zoom=1:d.display="inline-block")),n.overflow&&(d.overflow="hidden",b.support.shrinkWrapBlocks||f.always(function(){d.overflow=n.overflow[0],d.overflowX=n.overflow[1],d.overflowY=n.overflow[2]}));for(i in t)if(a=t[i],Vn.exec(a)){if(delete t[i],u=u||"toggle"===a,a===(m?"hide":"show"))continue;g.push(i)}if(o=g.length){s=b._data(e,"fxshow")||b._data(e,"fxshow",{}),"hidden"in s&&(m=s.hidden),u&&(s.hidden=!m),m?b(e).show():f.done(function(){b(e).hide()}),f.done(function(){var t;b._removeData(e,"fxshow");for(t in h)b.style(e,t,h[t])});for(i=0;o>i;i++)r=g[i],l=f.createTween(r,m?s[r]:0),h[r]=s[r]||b.style(e,r),r in s||(s[r]=l.start,m&&(l.end=l.start,l.start="width"===r||"height"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}b.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(b.cssNumber[n]?"":"px")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?b.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=b.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){b.fx.step[e.prop]?b.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[b.cssProps[e.prop]]||b.cssHooks[e.prop])?b.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},b.each(["toggle","show","hide"],function(e,t){var n=b.fn[t];b.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),b.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=b.isEmptyObject(e),o=b.speed(t,n,r),a=function(){var t=er(this,b.extend({},e),o);a.finish=function(){t.stop(!0)},(i||b._data(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return"string"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=null!=e&&e+"queueHooks",o=b.timers,a=b._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&b.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=b._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=b.timers,a=r?r.length:0;for(n.finish=!0,b.queue(this,e,[]),i&&i.cur&&i.cur.finish&&i.cur.finish.call(this),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}b.each({slideDown:ir("show"),slideUp:ir("hide"),slideToggle:ir("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){b.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),b.speed=function(e,t,n){var r=e&&"object"==typeof e?b.extend({},e):{complete:n||!n&&t||b.isFunction(e)&&e,duration:e,easing:n&&t||t&&!b.isFunction(t)&&t};return r.duration=b.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in b.fx.speeds?b.fx.speeds[r.duration]:b.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){b.isFunction(r.old)&&r.old.call(this),r.queue&&b.dequeue(this,r.queue)},r},b.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},b.timers=[],b.fx=rr.prototype.init,b.fx.tick=function(){var e,n=b.timers,r=0;for(Xn=b.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||b.fx.stop(),Xn=t},b.fx.timer=function(e){e()&&b.timers.push(e)&&b.fx.start()},b.fx.interval=13,b.fx.start=function(){Un||(Un=setInterval(b.fx.tick,b.fx.interval))},b.fx.stop=function(){clearInterval(Un),Un=null},b.fx.speeds={slow:600,fast:200,_default:400},b.fx.step={},b.expr&&b.expr.filters&&(b.expr.filters.animated=function(e){return b.grep(b.timers,function(t){return e===t.elem}).length}),b.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){b.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,b.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},b.offset={setOffset:function(e,t,n){var r=b.css(e,"position");"static"===r&&(e.style.position="relative");var i=b(e),o=i.offset(),a=b.css(e,"top"),s=b.css(e,"left"),u=("absolute"===r||"fixed"===r)&&b.inArray("auto",[a,s])>-1,l={},c={},p,f;u?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),b.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(l.top=t.top-o.top+p),null!=t.left&&(l.left=t.left-o.left+f),"using"in t?t.using.call(e,l):i.css(l)}},b.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return"fixed"===b.css(r,"position")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),b.nodeName(e[0],"html")||(n=e.offset()),n.top+=b.css(e[0],"borderTopWidth",!0),n.left+=b.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-b.css(r,"marginTop",!0),left:t.left-n.left-b.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||o.documentElement;while(e&&!b.nodeName(e,"html")&&"static"===b.css(e,"position"))e=e.offsetParent;return e||o.documentElement})}}),b.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);b.fn[e]=function(i){return b.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?b(a).scrollLeft():o,r?o:b(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return b.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}b.each({Height:"height",Width:"width"},function(e,n){b.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){b.fn[i]=function(i,o){var a=arguments.length&&(r||"boolean"!=typeof i),s=r||(i===!0||o===!0?"margin":"border");return b.access(this,function(n,r,i){var o;return b.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body["scroll"+e],o["scroll"+e],n.body["offset"+e],o["offset"+e],o["client"+e])):i===t?b.css(n,r,s):b.style(n,r,i,s)},n,a?i:t,a,null)}})}),e.jQuery=e.$=b,"function"==typeof define&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return b})})(window);;/**
 * JsonRpcClient
 *
 * A JSON RPC Client that uses WebSockets if available otherwise fallbacks to ajax.
 * Depends on JSON, if browser lacks native support either use JSON3 or jquery.json.
 * Usage example:
 *
 *   var foo = new $.JsonRpcClient({ ajaxUrl: '/backend/jsonrpc' });
 *   foo.call(
 *     'bar', [ 'A parameter', 'B parameter' ],
 *     function(result) { alert('Foo bar answered: ' + result.my_answer); },
 *     function(error)  { console.log('There was an error', error); }
 *   );
 *
 * More examples are available in README.md
 */
(function($) {


  /**
   * @fn new
   * @memberof JsonRpcClient
   *
   * @param options An object stating the backends:
   *                ajaxUrl    A url (relative or absolute) to a http(s) backend.
   *                headers    An object that will be passed along to $.ajax in options.headers
   *                xhrFields  An object that will be passed along to $.ajax in options.xhrFields
   *                socketUrl  A url (relative of absolute) to a ws(s) backend.
   *                onmessage  A socket message handler for other messages (non-responses).
   *                onopen     A socket onopen handler. (Not used for custom getSocket.)
   *                onclose    A socket onclose handler. (Not used for custom getSocket.)
   *                onerror    A socket onerror handler. (Not used for custom getSocket.)
   *                getSocket  A function returning a WebSocket or null.
   *                           It must take an onmessage_cb and bind it to the onmessage event
   *                           (or chain it before/after some other onmessage handler).
   *                           Or, it could return null if no socket is available.
   *                           The returned instance must have readyState <= 1, and if less than 1,
   *                           react to onopen binding.
   */
  var JsonRpcClient = function(options) {
    var self = this;
    var noop = function(){};
    this.options = $.extend({
      ajaxUrl     : null,
      headers     : {},   ///< Optional additional headers to send in $.ajax request.
      socketUrl   : null, ///< WebSocket URL. (Not used if a custom getSocket is supplied.)
      onmessage   : noop, ///< Optional onmessage-handler for WebSocket.
      onopen      : noop, ///< Optional onopen-handler for WebSocket.
      onclose     : noop, ///< Optional onclose-handler for WebSocket.
      onerror     : noop, ///< Optional onerror-handler for WebSocket.
      /// Custom socket supplier for using an already existing socket
      getSocket   : function (onmessage_cb) { return self._getSocket(onmessage_cb); }
    }, options);

    // Declare an instance version of the onmessage callback to wrap 'this'.
    this.wsOnMessage = function(event) { self._wsOnMessage(event); };

    //queue for ws request sent *before* ws is open.
    this._ws_request_queue = [];


    if (!window.JSON && $ && $.toJSON) {
      this.JSON = {
        stringify: $.toJSON,
        parse: $.parseJSON
      };
    } else {
      this.JSON = JSON;
    }

  };

  /// Holding the WebSocket on default getsocket.
  JsonRpcClient.prototype._ws_socket = null;

  /// Object <id>: { success_cb: cb, error_cb: cb }
  JsonRpcClient.prototype._ws_callbacks = {};

  /// The next JSON-RPC request id.
  JsonRpcClient.prototype._current_id = 1;

  /**
   * @fn call
   * @memberof JsonRpcClient
   *
   * @param method     The method to run on JSON-RPC server.
   * @param params     The params; an array or object.
   * @param success_cb A callback for successful request.
   * @param error_cb   A callback for error.
   *
   * @return {object} Returns the deferred object that $.ajax returns or {null} if websockets are used
   */
  JsonRpcClient.prototype.call = function(method, params, success_cb, error_cb) {
    success_cb = typeof success_cb === 'function' ? success_cb : function(){};
    error_cb   = typeof error_cb   === 'function' ? error_cb   : function(){};

    // Construct the JSON-RPC 2.0 request.
    var request = {
      jsonrpc : '2.0',
      method  : method,
      params  : params,
      id      : this._current_id++  // Increase the id counter to match request/response
    };

    // Try making a WebSocket call.
    var socket = this.options.getSocket(this.wsOnMessage);
    if (socket !== null) {
      this._wsCall(socket, request, success_cb, error_cb);
      return null;
    }

    // No WebSocket, and no HTTP backend?  This won't work.
    if (this.options.ajaxUrl === null) {
      throw "JsonRpcClient.call used with no websocket and no http endpoint.";
    }

    var self = this;

    var deferred = $.ajax({
      noBlocking: _.get(request, 'params.noBlocking', false),
      type       : 'POST',
      url        : this.options.ajaxUrl,
      contentType: "application/json",
      data       : this.JSON.stringify(request),
      dataType   : 'json',
      cache      : false,
      headers    : this.options.headers,
      xhrFields  : this.options.xhrFields,

      success  : function(data) {
        if ('error' in data) {
          error_cb(data.error);
        }
        else {
          success_cb(data.result);
        }
      },

      // JSON-RPC Server could return non-200 on error
      error    : function(jqXHR, textStatus, errorThrown) {
        try {
          var response = self.JSON.parse(jqXHR.responseText);7
          if ('console' in window) console.log(response);

          error_cb(response.error);
        }
        catch (err) {
          // Perhaps the responseText wasn't really a jsonrpc-error.
          error_cb({ error: jqXHR.responseText });
        }
      }
    });

    return deferred;
  };

  /**
   * Notify sends a command to the server that won't need a response.  In http, there is probably
   * an empty response - that will be dropped, but in ws there should be no response at all.
   *
   * This is very similar to call, but has no id and no handling of callbacks.
   *
   * @fn notify
   * @memberof JsonRpcClient
   *
   * @param method     The method to run on JSON-RPC server.
   * @param params     The params; an array or object.
   *
   * @return {object} Returns the deferred object that $.ajax returns or {null} if websockets are used
   */
  JsonRpcClient.prototype.notify = function(method, params) {
    // Construct the JSON-RPC 2.0 request.
    var request = {
      jsonrpc: '2.0',
      method:  method,
      params:  params
    };

    // Try making a WebSocket call.
    var socket = this.options.getSocket(this.wsOnMessage);
    if (socket !== null) {
      this._wsCall(socket, request);
      return null;
    }

    // No WebSocket, and no HTTP backend?  This won't work.
    if (this.options.ajaxUrl === null) {
      throw "JsonRpcClient.notify used with no websocket and no http endpoint.";
    }

    var deferred = $.ajax({
      noBlocking: _.get(request, 'params.noBlocking', false),
      type       : 'POST',
      url        : this.options.ajaxUrl,
      contentType: "application/json",
      data       : this.JSON.stringify(request),
      dataType   : 'json',
      cache      : false,
      headers    : this.options.headers,
      xhrFields  : this.options.xhrFields
    });

    return deferred;
  };

  /**
   * Make a batch-call by using a callback.
   *
   * The callback will get an object "batch" as only argument.  On batch, you can call the methods
   * "call" and "notify" just as if it was a normal JsonRpcClient object, and all calls will be
   * sent as a batch call then the callback is done.
   *
   * @fn batch
   * @memberof JsonRpcClient
   *
   * @param callback    The main function which will get a batch handler to run call and notify on.
   * @param all_done_cb A callback function to call after all results have been handled.
   * @param error_cb    A callback function to call if there is an error from the server.
   *                    Note, that batch calls should always get an overall success, and the
   *                    only error
   */
  JsonRpcClient.prototype.batch = function(callback, all_done_cb, error_cb) {
    var batch = new JsonRpcClient._batchObject(this, all_done_cb, error_cb);
    callback(batch);
    batch._execute();
  };

  /**
   * The default getSocket handler.
   *
   * @param onmessage_cb The callback to be bound to onmessage events on the socket.
   *
   * @fn _getSocket
   * @memberof JsonRpcClient
   */
  JsonRpcClient.prototype._getSocket = function(onmessage_cb) {
    // If there is no ws url set, we don't have a socket.
    // Likewise, if there is no window.WebSocket.
    if (this.options.socketUrl === null || !("WebSocket" in window)) return null;

    if (this._ws_socket === null || this._ws_socket.readyState > 1) {
      // No socket, or dying socket, let's get a new one.
      this._ws_socket = new WebSocket(this.options.socketUrl);

      // Set up onmessage handler.
      this._ws_socket.onmessage = onmessage_cb;

      // Set up onclose handler.
      this._ws_socket.onclose = this.options.onclose;

      // Set up onerror handler.
      this._ws_socket.onerror = this.options.onerror;
    }

    return this._ws_socket;
  };

  /**
   * Internal handler to dispatch a JRON-RPC request through a websocket.
   *
   * @fn _wsCall
   * @memberof JsonRpcClient
   */
  JsonRpcClient.prototype._wsCall = function(socket, request, success_cb, error_cb) {
    var request_json = this.JSON.stringify(request);

    if (socket.readyState < 1) {

      //queue request
      this._ws_request_queue.push(request_json);

      if (!socket.onopen) {
        // The websocket is not open yet; we have to set sending of the message in onopen.
        var self = this; // In closure below, this is set to the WebSocket.  Use self instead.

        // Set up sending of message for when the socket is open.
        socket.onopen = function(event) {
          // Hook for extra onopen callback
          self.options.onopen(event);

          // Send queued requests.
          for (var i=0; i<self._ws_request_queue.length; i++) {
            socket.send(self._ws_request_queue[i]);
          }
          self._ws_request_queue = [];
        };
      }
    }
    else {
      // We have a socket and it should be ready to send on.
      socket.send(request_json);
    }

    // Setup callbacks.  If there is an id, this is a call and not a notify.
    if ('id' in request && typeof success_cb !== 'undefined') {
      this._ws_callbacks[request.id] = { success_cb: success_cb, error_cb: error_cb };
    }
  };

  /**
   * Internal handler for the websocket messages.  It determines if the message is a JSON-RPC
   * response, and if so, tries to couple it with a given callback.  Otherwise, it falls back to
   * given external onmessage-handler, if any.
   *
   * @param event The websocket onmessage-event.
   */
  JsonRpcClient.prototype._wsOnMessage = function(event) {

    // Check if this could be a JSON RPC message.
    var response;
    try {
      response = this.JSON.parse(event.data);
    } catch (err){
      this.options.onmessage(event);
      return;
    }

    /// @todo Make using the jsonrcp 2.0 check optional, to use this on JSON-RPC 1 backends.
    if (typeof response === 'object'
        && response.jsonrpc === '2.0') {

      /// @todo Handle bad response (without id).

      // If this is an object with result, it is a response.
      if ('result' in response && this._ws_callbacks[response.id]) {
        // Get the success callback.
        var success_cb = this._ws_callbacks[response.id].success_cb;

        // Delete the callback from the storage.
        delete this._ws_callbacks[response.id];

        // Run callback with result as parameter.
        success_cb(response.result);
        return;
      }

      // If this is an object with error, it is an error response.
      else if ('error' in response && this._ws_callbacks[response.id]) {
        // Get the error callback.
        var error_cb = this._ws_callbacks[response.id].error_cb;

        // Delete the callback from the storage.
        delete this._ws_callbacks[response.id];

        // Run callback with the error object as parameter.
        error_cb(response.error);
        return;
      }
    }

    //If we get here its not a valid JSON-RPC response, pass it along to the fallback message handler.
    this.options.onmessage(event);
  };


  /************************************************************************************************
   * Batch object with methods
   ************************************************************************************************/

  /**
   * Handling object for batch calls.
   */
  JsonRpcClient._batchObject = function(jsonrpcclient, all_done_cb, error_cb) {
    // Array of objects to hold the call and notify requests.  Each objects will have the request
    // object, and unless it is a notify, success_cb and error_cb.
    this._requests   = [];

    this.jsonrpcclient = jsonrpcclient;
    this.all_done_cb = all_done_cb;
    this.error_cb    = typeof error_cb    === 'function' ? error_cb : function(){};
  };

  /**
   * @sa JsonRpcClient.prototype.call
   */
  JsonRpcClient._batchObject.prototype.call = function(method, params, success_cb, error_cb) {
    this._requests.push({
      request    : {
        jsonrpc : '2.0',
        method  : method,
        params  : params,
        id      : this.jsonrpcclient._current_id++  // Use the client's id series.
      },
      success_cb : success_cb,
      error_cb   : error_cb
    });
  };

  /**
   * @sa JsonRpcClient.prototype.notify
   */
  JsonRpcClient._batchObject.prototype.notify = function(method, params) {
    this._requests.push({
      request    : {
        jsonrpc : '2.0',
        method  : method,
        params  : params
      }
    });
  };

  /**
   * Executes the batched up calls.
   *
   * @return {object} Returns the deferred object that $.ajax returns or {null} if websockets are used
   */
  JsonRpcClient._batchObject.prototype._execute = function() {
    var self = this;
    var deferred = null; // used to store and return the deffered that $.ajax returns

    if (this._requests.length === 0) return; // All done :P

    // Collect all request data and sort handlers by request id.
    var batch_request = [];

    //  when processing a batch, any request ( without noBlocking === true ) will cause the UI to be locked by AJAX library
    var allNonBlocking = true;

    // If we have a WebSocket, just send the requests individually like normal calls.
    var socket = self.jsonrpcclient.options.getSocket(self.jsonrpcclient.wsOnMessage);

    if (socket !== null) {
      //we need to keep track of results for the all done callback
      var expected_nr_of_cb = 0;
      var cb_results = [];

      var wrap_cb = function(cb) {
        if (!self.all_done_cb) { //no all done callback? no need to keep track
          return cb;
        }

        return function(data) {
          cb(data);
          cb_results.push(data);
          expected_nr_of_cb--;
          if (expected_nr_of_cb <= 0) {
            //change order so that it maps to request order
            var i;
            var resultMap = {};
            for (i=0;i<cb_results.length;i++) {
              resultMap[cb_results[i].id] = cb_results[i];
            }
            var results = [];
            for (i=0; i<self._requests.length; i++) {
              if (resultMap[self._requests[i].id]) {
                results.push(resultMap[self._requests[i].id]);
              }
            }
            //call all done!
            self.all_done_cb(results);
          }
        };
      };


      for (var i = 0; i < this._requests.length; i++) {
        var call = this._requests[i];

        if ('id' in call.request) {
          //we expect an answer
          expected_nr_of_cb++;
        }

        self.jsonrpcclient._wsCall(socket, call.request, wrap_cb(call.success_cb), wrap_cb(call.error_cb));
      }

      return null;

    } else {
      //no websocket, let's use ajax
      var handlers = {};

      for (var i = 0; i < this._requests.length; i++) {
        var call = this._requests[i];
        batch_request.push(call.request);

        if ( !call.request.params || !call.request.params.noBlocking ) {
            allNonBlocking = false;
        }

        // If the request has an id, it should handle returns (otherwise it's a notify).
        if ('id' in call.request) {
          handlers[call.request.id] = {
            success_cb : call.success_cb,
            error_cb   : call.error_cb
          };
        }
      }

      var success_cb = function(data) { self._batchCb(data, handlers, self.all_done_cb); };

      // No WebSocket, and no HTTP backend?  This won't work.
      if (self.jsonrpcclient.options.ajaxUrl === null) {
        throw "JsonRpcClient.batch used with no websocket and no http endpoint.";
      }

      // Send request
      deferred = $.ajax({
        url        : self.jsonrpcclient.options.ajaxUrl,
        contentType: "application/json",
        data       : this.jsonrpcclient.JSON.stringify(batch_request),
        dataType   : 'json',
        cache      : false,
        type       : 'POST',
        headers    : self.jsonrpcclient.options.headers,
        xhrFields  : self.jsonrpcclient.options.xhrFields,

        noBlocking: allNonBlocking,

        // Batch-requests should always return 200
        error    : function(jqXHR, textStatus, errorThrown) {
          self.error_cb(jqXHR, textStatus, errorThrown);
        },
        success  : success_cb
      });

      return deferred;

    }

  };

  /**
   * Internal helper to match the result array from a batch call to their respective callbacks.
   *
   * @fn _batchCb
   * @memberof JsonRpcClient
   */
  JsonRpcClient._batchObject.prototype._batchCb = function(result, handlers, all_done_cb) {
    for (var i = 0; i < result.length; i++) {
      var response = result[i];

      // Handle error
      if ('error' in response) {
        if (response.id === null || !(response.id in handlers)) {
          // An error on a notify?  Just log it to the console.
          if ('console' in window) console.log(response);
        }
        else handlers[response.id].error_cb(response.error);
      }
      else {
        // Here we should always have a correct id and no error.
        if (!(response.id in handlers) && 'console' in window) console.log(response);
        else handlers[response.id].success_cb(response.result);
      }
    }

    if (typeof all_done_cb === 'function') all_done_cb(result);
  };


  $.JsonRpcClient = JsonRpcClient;

})(this.jQuery);
;/*! jQuery UI - v1.10.2 - 2013-03-16
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.resizable.js
* Copyright 2013 jQuery Foundation and other contributors Licensed MIT */

(function(e,t){function i(t,i){var a,n,r,o=t.nodeName.toLowerCase();return"area"===o?(a=t.parentNode,n=a.name,t.href&&n&&"map"===a.nodeName.toLowerCase()?(r=e("img[usemap=#"+n+"]")[0],!!r&&s(r)):!1):(/input|select|textarea|button|object/.test(o)?!t.disabled:"a"===o?t.href||i:i)&&s(t)}function s(t){return e.expr.filters.visible(t)&&!e(t).parents().addBack().filter(function(){return"hidden"===e.css(this,"visibility")}).length}var a=0,n=/^ui-id-\d+$/;e.ui=e.ui||{},e.extend(e.ui,{version:"1.10.2",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({focus:function(t){return function(i,s){return"number"==typeof i?this.each(function(){var t=this;setTimeout(function(){e(t).focus(),s&&s.call(t)},i)}):t.apply(this,arguments)}}(e.fn.focus),scrollParent:function(){var t;return t=e.ui.ie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?this.parents().filter(function(){return/(relative|absolute|fixed)/.test(e.css(this,"position"))&&/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0):this.parents().filter(function(){return/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0),/fixed/.test(this.css("position"))||!t.length?e(document):t},zIndex:function(i){if(i!==t)return this.css("zIndex",i);if(this.length)for(var s,a,n=e(this[0]);n.length&&n[0]!==document;){if(s=n.css("position"),("absolute"===s||"relative"===s||"fixed"===s)&&(a=parseInt(n.css("zIndex"),10),!isNaN(a)&&0!==a))return a;n=n.parent()}return 0},uniqueId:function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++a)})},removeUniqueId:function(){return this.each(function(){n.test(this.id)&&e(this).removeAttr("id")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(i){return!!e.data(i,t)}}):function(t,i,s){return!!e.data(t,s[3])},focusable:function(t){return i(t,!isNaN(e.attr(t,"tabindex")))},tabbable:function(t){var s=e.attr(t,"tabindex"),a=isNaN(s);return(a||s>=0)&&i(t,!a)}}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(i,s){function a(t,i,s,a){return e.each(n,function(){i-=parseFloat(e.css(t,"padding"+this))||0,s&&(i-=parseFloat(e.css(t,"border"+this+"Width"))||0),a&&(i-=parseFloat(e.css(t,"margin"+this))||0)}),i}var n="Width"===s?["Left","Right"]:["Top","Bottom"],r=s.toLowerCase(),o={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+s]=function(i){return i===t?o["inner"+s].call(this):this.each(function(){e(this).css(r,a(this,i)+"px")})},e.fn["outer"+s]=function(t,i){return"number"!=typeof t?o["outer"+s].call(this,t):this.each(function(){e(this).css(r,a(this,t,!0,i)+"px")})}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(e.fn.removeData=function(t){return function(i){return arguments.length?t.call(this,e.camelCase(i)):t.call(this)}}(e.fn.removeData)),e.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),e.support.selectstart="onselectstart"in document.createElement("div"),e.fn.extend({disableSelection:function(){return this.bind((e.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(e){e.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}}),e.extend(e.ui,{plugin:{add:function(t,i,s){var a,n=e.ui[t].prototype;for(a in s)n.plugins[a]=n.plugins[a]||[],n.plugins[a].push([i,s[a]])},call:function(e,t,i){var s,a=e.plugins[t];if(a&&e.element[0].parentNode&&11!==e.element[0].parentNode.nodeType)for(s=0;a.length>s;s++)e.options[a[s][0]]&&a[s][1].apply(e.element,i)}},hasScroll:function(t,i){if("hidden"===e(t).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",a=!1;return t[s]>0?!0:(t[s]=1,a=t[s]>0,t[s]=0,a)}})})(jQuery);(function(e,t){var i=0,s=Array.prototype.slice,n=e.cleanData;e.cleanData=function(t){for(var i,s=0;null!=(i=t[s]);s++)try{e(i).triggerHandler("remove")}catch(a){}n(t)},e.widget=function(i,s,n){var a,r,o,h,l={},u=i.split(".")[0];i=i.split(".")[1],a=u+"-"+i,n||(n=s,s=e.Widget),e.expr[":"][a.toLowerCase()]=function(t){return!!e.data(t,a)},e[u]=e[u]||{},r=e[u][i],o=e[u][i]=function(e,i){return this._createWidget?(arguments.length&&this._createWidget(e,i),t):new o(e,i)},e.extend(o,r,{version:n.version,_proto:e.extend({},n),_childConstructors:[]}),h=new s,h.options=e.widget.extend({},h.options),e.each(n,function(i,n){return e.isFunction(n)?(l[i]=function(){var e=function(){return s.prototype[i].apply(this,arguments)},t=function(e){return s.prototype[i].apply(this,e)};return function(){var i,s=this._super,a=this._superApply;return this._super=e,this._superApply=t,i=n.apply(this,arguments),this._super=s,this._superApply=a,i}}(),t):(l[i]=n,t)}),o.prototype=e.widget.extend(h,{widgetEventPrefix:r?h.widgetEventPrefix:i},l,{constructor:o,namespace:u,widgetName:i,widgetFullName:a}),r?(e.each(r._childConstructors,function(t,i){var s=i.prototype;e.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete r._childConstructors):s._childConstructors.push(o),e.widget.bridge(i,o)},e.widget.extend=function(i){for(var n,a,r=s.call(arguments,1),o=0,h=r.length;h>o;o++)for(n in r[o])a=r[o][n],r[o].hasOwnProperty(n)&&a!==t&&(i[n]=e.isPlainObject(a)?e.isPlainObject(i[n])?e.widget.extend({},i[n],a):e.widget.extend({},a):a);return i},e.widget.bridge=function(i,n){var a=n.prototype.widgetFullName||i;e.fn[i]=function(r){var o="string"==typeof r,h=s.call(arguments,1),l=this;return r=!o&&h.length?e.widget.extend.apply(null,[r].concat(h)):r,o?this.each(function(){var s,n=e.data(this,a);return n?e.isFunction(n[r])&&"_"!==r.charAt(0)?(s=n[r].apply(n,h),s!==n&&s!==t?(l=s&&s.jquery?l.pushStack(s.get()):s,!1):t):e.error("no such method '"+r+"' for "+i+" widget instance"):e.error("cannot call methods on "+i+" prior to initialization; "+"attempted to call method '"+r+"'")}):this.each(function(){var t=e.data(this,a);t?t.option(r||{})._init():e.data(this,a,new n(r,this))}),l}},e.Widget=function(){},e.Widget._childConstructors=[],e.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(t,s){s=e(s||this.defaultElement||this)[0],this.element=e(s),this.uuid=i++,this.eventNamespace="."+this.widgetName+this.uuid,this.options=e.widget.extend({},this.options,this._getCreateOptions(),t),this.bindings=e(),this.hoverable=e(),this.focusable=e(),s!==this&&(e.data(s,this.widgetFullName,this),this._on(!0,this.element,{remove:function(e){e.target===s&&this.destroy()}}),this.document=e(s.style?s.ownerDocument:s.document||s),this.window=e(this.document[0].defaultView||this.document[0].parentWindow)),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:e.noop,_getCreateEventData:e.noop,_create:e.noop,_init:e.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:e.noop,widget:function(){return this.element},option:function(i,s){var n,a,r,o=i;if(0===arguments.length)return e.widget.extend({},this.options);if("string"==typeof i)if(o={},n=i.split("."),i=n.shift(),n.length){for(a=o[i]=e.widget.extend({},this.options[i]),r=0;n.length-1>r;r++)a[n[r]]=a[n[r]]||{},a=a[n[r]];if(i=n.pop(),s===t)return a[i]===t?null:a[i];a[i]=s}else{if(s===t)return this.options[i]===t?null:this.options[i];o[i]=s}return this._setOptions(o),this},_setOptions:function(e){var t;for(t in e)this._setOption(t,e[t]);return this},_setOption:function(e,t){return this.options[e]=t,"disabled"===e&&(this.widget().toggleClass(this.widgetFullName+"-disabled ui-state-disabled",!!t).attr("aria-disabled",t),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")),this},enable:function(){return this._setOption("disabled",!1)},disable:function(){return this._setOption("disabled",!0)},_on:function(i,s,n){var a,r=this;"boolean"!=typeof i&&(n=s,s=i,i=!1),n?(s=a=e(s),this.bindings=this.bindings.add(s)):(n=s,s=this.element,a=this.widget()),e.each(n,function(n,o){function h(){return i||r.options.disabled!==!0&&!e(this).hasClass("ui-state-disabled")?("string"==typeof o?r[o]:o).apply(r,arguments):t}"string"!=typeof o&&(h.guid=o.guid=o.guid||h.guid||e.guid++);var l=n.match(/^(\w+)\s*(.*)$/),u=l[1]+r.eventNamespace,c=l[2];c?a.delegate(c,u,h):s.bind(u,h)})},_off:function(e,t){t=(t||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.unbind(t).undelegate(t)},_delay:function(e,t){function i(){return("string"==typeof e?s[e]:e).apply(s,arguments)}var s=this;return setTimeout(i,t||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){e(t.currentTarget).addClass("ui-state-hover")},mouseleave:function(t){e(t.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){e(t.currentTarget).addClass("ui-state-focus")},focusout:function(t){e(t.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(t,i,s){var n,a,r=this.options[t];if(s=s||{},i=e.Event(i),i.type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),i.target=this.element[0],a=i.originalEvent)for(n in a)n in i||(i[n]=a[n]);return this.element.trigger(i,s),!(e.isFunction(r)&&r.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},e.each({show:"fadeIn",hide:"fadeOut"},function(t,i){e.Widget.prototype["_"+t]=function(s,n,a){"string"==typeof n&&(n={effect:n});var r,o=n?n===!0||"number"==typeof n?i:n.effect||i:t;n=n||{},"number"==typeof n&&(n={duration:n}),r=!e.isEmptyObject(n),n.complete=a,n.delay&&s.delay(n.delay),r&&e.effects&&e.effects.effect[o]?s[t](n):o!==t&&s[o]?s[o](n.duration,n.easing,a):s.queue(function(i){e(this)[t](),a&&a.call(s[0]),i()})}})})(jQuery);(function(e){var t=!1;e(document).mouseup(function(){t=!1}),e.widget("ui.mouse",{version:"1.10.2",options:{cancel:"input,textarea,button,select,option",distance:1,delay:0},_mouseInit:function(){var t=this;this.element.bind("mousedown."+this.widgetName,function(e){return t._mouseDown(e)}).bind("click."+this.widgetName,function(i){return!0===e.data(i.target,t.widgetName+".preventClickEvent")?(e.removeData(i.target,t.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):undefined}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),this._mouseMoveDelegate&&e(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(i){if(!t){this._mouseStarted&&this._mouseUp(i),this._mouseDownEvent=i;var s=this,n=1===i.which,a="string"==typeof this.options.cancel&&i.target.nodeName?e(i.target).closest(this.options.cancel).length:!1;return n&&!a&&this._mouseCapture(i)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){s.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(i)&&this._mouseDelayMet(i)&&(this._mouseStarted=this._mouseStart(i)!==!1,!this._mouseStarted)?(i.preventDefault(),!0):(!0===e.data(i.target,this.widgetName+".preventClickEvent")&&e.removeData(i.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(e){return s._mouseMove(e)},this._mouseUpDelegate=function(e){return s._mouseUp(e)},e(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),i.preventDefault(),t=!0,!0)):!0}},_mouseMove:function(t){return e.ui.ie&&(!document.documentMode||9>document.documentMode)&&!t.button?this._mouseUp(t):this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,t)!==!1,this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!this._mouseStarted)},_mouseUp:function(t){return e(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,t.target===this._mouseDownEvent.target&&e.data(t.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(t)),!1},_mouseDistanceMet:function(e){return Math.max(Math.abs(this._mouseDownEvent.pageX-e.pageX),Math.abs(this._mouseDownEvent.pageY-e.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}})})(jQuery);(function(e){e.widget("ui.draggable",e.ui.mouse,{version:"1.10.2",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"!==this.options.helper||/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative"),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._mouseInit()},_destroy:function(){this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._mouseDestroy()},_mouseCapture:function(t){var i=this.options;return this.helper||i.disabled||e(t.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(t),this.handle?(e(i.iframeFix===!0?"iframe":i.iframeFix).each(function(){e("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>").css({width:this.offsetWidth+"px",height:this.offsetHeight+"px",position:"absolute",opacity:"0.001",zIndex:1e3}).css(e(this).offset()).appendTo("body")}),!0):!1)},_mouseStart:function(t){var i=this.options;return this.helper=this._createHelper(t),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),e.ui.ddmanager&&(e.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(),this.offset=this.positionAbs=this.element.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},e.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.originalPosition=this.position=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),i.containment&&this._setContainment(),this._trigger("start",t)===!1?(this._clear(),!1):(this._cacheHelperProportions(),e.ui.ddmanager&&!i.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this._mouseDrag(t,!0),e.ui.ddmanager&&e.ui.ddmanager.dragStart(this,t),!0)},_mouseDrag:function(t,i){if(this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",t,s)===!1)return this._mouseUp({}),!1;this.position=s.position}return this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),!1},_mouseStop:function(t){var i,s=this,n=!1,a=!1;for(e.ui.ddmanager&&!this.options.dropBehaviour&&(a=e.ui.ddmanager.drop(this,t)),this.dropped&&(a=this.dropped,this.dropped=!1),i=this.element[0];i&&(i=i.parentNode);)i===document&&(n=!0);return n||"original"!==this.options.helper?("invalid"===this.options.revert&&!a||"valid"===this.options.revert&&a||this.options.revert===!0||e.isFunction(this.options.revert)&&this.options.revert.call(this.element,a)?e(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){s._trigger("stop",t)!==!1&&s._clear()}):this._trigger("stop",t)!==!1&&this._clear(),!1):!1},_mouseUp:function(t){return e("div.ui-draggable-iframeFix").each(function(){this.parentNode.removeChild(this)}),e.ui.ddmanager&&e.ui.ddmanager.dragStop(this,t),e.ui.mouse.prototype._mouseUp.call(this,t)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(t){return this.options.handle?!!e(t.target).closest(this.element.find(this.options.handle)).length:!0},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper)?e(i.helper.apply(this.element[0],[t])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return s.parents("body").length||s.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s[0]===this.element[0]||/(fixed|absolute)/.test(s.css("position"))||s.css("position","absolute"),s},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var t=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===document.body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&e.ui.ie)&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var e=this.element.position();return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:e.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,n=this.options;if("parent"===n.containment&&(n.containment=this.helper[0].parentNode),("document"===n.containment||"window"===n.containment)&&(this.containment=["document"===n.containment?0:e(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,"document"===n.containment?0:e(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,("document"===n.containment?0:e(window).scrollLeft())+e("document"===n.containment?document:window).width()-this.helperProportions.width-this.margins.left,("document"===n.containment?0:e(window).scrollTop())+(e("document"===n.containment?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(n.containment)||n.containment.constructor===Array)n.containment.constructor===Array&&(this.containment=n.containment);else{if(i=e(n.containment),s=i[0],!s)return;t="hidden"!==e(s).css("overflow"),this.containment=[(parseInt(e(s).css("borderLeftWidth"),10)||0)+(parseInt(e(s).css("paddingLeft"),10)||0),(parseInt(e(s).css("borderTopWidth"),10)||0)+(parseInt(e(s).css("paddingTop"),10)||0),(t?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(e(s).css("borderRightWidth"),10)||0)-(parseInt(e(s).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(t?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(e(s).css("borderBottomWidth"),10)||0)-(parseInt(e(s).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relative_container=i}},_convertPositionTo:function(t,i){i||(i=this.position);var s="absolute"===t?1:-1,n="absolute"!==this.cssPosition||this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,a=/(html|body)/i.test(n[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():a?0:n.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():a?0:n.scrollLeft())*s}},_generatePosition:function(t){var i,s,n,a,o=this.options,r="absolute"!==this.cssPosition||this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,h=/(html|body)/i.test(r[0].tagName),l=t.pageX,u=t.pageY;return this.originalPosition&&(this.containment&&(this.relative_container?(s=this.relative_container.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,t.pageX-this.offset.click.left<i[0]&&(l=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(u=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(l=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(u=i[3]+this.offset.click.top)),o.grid&&(n=o.grid[1]?this.originalPageY+Math.round((u-this.originalPageY)/o.grid[1])*o.grid[1]:this.originalPageY,u=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-o.grid[1]:n+o.grid[1]:n,a=o.grid[0]?this.originalPageX+Math.round((l-this.originalPageX)/o.grid[0])*o.grid[0]:this.originalPageX,l=i?a-this.offset.click.left>=i[0]||a-this.offset.click.left>i[2]?a:a-this.offset.click.left>=i[0]?a-o.grid[0]:a+o.grid[0]:a)),{top:u-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():h?0:r.scrollTop()),left:l-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():h?0:r.scrollLeft())}},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1},_trigger:function(t,i,s){return s=s||this._uiHash(),e.ui.plugin.call(this,t,[i,s]),"drag"===t&&(this.positionAbs=this._convertPositionTo("absolute")),e.Widget.prototype._trigger.call(this,t,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),e.ui.plugin.add("draggable","connectToSortable",{start:function(t,i){var s=e(this).data("ui-draggable"),n=s.options,a=e.extend({},i,{item:s.element});s.sortables=[],e(n.connectToSortable).each(function(){var i=e.data(this,"ui-sortable");i&&!i.options.disabled&&(s.sortables.push({instance:i,shouldRevert:i.options.revert}),i.refreshPositions(),i._trigger("activate",t,a))})},stop:function(t,i){var s=e(this).data("ui-draggable"),n=e.extend({},i,{item:s.element});e.each(s.sortables,function(){this.instance.isOver?(this.instance.isOver=0,s.cancelHelperRemoval=!0,this.instance.cancelHelperRemoval=!1,this.shouldRevert&&(this.instance.options.revert=this.shouldRevert),this.instance._mouseStop(t),this.instance.options.helper=this.instance.options._helper,"original"===s.options.helper&&this.instance.currentItem.css({top:"auto",left:"auto"})):(this.instance.cancelHelperRemoval=!1,this.instance._trigger("deactivate",t,n))})},drag:function(t,i){var s=e(this).data("ui-draggable"),n=this;e.each(s.sortables,function(){var a=!1,o=this;this.instance.positionAbs=s.positionAbs,this.instance.helperProportions=s.helperProportions,this.instance.offset.click=s.offset.click,this.instance._intersectsWith(this.instance.containerCache)&&(a=!0,e.each(s.sortables,function(){return this.instance.positionAbs=s.positionAbs,this.instance.helperProportions=s.helperProportions,this.instance.offset.click=s.offset.click,this!==o&&this.instance._intersectsWith(this.instance.containerCache)&&e.contains(o.instance.element[0],this.instance.element[0])&&(a=!1),a})),a?(this.instance.isOver||(this.instance.isOver=1,this.instance.currentItem=e(n).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item",!0),this.instance.options._helper=this.instance.options.helper,this.instance.options.helper=function(){return i.helper[0]},t.target=this.instance.currentItem[0],this.instance._mouseCapture(t,!0),this.instance._mouseStart(t,!0,!0),this.instance.offset.click.top=s.offset.click.top,this.instance.offset.click.left=s.offset.click.left,this.instance.offset.parent.left-=s.offset.parent.left-this.instance.offset.parent.left,this.instance.offset.parent.top-=s.offset.parent.top-this.instance.offset.parent.top,s._trigger("toSortable",t),s.dropped=this.instance.element,s.currentItem=s.element,this.instance.fromOutside=s),this.instance.currentItem&&this.instance._mouseDrag(t)):this.instance.isOver&&(this.instance.isOver=0,this.instance.cancelHelperRemoval=!0,this.instance.options.revert=!1,this.instance._trigger("out",t,this.instance._uiHash(this.instance)),this.instance._mouseStop(t,!0),this.instance.options.helper=this.instance.options._helper,this.instance.currentItem.remove(),this.instance.placeholder&&this.instance.placeholder.remove(),s._trigger("fromSortable",t),s.dropped=!1)})}}),e.ui.plugin.add("draggable","cursor",{start:function(){var t=e("body"),i=e(this).data("ui-draggable").options;t.css("cursor")&&(i._cursor=t.css("cursor")),t.css("cursor",i.cursor)},stop:function(){var t=e(this).data("ui-draggable").options;t._cursor&&e("body").css("cursor",t._cursor)}}),e.ui.plugin.add("draggable","opacity",{start:function(t,i){var s=e(i.helper),n=e(this).data("ui-draggable").options;s.css("opacity")&&(n._opacity=s.css("opacity")),s.css("opacity",n.opacity)},stop:function(t,i){var s=e(this).data("ui-draggable").options;s._opacity&&e(i.helper).css("opacity",s._opacity)}}),e.ui.plugin.add("draggable","scroll",{start:function(){var t=e(this).data("ui-draggable");t.scrollParent[0]!==document&&"HTML"!==t.scrollParent[0].tagName&&(t.overflowOffset=t.scrollParent.offset())},drag:function(t){var i=e(this).data("ui-draggable"),s=i.options,n=!1;i.scrollParent[0]!==document&&"HTML"!==i.scrollParent[0].tagName?(s.axis&&"x"===s.axis||(i.overflowOffset.top+i.scrollParent[0].offsetHeight-t.pageY<s.scrollSensitivity?i.scrollParent[0].scrollTop=n=i.scrollParent[0].scrollTop+s.scrollSpeed:t.pageY-i.overflowOffset.top<s.scrollSensitivity&&(i.scrollParent[0].scrollTop=n=i.scrollParent[0].scrollTop-s.scrollSpeed)),s.axis&&"y"===s.axis||(i.overflowOffset.left+i.scrollParent[0].offsetWidth-t.pageX<s.scrollSensitivity?i.scrollParent[0].scrollLeft=n=i.scrollParent[0].scrollLeft+s.scrollSpeed:t.pageX-i.overflowOffset.left<s.scrollSensitivity&&(i.scrollParent[0].scrollLeft=n=i.scrollParent[0].scrollLeft-s.scrollSpeed))):(s.axis&&"x"===s.axis||(t.pageY-e(document).scrollTop()<s.scrollSensitivity?n=e(document).scrollTop(e(document).scrollTop()-s.scrollSpeed):e(window).height()-(t.pageY-e(document).scrollTop())<s.scrollSensitivity&&(n=e(document).scrollTop(e(document).scrollTop()+s.scrollSpeed))),s.axis&&"y"===s.axis||(t.pageX-e(document).scrollLeft()<s.scrollSensitivity?n=e(document).scrollLeft(e(document).scrollLeft()-s.scrollSpeed):e(window).width()-(t.pageX-e(document).scrollLeft())<s.scrollSensitivity&&(n=e(document).scrollLeft(e(document).scrollLeft()+s.scrollSpeed)))),n!==!1&&e.ui.ddmanager&&!s.dropBehaviour&&e.ui.ddmanager.prepareOffsets(i,t)}}),e.ui.plugin.add("draggable","snap",{start:function(){var t=e(this).data("ui-draggable"),i=t.options;t.snapElements=[],e(i.snap.constructor!==String?i.snap.items||":data(ui-draggable)":i.snap).each(function(){var i=e(this),s=i.offset();this!==t.element[0]&&t.snapElements.push({item:this,width:i.outerWidth(),height:i.outerHeight(),top:s.top,left:s.left})})},drag:function(t,i){var s,n,a,o,r,h,l,u,c,d,p=e(this).data("ui-draggable"),f=p.options,m=f.snapTolerance,g=i.offset.left,v=g+p.helperProportions.width,y=i.offset.top,b=y+p.helperProportions.height;for(c=p.snapElements.length-1;c>=0;c--)r=p.snapElements[c].left,h=r+p.snapElements[c].width,l=p.snapElements[c].top,u=l+p.snapElements[c].height,g>r-m&&h+m>g&&y>l-m&&u+m>y||g>r-m&&h+m>g&&b>l-m&&u+m>b||v>r-m&&h+m>v&&y>l-m&&u+m>y||v>r-m&&h+m>v&&b>l-m&&u+m>b?("inner"!==f.snapMode&&(s=m>=Math.abs(l-b),n=m>=Math.abs(u-y),a=m>=Math.abs(r-v),o=m>=Math.abs(h-g),s&&(i.position.top=p._convertPositionTo("relative",{top:l-p.helperProportions.height,left:0}).top-p.margins.top),n&&(i.position.top=p._convertPositionTo("relative",{top:u,left:0}).top-p.margins.top),a&&(i.position.left=p._convertPositionTo("relative",{top:0,left:r-p.helperProportions.width}).left-p.margins.left),o&&(i.position.left=p._convertPositionTo("relative",{top:0,left:h}).left-p.margins.left)),d=s||n||a||o,"outer"!==f.snapMode&&(s=m>=Math.abs(l-y),n=m>=Math.abs(u-b),a=m>=Math.abs(r-g),o=m>=Math.abs(h-v),s&&(i.position.top=p._convertPositionTo("relative",{top:l,left:0}).top-p.margins.top),n&&(i.position.top=p._convertPositionTo("relative",{top:u-p.helperProportions.height,left:0}).top-p.margins.top),a&&(i.position.left=p._convertPositionTo("relative",{top:0,left:r}).left-p.margins.left),o&&(i.position.left=p._convertPositionTo("relative",{top:0,left:h-p.helperProportions.width}).left-p.margins.left)),!p.snapElements[c].snapping&&(s||n||a||o||d)&&p.options.snap.snap&&p.options.snap.snap.call(p.element,t,e.extend(p._uiHash(),{snapItem:p.snapElements[c].item})),p.snapElements[c].snapping=s||n||a||o||d):(p.snapElements[c].snapping&&p.options.snap.release&&p.options.snap.release.call(p.element,t,e.extend(p._uiHash(),{snapItem:p.snapElements[c].item})),p.snapElements[c].snapping=!1)}}),e.ui.plugin.add("draggable","stack",{start:function(){var t,i=this.data("ui-draggable").options,s=e.makeArray(e(i.stack)).sort(function(t,i){return(parseInt(e(t).css("zIndex"),10)||0)-(parseInt(e(i).css("zIndex"),10)||0)});s.length&&(t=parseInt(e(s[0]).css("zIndex"),10)||0,e(s).each(function(i){e(this).css("zIndex",t+i)}),this.css("zIndex",t+s.length))}}),e.ui.plugin.add("draggable","zIndex",{start:function(t,i){var s=e(i.helper),n=e(this).data("ui-draggable").options;s.css("zIndex")&&(n._zIndex=s.css("zIndex")),s.css("zIndex",n.zIndex)},stop:function(t,i){var s=e(this).data("ui-draggable").options;s._zIndex&&e(i.helper).css("zIndex",s._zIndex)}})})(jQuery);(function(e){function t(e){return parseInt(e,10)||0}function i(e){return!isNaN(parseInt(e,10))}e.widget("ui.resizable",e.ui.mouse,{version:"1.10.2",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_create:function(){var t,i,s,n,a,o=this,r=this.options;if(this.element.addClass("ui-resizable"),e.extend(this,{_aspectRatio:!!r.aspectRatio,aspectRatio:r.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:r.helper||r.ghost||r.animate?r.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)&&(this.element.wrap(e("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.data("ui-resizable")),this.elementIsWrapper=!0,this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")}),this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0}),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css({margin:this.originalElement.css("margin")}),this._proportionallyResize()),this.handles=r.handles||(e(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),t=this.handles.split(","),this.handles={},i=0;t.length>i;i++)s=e.trim(t[i]),a="ui-resizable-"+s,n=e("<div class='ui-resizable-handle "+a+"'></div>"),n.css({zIndex:r.zIndex}),"se"===s&&n.addClass("ui-icon ui-icon-gripsmall-diagonal-se"),this.handles[s]=".ui-resizable-"+s,this.element.append(n);this._renderAxis=function(t){var i,s,n,a;t=t||this.element;for(i in this.handles)this.handles[i].constructor===String&&(this.handles[i]=e(this.handles[i],this.element).show()),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/textarea|input|select|button/i)&&(s=e(this.handles[i],this.element),a=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),n=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),t.css(n,a),this._proportionallyResize()),e(this.handles[i]).length},this._renderAxis(this.element),this._handles=e(".ui-resizable-handle",this.element).disableSelection(),this._handles.mouseover(function(){o.resizing||(this.className&&(n=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),o.axis=n&&n[1]?n[1]:"se")}),r.autoHide&&(this._handles.hide(),e(this.element).addClass("ui-resizable-autohide").mouseenter(function(){r.disabled||(e(this).removeClass("ui-resizable-autohide"),o._handles.show())}).mouseleave(function(){r.disabled||o.resizing||(e(this).addClass("ui-resizable-autohide"),o._handles.hide())})),this._mouseInit()},_destroy:function(){this._mouseDestroy();var t,i=function(t){e(t).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),t=this.element,this.originalElement.css({position:t.css("position"),width:t.outerWidth(),height:t.outerHeight(),top:t.css("top"),left:t.css("left")}).insertAfter(t),t.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_mouseCapture:function(t){var i,s,n=!1;for(i in this.handles)s=e(this.handles[i])[0],(s===t.target||e.contains(s,t.target))&&(n=!0);return!this.options.disabled&&n},_mouseStart:function(i){var s,n,a,o=this.options,r=this.element.position(),h=this.element;return this.resizing=!0,/absolute/.test(h.css("position"))?h.css({position:"absolute",top:h.css("top"),left:h.css("left")}):h.is(".ui-draggable")&&h.css({position:"absolute",top:r.top,left:r.left}),this._renderProxy(),s=t(this.helper.css("left")),n=t(this.helper.css("top")),o.containment&&(s+=e(o.containment).scrollLeft()||0,n+=e(o.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:s,top:n},this.size=this._helper?{width:h.outerWidth(),height:h.outerHeight()}:{width:h.width(),height:h.height()},this.originalSize=this._helper?{width:h.outerWidth(),height:h.outerHeight()}:{width:h.width(),height:h.height()},this.originalPosition={left:s,top:n},this.sizeDiff={width:h.outerWidth()-h.width(),height:h.outerHeight()-h.height()},this.originalMousePosition={left:i.pageX,top:i.pageY},this.aspectRatio="number"==typeof o.aspectRatio?o.aspectRatio:this.originalSize.width/this.originalSize.height||1,a=e(".ui-resizable-"+this.axis).css("cursor"),e("body").css("cursor","auto"===a?this.axis+"-resize":a),h.addClass("ui-resizable-resizing"),this._propagate("start",i),!0},_mouseDrag:function(t){var i,s=this.helper,n={},a=this.originalMousePosition,o=this.axis,r=this.position.top,h=this.position.left,l=this.size.width,u=this.size.height,c=t.pageX-a.left||0,d=t.pageY-a.top||0,p=this._change[o];return p?(i=p.apply(this,[t,c,d]),this._updateVirtualBoundaries(t.shiftKey),(this._aspectRatio||t.shiftKey)&&(i=this._updateRatio(i,t)),i=this._respectSize(i,t),this._updateCache(i),this._propagate("resize",t),this.position.top!==r&&(n.top=this.position.top+"px"),this.position.left!==h&&(n.left=this.position.left+"px"),this.size.width!==l&&(n.width=this.size.width+"px"),this.size.height!==u&&(n.height=this.size.height+"px"),s.css(n),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),e.isEmptyObject(n)||this._trigger("resize",t,this.ui()),!1):!1},_mouseStop:function(t){this.resizing=!1;var i,s,n,a,o,r,h,l=this.options,u=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),n=s&&e.ui.hasScroll(i[0],"left")?0:u.sizeDiff.height,a=s?0:u.sizeDiff.width,o={width:u.helper.width()-a,height:u.helper.height()-n},r=parseInt(u.element.css("left"),10)+(u.position.left-u.originalPosition.left)||null,h=parseInt(u.element.css("top"),10)+(u.position.top-u.originalPosition.top)||null,l.animate||this.element.css(e.extend(o,{top:h,left:r})),u.helper.height(u.size.height),u.helper.width(u.size.width),this._helper&&!l.animate&&this._proportionallyResize()),e("body").css("cursor","auto"),this.element.removeClass("ui-resizable-resizing"),this._propagate("stop",t),this._helper&&this.helper.remove(),!1},_updateVirtualBoundaries:function(e){var t,s,n,a,o,r=this.options;o={minWidth:i(r.minWidth)?r.minWidth:0,maxWidth:i(r.maxWidth)?r.maxWidth:1/0,minHeight:i(r.minHeight)?r.minHeight:0,maxHeight:i(r.maxHeight)?r.maxHeight:1/0},(this._aspectRatio||e)&&(t=o.minHeight*this.aspectRatio,n=o.minWidth/this.aspectRatio,s=o.maxHeight*this.aspectRatio,a=o.maxWidth/this.aspectRatio,t>o.minWidth&&(o.minWidth=t),n>o.minHeight&&(o.minHeight=n),o.maxWidth>s&&(o.maxWidth=s),o.maxHeight>a&&(o.maxHeight=a)),this._vBoundaries=o},_updateCache:function(e){this.offset=this.helper.offset(),i(e.left)&&(this.position.left=e.left),i(e.top)&&(this.position.top=e.top),i(e.height)&&(this.size.height=e.height),i(e.width)&&(this.size.width=e.width)},_updateRatio:function(e){var t=this.position,s=this.size,n=this.axis;return i(e.height)?e.width=e.height*this.aspectRatio:i(e.width)&&(e.height=e.width/this.aspectRatio),"sw"===n&&(e.left=t.left+(s.width-e.width),e.top=null),"nw"===n&&(e.top=t.top+(s.height-e.height),e.left=t.left+(s.width-e.width)),e},_respectSize:function(e){var t=this._vBoundaries,s=this.axis,n=i(e.width)&&t.maxWidth&&t.maxWidth<e.width,a=i(e.height)&&t.maxHeight&&t.maxHeight<e.height,o=i(e.width)&&t.minWidth&&t.minWidth>e.width,r=i(e.height)&&t.minHeight&&t.minHeight>e.height,h=this.originalPosition.left+this.originalSize.width,l=this.position.top+this.size.height,u=/sw|nw|w/.test(s),c=/nw|ne|n/.test(s);return o&&(e.width=t.minWidth),r&&(e.height=t.minHeight),n&&(e.width=t.maxWidth),a&&(e.height=t.maxHeight),o&&u&&(e.left=h-t.minWidth),n&&u&&(e.left=h-t.maxWidth),r&&c&&(e.top=l-t.minHeight),a&&c&&(e.top=l-t.maxHeight),e.width||e.height||e.left||!e.top?e.width||e.height||e.top||!e.left||(e.left=null):e.top=null,e},_proportionallyResize:function(){if(this._proportionallyResizeElements.length){var e,t,i,s,n,a=this.helper||this.element;for(e=0;this._proportionallyResizeElements.length>e;e++){if(n=this._proportionallyResizeElements[e],!this.borderDif)for(this.borderDif=[],i=[n.css("borderTopWidth"),n.css("borderRightWidth"),n.css("borderBottomWidth"),n.css("borderLeftWidth")],s=[n.css("paddingTop"),n.css("paddingRight"),n.css("paddingBottom"),n.css("paddingLeft")],t=0;i.length>t;t++)this.borderDif[t]=(parseInt(i[t],10)||0)+(parseInt(s[t],10)||0);n.css({height:a.height()-this.borderDif[0]-this.borderDif[2]||0,width:a.width()-this.borderDif[1]-this.borderDif[3]||0})}}},_renderProxy:function(){var t=this.element,i=this.options;this.elementOffset=t.offset(),this._helper?(this.helper=this.helper||e("<div style='overflow:hidden;'></div>"),this.helper.addClass(this._helper).css({width:this.element.outerWidth()-1,height:this.element.outerHeight()-1,position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(e,t){return{width:this.originalSize.width+t}},w:function(e,t){var i=this.originalSize,s=this.originalPosition;return{left:s.left+t,width:i.width-t}},n:function(e,t,i){var s=this.originalSize,n=this.originalPosition;return{top:n.top+i,height:s.height-i}},s:function(e,t,i){return{height:this.originalSize.height+i}},se:function(t,i,s){return e.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[t,i,s]))},sw:function(t,i,s){return e.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[t,i,s]))},ne:function(t,i,s){return e.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[t,i,s]))},nw:function(t,i,s){return e.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[t,i,s]))}},_propagate:function(t,i){e.ui.plugin.call(this,t,[i,this.ui()]),"resize"!==t&&this._trigger(t,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),e.ui.plugin.add("resizable","animate",{stop:function(t){var i=e(this).data("ui-resizable"),s=i.options,n=i._proportionallyResizeElements,a=n.length&&/textarea/i.test(n[0].nodeName),o=a&&e.ui.hasScroll(n[0],"left")?0:i.sizeDiff.height,r=a?0:i.sizeDiff.width,h={width:i.size.width-r,height:i.size.height-o},l=parseInt(i.element.css("left"),10)+(i.position.left-i.originalPosition.left)||null,u=parseInt(i.element.css("top"),10)+(i.position.top-i.originalPosition.top)||null;i.element.animate(e.extend(h,u&&l?{top:u,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseInt(i.element.css("width"),10),height:parseInt(i.element.css("height"),10),top:parseInt(i.element.css("top"),10),left:parseInt(i.element.css("left"),10)};n&&n.length&&e(n[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",t)}})}}),e.ui.plugin.add("resizable","containment",{start:function(){var i,s,n,a,o,r,h,l=e(this).data("ui-resizable"),u=l.options,c=l.element,d=u.containment,p=d instanceof e?d.get(0):/parent/.test(d)?c.parent().get(0):d;p&&(l.containerElement=e(p),/document/.test(d)||d===document?(l.containerOffset={left:0,top:0},l.containerPosition={left:0,top:0},l.parentData={element:e(document),left:0,top:0,width:e(document).width(),height:e(document).height()||document.body.parentNode.scrollHeight}):(i=e(p),s=[],e(["Top","Right","Left","Bottom"]).each(function(e,n){s[e]=t(i.css("padding"+n))}),l.containerOffset=i.offset(),l.containerPosition=i.position(),l.containerSize={height:i.innerHeight()-s[3],width:i.innerWidth()-s[1]},n=l.containerOffset,a=l.containerSize.height,o=l.containerSize.width,r=e.ui.hasScroll(p,"left")?p.scrollWidth:o,h=e.ui.hasScroll(p)?p.scrollHeight:a,l.parentData={element:p,left:n.left,top:n.top,width:r,height:h}))},resize:function(t){var i,s,n,a,o=e(this).data("ui-resizable"),r=o.options,h=o.containerOffset,l=o.position,u=o._aspectRatio||t.shiftKey,c={top:0,left:0},d=o.containerElement;d[0]!==document&&/static/.test(d.css("position"))&&(c=h),l.left<(o._helper?h.left:0)&&(o.size.width=o.size.width+(o._helper?o.position.left-h.left:o.position.left-c.left),u&&(o.size.height=o.size.width/o.aspectRatio),o.position.left=r.helper?h.left:0),l.top<(o._helper?h.top:0)&&(o.size.height=o.size.height+(o._helper?o.position.top-h.top:o.position.top),u&&(o.size.width=o.size.height*o.aspectRatio),o.position.top=o._helper?h.top:0),o.offset.left=o.parentData.left+o.position.left,o.offset.top=o.parentData.top+o.position.top,i=Math.abs((o._helper?o.offset.left-c.left:o.offset.left-c.left)+o.sizeDiff.width),s=Math.abs((o._helper?o.offset.top-c.top:o.offset.top-h.top)+o.sizeDiff.height),n=o.containerElement.get(0)===o.element.parent().get(0),a=/relative|absolute/.test(o.containerElement.css("position")),n&&a&&(i-=o.parentData.left),i+o.size.width>=o.parentData.width&&(o.size.width=o.parentData.width-i,u&&(o.size.height=o.size.width/o.aspectRatio)),s+o.size.height>=o.parentData.height&&(o.size.height=o.parentData.height-s,u&&(o.size.width=o.size.height*o.aspectRatio))},stop:function(){var t=e(this).data("ui-resizable"),i=t.options,s=t.containerOffset,n=t.containerPosition,a=t.containerElement,o=e(t.helper),r=o.offset(),h=o.outerWidth()-t.sizeDiff.width,l=o.outerHeight()-t.sizeDiff.height;t._helper&&!i.animate&&/relative/.test(a.css("position"))&&e(this).css({left:r.left-n.left-s.left,width:h,height:l}),t._helper&&!i.animate&&/static/.test(a.css("position"))&&e(this).css({left:r.left-n.left-s.left,width:h,height:l})}}),e.ui.plugin.add("resizable","alsoResize",{start:function(){var t=e(this).data("ui-resizable"),i=t.options,s=function(t){e(t).each(function(){var t=e(this);t.data("ui-resizable-alsoresize",{width:parseInt(t.width(),10),height:parseInt(t.height(),10),left:parseInt(t.css("left"),10),top:parseInt(t.css("top"),10)})})};"object"!=typeof i.alsoResize||i.alsoResize.parentNode?s(i.alsoResize):i.alsoResize.length?(i.alsoResize=i.alsoResize[0],s(i.alsoResize)):e.each(i.alsoResize,function(e){s(e)})},resize:function(t,i){var s=e(this).data("ui-resizable"),n=s.options,a=s.originalSize,o=s.originalPosition,r={height:s.size.height-a.height||0,width:s.size.width-a.width||0,top:s.position.top-o.top||0,left:s.position.left-o.left||0},h=function(t,s){e(t).each(function(){var t=e(this),n=e(this).data("ui-resizable-alsoresize"),a={},o=s&&s.length?s:t.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];e.each(o,function(e,t){var i=(n[t]||0)+(r[t]||0);i&&i>=0&&(a[t]=i||null)}),t.css(a)})};"object"!=typeof n.alsoResize||n.alsoResize.nodeType?h(n.alsoResize):e.each(n.alsoResize,function(e,t){h(e,t)})},stop:function(){e(this).removeData("resizable-alsoresize")}}),e.ui.plugin.add("resizable","ghost",{start:function(){var t=e(this).data("ui-resizable"),i=t.options,s=t.size;t.ghost=t.originalElement.clone(),t.ghost.css({opacity:.25,display:"block",position:"relative",height:s.height,width:s.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass("string"==typeof i.ghost?i.ghost:""),t.ghost.appendTo(t.helper)},resize:function(){var t=e(this).data("ui-resizable");t.ghost&&t.ghost.css({position:"relative",height:t.size.height,width:t.size.width})},stop:function(){var t=e(this).data("ui-resizable");t.ghost&&t.helper&&t.helper.get(0).removeChild(t.ghost.get(0))}}),e.ui.plugin.add("resizable","grid",{resize:function(){var t=e(this).data("ui-resizable"),i=t.options,s=t.size,n=t.originalSize,a=t.originalPosition,o=t.axis,r="number"==typeof i.grid?[i.grid,i.grid]:i.grid,h=r[0]||1,l=r[1]||1,u=Math.round((s.width-n.width)/h)*h,c=Math.round((s.height-n.height)/l)*l,d=n.width+u,p=n.height+c,f=i.maxWidth&&d>i.maxWidth,m=i.maxHeight&&p>i.maxHeight,g=i.minWidth&&i.minWidth>d,v=i.minHeight&&i.minHeight>p;i.grid=r,g&&(d+=h),v&&(p+=l),f&&(d-=h),m&&(p-=l),/^(se|s|e)$/.test(o)?(t.size.width=d,t.size.height=p):/^(ne)$/.test(o)?(t.size.width=d,t.size.height=p,t.position.top=a.top-c):/^(sw)$/.test(o)?(t.size.width=d,t.size.height=p,t.position.left=a.left-u):(t.size.width=d,t.size.height=p,t.position.top=a.top-c,t.position.left=a.left-u)}})})(jQuery);;/*!
 * Bootstrap v3.1.1 (http://getbootstrap.com)
 * Copyright 2011-2021 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(a){"use strict";function b(){var a=document.createElement("bootstrap"),b={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one(a.support.transition.end,function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b()})}(jQuery),+function(a){"use strict";var b='[data-dismiss="alert"]',c=function(c){a(c).on("click",b,this.close)};c.prototype.close=function(b){function c(){f.trigger("closed.bs.alert").remove()}var d=a(this),e=d.attr("data-target");e||(e=d.attr("href"),e=e&&e.replace(/.*(?=#[^\s]*$)/,""));var f=a(e);b&&b.preventDefault(),f.length||(f=d.hasClass("alert")?d:d.parent()),f.trigger(b=a.Event("close.bs.alert")),b.isDefaultPrevented()||(f.removeClass("in"),a.support.transition&&f.hasClass("fade")?f.one(a.support.transition.end,c).emulateTransitionEnd(150):c())};var d=a.fn.alert;a.fn.alert=function(b){return this.each(function(){var d=a(this),e=d.data("bs.alert");e||d.data("bs.alert",e=new c(this)),"string"==typeof b&&e[b].call(d)})},a.fn.alert.Constructor=c,a.fn.alert.noConflict=function(){return a.fn.alert=d,this},a(document).on("click.bs.alert.data-api",b,c.prototype.close)}(jQuery),+function(a){"use strict";var b=function(c,d){this.$element=a(c),this.options=a.extend({},b.DEFAULTS,d),this.isLoading=!1};b.DEFAULTS={loadingText:"loading..."},b.prototype.setState=function(b){var c="disabled",d=this.$element,e=d.is("input")?"val":"html",f=d.data();b+="Text",f.resetText||d.data("resetText",d[e]()),d[e](f[b]||this.options[b]),setTimeout(a.proxy(function(){"loadingText"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},b.prototype.toggle=function(){var a=!0,b=this.$element.closest('[data-toggle="buttons"]');if(b.length){var c=this.$element.find("input");"radio"==c.prop("type")&&(c.prop("checked")&&this.$element.hasClass("active")?a=!1:b.find(".active").removeClass("active")),a&&c.prop("checked",!this.$element.hasClass("active")).trigger("change")}a&&this.$element.toggleClass("active")};var c=a.fn.button;a.fn.button=function(c){return this.each(function(){var d=a(this),e=d.data("bs.button"),f="object"==typeof c&&c;e||d.data("bs.button",e=new b(this,f)),"toggle"==c?e.toggle():c&&e.setState(c)})},a.fn.button.Constructor=b,a.fn.button.noConflict=function(){return a.fn.button=c,this},a(document).on("click.bs.button.data-api","[data-toggle^=button]",function(b){var c=a(b.target);c.hasClass("btn")||(c=c.closest(".btn")),c.button("toggle"),b.preventDefault()})}(jQuery),+function(a){"use strict";var b=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(".carousel-indicators"),this.options=c,this.paused=this.sliding=this.interval=this.$active=this.$items=null,"hover"==this.options.pause&&this.$element.on("mouseenter",a.proxy(this.pause,this)).on("mouseleave",a.proxy(this.cycle,this))};b.DEFAULTS={interval:5e3,pause:"hover",wrap:!0},b.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},b.prototype.getActiveIndex=function(){return this.$active=this.$element.find(".item.active"),this.$items=this.$active.parent().children(),this.$items.index(this.$active)},b.prototype.to=function(b){var c=this,d=this.getActiveIndex();return b>this.$items.length-1||0>b?void 0:this.sliding?this.$element.one("slid.bs.carousel",function(){c.to(b)}):d==b?this.pause().cycle():this.slide(b>d?"next":"prev",a(this.$items[b]))},b.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(".next, .prev").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},b.prototype.next=function(){return this.sliding?void 0:this.slide("next")},b.prototype.prev=function(){return this.sliding?void 0:this.slide("prev")},b.prototype.slide=function(b,c){var d=this.$element.find(".item.active"),e=c||d[b](),f=this.interval,g="next"==b?"left":"right",h="next"==b?"first":"last",i=this;if(!e.length){if(!this.options.wrap)return;e=this.$element.find(".item")[h]()}if(e.hasClass("active"))return this.sliding=!1;var j=a.Event("slide.bs.carousel",{relatedTarget:e[0],direction:g});return this.$element.trigger(j),j.isDefaultPrevented()?void 0:(this.sliding=!0,f&&this.pause(),this.$indicators.length&&(this.$indicators.find(".active").removeClass("active"),this.$element.one("slid.bs.carousel",function(){var b=a(i.$indicators.children()[i.getActiveIndex()]);b&&b.addClass("active")})),a.support.transition&&this.$element.hasClass("slide")?(e.addClass(b),e[0].offsetWidth,d.addClass(g),e.addClass(g),d.one(a.support.transition.end,function(){e.removeClass([b,g].join(" ")).addClass("active"),d.removeClass(["active",g].join(" ")),i.sliding=!1,setTimeout(function(){i.$element.trigger("slid.bs.carousel")},0)}).emulateTransitionEnd(1e3*d.css("transition-duration").slice(0,-1))):(d.removeClass("active"),e.addClass("active"),this.sliding=!1,this.$element.trigger("slid.bs.carousel")),f&&this.cycle(),this)};var c=a.fn.carousel;a.fn.carousel=function(c){return this.each(function(){var d=a(this),e=d.data("bs.carousel"),f=a.extend({},b.DEFAULTS,d.data(),"object"==typeof c&&c),g="string"==typeof c?c:f.slide;e||d.data("bs.carousel",e=new b(this,f)),"number"==typeof c?e.to(c):g?e[g]():f.interval&&e.pause().cycle()})},a.fn.carousel.Constructor=b,a.fn.carousel.noConflict=function(){return a.fn.carousel=c,this},a(document).on("click.bs.carousel.data-api","[data-slide], [data-slide-to]",function(b){var c,d=a(this),e=a(d.attr("data-target")||(c=d.attr("href"))&&c.replace(/.*(?=#[^\s]+$)/,"")),f=a.extend({},e.data(),d.data()),g=d.attr("data-slide-to");g&&(f.interval=!1),e.carousel(f),(g=d.attr("data-slide-to"))&&e.data("bs.carousel").to(g),b.preventDefault()}),a(window).on("load",function(){a('[data-ride="carousel"]').each(function(){var b=a(this);b.carousel(b.data())})})}(jQuery),+function(a){"use strict";var b=function(c,d){this.$element=a(c),this.options=a.extend({},b.DEFAULTS,d),this.transitioning=null,this.options.parent&&(this.$parent=a(this.options.parent)),this.options.toggle&&this.toggle()};b.DEFAULTS={toggle:!0},b.prototype.dimension=function(){var a=this.$element.hasClass("width");return a?"width":"height"},b.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var b=a.Event("show.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.$parent&&this.$parent.find("> .panel > .in");if(c&&c.length){var d=c.data("bs.collapse");if(d&&d.transitioning)return;c.collapse("hide"),d||c.data("bs.collapse",null)}var e=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[e](0),this.transitioning=1;var f=function(){this.$element.removeClass("collapsing").addClass("collapse in")[e]("auto"),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!a.support.transition)return f.call(this);var g=a.camelCase(["scroll",e].join("-"));this.$element.one(a.support.transition.end,a.proxy(f,this)).emulateTransitionEnd(350)[e](this.$element[0][g])}}},b.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var b=a.Event("hide.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse").removeClass("in"),this.transitioning=1;var d=function(){this.transitioning=0,this.$element.trigger("hidden.bs.collapse").removeClass("collapsing").addClass("collapse")};return a.support.transition?void this.$element[c](0).one(a.support.transition.end,a.proxy(d,this)).emulateTransitionEnd(350):d.call(this)}}},b.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()};var c=a.fn.collapse;a.fn.collapse=function(c){return this.each(function(){var d=a(this),e=d.data("bs.collapse"),f=a.extend({},b.DEFAULTS,d.data(),"object"==typeof c&&c);!e&&f.toggle&&"show"==c&&(c=!c),e||d.data("bs.collapse",e=new b(this,f)),"string"==typeof c&&e[c]()})},a.fn.collapse.Constructor=b,a.fn.collapse.noConflict=function(){return a.fn.collapse=c,this},a(document).on("click.bs.collapse.data-api","[data-toggle=collapse]",function(b){var c,d=a(this),e=d.attr("data-target")||b.preventDefault()||(c=d.attr("href"))&&c.replace(/.*(?=#[^\s]+$)/,""),f=a(e),g=f.data("bs.collapse"),h=g?"toggle":d.data(),i=d.attr("data-parent"),j=i&&a(i);g&&g.transitioning||(j&&j.find('[data-toggle=collapse][data-parent="'+i+'"]').not(d).addClass("collapsed"),d[f.hasClass("in")?"addClass":"removeClass"]("collapsed")),f.collapse(h)})}(jQuery),+function(a){"use strict";function b(b){a(d).remove(),a(e).each(function(){var d=c(a(this)),e={relatedTarget:this};d.hasClass("open")&&(d.trigger(b=a.Event("hide.bs.dropdown",e)),b.isDefaultPrevented()||d.removeClass("open").trigger("hidden.bs.dropdown",e))})}function c(b){var c=b.attr("data-target");c||(c=b.attr("href"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\s]*$)/,""));var d=c&&a(c);return d&&d.length?d:b.parent()}var d=".dropdown-backdrop",e="[data-toggle=dropdown]",f=function(b){a(b).on("click.bs.dropdown",this.toggle)};f.prototype.toggle=function(d){var e=a(this);if(!e.is(".disabled, :disabled")){var f=c(e),g=f.hasClass("open");if(b(),!g){"ontouchstart"in document.documentElement&&!f.closest(".navbar-nav").length&&a('<div class="dropdown-backdrop"/>').insertAfter(a(this)).on("click",b);var h={relatedTarget:this};if(f.trigger(d=a.Event("show.bs.dropdown",h)),d.isDefaultPrevented())return;f.toggleClass("open").trigger("shown.bs.dropdown",h),e.focus()}return!1}},f.prototype.keydown=function(b){if(/(38|40|27)/.test(b.keyCode)){var d=a(this);if(b.preventDefault(),b.stopPropagation(),!d.is(".disabled, :disabled")){var f=c(d),g=f.hasClass("open");if(!g||g&&27==b.keyCode)return 27==b.which&&f.find(e).focus(),d.click();var h=" li:not(.divider):visible a",i=f.find("[role=menu]"+h+", [role=listbox]"+h);if(i.length){var j=i.index(i.filter(":focus"));38==b.keyCode&&j>0&&j--,40==b.keyCode&&j<i.length-1&&j++,~j||(j=0),i.eq(j).focus()}}}};var g=a.fn.dropdown;a.fn.dropdown=function(b){return this.each(function(){var c=a(this),d=c.data("bs.dropdown");d||c.data("bs.dropdown",d=new f(this)),"string"==typeof b&&d[b].call(c)})},a.fn.dropdown.Constructor=f,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=g,this},a(document).on("click.bs.dropdown.data-api",b).on("click.bs.dropdown.data-api",".dropdown form",function(a){a.stopPropagation()}).on("click.bs.dropdown.data-api",e,f.prototype.toggle).on("keydown.bs.dropdown.data-api",e+", [role=menu], [role=listbox]",f.prototype.keydown)}(jQuery),+function(a){"use strict";var b=function(b,c){this.options=c,this.$element=a(b),this.$backdrop=this.isShown=null,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,a.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};b.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},b.prototype.toggle=function(a){return this[this.isShown?"hide":"show"](a)},b.prototype.show=function(b){var c=this,d=a.Event("show.bs.modal",{relatedTarget:b});this.$element.trigger(d),this.isShown||d.isDefaultPrevented()||(this.isShown=!0,this.escape(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',a.proxy(this.hide,this)),this.backdrop(function(){var d=a.support.transition&&c.$element.hasClass("fade");c.$element.parent().length||c.$element.appendTo(document.body),c.$element.show().scrollTop(0),d&&c.$element[0].offsetWidth,c.$element.addClass("in").attr("aria-hidden",!1),c.enforceFocus();var e=a.Event("shown.bs.modal",{relatedTarget:b});d?c.$element.find(".modal-dialog").one(a.support.transition.end,function(){c.$element.focus().trigger(e)}).emulateTransitionEnd(300):c.$element.focus().trigger(e)}))},b.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event("hide.bs.modal"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.escape(),a(document).off("focusin.bs.modal"),this.$element.removeClass("in").attr("aria-hidden",!0).off("click.dismiss.bs.modal"),a.support.transition&&this.$element.hasClass("fade")?this.$element.one(a.support.transition.end,a.proxy(this.hideModal,this)).emulateTransitionEnd(300):this.hideModal())},b.prototype.enforceFocus=function(){a(document).off("focusin.bs.modal").on("focusin.bs.modal",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.focus()},this))},b.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keyup.dismiss.bs.modal",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off("keyup.dismiss.bs.modal")},b.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.removeBackdrop(),a.$element.trigger("hidden.bs.modal")})},b.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},b.prototype.backdrop=function(b){var c=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var d=a.support.transition&&c;if(this.$backdrop=a('<div class="modal-backdrop '+c+'" />').appendTo(document.body),this.$element.on("click.dismiss.bs.modal",a.proxy(function(a){a.target===a.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus.call(this.$element[0]):this.hide.call(this))},this)),d&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!b)return;d?this.$backdrop.one(a.support.transition.end,b).emulateTransitionEnd(150):b()}else!this.isShown&&this.$backdrop?(this.$backdrop.removeClass("in"),a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one(a.support.transition.end,b).emulateTransitionEnd(150):b()):b&&b()};var c=a.fn.modal;a.fn.modal=function(c,d){return this.each(function(){var e=a(this),f=e.data("bs.modal"),g=a.extend({},b.DEFAULTS,e.data(),"object"==typeof c&&c);f||e.data("bs.modal",f=new b(this,g)),"string"==typeof c?f[c](d):g.show&&f.show(d)})},a.fn.modal.Constructor=b,a.fn.modal.noConflict=function(){return a.fn.modal=c,this},a(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(b){var c=a(this),d=c.attr("href"),e=a(c.attr("data-target")||d&&d.replace(/.*(?=#[^\s]+$)/,"")),f=e.data("bs.modal")?"toggle":a.extend({remote:!/#/.test(d)&&d},e.data(),c.data());c.is("a")&&b.preventDefault(),e.modal(f,this).one("hide",function(){c.is(":visible")&&c.focus()})}),a(document).on("show.bs.modal",".modal",function(){a(document.body).addClass("modal-open")}).on("hidden.bs.modal",".modal",function(){a(document.body).removeClass("modal-open")})}(jQuery),+function(a){"use strict";var b=function(a,b){this.type=this.options=this.enabled=this.timeout=this.hoverState=this.$element=null,this.init("tooltip",a,b)};b.DEFAULTS={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1},b.prototype.init=function(b,c,d){this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d);for(var e=this.options.trigger.split(" "),f=e.length;f--;){var g=e[f];if("click"==g)this.$element.on("click."+this.type,this.options.selector,a.proxy(this.toggle,this));else if("manual"!=g){var h="hover"==g?"mouseenter":"focusin",i="hover"==g?"mouseleave":"focusout";this.$element.on(h+"."+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+"."+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},b.prototype.getDefaults=function(){return b.DEFAULTS},b.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&"number"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},b.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},b.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget)[this.type](this.getDelegateOptions()).data("bs."+this.type);return clearTimeout(c.timeout),c.hoverState="in",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){"in"==c.hoverState&&c.show()},c.options.delay.show)):c.show()},b.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget)[this.type](this.getDelegateOptions()).data("bs."+this.type);return clearTimeout(c.timeout),c.hoverState="out",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){"out"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide()},b.prototype.show=function(){var b=a.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){if(this.$element.trigger(b),b.isDefaultPrevented())return;var c=this,d=this.tip();this.setContent(),this.options.animation&&d.addClass("fade");var e="function"==typeof this.options.placement?this.options.placement.call(this,d[0],this.$element[0]):this.options.placement,f=/\s?auto?\s?/i,g=f.test(e);g&&(e=e.replace(f,"")||"top"),d.detach().css({top:0,left:0,display:"block"}).addClass(e),this.options.container?d.appendTo(this.options.container):d.insertAfter(this.$element);var h=this.getPosition(),i=d[0].offsetWidth,j=d[0].offsetHeight;if(g){var k=this.$element.parent(),l=e,m=document.documentElement.scrollTop||document.body.scrollTop,n="body"==this.options.container?window.innerWidth:k.outerWidth(),o="body"==this.options.container?window.innerHeight:k.outerHeight(),p="body"==this.options.container?0:k.offset().left;e="bottom"==e&&h.top+h.height+j-m>o?"top":"top"==e&&h.top-m-j<0?"bottom":"right"==e&&h.right+i>n?"left":"left"==e&&h.left-i<p?"right":e,d.removeClass(l).addClass(e)}var q=this.getCalculatedOffset(e,h,i,j);this.applyPlacement(q,e),this.hoverState=null;var r=function(){c.$element.trigger("shown.bs."+c.type)};a.support.transition&&this.$tip.hasClass("fade")?d.one(a.support.transition.end,r).emulateTransitionEnd(150):r()}},b.prototype.applyPlacement=function(b,c){var d,e=this.tip(),f=e[0].offsetWidth,g=e[0].offsetHeight,h=parseInt(e.css("margin-top"),10),i=parseInt(e.css("margin-left"),10);isNaN(h)&&(h=0),isNaN(i)&&(i=0),b.top=b.top+h,b.left=b.left+i,a.offset.setOffset(e[0],a.extend({using:function(a){e.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),e.addClass("in");var j=e[0].offsetWidth,k=e[0].offsetHeight;if("top"==c&&k!=g&&(d=!0,b.top=b.top+g-k),/bottom|top/.test(c)){var l=0;b.left<0&&(l=-2*b.left,b.left=0,e.offset(b),j=e[0].offsetWidth,k=e[0].offsetHeight),this.replaceArrow(l-f+j,j,"left")}else this.replaceArrow(k-g,k,"top");d&&e.offset(b)},b.prototype.replaceArrow=function(a,b,c){this.arrow().css(c,a?50*(1-a/b)+"%":"")},b.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(".tooltip-inner")[this.options.html?"html":"text"](b),a.removeClass("fade in top bottom left right")},b.prototype.hide=function(){function b(){"in"!=c.hoverState&&d.detach(),c.$element.trigger("hidden.bs."+c.type)}var c=this,d=this.tip(),e=a.Event("hide.bs."+this.type);return this.$element.trigger(e),e.isDefaultPrevented()?void 0:(d.removeClass("in"),a.support.transition&&this.$tip.hasClass("fade")?d.one(a.support.transition.end,b).emulateTransitionEnd(150):b(),this.hoverState=null,this)},b.prototype.fixTitle=function(){var a=this.$element;(a.attr("title")||"string"!=typeof a.attr("data-original-title"))&&a.attr("data-original-title",a.attr("title")||"").attr("title","")},b.prototype.hasContent=function(){return this.getTitle()},b.prototype.getPosition=function(){var b=this.$element[0];return a.extend({},"function"==typeof b.getBoundingClientRect?b.getBoundingClientRect():{width:b.offsetWidth,height:b.offsetHeight},this.$element.offset())},b.prototype.getCalculatedOffset=function(a,b,c,d){return"bottom"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:"top"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:"left"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},b.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr("data-original-title")||("function"==typeof c.title?c.title.call(b[0]):c.title)},b.prototype.tip=function(){return this.$tip=this.$tip||a(this.options.template)},b.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},b.prototype.validate=function(){this.$element[0].parentNode||(this.hide(),this.$element=null,this.options=null)},b.prototype.enable=function(){this.enabled=!0},b.prototype.disable=function(){this.enabled=!1},b.prototype.toggleEnabled=function(){this.enabled=!this.enabled},b.prototype.toggle=function(b){var c=b?a(b.currentTarget)[this.type](this.getDelegateOptions()).data("bs."+this.type):this;c.tip().hasClass("in")?c.leave(c):c.enter(c)},b.prototype.destroy=function(){clearTimeout(this.timeout),this.hide().$element.off("."+this.type).removeData("bs."+this.type)};var c=a.fn.tooltip;a.fn.tooltip=function(c){return this.each(function(){var d=a(this),e=d.data("bs.tooltip"),f="object"==typeof c&&c;(e||"destroy"!=c)&&(e||d.data("bs.tooltip",e=new b(this,f)),"string"==typeof c&&e[c]())})},a.fn.tooltip.Constructor=b,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=c,this}}(jQuery),+function(a){"use strict";var b=function(a,b){this.init("popover",a,b)};if(!a.fn.tooltip)throw new Error("Popover requires tooltip.js");b.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:'<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),b.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),b.prototype.constructor=b,b.prototype.getDefaults=function(){return b.DEFAULTS},b.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(".popover-title")[this.options.html?"html":"text"](b),a.find(".popover-content")[this.options.html?"string"==typeof c?"html":"append":"text"](c),a.removeClass("fade top bottom left right in"),a.find(".popover-title").html()||a.find(".popover-title").hide()},b.prototype.hasContent=function(){return this.getTitle()||this.getContent()},b.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr("data-content")||("function"==typeof b.content?b.content.call(a[0]):b.content)},b.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")},b.prototype.tip=function(){return this.$tip||(this.$tip=a(this.options.template)),this.$tip};var c=a.fn.popover;a.fn.popover=function(c){return this.each(function(){var d=a(this),e=d.data("bs.popover"),f="object"==typeof c&&c;(e||"destroy"!=c)&&(e||d.data("bs.popover",e=new b(this,f)),"string"==typeof c&&e[c]())})},a.fn.popover.Constructor=b,a.fn.popover.noConflict=function(){return a.fn.popover=c,this}}(jQuery),+function(a){"use strict";function b(c,d){var e,f=a.proxy(this.process,this);this.$element=a(a(c).is("body")?window:c),this.$body=a("body"),this.$scrollElement=this.$element.on("scroll.bs.scroll-spy.data-api",f),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||(e=a(c).attr("href"))&&e.replace(/.*(?=#[^\s]+$)/,"")||"")+" .nav li > a",this.offsets=a([]),this.targets=a([]),this.activeTarget=null,this.refresh(),this.process()}b.DEFAULTS={offset:10},b.prototype.refresh=function(){var b=this.$element[0]==window?"offset":"position";this.offsets=a([]),this.targets=a([]);var c=this;this.$body.find(this.selector).map(function(){var d=a(this),e=d.data("target")||d.attr("href"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(":visible")&&[[f[b]().top+(!a.isWindow(c.$scrollElement.get(0))&&c.$scrollElement.scrollTop()),e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){c.offsets.push(this[0]),c.targets.push(this[1])})},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.$scrollElement[0].scrollHeight||this.$body[0].scrollHeight,d=c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(b>=d)return g!=(a=f.last()[0])&&this.activate(a);if(g&&b<=e[0])return g!=(a=f[0])&&this.activate(a);for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(!e[a+1]||b<=e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,a(this.selector).parentsUntil(this.options.target,".active").removeClass("active");var c=this.selector+'[data-target="'+b+'"],'+this.selector+'[href="'+b+'"]',d=a(c).parents("li").addClass("active");d.parent(".dropdown-menu").length&&(d=d.closest("li.dropdown").addClass("active")),d.trigger("activate.bs.scrollspy")};var c=a.fn.scrollspy;a.fn.scrollspy=function(c){return this.each(function(){var d=a(this),e=d.data("bs.scrollspy"),f="object"==typeof c&&c;e||d.data("bs.scrollspy",e=new b(this,f)),"string"==typeof c&&e[c]()})},a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=c,this},a(window).on("load",function(){a('[data-spy="scroll"]').each(function(){var b=a(this);b.scrollspy(b.data())})})}(jQuery),+function(a){"use strict";var b=function(b){this.element=a(b)};b.prototype.show=function(){var b=this.element,c=b.closest("ul:not(.dropdown-menu)"),d=b.data("target");if(d||(d=b.attr("href"),d=d&&d.replace(/.*(?=#[^\s]*$)/,"")),!b.parent("li").hasClass("active")){var e=c.find(".active:last a")[0],f=a.Event("show.bs.tab",{relatedTarget:e});if(b.trigger(f),!f.isDefaultPrevented()){var g=a(d);this.activate(b.parent("li"),c),this.activate(g,g.parent(),function(){b.trigger({type:"shown.bs.tab",relatedTarget:e})})}}},b.prototype.activate=function(b,c,d){function e(){f.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"),b.addClass("active"),g?(b[0].offsetWidth,b.addClass("in")):b.removeClass("fade"),b.parent(".dropdown-menu")&&b.closest("li.dropdown").addClass("active"),d&&d()}var f=c.find("> .active"),g=d&&a.support.transition&&f.hasClass("fade");g?f.one(a.support.transition.end,e).emulateTransitionEnd(150):e(),f.removeClass("in")};var c=a.fn.tab;a.fn.tab=function(c){return this.each(function(){var d=a(this),e=d.data("bs.tab");e||d.data("bs.tab",e=new b(this)),"string"==typeof c&&e[c]()})},a.fn.tab.Constructor=b,a.fn.tab.noConflict=function(){return a.fn.tab=c,this},a(document).on("click.bs.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"]',function(b){b.preventDefault(),a(this).tab("show")})}(jQuery),+function(a){"use strict";var b=function(c,d){this.options=a.extend({},b.DEFAULTS,d),this.$window=a(window).on("scroll.bs.affix.data-api",a.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(c),this.affixed=this.unpin=this.pinnedOffset=null,this.checkPosition()};b.RESET="affix affix-top affix-bottom",b.DEFAULTS={offset:0},b.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(b.RESET).addClass("affix");var a=this.$window.scrollTop(),c=this.$element.offset();return this.pinnedOffset=c.top-a},b.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},b.prototype.checkPosition=function(){if(this.$element.is(":visible")){var c=a(document).height(),d=this.$window.scrollTop(),e=this.$element.offset(),f=this.options.offset,g=f.top,h=f.bottom;"top"==this.affixed&&(e.top+=d),"object"!=typeof f&&(h=g=f),"function"==typeof g&&(g=f.top(this.$element)),"function"==typeof h&&(h=f.bottom(this.$element));var i=null!=this.unpin&&d+this.unpin<=e.top?!1:null!=h&&e.top+this.$element.height()>=c-h?"bottom":null!=g&&g>=d?"top":!1;if(this.affixed!==i){this.unpin&&this.$element.css("top","");var j="affix"+(i?"-"+i:""),k=a.Event(j+".bs.affix");this.$element.trigger(k),k.isDefaultPrevented()||(this.affixed=i,this.unpin="bottom"==i?this.getPinnedOffset():null,this.$element.removeClass(b.RESET).addClass(j).trigger(a.Event(j.replace("affix","affixed"))),"bottom"==i&&this.$element.offset({top:c-h-this.$element.height()}))}}};var c=a.fn.affix;a.fn.affix=function(c){return this.each(function(){var d=a(this),e=d.data("bs.affix"),f="object"==typeof c&&c;e||d.data("bs.affix",e=new b(this,f)),"string"==typeof c&&e[c]()})},a.fn.affix.Constructor=b,a.fn.affix.noConflict=function(){return a.fn.affix=c,this},a(window).on("load",function(){a('[data-spy="affix"]').each(function(){var b=a(this),c=b.data();c.offset=c.offset||{},c.offsetBottom&&(c.offset.bottom=c.offsetBottom),c.offsetTop&&(c.offset.top=c.offsetTop),b.affix(c)})})}(jQuery);;/*
 * Copyright 2012 Doc Cirrus GmbH, Berlin
 * Date: 20.12.2012
 */

/*global jQuery */

"use strict";

/* jshint unused:false */
function dcChangeTab( param ) {

    jQuery( '#container' ).find( '.toplevel' ).each( function() {
        jQuery( this ).removeClass( 'active' );
    } );

    jQuery( param ).addClass( 'active' );
}

/**
 * Viewport switching between normal (bootstrap container) and wide (resolution dependent)
 * use normal, for normal forms and content
 * use wide, for large forms and datatables
 *
 * @wide Boolean, true means wide, false means normal (default)
 */
// TODO: MOJ-3142
function setViewportWide( wide ) {
    var
        $containers = jQuery( '.container' ),
        body = document.body;
    if( wide ) {
        $containers.addClass( 'container-fullscreen' );
        body.classList.add( 'content-fullscreen' );
    } else {
        $containers.removeClass( 'container-fullscreen' );
        body.classList.remove( 'content-fullscreen' );
    }
}
;function p( a ) {
    throw a;
}
var r = void 0, v = !0, C = !1;
var sjcl = {cipher: {}, hash: {}, keyexchange: {}, mode: {}, misc: {}, codec: {}, exception: {corrupt: function( a ) {
    this.toString = function() {
        return"CORRUPT: " + this.message
    };
    this.message = a
}, invalid: function( a ) {
    this.toString = function() {
        return"INVALID: " + this.message
    };
    this.message = a
}, bug: function( a ) {
    this.toString = function() {
        return"BUG: " + this.message
    };
    this.message = a
}, notReady: function( a ) {
    this.toString = function() {
        return"NOT READY: " + this.message
    };
    this.message = a
}}};
"undefined" !== typeof module && module.exports && (module.exports = sjcl);
"function" === typeof define && define( [], function() {
    return sjcl
} );
sjcl.cipher.aes = function( a ) {
    this.A[0][0][0] || this.J();
    var b, c, d, e, f = this.A[0][4], g = this.A[1];
    b = a.length;
    var h = 1;
    4 !== b && (6 !== b && 8 !== b) && p( new sjcl.exception.invalid( "invalid aes key size" ) );
    this.d = [d = a.slice( 0 ), e = []];
    for( a = b; a < 4 * b + 28; a++ ) {
        c = d[a - 1];
        if( 0 === a % b || 8 === b && 4 === a % b ) {
            c = f[c >>> 24] << 24 ^ f[c >> 16 & 255] << 16 ^ f[c >> 8 & 255] << 8 ^ f[c & 255], 0 === a % b && (c = c << 8 ^ c >>> 24 ^ h << 24, h = h << 1 ^ 283 * (h >> 7));
        }
        d[a] = d[a - b] ^ c
    }
    for( b = 0; a; b++, a-- ) {
        c = d[b & 3 ? a : a - 4], e[b] = 4 >= a || 4 > b ? c : g[0][f[c >>> 24]] ^ g[1][f[c >> 16 & 255]] ^ g[2][f[c >> 8 & 255]] ^ g[3][f[c &
                                                                                                                                           255]]
    }
};
sjcl.cipher.aes.prototype = {encrypt: function( a ) {
    return ba( this, a, 0 )
}, decrypt: function( a ) {
    return ba( this, a, 1 )
}, A: [
    [
        [],
        [],
        [],
        [],
        []
    ],
    [
        [],
        [],
        [],
        [],
        []
    ]
], J: function() {
    var a = this.A[0], b = this.A[1], c = a[4], d = b[4], e, f, g, h = [], k = [], l, n, m, q;
    for( e = 0; 0x100 > e; e++ ) {
        k[(h[e] = e << 1 ^ 283 * (e >> 7)) ^ e] = e;
    }
    for( f = g = 0; !c[f]; f ^= l || 1, g = k[g] || 1 ) {
        m = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4;
        m = m >> 8 ^ m & 255 ^ 99;
        c[f] = m;
        d[m] = f;
        n = h[e = h[l = h[f]]];
        q = 0x1010101 * n ^ 0x10001 * e ^ 0x101 * l ^ 0x1010100 * f;
        n = 0x101 * h[m] ^ 0x1010100 * m;
        for( e = 0; 4 > e; e++ ) {
            a[e][f] = n = n << 24 ^ n >>> 8, b[e][m] = q = q << 24 ^ q >>> 8
        }
    }
    for( e =
         0; 5 > e; e++ ) {
        a[e] = a[e].slice( 0 ), b[e] = b[e].slice( 0 )
    }
}};
function ba( a, b, c ) {
    4 !== b.length && p( new sjcl.exception.invalid( "invalid aes block size" ) );
    var d = a.d[c], e = b[0] ^ d[0], f = b[c ? 3 : 1] ^ d[1], g = b[2] ^ d[2];
    b = b[c ? 1 : 3] ^ d[3];
    var h, k, l, n = d.length / 4 - 2, m, q = 4, t = [0, 0, 0, 0];
    h = a.A[c];
    a = h[0];
    var s = h[1], E = h[2], G = h[3], F = h[4];
    for( m = 0; m < n; m++ ) {
        h = a[e >>> 24] ^ s[f >> 16 & 255] ^ E[g >> 8 & 255] ^ G[b & 255] ^ d[q], k = a[f >>> 24] ^ s[g >> 16 & 255] ^ E[b >> 8 & 255] ^ G[e & 255] ^ d[q + 1], l = a[g >>> 24] ^ s[b >> 16 & 255] ^ E[e >> 8 & 255] ^ G[f & 255] ^ d[q + 2], b = a[b >>> 24] ^ s[e >> 16 & 255] ^ E[f >> 8 & 255] ^ G[g & 255] ^ d[q + 3], q += 4, e = h, f = k, g = l;
    }
    for( m = 0; 4 >
                m; m++ ) {
        t[c ? 3 & -m : m] = F[e >>> 24] << 24 ^ F[f >> 16 & 255] << 16 ^ F[g >> 8 & 255] << 8 ^ F[b & 255] ^ d[q++], h = e, e = f, f = g, g = b, b = h;
    }
    return t
}
sjcl.bitArray = {bitSlice: function( a, b, c ) {
    a = sjcl.bitArray.ea( a.slice( b / 32 ), 32 - (b & 31) ).slice( 1 );
    return c === r ? a : sjcl.bitArray.clamp( a, c - b )
}, extract: function( a, b, c ) {
    var d = Math.floor( -b - c & 31 );
    return((b + c - 1 ^ b) & -32 ? a[b / 32 | 0] << 32 - d ^ a[b / 32 + 1 | 0] >>> d : a[b / 32 | 0] >>> d) & (1 << c) - 1
}, concat: function( a, b ) {
    if( 0 === a.length || 0 === b.length ) {
        return a.concat( b );
    }
    var c = a[a.length - 1], d = sjcl.bitArray.getPartial( c );
    return 32 === d ? a.concat( b ) : sjcl.bitArray.ea( b, d, c | 0, a.slice( 0, a.length - 1 ) )
}, bitLength: function( a ) {
    var b = a.length;
    return 0 ===
           b ? 0 : 32 * (b - 1) + sjcl.bitArray.getPartial( a[b - 1] )
}, clamp: function( a, b ) {
    if( 32 * a.length < b ) {
        return a;
    }
    a = a.slice( 0, Math.ceil( b / 32 ) );
    var c = a.length;
    b &= 31;
    0 < c && b && (a[c - 1] = sjcl.bitArray.partial( b, a[c - 1] & 2147483648 >> b - 1, 1 ));
    return a
}, partial: function( a, b, c ) {
    return 32 === a ? b : (c ? b | 0 : b << 32 - a) + 0x10000000000 * a
}, getPartial: function( a ) {
    return Math.round( a / 0x10000000000 ) || 32
}, equal: function( a, b ) {
    if( sjcl.bitArray.bitLength( a ) !== sjcl.bitArray.bitLength( b ) ) {
        return C;
    }
    var c = 0, d;
    for( d = 0; d < a.length; d++ ) {
        c |= a[d] ^ b[d];
    }
    return 0 ===
           c
}, ea: function( a, b, c, d ) {
    var e;
    e = 0;
    for( d === r && (d = []); 32 <= b; b -= 32 ) {
        d.push( c ), c = 0;
    }
    if( 0 === b ) {
        return d.concat( a );
    }
    for( e = 0; e < a.length; e++ ) {
        d.push( c | a[e] >>> b ), c = a[e] << 32 - b;
    }
    e = a.length ? a[a.length - 1] : 0;
    a = sjcl.bitArray.getPartial( e );
    d.push( sjcl.bitArray.partial( b + a & 31, 32 < b + a ? c : d.pop(), 1 ) );
    return d
}, o: function( a, b ) {
    return[a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]]
}, byteswapM: function( a ) {
    var b, c;
    for( b = 0; b < a.length; ++b ) {
        c = a[b], a[b] = c >>> 24 | c >>> 8 & 0xff00 | (c & 0xff00) << 8 | c << 24;
    }
    return a
}};
sjcl.codec.utf8String = {fromBits: function( a ) {
    var b = "", c = sjcl.bitArray.bitLength( a ), d, e;
    for( d = 0; d < c / 8; d++ ) {
        0 === (d & 3) && (e = a[d / 4]), b += String.fromCharCode( e >>> 24 ), e <<= 8;
    }
    return decodeURIComponent( escape( b ) )
}, toBits: function( a ) {
    a = unescape( encodeURIComponent( a ) );
    var b = [], c, d = 0;
    for( c = 0; c < a.length; c++ ) {
        d = d << 8 | a.charCodeAt( c ), 3 === (c & 3) && (b.push( d ), d = 0);
    }
    c & 3 && b.push( sjcl.bitArray.partial( 8 * (c & 3), d ) );
    return b
}};
sjcl.codec.hex = {fromBits: function( a ) {
    var b = "", c;
    for( c = 0; c < a.length; c++ ) {
        b += ((a[c] | 0) + 0xf00000000000).toString( 16 ).substr( 4 );
    }
    return b.substr( 0, sjcl.bitArray.bitLength( a ) / 4 )
}, toBits: function( a ) {
    var b, c = [], d;
    a = a.replace( /\s|0x/g, "" );
    d = a.length;
    a += "00000000";
    for( b = 0; b < a.length; b += 8 ) {
        c.push( parseInt( a.substr( b, 8 ), 16 ) ^ 0 );
    }
    return sjcl.bitArray.clamp( c, 4 * d )
}};
sjcl.codec.base32 = {D: "0123456789abcdefghjkmnpqrstvwxyz", BITS: 32, BASE: 5, REMAINING: 27, fromBits: function( a ) {
    var b = sjcl.codec.base32.BASE, c = sjcl.codec.base32.REMAINING, d = "", e, f = 0, g = sjcl.codec.base32.D, h = 0, k = sjcl.bitArray.bitLength( a );
    for( e = 0; d.length * b <= k; ) {
        d += g.charAt( (h ^ a[e] >>> f) >>> c ), f < b ? (h = a[e] << b - f, f += c, e++) : (h <<= b, f -= b);
    }
    return d
}, toBits: function( a ) {
    var b = sjcl.codec.base32.BITS, c = sjcl.codec.base32.BASE, d = sjcl.codec.base32.REMAINING, e = [], f, g = 0, h = sjcl.codec.base32.D, k = 0, l;
    for( f = 0; f < a.length; f++ ) {
        l = h.indexOf( a.charAt( f ) ),
            0 > l && p( new sjcl.exception.invalid( "this isn't base32!" ) ), g > d ? (g -= d, e.push( k ^ l >>> g ), k = l << b - g) : (g += c, k ^= l << b - g);
    }
    g & 56 && e.push( sjcl.bitArray.partial( g & 56, k, 1 ) );
    return e
}};
sjcl.codec.base64 = {D: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", fromBits: function( a, b, c ) {
    var d = "", e = 0, f = sjcl.codec.base64.D, g = 0, h = sjcl.bitArray.bitLength( a );
    c && (f = f.substr( 0, 62 ) + "-_");
    for( c = 0; 6 * d.length < h; ) {
        d += f.charAt( (g ^ a[c] >>> e) >>> 26 ), 6 > e ? (g = a[c] << 6 - e, e += 26, c++) : (g <<= 6, e -= 6);
    }
    for( ; d.length & 3 && !b; ) {
        d += "=";
    }
    return d
}, toBits: function( a, b ) {
    a = a.replace( /\s|=/g, "" );
    var c = [], d, e = 0, f = sjcl.codec.base64.D, g = 0, h;
    b && (f = f.substr( 0, 62 ) + "-_");
    for( d = 0; d < a.length; d++ ) {
        h = f.indexOf( a.charAt( d ) ),
            0 > h && p( new sjcl.exception.invalid( "this isn't base64!" ) ), 26 < e ? (e -= 26, c.push( g ^ h >>> e ), g = h << 32 - e) : (e += 6, g ^= h << 32 - e);
    }
    e & 56 && c.push( sjcl.bitArray.partial( e & 56, g, 1 ) );
    return c
}};
sjcl.codec.base64url = {fromBits: function( a ) {
    return sjcl.codec.base64.fromBits( a, 1, 1 )
}, toBits: function( a ) {
    return sjcl.codec.base64.toBits( a, 1 )
}};
sjcl.codec.bytes = {fromBits: function( a ) {
    var b = [], c = sjcl.bitArray.bitLength( a ), d, e;
    for( d = 0; d < c / 8; d++ ) {
        0 === (d & 3) && (e = a[d / 4]), b.push( e >>> 24 ), e <<= 8;
    }
    return b
}, toBits: function( a ) {
    var b = [], c, d = 0;
    for( c = 0; c < a.length; c++ ) {
        d = d << 8 | a[c], 3 === (c & 3) && (b.push( d ), d = 0);
    }
    c & 3 && b.push( sjcl.bitArray.partial( 8 * (c & 3), d ) );
    return b
}};
sjcl.hash.sha256 = function( a ) {
    this.d[0] || this.J();
    a ? (this.h = a.h.slice( 0 ), this.e = a.e.slice( 0 ), this.c = a.c) : this.reset()
};
sjcl.hash.sha256.hash = function( a ) {
    return(new sjcl.hash.sha256).update( a ).finalize()
};
sjcl.hash.sha256.prototype = {blockSize: 512, reset: function() {
    this.h = this.m.slice( 0 );
    this.e = [];
    this.c = 0;
    return this
}, update: function( a ) {
    "string" === typeof a && (a = sjcl.codec.utf8String.toBits( a ));
    var b, c = this.e = sjcl.bitArray.concat( this.e, a );
    b = this.c;
    a = this.c = b + sjcl.bitArray.bitLength( a );
    for( b = 512 + b & -512; b <= a; b += 512 ) {
        this.k( c.splice( 0, 16 ) );
    }
    return this
}, finalize: function() {
    var a, b = this.e, c = this.h, b = sjcl.bitArray.concat( b, [sjcl.bitArray.partial( 1, 1 )] );
    for( a = b.length + 2; a & 15; a++ ) {
        b.push( 0 );
    }
    b.push( Math.floor( this.c /
                        4294967296 ) );
    for( b.push( this.c | 0 ); b.length; ) {
        this.k( b.splice( 0, 16 ) );
    }
    this.reset();
    return c
}, m: [], d: [], J: function() {
    function a( a ) {
        return 0x100000000 * (a - Math.floor( a )) | 0
    }

    var b = 0, c = 2, d;
    a:for( ; 64 > b; c++ ) {
        for( d = 2; d * d <= c; d++ ) {
            if( 0 === c % d ) {
                continue a;
            }
        }
        8 > b && (this.m[b] = a( Math.pow( c, 0.5 ) ));
        this.d[b] = a( Math.pow( c, 1 / 3 ) );
        b++
    }
}, k: function( a ) {
    var b, c, d = a.slice( 0 ), e = this.h, f = this.d, g = e[0], h = e[1], k = e[2], l = e[3], n = e[4], m = e[5], q = e[6], t = e[7];
    for( a = 0; 64 > a; a++ ) {
        16 > a ? b = d[a] : (b = d[a + 1 & 15], c = d[a + 14 & 15], b = d[a & 15] = (b >>> 7 ^ b >>> 18 ^ b >>> 3 ^
                                                                                     b << 25 ^ b << 14) + (c >>> 17 ^ c >>> 19 ^ c >>> 10 ^ c << 15 ^ c << 13) + d[a & 15] + d[a + 9 & 15] | 0), b = b + t + (n >>> 6 ^ n >>> 11 ^ n >>> 25 ^ n << 26 ^ n << 21 ^ n << 7) + (q ^ n & (m ^ q)) + f[a], t = q, q = m, m = n, n = l + b | 0, l = k, k = h, h = g, g = b + (h & k ^ l & (h ^ k)) + (h >>> 2 ^ h >>> 13 ^ h >>> 22 ^ h << 30 ^ h << 19 ^ h << 10) | 0;
    }
    e[0] = e[0] + g | 0;
    e[1] = e[1] + h | 0;
    e[2] = e[2] + k | 0;
    e[3] = e[3] + l | 0;
    e[4] = e[4] + n | 0;
    e[5] = e[5] + m | 0;
    e[6] = e[6] + q | 0;
    e[7] = e[7] + t | 0
}};
sjcl.hash.sha512 = function( a ) {
    this.d[0] || this.J();
    a ? (this.h = a.h.slice( 0 ), this.e = a.e.slice( 0 ), this.c = a.c) : this.reset()
};
sjcl.hash.sha512.hash = function( a ) {
    return(new sjcl.hash.sha512).update( a ).finalize()
};
sjcl.hash.sha512.prototype = {blockSize: 1024, reset: function() {
    this.h = this.m.slice( 0 );
    this.e = [];
    this.c = 0;
    return this
}, update: function( a ) {
    "string" === typeof a && (a = sjcl.codec.utf8String.toBits( a ));
    var b, c = this.e = sjcl.bitArray.concat( this.e, a );
    b = this.c;
    a = this.c = b + sjcl.bitArray.bitLength( a );
    for( b = 1024 + b & -1024; b <= a; b += 1024 ) {
        this.k( c.splice( 0, 32 ) );
    }
    return this
}, finalize: function() {
    var a, b = this.e, c = this.h, b = sjcl.bitArray.concat( b, [sjcl.bitArray.partial( 1, 1 )] );
    for( a = b.length + 4; a & 31; a++ ) {
        b.push( 0 );
    }
    b.push( 0 );
    b.push( 0 );
    b.push( Math.floor( this.c / 0x100000000 ) );
    for( b.push( this.c | 0 ); b.length; ) {
        this.k( b.splice( 0, 32 ) );
    }
    this.reset();
    return c
}, m: [], ra: [12372232, 13281083, 9762859, 1914609, 15106769, 4090911, 4308331, 8266105], d: [], ta: [2666018, 15689165, 5061423, 9034684, 4764984, 380953, 1658779, 7176472, 197186, 7368638, 14987916, 16757986, 8096111, 1480369, 13046325, 6891156, 15813330, 5187043, 9229749, 11312229, 2818677, 10937475, 4324308, 1135541, 6741931, 11809296, 16458047, 15666916, 11046850, 698149, 229999, 945776, 13774844, 2541862, 12856045, 9810911, 11494366,
    7844520, 15576806, 8533307, 15795044, 4337665, 16291729, 5553712, 15684120, 6662416, 7413802, 12308920, 13816008, 4303699, 9366425, 10176680, 13195875, 4295371, 6546291, 11712675, 15708924, 1519456, 15772530, 6568428, 6495784, 8568297, 13007125, 7492395, 2515356, 12632583, 14740254, 7262584, 1535930, 13146278, 16321966, 1853211, 294276, 13051027, 13221564, 1051980, 4080310, 6651434, 14088940, 4675607], J: function() {
    function a( a ) {
        return 0x100000000 * (a - Math.floor( a )) | 0
    }

    function b( a ) {
        return 0x10000000000 * (a - Math.floor( a )) & 255
    }

    var c = 0, d = 2, e;
    a:for( ; 80 >
             c; d++ ) {
        for( e = 2; e * e <= d; e++ ) {
            if( 0 === d % e ) {
                continue a;
            }
        }
        8 > c && (this.m[2 * c] = a( Math.pow( d, 0.5 ) ), this.m[2 * c + 1] = b( Math.pow( d, 0.5 ) ) << 24 | this.ra[c]);
        this.d[2 * c] = a( Math.pow( d, 1 / 3 ) );
        this.d[2 * c + 1] = b( Math.pow( d, 1 / 3 ) ) << 24 | this.ta[c];
        c++
    }
}, k: function( a ) {
    var b, c, d = a.slice( 0 ), e = this.h, f = this.d, g = e[0], h = e[1], k = e[2], l = e[3], n = e[4], m = e[5], q = e[6], t = e[7], s = e[8], E = e[9], G = e[10], F = e[11], ha = e[12], S = e[13], ia = e[14], T = e[15], y = g, w = h, J = k, H = l, K = n, I = m, Y = q, L = t, z = s, x = E, U = G, M = F, V = ha, N = S, Z = ia, O = T;
    for( a = 0; 80 > a; a++ ) {
        if( 16 > a ) {
            b = d[2 * a], c = d[2 * a +
                                1];
        } else {
            c = d[2 * (a - 15)];
            var u = d[2 * (a - 15) + 1];
            b = (u << 31 | c >>> 1) ^ (u << 24 | c >>> 8) ^ c >>> 7;
            var A = (c << 31 | u >>> 1) ^ (c << 24 | u >>> 8) ^ (c << 25 | u >>> 7);
            c = d[2 * (a - 2)];
            var B = d[2 * (a - 2) + 1], u = (B << 13 | c >>> 19) ^ (c << 3 | B >>> 29) ^ c >>> 6, B = (c << 13 | B >>> 19) ^ (B << 3 | c >>> 29) ^ (c << 26 | B >>> 6), $ = d[2 * (a - 7)], aa = d[2 * (a - 16)], P = d[2 * (a - 16) + 1];
            c = A + d[2 * (a - 7) + 1];
            b = b + $ + (c >>> 0 < A >>> 0 ? 1 : 0);
            c += B;
            b += u + (c >>> 0 < B >>> 0 ? 1 : 0);
            c += P;
            b += aa + (c >>> 0 < P >>> 0 ? 1 : 0)
        }
        d[2 * a] = b |= 0;
        d[2 * a + 1] = c |= 0;
        var $ = z & U ^ ~z & V, ja = x & M ^ ~x & N, B = y & J ^ y & K ^ J & K, na = w & H ^ w & I ^ H & I, aa = (w << 4 | y >>> 28) ^ (y << 30 | w >>> 2) ^ (y << 25 |
                                                                                                                                                              w >>> 7), P = (y << 4 | w >>> 28) ^ (w << 30 | y >>> 2) ^ (w << 25 | y >>> 7), oa = f[2 * a], ka = f[2 * a + 1], u = O + ((z << 18 | x >>> 14) ^ (z << 14 | x >>> 18) ^ (x << 23 | z >>> 9)), A = Z + ((x << 18 | z >>> 14) ^ (x << 14 | z >>> 18) ^ (z << 23 | x >>> 9)) + (u >>> 0 < O >>> 0 ? 1 : 0), u = u + ja, A = A + ($ + (u >>> 0 < ja >>> 0 ? 1 : 0)), u = u + ka, A = A + (oa + (u >>> 0 < ka >>> 0 ? 1 : 0)), u = u + c | 0, A = A + (b + (u >>> 0 < c >>> 0 ? 1 : 0));
        c = P + na;
        b = aa + B + (c >>> 0 < P >>> 0 ? 1 : 0);
        Z = V;
        O = N;
        V = U;
        N = M;
        U = z;
        M = x;
        x = L + u | 0;
        z = Y + A + (x >>> 0 < L >>> 0 ? 1 : 0) | 0;
        Y = K;
        L = I;
        K = J;
        I = H;
        J = y;
        H = w;
        w = u + c | 0;
        y = A + b + (w >>> 0 < u >>> 0 ? 1 : 0) | 0
    }
    h = e[1] = h + w | 0;
    e[0] = g + y + (h >>> 0 < w >>> 0 ? 1 : 0) | 0;
    l = e[3] = l + H | 0;
    e[2] =
    k + J + (l >>> 0 < H >>> 0 ? 1 : 0) | 0;
    m = e[5] = m + I | 0;
    e[4] = n + K + (m >>> 0 < I >>> 0 ? 1 : 0) | 0;
    t = e[7] = t + L | 0;
    e[6] = q + Y + (t >>> 0 < L >>> 0 ? 1 : 0) | 0;
    E = e[9] = E + x | 0;
    e[8] = s + z + (E >>> 0 < x >>> 0 ? 1 : 0) | 0;
    F = e[11] = F + M | 0;
    e[10] = G + U + (F >>> 0 < M >>> 0 ? 1 : 0) | 0;
    S = e[13] = S + N | 0;
    e[12] = ha + V + (S >>> 0 < N >>> 0 ? 1 : 0) | 0;
    T = e[15] = T + O | 0;
    e[14] = ia + Z + (T >>> 0 < O >>> 0 ? 1 : 0) | 0
}};
sjcl.hash.sha1 = function( a ) {
    a ? (this.h = a.h.slice( 0 ), this.e = a.e.slice( 0 ), this.c = a.c) : this.reset()
};
sjcl.hash.sha1.hash = function( a ) {
    return(new sjcl.hash.sha1).update( a ).finalize()
};
sjcl.hash.sha1.prototype = {blockSize: 512, reset: function() {
    this.h = this.m.slice( 0 );
    this.e = [];
    this.c = 0;
    return this
}, update: function( a ) {
    "string" === typeof a && (a = sjcl.codec.utf8String.toBits( a ));
    var b, c = this.e = sjcl.bitArray.concat( this.e, a );
    b = this.c;
    a = this.c = b + sjcl.bitArray.bitLength( a );
    for( b = this.blockSize + b & -this.blockSize; b <= a; b += this.blockSize ) {
        this.k( c.splice( 0, 16 ) );
    }
    return this
}, finalize: function() {
    var a, b = this.e, c = this.h, b = sjcl.bitArray.concat( b, [sjcl.bitArray.partial( 1, 1 )] );
    for( a = b.length + 2; a & 15; a++ ) {
        b.push( 0 );
    }
    b.push( Math.floor( this.c / 0x100000000 ) );
    for( b.push( this.c | 0 ); b.length; ) {
        this.k( b.splice( 0, 16 ) );
    }
    this.reset();
    return c
}, m: [1732584193, 4023233417, 2562383102, 271733878, 3285377520], d: [1518500249, 1859775393, 2400959708, 3395469782], k: function( a ) {
    var b, c, d, e, f, g, h = a.slice( 0 ), k = this.h;
    c = k[0];
    d = k[1];
    e = k[2];
    f = k[3];
    g = k[4];
    for( a = 0; 79 >= a; a++ ) {
        16 <= a && (h[a] = (h[a - 3] ^ h[a - 8] ^ h[a - 14] ^ h[a - 16]) << 1 | (h[a - 3] ^ h[a - 8] ^ h[a - 14] ^ h[a - 16]) >>> 31), b = 19 >= a ? d & e | ~d & f : 39 >= a ? d ^ e ^ f : 59 >= a ? d & e | d & f | e & f : 79 >= a ? d ^ e ^ f : r, b = (c << 5 | c >>> 27) + b + g + h[a] + this.d[Math.floor( a /
                                                                                                                                                                                                                                                                                                                   20 )] | 0, g = f, f = e, e = d << 30 | d >>> 2, d = c, c = b;
    }
    k[0] = k[0] + c | 0;
    k[1] = k[1] + d | 0;
    k[2] = k[2] + e | 0;
    k[3] = k[3] + f | 0;
    k[4] = k[4] + g | 0
}};
sjcl.mode.ccm = {name: "ccm", encrypt: function( a, b, c, d, e ) {
    var f, g = b.slice( 0 ), h = sjcl.bitArray, k = h.bitLength( c ) / 8, l = h.bitLength( g ) / 8;
    e = e || 64;
    d = d || [];
    7 > k && p( new sjcl.exception.invalid( "ccm: iv must be at least 7 bytes" ) );
    for( f = 2; 4 > f && l >>> 8 * f; f++ ) {
        ;
    }
    f < 15 - k && (f = 15 - k);
    c = h.clamp( c, 8 * (15 - f) );
    b = sjcl.mode.ccm.Y( a, b, c, d, e, f );
    g = sjcl.mode.ccm.F( a, g, c, b, e, f );
    return h.concat( g.data, g.tag )
}, decrypt: function( a, b, c, d, e ) {
    e = e || 64;
    d = d || [];
    var f = sjcl.bitArray, g = f.bitLength( c ) / 8, h = f.bitLength( b ), k = f.clamp( b, h - e ), l = f.bitSlice( b,
        h - e ), h = (h - e) / 8;
    7 > g && p( new sjcl.exception.invalid( "ccm: iv must be at least 7 bytes" ) );
    for( b = 2; 4 > b && h >>> 8 * b; b++ ) {
        ;
    }
    b < 15 - g && (b = 15 - g);
    c = f.clamp( c, 8 * (15 - b) );
    k = sjcl.mode.ccm.F( a, k, c, l, e, b );
    a = sjcl.mode.ccm.Y( a, k.data, c, d, e, b );
    f.equal( k.tag, a ) || p( new sjcl.exception.corrupt( "ccm: tag doesn't match" ) );
    return k.data
}, Y: function( a, b, c, d, e, f ) {
    var g = [], h = sjcl.bitArray, k = h.o;
    e /= 8;
    (e % 2 || 4 > e || 16 < e) && p( new sjcl.exception.invalid( "ccm: invalid tag length" ) );
    (0xffffffff < d.length || 0xffffffff < b.length) && p( new sjcl.exception.bug( "ccm: can't deal with 4GiB or more data" ) );
    f = [h.partial( 8, (d.length ? 64 : 0) | e - 2 << 2 | f - 1 )];
    f = h.concat( f, c );
    f[3] |= h.bitLength( b ) / 8;
    f = a.encrypt( f );
    if( d.length ) {
        c = h.bitLength( d ) / 8;
        65279 >= c ? g = [h.partial( 16, c )] : 0xffffffff >= c && (g = h.concat( [h.partial( 16, 65534 )], [c] ));
        g = h.concat( g, d );
        for( d = 0; d < g.length; d += 4 ) {
            f = a.encrypt( k( f, g.slice( d, d + 4 ).concat( [0, 0, 0] ) ) )
        }
    }
    for( d = 0; d < b.length; d += 4 ) {
        f = a.encrypt( k( f, b.slice( d, d + 4 ).concat( [0, 0, 0] ) ) );
    }
    return h.clamp( f, 8 * e )
}, F: function( a, b, c, d, e, f ) {
    var g, h = sjcl.bitArray;
    g = h.o;
    var k = b.length, l = h.bitLength( b );
    c = h.concat( [h.partial( 8,
        f - 1 )], c ).concat( [0, 0, 0] ).slice( 0, 4 );
    d = h.bitSlice( g( d, a.encrypt( c ) ), 0, e );
    if( !k ) {
        return{tag: d, data: []};
    }
    for( g = 0; g < k; g += 4 ) {
        c[3]++, e = a.encrypt( c ), b[g] ^= e[0], b[g + 1] ^= e[1], b[g + 2] ^= e[2], b[g + 3] ^= e[3];
    }
    return{tag: d, data: h.clamp( b, l )}
}};
sjcl.beware === r && (sjcl.beware = {});
sjcl.beware["CBC mode is dangerous because it doesn't protect message integrity."] = function() {
    sjcl.mode.cbc = {name: "cbc", encrypt: function( a, b, c, d ) {
        d && d.length && p( new sjcl.exception.invalid( "cbc can't authenticate data" ) );
        128 !== sjcl.bitArray.bitLength( c ) && p( new sjcl.exception.invalid( "cbc iv must be 128 bits" ) );
        var e = sjcl.bitArray, f = e.o, g = e.bitLength( b ), h = 0, k = [];
        g & 7 && p( new sjcl.exception.invalid( "pkcs#5 padding only works for multiples of a byte" ) );
        for( d = 0; h + 128 <= g; d += 4, h += 128 ) {
            c = a.encrypt( f( c, b.slice( d,
                d + 4 ) ) ), k.splice( d, 0, c[0], c[1], c[2], c[3] );
        }
        g = 0x1010101 * (16 - (g >> 3 & 15));
        c = a.encrypt( f( c, e.concat( b, [g, g, g, g] ).slice( d, d + 4 ) ) );
        k.splice( d, 0, c[0], c[1], c[2], c[3] );
        return k
    }, decrypt: function( a, b, c, d ) {
        d && d.length && p( new sjcl.exception.invalid( "cbc can't authenticate data" ) );
        128 !== sjcl.bitArray.bitLength( c ) && p( new sjcl.exception.invalid( "cbc iv must be 128 bits" ) );
        (sjcl.bitArray.bitLength( b ) & 127 || !b.length) && p( new sjcl.exception.corrupt( "cbc ciphertext must be a positive multiple of the block size" ) );
        var e = sjcl.bitArray,
            f = e.o, g, h = [];
        for( d = 0; d < b.length; d += 4 ) {
            g = b.slice( d, d + 4 ), c = f( c, a.decrypt( g ) ), h.splice( d, 0, c[0], c[1], c[2], c[3] ), c = g;
        }
        g = h[d - 1] & 255;
        (0 === g || 16 < g) && p( new sjcl.exception.corrupt( "pkcs#5 padding corrupt" ) );
        c = 0x1010101 * g;
        e.equal( e.bitSlice( [c, c, c, c], 0, 8 * g ), e.bitSlice( h, 32 * h.length - 8 * g, 32 * h.length ) ) || p( new sjcl.exception.corrupt( "pkcs#5 padding corrupt" ) );
        return e.bitSlice( h, 0, 32 * h.length - 8 * g )
    }}
};
sjcl.mode.ocb2 = {name: "ocb2", encrypt: function( a, b, c, d, e, f ) {
    128 !== sjcl.bitArray.bitLength( c ) && p( new sjcl.exception.invalid( "ocb iv must be 128 bits" ) );
    var g, h = sjcl.mode.ocb2.V, k = sjcl.bitArray, l = k.o, n = [0, 0, 0, 0];
    c = h( a.encrypt( c ) );
    var m, q = [];
    d = d || [];
    e = e || 64;
    for( g = 0; g + 4 < b.length; g += 4 ) {
        m = b.slice( g, g + 4 ), n = l( n, m ), q = q.concat( l( c, a.encrypt( l( c, m ) ) ) ), c = h( c );
    }
    m = b.slice( g );
    b = k.bitLength( m );
    g = a.encrypt( l( c, [0, 0, 0, b] ) );
    m = k.clamp( l( m.concat( [0, 0, 0] ), g ), b );
    n = l( n, l( m.concat( [0, 0, 0] ), g ) );
    n = a.encrypt( l( n, l( c, h( c ) ) ) );
    d.length &&
    (n = l( n, f ? d : sjcl.mode.ocb2.pmac( a, d ) ));
    return q.concat( k.concat( m, k.clamp( n, e ) ) )
}, decrypt: function( a, b, c, d, e, f ) {
    128 !== sjcl.bitArray.bitLength( c ) && p( new sjcl.exception.invalid( "ocb iv must be 128 bits" ) );
    e = e || 64;
    var g = sjcl.mode.ocb2.V, h = sjcl.bitArray, k = h.o, l = [0, 0, 0, 0], n = g( a.encrypt( c ) ), m, q, t = sjcl.bitArray.bitLength( b ) - e, s = [];
    d = d || [];
    for( c = 0; c + 4 < t / 32; c += 4 ) {
        m = k( n, a.decrypt( k( n, b.slice( c, c + 4 ) ) ) ), l = k( l, m ), s = s.concat( m ), n = g( n );
    }
    q = t - 32 * c;
    m = a.encrypt( k( n, [0, 0, 0, q] ) );
    m = k( m, h.clamp( b.slice( c ), q ).concat( [0, 0, 0] ) );
    l = k( l, m );
    l = a.encrypt( k( l, k( n, g( n ) ) ) );
    d.length && (l = k( l, f ? d : sjcl.mode.ocb2.pmac( a, d ) ));
    h.equal( h.clamp( l, e ), h.bitSlice( b, t ) ) || p( new sjcl.exception.corrupt( "ocb: tag doesn't match" ) );
    return s.concat( h.clamp( m, q ) )
}, pmac: function( a, b ) {
    var c, d = sjcl.mode.ocb2.V, e = sjcl.bitArray, f = e.o, g = [0, 0, 0, 0], h = a.encrypt( [0, 0, 0, 0] ), h = f( h, d( d( h ) ) );
    for( c = 0; c + 4 < b.length; c += 4 ) {
        h = d( h ), g = f( g, a.encrypt( f( h, b.slice( c, c + 4 ) ) ) );
    }
    c = b.slice( c );
    128 > e.bitLength( c ) && (h = f( h, d( h ) ), c = e.concat( c, [-2147483648, 0, 0, 0] ));
    g = f( g, c );
    return a.encrypt( f( d( f( h,
        d( h ) ) ), g ) )
}, V: function( a ) {
    return[a[0] << 1 ^ a[1] >>> 31, a[1] << 1 ^ a[2] >>> 31, a[2] << 1 ^ a[3] >>> 31, a[3] << 1 ^ 135 * (a[0] >>> 31)]
}};
sjcl.mode.gcm = {name: "gcm", encrypt: function( a, b, c, d, e ) {
    var f = b.slice( 0 );
    b = sjcl.bitArray;
    d = d || [];
    a = sjcl.mode.gcm.F( v, a, f, d, c, e || 128 );
    return b.concat( a.data, a.tag )
}, decrypt: function( a, b, c, d, e ) {
    var f = b.slice( 0 ), g = sjcl.bitArray, h = g.bitLength( f );
    e = e || 128;
    d = d || [];
    e <= h ? (b = g.bitSlice( f, h - e ), f = g.bitSlice( f, 0, h - e )) : (b = f, f = []);
    a = sjcl.mode.gcm.F( C, a, f, d, c, e );
    g.equal( a.tag, b ) || p( new sjcl.exception.corrupt( "gcm: tag doesn't match" ) );
    return a.data
}, pa: function( a, b ) {
    var c, d, e, f, g, h = sjcl.bitArray.o;
    e = [0, 0, 0, 0];
    f = b.slice( 0 );
    for( c = 0; 128 > c; c++ ) {
        (d = 0 !== (a[Math.floor( c / 32 )] & 1 << 31 - c % 32)) && (e = h( e, f ));
        g = 0 !== (f[3] & 1);
        for( d = 3; 0 < d; d-- ) {
            f[d] = f[d] >>> 1 | (f[d - 1] & 1) << 31;
        }
        f[0] >>>= 1;
        g && (f[0] ^= -0x1f000000)
    }
    return e
}, t: function( a, b, c ) {
    var d, e = c.length;
    b = b.slice( 0 );
    for( d = 0; d < e; d += 4 ) {
        b[0] ^= 0xffffffff & c[d], b[1] ^= 0xffffffff & c[d + 1], b[2] ^= 0xffffffff & c[d + 2], b[3] ^= 0xffffffff & c[d + 3], b = sjcl.mode.gcm.pa( b, a );
    }
    return b
}, F: function( a, b, c, d, e, f ) {
    var g, h, k, l, n, m, q, t, s = sjcl.bitArray;
    m = c.length;
    q = s.bitLength( c );
    t = s.bitLength( d );
    h = s.bitLength( e );
    g = b.encrypt( [0,
        0, 0, 0] );
    96 === h ? (e = e.slice( 0 ), e = s.concat( e, [1] )) : (e = sjcl.mode.gcm.t( g, [0, 0, 0, 0], e ), e = sjcl.mode.gcm.t( g, e, [0, 0, Math.floor( h / 0x100000000 ), h & 0xffffffff] ));
    h = sjcl.mode.gcm.t( g, [0, 0, 0, 0], d );
    n = e.slice( 0 );
    d = h.slice( 0 );
    a || (d = sjcl.mode.gcm.t( g, h, c ));
    for( l = 0; l < m; l += 4 ) {
        n[3]++, k = b.encrypt( n ), c[l] ^= k[0], c[l + 1] ^= k[1], c[l + 2] ^= k[2], c[l + 3] ^= k[3];
    }
    c = s.clamp( c, q );
    a && (d = sjcl.mode.gcm.t( g, h, c ));
    a = [Math.floor( t / 0x100000000 ), t & 0xffffffff, Math.floor( q / 0x100000000 ), q & 0xffffffff];
    d = sjcl.mode.gcm.t( g, d, a );
    k = b.encrypt( e );
    d[0] ^= k[0];
    d[1] ^= k[1];
    d[2] ^= k[2];
    d[3] ^= k[3];
    return{tag: s.bitSlice( d, 0, f ), data: c}
}};
sjcl.misc.hmac = function( a, b ) {
    this.$ = b = b || sjcl.hash.sha256;
    var c = [
        [],
        []
    ], d, e = b.prototype.blockSize / 32;
    this.C = [new b, new b];
    a.length > e && (a = b.hash( a ));
    for( d = 0; d < e; d++ ) {
        c[0][d] = a[d] ^ 909522486, c[1][d] = a[d] ^ 1549556828;
    }
    this.C[0].update( c[0] );
    this.C[1].update( c[1] );
    this.U = new b( this.C[0] )
};
sjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function( a ) {
    this.ga && p( new sjcl.exception.invalid( "encrypt on already updated hmac called!" ) );
    this.update( a );
    return this.digest( a )
};
sjcl.misc.hmac.prototype.reset = function() {
    this.U = new this.$( this.C[0] );
    this.ga = C
};
sjcl.misc.hmac.prototype.update = function( a ) {
    this.ga = v;
    this.U.update( a )
};
sjcl.misc.hmac.prototype.digest = function() {
    var a = this.U.finalize(), a = (new this.$( this.C[1] )).update( a ).finalize();
    this.reset();
    return a
};
sjcl.misc.pbkdf2 = function( a, b, c, d, e ) {
    c = c || 1E3;
    (0 > d || 0 > c) && p( sjcl.exception.invalid( "invalid params to pbkdf2" ) );
    "string" === typeof a && (a = sjcl.codec.utf8String.toBits( a ));
    "string" === typeof b && (b = sjcl.codec.utf8String.toBits( b ));
    e = e || sjcl.misc.hmac;
    a = new e( a );
    var f, g, h, k, l = [], n = sjcl.bitArray;
    for( k = 1; 32 * l.length < (d || 1); k++ ) {
        e = f = a.encrypt( n.concat( b, [k] ) );
        for( g = 1; g < c; g++ ) {
            f = a.encrypt( f );
            for( h = 0; h < f.length; h++ ) {
                e[h] ^= f[h]
            }
        }
        l = l.concat( e )
    }
    d && (l = n.clamp( l, d ));
    return l
};
sjcl.prng = function( a ) {
    this.j = [new sjcl.hash.sha256];
    this.u = [0];
    this.T = 0;
    this.L = {};
    this.S = 0;
    this.X = {};
    this.da = this.n = this.w = this.ma = 0;
    this.d = [0, 0, 0, 0, 0, 0, 0, 0];
    this.q = [0, 0, 0, 0];
    this.Q = r;
    this.R = a;
    this.K = C;
    this.P = {progress: {}, seeded: {}};
    this.B = this.la = 0;
    this.M = 1;
    this.O = 2;
    this.ia = 0x10000;
    this.W = [0, 48, 64, 96, 128, 192, 0x100, 384, 512, 768, 1024];
    this.ja = 3E4;
    this.ha = 80
};
sjcl.prng.prototype = {randomWords: function( a, b ) {
    var c = [], d;
    d = this.isReady( b );
    var e;
    d === this.B && p( new sjcl.exception.notReady( "generator isn't seeded" ) );
    if( d & this.O ) {
        d = !(d & this.M);
        e = [];
        var f = 0, g;
        this.da = e[0] = (new Date).valueOf() + this.ja;
        for( g = 0; 16 > g; g++ ) {
            e.push( 0x100000000 * Math.random() | 0 );
        }
        for( g = 0; g < this.j.length && !(e = e.concat( this.j[g].finalize() ), f += this.u[g], this.u[g] = 0, !d && this.T & 1 << g); g++ ) {
            ;
        }
        this.T >= 1 << this.j.length && (this.j.push( new sjcl.hash.sha256 ), this.u.push( 0 ));
        this.n -= f;
        f > this.w && (this.w = f);
        this.T++;
        this.d = sjcl.hash.sha256.hash( this.d.concat( e ) );
        this.Q = new sjcl.cipher.aes( this.d );
        for( d = 0; 4 > d && !(this.q[d] = this.q[d] + 1 | 0, this.q[d]); d++ ) {
            ;
        }
    }
    for( d = 0; d < a; d += 4 ) {
        0 === (d + 1) % this.ia && ca( this ), e = da( this ), c.push( e[0], e[1], e[2], e[3] );
    }
    ca( this );
    return c.slice( 0, a )
}, setDefaultParanoia: function( a, b ) {
    0 === a && "Setting paranoia=0 will ruin your security; use it only for testing" !== b && p( "Setting paranoia=0 will ruin your security; use it only for testing" );
    this.R = a
}, addEntropy: function( a, b, c ) {
    c = c || "user";
    var d,
        e, f = (new Date).valueOf(), g = this.L[c], h = this.isReady(), k = 0;
    d = this.X[c];
    d === r && (d = this.X[c] = this.ma++);
    g === r && (g = this.L[c] = 0);
    this.L[c] = (this.L[c] + 1) % this.j.length;
    switch( typeof a ) {
        case "number":
            b === r && (b = 1);
            this.j[g].update( [d, this.S++, 1, b, f, 1, a | 0] );
            break;
        case "object":
            c = Object.prototype.toString.call( a );
            if( "[object Uint32Array]" === c ) {
                e = [];
                for( c = 0; c < a.length; c++ ) {
                    e.push( a[c] );
                }
                a = e
            } else {
                "[object Array]" !== c && (k = 1);
                for( c = 0; c < a.length && !k; c++ ) {
                    "number" !== typeof a[c] && (k = 1)
                }
            }
            if( !k ) {
                if( b === r ) {
                    for( c = b = 0; c < a.length; c++ ) {
                        for( e =
                             a[c]; 0 < e; ) {
                            b++, e >>>= 1;
                        }
                    }
                }
                this.j[g].update( [d, this.S++, 2, b, f, a.length].concat( a ) )
            }
            break;
        case "string":
            b === r && (b = a.length);
            this.j[g].update( [d, this.S++, 3, b, f, a.length] );
            this.j[g].update( a );
            break;
        default:
            k = 1
    }
    k && p( new sjcl.exception.bug( "random: addEntropy only supports number, array of numbers or string" ) );
    this.u[g] += b;
    this.n += b;
    h === this.B && (this.isReady() !== this.B && ea( "seeded", Math.max( this.w, this.n ) ), ea( "progress", this.getProgress() ))
}, isReady: function( a ) {
    a = this.W[a !== r ? a : this.R];
    return this.w && this.w >=
                     a ? this.u[0] > this.ha && (new Date).valueOf() > this.da ? this.O | this.M : this.M : this.n >= a ? this.O | this.B : this.B
}, getProgress: function( a ) {
    a = this.W[a ? a : this.R];
    return this.w >= a ? 1 : this.n > a ? 1 : this.n / a
}, startCollectors: function() {
    this.K || (this.f = {loadTimeCollector: D( this, this.ua ), mouseCollector: D( this, this.va ), keyboardCollector: D( this, this.sa ), accelerometerCollector: D( this, this.ka ), touchCollector: D( this, this.xa )}, window.addEventListener ? (window.addEventListener( "load", this.f.loadTimeCollector, C ), window.addEventListener( "mousemove",
        this.f.mouseCollector, C ), window.addEventListener( "keypress", this.f.keyboardCollector, C ), window.addEventListener( "devicemotion", this.f.accelerometerCollector, C ), window.addEventListener( "touchmove", this.f.touchCollector, C )) : document.attachEvent ? (document.attachEvent( "onload", this.f.loadTimeCollector ), document.attachEvent( "onmousemove", this.f.mouseCollector ), document.attachEvent( "keypress", this.f.keyboardCollector )) : p( new sjcl.exception.bug( "can't attach event" ) ), this.K = v)
}, stopCollectors: function() {
    this.K &&
    (window.removeEventListener ? (window.removeEventListener( "load", this.f.loadTimeCollector, C ), window.removeEventListener( "mousemove", this.f.mouseCollector, C ), window.removeEventListener( "keypress", this.f.keyboardCollector, C ), window.removeEventListener( "devicemotion", this.f.accelerometerCollector, C ), window.removeEventListener( "touchmove", this.f.touchCollector, C )) : document.detachEvent && (document.detachEvent( "onload", this.f.loadTimeCollector ), document.detachEvent( "onmousemove", this.f.mouseCollector ), document.detachEvent( "keypress",
        this.f.keyboardCollector )), this.K = C)
}, addEventListener: function( a, b ) {
    this.P[a][this.la++] = b
}, removeEventListener: function( a, b ) {
    var c, d, e = this.P[a], f = [];
    for( d in e ) {
        e.hasOwnProperty( d ) && e[d] === b && f.push( d );
    }
    for( c = 0; c < f.length; c++ ) {
        d = f[c], delete e[d]
    }
}, sa: function() {
    Q( 1 )
}, va: function( a ) {
    var b, c;
    try {
        b = a.x || a.clientX || a.offsetX || 0, c = a.y || a.clientY || a.offsetY || 0
    } catch( d ) {
        c = b = 0
    }
    0 != b && 0 != c && sjcl.random.addEntropy( [b, c], 2, "mouse" );
    Q( 0 )
}, xa: function( a ) {
    a = a.touches[0] || a.changedTouches[0];
    sjcl.random.addEntropy( [a.pageX ||
                             a.clientX, a.pageY || a.clientY], 1, "touch" );
    Q( 0 )
}, ua: function() {
    Q( 2 )
}, ka: function( a ) {
    a = a.accelerationIncludingGravity.x || a.accelerationIncludingGravity.y || a.accelerationIncludingGravity.z;
    if( window.orientation ) {
        var b = window.orientation;
        "number" === typeof b && sjcl.random.addEntropy( b, 1, "accelerometer" )
    }
    a && sjcl.random.addEntropy( a, 2, "accelerometer" );
    Q( 0 )
}};
function ea( a, b ) {
    var c, d = sjcl.random.P[a], e = [];
    for( c in d ) {
        d.hasOwnProperty( c ) && e.push( d[c] );
    }
    for( c = 0; c < e.length; c++ ) {
        e[c]( b )
    }
}
function Q( a ) {
    "undefined" !== typeof window && window.performance && "function" === typeof window.performance.now ? sjcl.random.addEntropy( window.performance.now(), a, "loadtime" ) : sjcl.random.addEntropy( (new Date).valueOf(), a, "loadtime" )
}
function ca( a ) {
    a.d = da( a ).concat( da( a ) );
    a.Q = new sjcl.cipher.aes( a.d )
}
function da( a ) {
    for( var b = 0; 4 > b && !(a.q[b] = a.q[b] + 1 | 0, a.q[b]); b++ ) {
        ;
    }
    return a.Q.encrypt( a.q )
}
function D( a, b ) {
    return function() {
        b.apply( a, arguments )
    }
}
sjcl.random = new sjcl.prng( 6 );
a:try {
    var R, fa, W, ga;
    if( ga = "undefined" !== typeof module ) {
        var la;
        if( la = module.exports ) {
            var ma;
            try {
                ma = require( "crypto" )
            } catch( pa ) {
                ma = null
            }
            la = (fa = ma) && fa.randomBytes
        }
        ga = la
    }
    if( ga ) {
        R = fa.randomBytes( 128 ), R = new Uint32Array( (new Uint8Array( R )).buffer ), sjcl.random.addEntropy( R, 1024, "crypto['randomBytes']" );
    } else if( "undefined" !== typeof window && "undefined" !== typeof Uint32Array ) {
        W = new Uint32Array( 32 );
        if( window.crypto && window.crypto.getRandomValues ) {
            window.crypto.getRandomValues( W );
        } else if( window.msCrypto && window.msCrypto.getRandomValues ) {
            window.msCrypto.getRandomValues( W );
        }
        else {
            break a;
        }
        sjcl.random.addEntropy( W, 1024, "crypto['getRandomValues']" )
    }
} catch( qa ) {
    "undefined" !== typeof window && window.console && (console.log( "There was an error collecting entropy from the browser:" ), console.log( qa ))
}
sjcl.json = {defaults: {v: 1, iter: 1E3, ks: 128, ts: 64, mode: "ccm", adata: "", cipher: "aes"}, oa: function( a, b, c, d ) {
    c = c || {};
    d = d || {};
    var e = sjcl.json, f = e.p( {iv: sjcl.random.randomWords( 4, 0 )}, e.defaults ), g;
    e.p( f, c );
    c = f.adata;
    "string" === typeof f.salt && (f.salt = sjcl.codec.base64.toBits( f.salt ));
    "string" === typeof f.iv && (f.iv = sjcl.codec.base64.toBits( f.iv ));
    (!sjcl.mode[f.mode] || !sjcl.cipher[f.cipher] || "string" === typeof a && 100 >= f.iter || 64 !== f.ts && 96 !== f.ts && 128 !== f.ts || 128 !== f.ks && 192 !== f.ks && 0x100 !== f.ks || 2 > f.iv.length ||
     4 < f.iv.length) && p( new sjcl.exception.invalid( "json encrypt: invalid parameters" ) );
    "string" === typeof a ? (g = sjcl.misc.cachedPbkdf2( a, f ), a = g.key.slice( 0, f.ks / 32 ), f.salt = g.salt) : sjcl.ecc && a instanceof sjcl.ecc.elGamal.publicKey && (g = a.kem(), f.kemtag = g.tag, a = g.key.slice( 0, f.ks / 32 ));
    "string" === typeof b && (b = sjcl.codec.utf8String.toBits( b ));
    "string" === typeof c && (f.adata = c = sjcl.codec.utf8String.toBits( c ));
    g = new sjcl.cipher[f.cipher]( a );
    e.p( d, f );
    d.key = a;
    f.ct = sjcl.mode[f.mode].encrypt( g, b, f.iv, c, f.ts );
    return f
},
    encrypt: function( a, b, c, d ) {
        var e = sjcl.json, f = e.oa.apply( e, arguments );
        return e.encode( f )
    }, na: function( a, b, c, d ) {
        c = c || {};
        d = d || {};
        var e = sjcl.json;
        b = e.p( e.p( e.p( {}, e.defaults ), b ), c, v );
        var f, g;
        f = b.adata;
        "string" === typeof b.salt && (b.salt = sjcl.codec.base64.toBits( b.salt ));
        "string" === typeof b.iv && (b.iv = sjcl.codec.base64.toBits( b.iv ));
        (!sjcl.mode[b.mode] || !sjcl.cipher[b.cipher] || "string" === typeof a && 100 >= b.iter || 64 !== b.ts && 96 !== b.ts && 128 !== b.ts || 128 !== b.ks && 192 !== b.ks && 0x100 !== b.ks || !b.iv || 2 > b.iv.length || 4 < b.iv.length) &&
        p( new sjcl.exception.invalid( "json decrypt: invalid parameters" ) );
        "string" === typeof a ? (g = sjcl.misc.cachedPbkdf2( a, b ), a = g.key.slice( 0, b.ks / 32 ), b.salt = g.salt) : sjcl.ecc && a instanceof sjcl.ecc.elGamal.secretKey && (a = a.unkem( sjcl.codec.base64.toBits( b.kemtag ) ).slice( 0, b.ks / 32 ));
        "string" === typeof f && (f = sjcl.codec.utf8String.toBits( f ));
        g = new sjcl.cipher[b.cipher]( a );
        f = sjcl.mode[b.mode].decrypt( g, b.ct, b.iv, f, b.ts );
        e.p( d, b );
        d.key = a;
        return 1 === c.raw ? f : sjcl.codec.utf8String.fromBits( f )
    }, decrypt: function( a, b, c, d ) {
        var e = sjcl.json;
        return e.na( a, e.decode( b ), c, d )
    }, encode: function( a ) {
        var b, c = "{", d = "";
        for( b in a ) {
            if( a.hasOwnProperty( b ) ) {
                switch( b.match( /^[a-z0-9]+$/i ) || p( new sjcl.exception.invalid( "json encode: invalid property name" ) ), c += d + '"' + b + '":', d = ",", typeof a[b] ) {
                    case "number":
                    case "boolean":
                        c += a[b];
                        break;
                    case "string":
                        c += '"' + escape( a[b] ) + '"';
                        break;
                    case "object":
                        c += '"' + sjcl.codec.base64.fromBits( a[b], 0 ) + '"';
                        break;
                    default:
                        p( new sjcl.exception.bug( "json encode: unsupported type" ) )
                }
            }
        }
        return c + "}"
    }, decode: function( a ) {
        a =
        a.replace( /\s/g, "" );
        a.match( /^\{.*\}$/ ) || p( new sjcl.exception.invalid( "json decode: this isn't json!" ) );
        a = a.replace( /^\{|\}$/g, "" ).split( /,/ );
        var b = {}, c, d;
        for( c = 0; c < a.length; c++ ) {
            (d = a[c].match( /^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i )) || p( new sjcl.exception.invalid( "json decode: this isn't json!" ) ), d[3] ? b[d[2]] = parseInt( d[3], 10 ) : d[4] ? b[d[2]] = d[2].match( /^(ct|adata|salt|iv)$/ ) ? sjcl.codec.base64.toBits( d[4] ) : unescape( d[4] ) : d[5] && (b[d[2]] = "true" ===
                                                                                                                                                                                                                                                                                                                                                                              d[5]);
        }
        return b
    }, p: function( a, b, c ) {
        a === r && (a = {});
        if( b === r ) {
            return a;
        }
        for( var d in b ) {
            b.hasOwnProperty( d ) && (c && (a[d] !== r && a[d] !== b[d]) && p( new sjcl.exception.invalid( "required parameter overridden" ) ), a[d] = b[d]);
        }
        return a
    }, za: function( a, b ) {
        var c = {}, d;
        for( d in a ) {
            a.hasOwnProperty( d ) && a[d] !== b[d] && (c[d] = a[d]);
        }
        return c
    }, ya: function( a, b ) {
        var c = {}, d;
        for( d = 0; d < b.length; d++ ) {
            a[b[d]] !== r && (c[b[d]] = a[b[d]]);
        }
        return c
    }};
sjcl.encrypt = sjcl.json.encrypt;
sjcl.decrypt = sjcl.json.decrypt;
sjcl.misc.wa = {};
sjcl.misc.cachedPbkdf2 = function( a, b ) {
    var c = sjcl.misc.wa, d;
    b = b || {};
    d = b.iter || 1E3;
    c = c[a] = c[a] || {};
    d = c[d] = c[d] || {firstSalt: b.salt && b.salt.length ? b.salt.slice( 0 ) : sjcl.random.randomWords( 2, 0 )};
    c = b.salt === r ? d.firstSalt : b.salt;
    d[c] = d[c] || sjcl.misc.pbkdf2( a, c, b.iter );
    return{key: d[c].slice( 0 ), salt: c.slice( 0 )}
};
sjcl.bn = function( a ) {
    this.initWith( a )
};
sjcl.bn.prototype = {radix: 24, maxMul: 8, i: sjcl.bn, copy: function() {
    return new this.i( this )
}, initWith: function( a ) {
    var b = 0, c;
    switch( typeof a ) {
        case "object":
            this.limbs = a.limbs.slice( 0 );
            break;
        case "number":
            this.limbs = [a];
            this.normalize();
            break;
        case "string":
            a = a.replace( /^0x/, "" );
            this.limbs = [];
            c = this.radix / 4;
            for( b = 0; b < a.length; b += c ) {
                this.limbs.push( parseInt( a.substring( Math.max( a.length - b - c, 0 ), a.length - b ), 16 ) );
            }
            break;
        default:
            this.limbs = [0]
    }
    return this
}, equals: function( a ) {
    "number" === typeof a && (a = new this.i( a ));
    var b = 0, c;
    this.fullReduce();
    a.fullReduce();
    for( c = 0; c < this.limbs.length || c < a.limbs.length; c++ ) {
        b |= this.getLimb( c ) ^ a.getLimb( c );
    }
    return 0 === b
}, getLimb: function( a ) {
    return a >= this.limbs.length ? 0 : this.limbs[a]
}, greaterEquals: function( a ) {
    "number" === typeof a && (a = new this.i( a ));
    var b = 0, c = 0, d, e, f;
    for( d = Math.max( this.limbs.length, a.limbs.length ) - 1; 0 <= d; d-- ) {
        e = this.getLimb( d ), f = a.getLimb( d ), c |= f - e & ~b, b |= e - f & ~c;
    }
    return(c | ~b) >>> 31
}, toString: function() {
    this.fullReduce();
    var a = "", b, c, d = this.limbs;
    for( b = 0; b < this.limbs.length; b++ ) {
        for( c =
             d[b].toString( 16 ); b < this.limbs.length - 1 && 6 > c.length; ) {
            c = "0" + c;
        }
        a = c + a
    }
    return"0x" + a
}, addM: function( a ) {
    "object" !== typeof a && (a = new this.i( a ));
    var b = this.limbs, c = a.limbs;
    for( a = b.length; a < c.length; a++ ) {
        b[a] = 0;
    }
    for( a = 0; a < c.length; a++ ) {
        b[a] += c[a];
    }
    return this
}, doubleM: function() {
    var a, b = 0, c, d = this.radix, e = this.radixMask, f = this.limbs;
    for( a = 0; a < f.length; a++ ) {
        c = f[a], c = c + c + b, f[a] = c & e, b = c >> d;
    }
    b && f.push( b );
    return this
}, halveM: function() {
    var a, b = 0, c, d = this.radix, e = this.limbs;
    for( a = e.length - 1; 0 <= a; a-- ) {
        c = e[a], e[a] = c + b >>
                         1, b = (c & 1) << d;
    }
    e[e.length - 1] || e.pop();
    return this
}, subM: function( a ) {
    "object" !== typeof a && (a = new this.i( a ));
    var b = this.limbs, c = a.limbs;
    for( a = b.length; a < c.length; a++ ) {
        b[a] = 0;
    }
    for( a = 0; a < c.length; a++ ) {
        b[a] -= c[a];
    }
    return this
}, mod: function( a ) {
    var b = !this.greaterEquals( new sjcl.bn( 0 ) );
    a = (new sjcl.bn( a )).normalize();
    var c = (new sjcl.bn( this )).normalize(), d = 0;
    for( b && (c = (new sjcl.bn( 0 )).subM( c ).normalize()); c.greaterEquals( a ); d++ ) {
        a.doubleM();
    }
    for( b && (c = a.sub( c ).normalize()); 0 < d; d-- ) {
        a.halveM(), c.greaterEquals( a ) &&
                    c.subM( a ).normalize();
    }
    return c.trim()
}, inverseMod: function( a ) {
    var b = new sjcl.bn( 1 ), c = new sjcl.bn( 0 ), d = new sjcl.bn( this ), e = new sjcl.bn( a ), f, g = 1;
    a.limbs[0] & 1 || p( new sjcl.exception.invalid( "inverseMod: p must be odd" ) );
    do {
        d.limbs[0] & 1 && (d.greaterEquals( e ) || (f = d, d = e, e = f, f = b, b = c, c = f), d.subM( e ), d.normalize(), b.greaterEquals( c ) || b.addM( a ), b.subM( c ));
        d.halveM();
        b.limbs[0] & 1 && b.addM( a );
        b.normalize();
        b.halveM();
        for( f = g = 0; f < d.limbs.length; f++ ) {
            g |= d.limbs[f]
        }
    } while( g );
    e.equals( 1 ) || p( new sjcl.exception.invalid( "inverseMod: p and x must be relatively prime" ) );
    return c
}, add: function( a ) {
    return this.copy().addM( a )
}, sub: function( a ) {
    return this.copy().subM( a )
}, mul: function( a ) {
    "number" === typeof a && (a = new this.i( a ));
    var b, c = this.limbs, d = a.limbs, e = c.length, f = d.length, g = new this.i, h = g.limbs, k, l = this.maxMul;
    for( b = 0; b < this.limbs.length + a.limbs.length + 1; b++ ) {
        h[b] = 0;
    }
    for( b = 0; b < e; b++ ) {
        k = c[b];
        for( a = 0; a < f; a++ ) {
            h[b + a] += k * d[a];
        }
        --l || (l = this.maxMul, g.cnormalize())
    }
    return g.cnormalize().reduce()
}, square: function() {
    return this.mul( this )
}, power: function( a ) {
    "number" === typeof a ?
        a = [a] : a.limbs !== r && (a = a.normalize().limbs);
    var b, c, d = new this.i( 1 ), e = this;
    for( b = 0; b < a.length; b++ ) {
        for( c = 0; c < this.radix; c++ ) {
            a[b] & 1 << c && (d = d.mul( e )), e = e.square();
        }
    }
    return d
}, mulmod: function( a, b ) {
    return this.mod( b ).mul( a.mod( b ) ).mod( b )
}, powermod: function( a, b ) {
    for( var c = new sjcl.bn( 1 ), d = new sjcl.bn( this ), e = new sjcl.bn( a ); ; ) {
        e.limbs[0] & 1 && (c = c.mulmod( d, b ));
        e.halveM();
        if( e.equals( 0 ) ) {
            break;
        }
        d = d.mulmod( d, b )
    }
    return c.normalize().reduce()
}, trim: function() {
    var a = this.limbs, b;
    do {
        b = a.pop();
    } while( a.length && 0 === b );
    a.push( b );
    return this
}, reduce: function() {
    return this
}, fullReduce: function() {
    return this.normalize()
}, normalize: function() {
    var a = 0, b, c = this.placeVal, d = this.ipv, e, f = this.limbs, g = f.length, h = this.radixMask;
    for( b = 0; b < g || 0 !== a && -1 !== a; b++ ) {
        a = (f[b] || 0) + a, e = f[b] = a & h, a = (a - e) * d;
    }
    -1 === a && (f[b - 1] -= c);
    return this
}, cnormalize: function() {
    var a = 0, b, c = this.ipv, d, e = this.limbs, f = e.length, g = this.radixMask;
    for( b = 0; b < f - 1; b++ ) {
        a = e[b] + a, d = e[b] = a & g, a = (a - d) * c;
    }
    e[b] += a;
    return this
}, toBits: function( a ) {
    this.fullReduce();
    a = a || this.exponent ||
        this.bitLength();
    var b = Math.floor( (a - 1) / 24 ), c = sjcl.bitArray, d = [c.partial( (a + 7 & -8) % this.radix || this.radix, this.getLimb( b ) )];
    for( b--; 0 <= b; b-- ) {
        d = c.concat( d, [c.partial( Math.min( this.radix, a ), this.getLimb( b ) )] ), a -= this.radix;
    }
    return d
}, bitLength: function() {
    this.fullReduce();
    for( var a = this.radix * (this.limbs.length - 1), b = this.limbs[this.limbs.length - 1]; b; b >>>= 1 ) {
        a++;
    }
    return a + 7 & -8
}};
sjcl.bn.fromBits = function( a ) {
    var b = new this, c = [], d = sjcl.bitArray, e = this.prototype, f = Math.min( this.bitLength || 0x100000000, d.bitLength( a ) ), g = f % e.radix || e.radix;
    for( c[0] = d.extract( a, 0, g ); g < f; g += e.radix ) {
        c.unshift( d.extract( a, g, e.radix ) );
    }
    b.limbs = c;
    return b
};
sjcl.bn.prototype.ipv = 1 / (sjcl.bn.prototype.placeVal = Math.pow( 2, sjcl.bn.prototype.radix ));
sjcl.bn.prototype.radixMask = (1 << sjcl.bn.prototype.radix) - 1;
sjcl.bn.pseudoMersennePrime = function( a, b ) {
    function c( a ) {
        this.initWith( a )
    }

    var d = c.prototype = new sjcl.bn, e, f;
    e = d.modOffset = Math.ceil( f = a / d.radix );
    d.exponent = a;
    d.offset = [];
    d.factor = [];
    d.minOffset = e;
    d.fullMask = 0;
    d.fullOffset = [];
    d.fullFactor = [];
    d.modulus = c.modulus = new sjcl.bn( Math.pow( 2, a ) );
    d.fullMask = 0 | -Math.pow( 2, a % d.radix );
    for( e = 0; e < b.length; e++ ) {
        d.offset[e] = Math.floor( b[e][0] / d.radix - f ), d.fullOffset[e] = Math.ceil( b[e][0] / d.radix - f ), d.factor[e] = b[e][1] * Math.pow( 0.5, a - b[e][0] + d.offset[e] * d.radix ), d.fullFactor[e] =
                                                                                                                                                                                               b[e][1] * Math.pow( 0.5, a - b[e][0] + d.fullOffset[e] * d.radix ), d.modulus.addM( new sjcl.bn( Math.pow( 2, b[e][0] ) * b[e][1] ) ), d.minOffset = Math.min( d.minOffset, -d.offset[e] );
    }
    d.i = c;
    d.modulus.cnormalize();
    d.reduce = function() {
        var a, b, c, d = this.modOffset, e = this.limbs, f = this.offset, q = this.offset.length, t = this.factor, s;
        for( a = this.minOffset; e.length > d; ) {
            c = e.pop();
            s = e.length;
            for( b = 0; b < q; b++ ) {
                e[s + f[b]] -= t[b] * c;
            }
            a--;
            a || (e.push( 0 ), this.cnormalize(), a = this.minOffset)
        }
        this.cnormalize();
        return this
    };
    d.fa = -1 === d.fullMask ? d.reduce :
        function() {
            var a = this.limbs, b = a.length - 1, c, d;
            this.reduce();
            if( b === this.modOffset - 1 ) {
                d = a[b] & this.fullMask;
                a[b] -= d;
                for( c = 0; c < this.fullOffset.length; c++ ) {
                    a[b + this.fullOffset[c]] -= this.fullFactor[c] * d;
                }
                this.normalize()
            }
        };
    d.fullReduce = function() {
        var a, b;
        this.fa();
        this.addM( this.modulus );
        this.addM( this.modulus );
        this.normalize();
        this.fa();
        for( b = this.limbs.length; b < this.modOffset; b++ ) {
            this.limbs[b] = 0;
        }
        a = this.greaterEquals( this.modulus );
        for( b = 0; b < this.limbs.length; b++ ) {
            this.limbs[b] -= this.modulus.limbs[b] * a;
        }
        this.cnormalize();
        return this
    };
    d.inverse = function() {
        return this.power( this.modulus.sub( 2 ) )
    };
    c.fromBits = sjcl.bn.fromBits;
    return c
};
var X = sjcl.bn.pseudoMersennePrime;
sjcl.bn.prime = {p127: X( 127, [
    [0, -1]
] ), p25519: X( 255, [
    [0, -19]
] ), p192k: X( 192, [
    [32, -1],
    [12, -1],
    [8, -1],
    [7, -1],
    [6, -1],
    [3, -1],
    [0, -1]
] ), p224k: X( 224, [
    [32, -1],
    [12, -1],
    [11, -1],
    [9, -1],
    [7, -1],
    [4, -1],
    [1, -1],
    [0, -1]
] ), p256k: X( 0x100, [
    [32, -1],
    [9, -1],
    [8, -1],
    [7, -1],
    [6, -1],
    [4, -1],
    [0, -1]
] ), p192: X( 192, [
    [0, -1],
    [64, -1]
] ), p224: X( 224, [
    [0, 1],
    [96, -1]
] ), p256: X( 0x100, [
    [0, -1],
    [96, 1],
    [192, 1],
    [224, -1]
] ), p384: X( 384, [
    [0, -1],
    [32, 1],
    [96, -1],
    [128, -1]
] ), p521: X( 521, [
    [0, -1]
] )};
sjcl.bn.random = function( a, b ) {
    "object" !== typeof a && (a = new sjcl.bn( a ));
    for( var c, d, e = a.limbs.length, f = a.limbs[e - 1] + 1, g = new sjcl.bn; ; ) {
        do {
            c = sjcl.random.randomWords( e, b ), 0 > c[e - 1] && (c[e - 1] += 0x100000000);
        } while( Math.floor( c[e - 1] / f ) === Math.floor( 0x100000000 / f ) );
        c[e - 1] %= f;
        for( d = 0; d < e - 1; d++ ) {
            c[d] &= a.radixMask;
        }
        g.limbs = c;
        if( !g.greaterEquals( a ) ) {
            return g
        }
    }
};
sjcl.ecc = {};
sjcl.ecc.point = function( a, b, c ) {
    b === r ? this.isIdentity = v : (b instanceof sjcl.bn && (b = new a.field( b )), c instanceof sjcl.bn && (c = new a.field( c )), this.x = b, this.y = c, this.isIdentity = C);
    this.curve = a
};
sjcl.ecc.point.prototype = {toJac: function() {
    return new sjcl.ecc.pointJac( this.curve, this.x, this.y, new this.curve.field( 1 ) )
}, mult: function( a ) {
    return this.toJac().mult( a, this ).toAffine()
}, mult2: function( a, b, c ) {
    return this.toJac().mult2( a, this, b, c ).toAffine()
}, multiples: function() {
    var a, b, c;
    if( this.ca === r ) {
        c = this.toJac().doubl();
        a = this.ca = [new sjcl.ecc.point( this.curve ), this, c.toAffine()];
        for( b = 3; 16 > b; b++ ) {
            c = c.add( this ), a.push( c.toAffine() )
        }
    }
    return this.ca
}, negate: function() {
    var a = (new this.curve.field( 0 )).sub( this.y ).normalize().reduce();
    return new sjcl.ecc.point( this.curve, this.x, a )
}, isValid: function() {
    return this.y.square().equals( this.curve.b.add( this.x.mul( this.curve.a.add( this.x.square() ) ) ) )
}, toBits: function() {
    return sjcl.bitArray.concat( this.x.toBits(), this.y.toBits() )
}};
sjcl.ecc.pointJac = function( a, b, c, d ) {
    b === r ? this.isIdentity = v : (this.x = b, this.y = c, this.z = d, this.isIdentity = C);
    this.curve = a
};
sjcl.ecc.pointJac.prototype = {add: function( a ) {
    var b, c, d, e;
    this.curve !== a.curve && p( "sjcl['ecc']['add'](): Points must be on the same curve to add them!" );
    if( this.isIdentity ) {
        return a.toJac();
    }
    if( a.isIdentity ) {
        return this;
    }
    b = this.z.square();
    c = a.x.mul( b ).subM( this.x );
    if( c.equals( 0 ) ) {
        return this.y.equals( a.y.mul( b.mul( this.z ) ) ) ? this.doubl() : new sjcl.ecc.pointJac( this.curve );
    }
    b = a.y.mul( b.mul( this.z ) ).subM( this.y );
    d = c.square();
    a = b.square();
    e = c.square().mul( c ).addM( this.x.add( this.x ).mul( d ) );
    a = a.subM( e );
    b = this.x.mul( d ).subM( a ).mul( b );
    d = this.y.mul( c.square().mul( c ) );
    b = b.subM( d );
    c = this.z.mul( c );
    return new sjcl.ecc.pointJac( this.curve, a, b, c )
}, doubl: function() {
    if( this.isIdentity ) {
        return this;
    }
    var a = this.y.square(), b = a.mul( this.x.mul( 4 ) ), c = a.square().mul( 8 ), a = this.z.square(), d = this.curve.a.toString() == (new sjcl.bn( -3 )).toString() ? this.x.sub( a ).mul( 3 ).mul( this.x.add( a ) ) : this.x.square().mul( 3 ).add( a.square().mul( this.curve.a ) ), a = d.square().subM( b ).subM( b ), b = b.sub( a ).mul( d ).subM( c ), c = this.y.add( this.y ).mul( this.z );
    return new sjcl.ecc.pointJac( this.curve,
        a, b, c )
}, toAffine: function() {
    if( this.isIdentity || this.z.equals( 0 ) ) {
        return new sjcl.ecc.point( this.curve );
    }
    var a = this.z.inverse(), b = a.square();
    return new sjcl.ecc.point( this.curve, this.x.mul( b ).fullReduce(), this.y.mul( b.mul( a ) ).fullReduce() )
}, mult: function( a, b ) {
    "number" === typeof a ? a = [a] : a.limbs !== r && (a = a.normalize().limbs);
    var c, d, e = (new sjcl.ecc.point( this.curve )).toJac(), f = b.multiples();
    for( c = a.length - 1; 0 <= c; c-- ) {
        for( d = sjcl.bn.prototype.radix - 4; 0 <= d; d -= 4 ) {
            e = e.doubl().doubl().doubl().doubl().add( f[a[c] >>
                                                         d & 15] );
        }
    }
    return e
}, mult2: function( a, b, c, d ) {
    "number" === typeof a ? a = [a] : a.limbs !== r && (a = a.normalize().limbs);
    "number" === typeof c ? c = [c] : c.limbs !== r && (c = c.normalize().limbs);
    var e, f = (new sjcl.ecc.point( this.curve )).toJac();
    b = b.multiples();
    var g = d.multiples(), h, k;
    for( d = Math.max( a.length, c.length ) - 1; 0 <= d; d-- ) {
        h = a[d] | 0;
        k = c[d] | 0;
        for( e = sjcl.bn.prototype.radix - 4; 0 <= e; e -= 4 ) {
            f = f.doubl().doubl().doubl().doubl().add( b[h >> e & 15] ).add( g[k >> e & 15] )
        }
    }
    return f
}, negate: function() {
    return this.toAffine().negate().toJac()
}, isValid: function() {
    var a =
        this.z.square(), b = a.square(), a = b.mul( a );
    return this.y.square().equals( this.curve.b.mul( a ).add( this.x.mul( this.curve.a.mul( b ).add( this.x.square() ) ) ) )
}};
sjcl.ecc.curve = function( a, b, c, d, e, f ) {
    this.field = a;
    this.r = new sjcl.bn( b );
    this.a = new a( c );
    this.b = new a( d );
    this.G = new sjcl.ecc.point( this, new a( e ), new a( f ) )
};
sjcl.ecc.curve.prototype.fromBits = function( a ) {
    var b = sjcl.bitArray, c = this.field.prototype.exponent + 7 & -8;
    a = new sjcl.ecc.point( this, this.field.fromBits( b.bitSlice( a, 0, c ) ), this.field.fromBits( b.bitSlice( a, c, 2 * c ) ) );
    a.isValid() || p( new sjcl.exception.corrupt( "not on the curve!" ) );
    return a
};
sjcl.ecc.curves = {c192: new sjcl.ecc.curve( sjcl.bn.prime.p192, "0xffffffffffffffffffffffff99def836146bc9b1b4d22831", -3, "0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1", "0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012", "0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811" ), c224: new sjcl.ecc.curve( sjcl.bn.prime.p224, "0xffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d", -3, "0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4", "0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21",
    "0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34" ), c256: new sjcl.ecc.curve( sjcl.bn.prime.p256, "0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551", -3, "0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b", "0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296", "0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5" ), c384: new sjcl.ecc.curve( sjcl.bn.prime.p384, "0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973",
    -3, "0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef", "0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7", "0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f" ), k192: new sjcl.ecc.curve( sjcl.bn.prime.p192k, "0xfffffffffffffffffffffffe26f2fc170f69466a74defd8d", 0, 3, "0xdb4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d", "0x9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d" ),
    k224: new sjcl.ecc.curve( sjcl.bn.prime.p224k, "0x010000000000000000000000000001dce8d2ec6184caf0a971769fb1f7", 0, 5, "0xa1455b334df099df30fc28a169a467e9e47075a90f7e650eb6b7a45c", "0x7e089fed7fba344282cafbd6f7e319f7c0b0bd59e2ca4bdb556d61a5" ), k256: new sjcl.ecc.curve( sjcl.bn.prime.p256k, "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 0, 7, "0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8" )};
sjcl.ecc.basicKey = {publicKey: function( a, b ) {
    this.l = a;
    this.s = a.r.bitLength();
    this.I = b instanceof Array ? a.fromBits( b ) : b;
    this.get = function() {
        var a = this.I.toBits(), b = sjcl.bitArray.bitLength( a ), e = sjcl.bitArray.bitSlice( a, 0, b / 2 ), a = sjcl.bitArray.bitSlice( a, b / 2 );
        return{x: e, y: a}
    }
}, secretKey: function( a, b ) {
    this.l = a;
    this.s = a.r.bitLength();
    this.H = b;
    this.get = function() {
        return this.H.toBits()
    }
}};
sjcl.ecc.basicKey.generateKeys = function( a ) {
    return function( b, c, d ) {
        b = b || 0x100;
        "number" === typeof b && (b = sjcl.ecc.curves["c" + b], b === r && p( new sjcl.exception.invalid( "no such curve" ) ));
        d = d || sjcl.bn.random( b.r, c );
        c = b.G.mult( d );
        return{pub: new sjcl.ecc[a].publicKey( b, c ), sec: new sjcl.ecc[a].secretKey( b, d )}
    }
};
sjcl.ecc.elGamal = {generateKeys: sjcl.ecc.basicKey.generateKeys( "elGamal" ), publicKey: function( a, b ) {
    sjcl.ecc.basicKey.publicKey.apply( this, arguments )
}, secretKey: function( a, b ) {
    sjcl.ecc.basicKey.secretKey.apply( this, arguments )
}};
sjcl.ecc.elGamal.publicKey.prototype = {kem: function( a ) {
    a = sjcl.bn.random( this.l.r, a );
    var b = this.l.G.mult( a ).toBits();
    return{key: sjcl.hash.sha256.hash( this.I.mult( a ).toBits() ), tag: b}
}};
sjcl.ecc.elGamal.secretKey.prototype = {unkem: function( a ) {
    return sjcl.hash.sha256.hash( this.l.fromBits( a ).mult( this.H ).toBits() )
}, dh: function( a ) {
    return sjcl.hash.sha256.hash( a.I.mult( this.H ).toBits() )
}, dhJavaEc: function( a ) {
    return a.I.mult( this.H ).x.toBits()
}};
sjcl.ecc.ecdsa = {generateKeys: sjcl.ecc.basicKey.generateKeys( "ecdsa" )};
sjcl.ecc.ecdsa.publicKey = function( a, b ) {
    sjcl.ecc.basicKey.publicKey.apply( this, arguments )
};
sjcl.ecc.ecdsa.publicKey.prototype = {verify: function( a, b, c ) {
    sjcl.bitArray.bitLength( a ) > this.s && (a = sjcl.bitArray.clamp( a, this.s ));
    var d = sjcl.bitArray, e = this.l.r, f = this.s, g = sjcl.bn.fromBits( d.bitSlice( b, 0, f ) ), d = sjcl.bn.fromBits( d.bitSlice( b, f, 2 * f ) ), h = c ? d : d.inverseMod( e ), f = sjcl.bn.fromBits( a ).mul( h ).mod( e ), h = g.mul( h ).mod( e ), f = this.l.G.mult2( f, h, this.I ).x;
    if( g.equals( 0 ) || d.equals( 0 ) || g.greaterEquals( e ) || d.greaterEquals( e ) || !f.equals( g ) ) {
        if( c === r ) {
            return this.verify( a, b, v );
        }
        p( new sjcl.exception.corrupt( "signature didn't check out" ) )
    }
    return v
}};
sjcl.ecc.ecdsa.secretKey = function( a, b ) {
    sjcl.ecc.basicKey.secretKey.apply( this, arguments )
};
sjcl.ecc.ecdsa.secretKey.prototype = {sign: function( a, b, c, d ) {
    sjcl.bitArray.bitLength( a ) > this.s && (a = sjcl.bitArray.clamp( a, this.s ));
    var e = this.l.r, f = e.bitLength();
    d = d || sjcl.bn.random( e.sub( 1 ), b ).add( 1 );
    b = this.l.G.mult( d ).x.mod( e );
    a = sjcl.bn.fromBits( a ).add( b.mul( this.H ) );
    c = c ? a.inverseMod( e ).mul( d ).mod( e ) : a.mul( d.inverseMod( e ) ).mod( e );
    return sjcl.bitArray.concat( b.toBits( f ), c.toBits( f ) )
}};
sjcl.keyexchange.srp = {makeVerifier: function( a, b, c, d ) {
    a = sjcl.keyexchange.srp.makeX( a, b, c );
    a = sjcl.bn.fromBits( a );
    return d.g.powermod( a, d.N )
}, makeX: function( a, b, c ) {
    a = sjcl.hash.sha1.hash( a + ":" + b );
    return sjcl.hash.sha1.hash( sjcl.bitArray.concat( c, a ) )
}, knownGroup: function( a ) {
    "string" !== typeof a && (a = a.toString());
    sjcl.keyexchange.srp.Z || sjcl.keyexchange.srp.qa();
    return sjcl.keyexchange.srp.ba[a]
}, Z: C, qa: function() {
    var a, b;
    for( a = 0; a < sjcl.keyexchange.srp.aa.length; a++ ) {
        b = sjcl.keyexchange.srp.aa[a].toString(),
            b = sjcl.keyexchange.srp.ba[b], b.N = new sjcl.bn( b.N ), b.g = new sjcl.bn( b.g );
    }
    sjcl.keyexchange.srp.Z = v
}, aa: [1024, 1536, 2048], ba: {1024: {N: "EEAF0AB9ADB38DD69C33F80AFA8FC5E86072618775FF3C0B9EA2314C9C256576D674DF7496EA81D3383B4813D692C6E0E0D5D8E250B98BE48E495C1D6089DAD15DC7D7B46154D6B6CE8EF4AD69B15D4982559B297BCF1885C529F566660E57EC68EDBC3C05726CC02FD4CBF4976EAA9AFD5138FE8376435B9FC61D2FC0EB06E3", g: 2}, 1536: {N: "9DEF3CAFB939277AB1F12A8617A47BBBDBA51DF499AC4C80BEEEA9614B19CC4D5F4F5F556E27CBDE51C6A94BE4607A291558903BA0D0F84380B655BB9A22E8DCDF028A7CEC67F0D08134B1C8B97989149B609E0BE3BAB63D47548381DBC5B1FC764E3F4B53DD9DA1158BFD3E2B9C8CF56EDF019539349627DB2FD53D24B7C48665772E437D6C7F8CE442734AF7CCB7AE837C264AE3A9BEB87F8A2FE9B8B5292E5A021FFF5E91479E8CE7A28C2442C6F315180F93499A234DCF76E3FED135F9BB",
    g: 2}, 2048: {N: "AC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73",
    g: 2}}};
;function SHA1(s){function U(a,b,c){while(0<c--)a.push(b)}function L(a,b){return(a<<b)|(a>>>(32-b))}function P(a,b,c){return a^b^c}function A(a,b){var c=(b&0xFFFF)+(a&0xFFFF),d=(b>>>16)+(a>>>16)+(c>>>16);return((d&0xFFFF)<<16)|(c&0xFFFF)}var B="0123456789abcdef";return(function(a){var c=[],d=a.length*4,e;for(var i=0;i<d;i++){e=a[i>>2]>>((3-(i%4))*8);c.push(B.charAt((e>>4)&0xF)+B.charAt(e&0xF))}return c.join('')}((function(a,b){var c,d,e,f,g,h=a.length,v=0x67452301,w=0xefcdab89,x=0x98badcfe,y=0x10325476,z=0xc3d2e1f0,M=[];U(M,0x5a827999,20);U(M,0x6ed9eba1,20);U(M,0x8f1bbcdc,20);U(M,0xca62c1d6,20);a[b>>5]|=0x80<<(24-(b%32));a[(((b+65)>>9)<<4)+15]=b;for(var i=0;i<h;i+=16){c=v;d=w;e=x;f=y;g=z;for(var j=0,O=[];j<80;j++){O[j]=j<16?a[j+i]:L(O[j-3]^O[j-8]^O[j-14]^O[j-16],1);var k=(function(a,b,c,d,e){var f=(e&0xFFFF)+(a&0xFFFF)+(b&0xFFFF)+(c&0xFFFF)+(d&0xFFFF),g=(e>>>16)+(a>>>16)+(b>>>16)+(c>>>16)+(d>>>16)+(f>>>16);return((g&0xFFFF)<<16)|(f&0xFFFF)})(j<20?(function(t,a,b){return(t&a)^(~t&b)}(d,e,f)):j<40?P(d,e,f):j<60?(function(t,a,b){return(t&a)^(t&b)^(a&b)}(d,e,f)):P(d,e,f),g,M[j],O[j],L(c,5));g=f;f=e;e=L(d,30);d=c;c=k}v=A(v,c);w=A(w,d);x=A(x,e);y=A(y,f);z=A(z,g)}return[v,w,x,y,z]}((function(t){var a=[],b=255,c=t.length*8;for(var i=0;i<c;i+=8){a[i>>5]|=(t.charCodeAt(i/8)&b)<<(24-(i%32))}return a}(s)).slice(),s.length*8))))}

"undefined" !== typeof module && module.exports && (module.exports = SHA1);;(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.jade = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    'use strict';

    /**
     * Merge two attribute objects giving precedence
     * to values in object `b`. Classes are special-cased
     * allowing for arrays and merging/joining appropriately
     * resulting in a string.
     *
     * @param {Object} a
     * @param {Object} b
     * @return {Object} a
     * @api private
     */

    exports.merge = function merge(a, b) {
        if (arguments.length === 1) {
            var attrs = a[0];
            for (var i = 1; i < a.length; i++) {
                attrs = merge(attrs, a[i]);
            }
            return attrs;
        }
        var ac = a['class'];
        var bc = b['class'];

        if (ac || bc) {
            ac = ac || [];
            bc = bc || [];
            if (!Array.isArray(ac)) ac = [ac];
            if (!Array.isArray(bc)) bc = [bc];
            a['class'] = ac.concat(bc).filter(nulls);
        }

        for (var key in b) {
            if (key != 'class') {
                a[key] = b[key];
            }
        }

        return a;
    };

    /**
     * Filter null `val`s.
     *
     * @param {*} val
     * @return {Boolean}
     * @api private
     */

    function nulls(val) {
        return val != null && val !== '';
    }

    /**
     * join array as classes.
     *
     * @param {*} val
     * @return {String}
     */
    exports.joinClasses = joinClasses;
    function joinClasses(val) {
        return (Array.isArray(val) ? val.map(joinClasses) :
            (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :
                [val]).filter(nulls).join(' ');
    }

    /**
     * Render the given classes.
     *
     * @param {Array} classes
     * @param {Array.<Boolean>} escaped
     * @return {String}
     */
    exports.cls = function cls(classes, escaped) {
        var buf = [];
        for (var i = 0; i < classes.length; i++) {
            if (escaped && escaped[i]) {
                buf.push(exports.escape(joinClasses([classes[i]])));
            } else {
                buf.push(joinClasses(classes[i]));
            }
        }
        var text = joinClasses(buf);
        if (text.length) {
            return ' class="' + text + '"';
        } else {
            return '';
        }
    };


    exports.style = function (val) {
        if (val && typeof val === 'object') {
            return Object.keys(val).map(function (style) {
                return style + ':' + val[style];
            }).join(';');
        } else {
            return val;
        }
    };
    /**
     * Render the given attribute.
     *
     * @param {String} key
     * @param {String} val
     * @param {Boolean} escaped
     * @param {Boolean} terse
     * @return {String}
     */
    exports.attr = function attr(key, val, escaped, terse) {
        if (key === 'style') {
            val = exports.style(val);
        }
        if ('boolean' == typeof val || null == val) {
            if (val) {
                return ' ' + (terse ? key : key + '="' + key + '"');
            } else {
                return '';
            }
        } else if (0 == key.indexOf('data') && 'string' != typeof val) {
            if (JSON.stringify(val).indexOf('&') !== -1) {
                console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +
                             'will be escaped to `&amp;`');
            };
            if (val && typeof val.toISOString === 'function') {
                console.warn('Jade will eliminate the double quotes around dates in ' +
                             'ISO form after 2.0.0');
            }
            return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
        } else if (escaped) {
            if (val && typeof val.toISOString === 'function') {
                console.warn('Jade will stringify dates in ISO form after 2.0.0');
            }
            return ' ' + key + '="' + exports.escape(val) + '"';
        } else {
            if (val && typeof val.toISOString === 'function') {
                console.warn('Jade will stringify dates in ISO form after 2.0.0');
            }
            return ' ' + key + '="' + val + '"';
        }
    };

    /**
     * Render the given attributes object.
     *
     * @param {Object} obj
     * @param {Object} escaped
     * @return {String}
     */
    exports.attrs = function attrs(obj, terse){
        var buf = [];

        var keys = Object.keys(obj);

        if (keys.length) {
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i]
                    , val = obj[key];

                if ('class' == key) {
                    if (val = joinClasses(val)) {
                        buf.push(' ' + key + '="' + val + '"');
                    }
                } else {
                    buf.push(exports.attr(key, val, false, terse));
                }
            }
        }

        return buf.join('');
    };

    /**
     * Escape the given string of `html`.
     *
     * @param {String} html
     * @return {String}
     * @api private
     */

    var jade_encode_html_rules = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;'
    };
    var jade_match_html = /[&<>"]/g;

    function jade_encode_char(c) {
        return jade_encode_html_rules[c] || c;
    }

    exports.escape = jade_escape;
    function jade_escape(html){
        var result = String(html).replace(jade_match_html, jade_encode_char);
        if (result === '' + html) return html;
        else return result;
    };

    /**
     * Re-throw the given `err` in context to the
     * the jade in `filename` at the given `lineno`.
     *
     * @param {Error} err
     * @param {String} filename
     * @param {String} lineno
     * @api private
     */

    exports.rethrow = function rethrow(err, filename, lineno, str){
        if (!(err instanceof Error)) throw err;
        if ((typeof window != 'undefined' || !filename) && !str) {
            err.message += ' on line ' + lineno;
            throw err;
        }
        try {
            str = str || require('fs').readFileSync(filename, 'utf8')
        } catch (ex) {
            rethrow(err, null, lineno)
        }
        var context = 3
            , lines = str.split('\n')
            , start = Math.max(lineno - context, 0)
            , end = Math.min(lines.length, lineno + context);

        // Error context
        var context = lines.slice(start, end).map(function(line, i){
            var curr = i + start + 1;
            return (curr == lineno ? '  > ' : '    ')
                   + curr
                   + '| '
                   + line;
        }).join('\n');

        // Alter exception message
        err.path = filename;
        err.message = (filename || 'Jade') + ':' + lineno
                      + '\n' + context + '\n\n' + err.message;
        throw err;
    };

    exports.DebugItem = function DebugItem(lineno, filename) {
        this.lineno = lineno;
        this.filename = filename;
    }

},{"fs":2}],2:[function(require,module,exports){

},{}]},{},[1])(1)
});;//! moment.js
//! version : 2.11.2
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
!function(a,b){"object"==typeof exports&&"undefined"!=typeof module?module.exports=b():"function"==typeof define&&define.amd?define(b):a.moment=b()}(this,function(){"use strict";function a(){return Uc.apply(null,arguments)}function b(a){Uc=a}function c(a){return"[object Array]"===Object.prototype.toString.call(a)}function d(a){return a instanceof Date||"[object Date]"===Object.prototype.toString.call(a)}function e(a,b){var c,d=[];for(c=0;c<a.length;++c)d.push(b(a[c],c));return d}function f(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function g(a,b){for(var c in b)f(b,c)&&(a[c]=b[c]);return f(b,"toString")&&(a.toString=b.toString),f(b,"valueOf")&&(a.valueOf=b.valueOf),a}function h(a,b,c,d){return Da(a,b,c,d,!0).utc()}function i(){return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1}}function j(a){return null==a._pf&&(a._pf=i()),a._pf}function k(a){if(null==a._isValid){var b=j(a);a._isValid=!(isNaN(a._d.getTime())||!(b.overflow<0)||b.empty||b.invalidMonth||b.invalidWeekday||b.nullInput||b.invalidFormat||b.userInvalidated),a._strict&&(a._isValid=a._isValid&&0===b.charsLeftOver&&0===b.unusedTokens.length&&void 0===b.bigHour)}return a._isValid}function l(a){var b=h(NaN);return null!=a?g(j(b),a):j(b).userInvalidated=!0,b}function m(a){return void 0===a}function n(a,b){var c,d,e;if(m(b._isAMomentObject)||(a._isAMomentObject=b._isAMomentObject),m(b._i)||(a._i=b._i),m(b._f)||(a._f=b._f),m(b._l)||(a._l=b._l),m(b._strict)||(a._strict=b._strict),m(b._tzm)||(a._tzm=b._tzm),m(b._isUTC)||(a._isUTC=b._isUTC),m(b._offset)||(a._offset=b._offset),m(b._pf)||(a._pf=j(b)),m(b._locale)||(a._locale=b._locale),Wc.length>0)for(c in Wc)d=Wc[c],e=b[d],m(e)||(a[d]=e);return a}function o(b){n(this,b),this._d=new Date(null!=b._d?b._d.getTime():NaN),Xc===!1&&(Xc=!0,a.updateOffset(this),Xc=!1)}function p(a){return a instanceof o||null!=a&&null!=a._isAMomentObject}function q(a){return 0>a?Math.ceil(a):Math.floor(a)}function r(a){var b=+a,c=0;return 0!==b&&isFinite(b)&&(c=q(b)),c}function s(a,b,c){var d,e=Math.min(a.length,b.length),f=Math.abs(a.length-b.length),g=0;for(d=0;e>d;d++)(c&&a[d]!==b[d]||!c&&r(a[d])!==r(b[d]))&&g++;return g+f}function t(){}function u(a){return a?a.toLowerCase().replace("_","-"):a}function v(a){for(var b,c,d,e,f=0;f<a.length;){for(e=u(a[f]).split("-"),b=e.length,c=u(a[f+1]),c=c?c.split("-"):null;b>0;){if(d=w(e.slice(0,b).join("-")))return d;if(c&&c.length>=b&&s(e,c,!0)>=b-1)break;b--}f++}return null}function w(a){var b=null;if(!Yc[a]&&"undefined"!=typeof module&&module&&module.exports)try{b=Vc._abbr,require("./locale/"+a),x(b)}catch(c){}return Yc[a]}function x(a,b){var c;return a&&(c=m(b)?z(a):y(a,b),c&&(Vc=c)),Vc._abbr}function y(a,b){return null!==b?(b.abbr=a,Yc[a]=Yc[a]||new t,Yc[a].set(b),x(a),Yc[a]):(delete Yc[a],null)}function z(a){var b;if(a&&a._locale&&a._locale._abbr&&(a=a._locale._abbr),!a)return Vc;if(!c(a)){if(b=w(a))return b;a=[a]}return v(a)}function A(a,b){var c=a.toLowerCase();Zc[c]=Zc[c+"s"]=Zc[b]=a}function B(a){return"string"==typeof a?Zc[a]||Zc[a.toLowerCase()]:void 0}function C(a){var b,c,d={};for(c in a)f(a,c)&&(b=B(c),b&&(d[b]=a[c]));return d}function D(a){return a instanceof Function||"[object Function]"===Object.prototype.toString.call(a)}function E(b,c){return function(d){return null!=d?(G(this,b,d),a.updateOffset(this,c),this):F(this,b)}}function F(a,b){return a.isValid()?a._d["get"+(a._isUTC?"UTC":"")+b]():NaN}function G(a,b,c){a.isValid()&&a._d["set"+(a._isUTC?"UTC":"")+b](c)}function H(a,b){var c;if("object"==typeof a)for(c in a)this.set(c,a[c]);else if(a=B(a),D(this[a]))return this[a](b);return this}function I(a,b,c){var d=""+Math.abs(a),e=b-d.length,f=a>=0;return(f?c?"+":"":"-")+Math.pow(10,Math.max(0,e)).toString().substr(1)+d}function J(a,b,c,d){var e=d;"string"==typeof d&&(e=function(){return this[d]()}),a&&(bd[a]=e),b&&(bd[b[0]]=function(){return I(e.apply(this,arguments),b[1],b[2])}),c&&(bd[c]=function(){return this.localeData().ordinal(e.apply(this,arguments),a)})}function K(a){return a.match(/\[[\s\S]/)?a.replace(/^\[|\]$/g,""):a.replace(/\\/g,"")}function L(a){var b,c,d=a.match($c);for(b=0,c=d.length;c>b;b++)bd[d[b]]?d[b]=bd[d[b]]:d[b]=K(d[b]);return function(e){var f="";for(b=0;c>b;b++)f+=d[b]instanceof Function?d[b].call(e,a):d[b];return f}}function M(a,b){return a.isValid()?(b=N(b,a.localeData()),ad[b]=ad[b]||L(b),ad[b](a)):a.localeData().invalidDate()}function N(a,b){function c(a){return b.longDateFormat(a)||a}var d=5;for(_c.lastIndex=0;d>=0&&_c.test(a);)a=a.replace(_c,c),_c.lastIndex=0,d-=1;return a}function O(a,b,c){td[a]=D(b)?b:function(a,d){return a&&c?c:b}}function P(a,b){return f(td,a)?td[a](b._strict,b._locale):new RegExp(Q(a))}function Q(a){return R(a.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(a,b,c,d,e){return b||c||d||e}))}function R(a){return a.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function S(a,b){var c,d=b;for("string"==typeof a&&(a=[a]),"number"==typeof b&&(d=function(a,c){c[b]=r(a)}),c=0;c<a.length;c++)ud[a[c]]=d}function T(a,b){S(a,function(a,c,d,e){d._w=d._w||{},b(a,d._w,d,e)})}function U(a,b,c){null!=b&&f(ud,a)&&ud[a](b,c._a,c,a)}function V(a,b){return new Date(Date.UTC(a,b+1,0)).getUTCDate()}function W(a,b){return c(this._months)?this._months[a.month()]:this._months[Ed.test(b)?"format":"standalone"][a.month()]}function X(a,b){return c(this._monthsShort)?this._monthsShort[a.month()]:this._monthsShort[Ed.test(b)?"format":"standalone"][a.month()]}function Y(a,b,c){var d,e,f;for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),d=0;12>d;d++){if(e=h([2e3,d]),c&&!this._longMonthsParse[d]&&(this._longMonthsParse[d]=new RegExp("^"+this.months(e,"").replace(".","")+"$","i"),this._shortMonthsParse[d]=new RegExp("^"+this.monthsShort(e,"").replace(".","")+"$","i")),c||this._monthsParse[d]||(f="^"+this.months(e,"")+"|^"+this.monthsShort(e,""),this._monthsParse[d]=new RegExp(f.replace(".",""),"i")),c&&"MMMM"===b&&this._longMonthsParse[d].test(a))return d;if(c&&"MMM"===b&&this._shortMonthsParse[d].test(a))return d;if(!c&&this._monthsParse[d].test(a))return d}}function Z(a,b){var c;return a.isValid()?"string"==typeof b&&(b=a.localeData().monthsParse(b),"number"!=typeof b)?a:(c=Math.min(a.date(),V(a.year(),b)),a._d["set"+(a._isUTC?"UTC":"")+"Month"](b,c),a):a}function $(b){return null!=b?(Z(this,b),a.updateOffset(this,!0),this):F(this,"Month")}function _(){return V(this.year(),this.month())}function aa(a){return this._monthsParseExact?(f(this,"_monthsRegex")||ca.call(this),a?this._monthsShortStrictRegex:this._monthsShortRegex):this._monthsShortStrictRegex&&a?this._monthsShortStrictRegex:this._monthsShortRegex}function ba(a){return this._monthsParseExact?(f(this,"_monthsRegex")||ca.call(this),a?this._monthsStrictRegex:this._monthsRegex):this._monthsStrictRegex&&a?this._monthsStrictRegex:this._monthsRegex}function ca(){function a(a,b){return b.length-a.length}var b,c,d=[],e=[],f=[];for(b=0;12>b;b++)c=h([2e3,b]),d.push(this.monthsShort(c,"")),e.push(this.months(c,"")),f.push(this.months(c,"")),f.push(this.monthsShort(c,""));for(d.sort(a),e.sort(a),f.sort(a),b=0;12>b;b++)d[b]=R(d[b]),e[b]=R(e[b]),f[b]=R(f[b]);this._monthsRegex=new RegExp("^("+f.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+e.join("|")+")$","i"),this._monthsShortStrictRegex=new RegExp("^("+d.join("|")+")$","i")}function da(a){var b,c=a._a;return c&&-2===j(a).overflow&&(b=c[wd]<0||c[wd]>11?wd:c[xd]<1||c[xd]>V(c[vd],c[wd])?xd:c[yd]<0||c[yd]>24||24===c[yd]&&(0!==c[zd]||0!==c[Ad]||0!==c[Bd])?yd:c[zd]<0||c[zd]>59?zd:c[Ad]<0||c[Ad]>59?Ad:c[Bd]<0||c[Bd]>999?Bd:-1,j(a)._overflowDayOfYear&&(vd>b||b>xd)&&(b=xd),j(a)._overflowWeeks&&-1===b&&(b=Cd),j(a)._overflowWeekday&&-1===b&&(b=Dd),j(a).overflow=b),a}function ea(b){a.suppressDeprecationWarnings===!1&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+b)}function fa(a,b){var c=!0;return g(function(){return c&&(ea(a+"\nArguments: "+Array.prototype.slice.call(arguments).join(", ")+"\n"+(new Error).stack),c=!1),b.apply(this,arguments)},b)}function ga(a,b){Jd[a]||(ea(b),Jd[a]=!0)}function ha(a){var b,c,d,e,f,g,h=a._i,i=Kd.exec(h)||Ld.exec(h);if(i){for(j(a).iso=!0,b=0,c=Nd.length;c>b;b++)if(Nd[b][1].exec(i[1])){e=Nd[b][0],d=Nd[b][2]!==!1;break}if(null==e)return void(a._isValid=!1);if(i[3]){for(b=0,c=Od.length;c>b;b++)if(Od[b][1].exec(i[3])){f=(i[2]||" ")+Od[b][0];break}if(null==f)return void(a._isValid=!1)}if(!d&&null!=f)return void(a._isValid=!1);if(i[4]){if(!Md.exec(i[4]))return void(a._isValid=!1);g="Z"}a._f=e+(f||"")+(g||""),wa(a)}else a._isValid=!1}function ia(b){var c=Pd.exec(b._i);return null!==c?void(b._d=new Date(+c[1])):(ha(b),void(b._isValid===!1&&(delete b._isValid,a.createFromInputFallback(b))))}function ja(a,b,c,d,e,f,g){var h=new Date(a,b,c,d,e,f,g);return 100>a&&a>=0&&isFinite(h.getFullYear())&&h.setFullYear(a),h}function ka(a){var b=new Date(Date.UTC.apply(null,arguments));return 100>a&&a>=0&&isFinite(b.getUTCFullYear())&&b.setUTCFullYear(a),b}function la(a){return ma(a)?366:365}function ma(a){return a%4===0&&a%100!==0||a%400===0}function na(){return ma(this.year())}function oa(a,b,c){var d=7+b-c,e=(7+ka(a,0,d).getUTCDay()-b)%7;return-e+d-1}function pa(a,b,c,d,e){var f,g,h=(7+c-d)%7,i=oa(a,d,e),j=1+7*(b-1)+h+i;return 0>=j?(f=a-1,g=la(f)+j):j>la(a)?(f=a+1,g=j-la(a)):(f=a,g=j),{year:f,dayOfYear:g}}function qa(a,b,c){var d,e,f=oa(a.year(),b,c),g=Math.floor((a.dayOfYear()-f-1)/7)+1;return 1>g?(e=a.year()-1,d=g+ra(e,b,c)):g>ra(a.year(),b,c)?(d=g-ra(a.year(),b,c),e=a.year()+1):(e=a.year(),d=g),{week:d,year:e}}function ra(a,b,c){var d=oa(a,b,c),e=oa(a+1,b,c);return(la(a)-d+e)/7}function sa(a,b,c){return null!=a?a:null!=b?b:c}function ta(b){var c=new Date(a.now());return b._useUTC?[c.getUTCFullYear(),c.getUTCMonth(),c.getUTCDate()]:[c.getFullYear(),c.getMonth(),c.getDate()]}function ua(a){var b,c,d,e,f=[];if(!a._d){for(d=ta(a),a._w&&null==a._a[xd]&&null==a._a[wd]&&va(a),a._dayOfYear&&(e=sa(a._a[vd],d[vd]),a._dayOfYear>la(e)&&(j(a)._overflowDayOfYear=!0),c=ka(e,0,a._dayOfYear),a._a[wd]=c.getUTCMonth(),a._a[xd]=c.getUTCDate()),b=0;3>b&&null==a._a[b];++b)a._a[b]=f[b]=d[b];for(;7>b;b++)a._a[b]=f[b]=null==a._a[b]?2===b?1:0:a._a[b];24===a._a[yd]&&0===a._a[zd]&&0===a._a[Ad]&&0===a._a[Bd]&&(a._nextDay=!0,a._a[yd]=0),a._d=(a._useUTC?ka:ja).apply(null,f),null!=a._tzm&&a._d.setUTCMinutes(a._d.getUTCMinutes()-a._tzm),a._nextDay&&(a._a[yd]=24)}}function va(a){var b,c,d,e,f,g,h,i;b=a._w,null!=b.GG||null!=b.W||null!=b.E?(f=1,g=4,c=sa(b.GG,a._a[vd],qa(Ea(),1,4).year),d=sa(b.W,1),e=sa(b.E,1),(1>e||e>7)&&(i=!0)):(f=a._locale._week.dow,g=a._locale._week.doy,c=sa(b.gg,a._a[vd],qa(Ea(),f,g).year),d=sa(b.w,1),null!=b.d?(e=b.d,(0>e||e>6)&&(i=!0)):null!=b.e?(e=b.e+f,(b.e<0||b.e>6)&&(i=!0)):e=f),1>d||d>ra(c,f,g)?j(a)._overflowWeeks=!0:null!=i?j(a)._overflowWeekday=!0:(h=pa(c,d,e,f,g),a._a[vd]=h.year,a._dayOfYear=h.dayOfYear)}function wa(b){if(b._f===a.ISO_8601)return void ha(b);b._a=[],j(b).empty=!0;var c,d,e,f,g,h=""+b._i,i=h.length,k=0;for(e=N(b._f,b._locale).match($c)||[],c=0;c<e.length;c++)f=e[c],d=(h.match(P(f,b))||[])[0],d&&(g=h.substr(0,h.indexOf(d)),g.length>0&&j(b).unusedInput.push(g),h=h.slice(h.indexOf(d)+d.length),k+=d.length),bd[f]?(d?j(b).empty=!1:j(b).unusedTokens.push(f),U(f,d,b)):b._strict&&!d&&j(b).unusedTokens.push(f);j(b).charsLeftOver=i-k,h.length>0&&j(b).unusedInput.push(h),j(b).bigHour===!0&&b._a[yd]<=12&&b._a[yd]>0&&(j(b).bigHour=void 0),b._a[yd]=xa(b._locale,b._a[yd],b._meridiem),ua(b),da(b)}function xa(a,b,c){var d;return null==c?b:null!=a.meridiemHour?a.meridiemHour(b,c):null!=a.isPM?(d=a.isPM(c),d&&12>b&&(b+=12),d||12!==b||(b=0),b):b}function ya(a){var b,c,d,e,f;if(0===a._f.length)return j(a).invalidFormat=!0,void(a._d=new Date(NaN));for(e=0;e<a._f.length;e++)f=0,b=n({},a),null!=a._useUTC&&(b._useUTC=a._useUTC),b._f=a._f[e],wa(b),k(b)&&(f+=j(b).charsLeftOver,f+=10*j(b).unusedTokens.length,j(b).score=f,(null==d||d>f)&&(d=f,c=b));g(a,c||b)}function za(a){if(!a._d){var b=C(a._i);a._a=e([b.year,b.month,b.day||b.date,b.hour,b.minute,b.second,b.millisecond],function(a){return a&&parseInt(a,10)}),ua(a)}}function Aa(a){var b=new o(da(Ba(a)));return b._nextDay&&(b.add(1,"d"),b._nextDay=void 0),b}function Ba(a){var b=a._i,e=a._f;return a._locale=a._locale||z(a._l),null===b||void 0===e&&""===b?l({nullInput:!0}):("string"==typeof b&&(a._i=b=a._locale.preparse(b)),p(b)?new o(da(b)):(c(e)?ya(a):e?wa(a):d(b)?a._d=b:Ca(a),k(a)||(a._d=null),a))}function Ca(b){var f=b._i;void 0===f?b._d=new Date(a.now()):d(f)?b._d=new Date(+f):"string"==typeof f?ia(b):c(f)?(b._a=e(f.slice(0),function(a){return parseInt(a,10)}),ua(b)):"object"==typeof f?za(b):"number"==typeof f?b._d=new Date(f):a.createFromInputFallback(b)}function Da(a,b,c,d,e){var f={};return"boolean"==typeof c&&(d=c,c=void 0),f._isAMomentObject=!0,f._useUTC=f._isUTC=e,f._l=c,f._i=a,f._f=b,f._strict=d,Aa(f)}function Ea(a,b,c,d){return Da(a,b,c,d,!1)}function Fa(a,b){var d,e;if(1===b.length&&c(b[0])&&(b=b[0]),!b.length)return Ea();for(d=b[0],e=1;e<b.length;++e)(!b[e].isValid()||b[e][a](d))&&(d=b[e]);return d}function Ga(){var a=[].slice.call(arguments,0);return Fa("isBefore",a)}function Ha(){var a=[].slice.call(arguments,0);return Fa("isAfter",a)}function Ia(a){var b=C(a),c=b.year||0,d=b.quarter||0,e=b.month||0,f=b.week||0,g=b.day||0,h=b.hour||0,i=b.minute||0,j=b.second||0,k=b.millisecond||0;this._milliseconds=+k+1e3*j+6e4*i+36e5*h,this._days=+g+7*f,this._months=+e+3*d+12*c,this._data={},this._locale=z(),this._bubble()}function Ja(a){return a instanceof Ia}function Ka(a,b){J(a,0,0,function(){var a=this.utcOffset(),c="+";return 0>a&&(a=-a,c="-"),c+I(~~(a/60),2)+b+I(~~a%60,2)})}function La(a,b){var c=(b||"").match(a)||[],d=c[c.length-1]||[],e=(d+"").match(Ud)||["-",0,0],f=+(60*e[1])+r(e[2]);return"+"===e[0]?f:-f}function Ma(b,c){var e,f;return c._isUTC?(e=c.clone(),f=(p(b)||d(b)?+b:+Ea(b))-+e,e._d.setTime(+e._d+f),a.updateOffset(e,!1),e):Ea(b).local()}function Na(a){return 15*-Math.round(a._d.getTimezoneOffset()/15)}function Oa(b,c){var d,e=this._offset||0;return this.isValid()?null!=b?("string"==typeof b?b=La(qd,b):Math.abs(b)<16&&(b=60*b),!this._isUTC&&c&&(d=Na(this)),this._offset=b,this._isUTC=!0,null!=d&&this.add(d,"m"),e!==b&&(!c||this._changeInProgress?cb(this,Za(b-e,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,a.updateOffset(this,!0),this._changeInProgress=null)),this):this._isUTC?e:Na(this):null!=b?this:NaN}function Pa(a,b){return null!=a?("string"!=typeof a&&(a=-a),this.utcOffset(a,b),this):-this.utcOffset()}function Qa(a){return this.utcOffset(0,a)}function Ra(a){return this._isUTC&&(this.utcOffset(0,a),this._isUTC=!1,a&&this.subtract(Na(this),"m")),this}function Sa(){return this._tzm?this.utcOffset(this._tzm):"string"==typeof this._i&&this.utcOffset(La(pd,this._i)),this}function Ta(a){return this.isValid()?(a=a?Ea(a).utcOffset():0,(this.utcOffset()-a)%60===0):!1}function Ua(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()}function Va(){if(!m(this._isDSTShifted))return this._isDSTShifted;var a={};if(n(a,this),a=Ba(a),a._a){var b=a._isUTC?h(a._a):Ea(a._a);this._isDSTShifted=this.isValid()&&s(a._a,b.toArray())>0}else this._isDSTShifted=!1;return this._isDSTShifted}function Wa(){return this.isValid()?!this._isUTC:!1}function Xa(){return this.isValid()?this._isUTC:!1}function Ya(){return this.isValid()?this._isUTC&&0===this._offset:!1}function Za(a,b){var c,d,e,g=a,h=null;return Ja(a)?g={ms:a._milliseconds,d:a._days,M:a._months}:"number"==typeof a?(g={},b?g[b]=a:g.milliseconds=a):(h=Vd.exec(a))?(c="-"===h[1]?-1:1,g={y:0,d:r(h[xd])*c,h:r(h[yd])*c,m:r(h[zd])*c,s:r(h[Ad])*c,ms:r(h[Bd])*c}):(h=Wd.exec(a))?(c="-"===h[1]?-1:1,g={y:$a(h[2],c),M:$a(h[3],c),d:$a(h[4],c),h:$a(h[5],c),m:$a(h[6],c),s:$a(h[7],c),w:$a(h[8],c)}):null==g?g={}:"object"==typeof g&&("from"in g||"to"in g)&&(e=ab(Ea(g.from),Ea(g.to)),g={},g.ms=e.milliseconds,g.M=e.months),d=new Ia(g),Ja(a)&&f(a,"_locale")&&(d._locale=a._locale),d}function $a(a,b){var c=a&&parseFloat(a.replace(",","."));return(isNaN(c)?0:c)*b}function _a(a,b){var c={milliseconds:0,months:0};return c.months=b.month()-a.month()+12*(b.year()-a.year()),a.clone().add(c.months,"M").isAfter(b)&&--c.months,c.milliseconds=+b-+a.clone().add(c.months,"M"),c}function ab(a,b){var c;return a.isValid()&&b.isValid()?(b=Ma(b,a),a.isBefore(b)?c=_a(a,b):(c=_a(b,a),c.milliseconds=-c.milliseconds,c.months=-c.months),c):{milliseconds:0,months:0}}function bb(a,b){return function(c,d){var e,f;return null===d||isNaN(+d)||(ga(b,"moment()."+b+"(period, number) is deprecated. Please use moment()."+b+"(number, period)."),f=c,c=d,d=f),c="string"==typeof c?+c:c,e=Za(c,d),cb(this,e,a),this}}function cb(b,c,d,e){var f=c._milliseconds,g=c._days,h=c._months;b.isValid()&&(e=null==e?!0:e,f&&b._d.setTime(+b._d+f*d),g&&G(b,"Date",F(b,"Date")+g*d),h&&Z(b,F(b,"Month")+h*d),e&&a.updateOffset(b,g||h))}function db(a,b){var c=a||Ea(),d=Ma(c,this).startOf("day"),e=this.diff(d,"days",!0),f=-6>e?"sameElse":-1>e?"lastWeek":0>e?"lastDay":1>e?"sameDay":2>e?"nextDay":7>e?"nextWeek":"sameElse",g=b&&(D(b[f])?b[f]():b[f]);return this.format(g||this.localeData().calendar(f,this,Ea(c)))}function eb(){return new o(this)}function fb(a,b){var c=p(a)?a:Ea(a);return this.isValid()&&c.isValid()?(b=B(m(b)?"millisecond":b),"millisecond"===b?+this>+c:+c<+this.clone().startOf(b)):!1}function gb(a,b){var c=p(a)?a:Ea(a);return this.isValid()&&c.isValid()?(b=B(m(b)?"millisecond":b),"millisecond"===b?+c>+this:+this.clone().endOf(b)<+c):!1}function hb(a,b,c){return this.isAfter(a,c)&&this.isBefore(b,c)}function ib(a,b){var c,d=p(a)?a:Ea(a);return this.isValid()&&d.isValid()?(b=B(b||"millisecond"),"millisecond"===b?+this===+d:(c=+d,+this.clone().startOf(b)<=c&&c<=+this.clone().endOf(b))):!1}function jb(a,b){return this.isSame(a,b)||this.isAfter(a,b)}function kb(a,b){return this.isSame(a,b)||this.isBefore(a,b)}function lb(a,b,c){var d,e,f,g;return this.isValid()?(d=Ma(a,this),d.isValid()?(e=6e4*(d.utcOffset()-this.utcOffset()),b=B(b),"year"===b||"month"===b||"quarter"===b?(g=mb(this,d),"quarter"===b?g/=3:"year"===b&&(g/=12)):(f=this-d,g="second"===b?f/1e3:"minute"===b?f/6e4:"hour"===b?f/36e5:"day"===b?(f-e)/864e5:"week"===b?(f-e)/6048e5:f),c?g:q(g)):NaN):NaN}function mb(a,b){var c,d,e=12*(b.year()-a.year())+(b.month()-a.month()),f=a.clone().add(e,"months");return 0>b-f?(c=a.clone().add(e-1,"months"),d=(b-f)/(f-c)):(c=a.clone().add(e+1,"months"),d=(b-f)/(c-f)),-(e+d)}function nb(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")}function ob(){var a=this.clone().utc();return 0<a.year()&&a.year()<=9999?D(Date.prototype.toISOString)?this.toDate().toISOString():M(a,"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]"):M(a,"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")}function pb(b){var c=M(this,b||a.defaultFormat);return this.localeData().postformat(c)}function qb(a,b){return this.isValid()&&(p(a)&&a.isValid()||Ea(a).isValid())?Za({to:this,from:a}).locale(this.locale()).humanize(!b):this.localeData().invalidDate()}function rb(a){return this.from(Ea(),a)}function sb(a,b){return this.isValid()&&(p(a)&&a.isValid()||Ea(a).isValid())?Za({from:this,to:a}).locale(this.locale()).humanize(!b):this.localeData().invalidDate()}function tb(a){return this.to(Ea(),a)}function ub(a){var b;return void 0===a?this._locale._abbr:(b=z(a),null!=b&&(this._locale=b),this)}function vb(){return this._locale}function wb(a){switch(a=B(a)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===a&&this.weekday(0),"isoWeek"===a&&this.isoWeekday(1),"quarter"===a&&this.month(3*Math.floor(this.month()/3)),this}function xb(a){return a=B(a),void 0===a||"millisecond"===a?this:this.startOf(a).add(1,"isoWeek"===a?"week":a).subtract(1,"ms")}function yb(){return+this._d-6e4*(this._offset||0)}function zb(){return Math.floor(+this/1e3)}function Ab(){return this._offset?new Date(+this):this._d}function Bb(){var a=this;return[a.year(),a.month(),a.date(),a.hour(),a.minute(),a.second(),a.millisecond()]}function Cb(){var a=this;return{years:a.year(),months:a.month(),date:a.date(),hours:a.hours(),minutes:a.minutes(),seconds:a.seconds(),milliseconds:a.milliseconds()}}function Db(){return this.isValid()?this.toISOString():"null"}function Eb(){return k(this)}function Fb(){return g({},j(this))}function Gb(){return j(this).overflow}function Hb(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}}function Ib(a,b){J(0,[a,a.length],0,b)}function Jb(a){return Nb.call(this,a,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)}function Kb(a){return Nb.call(this,a,this.isoWeek(),this.isoWeekday(),1,4)}function Lb(){return ra(this.year(),1,4)}function Mb(){var a=this.localeData()._week;return ra(this.year(),a.dow,a.doy)}function Nb(a,b,c,d,e){var f;return null==a?qa(this,d,e).year:(f=ra(a,d,e),b>f&&(b=f),Ob.call(this,a,b,c,d,e))}function Ob(a,b,c,d,e){var f=pa(a,b,c,d,e),g=ka(f.year,0,f.dayOfYear);return this.year(g.getUTCFullYear()),this.month(g.getUTCMonth()),this.date(g.getUTCDate()),this}function Pb(a){return null==a?Math.ceil((this.month()+1)/3):this.month(3*(a-1)+this.month()%3)}function Qb(a){return qa(a,this._week.dow,this._week.doy).week}function Rb(){return this._week.dow}function Sb(){return this._week.doy}function Tb(a){var b=this.localeData().week(this);return null==a?b:this.add(7*(a-b),"d")}function Ub(a){var b=qa(this,1,4).week;return null==a?b:this.add(7*(a-b),"d")}function Vb(a,b){return"string"!=typeof a?a:isNaN(a)?(a=b.weekdaysParse(a),"number"==typeof a?a:null):parseInt(a,10)}function Wb(a,b){return c(this._weekdays)?this._weekdays[a.day()]:this._weekdays[this._weekdays.isFormat.test(b)?"format":"standalone"][a.day()]}function Xb(a){return this._weekdaysShort[a.day()]}function Yb(a){return this._weekdaysMin[a.day()]}function Zb(a,b,c){var d,e,f;for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),d=0;7>d;d++){if(e=Ea([2e3,1]).day(d),c&&!this._fullWeekdaysParse[d]&&(this._fullWeekdaysParse[d]=new RegExp("^"+this.weekdays(e,"").replace(".",".?")+"$","i"),this._shortWeekdaysParse[d]=new RegExp("^"+this.weekdaysShort(e,"").replace(".",".?")+"$","i"),this._minWeekdaysParse[d]=new RegExp("^"+this.weekdaysMin(e,"").replace(".",".?")+"$","i")),this._weekdaysParse[d]||(f="^"+this.weekdays(e,"")+"|^"+this.weekdaysShort(e,"")+"|^"+this.weekdaysMin(e,""),this._weekdaysParse[d]=new RegExp(f.replace(".",""),"i")),c&&"dddd"===b&&this._fullWeekdaysParse[d].test(a))return d;if(c&&"ddd"===b&&this._shortWeekdaysParse[d].test(a))return d;if(c&&"dd"===b&&this._minWeekdaysParse[d].test(a))return d;if(!c&&this._weekdaysParse[d].test(a))return d}}function $b(a){if(!this.isValid())return null!=a?this:NaN;var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=a?(a=Vb(a,this.localeData()),this.add(a-b,"d")):b}function _b(a){if(!this.isValid())return null!=a?this:NaN;var b=(this.day()+7-this.localeData()._week.dow)%7;return null==a?b:this.add(a-b,"d")}function ac(a){return this.isValid()?null==a?this.day()||7:this.day(this.day()%7?a:a-7):null!=a?this:NaN}function bc(a){var b=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==a?b:this.add(a-b,"d")}function cc(){return this.hours()%12||12}function dc(a,b){J(a,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),b)})}function ec(a,b){return b._meridiemParse}function fc(a){return"p"===(a+"").toLowerCase().charAt(0)}function gc(a,b,c){return a>11?c?"pm":"PM":c?"am":"AM"}function hc(a,b){b[Bd]=r(1e3*("0."+a))}function ic(){return this._isUTC?"UTC":""}function jc(){return this._isUTC?"Coordinated Universal Time":""}function kc(a){return Ea(1e3*a)}function lc(){return Ea.apply(null,arguments).parseZone()}function mc(a,b,c){var d=this._calendar[a];return D(d)?d.call(b,c):d}function nc(a){var b=this._longDateFormat[a],c=this._longDateFormat[a.toUpperCase()];return b||!c?b:(this._longDateFormat[a]=c.replace(/MMMM|MM|DD|dddd/g,function(a){return a.slice(1)}),this._longDateFormat[a])}function oc(){return this._invalidDate}function pc(a){return this._ordinal.replace("%d",a)}function qc(a){return a}function rc(a,b,c,d){var e=this._relativeTime[c];return D(e)?e(a,b,c,d):e.replace(/%d/i,a)}function sc(a,b){var c=this._relativeTime[a>0?"future":"past"];return D(c)?c(b):c.replace(/%s/i,b)}function tc(a){var b,c;for(c in a)b=a[c],D(b)?this[c]=b:this["_"+c]=b;this._ordinalParseLenient=new RegExp(this._ordinalParse.source+"|"+/\d{1,2}/.source)}function uc(a,b,c,d){var e=z(),f=h().set(d,b);return e[c](f,a)}function vc(a,b,c,d,e){if("number"==typeof a&&(b=a,a=void 0),a=a||"",null!=b)return uc(a,b,c,e);var f,g=[];for(f=0;d>f;f++)g[f]=uc(a,f,c,e);return g}function wc(a,b){return vc(a,b,"months",12,"month")}function xc(a,b){return vc(a,b,"monthsShort",12,"month")}function yc(a,b){return vc(a,b,"weekdays",7,"day")}function zc(a,b){return vc(a,b,"weekdaysShort",7,"day")}function Ac(a,b){return vc(a,b,"weekdaysMin",7,"day")}function Bc(){var a=this._data;return this._milliseconds=se(this._milliseconds),this._days=se(this._days),this._months=se(this._months),a.milliseconds=se(a.milliseconds),a.seconds=se(a.seconds),a.minutes=se(a.minutes),a.hours=se(a.hours),a.months=se(a.months),a.years=se(a.years),this}function Cc(a,b,c,d){var e=Za(b,c);return a._milliseconds+=d*e._milliseconds,a._days+=d*e._days,a._months+=d*e._months,a._bubble()}function Dc(a,b){return Cc(this,a,b,1)}function Ec(a,b){return Cc(this,a,b,-1)}function Fc(a){return 0>a?Math.floor(a):Math.ceil(a)}function Gc(){var a,b,c,d,e,f=this._milliseconds,g=this._days,h=this._months,i=this._data;return f>=0&&g>=0&&h>=0||0>=f&&0>=g&&0>=h||(f+=864e5*Fc(Ic(h)+g),g=0,h=0),i.milliseconds=f%1e3,a=q(f/1e3),i.seconds=a%60,b=q(a/60),i.minutes=b%60,c=q(b/60),i.hours=c%24,g+=q(c/24),e=q(Hc(g)),h+=e,g-=Fc(Ic(e)),d=q(h/12),h%=12,i.days=g,i.months=h,i.years=d,this}function Hc(a){return 4800*a/146097}function Ic(a){return 146097*a/4800}function Jc(a){var b,c,d=this._milliseconds;if(a=B(a),"month"===a||"year"===a)return b=this._days+d/864e5,c=this._months+Hc(b),"month"===a?c:c/12;switch(b=this._days+Math.round(Ic(this._months)),a){case"week":return b/7+d/6048e5;case"day":return b+d/864e5;case"hour":return 24*b+d/36e5;case"minute":return 1440*b+d/6e4;case"second":return 86400*b+d/1e3;case"millisecond":return Math.floor(864e5*b)+d;default:throw new Error("Unknown unit "+a)}}function Kc(){return this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*r(this._months/12)}function Lc(a){return function(){return this.as(a)}}function Mc(a){return a=B(a),this[a+"s"]()}function Nc(a){return function(){return this._data[a]}}function Oc(){return q(this.days()/7)}function Pc(a,b,c,d,e){return e.relativeTime(b||1,!!c,a,d)}function Qc(a,b,c){var d=Za(a).abs(),e=Ie(d.as("s")),f=Ie(d.as("m")),g=Ie(d.as("h")),h=Ie(d.as("d")),i=Ie(d.as("M")),j=Ie(d.as("y")),k=e<Je.s&&["s",e]||1>=f&&["m"]||f<Je.m&&["mm",f]||1>=g&&["h"]||g<Je.h&&["hh",g]||1>=h&&["d"]||h<Je.d&&["dd",h]||1>=i&&["M"]||i<Je.M&&["MM",i]||1>=j&&["y"]||["yy",j];return k[2]=b,k[3]=+a>0,k[4]=c,Pc.apply(null,k)}function Rc(a,b){return void 0===Je[a]?!1:void 0===b?Je[a]:(Je[a]=b,!0)}function Sc(a){var b=this.localeData(),c=Qc(this,!a,b);return a&&(c=b.pastFuture(+this,c)),b.postformat(c)}function Tc(){var a,b,c,d=Ke(this._milliseconds)/1e3,e=Ke(this._days),f=Ke(this._months);a=q(d/60),b=q(a/60),d%=60,a%=60,c=q(f/12),f%=12;var g=c,h=f,i=e,j=b,k=a,l=d,m=this.asSeconds();return m?(0>m?"-":"")+"P"+(g?g+"Y":"")+(h?h+"M":"")+(i?i+"D":"")+(j||k||l?"T":"")+(j?j+"H":"")+(k?k+"M":"")+(l?l+"S":""):"P0D"}var Uc,Vc,Wc=a.momentProperties=[],Xc=!1,Yc={},Zc={},$c=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,_c=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,ad={},bd={},cd=/\d/,dd=/\d\d/,ed=/\d{3}/,fd=/\d{4}/,gd=/[+-]?\d{6}/,hd=/\d\d?/,id=/\d\d\d\d?/,jd=/\d\d\d\d\d\d?/,kd=/\d{1,3}/,ld=/\d{1,4}/,md=/[+-]?\d{1,6}/,nd=/\d+/,od=/[+-]?\d+/,pd=/Z|[+-]\d\d:?\d\d/gi,qd=/Z|[+-]\d\d(?::?\d\d)?/gi,rd=/[+-]?\d+(\.\d{1,3})?/,sd=/[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,td={},ud={},vd=0,wd=1,xd=2,yd=3,zd=4,Ad=5,Bd=6,Cd=7,Dd=8;J("M",["MM",2],"Mo",function(){return this.month()+1}),J("MMM",0,0,function(a){return this.localeData().monthsShort(this,a)}),J("MMMM",0,0,function(a){return this.localeData().months(this,a)}),A("month","M"),O("M",hd),O("MM",hd,dd),O("MMM",function(a,b){return b.monthsShortRegex(a)}),O("MMMM",function(a,b){return b.monthsRegex(a)}),S(["M","MM"],function(a,b){b[wd]=r(a)-1}),S(["MMM","MMMM"],function(a,b,c,d){var e=c._locale.monthsParse(a,d,c._strict);null!=e?b[wd]=e:j(c).invalidMonth=a});var Ed=/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/,Fd="January_February_March_April_May_June_July_August_September_October_November_December".split("_"),Gd="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),Hd=sd,Id=sd,Jd={};a.suppressDeprecationWarnings=!1;var Kd=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/,Ld=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/,Md=/Z|[+-]\d\d(?::?\d\d)?/,Nd=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],Od=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],Pd=/^\/?Date\((\-?\d+)/i;a.createFromInputFallback=fa("moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to https://github.com/moment/moment/issues/1407 for more info.",function(a){a._d=new Date(a._i+(a._useUTC?" UTC":""))}),J("Y",0,0,function(){var a=this.year();return 9999>=a?""+a:"+"+a}),J(0,["YY",2],0,function(){return this.year()%100}),J(0,["YYYY",4],0,"year"),J(0,["YYYYY",5],0,"year"),J(0,["YYYYYY",6,!0],0,"year"),A("year","y"),O("Y",od),O("YY",hd,dd),O("YYYY",ld,fd),O("YYYYY",md,gd),O("YYYYYY",md,gd),S(["YYYYY","YYYYYY"],vd),S("YYYY",function(b,c){c[vd]=2===b.length?a.parseTwoDigitYear(b):r(b)}),S("YY",function(b,c){c[vd]=a.parseTwoDigitYear(b)}),S("Y",function(a,b){b[vd]=parseInt(a,10)}),a.parseTwoDigitYear=function(a){return r(a)+(r(a)>68?1900:2e3)};var Qd=E("FullYear",!1);a.ISO_8601=function(){};var Rd=fa("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548",function(){var a=Ea.apply(null,arguments);return this.isValid()&&a.isValid()?this>a?this:a:l()}),Sd=fa("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548",function(){var a=Ea.apply(null,arguments);return this.isValid()&&a.isValid()?a>this?this:a:l()}),Td=function(){return Date.now?Date.now():+new Date};Ka("Z",":"),Ka("ZZ",""),O("Z",qd),O("ZZ",qd),S(["Z","ZZ"],function(a,b,c){c._useUTC=!0,c._tzm=La(qd,a)});var Ud=/([\+\-]|\d\d)/gi;a.updateOffset=function(){};var Vd=/^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/,Wd=/^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
    Za.fn=Ia.prototype;var Xd=bb(1,"add"),Yd=bb(-1,"subtract");a.defaultFormat="YYYY-MM-DDTHH:mm:ssZ";var Zd=fa("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(a){return void 0===a?this.localeData():this.locale(a)});J(0,["gg",2],0,function(){return this.weekYear()%100}),J(0,["GG",2],0,function(){return this.isoWeekYear()%100}),Ib("gggg","weekYear"),Ib("ggggg","weekYear"),Ib("GGGG","isoWeekYear"),Ib("GGGGG","isoWeekYear"),A("weekYear","gg"),A("isoWeekYear","GG"),O("G",od),O("g",od),O("GG",hd,dd),O("gg",hd,dd),O("GGGG",ld,fd),O("gggg",ld,fd),O("GGGGG",md,gd),O("ggggg",md,gd),T(["gggg","ggggg","GGGG","GGGGG"],function(a,b,c,d){b[d.substr(0,2)]=r(a)}),T(["gg","GG"],function(b,c,d,e){c[e]=a.parseTwoDigitYear(b)}),J("Q",0,"Qo","quarter"),A("quarter","Q"),O("Q",cd),S("Q",function(a,b){b[wd]=3*(r(a)-1)}),J("w",["ww",2],"wo","week"),J("W",["WW",2],"Wo","isoWeek"),A("week","w"),A("isoWeek","W"),O("w",hd),O("ww",hd,dd),O("W",hd),O("WW",hd,dd),T(["w","ww","W","WW"],function(a,b,c,d){b[d.substr(0,1)]=r(a)});var $d={dow:0,doy:6};J("D",["DD",2],"Do","date"),A("date","D"),O("D",hd),O("DD",hd,dd),O("Do",function(a,b){return a?b._ordinalParse:b._ordinalParseLenient}),S(["D","DD"],xd),S("Do",function(a,b){b[xd]=r(a.match(hd)[0],10)});var _d=E("Date",!0);J("d",0,"do","day"),J("dd",0,0,function(a){return this.localeData().weekdaysMin(this,a)}),J("ddd",0,0,function(a){return this.localeData().weekdaysShort(this,a)}),J("dddd",0,0,function(a){return this.localeData().weekdays(this,a)}),J("e",0,0,"weekday"),J("E",0,0,"isoWeekday"),A("day","d"),A("weekday","e"),A("isoWeekday","E"),O("d",hd),O("e",hd),O("E",hd),O("dd",sd),O("ddd",sd),O("dddd",sd),T(["dd","ddd","dddd"],function(a,b,c,d){var e=c._locale.weekdaysParse(a,d,c._strict);null!=e?b.d=e:j(c).invalidWeekday=a}),T(["d","e","E"],function(a,b,c,d){b[d]=r(a)});var ae="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),be="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),ce="Su_Mo_Tu_We_Th_Fr_Sa".split("_");J("DDD",["DDDD",3],"DDDo","dayOfYear"),A("dayOfYear","DDD"),O("DDD",kd),O("DDDD",ed),S(["DDD","DDDD"],function(a,b,c){c._dayOfYear=r(a)}),J("H",["HH",2],0,"hour"),J("h",["hh",2],0,cc),J("hmm",0,0,function(){return""+cc.apply(this)+I(this.minutes(),2)}),J("hmmss",0,0,function(){return""+cc.apply(this)+I(this.minutes(),2)+I(this.seconds(),2)}),J("Hmm",0,0,function(){return""+this.hours()+I(this.minutes(),2)}),J("Hmmss",0,0,function(){return""+this.hours()+I(this.minutes(),2)+I(this.seconds(),2)}),dc("a",!0),dc("A",!1),A("hour","h"),O("a",ec),O("A",ec),O("H",hd),O("h",hd),O("HH",hd,dd),O("hh",hd,dd),O("hmm",id),O("hmmss",jd),O("Hmm",id),O("Hmmss",jd),S(["H","HH"],yd),S(["a","A"],function(a,b,c){c._isPm=c._locale.isPM(a),c._meridiem=a}),S(["h","hh"],function(a,b,c){b[yd]=r(a),j(c).bigHour=!0}),S("hmm",function(a,b,c){var d=a.length-2;b[yd]=r(a.substr(0,d)),b[zd]=r(a.substr(d)),j(c).bigHour=!0}),S("hmmss",function(a,b,c){var d=a.length-4,e=a.length-2;b[yd]=r(a.substr(0,d)),b[zd]=r(a.substr(d,2)),b[Ad]=r(a.substr(e)),j(c).bigHour=!0}),S("Hmm",function(a,b,c){var d=a.length-2;b[yd]=r(a.substr(0,d)),b[zd]=r(a.substr(d))}),S("Hmmss",function(a,b,c){var d=a.length-4,e=a.length-2;b[yd]=r(a.substr(0,d)),b[zd]=r(a.substr(d,2)),b[Ad]=r(a.substr(e))});var de=/[ap]\.?m?\.?/i,ee=E("Hours",!0);J("m",["mm",2],0,"minute"),A("minute","m"),O("m",hd),O("mm",hd,dd),S(["m","mm"],zd);var fe=E("Minutes",!1);J("s",["ss",2],0,"second"),A("second","s"),O("s",hd),O("ss",hd,dd),S(["s","ss"],Ad);var ge=E("Seconds",!1);J("S",0,0,function(){return~~(this.millisecond()/100)}),J(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),J(0,["SSS",3],0,"millisecond"),J(0,["SSSS",4],0,function(){return 10*this.millisecond()}),J(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),J(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),J(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),J(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),J(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),A("millisecond","ms"),O("S",kd,cd),O("SS",kd,dd),O("SSS",kd,ed);var he;for(he="SSSS";he.length<=9;he+="S")O(he,nd);for(he="S";he.length<=9;he+="S")S(he,hc);var ie=E("Milliseconds",!1);J("z",0,0,"zoneAbbr"),J("zz",0,0,"zoneName");var je=o.prototype;je.add=Xd,je.calendar=db,je.clone=eb,je.diff=lb,je.endOf=xb,je.format=pb,je.from=qb,je.fromNow=rb,je.to=sb,je.toNow=tb,je.get=H,je.invalidAt=Gb,je.isAfter=fb,je.isBefore=gb,je.isBetween=hb,je.isSame=ib,je.isSameOrAfter=jb,je.isSameOrBefore=kb,je.isValid=Eb,je.lang=Zd,je.locale=ub,je.localeData=vb,je.max=Sd,je.min=Rd,je.parsingFlags=Fb,je.set=H,je.startOf=wb,je.subtract=Yd,je.toArray=Bb,je.toObject=Cb,je.toDate=Ab,je.toISOString=ob,je.toJSON=Db,je.toString=nb,je.unix=zb,je.valueOf=yb,je.creationData=Hb,je.year=Qd,je.isLeapYear=na,je.weekYear=Jb,je.isoWeekYear=Kb,je.quarter=je.quarters=Pb,je.month=$,je.daysInMonth=_,je.week=je.weeks=Tb,je.isoWeek=je.isoWeeks=Ub,je.weeksInYear=Mb,je.isoWeeksInYear=Lb,je.date=_d,je.day=je.days=$b,je.weekday=_b,je.isoWeekday=ac,je.dayOfYear=bc,je.hour=je.hours=ee,je.minute=je.minutes=fe,je.second=je.seconds=ge,je.millisecond=je.milliseconds=ie,je.utcOffset=Oa,je.utc=Qa,je.local=Ra,je.parseZone=Sa,je.hasAlignedHourOffset=Ta,je.isDST=Ua,je.isDSTShifted=Va,je.isLocal=Wa,je.isUtcOffset=Xa,je.isUtc=Ya,je.isUTC=Ya,je.zoneAbbr=ic,je.zoneName=jc,je.dates=fa("dates accessor is deprecated. Use date instead.",_d),je.months=fa("months accessor is deprecated. Use month instead",$),je.years=fa("years accessor is deprecated. Use year instead",Qd),je.zone=fa("moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779",Pa);var ke=je,le={sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},me={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},ne="Invalid date",oe="%d",pe=/\d{1,2}/,qe={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},re=t.prototype;re._calendar=le,re.calendar=mc,re._longDateFormat=me,re.longDateFormat=nc,re._invalidDate=ne,re.invalidDate=oc,re._ordinal=oe,re.ordinal=pc,re._ordinalParse=pe,re.preparse=qc,re.postformat=qc,re._relativeTime=qe,re.relativeTime=rc,re.pastFuture=sc,re.set=tc,re.months=W,re._months=Fd,re.monthsShort=X,re._monthsShort=Gd,re.monthsParse=Y,re._monthsRegex=Id,re.monthsRegex=ba,re._monthsShortRegex=Hd,re.monthsShortRegex=aa,re.week=Qb,re._week=$d,re.firstDayOfYear=Sb,re.firstDayOfWeek=Rb,re.weekdays=Wb,re._weekdays=ae,re.weekdaysMin=Yb,re._weekdaysMin=ce,re.weekdaysShort=Xb,re._weekdaysShort=be,re.weekdaysParse=Zb,re.isPM=fc,re._meridiemParse=de,re.meridiem=gc,x("en",{ordinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(a){var b=a%10,c=1===r(a%100/10)?"th":1===b?"st":2===b?"nd":3===b?"rd":"th";return a+c}}),a.lang=fa("moment.lang is deprecated. Use moment.locale instead.",x),a.langData=fa("moment.langData is deprecated. Use moment.localeData instead.",z);var se=Math.abs,te=Lc("ms"),ue=Lc("s"),ve=Lc("m"),we=Lc("h"),xe=Lc("d"),ye=Lc("w"),ze=Lc("M"),Ae=Lc("y"),Be=Nc("milliseconds"),Ce=Nc("seconds"),De=Nc("minutes"),Ee=Nc("hours"),Fe=Nc("days"),Ge=Nc("months"),He=Nc("years"),Ie=Math.round,Je={s:45,m:45,h:22,d:26,M:11},Ke=Math.abs,Le=Ia.prototype;Le.abs=Bc,Le.add=Dc,Le.subtract=Ec,Le.as=Jc,Le.asMilliseconds=te,Le.asSeconds=ue,Le.asMinutes=ve,Le.asHours=we,Le.asDays=xe,Le.asWeeks=ye,Le.asMonths=ze,Le.asYears=Ae,Le.valueOf=Kc,Le._bubble=Gc,Le.get=Mc,Le.milliseconds=Be,Le.seconds=Ce,Le.minutes=De,Le.hours=Ee,Le.days=Fe,Le.weeks=Oc,Le.months=Ge,Le.years=He,Le.humanize=Sc,Le.toISOString=Tc,Le.toString=Tc,Le.toJSON=Tc,Le.locale=ub,Le.localeData=vb,Le.toIsoString=fa("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",Tc),Le.lang=Zd,J("X",0,0,"unix"),J("x",0,0,"valueOf"),O("x",od),O("X",rd),S("X",function(a,b,c){c._d=new Date(1e3*parseFloat(a,10))}),S("x",function(a,b,c){c._d=new Date(r(a))}),a.version="2.11.2",b(Ea),a.fn=ke,a.min=Ga,a.max=Ha,a.now=Td,a.utc=h,a.unix=kc,a.months=wc,a.isDate=d,a.locale=x,a.invalid=l,a.duration=Za,a.isMoment=p,a.weekdays=yc,a.parseZone=lc,a.localeData=z,a.isDuration=Ja,a.monthsShort=xc,a.weekdaysMin=Ac,a.defineLocale=y,a.weekdaysShort=zc,a.normalizeUnits=B,a.relativeTimeThreshold=Rc,a.prototype=ke;var Me=a;return Me});;// moment.js locale configuration
// locale : german (de)
// author : lluchs : https://github.com/lluchs
// author: Menelion Elensle: https://github.com/Oire
// author : Mikolaj Dadela : https://github.com/mik01aj
/*global moment*/

"use strict";
(function (factory) {
    factory(moment);
}(function (moment) {
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    return moment.defineLocale('de', {
        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd, D. MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[Morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[Gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });
}));
;(function(t,e){if(typeof exports=="object")module.exports=e();else if(typeof define=="function"&&define.amd)define(e);else t.Spinner=e()})(this,function(){"use strict";var t=["webkit","Moz","ms","O"],e={},i;function o(t,e){var i=document.createElement(t||"div"),o;for(o in e)i[o]=e[o];return i}function n(t){for(var e=1,i=arguments.length;e<i;e++)t.appendChild(arguments[e]);return t}var r=function(){var t=o("style",{type:"text/css"});n(document.getElementsByTagName("head")[0],t);return t.sheet||t.styleSheet}();function s(t,o,n,s){var a=["opacity",o,~~(t*100),n,s].join("-"),f=.01+n/s*100,l=Math.max(1-(1-t)/o*(100-f),t),d=i.substring(0,i.indexOf("Animation")).toLowerCase(),u=d&&"-"+d+"-"||"";if(!e[a]){r.insertRule("@"+u+"keyframes "+a+"{"+"0%{opacity:"+l+"}"+f+"%{opacity:"+t+"}"+(f+.01)+"%{opacity:1}"+(f+o)%100+"%{opacity:"+t+"}"+"100%{opacity:"+l+"}"+"}",r.cssRules.length);e[a]=1}return a}function a(e,i){var o=e.style,n,r;if(o[i]!==undefined)return i;i=i.charAt(0).toUpperCase()+i.slice(1);for(r=0;r<t.length;r++){n=t[r]+i;if(o[n]!==undefined)return n}}function f(t,e){for(var i in e)t.style[a(t,i)||i]=e[i];return t}function l(t){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var o in i)if(t[o]===undefined)t[o]=i[o]}return t}function d(t){var e={x:t.offsetLeft,y:t.offsetTop};while(t=t.offsetParent)e.x+=t.offsetLeft,e.y+=t.offsetTop;return e}var u={lines:12,length:7,width:5,radius:10,rotate:0,corners:1,color:"#000",direction:1,speed:1,trail:100,opacity:1/4,fps:20,zIndex:2e9,className:"spinner",top:"auto",left:"auto",position:"relative"};function p(t){if(typeof this=="undefined")return new p(t);this.opts=l(t||{},p.defaults,u)}p.defaults={};l(p.prototype,{spin:function(t){this.stop();var e=this,n=e.opts,r=e.el=f(o(0,{className:n.className}),{position:n.position,width:0,zIndex:n.zIndex}),s=n.radius+n.length+n.width,a,l;if(t){t.insertBefore(r,t.firstChild||null);l=d(t);a=d(r);f(r,{left:(n.left=="auto"?l.x-a.x+(t.offsetWidth>>1):parseInt(n.left,10)+s)+"px",top:(n.top=="auto"?l.y-a.y+(t.offsetHeight>>1):parseInt(n.top,10)+s)+"px"})}r.setAttribute("role","progressbar");e.lines(r,e.opts);if(!i){var u=0,p=(n.lines-1)*(1-n.direction)/2,c,h=n.fps,m=h/n.speed,y=(1-n.opacity)/(m*n.trail/100),g=m/n.lines;(function v(){u++;for(var t=0;t<n.lines;t++){c=Math.max(1-(u+(n.lines-t)*g)%m*y,n.opacity);e.opacity(r,t*n.direction+p,c,n)}e.timeout=e.el&&setTimeout(v,~~(1e3/h))})()}return e},stop:function(){var t=this.el;if(t){clearTimeout(this.timeout);if(t.parentNode)t.parentNode.removeChild(t);this.el=undefined}return this},lines:function(t,e){var r=0,a=(e.lines-1)*(1-e.direction)/2,l;function d(t,i){return f(o(),{position:"absolute",width:e.length+e.width+"px",height:e.width+"px",background:t,boxShadow:i,transformOrigin:"left",transform:"rotate("+~~(360/e.lines*r+e.rotate)+"deg) translate("+e.radius+"px"+",0)",borderRadius:(e.corners*e.width>>1)+"px"})}for(;r<e.lines;r++){l=f(o(),{position:"absolute",top:1+~(e.width/2)+"px",transform:e.hwaccel?"translate3d(0,0,0)":"",opacity:e.opacity,animation:i&&s(e.opacity,e.trail,a+r*e.direction,e.lines)+" "+1/e.speed+"s linear infinite"});if(e.shadow)n(l,f(d("#000","0 0 4px "+"#000"),{top:2+"px"}));n(t,n(l,d(e.color,"0 0 1px rgba(0,0,0,.1)")))}return t},opacity:function(t,e,i){if(e<t.childNodes.length)t.childNodes[e].style.opacity=i}});function c(){function t(t,e){return o("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">',e)}r.addRule(".spin-vml","behavior:url(#default#VML)");p.prototype.lines=function(e,i){var o=i.length+i.width,r=2*o;function s(){return f(t("group",{coordsize:r+" "+r,coordorigin:-o+" "+-o}),{width:r,height:r})}var a=-(i.width+i.length)*2+"px",l=f(s(),{position:"absolute",top:a,left:a}),d;function u(e,r,a){n(l,n(f(s(),{rotation:360/i.lines*e+"deg",left:~~r}),n(f(t("roundrect",{arcsize:i.corners}),{width:o,height:i.width,left:i.radius,top:-i.width>>1,filter:a}),t("fill",{color:i.color,opacity:i.opacity}),t("stroke",{opacity:0}))))}if(i.shadow)for(d=1;d<=i.lines;d++)u(d,-2,"progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)");for(d=1;d<=i.lines;d++)u(d);return n(e,l)};p.prototype.opacity=function(t,e,i,o){var n=t.firstChild;o=o.shadow&&o.lines||0;if(n&&e+o<n.childNodes.length){n=n.childNodes[e+o];n=n&&n.firstChild;n=n&&n.firstChild;if(n)n.opacity=i}}}var h=f(o("group"),{behavior:"url(#default#VML)"});if(!a(h,"transform")&&h.adj)c();else i=a(h,"animation");return p});;/* Modernizr 2.6.2 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-fontface-backgroundsize-borderimage-borderradius-boxshadow-flexbox-hsla-multiplebgs-opacity-rgba-textshadow-cssanimations-csscolumns-generatedcontent-cssgradients-cssreflections-csstransforms-csstransforms3d-csstransitions-applicationcache-canvas-canvastext-draganddrop-hashchange-history-audio-video-indexeddb-input-inputtypes-localstorage-postmessage-sessionstorage-websockets-websqldatabase-webworkers-geolocation-inlinesvg-smil-svg-svgclippaths-touch-webgl-shiv-cssclasses-addtest-prefixed-teststyles-testprop-testallprops-hasevent-prefixes-domprefixes-load
 */
;



window.Modernizr = (function( window, document, undefined ) {

    var version = '2.6.2',

    Modernizr = {},

    enableClasses = true,

    docElement = document.documentElement,

    mod = 'modernizr',
    modElem = document.createElement(mod),
    mStyle = modElem.style,

    inputElem  = document.createElement('input')  ,

    smile = ':)',

    toString = {}.toString,

    prefixes = ' -webkit- -moz- -o- -ms- '.split(' '),



    omPrefixes = 'Webkit Moz O ms',

    cssomPrefixes = omPrefixes.split(' '),

    domPrefixes = omPrefixes.toLowerCase().split(' '),

    ns = {'svg': 'http://www.w3.org/2000/svg'},

    tests = {},
    inputs = {},
    attrs = {},

    classes = [],

    slice = classes.slice,

    featureName, 


    injectElementWithStyles = function( rule, callback, nodes, testnames ) {

      var style, ret, node, docOverflow,
          div = document.createElement('div'),
                body = document.body,
                fakeBody = body || document.createElement('body');

      if ( parseInt(nodes, 10) ) {
                      while ( nodes-- ) {
              node = document.createElement('div');
              node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
              div.appendChild(node);
          }
      }

                style = ['&#173;','<style id="s', mod, '">', rule, '</style>'].join('');
      div.id = mod;
          (body ? div : fakeBody).innerHTML += style;
      fakeBody.appendChild(div);
      if ( !body ) {
                fakeBody.style.background = '';
                fakeBody.style.overflow = 'hidden';
          docOverflow = docElement.style.overflow;
          docElement.style.overflow = 'hidden';
          docElement.appendChild(fakeBody);
      }

      ret = callback(div, rule);
        if ( !body ) {
          fakeBody.parentNode.removeChild(fakeBody);
          docElement.style.overflow = docOverflow;
      } else {
          div.parentNode.removeChild(div);
      }

      return !!ret;

    },



    isEventSupported = (function() {

      var TAGNAMES = {
        'select': 'input', 'change': 'input',
        'submit': 'form', 'reset': 'form',
        'error': 'img', 'load': 'img', 'abort': 'img'
      };

      function isEventSupported( eventName, element ) {

        element = element || document.createElement(TAGNAMES[eventName] || 'div');
        eventName = 'on' + eventName;

            var isSupported = eventName in element;

        if ( !isSupported ) {
                if ( !element.setAttribute ) {
            element = document.createElement('div');
          }
          if ( element.setAttribute && element.removeAttribute ) {
            element.setAttribute(eventName, '');
            isSupported = is(element[eventName], 'function');

                    if ( !is(element[eventName], 'undefined') ) {
              element[eventName] = undefined;
            }
            element.removeAttribute(eventName);
          }
        }

        element = null;
        return isSupported;
      }
      return isEventSupported;
    })(),


    _hasOwnProperty = ({}).hasOwnProperty, hasOwnProp;

    if ( !is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined') ) {
      hasOwnProp = function (object, property) {
        return _hasOwnProperty.call(object, property);
      };
    }
    else {
      hasOwnProp = function (object, property) { 
        return ((property in object) && is(object.constructor.prototype[property], 'undefined'));
      };
    }


    if (!Function.prototype.bind) {
      Function.prototype.bind = function bind(that) {

        var target = this;

        if (typeof target != "function") {
            throw new TypeError();
        }

        var args = slice.call(arguments, 1),
            bound = function () {

            if (this instanceof bound) {

              var F = function(){};
              F.prototype = target.prototype;
              var self = new F();

              var result = target.apply(
                  self,
                  args.concat(slice.call(arguments))
              );
              if (Object(result) === result) {
                  return result;
              }
              return self;

            } else {

              return target.apply(
                  that,
                  args.concat(slice.call(arguments))
              );

            }

        };

        return bound;
      };
    }

    function setCss( str ) {
        mStyle.cssText = str;
    }

    function setCssAll( str1, str2 ) {
        return setCss(prefixes.join(str1 + ';') + ( str2 || '' ));
    }

    function is( obj, type ) {
        return typeof obj === type;
    }

    function contains( str, substr ) {
        return !!~('' + str).indexOf(substr);
    }

    function testProps( props, prefixed ) {
        for ( var i in props ) {
            var prop = props[i];
            if ( !contains(prop, "-") && mStyle[prop] !== undefined ) {
                return prefixed == 'pfx' ? prop : true;
            }
        }
        return false;
    }

    function testDOMProps( props, obj, elem ) {
        for ( var i in props ) {
            var item = obj[props[i]];
            if ( item !== undefined) {

                            if (elem === false) return props[i];

                            if (is(item, 'function')){
                                return item.bind(elem || obj);
                }

                            return item;
            }
        }
        return false;
    }

    function testPropsAll( prop, prefixed, elem ) {

        var ucProp  = prop.charAt(0).toUpperCase() + prop.slice(1),
            props   = (prop + ' ' + cssomPrefixes.join(ucProp + ' ') + ucProp).split(' ');

            if(is(prefixed, "string") || is(prefixed, "undefined")) {
          return testProps(props, prefixed);

            } else {
          props = (prop + ' ' + (domPrefixes).join(ucProp + ' ') + ucProp).split(' ');
          return testDOMProps(props, prefixed, elem);
        }
    }    tests['flexbox'] = function() {
      return testPropsAll('flexWrap');
    };    tests['canvas'] = function() {
        var elem = document.createElement('canvas');
        return !!(elem.getContext && elem.getContext('2d'));
    };

    tests['canvastext'] = function() {
        return !!(Modernizr['canvas'] && is(document.createElement('canvas').getContext('2d').fillText, 'function'));
    };



    tests['webgl'] = function() {
        return !!window.WebGLRenderingContext;
    };


    tests['touch'] = function() {
        var bool;

        if(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
          bool = true;
        } else {
          injectElementWithStyles(['@media (',prefixes.join('touch-enabled),('),mod,')','{#modernizr{top:9px;position:absolute}}'].join(''), function( node ) {
            bool = node.offsetTop === 9;
          });
        }

        return bool;
    };



    tests['geolocation'] = function() {
        return 'geolocation' in navigator;
    };


    tests['postmessage'] = function() {
      return !!window.postMessage;
    };


    tests['websqldatabase'] = function() {
      return !!window.openDatabase;
    };

    tests['indexedDB'] = function() {
      return !!testPropsAll("indexedDB", window);
    };

    tests['hashchange'] = function() {
      return isEventSupported('hashchange', window) && (document.documentMode === undefined || document.documentMode > 7);
    };

    tests['history'] = function() {
      return !!(window.history && history.pushState);
    };

    tests['draganddrop'] = function() {
        var div = document.createElement('div');
        return ('draggable' in div) || ('ondragstart' in div && 'ondrop' in div);
    };

    tests['websockets'] = function() {
        return 'WebSocket' in window || 'MozWebSocket' in window;
    };


    tests['rgba'] = function() {
        setCss('background-color:rgba(150,255,150,.5)');

        return contains(mStyle.backgroundColor, 'rgba');
    };

    tests['hsla'] = function() {
            setCss('background-color:hsla(120,40%,100%,.5)');

        return contains(mStyle.backgroundColor, 'rgba') || contains(mStyle.backgroundColor, 'hsla');
    };

    tests['multiplebgs'] = function() {
                setCss('background:url(https://),url(https://),red url(https://)');

            return (/(url\s*\(.*?){3}/).test(mStyle.background);
    };    tests['backgroundsize'] = function() {
        return testPropsAll('backgroundSize');
    };

    tests['borderimage'] = function() {
        return testPropsAll('borderImage');
    };



    tests['borderradius'] = function() {
        return testPropsAll('borderRadius');
    };

    tests['boxshadow'] = function() {
        return testPropsAll('boxShadow');
    };

    tests['textshadow'] = function() {
        return document.createElement('div').style.textShadow === '';
    };


    tests['opacity'] = function() {
                setCssAll('opacity:.55');

                    return (/^0.55$/).test(mStyle.opacity);
    };


    tests['cssanimations'] = function() {
        return testPropsAll('animationName');
    };


    tests['csscolumns'] = function() {
        return testPropsAll('columnCount');
    };


    tests['cssgradients'] = function() {
        var str1 = 'background-image:',
            str2 = 'gradient(linear,left top,right bottom,from(#9f9),to(white));',
            str3 = 'linear-gradient(left top,#9f9, white);';

        setCss(
                       (str1 + '-webkit- '.split(' ').join(str2 + str1) +
                       prefixes.join(str3 + str1)).slice(0, -str1.length)
        );

        return contains(mStyle.backgroundImage, 'gradient');
    };


    tests['cssreflections'] = function() {
        return testPropsAll('boxReflect');
    };


    tests['csstransforms'] = function() {
        return !!testPropsAll('transform');
    };


    tests['csstransforms3d'] = function() {

        var ret = !!testPropsAll('perspective');

                        if ( ret && 'webkitPerspective' in docElement.style ) {

                      injectElementWithStyles('@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}', function( node, rule ) {
            ret = node.offsetLeft === 9 && node.offsetHeight === 3;
          });
        }
        return ret;
    };


    tests['csstransitions'] = function() {
        return testPropsAll('transition');
    };



    tests['fontface'] = function() {
        var bool;

        injectElementWithStyles('@font-face {font-family:"font";src:url("https://")}', function( node, rule ) {
          var style = document.getElementById('smodernizr'),
              sheet = style.sheet || style.styleSheet,
              cssText = sheet ? (sheet.cssRules && sheet.cssRules[0] ? sheet.cssRules[0].cssText : sheet.cssText || '') : '';

          bool = /src/i.test(cssText) && cssText.indexOf(rule.split(' ')[0]) === 0;
        });

        return bool;
    };

    tests['generatedcontent'] = function() {
        var bool;

        injectElementWithStyles(['#',mod,'{font:0/0 a}#',mod,':after{content:"',smile,'";visibility:hidden;font:3px/1 a}'].join(''), function( node ) {
          bool = node.offsetHeight >= 3;
        });

        return bool;
    };
    tests['video'] = function() {
        var elem = document.createElement('video'),
            bool = false;

            try {
            if ( bool = !!elem.canPlayType ) {
                bool      = new Boolean(bool);
                bool.ogg  = elem.canPlayType('video/ogg; codecs="theora"')      .replace(/^no$/,'');

                            bool.h264 = elem.canPlayType('video/mp4; codecs="avc1.42E01E"') .replace(/^no$/,'');

                bool.webm = elem.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/,'');
            }

        } catch(e) { }

        return bool;
    };

    tests['audio'] = function() {
        var elem = document.createElement('audio'),
            bool = false;

        try {
            if ( bool = !!elem.canPlayType ) {
                bool      = new Boolean(bool);
                bool.ogg  = elem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,'');
                bool.mp3  = elem.canPlayType('audio/mpeg;')               .replace(/^no$/,'');

                                                    bool.wav  = elem.canPlayType('audio/wav; codecs="1"')     .replace(/^no$/,'');
                bool.m4a  = ( elem.canPlayType('audio/x-m4a;')            ||
                              elem.canPlayType('audio/aac;'))             .replace(/^no$/,'');
            }
        } catch(e) { }

        return bool;
    };


    tests['localstorage'] = function() {
        try {
            localStorage.setItem(mod, mod);
            localStorage.removeItem(mod);
            return true;
        } catch(e) {
            return false;
        }
    };

    tests['sessionstorage'] = function() {
        try {
            sessionStorage.setItem(mod, mod);
            sessionStorage.removeItem(mod);
            return true;
        } catch(e) {
            return false;
        }
    };


    tests['webworkers'] = function() {
        return !!window.Worker;
    };


    tests['applicationcache'] = function() {
        return !!window.applicationCache;
    };


    tests['svg'] = function() {
        return !!document.createElementNS && !!document.createElementNS(ns.svg, 'svg').createSVGRect;
    };

    tests['inlinesvg'] = function() {
      var div = document.createElement('div');
      div.innerHTML = '<svg/>';
      return (div.firstChild && div.firstChild.namespaceURI) == ns.svg;
    };

    tests['smil'] = function() {
        return !!document.createElementNS && /SVGAnimate/.test(toString.call(document.createElementNS(ns.svg, 'animate')));
    };


    tests['svgclippaths'] = function() {
        return !!document.createElementNS && /SVGClipPath/.test(toString.call(document.createElementNS(ns.svg, 'clipPath')));
    };

    function webforms() {
                                            Modernizr['input'] = (function( props ) {
            for ( var i = 0, len = props.length; i < len; i++ ) {
                attrs[ props[i] ] = !!(props[i] in inputElem);
            }
            if (attrs.list){
                                  attrs.list = !!(document.createElement('datalist') && window.HTMLDataListElement);
            }
            return attrs;
        })('autocomplete autofocus list placeholder max min multiple pattern required step'.split(' '));
                            Modernizr['inputtypes'] = (function(props) {

            for ( var i = 0, bool, inputElemType, defaultView, len = props.length; i < len; i++ ) {

                inputElem.setAttribute('type', inputElemType = props[i]);
                bool = inputElem.type !== 'text';

                                                    if ( bool ) {

                    inputElem.value         = smile;
                    inputElem.style.cssText = 'position:absolute;visibility:hidden;';

                    if ( /^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined ) {

                      docElement.appendChild(inputElem);
                      defaultView = document.defaultView;

                                        bool =  defaultView.getComputedStyle &&
                              defaultView.getComputedStyle(inputElem, null).WebkitAppearance !== 'textfield' &&
                                                                                  (inputElem.offsetHeight !== 0);

                      docElement.removeChild(inputElem);

                    } else if ( /^(search|tel)$/.test(inputElemType) ){
                                                                                    } else if ( /^(url|email)$/.test(inputElemType) ) {
                                        bool = inputElem.checkValidity && inputElem.checkValidity() === false;

                    } else {
                                        bool = inputElem.value != smile;
                    }
                }

                inputs[ props[i] ] = !!bool;
            }
            return inputs;
        })('search tel url email datetime date month week time datetime-local number range color'.split(' '));
        }
    for ( var feature in tests ) {
        if ( hasOwnProp(tests, feature) ) {
                                    featureName  = feature.toLowerCase();
            Modernizr[featureName] = tests[feature]();

            classes.push((Modernizr[featureName] ? '' : 'no-') + featureName);
        }
    }

    Modernizr.input || webforms();


     Modernizr.addTest = function ( feature, test ) {
       if ( typeof feature == 'object' ) {
         for ( var key in feature ) {
           if ( hasOwnProp( feature, key ) ) {
             Modernizr.addTest( key, feature[ key ] );
           }
         }
       } else {

         feature = feature.toLowerCase();

         if ( Modernizr[feature] !== undefined ) {
                                              return Modernizr;
         }

         test = typeof test == 'function' ? test() : test;

         if (typeof enableClasses !== "undefined" && enableClasses) {
           docElement.className += ' ' + (test ? '' : 'no-') + feature;
         }
         Modernizr[feature] = test;

       }

       return Modernizr; 
     };


    setCss('');
    modElem = inputElem = null;

    ;(function(window, document) {
        var options = window.html5 || {};

        var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;

        var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;

        var supportsHtml5Styles;

        var expando = '_html5shiv';

        var expanID = 0;

        var expandoData = {};

        var supportsUnknownElements;

      (function() {
        try {
            var a = document.createElement('a');
            a.innerHTML = '<xyz></xyz>';
                    supportsHtml5Styles = ('hidden' in a);

            supportsUnknownElements = a.childNodes.length == 1 || (function() {
                        (document.createElement)('a');
              var frag = document.createDocumentFragment();
              return (
                typeof frag.cloneNode == 'undefined' ||
                typeof frag.createDocumentFragment == 'undefined' ||
                typeof frag.createElement == 'undefined'
              );
            }());
        } catch(e) {
          supportsHtml5Styles = true;
          supportsUnknownElements = true;
        }

      }());        function addStyleSheet(ownerDocument, cssText) {
        var p = ownerDocument.createElement('p'),
            parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

        p.innerHTML = 'x<style>' + cssText + '</style>';
        return parent.insertBefore(p.lastChild, parent.firstChild);
      }

        function getElements() {
        var elements = html5.elements;
        return typeof elements == 'string' ? elements.split(' ') : elements;
      }

          function getExpandoData(ownerDocument) {
        var data = expandoData[ownerDocument[expando]];
        if (!data) {
            data = {};
            expanID++;
            ownerDocument[expando] = expanID;
            expandoData[expanID] = data;
        }
        return data;
      }

        function createElement(nodeName, ownerDocument, data){
        if (!ownerDocument) {
            ownerDocument = document;
        }
        if(supportsUnknownElements){
            return ownerDocument.createElement(nodeName);
        }
        if (!data) {
            data = getExpandoData(ownerDocument);
        }
        var node;

        if (data.cache[nodeName]) {
            node = data.cache[nodeName].cloneNode();
        } else if (saveClones.test(nodeName)) {
            node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
        } else {
            node = data.createElem(nodeName);
        }

                                    return node.canHaveChildren && !reSkip.test(nodeName) ? data.frag.appendChild(node) : node;
      }

        function createDocumentFragment(ownerDocument, data){
        if (!ownerDocument) {
            ownerDocument = document;
        }
        if(supportsUnknownElements){
            return ownerDocument.createDocumentFragment();
        }
        data = data || getExpandoData(ownerDocument);
        var clone = data.frag.cloneNode(),
            i = 0,
            elems = getElements(),
            l = elems.length;
        for(;i<l;i++){
            clone.createElement(elems[i]);
        }
        return clone;
      }

        function shivMethods(ownerDocument, data) {
        if (!data.cache) {
            data.cache = {};
            data.createElem = ownerDocument.createElement;
            data.createFrag = ownerDocument.createDocumentFragment;
            data.frag = data.createFrag();
        }


        ownerDocument.createElement = function(nodeName) {
                if (!html5.shivMethods) {
              return data.createElem(nodeName);
          }
          return createElement(nodeName, ownerDocument, data);
        };

        ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +
          'var n=f.cloneNode(),c=n.createElement;' +
          'h.shivMethods&&(' +
                    getElements().join().replace(/\w+/g, function(nodeName) {
              data.createElem(nodeName);
              data.frag.createElement(nodeName);
              return 'c("' + nodeName + '")';
            }) +
          ');return n}'
        )(html5, data.frag);
      }        function shivDocument(ownerDocument) {
        if (!ownerDocument) {
            ownerDocument = document;
        }
        var data = getExpandoData(ownerDocument);

        if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
          data.hasCSS = !!addStyleSheet(ownerDocument,
                    'article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}' +
                    'mark{background:#FF0;color:#000}'
          );
        }
        if (!supportsUnknownElements) {
          shivMethods(ownerDocument, data);
        }
        return ownerDocument;
      }        var html5 = {

            'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video',

            'shivCSS': (options.shivCSS !== false),

            'supportsUnknownElements': supportsUnknownElements,

            'shivMethods': (options.shivMethods !== false),

            'type': 'default',

            'shivDocument': shivDocument,

            createElement: createElement,

            createDocumentFragment: createDocumentFragment
      };        window.html5 = html5;

        shivDocument(document);

    }(this, document));

    Modernizr._version      = version;

    Modernizr._prefixes     = prefixes;
    Modernizr._domPrefixes  = domPrefixes;
    Modernizr._cssomPrefixes  = cssomPrefixes;


    Modernizr.hasEvent      = isEventSupported;

    Modernizr.testProp      = function(prop){
        return testProps([prop]);
    };

    Modernizr.testAllProps  = testPropsAll;


    Modernizr.testStyles    = injectElementWithStyles;
    Modernizr.prefixed      = function(prop, obj, elem){
      if(!obj) {
        return testPropsAll(prop, 'pfx');
      } else {
            return testPropsAll(prop, obj, elem);
      }
    };


    docElement.className = docElement.className.replace(/(^|\s)no-js(\s|$)/, '$1$2') +

                                                    (enableClasses ? ' js ' + classes.join(' ') : '');

    return Modernizr;

})(this, this.document);
/*yepnope1.5.4|WTFPL*/
(function(a,b,c){function d(a){return"[object Function]"==o.call(a)}function e(a){return"string"==typeof a}function f(){}function g(a){return!a||"loaded"==a||"complete"==a||"uninitialized"==a}function h(){var a=p.shift();q=1,a?a.t?m(function(){("c"==a.t?B.injectCss:B.injectJs)(a.s,0,a.a,a.x,a.e,1)},0):(a(),h()):q=0}function i(a,c,d,e,f,i,j){function k(b){if(!o&&g(l.readyState)&&(u.r=o=1,!q&&h(),l.onload=l.onreadystatechange=null,b)){"img"!=a&&m(function(){t.removeChild(l)},50);for(var d in y[c])y[c].hasOwnProperty(d)&&y[c][d].onload()}}var j=j||B.errorTimeout,l=b.createElement(a),o=0,r=0,u={t:d,s:c,e:f,a:i,x:j};1===y[c]&&(r=1,y[c]=[]),"object"==a?l.data=c:(l.src=c,l.type=a),l.width=l.height="0",l.onerror=l.onload=l.onreadystatechange=function(){k.call(this,r)},p.splice(e,0,u),"img"!=a&&(r||2===y[c]?(t.insertBefore(l,s?null:n),m(k,j)):y[c].push(l))}function j(a,b,c,d,f){return q=0,b=b||"j",e(a)?i("c"==b?v:u,a,b,this.i++,c,d,f):(p.splice(this.i++,0,a),1==p.length&&h()),this}function k(){var a=B;return a.loader={load:j,i:0},a}var l=b.documentElement,m=a.setTimeout,n=b.getElementsByTagName("script")[0],o={}.toString,p=[],q=0,r="MozAppearance"in l.style,s=r&&!!b.createRange().compareNode,t=s?l:n.parentNode,l=a.opera&&"[object Opera]"==o.call(a.opera),l=!!b.attachEvent&&!l,u=r?"object":l?"script":"img",v=l?"script":u,w=Array.isArray||function(a){return"[object Array]"==o.call(a)},x=[],y={},z={timeout:function(a,b){return b.length&&(a.timeout=b[0]),a}},A,B;B=function(a){function b(a){var a=a.split("!"),b=x.length,c=a.pop(),d=a.length,c={url:c,origUrl:c,prefixes:a},e,f,g;for(f=0;f<d;f++)g=a[f].split("="),(e=z[g.shift()])&&(c=e(c,g));for(f=0;f<b;f++)c=x[f](c);return c}function g(a,e,f,g,h){var i=b(a),j=i.autoCallback;i.url.split(".").pop().split("?").shift(),i.bypass||(e&&(e=d(e)?e:e[a]||e[g]||e[a.split("/").pop().split("?")[0]]),i.instead?i.instead(a,e,f,g,h):(y[i.url]?i.noexec=!0:y[i.url]=1,f.load(i.url,i.forceCSS||!i.forceJS&&"css"==i.url.split(".").pop().split("?").shift()?"c":c,i.noexec,i.attrs,i.timeout),(d(e)||d(j))&&f.load(function(){k(),e&&e(i.origUrl,h,g),j&&j(i.origUrl,h,g),y[i.url]=2})))}function h(a,b){function c(a,c){if(a){if(e(a))c||(j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}),g(a,j,b,0,h);else if(Object(a)===a)for(n in m=function(){var b=0,c;for(c in a)a.hasOwnProperty(c)&&b++;return b}(),a)a.hasOwnProperty(n)&&(!c&&!--m&&(d(j)?j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}:j[n]=function(a){return function(){var b=[].slice.call(arguments);a&&a.apply(this,b),l()}}(k[n])),g(a[n],j,b,n,h))}else!c&&l()}var h=!!a.test,i=a.load||a.both,j=a.callback||f,k=j,l=a.complete||f,m,n;c(h?a.yep:a.nope,!!i),i&&c(i)}var i,j,l=this.yepnope.loader;if(e(a))g(a,0,l,0);else if(w(a))for(i=0;i<a.length;i++)j=a[i],e(j)?g(j,0,l,0):w(j)?B(j):Object(j)===j&&h(j,l);else Object(a)===a&&h(a,l)},B.addPrefix=function(a,b){z[a]=b},B.addFilter=function(a){x.push(a)},B.errorTimeout=1e4,null==b.readyState&&b.addEventListener&&(b.readyState="loading",b.addEventListener("DOMContentLoaded",A=function(){b.removeEventListener("DOMContentLoaded",A,0),b.readyState="complete"},0)),a.yepnope=k(),a.yepnope.executeStack=h,a.yepnope.injectJs=function(a,c,d,e,i,j){var k=b.createElement("script"),l,o,e=e||B.errorTimeout;k.src=a;for(o in d)k.setAttribute(o,d[o]);c=j?h:c||f,k.onreadystatechange=k.onload=function(){!l&&g(k.readyState)&&(l=1,c(),k.onload=k.onreadystatechange=null)},m(function(){l||(l=1,c(1))},e),i?k.onload():n.parentNode.insertBefore(k,n)},a.yepnope.injectCss=function(a,c,d,e,g,i){var e=b.createElement("link"),j,c=i?h:c||f;e.href=a,e.rel="stylesheet",e.type="text/css";for(j in d)e.setAttribute(j,d[j]);g||(n.parentNode.insertBefore(e,n),m(c,0))}})(this,document);
Modernizr.load=function(){yepnope.apply(window,[].slice.call(arguments,0));};
;;!function(){function n(){}function t(n){return n}function e(n){return!!n}function r(n){return!n}function u(n){return function(){if(null===n)throw new Error("Callback was already called.");n.apply(this,arguments),n=null}}function i(n){return function(){null!==n&&(n.apply(this,arguments),n=null)}}function o(n){return M(n)||"number"==typeof n.length&&n.length>=0&&n.length%1===0}function c(n,t){for(var e=-1,r=n.length;++e<r;)t(n[e],e,n)}function a(n,t){for(var e=-1,r=n.length,u=Array(r);++e<r;)u[e]=t(n[e],e,n);return u}function f(n){return a(Array(n),function(n,t){return t})}function l(n,t,e){return c(n,function(n,r,u){e=t(e,n,r,u)}),e}function s(n,t){c(W(n),function(e){t(n[e],e)})}function p(n,t){for(var e=0;e<n.length;e++)if(n[e]===t)return e;return-1}function h(n){var t,e,r=-1;return o(n)?(t=n.length,function(){return r++,t>r?r:null}):(e=W(n),t=e.length,function(){return r++,t>r?e[r]:null})}function m(n,t){return t=null==t?n.length-1:+t,function(){for(var e=Math.max(arguments.length-t,0),r=Array(e),u=0;e>u;u++)r[u]=arguments[u+t];switch(t){case 0:return n.call(this,r);case 1:return n.call(this,arguments[0],r)}}}function y(n){return function(t,e,r){return n(t,r)}}function v(t){return function(e,r,o){o=i(o||n),e=e||[];var c=h(e);if(0>=t)return o(null);var a=!1,f=0,l=!1;!function s(){if(a&&0>=f)return o(null);for(;t>f&&!l;){var n=c();if(null===n)return a=!0,void(0>=f&&o(null));f+=1,r(e[n],n,u(function(n){f-=1,n?(o(n),l=!0):s()}))}}()}}function d(n){return function(t,e,r){return n(P.eachOf,t,e,r)}}function g(n){return function(t,e,r,u){return n(v(e),t,r,u)}}function k(n){return function(t,e,r){return n(P.eachOfSeries,t,e,r)}}function b(t,e,r,u){u=i(u||n),e=e||[];var c=o(e)?[]:{};t(e,function(n,t,e){r(n,function(n,r){c[t]=r,e(n)})},function(n){u(n,c)})}function w(n,t,e,r){var u=[];n(t,function(n,t,r){e(n,function(e){e&&u.push({index:t,value:n}),r()})},function(){r(a(u.sort(function(n,t){return n.index-t.index}),function(n){return n.value}))})}function O(n,t,e,r){w(n,t,function(n,t){e(n,function(n){t(!n)})},r)}function S(n,t,e){return function(r,u,i,o){function c(){o&&o(e(!1,void 0))}function a(n,r,u){return o?void i(n,function(r){o&&t(r)&&(o(e(!0,n)),o=i=!1),u()}):u()}arguments.length>3?n(r,u,a,c):(o=i,i=u,n(r,a,c))}}function E(n,t){return t}function L(t,e,r){r=r||n;var u=o(e)?[]:{};t(e,function(n,t,e){n(m(function(n,r){r.length<=1&&(r=r[0]),u[t]=r,e(n)}))},function(n){r(n,u)})}function j(n,t,e,r){var u=[];n(t,function(n,t,r){e(n,function(n,t){u=u.concat(t||[]),r(n)})},function(n){r(n,u)})}function I(t,e,r){function i(t,e,r,u){if(null!=u&&"function"!=typeof u)throw new Error("task callback must be a function");return t.started=!0,M(e)||(e=[e]),0===e.length&&t.idle()?P.setImmediate(function(){t.drain()}):(c(e,function(e){var i={data:e,callback:u||n};r?t.tasks.unshift(i):t.tasks.push(i),t.tasks.length===t.concurrency&&t.saturated()}),void P.setImmediate(t.process))}function o(n,t){return function(){f-=1;var e=!1,r=arguments;c(t,function(n){c(l,function(t,r){t!==n||e||(l.splice(r,1),e=!0)}),n.callback.apply(n,r)}),n.tasks.length+f===0&&n.drain(),n.process()}}if(null==e)e=1;else if(0===e)throw new Error("Concurrency must not be zero");var f=0,l=[],s={tasks:[],concurrency:e,payload:r,saturated:n,empty:n,drain:n,started:!1,paused:!1,push:function(n,t){i(s,n,!1,t)},kill:function(){s.drain=n,s.tasks=[]},unshift:function(n,t){i(s,n,!0,t)},process:function(){for(;!s.paused&&f<s.concurrency&&s.tasks.length;){var n=s.payload?s.tasks.splice(0,s.payload):s.tasks.splice(0,s.tasks.length),e=a(n,function(n){return n.data});0===s.tasks.length&&s.empty(),f+=1,l.push(n[0]);var r=u(o(s,n));t(e,r)}},length:function(){return s.tasks.length},running:function(){return f},workersList:function(){return l},idle:function(){return s.tasks.length+f===0},pause:function(){s.paused=!0},resume:function(){if(s.paused!==!1){s.paused=!1;for(var n=Math.min(s.concurrency,s.tasks.length),t=1;n>=t;t++)P.setImmediate(s.process)}}};return s}function x(n){return m(function(t,e){t.apply(null,e.concat([m(function(t,e){"object"==typeof console&&(t?console.error&&console.error(t):console[n]&&c(e,function(t){console[n](t)}))})]))})}function A(n){return function(t,e,r){n(f(t),e,r)}}function T(n){return m(function(t,e){var r=m(function(e){var r=this,u=e.pop();return n(t,function(n,t,u){n.apply(r,e.concat([u]))},u)});return e.length?r.apply(this,e):r})}function z(n){return m(function(t){var e=t.pop();t.push(function(){var n=arguments;r?P.setImmediate(function(){e.apply(null,n)}):e.apply(null,n)});var r=!0;n.apply(this,t),r=!1})}var q,P={},C="object"==typeof self&&self.self===self&&self||"object"==typeof global&&global.global===global&&global||this;null!=C&&(q=C.async),P.noConflict=function(){return C.async=q,P};var H=Object.prototype.toString,M=Array.isArray||function(n){return"[object Array]"===H.call(n)},U=function(n){var t=typeof n;return"function"===t||"object"===t&&!!n},W=Object.keys||function(n){var t=[];for(var e in n)n.hasOwnProperty(e)&&t.push(e);return t},B="function"==typeof setImmediate&&setImmediate,D=B?function(n){B(n)}:function(n){setTimeout(n,0)};"object"==typeof process&&"function"==typeof process.nextTick?P.nextTick=process.nextTick:P.nextTick=D,P.setImmediate=B?D:P.nextTick,P.forEach=P.each=function(n,t,e){return P.eachOf(n,y(t),e)},P.forEachSeries=P.eachSeries=function(n,t,e){return P.eachOfSeries(n,y(t),e)},P.forEachLimit=P.eachLimit=function(n,t,e,r){return v(t)(n,y(e),r)},P.forEachOf=P.eachOf=function(t,e,r){function o(n){f--,n?r(n):null===c&&0>=f&&r(null)}r=i(r||n),t=t||[];for(var c,a=h(t),f=0;null!=(c=a());)f+=1,e(t[c],c,u(o));0===f&&r(null)},P.forEachOfSeries=P.eachOfSeries=function(t,e,r){function o(){var n=!0;return null===a?r(null):(e(t[a],a,u(function(t){if(t)r(t);else{if(a=c(),null===a)return r(null);n?P.setImmediate(o):o()}})),void(n=!1))}r=i(r||n),t=t||[];var c=h(t),a=c();o()},P.forEachOfLimit=P.eachOfLimit=function(n,t,e,r){v(t)(n,e,r)},P.map=d(b),P.mapSeries=k(b),P.mapLimit=g(b),P.inject=P.foldl=P.reduce=function(n,t,e,r){P.eachOfSeries(n,function(n,r,u){e(t,n,function(n,e){t=e,u(n)})},function(n){r(n,t)})},P.foldr=P.reduceRight=function(n,e,r,u){var i=a(n,t).reverse();P.reduce(i,e,r,u)},P.transform=function(n,t,e,r){3===arguments.length&&(r=e,e=t,t=M(n)?[]:{}),P.eachOf(n,function(n,r,u){e(t,n,r,u)},function(n){r(n,t)})},P.select=P.filter=d(w),P.selectLimit=P.filterLimit=g(w),P.selectSeries=P.filterSeries=k(w),P.reject=d(O),P.rejectLimit=g(O),P.rejectSeries=k(O),P.any=P.some=S(P.eachOf,e,t),P.someLimit=S(P.eachOfLimit,e,t),P.all=P.every=S(P.eachOf,r,r),P.everyLimit=S(P.eachOfLimit,r,r),P.detect=S(P.eachOf,t,E),P.detectSeries=S(P.eachOfSeries,t,E),P.detectLimit=S(P.eachOfLimit,t,E),P.sortBy=function(n,t,e){function r(n,t){var e=n.criteria,r=t.criteria;return r>e?-1:e>r?1:0}P.map(n,function(n,e){t(n,function(t,r){t?e(t):e(null,{value:n,criteria:r})})},function(n,t){return n?e(n):void e(null,a(t.sort(r),function(n){return n.value}))})},P.auto=function(t,e,r){function u(n){g.unshift(n)}function o(n){var t=p(g,n);t>=0&&g.splice(t,1)}function a(){h--,c(g.slice(0),function(n){n()})}"function"==typeof arguments[1]&&(r=e,e=null),r=i(r||n);var f=W(t),h=f.length;if(!h)return r(null);e||(e=h);var y={},v=0,d=!1,g=[];u(function(){h||r(null,y)}),c(f,function(n){function i(){return e>v&&l(k,function(n,t){return n&&y.hasOwnProperty(t)},!0)&&!y.hasOwnProperty(n)}function c(){i()&&(v++,o(c),h[h.length-1](g,y))}if(!d){for(var f,h=M(t[n])?t[n]:[t[n]],g=m(function(t,e){if(v--,e.length<=1&&(e=e[0]),t){var u={};s(y,function(n,t){u[t]=n}),u[n]=e,d=!0,r(t,u)}else y[n]=e,P.setImmediate(a)}),k=h.slice(0,h.length-1),b=k.length;b--;){if(!(f=t[k[b]]))throw new Error("Has nonexistent dependency in "+k.join(", "));if(M(f)&&p(f,n)>=0)throw new Error("Has cyclic dependencies")}i()?(v++,h[h.length-1](g,y)):u(c)}})},P.retry=function(n,t,e){function r(n,t){if("number"==typeof t)n.times=parseInt(t,10)||i;else{if("object"!=typeof t)throw new Error("Unsupported argument type for 'times': "+typeof t);n.times=parseInt(t.times,10)||i,n.interval=parseInt(t.interval,10)||o}}function u(n,t){function e(n,e){return function(r){n(function(n,t){r(!n||e,{err:n,result:t})},t)}}function r(n){return function(t){setTimeout(function(){t(null)},n)}}for(;a.times;){var u=!(a.times-=1);c.push(e(a.task,u)),!u&&a.interval>0&&c.push(r(a.interval))}P.series(c,function(t,e){e=e[e.length-1],(n||a.callback)(e.err,e.result)})}var i=5,o=0,c=[],a={times:i,interval:o},f=arguments.length;if(1>f||f>3)throw new Error("Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)");return 2>=f&&"function"==typeof n&&(e=t,t=n),"function"!=typeof n&&r(a,n),a.callback=e,a.task=t,a.callback?u():u},P.waterfall=function(t,e){function r(n){return m(function(t,u){if(t)e.apply(null,[t].concat(u));else{var i=n.next();i?u.push(r(i)):u.push(e),z(n).apply(null,u)}})}if(e=i(e||n),!M(t)){var u=new Error("First argument to waterfall must be an array of functions");return e(u)}return t.length?void r(P.iterator(t))():e()},P.parallel=function(n,t){L(P.eachOf,n,t)},P.parallelLimit=function(n,t,e){L(v(t),n,e)},P.series=function(n,t){L(P.eachOfSeries,n,t)},P.iterator=function(n){function t(e){function r(){return n.length&&n[e].apply(null,arguments),r.next()}return r.next=function(){return e<n.length-1?t(e+1):null},r}return t(0)},P.apply=m(function(n,t){return m(function(e){return n.apply(null,t.concat(e))})}),P.concat=d(j),P.concatSeries=k(j),P.whilst=function(t,e,r){if(r=r||n,t()){var u=m(function(n,i){n?r(n):t.apply(this,i)?e(u):r.apply(null,[null].concat(i))});e(u)}else r(null)},P.doWhilst=function(n,t,e){var r=0;return P.whilst(function(){return++r<=1||t.apply(this,arguments)},n,e)},P.until=function(n,t,e){return P.whilst(function(){return!n.apply(this,arguments)},t,e)},P.doUntil=function(n,t,e){return P.doWhilst(n,function(){return!t.apply(this,arguments)},e)},P.during=function(t,e,r){r=r||n;var u=m(function(n,e){n?r(n):(e.push(i),t.apply(this,e))}),i=function(n,t){n?r(n):t?e(u):r(null)};t(i)},P.doDuring=function(n,t,e){var r=0;P.during(function(n){r++<1?n(null,!0):t.apply(this,arguments)},n,e)},P.queue=function(n,t){var e=I(function(t,e){n(t[0],e)},t,1);return e},P.priorityQueue=function(t,e){function r(n,t){return n.priority-t.priority}function u(n,t,e){for(var r=-1,u=n.length-1;u>r;){var i=r+(u-r+1>>>1);e(t,n[i])>=0?r=i:u=i-1}return r}function i(t,e,i,o){if(null!=o&&"function"!=typeof o)throw new Error("task callback must be a function");return t.started=!0,M(e)||(e=[e]),0===e.length?P.setImmediate(function(){t.drain()}):void c(e,function(e){var c={data:e,priority:i,callback:"function"==typeof o?o:n};t.tasks.splice(u(t.tasks,c,r)+1,0,c),t.tasks.length===t.concurrency&&t.saturated(),P.setImmediate(t.process)})}var o=P.queue(t,e);return o.push=function(n,t,e){i(o,n,t,e)},delete o.unshift,o},P.cargo=function(n,t){return I(n,1,t)},P.log=x("log"),P.dir=x("dir"),P.memoize=function(n,e){var r={},u={},i=Object.prototype.hasOwnProperty;e=e||t;var o=m(function(t){var o=t.pop(),c=e.apply(null,t);i.call(r,c)?P.setImmediate(function(){o.apply(null,r[c])}):i.call(u,c)?u[c].push(o):(u[c]=[o],n.apply(null,t.concat([m(function(n){r[c]=n;var t=u[c];delete u[c];for(var e=0,i=t.length;i>e;e++)t[e].apply(null,n)})])))});return o.memo=r,o.unmemoized=n,o},P.unmemoize=function(n){return function(){return(n.unmemoized||n).apply(null,arguments)}},P.times=A(P.map),P.timesSeries=A(P.mapSeries),P.timesLimit=function(n,t,e,r){return P.mapLimit(f(n),t,e,r)},P.seq=function(){var t=arguments;return m(function(e){var r=this,u=e[e.length-1];"function"==typeof u?e.pop():u=n,P.reduce(t,e,function(n,t,e){t.apply(r,n.concat([m(function(n,t){e(n,t)})]))},function(n,t){u.apply(r,[n].concat(t))})})},P.compose=function(){return P.seq.apply(null,Array.prototype.reverse.call(arguments))},P.applyEach=T(P.eachOf),P.applyEachSeries=T(P.eachOfSeries),P.forever=function(t,e){function r(n){return n?i(n):void o(r)}var i=u(e||n),o=z(t);r()},P.ensureAsync=z,P.constant=m(function(n){var t=[null].concat(n);return function(n){return n.apply(this,t)}}),P.wrapSync=P.asyncify=function(n){return m(function(t){var e,r=t.pop();try{e=n.apply(this,t)}catch(u){return r(u)}U(e)&&"function"==typeof e.then?e.then(function(n){r(null,n)})["catch"](function(n){r(n.message?n:new Error(n))}):r(null,e)})},"object"==typeof module&&module.exports?module.exports=P:"function"==typeof define&&define.amd?define([],function(){return P}):C.async=P}();
;/* @preserve
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Petka Antonov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */
/**
 * bluebird build version 3.1.5
 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
*/
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;"undefined"!=typeof window?e=window:"undefined"!=typeof global?e=global:"undefined"!=typeof self&&(e=self),e.Promise=t()}}(function(){var t,e,n;return function r(t,e,n){function i(s,a){if(!e[s]){if(!t[s]){var c="function"==typeof _dereq_&&_dereq_;if(!a&&c)return c(s,!0);if(o)return o(s,!0);var l=new Error("Cannot find module '"+s+"'");throw l.code="MODULE_NOT_FOUND",l}var u=e[s]={exports:{}};t[s][0].call(u.exports,function(e){var n=t[s][1][e];return i(n?n:e)},u,u.exports,r,t,e,n)}return e[s].exports}for(var o="function"==typeof _dereq_&&_dereq_,s=0;s<n.length;s++)i(n[s]);return i}({1:[function(t,e,n){"use strict";e.exports=function(t){function e(t){var e=new n(t),r=e.promise();return e.setHowMany(1),e.setUnwrap(),e.init(),r}var n=t._SomePromiseArray;t.any=function(t){return e(t)},t.prototype.any=function(){return e(this)}}},{}],2:[function(t,e,n){"use strict";function r(){this._isTickUsed=!1,this._lateQueue=new u(16),this._normalQueue=new u(16),this._haveDrainedQueues=!1,this._trampolineEnabled=!0;var t=this;this.drainQueues=function(){t._drainQueues()},this._schedule=l}function i(t,e,n){this._lateQueue.push(t,e,n),this._queueTick()}function o(t,e,n){this._normalQueue.push(t,e,n),this._queueTick()}function s(t){this._normalQueue._pushOne(t),this._queueTick()}var a;try{throw new Error}catch(c){a=c}var l=t("./schedule"),u=t("./queue"),p=t("./util");r.prototype.enableTrampoline=function(){this._trampolineEnabled=!0},r.prototype.disableTrampolineIfNecessary=function(){p.hasDevTools&&(this._trampolineEnabled=!1)},r.prototype.haveItemsQueued=function(){return this._isTickUsed||this._haveDrainedQueues},r.prototype.fatalError=function(t,e){e?(process.stderr.write("Fatal "+(t instanceof Error?t.stack:t)),process.exit(2)):this.throwLater(t)},r.prototype.throwLater=function(t,e){if(1===arguments.length&&(e=t,t=function(){throw e}),"undefined"!=typeof setTimeout)setTimeout(function(){t(e)},0);else try{this._schedule(function(){t(e)})}catch(n){throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n")}},p.hasDevTools?(r.prototype.invokeLater=function(t,e,n){this._trampolineEnabled?i.call(this,t,e,n):this._schedule(function(){setTimeout(function(){t.call(e,n)},100)})},r.prototype.invoke=function(t,e,n){this._trampolineEnabled?o.call(this,t,e,n):this._schedule(function(){t.call(e,n)})},r.prototype.settlePromises=function(t){this._trampolineEnabled?s.call(this,t):this._schedule(function(){t._settlePromises()})}):(r.prototype.invokeLater=i,r.prototype.invoke=o,r.prototype.settlePromises=s),r.prototype.invokeFirst=function(t,e,n){this._normalQueue.unshift(t,e,n),this._queueTick()},r.prototype._drainQueue=function(t){for(;t.length()>0;){var e=t.shift();if("function"==typeof e){var n=t.shift(),r=t.shift();e.call(n,r)}else e._settlePromises()}},r.prototype._drainQueues=function(){this._drainQueue(this._normalQueue),this._reset(),this._haveDrainedQueues=!0,this._drainQueue(this._lateQueue)},r.prototype._queueTick=function(){this._isTickUsed||(this._isTickUsed=!0,this._schedule(this.drainQueues))},r.prototype._reset=function(){this._isTickUsed=!1},e.exports=r,e.exports.firstLineError=a},{"./queue":26,"./schedule":29,"./util":36}],3:[function(t,e,n){"use strict";e.exports=function(t,e,n,r){var i=!1,o=function(t,e){this._reject(e)},s=function(t,e){e.promiseRejectionQueued=!0,e.bindingPromise._then(o,o,null,this,t)},a=function(t,e){0===(50397184&this._bitField)&&this._resolveCallback(e.target)},c=function(t,e){e.promiseRejectionQueued||this._reject(t)};t.prototype.bind=function(o){i||(i=!0,t.prototype._propagateFrom=r.propagateFromFunction(),t.prototype._boundValue=r.boundValueFunction());var l=n(o),u=new t(e);u._propagateFrom(this,1);var p=this._target();if(u._setBoundTo(l),l instanceof t){var h={promiseRejectionQueued:!1,promise:u,target:p,bindingPromise:l};p._then(e,s,void 0,u,h),l._then(a,c,void 0,u,h),u._setOnCancel(l)}else u._resolveCallback(p);return u},t.prototype._setBoundTo=function(t){void 0!==t?(this._bitField=2097152|this._bitField,this._boundTo=t):this._bitField=-2097153&this._bitField},t.prototype._isBound=function(){return 2097152===(2097152&this._bitField)},t.bind=function(e,n){return t.resolve(n).bind(e)}}},{}],4:[function(t,e,n){"use strict";function r(){try{Promise===o&&(Promise=i)}catch(t){}return o}var i;"undefined"!=typeof Promise&&(i=Promise);var o=t("./promise")();o.noConflict=r,e.exports=o},{"./promise":22}],5:[function(t,e,n){"use strict";var r=Object.create;if(r){var i=r(null),o=r(null);i[" size"]=o[" size"]=0}e.exports=function(e){function n(t,n){var r;if(null!=t&&(r=t[n]),"function"!=typeof r){var i="Object "+a.classString(t)+" has no method '"+a.toString(n)+"'";throw new e.TypeError(i)}return r}function r(t){var e=this.pop(),r=n(t,e);return r.apply(t,this)}function i(t){return t[this]}function o(t){var e=+this;return 0>e&&(e=Math.max(0,e+t.length)),t[e]}var s,a=t("./util"),c=a.canEvaluate;a.isIdentifier;e.prototype.call=function(t){var e=[].slice.call(arguments,1);return e.push(t),this._then(r,void 0,void 0,e,void 0)},e.prototype.get=function(t){var e,n="number"==typeof t;if(n)e=o;else if(c){var r=s(t);e=null!==r?r:i}else e=i;return this._then(e,void 0,void 0,t,void 0)}}},{"./util":36}],6:[function(t,e,n){"use strict";e.exports=function(e,n,r,i){var o=t("./util"),s=o.tryCatch,a=o.errorObj,c=e._async;e.prototype["break"]=e.prototype.cancel=function(){if(!i.cancellation())return this._warn("cancellation is disabled");for(var t=this,e=t;t.isCancellable();){if(!t._cancelBy(e)){e._isFollowing()?e._followee().cancel():e._cancelBranched();break}var n=t._cancellationParent;if(null==n||!n.isCancellable()){t._isFollowing()?t._followee().cancel():t._cancelBranched();break}t._isFollowing()&&t._followee().cancel(),e=t,t=n}},e.prototype._branchHasCancelled=function(){this._branchesRemainingToCancel--},e.prototype._enoughBranchesHaveCancelled=function(){return void 0===this._branchesRemainingToCancel||this._branchesRemainingToCancel<=0},e.prototype._cancelBy=function(t){return t===this?(this._branchesRemainingToCancel=0,this._invokeOnCancel(),!0):(this._branchHasCancelled(),this._enoughBranchesHaveCancelled()?(this._invokeOnCancel(),!0):!1)},e.prototype._cancelBranched=function(){this._enoughBranchesHaveCancelled()&&this._cancel()},e.prototype._cancel=function(){this.isCancellable()&&(this._setCancelled(),c.invoke(this._cancelPromises,this,void 0))},e.prototype._cancelPromises=function(){this._length()>0&&this._settlePromises()},e.prototype._unsetOnCancel=function(){this._onCancelField=void 0},e.prototype.isCancellable=function(){return this.isPending()&&!this.isCancelled()},e.prototype._doInvokeOnCancel=function(t,e){if(o.isArray(t))for(var n=0;n<t.length;++n)this._doInvokeOnCancel(t[n],e);else if(void 0!==t)if("function"==typeof t){if(!e){var r=s(t).call(this._boundValue());r===a&&(this._attachExtraTrace(r.e),c.throwLater(r.e))}}else t._resultCancelled(this)},e.prototype._invokeOnCancel=function(){var t=this._onCancel();this._unsetOnCancel(),c.invoke(this._doInvokeOnCancel,this,t)},e.prototype._invokeInternalOnCancel=function(){this.isCancellable()&&(this._doInvokeOnCancel(this._onCancel(),!0),this._unsetOnCancel())},e.prototype._resultCancelled=function(){this.cancel()}}},{"./util":36}],7:[function(t,e,n){"use strict";e.exports=function(e){function n(t,n,a){return function(c){var l=a._boundValue();t:for(var u=0;u<t.length;++u){var p=t[u];if(p===Error||null!=p&&p.prototype instanceof Error){if(c instanceof p)return o(n).call(l,c)}else if("function"==typeof p){var h=o(p).call(l,c);if(h===s)return h;if(h)return o(n).call(l,c)}else if(r.isObject(c)){for(var f=i(p),_=0;_<f.length;++_){var d=f[_];if(p[d]!=c[d])continue t}return o(n).call(l,c)}}return e}}var r=t("./util"),i=t("./es5").keys,o=r.tryCatch,s=r.errorObj;return n}},{"./es5":13,"./util":36}],8:[function(t,e,n){"use strict";e.exports=function(t){function e(){this._trace=new e.CapturedTrace(r())}function n(){return i?new e:void 0}function r(){var t=o.length-1;return t>=0?o[t]:void 0}var i=!1,o=[];return t.prototype._promiseCreated=function(){},t.prototype._pushContext=function(){},t.prototype._popContext=function(){return null},t._peekContext=t.prototype._peekContext=function(){},e.prototype._pushContext=function(){void 0!==this._trace&&(this._trace._promiseCreated=null,o.push(this._trace))},e.prototype._popContext=function(){if(void 0!==this._trace){var t=o.pop(),e=t._promiseCreated;return t._promiseCreated=null,e}return null},e.CapturedTrace=null,e.create=n,e.deactivateLongStackTraces=function(){},e.activateLongStackTraces=function(){var n=t.prototype._pushContext,o=t.prototype._popContext,s=t._peekContext,a=t.prototype._peekContext,c=t.prototype._promiseCreated;e.deactivateLongStackTraces=function(){t.prototype._pushContext=n,t.prototype._popContext=o,t._peekContext=s,t.prototype._peekContext=a,t.prototype._promiseCreated=c,i=!1},i=!0,t.prototype._pushContext=e.prototype._pushContext,t.prototype._popContext=e.prototype._popContext,t._peekContext=t.prototype._peekContext=r,t.prototype._promiseCreated=function(){var t=this._peekContext();t&&null==t._promiseCreated&&(t._promiseCreated=this)}},e}},{}],9:[function(t,e,n){"use strict";e.exports=function(e,n){function r(t,e,n){var r=this;try{t(e,n,function(t){if("function"!=typeof t)throw new TypeError("onCancel must be a function, got: "+I.toString(t));r._attachCancellationCallback(t)})}catch(i){return i}}function i(t){if(!this.isCancellable())return this;var e=this._onCancel();void 0!==e?I.isArray(e)?e.push(t):this._setOnCancel([e,t]):this._setOnCancel(t)}function o(){return this._onCancelField}function s(t){this._onCancelField=t}function a(){this._cancellationParent=void 0,this._onCancelField=void 0}function c(t,e){if(0!==(1&e)){this._cancellationParent=t;var n=t._branchesRemainingToCancel;void 0===n&&(n=0),t._branchesRemainingToCancel=n+1}0!==(2&e)&&t._isBound()&&this._setBoundTo(t._boundTo)}function l(t,e){0!==(2&e)&&t._isBound()&&this._setBoundTo(t._boundTo)}function u(){var t=this._boundTo;return void 0!==t&&t instanceof e?t.isFulfilled()?t.value():void 0:t}function p(){this._trace=new R(this._peekContext())}function h(t,e){if(L(t)){var n=this._trace;if(void 0!==n&&e&&(n=n._parent),void 0!==n)n.attachExtraTrace(t);else if(!t.__stackCleaned__){var r=w(t);I.notEnumerableProp(t,"stack",r.message+"\n"+r.stack.join("\n")),I.notEnumerableProp(t,"__stackCleaned__",!0)}}}function f(t,e,n,r,i){if(void 0===t&&null!==e&&$){if(void 0!==i&&i._returnedNonUndefined())return;n&&(n+=" ");var o="a promise was created in a "+n+"handler but was not returned from it";r._warn(o,!0,e)}}function _(t,e){var n=t+" is deprecated and will be removed in a future version.";return e&&(n+=" Use "+e+" instead."),d(n)}function d(t,n,r){if(Z.warnings){var i,o=new V(t);if(n)r._attachExtraTrace(o);else if(Z.longStackTraces&&(i=e._peekContext()))i.attachExtraTrace(o);else{var s=w(o);o.stack=s.message+"\n"+s.stack.join("\n")}C(o,"",!0)}}function v(t,e){for(var n=0;n<e.length-1;++n)e[n].push("From previous event:"),e[n]=e[n].join("\n");return n<e.length&&(e[n]=e[n].join("\n")),t+"\n"+e.join("\n")}function y(t){for(var e=0;e<t.length;++e)(0===t[e].length||e+1<t.length&&t[e][0]===t[e+1][0])&&(t.splice(e,1),e--)}function g(t){for(var e=t[0],n=1;n<t.length;++n){for(var r=t[n],i=e.length-1,o=e[i],s=-1,a=r.length-1;a>=0;--a)if(r[a]===o){s=a;break}for(var a=s;a>=0;--a){var c=r[a];if(e[i]!==c)break;e.pop(),i--}e=r}}function m(t){for(var e=[],n=0;n<t.length;++n){var r=t[n],i="    (No stack trace)"===r||N.test(r),o=i&&X(r);i&&!o&&(B&&" "!==r.charAt(0)&&(r="    "+r),e.push(r))}return e}function b(t){for(var e=t.stack.replace(/\s+$/g,"").split("\n"),n=0;n<e.length;++n){var r=e[n];if("    (No stack trace)"===r||N.test(r))break}return n>0&&(e=e.slice(n)),e}function w(t){var e=t.stack,n=t.toString();return e="string"==typeof e&&e.length>0?b(t):["    (No stack trace)"],{message:n,stack:m(e)}}function C(t,e,n){if("undefined"!=typeof console){var r;if(I.isObject(t)){var i=t.stack;r=e+U(i,t)}else r=e+String(t);"function"==typeof S?S(r,n):("function"==typeof console.log||"object"==typeof console.log)&&console.log(r)}}function j(t,e,n,r){var i=!1;try{"function"==typeof e&&(i=!0,"rejectionHandled"===t?e(r):e(n,r))}catch(o){D.throwLater(o)}var s=!1;try{s=Y(t,n,r)}catch(o){s=!0,D.throwLater(o)}var a=!1;if(K)try{a=K(t.toLowerCase(),{reason:n,promise:r})}catch(o){a=!0,D.throwLater(o)}s||i||a||"unhandledRejection"!==t||C(n,"Unhandled rejection ")}function k(t){var e;if("function"==typeof t)e="[function "+(t.name||"anonymous")+"]";else{e=t&&"function"==typeof t.toString?t.toString():I.toString(t);var n=/\[object [a-zA-Z0-9$_]+\]/;if(n.test(e))try{var r=JSON.stringify(t);e=r}catch(i){}0===e.length&&(e="(empty array)")}return"(<"+F(e)+">, no stack trace)"}function F(t){var e=41;return t.length<e?t:t.substr(0,e-3)+"..."}function E(){return"function"==typeof J}function x(t){var e=t.match(W);return e?{fileName:e[1],line:parseInt(e[2],10)}:void 0}function T(t,e){if(E()){for(var n,r,i=t.stack.split("\n"),o=e.stack.split("\n"),s=-1,a=-1,c=0;c<i.length;++c){var l=x(i[c]);if(l){n=l.fileName,s=l.line;break}}for(var c=0;c<o.length;++c){var l=x(o[c]);if(l){r=l.fileName,a=l.line;break}}0>s||0>a||!n||!r||n!==r||s>=a||(X=function(t){if(H.test(t))return!0;var e=x(t);return e&&e.fileName===n&&s<=e.line&&e.line<=a?!0:!1})}}function R(t){this._parent=t,this._promisesCreated=0;var e=this._length=1+(void 0===t?0:t._length);J(this,R),e>32&&this.uncycle()}var P,O,S,A=e._getDomain,D=e._async,V=t("./errors").Warning,I=t("./util"),L=I.canAttachTrace,H=/[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/,N=null,U=null,B=!1,M=!(0==I.env("BLUEBIRD_DEBUG")||!I.env("BLUEBIRD_DEBUG")&&"development"!==I.env("NODE_ENV")),q=!(0==I.env("BLUEBIRD_WARNINGS")||!M&&!I.env("BLUEBIRD_WARNINGS")),Q=!(0==I.env("BLUEBIRD_LONG_STACK_TRACES")||!M&&!I.env("BLUEBIRD_LONG_STACK_TRACES")),$=0!=I.env("BLUEBIRD_W_FORGOTTEN_RETURN")&&(q||!!I.env("BLUEBIRD_W_FORGOTTEN_RETURN"));e.prototype.suppressUnhandledRejections=function(){var t=this._target();t._bitField=-1048577&t._bitField|524288},e.prototype._ensurePossibleRejectionHandled=function(){0===(524288&this._bitField)&&(this._setRejectionIsUnhandled(),D.invokeLater(this._notifyUnhandledRejection,this,void 0))},e.prototype._notifyUnhandledRejectionIsHandled=function(){j("rejectionHandled",P,void 0,this)},e.prototype._setReturnedNonUndefined=function(){this._bitField=268435456|this._bitField},e.prototype._returnedNonUndefined=function(){return 0!==(268435456&this._bitField)},e.prototype._notifyUnhandledRejection=function(){if(this._isRejectionUnhandled()){var t=this._settledValue();this._setUnhandledRejectionIsNotified(),j("unhandledRejection",O,t,this)}},e.prototype._setUnhandledRejectionIsNotified=function(){this._bitField=262144|this._bitField},e.prototype._unsetUnhandledRejectionIsNotified=function(){this._bitField=-262145&this._bitField},e.prototype._isUnhandledRejectionNotified=function(){return(262144&this._bitField)>0},e.prototype._setRejectionIsUnhandled=function(){this._bitField=1048576|this._bitField},e.prototype._unsetRejectionIsUnhandled=function(){this._bitField=-1048577&this._bitField,this._isUnhandledRejectionNotified()&&(this._unsetUnhandledRejectionIsNotified(),this._notifyUnhandledRejectionIsHandled())},e.prototype._isRejectionUnhandled=function(){return(1048576&this._bitField)>0},e.prototype._warn=function(t,e,n){return d(t,e,n||this)},e.onPossiblyUnhandledRejection=function(t){var e=A();O="function"==typeof t?null===e?t:e.bind(t):void 0},e.onUnhandledRejectionHandled=function(t){var e=A();P="function"==typeof t?null===e?t:e.bind(t):void 0};var z=function(){};e.longStackTraces=function(){if(D.haveItemsQueued()&&!Z.longStackTraces)throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");if(!Z.longStackTraces&&E()){var t=e.prototype._captureStackTrace,r=e.prototype._attachExtraTrace;Z.longStackTraces=!0,z=function(){if(D.haveItemsQueued()&&!Z.longStackTraces)throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");e.prototype._captureStackTrace=t,e.prototype._attachExtraTrace=r,n.deactivateLongStackTraces(),D.enableTrampoline(),Z.longStackTraces=!1},e.prototype._captureStackTrace=p,e.prototype._attachExtraTrace=h,n.activateLongStackTraces(),D.disableTrampolineIfNecessary()}},e.hasLongStackTraces=function(){return Z.longStackTraces&&E()},e.config=function(t){if(t=Object(t),"longStackTraces"in t&&(t.longStackTraces?e.longStackTraces():!t.longStackTraces&&e.hasLongStackTraces()&&z()),"warnings"in t){var n=t.warnings;Z.warnings=!!n,$=Z.warnings,I.isObject(n)&&"wForgottenReturn"in n&&($=!!n.wForgottenReturn)}if("cancellation"in t&&t.cancellation&&!Z.cancellation){if(D.haveItemsQueued())throw new Error("cannot enable cancellation after promises are in use");e.prototype._clearCancellationData=a,e.prototype._propagateFrom=c,e.prototype._onCancel=o,e.prototype._setOnCancel=s,e.prototype._attachCancellationCallback=i,e.prototype._execute=r,G=c,Z.cancellation=!0}},e.prototype._execute=function(t,e,n){try{t(e,n)}catch(r){return r}},e.prototype._onCancel=function(){},e.prototype._setOnCancel=function(t){},e.prototype._attachCancellationCallback=function(t){},e.prototype._captureStackTrace=function(){},e.prototype._attachExtraTrace=function(){},e.prototype._clearCancellationData=function(){},e.prototype._propagateFrom=function(t,e){};var G=l,X=function(){return!1},W=/[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;I.inherits(R,Error),n.CapturedTrace=R,R.prototype.uncycle=function(){var t=this._length;if(!(2>t)){for(var e=[],n={},r=0,i=this;void 0!==i;++r)e.push(i),i=i._parent;t=this._length=r;for(var r=t-1;r>=0;--r){var o=e[r].stack;void 0===n[o]&&(n[o]=r)}for(var r=0;t>r;++r){var s=e[r].stack,a=n[s];if(void 0!==a&&a!==r){a>0&&(e[a-1]._parent=void 0,e[a-1]._length=1),e[r]._parent=void 0,e[r]._length=1;var c=r>0?e[r-1]:this;t-1>a?(c._parent=e[a+1],c._parent.uncycle(),c._length=c._parent._length+1):(c._parent=void 0,c._length=1);for(var l=c._length+1,u=r-2;u>=0;--u)e[u]._length=l,l++;return}}}},R.prototype.attachExtraTrace=function(t){if(!t.__stackCleaned__){this.uncycle();for(var e=w(t),n=e.message,r=[e.stack],i=this;void 0!==i;)r.push(m(i.stack.split("\n"))),i=i._parent;g(r),y(r),I.notEnumerableProp(t,"stack",v(n,r)),I.notEnumerableProp(t,"__stackCleaned__",!0)}};var K,J=function(){var t=/^\s*at\s*/,e=function(t,e){return"string"==typeof t?t:void 0!==e.name&&void 0!==e.message?e.toString():k(e)};if("number"==typeof Error.stackTraceLimit&&"function"==typeof Error.captureStackTrace){Error.stackTraceLimit+=6,N=t,U=e;var n=Error.captureStackTrace;return X=function(t){return H.test(t)},function(t,e){Error.stackTraceLimit+=6,n(t,e),Error.stackTraceLimit-=6}}var r=new Error;if("string"==typeof r.stack&&r.stack.split("\n")[0].indexOf("stackDetection@")>=0)return N=/@/,U=e,B=!0,function(t){t.stack=(new Error).stack};var i;try{throw new Error}catch(o){i="stack"in o}return"stack"in r||!i||"number"!=typeof Error.stackTraceLimit?(U=function(t,e){return"string"==typeof t?t:"object"!=typeof e&&"function"!=typeof e||void 0===e.name||void 0===e.message?k(e):e.toString()},null):(N=t,U=e,function(t){Error.stackTraceLimit+=6;try{throw new Error}catch(e){t.stack=e.stack}Error.stackTraceLimit-=6})}([]),Y=function(){if(I.isNode)return function(t,e,n){return"rejectionHandled"===t?process.emit(t,n):process.emit(t,e,n)};var t="undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0!==this?this:null;if(!t)return function(){return!1};try{var e=document.createEvent("CustomEvent");e.initCustomEvent("testingtheevent",!1,!0,{}),t.dispatchEvent(e),K=function(e,n){var r=document.createEvent("CustomEvent");return r.initCustomEvent(e,!1,!0,n),!t.dispatchEvent(r)}}catch(n){}var r={};return r.unhandledRejection="onunhandledRejection".toLowerCase(),r.rejectionHandled="onrejectionHandled".toLowerCase(),function(e,n,i){var o=r[e],s=t[o];return s?("rejectionHandled"===e?s.call(t,i):s.call(t,n,i),!0):!1}}();"undefined"!=typeof console&&"undefined"!=typeof console.warn&&(S=function(t){console.warn(t)},I.isNode&&process.stderr.isTTY?S=function(t,e){var n=e?"[33m":"[31m";console.warn(n+t+"[0m\n")}:I.isNode||"string"!=typeof(new Error).stack||(S=function(t,e){console.warn("%c"+t,e?"color: darkorange":"color: red")}));var Z={warnings:q,longStackTraces:!1,cancellation:!1};return Q&&e.longStackTraces(),{longStackTraces:function(){return Z.longStackTraces},warnings:function(){return Z.warnings},cancellation:function(){return Z.cancellation},propagateFromFunction:function(){return G},boundValueFunction:function(){return u},checkForgottenReturns:f,setBounds:T,warn:d,deprecated:_,CapturedTrace:R}}},{"./errors":12,"./util":36}],10:[function(t,e,n){"use strict";e.exports=function(t){function e(){return this.value}function n(){throw this.reason}t.prototype["return"]=t.prototype.thenReturn=function(n){return n instanceof t&&n.suppressUnhandledRejections(),this._then(e,void 0,void 0,{value:n},void 0)},t.prototype["throw"]=t.prototype.thenThrow=function(t){return this._then(n,void 0,void 0,{reason:t},void 0)},t.prototype.catchThrow=function(t){if(arguments.length<=1)return this._then(void 0,n,void 0,{reason:t},void 0);var e=arguments[1],r=function(){throw e};return this.caught(t,r)},t.prototype.catchReturn=function(n){if(arguments.length<=1)return n instanceof t&&n.suppressUnhandledRejections(),this._then(void 0,e,void 0,{value:n},void 0);var r=arguments[1];r instanceof t&&r.suppressUnhandledRejections();var i=function(){return r};return this.caught(n,i)}}},{}],11:[function(t,e,n){"use strict";e.exports=function(t,e){function n(){return o(this)}function r(t,n){return i(t,n,e,e)}var i=t.reduce,o=t.all;t.prototype.each=function(t){return this.mapSeries(t)._then(n,void 0,void 0,this,void 0)},t.prototype.mapSeries=function(t){return i(this,t,e,e)},t.each=function(t,e){return r(t,e)._then(n,void 0,void 0,t,void 0)},t.mapSeries=r}},{}],12:[function(t,e,n){"use strict";function r(t,e){function n(r){return this instanceof n?(p(this,"message","string"==typeof r?r:e),p(this,"name",t),void(Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):Error.call(this))):new n(r)}return u(n,Error),n}function i(t){return this instanceof i?(p(this,"name","OperationalError"),p(this,"message",t),this.cause=t,this.isOperational=!0,void(t instanceof Error?(p(this,"message",t.message),p(this,"stack",t.stack)):Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor))):new i(t)}var o,s,a=t("./es5"),c=a.freeze,l=t("./util"),u=l.inherits,p=l.notEnumerableProp,h=r("Warning","warning"),f=r("CancellationError","cancellation error"),_=r("TimeoutError","timeout error"),d=r("AggregateError","aggregate error");try{o=TypeError,s=RangeError}catch(v){o=r("TypeError","type error"),s=r("RangeError","range error")}for(var y="join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "),g=0;g<y.length;++g)"function"==typeof Array.prototype[y[g]]&&(d.prototype[y[g]]=Array.prototype[y[g]]);a.defineProperty(d.prototype,"length",{value:0,configurable:!1,writable:!0,enumerable:!0}),d.prototype.isOperational=!0;var m=0;d.prototype.toString=function(){var t=Array(4*m+1).join(" "),e="\n"+t+"AggregateError of:\n";m++,t=Array(4*m+1).join(" ");for(var n=0;n<this.length;++n){for(var r=this[n]===this?"[Circular AggregateError]":this[n]+"",i=r.split("\n"),o=0;o<i.length;++o)i[o]=t+i[o];r=i.join("\n"),e+=r+"\n"}return m--,e},u(i,Error);var b=Error.__BluebirdErrorTypes__;b||(b=c({CancellationError:f,TimeoutError:_,OperationalError:i,RejectionError:i,AggregateError:d}),p(Error,"__BluebirdErrorTypes__",b)),e.exports={Error:Error,TypeError:o,RangeError:s,CancellationError:b.CancellationError,OperationalError:b.OperationalError,TimeoutError:b.TimeoutError,AggregateError:b.AggregateError,Warning:h}},{"./es5":13,"./util":36}],13:[function(t,e,n){var r=function(){"use strict";return void 0===this}();if(r)e.exports={freeze:Object.freeze,defineProperty:Object.defineProperty,getDescriptor:Object.getOwnPropertyDescriptor,keys:Object.keys,names:Object.getOwnPropertyNames,getPrototypeOf:Object.getPrototypeOf,isArray:Array.isArray,isES5:r,propertyIsWritable:function(t,e){var n=Object.getOwnPropertyDescriptor(t,e);return!(n&&!n.writable&&!n.set)}};else{var i={}.hasOwnProperty,o={}.toString,s={}.constructor.prototype,a=function(t){var e=[];for(var n in t)i.call(t,n)&&e.push(n);return e},c=function(t,e){return{value:t[e]}},l=function(t,e,n){return t[e]=n.value,t},u=function(t){return t},p=function(t){try{return Object(t).constructor.prototype}catch(e){return s}},h=function(t){try{return"[object Array]"===o.call(t)}catch(e){return!1}};e.exports={isArray:h,keys:a,names:a,defineProperty:l,getDescriptor:c,freeze:u,getPrototypeOf:p,isES5:r,propertyIsWritable:function(){return!0}}}},{}],14:[function(t,e,n){"use strict";e.exports=function(t,e){var n=t.map;t.prototype.filter=function(t,r){return n(this,t,r,e)},t.filter=function(t,r,i){return n(t,r,i,e)}}},{}],15:[function(t,e,n){"use strict";e.exports=function(e,n){function r(t,e,n){this.promise=t,this.type=e,this.handler=n,this.called=!1,this.cancelPromise=null}function i(t){this.finallyHandler=t}function o(t,e){return null!=t.cancelPromise?(arguments.length>1?t.cancelPromise._reject(e):t.cancelPromise._cancel(),t.cancelPromise=null,!0):!1}function s(){return c.call(this,this.promise._target()._settledValue())}function a(t){return o(this,t)?void 0:(p.e=t,p)}function c(t){var r=this.promise,c=this.handler;if(!this.called){this.called=!0;var l=0===this.type?c.call(r._boundValue()):c.call(r._boundValue(),t);if(void 0!==l){r._setReturnedNonUndefined();var h=n(l,r);if(h instanceof e){if(null!=this.cancelPromise){if(h.isCancelled()){var f=new u("late cancellation observer");return r._attachExtraTrace(f),p.e=f,p}h.isPending()&&h._attachCancellationCallback(new i(this))}return h._then(s,a,void 0,this,void 0)}}}return r.isRejected()?(o(this),p.e=t,p):(o(this),t)}var l=t("./util"),u=e.CancellationError,p=l.errorObj;return i.prototype._resultCancelled=function(){o(this.finallyHandler)},e.prototype._passThrough=function(t,e,n,i){return"function"!=typeof t?this.then():this._then(n,i,void 0,new r(this,e,t),void 0)},e.prototype.lastly=e.prototype["finally"]=function(t){return this._passThrough(t,0,c,c)},e.prototype.tap=function(t){return this._passThrough(t,1,c)},r}},{"./util":36}],16:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o,s){function a(t,n,r){for(var o=0;o<n.length;++o){r._pushContext();var s=f(n[o])(t);if(r._popContext(),s===h){r._pushContext();var a=e.reject(h.e);return r._popContext(),a}var c=i(s,r);if(c instanceof e)return c}return null}function c(t,n,i,o){var s=this._promise=new e(r);s._captureStackTrace(),s._setOnCancel(this),this._stack=o,this._generatorFunction=t,this._receiver=n,this._generator=void 0,this._yieldHandlers="function"==typeof i?[i].concat(_):_,this._yieldedPromise=null}var l=t("./errors"),u=l.TypeError,p=t("./util"),h=p.errorObj,f=p.tryCatch,_=[];p.inherits(c,o),c.prototype._isResolved=function(){return null===this._promise},c.prototype._cleanup=function(){this._promise=this._generator=null},c.prototype._promiseCancelled=function(){if(!this._isResolved()){var t,n="undefined"!=typeof this._generator["return"];if(n)this._promise._pushContext(),t=f(this._generator["return"]).call(this._generator,void 0),this._promise._popContext();else{var r=new e.CancellationError("generator .return() sentinel");e.coroutine.returnSentinel=r,this._promise._attachExtraTrace(r),this._promise._pushContext(),t=f(this._generator["throw"]).call(this._generator,r),this._promise._popContext(),t===h&&t.e===r&&(t=null)}var i=this._promise;this._cleanup(),t===h?i._rejectCallback(t.e,!1):i.cancel()}},c.prototype._promiseFulfilled=function(t){this._yieldedPromise=null,this._promise._pushContext();var e=f(this._generator.next).call(this._generator,t);this._promise._popContext(),this._continue(e)},c.prototype._promiseRejected=function(t){this._yieldedPromise=null,this._promise._attachExtraTrace(t),this._promise._pushContext();var e=f(this._generator["throw"]).call(this._generator,t);this._promise._popContext(),this._continue(e)},c.prototype._resultCancelled=function(){if(this._yieldedPromise instanceof e){var t=this._yieldedPromise;this._yieldedPromise=null,t.cancel()}},c.prototype.promise=function(){return this._promise},c.prototype._run=function(){this._generator=this._generatorFunction.call(this._receiver),this._receiver=this._generatorFunction=void 0,this._promiseFulfilled(void 0)},c.prototype._continue=function(t){var n=this._promise;if(t===h)return this._cleanup(),n._rejectCallback(t.e,!1);var r=t.value;if(t.done===!0)return this._cleanup(),n._resolveCallback(r);var o=i(r,this._promise);if(!(o instanceof e)&&(o=a(o,this._yieldHandlers,this._promise),null===o))return void this._promiseRejected(new u("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s",r)+"From coroutine:\n"+this._stack.split("\n").slice(1,-7).join("\n")));o=o._target();var s=o._bitField;0===(50397184&s)?(this._yieldedPromise=o,o._proxy(this,null)):0!==(33554432&s)?this._promiseFulfilled(o._value()):0!==(16777216&s)?this._promiseRejected(o._reason()):this._promiseCancelled()},e.coroutine=function(t,e){if("function"!=typeof t)throw new u("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");var n=Object(e).yieldHandler,r=c,i=(new Error).stack;return function(){var e=t.apply(this,arguments),o=new r(void 0,void 0,n,i),s=o.promise();return o._generator=e,o._promiseFulfilled(void 0),s}},e.coroutine.addYieldHandler=function(t){if("function"!=typeof t)throw new u("expecting a function but got "+p.classString(t));_.push(t)},e.spawn=function(t){if(s.deprecated("Promise.spawn()","Promise.coroutine()"),"function"!=typeof t)return n("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");var r=new c(t,this),i=r.promise();return r._run(e.spawn),i}}},{"./errors":12,"./util":36}],17:[function(t,e,n){"use strict";e.exports=function(e,n,r,i){var o=t("./util");o.canEvaluate,o.tryCatch,o.errorObj;e.join=function(){var t,e=arguments.length-1;if(e>0&&"function"==typeof arguments[e]){t=arguments[e];var r}var i=[].slice.call(arguments);t&&i.pop();var r=new n(i).promise();return void 0!==t?r.spread(t):r}}},{"./util":36}],18:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o,s){function a(t,e,n,r){this.constructor$(t),this._promise._captureStackTrace();var i=l();this._callback=null===i?e:i.bind(e),this._preservedValues=r===o?new Array(this.length()):null,this._limit=n,this._inFlight=0,this._queue=n>=1?[]:f,this._init$(void 0,-2)}function c(t,e,n,i){if("function"!=typeof e)return r("expecting a function but got "+u.classString(e));var o="object"==typeof n&&null!==n?n.concurrency:0;return o="number"==typeof o&&isFinite(o)&&o>=1?o:0,new a(t,e,o,i).promise()}var l=e._getDomain,u=t("./util"),p=u.tryCatch,h=u.errorObj,f=[];u.inherits(a,n),a.prototype._init=function(){},a.prototype._promiseFulfilled=function(t,n){var r=this._values,o=this.length(),a=this._preservedValues,c=this._limit;if(0>n){if(n=-1*n-1,r[n]=t,c>=1&&(this._inFlight--,this._drainQueue(),this._isResolved()))return!0}else{if(c>=1&&this._inFlight>=c)return r[n]=t,this._queue.push(n),!1;null!==a&&(a[n]=t);var l=this._promise,u=this._callback,f=l._boundValue();l._pushContext();var _=p(u).call(f,t,n,o),d=l._popContext();if(s.checkForgottenReturns(_,d,null!==a?"Promise.filter":"Promise.map",l),_===h)return this._reject(_.e),!0;var v=i(_,this._promise);if(v instanceof e){v=v._target();var y=v._bitField;if(0===(50397184&y))return c>=1&&this._inFlight++,r[n]=v,v._proxy(this,-1*(n+1)),!1;if(0===(33554432&y))return 0!==(16777216&y)?(this._reject(v._reason()),
!0):(this._cancel(),!0);_=v._value()}r[n]=_}var g=++this._totalResolved;return g>=o?(null!==a?this._filter(r,a):this._resolve(r),!0):!1},a.prototype._drainQueue=function(){for(var t=this._queue,e=this._limit,n=this._values;t.length>0&&this._inFlight<e;){if(this._isResolved())return;var r=t.pop();this._promiseFulfilled(n[r],r)}},a.prototype._filter=function(t,e){for(var n=e.length,r=new Array(n),i=0,o=0;n>o;++o)t[o]&&(r[i++]=e[o]);r.length=i,this._resolve(r)},a.prototype.preservedValues=function(){return this._preservedValues},e.prototype.map=function(t,e){return c(this,t,e,null)},e.map=function(t,e,n,r){return c(t,e,n,r)}}},{"./util":36}],19:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o){var s=t("./util"),a=s.tryCatch;e.method=function(t){if("function"!=typeof t)throw new e.TypeError("expecting a function but got "+s.classString(t));return function(){var r=new e(n);r._captureStackTrace(),r._pushContext();var i=a(t).apply(this,arguments),s=r._popContext();return o.checkForgottenReturns(i,s,"Promise.method",r),r._resolveFromSyncValue(i),r}},e.attempt=e["try"]=function(t){if("function"!=typeof t)return i("expecting a function but got "+s.classString(t));var r=new e(n);r._captureStackTrace(),r._pushContext();var c;if(arguments.length>1){o.deprecated("calling Promise.try with more than 1 argument");var l=arguments[1],u=arguments[2];c=s.isArray(l)?a(t).apply(u,l):a(t).call(u,l)}else c=a(t)();var p=r._popContext();return o.checkForgottenReturns(c,p,"Promise.try",r),r._resolveFromSyncValue(c),r},e.prototype._resolveFromSyncValue=function(t){t===s.errorObj?this._rejectCallback(t.e,!1):this._resolveCallback(t,!0)}}},{"./util":36}],20:[function(t,e,n){"use strict";function r(t){return t instanceof Error&&u.getPrototypeOf(t)===Error.prototype}function i(t){var e;if(r(t)){e=new l(t),e.name=t.name,e.message=t.message,e.stack=t.stack;for(var n=u.keys(t),i=0;i<n.length;++i){var o=n[i];p.test(o)||(e[o]=t[o])}return e}return s.markAsOriginatingFromRejection(t),t}function o(t,e){return function(n,r){if(null!==t){if(n){var o=i(a(n));t._attachExtraTrace(o),t._reject(o)}else if(e){var s=[].slice.call(arguments,1);t._fulfill(s)}else t._fulfill(r);t=null}}}var s=t("./util"),a=s.maybeWrapAsError,c=t("./errors"),l=c.OperationalError,u=t("./es5"),p=/^(?:name|message|stack|cause)$/;e.exports=o},{"./errors":12,"./es5":13,"./util":36}],21:[function(t,e,n){"use strict";e.exports=function(e){function n(t,e){var n=this;if(!o.isArray(t))return r.call(n,t,e);var i=a(e).apply(n._boundValue(),[null].concat(t));i===c&&s.throwLater(i.e)}function r(t,e){var n=this,r=n._boundValue(),i=void 0===t?a(e).call(r,null):a(e).call(r,null,t);i===c&&s.throwLater(i.e)}function i(t,e){var n=this;if(!t){var r=new Error(t+"");r.cause=t,t=r}var i=a(e).call(n._boundValue(),t);i===c&&s.throwLater(i.e)}var o=t("./util"),s=e._async,a=o.tryCatch,c=o.errorObj;e.prototype.asCallback=e.prototype.nodeify=function(t,e){if("function"==typeof t){var o=r;void 0!==e&&Object(e).spread&&(o=n),this._then(o,i,void 0,this,t)}return this}}},{"./util":36}],22:[function(t,e,n){"use strict";e.exports=function(){function e(){}function n(t,e){if("function"!=typeof e)throw new y("expecting a function but got "+h.classString(e));if(t.constructor!==r)throw new y("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n")}function r(t){this._bitField=0,this._fulfillmentHandler0=void 0,this._rejectionHandler0=void 0,this._promise0=void 0,this._receiver0=void 0,t!==m&&(n(this,t),this._resolveFromExecutor(t)),this._promiseCreated()}function i(t){this.promise._resolveCallback(t)}function o(t){this.promise._rejectCallback(t,!1)}function s(t){var e=new r(m);e._fulfillmentHandler0=t,e._rejectionHandler0=t,e._promise0=t,e._receiver0=t}var a,c=function(){return new y("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n")},l=function(){return new r.PromiseInspection(this._target())},u=function(t){return r.reject(new y(t))},p={},h=t("./util");a=h.isNode?function(){var t=process.domain;return void 0===t&&(t=null),t}:function(){return null},h.notEnumerableProp(r,"_getDomain",a);var f=t("./es5"),_=t("./async"),d=new _;f.defineProperty(r,"_async",{value:d});var v=t("./errors"),y=r.TypeError=v.TypeError;r.RangeError=v.RangeError;var g=r.CancellationError=v.CancellationError;r.TimeoutError=v.TimeoutError,r.OperationalError=v.OperationalError,r.RejectionError=v.OperationalError,r.AggregateError=v.AggregateError;var m=function(){},b={},w={},C=t("./thenables")(r,m),j=t("./promise_array")(r,m,C,u,e),k=t("./context")(r),F=k.create,E=t("./debuggability")(r,k),x=(E.CapturedTrace,t("./finally")(r,C)),T=t("./catch_filter")(w),R=t("./nodeback"),P=h.errorObj,O=h.tryCatch;return r.prototype.toString=function(){return"[object Promise]"},r.prototype.caught=r.prototype["catch"]=function(t){var e=arguments.length;if(e>1){var n,r=new Array(e-1),i=0;for(n=0;e-1>n;++n){var o=arguments[n];if(!h.isObject(o))return u("expecting an object but got "+h.classString(o));r[i++]=o}return r.length=i,t=arguments[n],this.then(void 0,T(r,t,this))}return this.then(void 0,t)},r.prototype.reflect=function(){return this._then(l,l,void 0,this,void 0)},r.prototype.then=function(t,e){if(E.warnings()&&arguments.length>0&&"function"!=typeof t&&"function"!=typeof e){var n=".then() only accepts functions but was passed: "+h.classString(t);arguments.length>1&&(n+=", "+h.classString(e)),this._warn(n)}return this._then(t,e,void 0,void 0,void 0)},r.prototype.done=function(t,e){var n=this._then(t,e,void 0,void 0,void 0);n._setIsFinal()},r.prototype.spread=function(t){return"function"!=typeof t?u("expecting a function but got "+h.classString(t)):this.all()._then(t,void 0,void 0,b,void 0)},r.prototype.toJSON=function(){var t={isFulfilled:!1,isRejected:!1,fulfillmentValue:void 0,rejectionReason:void 0};return this.isFulfilled()?(t.fulfillmentValue=this.value(),t.isFulfilled=!0):this.isRejected()&&(t.rejectionReason=this.reason(),t.isRejected=!0),t},r.prototype.all=function(){return arguments.length>0&&this._warn(".all() was passed arguments but it does not take any"),new j(this).promise()},r.prototype.error=function(t){return this.caught(h.originatesFromRejection,t)},r.is=function(t){return t instanceof r},r.fromNode=r.fromCallback=function(t){var e=new r(m);e._captureStackTrace();var n=arguments.length>1?!!Object(arguments[1]).multiArgs:!1,i=O(t)(R(e,n));return i===P&&e._rejectCallback(i.e,!0),e._isFateSealed()||e._setAsyncGuaranteed(),e},r.all=function(t){return new j(t).promise()},r.cast=function(t){var e=C(t);return e instanceof r||(e=new r(m),e._captureStackTrace(),e._setFulfilled(),e._rejectionHandler0=t),e},r.resolve=r.fulfilled=r.cast,r.reject=r.rejected=function(t){var e=new r(m);return e._captureStackTrace(),e._rejectCallback(t,!0),e},r.setScheduler=function(t){if("function"!=typeof t)throw new y("expecting a function but got "+h.classString(t));var e=d._schedule;return d._schedule=t,e},r.prototype._then=function(t,e,n,i,o){var s=void 0!==o,c=s?o:new r(m),l=this._target(),u=l._bitField;s||(c._propagateFrom(this,3),c._captureStackTrace(),void 0===i&&0!==(2097152&this._bitField)&&(i=0!==(50397184&u)?this._boundValue():l===this?void 0:this._boundTo));var p=a();if(0!==(50397184&u)){var h,f,_=l._settlePromiseCtx;0!==(33554432&u)?(f=l._rejectionHandler0,h=t):0!==(16777216&u)?(f=l._fulfillmentHandler0,h=e,l._unsetRejectionIsUnhandled()):(_=l._settlePromiseLateCancellationObserver,f=new g("late cancellation observer"),l._attachExtraTrace(f),h=e),d.invoke(_,l,{handler:null===p?h:"function"==typeof h&&p.bind(h),promise:c,receiver:i,value:f})}else l._addCallbacks(t,e,c,i,p);return c},r.prototype._length=function(){return 65535&this._bitField},r.prototype._isFateSealed=function(){return 0!==(117506048&this._bitField)},r.prototype._isFollowing=function(){return 67108864===(67108864&this._bitField)},r.prototype._setLength=function(t){this._bitField=-65536&this._bitField|65535&t},r.prototype._setFulfilled=function(){this._bitField=33554432|this._bitField},r.prototype._setRejected=function(){this._bitField=16777216|this._bitField},r.prototype._setFollowing=function(){this._bitField=67108864|this._bitField},r.prototype._setIsFinal=function(){this._bitField=4194304|this._bitField},r.prototype._isFinal=function(){return(4194304&this._bitField)>0},r.prototype._unsetCancelled=function(){this._bitField=-65537&this._bitField},r.prototype._setCancelled=function(){this._bitField=65536|this._bitField},r.prototype._setAsyncGuaranteed=function(){this._bitField=134217728|this._bitField},r.prototype._receiverAt=function(t){var e=0===t?this._receiver0:this[4*t-4+3];return e===p?void 0:void 0===e&&this._isBound()?this._boundValue():e},r.prototype._promiseAt=function(t){return this[4*t-4+2]},r.prototype._fulfillmentHandlerAt=function(t){return this[4*t-4+0]},r.prototype._rejectionHandlerAt=function(t){return this[4*t-4+1]},r.prototype._boundValue=function(){},r.prototype._migrateCallback0=function(t){var e=(t._bitField,t._fulfillmentHandler0),n=t._rejectionHandler0,r=t._promise0,i=t._receiverAt(0);void 0===i&&(i=p),this._addCallbacks(e,n,r,i,null)},r.prototype._migrateCallbackAt=function(t,e){var n=t._fulfillmentHandlerAt(e),r=t._rejectionHandlerAt(e),i=t._promiseAt(e),o=t._receiverAt(e);void 0===o&&(o=p),this._addCallbacks(n,r,i,o,null)},r.prototype._addCallbacks=function(t,e,n,r,i){var o=this._length();if(o>=65531&&(o=0,this._setLength(0)),0===o)this._promise0=n,this._receiver0=r,"function"==typeof t&&(this._fulfillmentHandler0=null===i?t:i.bind(t)),"function"==typeof e&&(this._rejectionHandler0=null===i?e:i.bind(e));else{var s=4*o-4;this[s+2]=n,this[s+3]=r,"function"==typeof t&&(this[s+0]=null===i?t:i.bind(t)),"function"==typeof e&&(this[s+1]=null===i?e:i.bind(e))}return this._setLength(o+1),o},r.prototype._proxy=function(t,e){this._addCallbacks(void 0,void 0,e,t,null)},r.prototype._resolveCallback=function(t,e){if(0===(117506048&this._bitField)){if(t===this)return this._rejectCallback(c(),!1);var n=C(t,this);if(!(n instanceof r))return this._fulfill(t);e&&this._propagateFrom(n,2);var i=n._target(),o=i._bitField;if(0===(50397184&o)){var s=this._length();s>0&&i._migrateCallback0(this);for(var a=1;s>a;++a)i._migrateCallbackAt(this,a);this._setFollowing(),this._setLength(0),this._setFollowee(i)}else if(0!==(33554432&o))this._fulfill(i._value());else if(0!==(16777216&o))this._reject(i._reason());else{var l=new g("late cancellation observer");i._attachExtraTrace(l),this._reject(l)}}},r.prototype._rejectCallback=function(t,e,n){var r=h.ensureErrorObject(t),i=r===t;if(!i&&!n&&E.warnings()){var o="a promise was rejected with a non-error: "+h.classString(t);this._warn(o,!0)}this._attachExtraTrace(r,e?i:!1),this._reject(t)},r.prototype._resolveFromExecutor=function(t){var e=this;this._captureStackTrace(),this._pushContext();var n=!0,r=this._execute(t,function(t){e._resolveCallback(t)},function(t){e._rejectCallback(t,n)});n=!1,this._popContext(),void 0!==r&&e._rejectCallback(r,!0)},r.prototype._settlePromiseFromHandler=function(t,e,n,r){var i=r._bitField;if(0===(65536&i)){r._pushContext();var o;e===b?n&&"number"==typeof n.length?o=O(t).apply(this._boundValue(),n):(o=P,o.e=new y("cannot .spread() a non-array: "+h.classString(n))):o=O(t).call(e,n);var s=r._popContext();if(i=r._bitField,0===(65536&i))if(o===w)r._reject(n);else if(o===P||o===r){var a=o===r?c():o.e;r._rejectCallback(a,!1)}else E.checkForgottenReturns(o,s,"",r,this),r._resolveCallback(o)}},r.prototype._target=function(){for(var t=this;t._isFollowing();)t=t._followee();return t},r.prototype._followee=function(){return this._rejectionHandler0},r.prototype._setFollowee=function(t){this._rejectionHandler0=t},r.prototype._settlePromise=function(t,n,i,o){var s=t instanceof r,a=this._bitField,c=0!==(134217728&a);0!==(65536&a)?(s&&t._invokeInternalOnCancel(),i instanceof x?(i.cancelPromise=t,O(n).call(i,o)===P&&t._reject(P.e)):n===l?t._fulfill(l.call(i)):i instanceof e?i._promiseCancelled(t):s||t instanceof j?t._cancel():i.cancel()):"function"==typeof n?s?(c&&t._setAsyncGuaranteed(),this._settlePromiseFromHandler(n,i,o,t)):n.call(i,o,t):i instanceof e?i._isResolved()||(0!==(33554432&a)?i._promiseFulfilled(o,t):i._promiseRejected(o,t)):s&&(c&&t._setAsyncGuaranteed(),0!==(33554432&a)?t._fulfill(o):t._reject(o))},r.prototype._settlePromiseLateCancellationObserver=function(t){var e=t.handler,n=t.promise,i=t.receiver,o=t.value;"function"==typeof e?n instanceof r?this._settlePromiseFromHandler(e,i,o,n):e.call(i,o,n):n instanceof r&&n._reject(o)},r.prototype._settlePromiseCtx=function(t){this._settlePromise(t.promise,t.handler,t.receiver,t.value)},r.prototype._settlePromise0=function(t,e,n){var r=this._promise0,i=this._receiverAt(0);this._promise0=void 0,this._receiver0=void 0,this._settlePromise(r,t,i,e)},r.prototype._clearCallbackDataAtIndex=function(t){var e=4*t-4;this[e+2]=this[e+3]=this[e+0]=this[e+1]=void 0},r.prototype._fulfill=function(t){var e=this._bitField;if(!((117506048&e)>>>16)){if(t===this){var n=c();return this._attachExtraTrace(n),this._reject(n)}this._setFulfilled(),this._rejectionHandler0=t,(65535&e)>0&&(0!==(134217728&e)?this._settlePromises():d.settlePromises(this))}},r.prototype._reject=function(t){var e=this._bitField;if(!((117506048&e)>>>16))return this._setRejected(),this._fulfillmentHandler0=t,this._isFinal()?d.fatalError(t,h.isNode):void((65535&e)>0?0!==(134217728&e)?this._settlePromises():d.settlePromises(this):this._ensurePossibleRejectionHandled())},r.prototype._fulfillPromises=function(t,e){for(var n=1;t>n;n++){var r=this._fulfillmentHandlerAt(n),i=this._promiseAt(n),o=this._receiverAt(n);this._clearCallbackDataAtIndex(n),this._settlePromise(i,r,o,e)}},r.prototype._rejectPromises=function(t,e){for(var n=1;t>n;n++){var r=this._rejectionHandlerAt(n),i=this._promiseAt(n),o=this._receiverAt(n);this._clearCallbackDataAtIndex(n),this._settlePromise(i,r,o,e)}},r.prototype._settlePromises=function(){var t=this._bitField,e=65535&t;if(e>0){if(0!==(16842752&t)){var n=this._fulfillmentHandler0;this._settlePromise0(this._rejectionHandler0,n,t),this._rejectPromises(e,n)}else{var r=this._rejectionHandler0;this._settlePromise0(this._fulfillmentHandler0,r,t),this._fulfillPromises(e,r)}this._setLength(0)}this._clearCancellationData()},r.prototype._settledValue=function(){var t=this._bitField;return 0!==(33554432&t)?this._rejectionHandler0:0!==(16777216&t)?this._fulfillmentHandler0:void 0},r.defer=r.pending=function(){E.deprecated("Promise.defer","new Promise");var t=new r(m);return{promise:t,resolve:i,reject:o}},h.notEnumerableProp(r,"_makeSelfResolutionError",c),t("./method")(r,m,C,u,E),t("./bind")(r,m,C,E),t("./cancel")(r,j,u,E),t("./direct_resolve")(r),t("./synchronous_inspection")(r),t("./join")(r,j,C,m,E),r.Promise=r,t("./map.js")(r,j,u,C,m,E),t("./using.js")(r,u,C,F,m,E),t("./timers.js")(r,m,E),t("./generators.js")(r,u,m,C,e,E),t("./nodeify.js")(r),t("./call_get.js")(r),t("./props.js")(r,j,C,u),t("./race.js")(r,m,C,u),t("./reduce.js")(r,j,u,C,m,E),t("./settle.js")(r,j,E),t("./some.js")(r,j,u),t("./promisify.js")(r,m),t("./any.js")(r),t("./each.js")(r,m),t("./filter.js")(r,m),h.toFastProperties(r),h.toFastProperties(r.prototype),s({a:1}),s({b:2}),s({c:3}),s(1),s(function(){}),s(void 0),s(!1),s(new r(m)),E.setBounds(_.firstLineError,h.lastLineError),r}},{"./any.js":1,"./async":2,"./bind":3,"./call_get.js":5,"./cancel":6,"./catch_filter":7,"./context":8,"./debuggability":9,"./direct_resolve":10,"./each.js":11,"./errors":12,"./es5":13,"./filter.js":14,"./finally":15,"./generators.js":16,"./join":17,"./map.js":18,"./method":19,"./nodeback":20,"./nodeify.js":21,"./promise_array":23,"./promisify.js":24,"./props.js":25,"./race.js":27,"./reduce.js":28,"./settle.js":30,"./some.js":31,"./synchronous_inspection":32,"./thenables":33,"./timers.js":34,"./using.js":35,"./util":36}],23:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o){function s(t){switch(t){case-2:return[];case-3:return{}}}function a(t){var r=this._promise=new e(n);t instanceof e&&r._propagateFrom(t,3),r._setOnCancel(this),this._values=t,this._length=0,this._totalResolved=0,this._init(void 0,-2)}var c=t("./util");c.isArray;return c.inherits(a,o),a.prototype.length=function(){return this._length},a.prototype.promise=function(){return this._promise},a.prototype._init=function l(t,n){var o=r(this._values,this._promise);if(o instanceof e){o=o._target();var a=o._bitField;if(this._values=o,0===(50397184&a))return this._promise._setAsyncGuaranteed(),o._then(l,this._reject,void 0,this,n);if(0===(33554432&a))return 0!==(16777216&a)?this._reject(o._reason()):this._cancel();o=o._value()}if(o=c.asArray(o),null===o){var u=i("expecting an array or an iterable object but got "+c.classString(o)).reason();return void this._promise._rejectCallback(u,!1)}return 0===o.length?void(-5===n?this._resolveEmptyArray():this._resolve(s(n))):void this._iterate(o)},a.prototype._iterate=function(t){var n=this.getActualLength(t.length);this._length=n,this._values=this.shouldCopyValues()?new Array(n):this._values;for(var i=this._promise,o=!1,s=null,a=0;n>a;++a){var c=r(t[a],i);c instanceof e?(c=c._target(),s=c._bitField):s=null,o?null!==s&&c.suppressUnhandledRejections():null!==s?0===(50397184&s)?(c._proxy(this,a),this._values[a]=c):o=0!==(33554432&s)?this._promiseFulfilled(c._value(),a):0!==(16777216&s)?this._promiseRejected(c._reason(),a):this._promiseCancelled(a):o=this._promiseFulfilled(c,a)}o||i._setAsyncGuaranteed()},a.prototype._isResolved=function(){return null===this._values},a.prototype._resolve=function(t){this._values=null,this._promise._fulfill(t)},a.prototype._cancel=function(){!this._isResolved()&&this._promise.isCancellable()&&(this._values=null,this._promise._cancel())},a.prototype._reject=function(t){this._values=null,this._promise._rejectCallback(t,!1)},a.prototype._promiseFulfilled=function(t,e){this._values[e]=t;var n=++this._totalResolved;return n>=this._length?(this._resolve(this._values),!0):!1},a.prototype._promiseCancelled=function(){return this._cancel(),!0},a.prototype._promiseRejected=function(t){return this._totalResolved++,this._reject(t),!0},a.prototype._resultCancelled=function(){if(!this._isResolved()){var t=this._values;if(this._cancel(),t instanceof e)t.cancel();else for(var n=0;n<t.length;++n)t[n]instanceof e&&t[n].cancel()}},a.prototype.shouldCopyValues=function(){return!0},a.prototype.getActualLength=function(t){return t},a}},{"./util":36}],24:[function(t,e,n){"use strict";e.exports=function(e,n){function r(t){return!C.test(t)}function i(t){try{return t.__isPromisified__===!0}catch(e){return!1}}function o(t,e,n){var r=f.getDataPropertyOrDefault(t,e+n,b);return r?i(r):!1}function s(t,e,n){for(var r=0;r<t.length;r+=2){var i=t[r];if(n.test(i))for(var o=i.replace(n,""),s=0;s<t.length;s+=2)if(t[s]===o)throw new g("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s",e))}}function a(t,e,n,r){for(var a=f.inheritedDataKeys(t),c=[],l=0;l<a.length;++l){var u=a[l],p=t[u],h=r===j?!0:j(u,p,t);"function"!=typeof p||i(p)||o(t,u,e)||!r(u,p,t,h)||c.push(u,p)}return s(c,e,n),c}function c(t,r,i,o,s,a){function c(){var i=r;r===h&&(i=this);var o=new e(n);o._captureStackTrace();var s="string"==typeof u&&this!==l?this[u]:t,c=_(o,a);try{s.apply(i,d(arguments,c))}catch(p){o._rejectCallback(v(p),!0,!0)}return o._isFateSealed()||o._setAsyncGuaranteed(),o}var l=function(){return this}(),u=t;return"string"==typeof u&&(t=o),f.notEnumerableProp(c,"__isPromisified__",!0),c}function l(t,e,n,r,i){for(var o=new RegExp(k(e)+"$"),s=a(t,e,o,n),c=0,l=s.length;l>c;c+=2){var u=s[c],p=s[c+1],_=u+e;if(r===F)t[_]=F(u,h,u,p,e,i);else{var d=r(p,function(){return F(u,h,u,p,e,i)});f.notEnumerableProp(d,"__isPromisified__",!0),t[_]=d}}return f.toFastProperties(t),t}function u(t,e,n){return F(t,e,void 0,t,null,n)}var p,h={},f=t("./util"),_=t("./nodeback"),d=f.withAppended,v=f.maybeWrapAsError,y=f.canEvaluate,g=t("./errors").TypeError,m="Async",b={__isPromisified__:!0},w=["arity","length","name","arguments","caller","callee","prototype","__isPromisified__"],C=new RegExp("^(?:"+w.join("|")+")$"),j=function(t){return f.isIdentifier(t)&&"_"!==t.charAt(0)&&"constructor"!==t},k=function(t){return t.replace(/([$])/,"\\$")},F=y?p:c;e.promisify=function(t,e){if("function"!=typeof t)throw new g("expecting a function but got "+f.classString(t));if(i(t))return t;e=Object(e);var n=void 0===e.context?h:e.context,o=!!e.multiArgs,s=u(t,n,o);return f.copyDescriptors(t,s,r),s},e.promisifyAll=function(t,e){if("function"!=typeof t&&"object"!=typeof t)throw new g("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");e=Object(e);var n=!!e.multiArgs,r=e.suffix;"string"!=typeof r&&(r=m);var i=e.filter;"function"!=typeof i&&(i=j);var o=e.promisifier;if("function"!=typeof o&&(o=F),!f.isIdentifier(r))throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");for(var s=f.inheritedDataKeys(t),a=0;a<s.length;++a){var c=t[s[a]];"constructor"!==s[a]&&f.isClass(c)&&(l(c.prototype,r,i,o,n),l(c,r,i,o,n))}return l(t,r,i,o,n)}}},{"./errors":12,"./nodeback":20,"./util":36}],25:[function(t,e,n){"use strict";e.exports=function(e,n,r,i){function o(t){var e,n=!1;if(void 0!==a&&t instanceof a)e=p(t),n=!0;else{var r=u.keys(t),i=r.length;e=new Array(2*i);for(var o=0;i>o;++o){var s=r[o];e[o]=t[s],e[o+i]=s}}this.constructor$(e),this._isMap=n,this._init$(void 0,-3)}function s(t){var n,s=r(t);return l(s)?(n=s instanceof e?s._then(e.props,void 0,void 0,void 0,void 0):new o(s).promise(),s instanceof e&&n._propagateFrom(s,2),n):i("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n")}var a,c=t("./util"),l=c.isObject,u=t("./es5");"function"==typeof Map&&(a=Map);var p=function(){function t(t,r){this[e]=t,this[e+n]=r,e++}var e=0,n=0;return function(r){n=r.size,e=0;var i=new Array(2*r.size);return r.forEach(t,i),i}}(),h=function(t){for(var e=new a,n=t.length/2|0,r=0;n>r;++r){var i=t[n+r],o=t[r];e.set(i,o)}return e};c.inherits(o,n),o.prototype._init=function(){},o.prototype._promiseFulfilled=function(t,e){this._values[e]=t;var n=++this._totalResolved;if(n>=this._length){var r;if(this._isMap)r=h(this._values);else{r={};for(var i=this.length(),o=0,s=this.length();s>o;++o)r[this._values[o+i]]=this._values[o]}return this._resolve(r),!0}return!1},o.prototype.shouldCopyValues=function(){return!1},o.prototype.getActualLength=function(t){return t>>1},e.prototype.props=function(){return s(this)},e.props=function(t){return s(t)}}},{"./es5":13,"./util":36}],26:[function(t,e,n){"use strict";function r(t,e,n,r,i){for(var o=0;i>o;++o)n[o+r]=t[o+e],t[o+e]=void 0}function i(t){this._capacity=t,this._length=0,this._front=0}i.prototype._willBeOverCapacity=function(t){return this._capacity<t},i.prototype._pushOne=function(t){var e=this.length();this._checkCapacity(e+1);var n=this._front+e&this._capacity-1;this[n]=t,this._length=e+1},i.prototype._unshiftOne=function(t){var e=this._capacity;this._checkCapacity(this.length()+1);var n=this._front,r=(n-1&e-1^e)-e;this[r]=t,this._front=r,this._length=this.length()+1},i.prototype.unshift=function(t,e,n){this._unshiftOne(n),this._unshiftOne(e),this._unshiftOne(t)},i.prototype.push=function(t,e,n){var r=this.length()+3;if(this._willBeOverCapacity(r))return this._pushOne(t),this._pushOne(e),void this._pushOne(n);var i=this._front+r-3;this._checkCapacity(r);var o=this._capacity-1;this[i+0&o]=t,this[i+1&o]=e,this[i+2&o]=n,this._length=r},i.prototype.shift=function(){var t=this._front,e=this[t];return this[t]=void 0,this._front=t+1&this._capacity-1,this._length--,e},i.prototype.length=function(){return this._length},i.prototype._checkCapacity=function(t){this._capacity<t&&this._resizeTo(this._capacity<<1)},i.prototype._resizeTo=function(t){var e=this._capacity;this._capacity=t;var n=this._front,i=this._length,o=n+i&e-1;r(this,0,this,e,o)},e.exports=i},{}],27:[function(t,e,n){"use strict";e.exports=function(e,n,r,i){function o(t,o){var c=r(t);if(c instanceof e)return a(c);if(t=s.asArray(t),null===t)return i("expecting an array or an iterable object but got "+s.classString(t));var l=new e(n);void 0!==o&&l._propagateFrom(o,3);for(var u=l._fulfill,p=l._reject,h=0,f=t.length;f>h;++h){var _=t[h];(void 0!==_||h in t)&&e.cast(_)._then(u,p,void 0,l,null)}return l}var s=t("./util"),a=function(t){return t.then(function(e){return o(e,t)})};e.race=function(t){return o(t,void 0)},e.prototype.race=function(){return o(this,void 0)}}},{"./util":36}],28:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o,s){function a(t,n,r,i){this.constructor$(t);var s=h();this._fn=null===s?n:s.bind(n),void 0!==r&&(r=e.resolve(r),r._attachCancellationCallback(this)),this._initialValue=r,this._currentCancellable=null,this._eachValues=i===o?[]:void 0,this._promise._captureStackTrace(),this._init$(void 0,-5)}function c(t,e){this.isFulfilled()?e._resolve(t):e._reject(t)}function l(t,e,n,i){if("function"!=typeof e)return r("expecting a function but got "+f.classString(e));var o=new a(t,e,n,i);return o.promise()}function u(t){this.accum=t,this.array._gotAccum(t);var n=i(this.value,this.array._promise);return n instanceof e?(this.array._currentCancellable=n,n._then(p,void 0,void 0,this,void 0)):p.call(this,n)}function p(t){var n=this.array,r=n._promise,i=_(n._fn);r._pushContext();var o;o=void 0!==n._eachValues?i.call(r._boundValue(),t,this.index,this.length):i.call(r._boundValue(),this.accum,t,this.index,this.length),o instanceof e&&(n._currentCancellable=o);var a=r._popContext();return s.checkForgottenReturns(o,a,void 0!==n._eachValues?"Promise.each":"Promise.reduce",r),o}var h=e._getDomain,f=t("./util"),_=f.tryCatch;f.inherits(a,n),a.prototype._gotAccum=function(t){void 0!==this._eachValues&&t!==o&&this._eachValues.push(t)},a.prototype._eachComplete=function(t){return this._eachValues.push(t),this._eachValues},a.prototype._init=function(){},a.prototype._resolveEmptyArray=function(){this._resolve(void 0!==this._eachValues?this._eachValues:this._initialValue)},a.prototype.shouldCopyValues=function(){return!1},a.prototype._resolve=function(t){this._promise._resolveCallback(t),this._values=null},a.prototype._resultCancelled=function(t){return t===this._initialValue?this._cancel():void(this._isResolved()||(this._resultCancelled$(),this._currentCancellable instanceof e&&this._currentCancellable.cancel(),this._initialValue instanceof e&&this._initialValue.cancel()))},a.prototype._iterate=function(t){this._values=t;var n,r,i=t.length;if(void 0!==this._initialValue?(n=this._initialValue,r=0):(n=e.resolve(t[0]),r=1),this._currentCancellable=n,!n.isRejected())for(;i>r;++r){var o={accum:null,value:t[r],index:r,length:i,array:this};n=n._then(u,void 0,void 0,o,void 0)}void 0!==this._eachValues&&(n=n._then(this._eachComplete,void 0,void 0,this,void 0)),n._then(c,c,void 0,n,this)},e.prototype.reduce=function(t,e){return l(this,t,e,null)},e.reduce=function(t,e,n,r){return l(t,e,n,r)}}},{"./util":36}],29:[function(t,e,n){"use strict";var r,i=t("./util"),o=function(){throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n")};if(i.isNode&&"undefined"==typeof MutationObserver){var s=global.setImmediate,a=process.nextTick;r=i.isRecentNode?function(t){s.call(global,t)}:function(t){a.call(process,t)}}else r="undefined"==typeof MutationObserver||"undefined"!=typeof window&&window.navigator&&window.navigator.standalone?"undefined"!=typeof setImmediate?function(t){setImmediate(t)}:"undefined"!=typeof setTimeout?function(t){setTimeout(t,0)}:o:function(){var t=document.createElement("div"),e={attributes:!0},n=!1,r=document.createElement("div"),i=new MutationObserver(function(){t.classList.toggle("foo"),n=!1});i.observe(r,e);var o=function(){n||(n=!0,r.classList.toggle("foo"))};return function(n){var r=new MutationObserver(function(){r.disconnect(),n()});r.observe(t,e),o()}}();e.exports=r},{"./util":36}],30:[function(t,e,n){"use strict";e.exports=function(e,n,r){function i(t){this.constructor$(t)}var o=e.PromiseInspection,s=t("./util");s.inherits(i,n),i.prototype._promiseResolved=function(t,e){this._values[t]=e;var n=++this._totalResolved;return n>=this._length?(this._resolve(this._values),!0):!1},i.prototype._promiseFulfilled=function(t,e){var n=new o;return n._bitField=33554432,n._settledValueField=t,this._promiseResolved(e,n)},i.prototype._promiseRejected=function(t,e){var n=new o;return n._bitField=16777216,n._settledValueField=t,this._promiseResolved(e,n)},e.settle=function(t){return r.deprecated(".settle()",".reflect()"),new i(t).promise()},e.prototype.settle=function(){return e.settle(this)}}},{"./util":36}],31:[function(t,e,n){"use strict";e.exports=function(e,n,r){function i(t){this.constructor$(t),this._howMany=0,this._unwrap=!1,this._initialized=!1}function o(t,e){if((0|e)!==e||0>e)return r("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");var n=new i(t),o=n.promise();return n.setHowMany(e),n.init(),o}var s=t("./util"),a=t("./errors").RangeError,c=t("./errors").AggregateError,l=s.isArray,u={};s.inherits(i,n),i.prototype._init=function(){if(this._initialized){if(0===this._howMany)return void this._resolve([]);this._init$(void 0,-5);var t=l(this._values);!this._isResolved()&&t&&this._howMany>this._canPossiblyFulfill()&&this._reject(this._getRangeError(this.length()))}},i.prototype.init=function(){this._initialized=!0,this._init()},i.prototype.setUnwrap=function(){this._unwrap=!0},i.prototype.howMany=function(){return this._howMany},i.prototype.setHowMany=function(t){this._howMany=t},i.prototype._promiseFulfilled=function(t){return this._addFulfilled(t),this._fulfilled()===this.howMany()?(this._values.length=this.howMany(),1===this.howMany()&&this._unwrap?this._resolve(this._values[0]):this._resolve(this._values),!0):!1},i.prototype._promiseRejected=function(t){return this._addRejected(t),this._checkOutcome()},i.prototype._promiseCancelled=function(){return this._values instanceof e||null==this._values?this._cancel():(this._addRejected(u),this._checkOutcome())},i.prototype._checkOutcome=function(){if(this.howMany()>this._canPossiblyFulfill()){for(var t=new c,e=this.length();e<this._values.length;++e)this._values[e]!==u&&t.push(this._values[e]);return t.length>0?this._reject(t):this._cancel(),!0}return!1},i.prototype._fulfilled=function(){return this._totalResolved},i.prototype._rejected=function(){return this._values.length-this.length()},i.prototype._addRejected=function(t){this._values.push(t)},i.prototype._addFulfilled=function(t){this._values[this._totalResolved++]=t},i.prototype._canPossiblyFulfill=function(){return this.length()-this._rejected()},i.prototype._getRangeError=function(t){var e="Input array must contain at least "+this._howMany+" items but contains only "+t+" items";return new a(e)},i.prototype._resolveEmptyArray=function(){this._reject(this._getRangeError(0))},e.some=function(t,e){return o(t,e)},e.prototype.some=function(t){return o(this,t)},e._SomePromiseArray=i}},{"./errors":12,"./util":36}],32:[function(t,e,n){"use strict";e.exports=function(t){function e(t){void 0!==t?(t=t._target(),this._bitField=t._bitField,this._settledValueField=t._isFateSealed()?t._settledValue():void 0):(this._bitField=0,this._settledValueField=void 0)}e.prototype._settledValue=function(){return this._settledValueField};var n=e.prototype.value=function(){if(!this.isFulfilled())throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");return this._settledValue()},r=e.prototype.error=e.prototype.reason=function(){if(!this.isRejected())throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");return this._settledValue()},i=e.prototype.isFulfilled=function(){return 0!==(33554432&this._bitField)},o=e.prototype.isRejected=function(){return 0!==(16777216&this._bitField)},s=e.prototype.isPending=function(){return 0===(50397184&this._bitField)},a=e.prototype.isResolved=function(){return 0!==(50331648&this._bitField)};e.prototype.isCancelled=t.prototype._isCancelled=function(){
return 65536===(65536&this._bitField)},t.prototype.isCancelled=function(){return this._target()._isCancelled()},t.prototype.isPending=function(){return s.call(this._target())},t.prototype.isRejected=function(){return o.call(this._target())},t.prototype.isFulfilled=function(){return i.call(this._target())},t.prototype.isResolved=function(){return a.call(this._target())},t.prototype.value=function(){return n.call(this._target())},t.prototype.reason=function(){var t=this._target();return t._unsetRejectionIsUnhandled(),r.call(t)},t.prototype._value=function(){return this._settledValue()},t.prototype._reason=function(){return this._unsetRejectionIsUnhandled(),this._settledValue()},t.PromiseInspection=e}},{}],33:[function(t,e,n){"use strict";e.exports=function(e,n){function r(t,r){if(u(t)){if(t instanceof e)return t;var i=o(t);if(i===l){r&&r._pushContext();var c=e.reject(i.e);return r&&r._popContext(),c}if("function"==typeof i){if(s(t)){var c=new e(n);return t._then(c._fulfill,c._reject,void 0,c,null),c}return a(t,i,r)}}return t}function i(t){return t.then}function o(t){try{return i(t)}catch(e){return l.e=e,l}}function s(t){return p.call(t,"_promise0")}function a(t,r,i){function o(t){a&&(a._resolveCallback(t),a=null)}function s(t){a&&(a._rejectCallback(t,p,!0),a=null)}var a=new e(n),u=a;i&&i._pushContext(),a._captureStackTrace(),i&&i._popContext();var p=!0,h=c.tryCatch(r).call(t,o,s);return p=!1,a&&h===l&&(a._rejectCallback(h.e,!0,!0),a=null),u}var c=t("./util"),l=c.errorObj,u=c.isObject,p={}.hasOwnProperty;return r}},{"./util":36}],34:[function(t,e,n){"use strict";e.exports=function(e,n,r){function i(t){var e=this;return e instanceof Number&&(e=+e),clearTimeout(e),t}function o(t){var e=this;throw e instanceof Number&&(e=+e),clearTimeout(e),t}var s=t("./util"),a=e.TimeoutError,c=function(t,e,n){if(t.isPending()){var i;i="string"!=typeof e?e instanceof Error?e:new a("operation timed out"):new a(e),s.markAsOriginatingFromRejection(i),t._attachExtraTrace(i),t._reject(i),r.cancellation()&&n.cancel()}},l=function(t){return u(+this).thenReturn(t)},u=e.delay=function(t,r){var i;return void 0!==r?i=e.resolve(r)._then(l,null,null,t,void 0):(i=new e(n),setTimeout(function(){i._fulfill()},+t)),i._setAsyncGuaranteed(),i};e.prototype.delay=function(t){return u(t,this)},e.prototype.timeout=function(t,e){t=+t;var n=this.then(),s=n.then(),a=setTimeout(function(){c(s,e,n)},t);return r.cancellation()&&s._setOnCancel({_resultCancelled:function(){clearTimeout(a)}}),s._then(i,o,void 0,a,void 0)}}},{"./util":36}],35:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o,s){function a(t){setTimeout(function(){throw t},0)}function c(t){var e=r(t);return e!==t&&"function"==typeof t._isDisposable&&"function"==typeof t._getDisposer&&t._isDisposable()&&e._setDisposable(t._getDisposer()),e}function l(t,n){function i(){if(s>=l)return u._fulfill();var o=c(t[s++]);if(o instanceof e&&o._isDisposable()){try{o=r(o._getDisposer().tryDispose(n),t.promise)}catch(p){return a(p)}if(o instanceof e)return o._then(i,a,null,null,null)}i()}var s=0,l=t.length,u=new e(o);return i(),u}function u(t,e,n){this._data=t,this._promise=e,this._context=n}function p(t,e,n){this.constructor$(t,e,n)}function h(t){return u.isDisposer(t)?(this.resources[this.index]._setDisposable(t),t.promise()):t}function f(t){this.length=t,this.promise=null,this[t-1]=null}var _=t("./util"),d=t("./errors").TypeError,v=t("./util").inherits,y=_.errorObj,g=_.tryCatch;u.prototype.data=function(){return this._data},u.prototype.promise=function(){return this._promise},u.prototype.resource=function(){return this.promise().isFulfilled()?this.promise().value():null},u.prototype.tryDispose=function(t){var e=this.resource(),n=this._context;void 0!==n&&n._pushContext();var r=null!==e?this.doDispose(e,t):null;return void 0!==n&&n._popContext(),this._promise._unsetDisposable(),this._data=null,r},u.isDisposer=function(t){return null!=t&&"function"==typeof t.resource&&"function"==typeof t.tryDispose},v(p,u),p.prototype.doDispose=function(t,e){var n=this.data();return n.call(t,t,e)},f.prototype._resultCancelled=function(){for(var t=this.length,n=0;t>n;++n){var r=this[n];r instanceof e&&r.cancel()}},e.using=function(){var t=arguments.length;if(2>t)return n("you must pass at least 2 arguments to Promise.using");var i=arguments[t-1];if("function"!=typeof i)return n("expecting a function but got "+_.classString(i));var o,a=!0;2===t&&Array.isArray(arguments[0])?(o=arguments[0],t=o.length,a=!1):(o=arguments,t--);for(var c=new f(t),p=0;t>p;++p){var d=o[p];if(u.isDisposer(d)){var v=d;d=d.promise(),d._setDisposable(v)}else{var m=r(d);m instanceof e&&(d=m._then(h,null,null,{resources:c,index:p},void 0))}c[p]=d}for(var b=new Array(c.length),p=0;p<b.length;++p)b[p]=e.resolve(c[p]).reflect();var w=e.all(b).then(function(t){for(var e=0;e<t.length;++e){var n=t[e];if(n.isRejected())return y.e=n.error(),y;if(!n.isFulfilled())return void w.cancel();t[e]=n.value()}C._pushContext(),i=g(i);var r=a?i.apply(void 0,t):i(t),o=C._popContext();return s.checkForgottenReturns(r,o,"Promise.using",C),r}),C=w.lastly(function(){var t=new e.PromiseInspection(w);return l(c,t)});return c.promise=C,C._setOnCancel(c),C},e.prototype._setDisposable=function(t){this._bitField=131072|this._bitField,this._disposer=t},e.prototype._isDisposable=function(){return(131072&this._bitField)>0},e.prototype._getDisposer=function(){return this._disposer},e.prototype._unsetDisposable=function(){this._bitField=-131073&this._bitField,this._disposer=void 0},e.prototype.disposer=function(t){if("function"==typeof t)return new p(t,this,i());throw new d}}},{"./errors":12,"./util":36}],36:[function(t,e,n){"use strict";function r(){try{var t=E;return E=null,t.apply(this,arguments)}catch(e){return F.e=e,F}}function i(t){return E=t,r}function o(t){return null==t||t===!0||t===!1||"string"==typeof t||"number"==typeof t}function s(t){return"function"==typeof t||"object"==typeof t&&null!==t}function a(t){return o(t)?new Error(v(t)):t}function c(t,e){var n,r=t.length,i=new Array(r+1);for(n=0;r>n;++n)i[n]=t[n];return i[n]=e,i}function l(t,e,n){if(!j.isES5)return{}.hasOwnProperty.call(t,e)?t[e]:void 0;var r=Object.getOwnPropertyDescriptor(t,e);return null!=r?null==r.get&&null==r.set?r.value:n:void 0}function u(t,e,n){if(o(t))return t;var r={value:n,configurable:!0,enumerable:!1,writable:!0};return j.defineProperty(t,e,r),t}function p(t){throw t}function h(t){try{if("function"==typeof t){var e=j.names(t.prototype),n=j.isES5&&e.length>1,r=e.length>0&&!(1===e.length&&"constructor"===e[0]),i=R.test(t+"")&&j.names(t).length>0;if(n||r||i)return!0}return!1}catch(o){return!1}}function f(t){function e(){}e.prototype=t;for(var n=8;n--;)new e;return t}function _(t){return P.test(t)}function d(t,e,n){for(var r=new Array(t),i=0;t>i;++i)r[i]=e+i+n;return r}function v(t){try{return t+""}catch(e){return"[no string representation]"}}function y(t){try{u(t,"isOperational",!0)}catch(e){}}function g(t){return null==t?!1:t instanceof Error.__BluebirdErrorTypes__.OperationalError||t.isOperational===!0}function m(t){return t instanceof Error&&j.propertyIsWritable(t,"stack")}function b(t){return{}.toString.call(t)}function w(t,e,n){for(var r=j.names(t),i=0;i<r.length;++i){var o=r[i];if(n(o))try{j.defineProperty(e,o,j.getDescriptor(t,o))}catch(s){}}}function C(t,e){return D?process.env[t]:e}var j=t("./es5"),k="undefined"==typeof navigator,F={e:{}},E,x=function(t,e){function n(){this.constructor=t,this.constructor$=e;for(var n in e.prototype)r.call(e.prototype,n)&&"$"!==n.charAt(n.length-1)&&(this[n+"$"]=e.prototype[n])}var r={}.hasOwnProperty;return n.prototype=e.prototype,t.prototype=new n,t.prototype},T=function(){var t=[Array.prototype,Object.prototype,Function.prototype],e=function(e){for(var n=0;n<t.length;++n)if(t[n]===e)return!0;return!1};if(j.isES5){var n=Object.getOwnPropertyNames;return function(t){for(var r=[],i=Object.create(null);null!=t&&!e(t);){var o;try{o=n(t)}catch(s){return r}for(var a=0;a<o.length;++a){var c=o[a];if(!i[c]){i[c]=!0;var l=Object.getOwnPropertyDescriptor(t,c);null!=l&&null==l.get&&null==l.set&&r.push(c)}}t=j.getPrototypeOf(t)}return r}}var r={}.hasOwnProperty;return function(n){if(e(n))return[];var i=[];t:for(var o in n)if(r.call(n,o))i.push(o);else{for(var s=0;s<t.length;++s)if(r.call(t[s],o))continue t;i.push(o)}return i}}(),R=/this\s*\.\s*\S+\s*=/,P=/^[a-z$_][a-z$_0-9]*$/i,O=function(){return"stack"in new Error?function(t){return m(t)?t:new Error(v(t))}:function(t){if(m(t))return t;try{throw new Error(v(t))}catch(e){return e}}}(),S=function(t){return j.isArray(t)?t:null};if("undefined"!=typeof Symbol&&Symbol.iterator){var A="function"==typeof Array.from?function(t){return Array.from(t)}:function(t){for(var e,n=[],r=t[Symbol.iterator]();!(e=r.next()).done;)n.push(e.value);return n};S=function(t){return j.isArray(t)?t:null!=t&&"function"==typeof t[Symbol.iterator]?A(t):null}}var D="undefined"!=typeof process&&"[object process]"===b(process).toLowerCase(),V={isClass:h,isIdentifier:_,inheritedDataKeys:T,getDataPropertyOrDefault:l,thrower:p,isArray:j.isArray,asArray:S,notEnumerableProp:u,isPrimitive:o,isObject:s,canEvaluate:k,errorObj:F,tryCatch:i,inherits:x,withAppended:c,maybeWrapAsError:a,toFastProperties:f,filledRange:d,toString:v,canAttachTrace:m,ensureErrorObject:O,originatesFromRejection:g,markAsOriginatingFromRejection:y,classString:b,copyDescriptors:w,hasDevTools:"undefined"!=typeof chrome&&chrome&&"function"==typeof chrome.loadTimes,isNode:D,env:C};V.isRecentNode=V.isNode&&function(){var t=process.versions.node.split(".").map(Number);return 0===t[0]&&t[1]>10||t[0]>0}(),V.isNode&&V.toFastProperties(process);try{throw new Error}catch(I){V.lastLineError=I}e.exports=V},{"./es5":13}]},{},[4])(4)}),"undefined"!=typeof window&&null!==window?window.P=window.Promise:"undefined"!=typeof self&&null!==self&&(self.P=self.Promise);;/**
 * @license
 * lodash 3.8.0 (Custom Build) lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE
 * Build: `lodash modern -o ./lodash.js`
 */
;(function(){function n(n,t){if(n!==t){var r=n===n,e=t===t;if(n>t||!r||n===w&&e)return 1;if(n<t||!e||t===w&&r)return-1}return 0}function t(n,t,r){for(var e=n.length,u=r?e:-1;r?u--:++u<e;)if(t(n[u],u,n))return u;return-1}function r(n,t,r){if(t!==t)return p(n,r);r-=1;for(var e=n.length;++r<e;)if(n[r]===t)return r;return-1}function e(n){return typeof n=="function"||false}function u(n){return typeof n=="string"?n:null==n?"":n+""}function o(n){return n.charCodeAt(0)}function i(n,t){for(var r=-1,e=n.length;++r<e&&-1<t.indexOf(n.charAt(r)););
    return r}function f(n,t){for(var r=n.length;r--&&-1<t.indexOf(n.charAt(r)););return r}function a(t,r){return n(t.a,r.a)||t.b-r.b}function c(n){return $n[n]}function l(n){return Ln[n]}function s(n){return"\\"+Mn[n]}function p(n,t,r){var e=n.length;for(t+=r?0:-1;r?t--:++t<e;){var u=n[t];if(u!==u)return t}return-1}function h(n){return!!n&&typeof n=="object"}function _(n){return 160>=n&&9<=n&&13>=n||32==n||160==n||5760==n||6158==n||8192<=n&&(8202>=n||8232==n||8233==n||8239==n||8287==n||12288==n||65279==n);

}function v(n,t){for(var r=-1,e=n.length,u=-1,o=[];++r<e;)n[r]===t&&(n[r]=z,o[++u]=r);return o}function g(n){for(var t=-1,r=n.length;++t<r&&_(n.charCodeAt(t)););return t}function y(n){for(var t=n.length;t--&&_(n.charCodeAt(t)););return t}function d(n){return zn[n]}function m(_){function $n(n){if(h(n)&&!(To(n)||n instanceof Bn)){if(n instanceof zn)return n;if(Ge.call(n,"__chain__")&&Ge.call(n,"__wrapped__"))return Lr(n)}return new zn(n)}function Ln(){}function zn(n,t,r){this.__wrapped__=n,this.__actions__=r||[],
    this.__chain__=!!t}function Bn(n){this.__wrapped__=n,this.__actions__=null,this.__dir__=1,this.__filtered__=false,this.__iteratees__=null,this.__takeCount__=Iu,this.__views__=null}function Mn(){this.__data__={}}function Dn(n){var t=n?n.length:0;for(this.data={hash:du(null),set:new lu};t--;)this.push(n[t])}function Pn(n,t){var r=n.data;return(typeof t=="string"||se(t)?r.set.has(t):r.hash[t])?0:-1}function qn(n,t){var r=-1,e=n.length;for(t||(t=Ue(e));++r<e;)t[r]=n[r];return t}function Kn(n,t){for(var r=-1,e=n.length;++r<e&&false!==t(n[r],r,n););
    return n}function Vn(n,t){for(var r=-1,e=n.length;++r<e;)if(!t(n[r],r,n))return false;return true}function Gn(n,t){for(var r=-1,e=n.length,u=-1,o=[];++r<e;){var i=n[r];t(i,r,n)&&(o[++u]=i)}return o}function Jn(n,t){for(var r=-1,e=n.length,u=Ue(e);++r<e;)u[r]=t(n[r],r,n);return u}function Xn(n,t,r,e){var u=-1,o=n.length;for(e&&o&&(r=n[++u]);++u<o;)r=t(r,n[u],u,n);return r}function Hn(n,t){for(var r=-1,e=n.length;++r<e;)if(t(n[r],r,n))return true;return false}function Qn(n,t){return n===w?t:n}function nt(n,t,r,e){
    return n!==w&&Ge.call(e,r)?n:t}function tt(n,t,r){var e=Ko(t);fu.apply(e,Zu(t));for(var u=-1,o=e.length;++u<o;){var i=e[u],f=n[i],a=r(f,t[i],i,n,t);(a===a?a===f:f!==f)&&(f!==w||i in n)||(n[i]=a)}return n}function rt(n,t){for(var r=-1,e=null==n,u=!e&&jr(n),o=u&&n.length,i=t.length,f=Ue(i);++r<i;){var a=t[r];f[r]=u?kr(a,o)?n[a]:w:e?w:n[a]}return f}function et(n,t,r){r||(r={});for(var e=-1,u=t.length;++e<u;){var o=t[e];r[o]=n[o]}return r}function ut(n,t,r){var e=typeof n;return"function"==e?t===w?n:zt(n,t,r):null==n?Re:"object"==e?wt(n):t===w?Te(n):bt(n,t);

}function ot(n,t,r,e,u,o,i){var f;if(r&&(f=u?r(n,e,u):r(n)),f!==w)return f;if(!se(n))return n;if(e=To(n)){if(f=wr(n),!t)return qn(n,f)}else{var a=Xe.call(n),c=a==K;if(a!=Y&&a!=B&&(!c||u))return Nn[a]?xr(n,a,t):u?n:{};if(f=br(c?{}:n),!t)return $u(f,n)}for(o||(o=[]),i||(i=[]),u=o.length;u--;)if(o[u]==n)return i[u];return o.push(n),i.push(f),(e?Kn:ht)(n,function(e,u){f[u]=ot(e,t,r,u,n,o,i)}),f}function it(n,t,r){if(typeof n!="function")throw new Pe(L);return su(function(){n.apply(w,r)},t)}function ft(n,t){
    var e=n?n.length:0,u=[];if(!e)return u;var o=-1,i=mr(),f=i==r,a=f&&200<=t.length?qu(t):null,c=t.length;a&&(i=Pn,f=false,t=a);n:for(;++o<e;)if(a=n[o],f&&a===a){for(var l=c;l--;)if(t[l]===a)continue n;u.push(a)}else 0>i(t,a,0)&&u.push(a);return u}function at(n,t){var r=true;return zu(n,function(n,e,u){return r=!!t(n,e,u)}),r}function ct(n,t){var r=[];return zu(n,function(n,e,u){t(n,e,u)&&r.push(n)}),r}function lt(n,t,r,e){var u;return r(n,function(n,r,o){return t(n,r,o)?(u=e?r:n,false):void 0}),u}function st(n,t,r){
    for(var e=-1,u=n.length,o=-1,i=[];++e<u;){var f=n[e];if(h(f)&&jr(f)&&(r||To(f)||ae(f))){t&&(f=st(f,t,r));for(var a=-1,c=f.length;++a<c;)i[++o]=f[a]}else r||(i[++o]=f)}return i}function pt(n,t){Mu(n,t,me)}function ht(n,t){return Mu(n,t,Ko)}function _t(n,t){return Du(n,t,Ko)}function vt(n,t){for(var r=-1,e=t.length,u=-1,o=[];++r<e;){var i=t[r];No(n[i])&&(o[++u]=i)}return o}function gt(n,t,r){if(null!=n){r!==w&&r in Fr(n)&&(t=[r]),r=-1;for(var e=t.length;null!=n&&++r<e;)n=n[t[r]];return r&&r==e?n:w}
}function yt(n,t,r,e,u,o){if(n===t)return true;var i=typeof n,f=typeof t;if("function"!=i&&"object"!=i&&"function"!=f&&"object"!=f||null==n||null==t)n=n!==n&&t!==t;else n:{var i=yt,f=To(n),a=To(t),c=M,l=M;f||(c=Xe.call(n),c==B?c=Y:c!=Y&&(f=ge(n))),a||(l=Xe.call(t),l==B?l=Y:l!=Y&&ge(t));var s=c==Y,a=l==Y,l=c==l;if(!l||f||s){if(!e&&(c=s&&Ge.call(n,"__wrapped__"),a=a&&Ge.call(t,"__wrapped__"),c||a)){n=i(c?n.value():n,a?t.value():t,r,e,u,o);break n}if(l){for(u||(u=[]),o||(o=[]),c=u.length;c--;)if(u[c]==n){
    n=o[c]==t;break n}u.push(n),o.push(t),n=(f?_r:gr)(n,t,i,r,e,u,o),u.pop(),o.pop()}else n=false}else n=vr(n,t,c)}return n}function dt(n,t,r,e,u){for(var o=-1,i=t.length,f=!u;++o<i;)if(f&&e[o]?r[o]!==n[t[o]]:!(t[o]in n))return false;for(o=-1;++o<i;){var a=t[o],c=n[a],l=r[o];if(f&&e[o]?a=c!==w||a in n:(a=u?u(c,l,a):w,a===w&&(a=yt(l,c,u,true))),!a)return false}return true}function mt(n,t){var r=-1,e=jr(n)?Ue(n.length):[];return zu(n,function(n,u,o){e[++r]=t(n,u,o)}),e}function wt(n){var t=Ko(n),r=t.length;if(!r)return Ie(true);

    if(1==r){var e=t[0],u=n[e];if(Cr(u))return function(n){return null==n?false:n[e]===u&&(u!==w||e in Fr(n))}}for(var o=Ue(r),i=Ue(r);r--;)u=n[t[r]],o[r]=u,i[r]=Cr(u);return function(n){return null!=n&&dt(Fr(n),t,o,i)}}function bt(n,t){var r=To(n),e=Er(n)&&Cr(t),u=n+"";return n=$r(n),function(o){if(null==o)return false;var i=u;if(o=Fr(o),!(!r&&e||i in o)){if(o=1==n.length?o:gt(o,It(n,0,-1)),null==o)return false;i=Pr(n),o=Fr(o)}return o[i]===t?t!==w||i in o:yt(t,o[i],null,true)}}function xt(n,t,r,e,u){if(!se(n))return n;

    var o=jr(t)&&(To(t)||ge(t));if(!o){var i=Ko(t);fu.apply(i,Zu(t))}return Kn(i||t,function(f,a){if(i&&(a=f,f=t[a]),h(f)){e||(e=[]),u||(u=[]);n:{for(var c=a,l=e,s=u,p=l.length,_=t[c];p--;)if(l[p]==_){n[c]=s[p];break n}var p=n[c],v=r?r(p,_,c,n,t):w,g=v===w;g&&(v=_,jr(_)&&(To(_)||ge(_))?v=To(p)?p:jr(p)?qn(p):[]:Fo(_)||ae(_)?v=ae(p)?ye(p):Fo(p)?p:{}:g=false),l.push(_),s.push(v),g?n[c]=xt(v,_,r,l,s):(v===v?v!==p:p===p)&&(n[c]=v)}}else c=n[a],l=r?r(c,f,a,n,t):w,(s=l===w)&&(l=f),!o&&l===w||!s&&(l===l?l===c:c!==c)||(n[a]=l);

    }),n}function At(n){return function(t){return null==t?w:t[n]}}function jt(n){var t=n+"";return n=$r(n),function(r){return gt(r,n,t)}}function kt(n,t){for(var r=n?t.length:0;r--;){var e=parseFloat(t[r]);if(e!=u&&kr(e)){var u=e;pu.call(n,e,1)}}}function Ot(n,t){return n+uu(Ou()*(t-n+1))}function Et(n,t,r,e,u){return u(n,function(n,u,o){r=e?(e=false,n):t(r,n,u,o)}),r}function It(n,t,r){var e=-1,u=n.length;for(t=null==t?0:+t||0,0>t&&(t=-t>u?0:u+t),r=r===w||r>u?u:+r||0,0>r&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0,
                                                                                                                                                                                                                                                                                                                                                                                                                                  r=Ue(u);++e<u;)r[e]=n[e+t];return r}function Rt(n,t){var r;return zu(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function Ct(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].c;return n}function Wt(t,r,e){var u=dr(),o=-1;return r=Jn(r,function(n){return u(n)}),t=mt(t,function(n){return{a:Jn(r,function(t){return t(n)}),b:++o,c:n}}),Ct(t,function(t,r){var u;n:{u=-1;for(var o=t.a,i=r.a,f=o.length,a=e.length;++u<f;){var c=n(o[u],i[u]);if(c){u=u<a?c*(e[u]?1:-1):c;break n}}u=t.b-r.b}return u})}function St(n,t){
    var r=0;return zu(n,function(n,e,u){r+=+t(n,e,u)||0}),r}function Tt(n,t){var e=-1,u=mr(),o=n.length,i=u==r,f=i&&200<=o,a=f?qu():null,c=[];a?(u=Pn,i=false):(f=false,a=t?[]:c);n:for(;++e<o;){var l=n[e],s=t?t(l,e,n):l;if(i&&l===l){for(var p=a.length;p--;)if(a[p]===s)continue n;t&&a.push(s),c.push(l)}else 0>u(a,s,0)&&((t||f)&&a.push(s),c.push(l))}return c}function Ut(n,t){for(var r=-1,e=t.length,u=Ue(e);++r<e;)u[r]=n[t[r]];return u}function Nt(n,t,r,e){for(var u=n.length,o=e?u:-1;(e?o--:++o<u)&&t(n[o],o,n););
    return r?It(n,e?0:o,e?o+1:u):It(n,e?o+1:0,e?u:o)}function Ft(n,t){var r=n;r instanceof Bn&&(r=r.value());for(var e=-1,u=t.length;++e<u;){var r=[r],o=t[e];fu.apply(r,o.args),r=o.func.apply(o.thisArg,r)}return r}function $t(n,t,r){var e=0,u=n?n.length:e;if(typeof t=="number"&&t===t&&u<=Wu){for(;e<u;){var o=e+u>>>1,i=n[o];(r?i<=t:i<t)?e=o+1:u=o}return u}return Lt(n,t,Re,r)}function Lt(n,t,r,e){t=r(t);for(var u=0,o=n?n.length:0,i=t!==t,f=t===w;u<o;){var a=uu((u+o)/2),c=r(n[a]),l=c===c;(i?l||e:f?l&&(e||c!==w):e?c<=t:c<t)?u=a+1:o=a;

}return xu(o,Cu)}function zt(n,t,r){if(typeof n!="function")return Re;if(t===w)return n;switch(r){case 1:return function(r){return n.call(t,r)};case 3:return function(r,e,u){return n.call(t,r,e,u)};case 4:return function(r,e,u,o){return n.call(t,r,e,u,o)};case 5:return function(r,e,u,o,i){return n.call(t,r,e,u,o,i)}}return function(){return n.apply(t,arguments)}}function Bt(n){return tu.call(n,0)}function Mt(n,t,r){for(var e=r.length,u=-1,o=bu(n.length-e,0),i=-1,f=t.length,a=Ue(o+f);++i<f;)a[i]=t[i];

    for(;++u<e;)a[r[u]]=n[u];for(;o--;)a[i++]=n[u++];return a}function Dt(n,t,r){for(var e=-1,u=r.length,o=-1,i=bu(n.length-u,0),f=-1,a=t.length,c=Ue(i+a);++o<i;)c[o]=n[o];for(i=o;++f<a;)c[i+f]=t[f];for(;++e<u;)c[i+r[e]]=n[o++];return c}function Pt(n,t){return function(r,e,u){var o=t?t():{};if(e=dr(e,u,3),To(r)){u=-1;for(var i=r.length;++u<i;){var f=r[u];n(o,f,e(f,u,r),r)}}else zu(r,function(t,r,u){n(o,t,e(t,r,u),u)});return o}}function qt(n){return fe(function(t,r){var e=-1,u=null==t?0:r.length,o=2<u&&r[u-2],i=2<u&&r[2],f=1<u&&r[u-1];

    for(typeof o=="function"?(o=zt(o,f,5),u-=2):(o=typeof f=="function"?f:null,u-=o?1:0),i&&Or(r[0],r[1],i)&&(o=3>u?null:o,u=1);++e<u;)(i=r[e])&&n(t,i,o);return t})}function Kt(n,t){return function(r,e){var u=r?Yu(r):0;if(!Rr(u))return n(r,e);for(var o=t?u:-1,i=Fr(r);(t?o--:++o<u)&&false!==e(i[o],o,i););return r}}function Vt(n){return function(t,r,e){var u=Fr(t);e=e(t);for(var o=e.length,i=n?o:-1;n?i--:++i<o;){var f=e[i];if(false===r(u[f],f,u))break}return t}}function Yt(n,t){function r(){return(this&&this!==Yn&&this instanceof r?e:n).apply(t,arguments);

}var e=Gt(n);return r}function Zt(n){return function(t){var r=-1;t=Oe(be(t));for(var e=t.length,u="";++r<e;)u=n(u,t[r],r);return u}}function Gt(n){return function(){var t=Lu(n.prototype),r=n.apply(t,arguments);return se(r)?r:t}}function Jt(n){function t(r,e,u){return u&&Or(r,e,u)&&(e=null),r=hr(r,n,null,null,null,null,null,e),r.placeholder=t.placeholder,r}return t}function Xt(n,t){return function(r,e,u){u&&Or(r,e,u)&&(e=null);var i=dr(),f=null==e;if(i===ut&&f||(f=false,e=i(e,u,3)),f){if(e=To(r),e||!ve(r))return n(e?r:Nr(r));

    e=o}return yr(r,e,t)}}function Ht(n,r){return function(e,u,o){return u=dr(u,o,3),To(e)?(u=t(e,u,r),-1<u?e[u]:w):lt(e,u,n)}}function Qt(n){return function(r,e,u){return r&&r.length?(e=dr(e,u,3),t(r,e,n)):-1}}function nr(n){return function(t,r,e){return r=dr(r,e,3),lt(t,r,n,true)}}function tr(n){return function(){var t=arguments.length;if(!t)return function(){return arguments[0]};for(var r,e=n?t:-1,u=0,o=Ue(t);n?e--:++e<t;){var i=o[u++]=arguments[e];if(typeof i!="function")throw new Pe(L);var f=r?"":Vu(i);

    r="wrapper"==f?new zn([]):r}for(e=r?-1:t;++e<t;)i=o[e],f=Vu(i),r=(u="wrapper"==f?Ku(i):null)&&Ir(u[0])&&u[1]==(R|k|E|C)&&!u[4].length&&1==u[9]?r[Vu(u[0])].apply(r,u[3]):1==i.length&&Ir(i)?r[f]():r.thru(i);return function(){var n=arguments;if(r&&1==n.length&&To(n[0]))return r.plant(n[0]).value();for(var e=0,n=o[e].apply(this,n);++e<t;)n=o[e].call(this,n);return n}}}function rr(n,t){return function(r,e,u){return typeof e=="function"&&u===w&&To(r)?n(r,e):t(r,zt(e,u,3))}}function er(n){return function(t,r,e){
    return(typeof r!="function"||e!==w)&&(r=zt(r,e,3)),n(t,r,me)}}function ur(n){return function(t,r,e){return(typeof r!="function"||e!==w)&&(r=zt(r,e,3)),n(t,r)}}function or(n){return function(t,r,e){var u={};return r=dr(r,e,3),ht(t,function(t,e,o){o=r(t,e,o),e=n?o:e,t=n?t:o,u[e]=t}),u}}function ir(n){return function(t,r,e){return t=u(t),(n?t:"")+lr(t,r,e)+(n?"":t)}}function fr(n){var t=fe(function(r,e){var u=v(e,t.placeholder);return hr(r,n,null,e,u)});return t}function ar(n,t){return function(r,e,u,o){
    var i=3>arguments.length;return typeof e=="function"&&o===w&&To(r)?n(r,e,u,i):Et(r,dr(e,o,4),u,i,t)}}function cr(n,t,r,e,u,o,i,f,a,c){function l(){for(var b=arguments.length,j=b,k=Ue(b);j--;)k[j]=arguments[j];if(e&&(k=Mt(k,e,u)),o&&(k=Dt(k,o,i)),_||y){var j=l.placeholder,O=v(k,j),b=b-O.length;if(b<c){var R=f?qn(f):null,b=bu(c-b,0),C=_?O:null,O=_?null:O,W=_?k:null,k=_?null:k;return t|=_?E:I,t&=~(_?I:E),g||(t&=~(x|A)),k=[n,t,r,W,C,k,O,R,a,b],R=cr.apply(w,k),Ir(n)&&Gu(R,k),R.placeholder=j,R}}if(j=p?r:this,
    h&&(n=j[m]),f)for(R=k.length,b=xu(f.length,R),C=qn(k);b--;)O=f[b],k[b]=kr(O,R)?C[O]:w;return s&&a<k.length&&(k.length=a),(this&&this!==Yn&&this instanceof l?d||Gt(n):n).apply(j,k)}var s=t&R,p=t&x,h=t&A,_=t&k,g=t&j,y=t&O,d=!h&&Gt(n),m=n;return l}function lr(n,t,r){return n=n.length,t=+t,n<t&&mu(t)?(t-=n,r=null==r?" ":r+"",je(r,ru(t/r.length)).slice(0,t)):""}function sr(n,t,r,e){function u(){for(var t=-1,f=arguments.length,a=-1,c=e.length,l=Ue(f+c);++a<c;)l[a]=e[a];for(;f--;)l[a++]=arguments[++t];return(this&&this!==Yn&&this instanceof u?i:n).apply(o?r:this,l);

}var o=t&x,i=Gt(n);return u}function pr(n){return function(t,r,e,u){var o=dr(e);return o===ut&&null==e?$t(t,r,n):Lt(t,r,o(e,u,1),n)}}function hr(n,t,r,e,u,o,i,f){var a=t&A;if(!a&&typeof n!="function")throw new Pe(L);var c=e?e.length:0;if(c||(t&=~(E|I),e=u=null),c-=u?u.length:0,t&I){var l=e,s=u;e=u=null}var p=a?null:Ku(n);return r=[n,t,r,e,u,l,s,o,i,f],p&&(e=r[1],t=p[1],f=e|t,u=t==R&&e==k||t==R&&e==C&&r[7].length<=p[8]||t==(R|C)&&e==k,(f<R||u)&&(t&x&&(r[2]=p[2],f|=e&x?0:j),(e=p[3])&&(u=r[3],r[3]=u?Mt(u,e,p[4]):qn(e),
    r[4]=u?v(r[3],z):qn(p[4])),(e=p[5])&&(u=r[5],r[5]=u?Dt(u,e,p[6]):qn(e),r[6]=u?v(r[5],z):qn(p[6])),(e=p[7])&&(r[7]=qn(e)),t&R&&(r[8]=null==r[8]?p[8]:xu(r[8],p[8])),null==r[9]&&(r[9]=p[9]),r[0]=p[0],r[1]=f),t=r[1],f=r[9]),r[9]=null==f?a?0:n.length:bu(f-c,0)||0,(p?Pu:Gu)(t==x?Yt(r[0],r[2]):t!=E&&t!=(x|E)||r[4].length?cr.apply(w,r):sr.apply(w,r),r)}function _r(n,t,r,e,u,o,i){var f=-1,a=n.length,c=t.length,l=true;if(a!=c&&(!u||c<=a))return false;for(;l&&++f<a;){var s=n[f],p=t[f],l=w;if(e&&(l=u?e(p,s,f):e(s,p,f)),
    l===w)if(u)for(var h=c;h--&&(p=t[h],!(l=s&&s===p||r(s,p,e,u,o,i))););else l=s&&s===p||r(s,p,e,u,o,i)}return!!l}function vr(n,t,r){switch(r){case D:case P:return+n==+t;case q:return n.name==t.name&&n.message==t.message;case V:return n!=+n?t!=+t:n==+t;case Z:case G:return n==t+""}return false}function gr(n,t,r,e,u,o,i){var f=Ko(n),a=f.length,c=Ko(t).length;if(a!=c&&!u)return false;for(var c=u,l=-1;++l<a;){var s=f[l],p=u?s in t:Ge.call(t,s);if(p){var h=n[s],_=t[s],p=w;e&&(p=u?e(_,h,s):e(h,_,s)),p===w&&(p=h&&h===_||r(h,_,e,u,o,i));

}if(!p)return false;c||(c="constructor"==s)}return c||(r=n.constructor,e=t.constructor,!(r!=e&&"constructor"in n&&"constructor"in t)||typeof r=="function"&&r instanceof r&&typeof e=="function"&&e instanceof e)?true:false}function yr(n,t,r){var e=r?Iu:Eu,u=e,o=u;return zu(n,function(n,i,f){i=t(n,i,f),((r?i<u:i>u)||i===e&&i===o)&&(u=i,o=n)}),o}function dr(n,t,r){var e=$n.callback||Ee,e=e===Ee?ut:e;return r?e(n,t,r):e}function mr(n,t,e){var u=$n.indexOf||Dr,u=u===Dr?r:u;return n?u(n,t,e):u}function wr(n){var t=n.length,r=new n.constructor(t);

    return t&&"string"==typeof n[0]&&Ge.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function br(n){return n=n.constructor,typeof n=="function"&&n instanceof n||(n=Be),new n}function xr(n,t,r){var e=n.constructor;switch(t){case J:return Bt(n);case D:case P:return new e(+n);case X:case H:case Q:case nn:case tn:case rn:case en:case un:case on:return t=n.buffer,new e(r?Bt(t):t,n.byteOffset,n.length);case V:case G:return new e(n);case Z:var u=new e(n.source,kn.exec(n));u.lastIndex=n.lastIndex}return u;

}function Ar(n,t,r){return null==n||Er(t,n)||(t=$r(t),n=1==t.length?n:gt(n,It(t,0,-1)),t=Pr(t)),t=null==n?n:n[t],null==t?w:t.apply(n,r)}function jr(n){return null!=n&&Rr(Yu(n))}function kr(n,t){return n=+n,t=null==t?Tu:t,-1<n&&0==n%1&&n<t}function Or(n,t,r){if(!se(r))return false;var e=typeof t;return("number"==e?jr(r)&&kr(t,r.length):"string"==e&&t in r)?(t=r[t],n===n?n===t:t!==t):false}function Er(n,t){var r=typeof n;return"string"==r&&dn.test(n)||"number"==r?true:To(n)?false:!yn.test(n)||null!=t&&n in Fr(t);

}function Ir(n){var t=Vu(n);return!!t&&n===$n[t]&&t in Bn.prototype}function Rr(n){return typeof n=="number"&&-1<n&&0==n%1&&n<=Tu}function Cr(n){return n===n&&!se(n)}function Wr(n,t){n=Fr(n);for(var r=-1,e=t.length,u={};++r<e;){var o=t[r];o in n&&(u[o]=n[o])}return u}function Sr(n,t){var r={};return pt(n,function(n,e,u){t(n,e,u)&&(r[e]=n)}),r}function Tr(n){var t;if(!h(n)||Xe.call(n)!=Y||!(Ge.call(n,"constructor")||(t=n.constructor,typeof t!="function"||t instanceof t)))return false;var r;return pt(n,function(n,t){
    r=t}),r===w||Ge.call(n,r)}function Ur(n){for(var t=me(n),r=t.length,e=r&&n.length,u=$n.support,u=e&&Rr(e)&&(To(n)||u.nonEnumArgs&&ae(n)),o=-1,i=[];++o<r;){var f=t[o];(u&&kr(f,e)||Ge.call(n,f))&&i.push(f)}return i}function Nr(n){return null==n?[]:jr(n)?se(n)?n:Be(n):we(n)}function Fr(n){return se(n)?n:Be(n)}function $r(n){if(To(n))return n;var t=[];return u(n).replace(mn,function(n,r,e,u){t.push(e?u.replace(An,"$1"):r||n)}),t}function Lr(n){return n instanceof Bn?n.clone():new zn(n.__wrapped__,n.__chain__,qn(n.__actions__));

}function zr(n,t,r){return n&&n.length?((r?Or(n,t,r):null==t)&&(t=1),It(n,0>t?0:t)):[]}function Br(n,t,r){var e=n?n.length:0;return e?((r?Or(n,t,r):null==t)&&(t=1),t=e-(+t||0),It(n,0,0>t?0:t)):[]}function Mr(n){return n?n[0]:w}function Dr(n,t,e){var u=n?n.length:0;if(!u)return-1;if(typeof e=="number")e=0>e?bu(u+e,0):e;else if(e)return e=$t(n,t),n=n[e],(t===t?t===n:n!==n)?e:-1;return r(n,t,e||0)}function Pr(n){var t=n?n.length:0;return t?n[t-1]:w}function qr(n){return zr(n,1)}function Kr(n,t,e,u){
    if(!n||!n.length)return[];null!=t&&typeof t!="boolean"&&(u=e,e=Or(n,t,u)?null:t,t=false);var o=dr();if((o!==ut||null!=e)&&(e=o(e,u,3)),t&&mr()==r){t=e;var i;e=-1,u=n.length;for(var o=-1,f=[];++e<u;){var a=n[e],c=t?t(a,e,n):a;e&&i===c||(i=c,f[++o]=a)}n=f}else n=Tt(n,e);return n}function Vr(n){if(!n||!n.length)return[];var t=-1,r=0;n=Gn(n,function(n){return jr(n)?(r=bu(n.length,r),true):void 0});for(var e=Ue(r);++t<r;)e[t]=Jn(n,At(t));return e}function Yr(n,t,r){return n&&n.length?(n=Vr(n),null==t?n:(t=zt(t,r,4),
    Jn(n,function(n){return Xn(n,t,w,true)}))):[]}function Zr(n,t){var r=-1,e=n?n.length:0,u={};for(!e||t||To(n[0])||(t=[]);++r<e;){var o=n[r];t?u[o]=t[r]:o&&(u[o[0]]=o[1])}return u}function Gr(n){return n=$n(n),n.__chain__=true,n}function Jr(n,t,r){return t.call(r,n)}function Xr(n,t,r){var e=To(n)?Vn:at;return r&&Or(n,t,r)&&(t=null),(typeof t!="function"||r!==w)&&(t=dr(t,r,3)),e(n,t)}function Hr(n,t,r){var e=To(n)?Gn:ct;return t=dr(t,r,3),e(n,t)}function Qr(n,t,r,e){var u=n?Yu(n):0;return Rr(u)||(n=we(n),
    u=n.length),u?(r=typeof r!="number"||e&&Or(t,r,e)?0:0>r?bu(u+r,0):r||0,typeof n=="string"||!To(n)&&ve(n)?r<u&&-1<n.indexOf(t,r):-1<mr(n,t,r)):false}function ne(n,t,r){var e=To(n)?Jn:mt;return t=dr(t,r,3),e(n,t)}function te(n,t,r){return(r?Or(n,t,r):null==t)?(n=Nr(n),t=n.length,0<t?n[Ot(0,t-1)]:w):(n=re(n),n.length=xu(0>t?0:+t||0,n.length),n)}function re(n){n=Nr(n);for(var t=-1,r=n.length,e=Ue(r);++t<r;){var u=Ot(0,t);t!=u&&(e[t]=e[u]),e[u]=n[t]}return e}function ee(n,t,r){var e=To(n)?Hn:Rt;return r&&Or(n,t,r)&&(t=null),
(typeof t!="function"||r!==w)&&(t=dr(t,r,3)),e(n,t)}function ue(n,t){var r;if(typeof t!="function"){if(typeof n!="function")throw new Pe(L);var e=n;n=t,t=e}return function(){return 0<--n&&(r=t.apply(this,arguments)),1>=n&&(t=null),r}}function oe(n,t,r){function e(){var r=t-(wo()-c);0>=r||r>t?(f&&eu(f),r=p,f=s=p=w,r&&(h=wo(),a=n.apply(l,i),s||f||(i=l=null))):s=su(e,r)}function u(){s&&eu(s),f=s=p=w,(v||_!==t)&&(h=wo(),a=n.apply(l,i),s||f||(i=l=null))}function o(){if(i=arguments,c=wo(),l=this,p=v&&(s||!g),
    !1===_)var r=g&&!s;else{f||g||(h=c);var o=_-(c-h),y=0>=o||o>_;y?(f&&(f=eu(f)),h=c,a=n.apply(l,i)):f||(f=su(u,o))}return y&&s?s=eu(s):s||t===_||(s=su(e,t)),r&&(y=true,a=n.apply(l,i)),!y||s||f||(i=l=null),a}var i,f,a,c,l,s,p,h=0,_=false,v=true;if(typeof n!="function")throw new Pe(L);if(t=0>t?0:+t||0,true===r)var g=true,v=false;else se(r)&&(g=r.leading,_="maxWait"in r&&bu(+r.maxWait||0,t),v="trailing"in r?r.trailing:v);return o.cancel=function(){s&&eu(s),f&&eu(f),f=s=p=w},o}function ie(n,t){function r(){var e=arguments,u=r.cache,o=t?t.apply(this,e):e[0];

    return u.has(o)?u.get(o):(e=n.apply(this,e),u.set(o,e),e)}if(typeof n!="function"||t&&typeof t!="function")throw new Pe(L);return r.cache=new ie.Cache,r}function fe(n,t){if(typeof n!="function")throw new Pe(L);return t=bu(t===w?n.length-1:+t||0,0),function(){for(var r=arguments,e=-1,u=bu(r.length-t,0),o=Ue(u);++e<u;)o[e]=r[t+e];switch(t){case 0:return n.call(this,o);case 1:return n.call(this,r[0],o);case 2:return n.call(this,r[0],r[1],o)}for(u=Ue(t+1),e=-1;++e<t;)u[e]=r[e];return u[t]=o,n.apply(this,u);

}}function ae(n){return h(n)&&jr(n)&&Xe.call(n)==B}function ce(n){return!!n&&1===n.nodeType&&h(n)&&-1<Xe.call(n).indexOf("Element")}function le(n){return h(n)&&typeof n.message=="string"&&Xe.call(n)==q}function se(n){var t=typeof n;return"function"==t||!!n&&"object"==t}function pe(n){return null==n?false:Xe.call(n)==K?Qe.test(Ze.call(n)):h(n)&&En.test(n)}function he(n){return typeof n=="number"||h(n)&&Xe.call(n)==V}function _e(n){return h(n)&&Xe.call(n)==Z}function ve(n){return typeof n=="string"||h(n)&&Xe.call(n)==G;

}function ge(n){return h(n)&&Rr(n.length)&&!!Un[Xe.call(n)]}function ye(n){return et(n,me(n))}function de(n){return vt(n,me(n))}function me(n){if(null==n)return[];se(n)||(n=Be(n));for(var t=n.length,t=t&&Rr(t)&&(To(n)||Fu.nonEnumArgs&&ae(n))&&t||0,r=n.constructor,e=-1,r=typeof r=="function"&&r.prototype===n,u=Ue(t),o=0<t;++e<t;)u[e]=e+"";for(var i in n)o&&kr(i,t)||"constructor"==i&&(r||!Ge.call(n,i))||u.push(i);return u}function we(n){return Ut(n,Ko(n))}function be(n){return(n=u(n))&&n.replace(In,c).replace(xn,"");

}function xe(n){return(n=u(n))&&bn.test(n)?n.replace(wn,"\\$&"):n}function Ae(n,t,r){return r&&Or(n,t,r)&&(t=0),ku(n,t)}function je(n,t){var r="";if(n=u(n),t=+t,1>t||!n||!mu(t))return r;do t%2&&(r+=n),t=uu(t/2),n+=n;while(t);return r}function ke(n,t,r){var e=n;return(n=u(n))?(r?Or(e,t,r):null==t)?n.slice(g(n),y(n)+1):(t+="",n.slice(i(n,t),f(n,t)+1)):n}function Oe(n,t,r){return r&&Or(n,t,r)&&(t=null),n=u(n),n.match(t||Wn)||[]}function Ee(n,t,r){return r&&Or(n,t,r)&&(t=null),h(n)?Ce(n):ut(n,t)}function Ie(n){
    return function(){return n}}function Re(n){return n}function Ce(n){return wt(ot(n,true))}function We(n,t,r){if(null==r){var e=se(t),u=e&&Ko(t);((u=u&&u.length&&vt(t,u))?u.length:e)||(u=false,r=t,t=n,n=this)}u||(u=vt(t,Ko(t)));var o=true,e=-1,i=No(n),f=u.length;false===r?o=false:se(r)&&"chain"in r&&(o=r.chain);for(;++e<f;){r=u[e];var a=t[r];n[r]=a,i&&(n.prototype[r]=function(t){return function(){var r=this.__chain__;if(o||r){var e=n(this.__wrapped__);return(e.__actions__=qn(this.__actions__)).push({func:t,args:arguments,
    thisArg:n}),e.__chain__=r,e}return r=[this.value()],fu.apply(r,arguments),t.apply(n,r)}}(a))}return n}function Se(){}function Te(n){return Er(n)?At(n):jt(n)}_=_?Zn.defaults(Yn.Object(),_,Zn.pick(Yn,Tn)):Yn;var Ue=_.Array,Ne=_.Date,Fe=_.Error,$e=_.Function,Le=_.Math,ze=_.Number,Be=_.Object,Me=_.RegExp,De=_.String,Pe=_.TypeError,qe=Ue.prototype,Ke=Be.prototype,Ve=De.prototype,Ye=(Ye=_.window)&&Ye.document,Ze=$e.prototype.toString,Ge=Ke.hasOwnProperty,Je=0,Xe=Ke.toString,He=_._,Qe=Me("^"+xe(Xe).replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),nu=pe(nu=_.ArrayBuffer)&&nu,tu=pe(tu=nu&&new nu(0).slice)&&tu,ru=Le.ceil,eu=_.clearTimeout,uu=Le.floor,ou=pe(ou=Be.getOwnPropertySymbols)&&ou,iu=pe(iu=Be.getPrototypeOf)&&iu,fu=qe.push,au=pe(au=Be.preventExtensions)&&au,cu=Ke.propertyIsEnumerable,lu=pe(lu=_.Set)&&lu,su=_.setTimeout,pu=qe.splice,hu=pe(hu=_.Uint8Array)&&hu,_u=pe(_u=_.WeakMap)&&_u,vu=function(){
    try{var n=pe(n=_.Float64Array)&&n,t=new n(new nu(10),0,1)&&n}catch(r){}return t}(),gu=function(){var n=au&&pe(n=Be.assign)&&n;try{if(n){var t=au({1:0});t[0]=1}}catch(r){try{n(t,"xo")}catch(e){}return!t[1]&&n}return false}(),yu=pe(yu=Ue.isArray)&&yu,du=pe(du=Be.create)&&du,mu=_.isFinite,wu=pe(wu=Be.keys)&&wu,bu=Le.max,xu=Le.min,Au=pe(Au=Ne.now)&&Au,ju=pe(ju=ze.isFinite)&&ju,ku=_.parseInt,Ou=Le.random,Eu=ze.NEGATIVE_INFINITY,Iu=ze.POSITIVE_INFINITY,Ru=Le.pow(2,32)-1,Cu=Ru-1,Wu=Ru>>>1,Su=vu?vu.BYTES_PER_ELEMENT:0,Tu=Le.pow(2,53)-1,Uu=_u&&new _u,Nu={},Fu=$n.support={};

    !function(n){function t(){this.x=n}var r=arguments,e=[];t.prototype={valueOf:n,y:n};for(var u in new t)e.push(u);Fu.funcDecomp=/\bthis\b/.test(function(){return this}),Fu.funcNames=typeof $e.name=="string";try{Fu.dom=11===Ye.createDocumentFragment().nodeType}catch(o){Fu.dom=false}try{Fu.nonEnumArgs=!cu.call(r,1)}catch(i){Fu.nonEnumArgs=true}}(1,0),$n.templateSettings={escape:_n,evaluate:vn,interpolate:gn,variable:"",imports:{_:$n}};var $u=gu||function(n,t){return null==t?n:et(t,Zu(t),et(t,Ko(t),n))},Lu=function(){
        function n(){}return function(t){if(se(t)){n.prototype=t;var r=new n;n.prototype=null}return r||_.Object()}}(),zu=Kt(ht),Bu=Kt(_t,true),Mu=Vt(),Du=Vt(true),Pu=Uu?function(n,t){return Uu.set(n,t),n}:Re;tu||(Bt=nu&&hu?function(n){var t=n.byteLength,r=vu?uu(t/Su):0,e=r*Su,u=new nu(t);if(r){var o=new vu(u,0,r);o.set(new vu(n,0,r))}return t!=e&&(o=new hu(u,e),o.set(new hu(n,e))),u}:Ie(null));var qu=du&&lu?function(n){return new Dn(n)}:Ie(null),Ku=Uu?function(n){return Uu.get(n)}:Se,Vu=function(){return Fu.funcNames?"constant"==Ie.name?At("name"):function(n){
        for(var t=n.name,r=Nu[t],e=r?r.length:0;e--;){var u=r[e],o=u.func;if(null==o||o==n)return u.name}return t}:Ie("")}(),Yu=At("length"),Zu=ou?function(n){return ou(Fr(n))}:Ie([]),Gu=function(){var n=0,t=0;return function(r,e){var u=wo(),o=U-(u-t);if(t=u,0<o){if(++n>=T)return r}else n=0;return Pu(r,e)}}(),Ju=fe(function(n,t){return jr(n)?ft(n,st(t,false,true)):[]}),Xu=Qt(),Hu=Qt(true),Qu=fe(function(t,r){r=st(r);var e=rt(t,r);return kt(t,r.sort(n)),e}),no=pr(),to=pr(true),ro=fe(function(n){return Tt(st(n,false,true));

    }),eo=fe(function(n,t){return jr(n)?ft(n,t):[]}),uo=fe(Vr),oo=fe(function(n){var t=n.length,r=n[t-2],e=n[t-1];return 2<t&&typeof r=="function"?t-=2:(r=1<t&&typeof e=="function"?(--t,e):w,e=w),n.length=t,Yr(n,r,e)}),io=fe(function(n,t){return rt(n,st(t))}),fo=Pt(function(n,t,r){Ge.call(n,r)?++n[r]:n[r]=1}),ao=Ht(zu),co=Ht(Bu,true),lo=rr(Kn,zu),so=rr(function(n,t){for(var r=n.length;r--&&false!==t(n[r],r,n););return n},Bu),po=Pt(function(n,t,r){Ge.call(n,r)?n[r].push(t):n[r]=[t]}),ho=Pt(function(n,t,r){
        n[r]=t}),_o=fe(function(n,t,r){var e=-1,u=typeof t=="function",o=Er(t),i=jr(n)?Ue(n.length):[];return zu(n,function(n){var f=u?t:o&&null!=n&&n[t];i[++e]=f?f.apply(n,r):Ar(n,t,r)}),i}),vo=Pt(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),go=ar(Xn,zu),yo=ar(function(n,t,r,e){var u=n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r},Bu),mo=fe(function(n,t){if(null==n)return[];var r=t[2];return r&&Or(t[0],t[1],r)&&(t.length=1),Wt(n,st(t),[])}),wo=Au||function(){return(new Ne).getTime();

        },bo=fe(function(n,t,r){var e=x;if(r.length)var u=v(r,bo.placeholder),e=e|E;return hr(n,e,t,r,u)}),xo=fe(function(n,t){t=t.length?st(t):de(n);for(var r=-1,e=t.length;++r<e;){var u=t[r];n[u]=hr(n[u],x,n)}return n}),Ao=fe(function(n,t,r){var e=x|A;if(r.length)var u=v(r,Ao.placeholder),e=e|E;return hr(t,e,n,r,u)}),jo=Jt(k),ko=Jt(O),Oo=fe(function(n,t){return it(n,1,t)}),Eo=fe(function(n,t,r){return it(n,t,r)}),Io=tr(),Ro=tr(true),Co=fr(E),Wo=fr(I),So=fe(function(n,t){return hr(n,C,null,null,null,st(t));

    }),To=yu||function(n){return h(n)&&Rr(n.length)&&Xe.call(n)==M};Fu.dom||(ce=function(n){return!!n&&1===n.nodeType&&h(n)&&!Fo(n)});var Uo=ju||function(n){return typeof n=="number"&&mu(n)},No=e(/x/)||hu&&!e(hu)?function(n){return Xe.call(n)==K}:e,Fo=iu?function(n){if(!n||Xe.call(n)!=Y)return false;var t=n.valueOf,r=pe(t)&&(r=iu(t))&&iu(r);return r?n==r||iu(n)==r:Tr(n)}:Tr,$o=qt(function(n,t,r){return r?tt(n,t,r):$u(n,t)}),Lo=fe(function(n){var t=n[0];return null==t?t:(n.push(Qn),$o.apply(w,n))}),zo=nr(ht),Bo=nr(_t),Mo=er(Mu),Do=er(Du),Po=ur(ht),qo=ur(_t),Ko=wu?function(n){
        var t=null!=n&&n.constructor;return typeof t=="function"&&t.prototype===n||typeof n!="function"&&jr(n)?Ur(n):se(n)?wu(n):[]}:Ur,Vo=or(true),Yo=or(),Zo=qt(xt),Go=fe(function(n,t){if(null==n)return{};if("function"!=typeof t[0])return t=Jn(st(t),De),Wr(n,ft(me(n),t));var r=zt(t[0],t[1],3);return Sr(n,function(n,t,e){return!r(n,t,e)})}),Jo=fe(function(n,t){return null==n?{}:"function"==typeof t[0]?Sr(n,zt(t[0],t[1],3)):Wr(n,st(t))}),Xo=Zt(function(n,t,r){return t=t.toLowerCase(),n+(r?t.charAt(0).toUpperCase()+t.slice(1):t);

    }),Ho=Zt(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Qo=ir(),ni=ir(true);8!=ku(Sn+"08")&&(Ae=function(n,t,r){return(r?Or(n,t,r):null==t)?t=0:t&&(t=+t),n=ke(n),ku(n,t||(On.test(n)?16:10))});var ti=Zt(function(n,t,r){return n+(r?"_":"")+t.toLowerCase()}),ri=Zt(function(n,t,r){return n+(r?" ":"")+(t.charAt(0).toUpperCase()+t.slice(1))}),ei=fe(function(n,t){try{return n.apply(w,t)}catch(r){return le(r)?r:new Fe(r)}}),ui=fe(function(n,t){return function(r){return Ar(r,n,t)}}),oi=fe(function(n,t){
        return function(r){return Ar(n,r,t)}}),ii=Xt(function(n){for(var t=-1,r=n.length,e=Eu;++t<r;){var u=n[t];u>e&&(e=u)}return e}),fi=Xt(function(n){for(var t=-1,r=n.length,e=Iu;++t<r;){var u=n[t];u<e&&(e=u)}return e},true);return $n.prototype=Ln.prototype,zn.prototype=Lu(Ln.prototype),zn.prototype.constructor=zn,Bn.prototype=Lu(Ln.prototype),Bn.prototype.constructor=Bn,Mn.prototype["delete"]=function(n){return this.has(n)&&delete this.__data__[n]},Mn.prototype.get=function(n){return"__proto__"==n?w:this.__data__[n];

    },Mn.prototype.has=function(n){return"__proto__"!=n&&Ge.call(this.__data__,n)},Mn.prototype.set=function(n,t){return"__proto__"!=n&&(this.__data__[n]=t),this},Dn.prototype.push=function(n){var t=this.data;typeof n=="string"||se(n)?t.set.add(n):t.hash[n]=true},ie.Cache=Mn,$n.after=function(n,t){if(typeof t!="function"){if(typeof n!="function")throw new Pe(L);var r=n;n=t,t=r}return n=mu(n=+n)?n:0,function(){return 1>--n?t.apply(this,arguments):void 0}},$n.ary=function(n,t,r){return r&&Or(n,t,r)&&(t=null),
        t=n&&null==t?n.length:bu(+t||0,0),hr(n,R,null,null,null,null,t)},$n.assign=$o,$n.at=io,$n.before=ue,$n.bind=bo,$n.bindAll=xo,$n.bindKey=Ao,$n.callback=Ee,$n.chain=Gr,$n.chunk=function(n,t,r){t=(r?Or(n,t,r):null==t)?1:bu(+t||1,1),r=0;for(var e=n?n.length:0,u=-1,o=Ue(ru(e/t));r<e;)o[++u]=It(n,r,r+=t);return o},$n.compact=function(n){for(var t=-1,r=n?n.length:0,e=-1,u=[];++t<r;){var o=n[t];o&&(u[++e]=o)}return u},$n.constant=Ie,$n.countBy=fo,$n.create=function(n,t,r){var e=Lu(n);return r&&Or(n,t,r)&&(t=null),
        t?$u(e,t):e},$n.curry=jo,$n.curryRight=ko,$n.debounce=oe,$n.defaults=Lo,$n.defer=Oo,$n.delay=Eo,$n.difference=Ju,$n.drop=zr,$n.dropRight=Br,$n.dropRightWhile=function(n,t,r){return n&&n.length?Nt(n,dr(t,r,3),true,true):[]},$n.dropWhile=function(n,t,r){return n&&n.length?Nt(n,dr(t,r,3),true):[]},$n.fill=function(n,t,r,e){var u=n?n.length:0;if(!u)return[];for(r&&typeof r!="number"&&Or(n,t,r)&&(r=0,e=u),u=n.length,r=null==r?0:+r||0,0>r&&(r=-r>u?0:u+r),e=e===w||e>u?u:+e||0,0>e&&(e+=u),u=r>e?0:e>>>0,r>>>=0;r<u;)n[r++]=t;

        return n},$n.filter=Hr,$n.flatten=function(n,t,r){var e=n?n.length:0;return r&&Or(n,t,r)&&(t=false),e?st(n,t):[]},$n.flattenDeep=function(n){return n&&n.length?st(n,true):[]},$n.flow=Io,$n.flowRight=Ro,$n.forEach=lo,$n.forEachRight=so,$n.forIn=Mo,$n.forInRight=Do,$n.forOwn=Po,$n.forOwnRight=qo,$n.functions=de,$n.groupBy=po,$n.indexBy=ho,$n.initial=function(n){return Br(n,1)},$n.intersection=function(){for(var n=[],t=-1,e=arguments.length,u=[],o=mr(),i=o==r,f=[];++t<e;){var a=arguments[t];jr(a)&&(n.push(a),
        u.push(i&&120<=a.length?qu(t&&a):null))}if(e=n.length,2>e)return f;var i=n[0],c=-1,l=i?i.length:0,s=u[0];n:for(;++c<l;)if(a=i[c],0>(s?Pn(s,a):o(f,a,0))){for(t=e;--t;){var p=u[t];if(0>(p?Pn(p,a):o(n[t],a,0)))continue n}s&&s.push(a),f.push(a)}return f},$n.invert=function(n,t,r){r&&Or(n,t,r)&&(t=null),r=-1;for(var e=Ko(n),u=e.length,o={};++r<u;){var i=e[r],f=n[i];t?Ge.call(o,f)?o[f].push(i):o[f]=[i]:o[f]=i}return o},$n.invoke=_o,$n.keys=Ko,$n.keysIn=me,$n.map=ne,$n.mapKeys=Vo,$n.mapValues=Yo,$n.matches=Ce,
        $n.matchesProperty=function(n,t){return bt(n,ot(t,true))},$n.memoize=ie,$n.merge=Zo,$n.method=ui,$n.methodOf=oi,$n.mixin=We,$n.negate=function(n){if(typeof n!="function")throw new Pe(L);return function(){return!n.apply(this,arguments)}},$n.omit=Go,$n.once=function(n){return ue(2,n)},$n.pairs=function(n){for(var t=-1,r=Ko(n),e=r.length,u=Ue(e);++t<e;){var o=r[t];u[t]=[o,n[o]]}return u},$n.partial=Co,$n.partialRight=Wo,$n.partition=vo,$n.pick=Jo,$n.pluck=function(n,t){return ne(n,Te(t))},$n.property=Te,
        $n.propertyOf=function(n){return function(t){return gt(n,$r(t),t+"")}},$n.pull=function(){var n=arguments,t=n[0];if(!t||!t.length)return t;for(var r=0,e=mr(),u=n.length;++r<u;)for(var o=0,i=n[r];-1<(o=e(t,i,o));)pu.call(t,o,1);return t},$n.pullAt=Qu,$n.range=function(n,t,r){r&&Or(n,t,r)&&(t=r=null),n=+n||0,r=null==r?1:+r||0,null==t?(t=n,n=0):t=+t||0;var e=-1;t=bu(ru((t-n)/(r||1)),0);for(var u=Ue(t);++e<t;)u[e]=n,n+=r;return u},$n.rearg=So,$n.reject=function(n,t,r){var e=To(n)?Gn:ct;return t=dr(t,r,3),
        e(n,function(n,r,e){return!t(n,r,e)})},$n.remove=function(n,t,r){var e=[];if(!n||!n.length)return e;var u=-1,o=[],i=n.length;for(t=dr(t,r,3);++u<i;)r=n[u],t(r,u,n)&&(e.push(r),o.push(u));return kt(n,o),e},$n.rest=qr,$n.restParam=fe,$n.set=function(n,t,r){if(null==n)return n;var e=t+"";t=null!=n[e]||Er(t,n)?[e]:$r(t);for(var e=-1,u=t.length,o=u-1,i=n;null!=i&&++e<u;){var f=t[e];se(i)&&(e==o?i[f]=r:null==i[f]&&(i[f]=kr(t[e+1])?[]:{})),i=i[f]}return n},$n.shuffle=re,$n.slice=function(n,t,r){var e=n?n.length:0;

        return e?(r&&typeof r!="number"&&Or(n,t,r)&&(t=0,r=e),It(n,t,r)):[]},$n.sortBy=function(n,t,r){if(null==n)return[];r&&Or(n,t,r)&&(t=null);var e=-1;return t=dr(t,r,3),n=mt(n,function(n,r,u){return{a:t(n,r,u),b:++e,c:n}}),Ct(n,a)},$n.sortByAll=mo,$n.sortByOrder=function(n,t,r,e){return null==n?[]:(e&&Or(t,r,e)&&(r=null),To(t)||(t=null==t?[]:[t]),To(r)||(r=null==r?[]:[r]),Wt(n,t,r))},$n.spread=function(n){if(typeof n!="function")throw new Pe(L);return function(t){return n.apply(this,t)}},$n.take=function(n,t,r){
        return n&&n.length?((r?Or(n,t,r):null==t)&&(t=1),It(n,0,0>t?0:t)):[]},$n.takeRight=function(n,t,r){var e=n?n.length:0;return e?((r?Or(n,t,r):null==t)&&(t=1),t=e-(+t||0),It(n,0>t?0:t)):[]},$n.takeRightWhile=function(n,t,r){return n&&n.length?Nt(n,dr(t,r,3),false,true):[]},$n.takeWhile=function(n,t,r){return n&&n.length?Nt(n,dr(t,r,3)):[]},$n.tap=function(n,t,r){return t.call(r,n),n},$n.throttle=function(n,t,r){var e=true,u=true;if(typeof n!="function")throw new Pe(L);return false===r?e=false:se(r)&&(e="leading"in r?!!r.leading:e,
        u="trailing"in r?!!r.trailing:u),Fn.leading=e,Fn.maxWait=+t,Fn.trailing=u,oe(n,t,Fn)},$n.thru=Jr,$n.times=function(n,t,r){if(n=uu(n),1>n||!mu(n))return[];var e=-1,u=Ue(xu(n,Ru));for(t=zt(t,r,1);++e<n;)e<Ru?u[e]=t(e):t(e);return u},$n.toArray=function(n){var t=n?Yu(n):0;return Rr(t)?t?qn(n):[]:we(n)},$n.toPlainObject=ye,$n.transform=function(n,t,r,e){var u=To(n)||ge(n);return t=dr(t,e,4),null==r&&(u||se(n)?(e=n.constructor,r=u?To(n)?new e:[]:Lu(No(e)&&e.prototype)):r={}),(u?Kn:ht)(n,function(n,e,u){
        return t(r,n,e,u)}),r},$n.union=ro,$n.uniq=Kr,$n.unzip=Vr,$n.unzipWith=Yr,$n.values=we,$n.valuesIn=function(n){return Ut(n,me(n))},$n.where=function(n,t){return Hr(n,wt(t))},$n.without=eo,$n.wrap=function(n,t){return t=null==t?Re:t,hr(t,E,null,[n],[])},$n.xor=function(){for(var n=-1,t=arguments.length;++n<t;){var r=arguments[n];if(jr(r))var e=e?ft(e,r).concat(ft(r,e)):r}return e?Tt(e):[]},$n.zip=uo,$n.zipObject=Zr,$n.zipWith=oo,$n.backflow=Ro,$n.collect=ne,$n.compose=Ro,$n.each=lo,$n.eachRight=so,
        $n.extend=$o,$n.iteratee=Ee,$n.methods=de,$n.object=Zr,$n.select=Hr,$n.tail=qr,$n.unique=Kr,We($n,$n),$n.add=function(n,t){return(+n||0)+(+t||0)},$n.attempt=ei,$n.camelCase=Xo,$n.capitalize=function(n){return(n=u(n))&&n.charAt(0).toUpperCase()+n.slice(1)},$n.clone=function(n,t,r,e){return t&&typeof t!="boolean"&&Or(n,t,r)?t=false:typeof t=="function"&&(e=r,r=t,t=false),r=typeof r=="function"&&zt(r,e,1),ot(n,t,r)},$n.cloneDeep=function(n,t,r){return t=typeof t=="function"&&zt(t,r,1),ot(n,true,t)},$n.deburr=be,
        $n.endsWith=function(n,t,r){n=u(n),t+="";var e=n.length;return r=r===w?e:xu(0>r?0:+r||0,e),r-=t.length,0<=r&&n.indexOf(t,r)==r},$n.escape=function(n){return(n=u(n))&&hn.test(n)?n.replace(sn,l):n},$n.escapeRegExp=xe,$n.every=Xr,$n.find=ao,$n.findIndex=Xu,$n.findKey=zo,$n.findLast=co,$n.findLastIndex=Hu,$n.findLastKey=Bo,$n.findWhere=function(n,t){return ao(n,wt(t))},$n.first=Mr,$n.get=function(n,t,r){return n=null==n?w:gt(n,$r(t),t+""),n===w?r:n},$n.has=function(n,t){if(null==n)return false;var r=Ge.call(n,t);

            return r||Er(t)||(t=$r(t),n=1==t.length?n:gt(n,It(t,0,-1)),t=Pr(t),r=null!=n&&Ge.call(n,t)),r},$n.identity=Re,$n.includes=Qr,$n.indexOf=Dr,$n.inRange=function(n,t,r){return t=+t||0,"undefined"===typeof r?(r=t,t=0):r=+r||0,n>=xu(t,r)&&n<bu(t,r)},$n.isArguments=ae,$n.isArray=To,$n.isBoolean=function(n){return true===n||false===n||h(n)&&Xe.call(n)==D},$n.isDate=function(n){return h(n)&&Xe.call(n)==P},$n.isElement=ce,$n.isEmpty=function(n){return null==n?true:jr(n)&&(To(n)||ve(n)||ae(n)||h(n)&&No(n.splice))?!n.length:!Ko(n).length;

        },$n.isEqual=function(n,t,r,e){return r=typeof r=="function"&&zt(r,e,3),!r&&Cr(n)&&Cr(t)?n===t:(e=r?r(n,t):w,e===w?yt(n,t,r):!!e)},$n.isError=le,$n.isFinite=Uo,$n.isFunction=No,$n.isMatch=function(n,t,r,e){var u=Ko(t),o=u.length;if(!o)return true;if(null==n)return false;if(r=typeof r=="function"&&zt(r,e,3),n=Fr(n),!r&&1==o){var i=u[0];if(e=t[i],Cr(e))return e===n[i]&&(e!==w||i in n)}for(var i=Ue(o),f=Ue(o);o--;)e=i[o]=t[u[o]],f[o]=Cr(e);return dt(n,u,i,f,r)},$n.isNaN=function(n){return he(n)&&n!=+n},$n.isNative=pe,
        $n.isNull=function(n){return null===n},$n.isNumber=he,$n.isObject=se,$n.isPlainObject=Fo,$n.isRegExp=_e,$n.isString=ve,$n.isTypedArray=ge,$n.isUndefined=function(n){return n===w},$n.kebabCase=Ho,$n.last=Pr,$n.lastIndexOf=function(n,t,r){var e=n?n.length:0;if(!e)return-1;var u=e;if(typeof r=="number")u=(0>r?bu(e+r,0):xu(r||0,e-1))+1;else if(r)return u=$t(n,t,true)-1,n=n[u],(t===t?t===n:n!==n)?u:-1;if(t!==t)return p(n,u,true);for(;u--;)if(n[u]===t)return u;return-1},$n.max=ii,$n.min=fi,$n.noConflict=function(){
            return _._=He,this},$n.noop=Se,$n.now=wo,$n.pad=function(n,t,r){n=u(n),t=+t;var e=n.length;return e<t&&mu(t)?(e=(t-e)/2,t=uu(e),e=ru(e),r=lr("",e,r),r.slice(0,t)+n+r):n},$n.padLeft=Qo,$n.padRight=ni,$n.parseInt=Ae,$n.random=function(n,t,r){r&&Or(n,t,r)&&(t=r=null);var e=null==n,u=null==t;return null==r&&(u&&typeof n=="boolean"?(r=n,n=1):typeof t=="boolean"&&(r=t,u=true)),e&&u&&(t=1,u=false),n=+n||0,u?(t=n,n=0):t=+t||0,r||n%1||t%1?(r=Ou(),xu(n+r*(t-n+parseFloat("1e-"+((r+"").length-1))),t)):Ot(n,t)},$n.reduce=go,
        $n.reduceRight=yo,$n.repeat=je,$n.result=function(n,t,r){var e=null==n?w:n[t];return e===w&&(null==n||Er(t,n)||(t=$r(t),n=1==t.length?n:gt(n,It(t,0,-1)),e=null==n?w:n[Pr(t)]),e=e===w?r:e),No(e)?e.call(n):e},$n.runInContext=m,$n.size=function(n){var t=n?Yu(n):0;return Rr(t)?t:Ko(n).length},$n.snakeCase=ti,$n.some=ee,$n.sortedIndex=no,$n.sortedLastIndex=to,$n.startCase=ri,$n.startsWith=function(n,t,r){return n=u(n),r=null==r?0:xu(0>r?0:+r||0,n.length),n.lastIndexOf(t,r)==r},$n.sum=function(n,t,r){r&&Or(n,t,r)&&(t=null);

            var e=dr(),u=null==t;if(e===ut&&u||(u=false,t=e(t,r,3)),u){for(n=To(n)?n:Nr(n),t=n.length,r=0;t--;)r+=+n[t]||0;n=r}else n=St(n,t);return n},$n.template=function(n,t,r){var e=$n.templateSettings;r&&Or(n,t,r)&&(t=r=null),n=u(n),t=tt($u({},r||t),e,nt),r=tt($u({},t.imports),e.imports,nt);var o,i,f=Ko(r),a=Ut(r,f),c=0;r=t.interpolate||Rn;var l="__p+='";r=Me((t.escape||Rn).source+"|"+r.source+"|"+(r===gn?jn:Rn).source+"|"+(t.evaluate||Rn).source+"|$","g");var p="sourceURL"in t?"//# sourceURL="+t.sourceURL+"\n":"";

            if(n.replace(r,function(t,r,e,u,f,a){return e||(e=u),l+=n.slice(c,a).replace(Cn,s),r&&(o=true,l+="'+__e("+r+")+'"),f&&(i=true,l+="';"+f+";\n__p+='"),e&&(l+="'+((__t=("+e+"))==null?'':__t)+'"),c=a+t.length,t}),l+="';",(t=t.variable)||(l="with(obj){"+l+"}"),l=(i?l.replace(fn,""):l).replace(an,"$1").replace(cn,"$1;"),l="function("+(t||"obj")+"){"+(t?"":"obj||(obj={});")+"var __t,__p=''"+(o?",__e=_.escape":"")+(i?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+l+"return __p}",
                    t=ei(function(){return $e(f,p+"return "+l).apply(w,a)}),t.source=l,le(t))throw t;return t},$n.trim=ke,$n.trimLeft=function(n,t,r){var e=n;return(n=u(n))?n.slice((r?Or(e,t,r):null==t)?g(n):i(n,t+"")):n},$n.trimRight=function(n,t,r){var e=n;return(n=u(n))?(r?Or(e,t,r):null==t)?n.slice(0,y(n)+1):n.slice(0,f(n,t+"")+1):n},$n.trunc=function(n,t,r){r&&Or(n,t,r)&&(t=null);var e=W;if(r=S,null!=t)if(se(t)){var o="separator"in t?t.separator:o,e="length"in t?+t.length||0:e;r="omission"in t?u(t.omission):r}else e=+t||0;

            if(n=u(n),e>=n.length)return n;if(e-=r.length,1>e)return r;if(t=n.slice(0,e),null==o)return t+r;if(_e(o)){if(n.slice(e).search(o)){var i,f=n.slice(0,e);for(o.global||(o=Me(o.source,(kn.exec(o)||"")+"g")),o.lastIndex=0;n=o.exec(f);)i=n.index;t=t.slice(0,null==i?e:i)}}else n.indexOf(o,e)!=e&&(o=t.lastIndexOf(o),-1<o&&(t=t.slice(0,o)));return t+r},$n.unescape=function(n){return(n=u(n))&&pn.test(n)?n.replace(ln,d):n},$n.uniqueId=function(n){var t=++Je;return u(n)+t},$n.words=Oe,$n.all=Xr,$n.any=ee,$n.contains=Qr,
        $n.detect=ao,$n.foldl=go,$n.foldr=yo,$n.head=Mr,$n.include=Qr,$n.inject=go,We($n,function(){var n={};return ht($n,function(t,r){$n.prototype[r]||(n[r]=t)}),n}(),false),$n.sample=te,$n.prototype.sample=function(n){return this.__chain__||null!=n?this.thru(function(t){return te(t,n)}):te(this.value())},$n.VERSION=b,Kn("bind bindKey curry curryRight partial partialRight".split(" "),function(n){$n[n].placeholder=$n}),Kn(["dropWhile","filter","map","takeWhile"],function(n,t){var r=t!=$,e=t==N;Bn.prototype[n]=function(n,u){
            var o=this.__filtered__,i=o&&e?new Bn(this):this.clone();return(i.__iteratees__||(i.__iteratees__=[])).push({done:false,count:0,index:0,iteratee:dr(n,u,1),limit:-1,type:t}),i.__filtered__=o||r,i}}),Kn(["drop","take"],function(n,t){var r=n+"While";Bn.prototype[n]=function(r){var e=this.__filtered__,u=e&&!t?this.dropWhile():this.clone();return r=null==r?1:bu(uu(r)||0,0),e?t?u.__takeCount__=xu(u.__takeCount__,r):Pr(u.__iteratees__).limit=r:(u.__views__||(u.__views__=[])).push({size:r,type:n+(0>u.__dir__?"Right":"")
        }),u},Bn.prototype[n+"Right"]=function(t){return this.reverse()[n](t).reverse()},Bn.prototype[n+"RightWhile"]=function(n,t){return this.reverse()[r](n,t).reverse()}}),Kn(["first","last"],function(n,t){var r="take"+(t?"Right":"");Bn.prototype[n]=function(){return this[r](1).value()[0]}}),Kn(["initial","rest"],function(n,t){var r="drop"+(t?"":"Right");Bn.prototype[n]=function(){return this[r](1)}}),Kn(["pluck","where"],function(n,t){var r=t?"filter":"map",e=t?wt:Te;Bn.prototype[n]=function(n){return this[r](e(n));

        }}),Bn.prototype.compact=function(){return this.filter(Re)},Bn.prototype.reject=function(n,t){return n=dr(n,t,1),this.filter(function(t){return!n(t)})},Bn.prototype.slice=function(n,t){n=null==n?0:+n||0;var r=this;return 0>n?r=this.takeRight(-n):n&&(r=this.drop(n)),t!==w&&(t=+t||0,r=0>t?r.dropRight(-t):r.take(t-n)),r},Bn.prototype.toArray=function(){return this.drop(0)},ht(Bn.prototype,function(n,t){var r=$n[t];if(r){var e=/^(?:filter|map|reject)|While$/.test(t),u=/^(?:first|last)$/.test(t);$n.prototype[t]=function(){
            function t(n){return n=[n],fu.apply(n,o),r.apply($n,n)}var o=arguments,i=this.__chain__,f=this.__wrapped__,a=!!this.__actions__.length,c=f instanceof Bn,l=o[0],s=c||To(f);return s&&e&&typeof l=="function"&&1!=l.length&&(c=s=false),c=c&&!a,u&&!i?c?n.call(f):r.call($n,this.value()):s?(f=n.apply(c?f:new Bn(this),o),u||!a&&!f.__actions__||(f.__actions__||(f.__actions__=[])).push({func:Jr,args:[t],thisArg:$n}),new zn(f,i)):this.thru(t)}}}),Kn("concat join pop push replace shift sort splice split unshift".split(" "),function(n){
            var t=(/^(?:replace|split)$/.test(n)?Ve:qe)[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:join|pop|replace|shift)$/.test(n);$n.prototype[n]=function(){var n=arguments;return e&&!this.__chain__?t.apply(this.value(),n):this[r](function(r){return t.apply(r,n)})}}),ht(Bn.prototype,function(n,t){var r=$n[t];if(r){var e=r.name;(Nu[e]||(Nu[e]=[])).push({name:t,func:r})}}),Nu[cr(null,A).name]=[{name:"wrapper",func:null}],Bn.prototype.clone=function(){var n=this.__actions__,t=this.__iteratees__,r=this.__views__,e=new Bn(this.__wrapped__);

            return e.__actions__=n?qn(n):null,e.__dir__=this.__dir__,e.__filtered__=this.__filtered__,e.__iteratees__=t?qn(t):null,e.__takeCount__=this.__takeCount__,e.__views__=r?qn(r):null,e},Bn.prototype.reverse=function(){if(this.__filtered__){var n=new Bn(this);n.__dir__=-1,n.__filtered__=true}else n=this.clone(),n.__dir__*=-1;return n},Bn.prototype.value=function(){var n=this.__wrapped__.value();if(!To(n))return Ft(n,this.__actions__);var t,r=this.__dir__,e=0>r;t=n.length;for(var u=this.__views__,o=0,i=-1,f=u?u.length:0;++i<f;){
            var a=u[i],c=a.size;switch(a.type){case"drop":o+=c;break;case"dropRight":t-=c;break;case"take":t=xu(t,o+c);break;case"takeRight":o=bu(o,t-c)}}t={start:o,end:t},u=t.start,o=t.end,t=o-u,u=e?o:u-1,o=xu(t,this.__takeCount__),f=(i=this.__iteratees__)?i.length:0,a=0,c=[];n:for(;t--&&a<o;){for(var u=u+r,l=-1,s=n[u];++l<f;){var p=i[l],h=p.iteratee,_=p.type;if(_==N){if(p.done&&(e?u>p.index:u<p.index)&&(p.count=0,p.done=false),p.index=u,!(p.done||(_=p.limit,p.done=-1<_?p.count++>=_:!h(s))))continue n}else if(p=h(s),
            _==$)s=p;else if(!p){if(_==F)continue n;break n}}c[a++]=s}return c},$n.prototype.chain=function(){return Gr(this)},$n.prototype.commit=function(){return new zn(this.value(),this.__chain__)},$n.prototype.plant=function(n){for(var t,r=this;r instanceof Ln;){var e=Lr(r);t?u.__wrapped__=e:t=e;var u=e,r=r.__wrapped__}return u.__wrapped__=n,t},$n.prototype.reverse=function(){var n=this.__wrapped__;return n instanceof Bn?(this.__actions__.length&&(n=new Bn(this)),new zn(n.reverse(),this.__chain__)):this.thru(function(n){
            return n.reverse()})},$n.prototype.toString=function(){return this.value()+""},$n.prototype.run=$n.prototype.toJSON=$n.prototype.valueOf=$n.prototype.value=function(){return Ft(this.__wrapped__,this.__actions__)},$n.prototype.collect=$n.prototype.map,$n.prototype.head=$n.prototype.first,$n.prototype.select=$n.prototype.filter,$n.prototype.tail=$n.prototype.rest,$n}var w,b="3.8.0",x=1,A=2,j=4,k=8,O=16,E=32,I=64,R=128,C=256,W=30,S="...",T=150,U=16,N=0,F=1,$=2,L="Expected a function",z="__lodash_placeholder__",B="[object Arguments]",M="[object Array]",D="[object Boolean]",P="[object Date]",q="[object Error]",K="[object Function]",V="[object Number]",Y="[object Object]",Z="[object RegExp]",G="[object String]",J="[object ArrayBuffer]",X="[object Float32Array]",H="[object Float64Array]",Q="[object Int8Array]",nn="[object Int16Array]",tn="[object Int32Array]",rn="[object Uint8Array]",en="[object Uint8ClampedArray]",un="[object Uint16Array]",on="[object Uint32Array]",fn=/\b__p\+='';/g,an=/\b(__p\+=)''\+/g,cn=/(__e\(.*?\)|\b__t\))\+'';/g,ln=/&(?:amp|lt|gt|quot|#39|#96);/g,sn=/[&<>"'`]/g,pn=RegExp(ln.source),hn=RegExp(sn.source),_n=/<%-([\s\S]+?)%>/g,vn=/<%([\s\S]+?)%>/g,gn=/<%=([\s\S]+?)%>/g,yn=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,dn=/^\w*$/,mn=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g,wn=/[.*+?^${}()|[\]\/\\]/g,bn=RegExp(wn.source),xn=/[\u0300-\u036f\ufe20-\ufe23]/g,An=/\\(\\)?/g,jn=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,kn=/\w*$/,On=/^0[xX]/,En=/^\[object .+?Constructor\]$/,In=/[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g,Rn=/($^)/,Cn=/['\n\r\u2028\u2029\\]/g,Wn=RegExp("[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?=[A-Z\\xc0-\\xd6\\xd8-\\xde][a-z\\xdf-\\xf6\\xf8-\\xff]+)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+|[A-Z\\xc0-\\xd6\\xd8-\\xde]+|[0-9]+","g"),Sn=" \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000",Tn="Array ArrayBuffer Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Math Number Object RegExp Set String _ clearTimeout document isFinite parseInt setTimeout TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap window".split(" "),Un={};

    Un[X]=Un[H]=Un[Q]=Un[nn]=Un[tn]=Un[rn]=Un[en]=Un[un]=Un[on]=true,Un[B]=Un[M]=Un[J]=Un[D]=Un[P]=Un[q]=Un[K]=Un["[object Map]"]=Un[V]=Un[Y]=Un[Z]=Un["[object Set]"]=Un[G]=Un["[object WeakMap]"]=false;var Nn={};Nn[B]=Nn[M]=Nn[J]=Nn[D]=Nn[P]=Nn[X]=Nn[H]=Nn[Q]=Nn[nn]=Nn[tn]=Nn[V]=Nn[Y]=Nn[Z]=Nn[G]=Nn[rn]=Nn[en]=Nn[un]=Nn[on]=true,Nn[q]=Nn[K]=Nn["[object Map]"]=Nn["[object Set]"]=Nn["[object WeakMap]"]=false;var Fn={leading:false,maxWait:0,trailing:false},$n={"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A",
        "\xe0":"a","\xe1":"a","\xe2":"a","\xe3":"a","\xe4":"a","\xe5":"a","\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e","\xcc":"I","\xcd":"I","\xce":"I","\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u",
        "\xfb":"u","\xfc":"u","\xdd":"Y","\xfd":"y","\xff":"y","\xc6":"Ae","\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss"},Ln={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#96;"},zn={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'","&#96;":"`"},Bn={"function":true,object:true},Mn={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Dn=Bn[typeof exports]&&exports&&!exports.nodeType&&exports,Pn=Bn[typeof module]&&module&&!module.nodeType&&module,qn=Bn[typeof self]&&self&&self.Object&&self,Kn=Bn[typeof window]&&window&&window.Object&&window,Vn=Pn&&Pn.exports===Dn&&Dn,Yn=Dn&&Pn&&typeof global=="object"&&global&&global.Object&&global||Kn!==(this&&this.window)&&Kn||qn||this,Zn=m();

    typeof define=="function"&&typeof define.amd=="object"&&define.amd?(Yn._=Zn, define(function(){return Zn})):Dn&&Pn?Vn?(Pn.exports=Zn)._=Zn:Dn._=Zn:Yn._=Zn}).call(this);;/*!
 * Knockout JavaScript library v3.4.0
 * (c) Steven Sanderson - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {(function(n){var x=this||(0,eval)("this"),u=x.document,M=x.navigator,v=x.jQuery,F=x.JSON;(function(n){"function"===typeof define&&define.amd?define(["exports","require"],n):"object"===typeof exports&&"object"===typeof module?n(module.exports||exports):n(x.ko={})})(function(N,O){function J(a,c){return null===a||typeof a in T?a===c:!1}function U(b,c){var d;return function(){d||(d=a.a.setTimeout(function(){d=n;b()},c))}}function V(b,c){var d;return function(){clearTimeout(d);d=a.a.setTimeout(b,c)}}function W(a,
c){c&&c!==I?"beforeChange"===c?this.Kb(a):this.Ha(a,c):this.Lb(a)}function X(a,c){null!==c&&c.k&&c.k()}function Y(a,c){var d=this.Hc,e=d[s];e.R||(this.lb&&this.Ma[c]?(d.Pb(c,a,this.Ma[c]),this.Ma[c]=null,--this.lb):e.r[c]||d.Pb(c,a,e.s?{ia:a}:d.uc(a)))}function K(b,c,d,e){a.d[b]={init:function(b,g,k,l,m){var h,r;a.m(function(){var q=a.a.c(g()),p=!d!==!q,A=!r;if(A||c||p!==h)A&&a.va.Aa()&&(r=a.a.ua(a.f.childNodes(b),!0)),p?(A||a.f.da(b,a.a.ua(r)),a.eb(e?e(m,q):m,b)):a.f.xa(b),h=p},null,{i:b});return{controlsDescendantBindings:!0}}};
a.h.ta[b]=!1;a.f.Z[b]=!0}var a="undefined"!==typeof N?N:{};a.b=function(b,c){for(var d=b.split("."),e=a,f=0;f<d.length-1;f++)e=e[d[f]];e[d[d.length-1]]=c};a.G=function(a,c,d){a[c]=d};a.version="3.4.0";a.b("version",a.version);a.options={deferUpdates:!1,useOnlyNativeEvents:!1};a.a=function(){function b(a,b){for(var c in a)a.hasOwnProperty(c)&&b(c,a[c])}function c(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a}function d(a,b){a.__proto__=b;return a}function e(b,c,d,e){var h=b[c].match(r)||
[];a.a.q(d.match(r),function(b){a.a.pa(h,b,e)});b[c]=h.join(" ")}var f={__proto__:[]}instanceof Array,g="function"===typeof Symbol,k={},l={};k[M&&/Firefox\/2/i.test(M.userAgent)?"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];k.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");b(k,function(a,b){if(b.length)for(var c=0,d=b.length;c<d;c++)l[b[c]]=a});var m={propertychange:!0},h=u&&function(){for(var a=3,b=u.createElement("div"),c=
b.getElementsByTagName("i");b.innerHTML="\x3c!--[if gt IE "+ ++a+"]><i></i><![endif]--\x3e",c[0];);return 4<a?a:n}(),r=/\S+/g;return{cc:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],q:function(a,b){for(var c=0,d=a.length;c<d;c++)b(a[c],c)},o:function(a,b){if("function"==typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(a,b);for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},Sb:function(a,b,c){for(var d=0,e=a.length;d<e;d++)if(b.call(c,a[d],d))return a[d];
return null},La:function(b,c){var d=a.a.o(b,c);0<d?b.splice(d,1):0===d&&b.shift()},Tb:function(b){b=b||[];for(var c=[],d=0,e=b.length;d<e;d++)0>a.a.o(c,b[d])&&c.push(b[d]);return c},fb:function(a,b){a=a||[];for(var c=[],d=0,e=a.length;d<e;d++)c.push(b(a[d],d));return c},Ka:function(a,b){a=a||[];for(var c=[],d=0,e=a.length;d<e;d++)b(a[d],d)&&c.push(a[d]);return c},ra:function(a,b){if(b instanceof Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<d;c++)a.push(b[c]);return a},pa:function(b,c,d){var e=
a.a.o(a.a.zb(b),c);0>e?d&&b.push(c):d||b.splice(e,1)},ka:f,extend:c,Xa:d,Ya:f?d:c,D:b,Ca:function(a,b){if(!a)return a;var c={},d;for(d in a)a.hasOwnProperty(d)&&(c[d]=b(a[d],d,a));return c},ob:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},jc:function(b){b=a.a.V(b);for(var c=(b[0]&&b[0].ownerDocument||u).createElement("div"),d=0,e=b.length;d<e;d++)c.appendChild(a.$(b[d]));return c},ua:function(b,c){for(var d=0,e=b.length,h=[];d<e;d++){var m=b[d].cloneNode(!0);h.push(c?a.$(m):m)}return h},
da:function(b,c){a.a.ob(b);if(c)for(var d=0,e=c.length;d<e;d++)b.appendChild(c[d])},qc:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var e=d[0],h=e.parentNode,m=0,l=c.length;m<l;m++)h.insertBefore(c[m],e);m=0;for(l=d.length;m<l;m++)a.removeNode(d[m])}},za:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.splice(0,1);for(;1<a.length&&a[a.length-1].parentNode!==b;)a.length--;if(1<a.length){var c=a[0],d=a[a.length-1];for(a.length=0;c!==d;)a.push(c),
c=c.nextSibling;a.push(d)}}return a},sc:function(a,b){7>h?a.setAttribute("selected",b):a.selected=b},$a:function(a){return null===a||a===n?"":a.trim?a.trim():a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},nd:function(a,b){a=a||"";return b.length>a.length?!1:a.substring(0,b.length)===b},Mc:function(a,b){if(a===b)return!0;if(11===a.nodeType)return!1;if(b.contains)return b.contains(3===a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&16);for(;a&&a!=
b;)a=a.parentNode;return!!a},nb:function(b){return a.a.Mc(b,b.ownerDocument.documentElement)},Qb:function(b){return!!a.a.Sb(b,a.a.nb)},A:function(a){return a&&a.tagName&&a.tagName.toLowerCase()},Wb:function(b){return a.onError?function(){try{return b.apply(this,arguments)}catch(c){throw a.onError&&a.onError(c),c;}}:b},setTimeout:function(b,c){return setTimeout(a.a.Wb(b),c)},$b:function(b){setTimeout(function(){a.onError&&a.onError(b);throw b;},0)},p:function(b,c,d){var e=a.a.Wb(d);d=h&&m[c];if(a.options.useOnlyNativeEvents||
d||!v)if(d||"function"!=typeof b.addEventListener)if("undefined"!=typeof b.attachEvent){var l=function(a){e.call(b,a)},f="on"+c;b.attachEvent(f,l);a.a.F.oa(b,function(){b.detachEvent(f,l)})}else throw Error("Browser doesn't support addEventListener or attachEvent");else b.addEventListener(c,e,!1);else v(b).bind(c,e)},Da:function(b,c){if(!b||!b.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var d;"input"===a.a.A(b)&&b.type&&"click"==c.toLowerCase()?(d=b.type,d="checkbox"==
d||"radio"==d):d=!1;if(a.options.useOnlyNativeEvents||!v||d)if("function"==typeof u.createEvent)if("function"==typeof b.dispatchEvent)d=u.createEvent(l[c]||"HTMLEvents"),d.initEvent(c,!0,!0,x,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error("The supplied element doesn't support dispatchEvent");else if(d&&b.click)b.click();else if("undefined"!=typeof b.fireEvent)b.fireEvent("on"+c);else throw Error("Browser doesn't support triggering events");else v(b).trigger(c)},c:function(b){return a.H(b)?
b():b},zb:function(b){return a.H(b)?b.t():b},bb:function(b,c,d){var h;c&&("object"===typeof b.classList?(h=b.classList[d?"add":"remove"],a.a.q(c.match(r),function(a){h.call(b.classList,a)})):"string"===typeof b.className.baseVal?e(b.className,"baseVal",c,d):e(b,"className",c,d))},Za:function(b,c){var d=a.a.c(c);if(null===d||d===n)d="";var e=a.f.firstChild(b);!e||3!=e.nodeType||a.f.nextSibling(e)?a.f.da(b,[b.ownerDocument.createTextNode(d)]):e.data=d;a.a.Rc(b)},rc:function(a,b){a.name=b;if(7>=h)try{a.mergeAttributes(u.createElement("<input name='"+
a.name+"'/>"),!1)}catch(c){}},Rc:function(a){9<=h&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},Nc:function(a){if(h){var b=a.style.width;a.style.width=0;a.style.width=b}},hd:function(b,c){b=a.a.c(b);c=a.a.c(c);for(var d=[],e=b;e<=c;e++)d.push(e);return d},V:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},Yb:function(a){return g?Symbol(a):a},rd:6===h,sd:7===h,C:h,ec:function(b,c){for(var d=a.a.V(b.getElementsByTagName("input")).concat(a.a.V(b.getElementsByTagName("textarea"))),
e="string"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},h=[],m=d.length-1;0<=m;m--)e(d[m])&&h.push(d[m]);return h},ed:function(b){return"string"==typeof b&&(b=a.a.$a(b))?F&&F.parse?F.parse(b):(new Function("return "+b))():null},Eb:function(b,c,d){if(!F||!F.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
return F.stringify(a.a.c(b),c,d)},fd:function(c,d,e){e=e||{};var h=e.params||{},m=e.includeFields||this.cc,l=c;if("object"==typeof c&&"form"===a.a.A(c))for(var l=c.action,f=m.length-1;0<=f;f--)for(var g=a.a.ec(c,m[f]),k=g.length-1;0<=k;k--)h[g[k].name]=g[k].value;d=a.a.c(d);var r=u.createElement("form");r.style.display="none";r.action=l;r.method="post";for(var n in d)c=u.createElement("input"),c.type="hidden",c.name=n,c.value=a.a.Eb(a.a.c(d[n])),r.appendChild(c);b(h,function(a,b){var c=u.createElement("input");
c.type="hidden";c.name=a;c.value=b;r.appendChild(c)});u.body.appendChild(r);e.submitter?e.submitter(r):r.submit();setTimeout(function(){r.parentNode.removeChild(r)},0)}}}();a.b("utils",a.a);a.b("utils.arrayForEach",a.a.q);a.b("utils.arrayFirst",a.a.Sb);a.b("utils.arrayFilter",a.a.Ka);a.b("utils.arrayGetDistinctValues",a.a.Tb);a.b("utils.arrayIndexOf",a.a.o);a.b("utils.arrayMap",a.a.fb);a.b("utils.arrayPushAll",a.a.ra);a.b("utils.arrayRemoveItem",a.a.La);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",
a.a.cc);a.b("utils.getFormFields",a.a.ec);a.b("utils.peekObservable",a.a.zb);a.b("utils.postJson",a.a.fd);a.b("utils.parseJson",a.a.ed);a.b("utils.registerEventHandler",a.a.p);a.b("utils.stringifyJson",a.a.Eb);a.b("utils.range",a.a.hd);a.b("utils.toggleDomNodeCssClass",a.a.bb);a.b("utils.triggerEvent",a.a.Da);a.b("utils.unwrapObservable",a.a.c);a.b("utils.objectForEach",a.a.D);a.b("utils.addOrRemoveItem",a.a.pa);a.b("utils.setTextContent",a.a.Za);a.b("unwrap",a.a.c);Function.prototype.bind||(Function.prototype.bind=
function(a){var c=this;if(1===arguments.length)return function(){return c.apply(a,arguments)};var d=Array.prototype.slice.call(arguments,1);return function(){var e=d.slice(0);e.push.apply(e,arguments);return c.apply(a,e)}});a.a.e=new function(){function a(b,g){var k=b[d];if(!k||"null"===k||!e[k]){if(!g)return n;k=b[d]="ko"+c++;e[k]={}}return e[k]}var c=0,d="__ko__"+(new Date).getTime(),e={};return{get:function(c,d){var e=a(c,!1);return e===n?n:e[d]},set:function(c,d,e){if(e!==n||a(c,!1)!==n)a(c,!0)[d]=
e},clear:function(a){var b=a[d];return b?(delete e[b],a[d]=null,!0):!1},I:function(){return c++ +d}}};a.b("utils.domData",a.a.e);a.b("utils.domData.clear",a.a.e.clear);a.a.F=new function(){function b(b,c){var e=a.a.e.get(b,d);e===n&&c&&(e=[],a.a.e.set(b,d,e));return e}function c(d){var e=b(d,!1);if(e)for(var e=e.slice(0),l=0;l<e.length;l++)e[l](d);a.a.e.clear(d);a.a.F.cleanExternalData(d);if(f[d.nodeType])for(e=d.firstChild;d=e;)e=d.nextSibling,8===d.nodeType&&c(d)}var d=a.a.e.I(),e={1:!0,8:!0,9:!0},
f={1:!0,9:!0};return{oa:function(a,c){if("function"!=typeof c)throw Error("Callback must be a function");b(a,!0).push(c)},pc:function(c,e){var l=b(c,!1);l&&(a.a.La(l,e),0==l.length&&a.a.e.set(c,d,n))},$:function(b){if(e[b.nodeType]&&(c(b),f[b.nodeType])){var d=[];a.a.ra(d,b.getElementsByTagName("*"));for(var l=0,m=d.length;l<m;l++)c(d[l])}return b},removeNode:function(b){a.$(b);b.parentNode&&b.parentNode.removeChild(b)},cleanExternalData:function(a){v&&"function"==typeof v.cleanData&&v.cleanData([a])}}};
a.$=a.a.F.$;a.removeNode=a.a.F.removeNode;a.b("cleanNode",a.$);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",a.a.F);a.b("utils.domNodeDisposal.addDisposeCallback",a.a.F.oa);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.F.pc);(function(){var b=[0,"",""],c=[1,"<table>","</table>"],d=[3,"<table><tbody><tr>","</tr></tbody></table>"],e=[1,"<select multiple='multiple'>","</select>"],f={thead:c,tbody:c,tfoot:c,tr:[2,"<table><tbody>","</tbody></table>"],td:d,th:d,option:e,optgroup:e},
g=8>=a.a.C;a.a.ma=function(c,d){var e;if(v)if(v.parseHTML)e=v.parseHTML(c,d)||[];else{if((e=v.clean([c],d))&&e[0]){for(var h=e[0];h.parentNode&&11!==h.parentNode.nodeType;)h=h.parentNode;h.parentNode&&h.parentNode.removeChild(h)}}else{(e=d)||(e=u);var h=e.parentWindow||e.defaultView||x,r=a.a.$a(c).toLowerCase(),q=e.createElement("div"),p;p=(r=r.match(/^<([a-z]+)[ >]/))&&f[r[1]]||b;r=p[0];p="ignored<div>"+p[1]+c+p[2]+"</div>";"function"==typeof h.innerShiv?q.appendChild(h.innerShiv(p)):(g&&e.appendChild(q),
q.innerHTML=p,g&&q.parentNode.removeChild(q));for(;r--;)q=q.lastChild;e=a.a.V(q.lastChild.childNodes)}return e};a.a.Cb=function(b,c){a.a.ob(b);c=a.a.c(c);if(null!==c&&c!==n)if("string"!=typeof c&&(c=c.toString()),v)v(b).html(c);else for(var d=a.a.ma(c,b.ownerDocument),e=0;e<d.length;e++)b.appendChild(d[e])}})();a.b("utils.parseHtmlFragment",a.a.ma);a.b("utils.setHtml",a.a.Cb);a.M=function(){function b(c,e){if(c)if(8==c.nodeType){var f=a.M.lc(c.nodeValue);null!=f&&e.push({Lc:c,cd:f})}else if(1==c.nodeType)for(var f=
0,g=c.childNodes,k=g.length;f<k;f++)b(g[f],e)}var c={};return{wb:function(a){if("function"!=typeof a)throw Error("You can only pass a function to ko.memoization.memoize()");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);c[b]=a;return"\x3c!--[ko_memo:"+b+"]--\x3e"},xc:function(a,b){var f=c[a];if(f===n)throw Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized.");try{return f.apply(null,b||[]),
!0}finally{delete c[a]}},yc:function(c,e){var f=[];b(c,f);for(var g=0,k=f.length;g<k;g++){var l=f[g].Lc,m=[l];e&&a.a.ra(m,e);a.M.xc(f[g].cd,m);l.nodeValue="";l.parentNode&&l.parentNode.removeChild(l)}},lc:function(a){return(a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:null}}}();a.b("memoization",a.M);a.b("memoization.memoize",a.M.wb);a.b("memoization.unmemoize",a.M.xc);a.b("memoization.parseMemoText",a.M.lc);a.b("memoization.unmemoizeDomNodeAndDescendants",a.M.yc);a.Y=function(){function b(){if(e)for(var b=
e,c=0,m;g<e;)if(m=d[g++]){if(g>b){if(5E3<=++c){g=e;a.a.$b(Error("'Too much recursion' after processing "+c+" task groups."));break}b=e}try{m()}catch(h){a.a.$b(h)}}}function c(){b();g=e=d.length=0}var d=[],e=0,f=1,g=0;return{scheduler:x.MutationObserver?function(a){var b=u.createElement("div");(new MutationObserver(a)).observe(b,{attributes:!0});return function(){b.classList.toggle("foo")}}(c):u&&"onreadystatechange"in u.createElement("script")?function(a){var b=u.createElement("script");b.onreadystatechange=
function(){b.onreadystatechange=null;u.documentElement.removeChild(b);b=null;a()};u.documentElement.appendChild(b)}:function(a){setTimeout(a,0)},Wa:function(b){e||a.Y.scheduler(c);d[e++]=b;return f++},cancel:function(a){a-=f-e;a>=g&&a<e&&(d[a]=null)},resetForTesting:function(){var a=e-g;g=e=d.length=0;return a},md:b}}();a.b("tasks",a.Y);a.b("tasks.schedule",a.Y.Wa);a.b("tasks.runEarly",a.Y.md);a.ya={throttle:function(b,c){b.throttleEvaluation=c;var d=null;return a.B({read:b,write:function(e){clearTimeout(d);
d=a.a.setTimeout(function(){b(e)},c)}})},rateLimit:function(a,c){var d,e,f;"number"==typeof c?d=c:(d=c.timeout,e=c.method);a.cb=!1;f="notifyWhenChangesStop"==e?V:U;a.Ta(function(a){return f(a,d)})},deferred:function(b,c){if(!0!==c)throw Error("The 'deferred' extender only accepts the value 'true', because it is not supported to turn deferral off once enabled.");b.cb||(b.cb=!0,b.Ta(function(c){var e;return function(){a.Y.cancel(e);e=a.Y.Wa(c);b.notifySubscribers(n,"dirty")}}))},notify:function(a,c){a.equalityComparer=
"always"==c?null:J}};var T={undefined:1,"boolean":1,number:1,string:1};a.b("extenders",a.ya);a.vc=function(b,c,d){this.ia=b;this.gb=c;this.Kc=d;this.R=!1;a.G(this,"dispose",this.k)};a.vc.prototype.k=function(){this.R=!0;this.Kc()};a.J=function(){a.a.Ya(this,D);D.rb(this)};var I="change",D={rb:function(a){a.K={};a.Nb=1},X:function(b,c,d){var e=this;d=d||I;var f=new a.vc(e,c?b.bind(c):b,function(){a.a.La(e.K[d],f);e.Ia&&e.Ia(d)});e.sa&&e.sa(d);e.K[d]||(e.K[d]=[]);e.K[d].push(f);return f},notifySubscribers:function(b,
c){c=c||I;c===I&&this.zc();if(this.Pa(c))try{a.l.Ub();for(var d=this.K[c].slice(0),e=0,f;f=d[e];++e)f.R||f.gb(b)}finally{a.l.end()}},Na:function(){return this.Nb},Uc:function(a){return this.Na()!==a},zc:function(){++this.Nb},Ta:function(b){var c=this,d=a.H(c),e,f,g;c.Ha||(c.Ha=c.notifySubscribers,c.notifySubscribers=W);var k=b(function(){c.Mb=!1;d&&g===c&&(g=c());e=!1;c.tb(f,g)&&c.Ha(f=g)});c.Lb=function(a){c.Mb=e=!0;g=a;k()};c.Kb=function(a){e||(f=a,c.Ha(a,"beforeChange"))}},Pa:function(a){return this.K[a]&&
this.K[a].length},Sc:function(b){if(b)return this.K[b]&&this.K[b].length||0;var c=0;a.a.D(this.K,function(a,b){"dirty"!==a&&(c+=b.length)});return c},tb:function(a,c){return!this.equalityComparer||!this.equalityComparer(a,c)},extend:function(b){var c=this;b&&a.a.D(b,function(b,e){var f=a.ya[b];"function"==typeof f&&(c=f(c,e)||c)});return c}};a.G(D,"subscribe",D.X);a.G(D,"extend",D.extend);a.G(D,"getSubscriptionsCount",D.Sc);a.a.ka&&a.a.Xa(D,Function.prototype);a.J.fn=D;a.hc=function(a){return null!=
a&&"function"==typeof a.X&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.J);a.b("isSubscribable",a.hc);a.va=a.l=function(){function b(a){d.push(e);e=a}function c(){e=d.pop()}var d=[],e,f=0;return{Ub:b,end:c,oc:function(b){if(e){if(!a.hc(b))throw Error("Only subscribable things can act as dependencies");e.gb.call(e.Gc,b,b.Cc||(b.Cc=++f))}},w:function(a,d,e){try{return b(),a.apply(d,e||[])}finally{c()}},Aa:function(){if(e)return e.m.Aa()},Sa:function(){if(e)return e.Sa}}}();a.b("computedContext",
a.va);a.b("computedContext.getDependenciesCount",a.va.Aa);a.b("computedContext.isInitial",a.va.Sa);a.b("ignoreDependencies",a.qd=a.l.w);var E=a.a.Yb("_latestValue");a.N=function(b){function c(){if(0<arguments.length)return c.tb(c[E],arguments[0])&&(c.ga(),c[E]=arguments[0],c.fa()),this;a.l.oc(c);return c[E]}c[E]=b;a.a.ka||a.a.extend(c,a.J.fn);a.J.fn.rb(c);a.a.Ya(c,B);a.options.deferUpdates&&a.ya.deferred(c,!0);return c};var B={equalityComparer:J,t:function(){return this[E]},fa:function(){this.notifySubscribers(this[E])},
ga:function(){this.notifySubscribers(this[E],"beforeChange")}};a.a.ka&&a.a.Xa(B,a.J.fn);var H=a.N.gd="__ko_proto__";B[H]=a.N;a.Oa=function(b,c){return null===b||b===n||b[H]===n?!1:b[H]===c?!0:a.Oa(b[H],c)};a.H=function(b){return a.Oa(b,a.N)};a.Ba=function(b){return"function"==typeof b&&b[H]===a.N||"function"==typeof b&&b[H]===a.B&&b.Vc?!0:!1};a.b("observable",a.N);a.b("isObservable",a.H);a.b("isWriteableObservable",a.Ba);a.b("isWritableObservable",a.Ba);a.b("observable.fn",B);a.G(B,"peek",B.t);a.G(B,
"valueHasMutated",B.fa);a.G(B,"valueWillMutate",B.ga);a.la=function(b){b=b||[];if("object"!=typeof b||!("length"in b))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");b=a.N(b);a.a.Ya(b,a.la.fn);return b.extend({trackArrayChanges:!0})};a.la.fn={remove:function(b){for(var c=this.t(),d=[],e="function"!=typeof b||a.H(b)?function(a){return a===b}:b,f=0;f<c.length;f++){var g=c[f];e(g)&&(0===d.length&&this.ga(),d.push(g),c.splice(f,1),f--)}d.length&&
this.fa();return d},removeAll:function(b){if(b===n){var c=this.t(),d=c.slice(0);this.ga();c.splice(0,c.length);this.fa();return d}return b?this.remove(function(c){return 0<=a.a.o(b,c)}):[]},destroy:function(b){var c=this.t(),d="function"!=typeof b||a.H(b)?function(a){return a===b}:b;this.ga();for(var e=c.length-1;0<=e;e--)d(c[e])&&(c[e]._destroy=!0);this.fa()},destroyAll:function(b){return b===n?this.destroy(function(){return!0}):b?this.destroy(function(c){return 0<=a.a.o(b,c)}):[]},indexOf:function(b){var c=
this();return a.a.o(c,b)},replace:function(a,c){var d=this.indexOf(a);0<=d&&(this.ga(),this.t()[d]=c,this.fa())}};a.a.ka&&a.a.Xa(a.la.fn,a.N.fn);a.a.q("pop push reverse shift sort splice unshift".split(" "),function(b){a.la.fn[b]=function(){var a=this.t();this.ga();this.Vb(a,b,arguments);var d=a[b].apply(a,arguments);this.fa();return d===a?this:d}});a.a.q(["slice"],function(b){a.la.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.b("observableArray",a.la);a.ya.trackArrayChanges=function(b,
c){function d(){if(!e){e=!0;var c=b.notifySubscribers;b.notifySubscribers=function(a,b){b&&b!==I||++k;return c.apply(this,arguments)};var d=[].concat(b.t()||[]);f=null;g=b.X(function(c){c=[].concat(c||[]);if(b.Pa("arrayChange")){var e;if(!f||1<k)f=a.a.ib(d,c,b.hb);e=f}d=c;f=null;k=0;e&&e.length&&b.notifySubscribers(e,"arrayChange")})}}b.hb={};c&&"object"==typeof c&&a.a.extend(b.hb,c);b.hb.sparse=!0;if(!b.Vb){var e=!1,f=null,g,k=0,l=b.sa,m=b.Ia;b.sa=function(a){l&&l.call(b,a);"arrayChange"===a&&d()};
b.Ia=function(a){m&&m.call(b,a);"arrayChange"!==a||b.Pa("arrayChange")||(g.k(),e=!1)};b.Vb=function(b,c,d){function m(a,b,c){return l[l.length]={status:a,value:b,index:c}}if(e&&!k){var l=[],g=b.length,t=d.length,G=0;switch(c){case "push":G=g;case "unshift":for(c=0;c<t;c++)m("added",d[c],G+c);break;case "pop":G=g-1;case "shift":g&&m("deleted",b[G],G);break;case "splice":c=Math.min(Math.max(0,0>d[0]?g+d[0]:d[0]),g);for(var g=1===t?g:Math.min(c+(d[1]||0),g),t=c+t-2,G=Math.max(g,t),P=[],n=[],Q=2;c<G;++c,
++Q)c<g&&n.push(m("deleted",b[c],c)),c<t&&P.push(m("added",d[Q],c));a.a.dc(n,P);break;default:return}f=l}}}};var s=a.a.Yb("_state");a.m=a.B=function(b,c,d){function e(){if(0<arguments.length){if("function"===typeof f)f.apply(g.pb,arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");return this}a.l.oc(e);(g.S||g.s&&e.Qa())&&e.aa();return g.T}"object"===typeof b?d=b:(d=d||{},b&&(d.read=
b));if("function"!=typeof d.read)throw Error("Pass a function that returns the value of the ko.computed");var f=d.write,g={T:n,S:!0,Ra:!1,Fb:!1,R:!1,Va:!1,s:!1,jd:d.read,pb:c||d.owner,i:d.disposeWhenNodeIsRemoved||d.i||null,wa:d.disposeWhen||d.wa,mb:null,r:{},L:0,bc:null};e[s]=g;e.Vc="function"===typeof f;a.a.ka||a.a.extend(e,a.J.fn);a.J.fn.rb(e);a.a.Ya(e,z);d.pure?(g.Va=!0,g.s=!0,a.a.extend(e,$)):d.deferEvaluation&&a.a.extend(e,aa);a.options.deferUpdates&&a.ya.deferred(e,!0);g.i&&(g.Fb=!0,g.i.nodeType||
(g.i=null));g.s||d.deferEvaluation||e.aa();g.i&&e.ba()&&a.a.F.oa(g.i,g.mb=function(){e.k()});return e};var z={equalityComparer:J,Aa:function(){return this[s].L},Pb:function(a,c,d){if(this[s].Va&&c===this)throw Error("A 'pure' computed must not be called recursively");this[s].r[a]=d;d.Ga=this[s].L++;d.na=c.Na()},Qa:function(){var a,c,d=this[s].r;for(a in d)if(d.hasOwnProperty(a)&&(c=d[a],c.ia.Uc(c.na)))return!0},bd:function(){this.Fa&&!this[s].Ra&&this.Fa()},ba:function(){return this[s].S||0<this[s].L},
ld:function(){this.Mb||this.ac()},uc:function(a){if(a.cb&&!this[s].i){var c=a.X(this.bd,this,"dirty"),d=a.X(this.ld,this);return{ia:a,k:function(){c.k();d.k()}}}return a.X(this.ac,this)},ac:function(){var b=this,c=b.throttleEvaluation;c&&0<=c?(clearTimeout(this[s].bc),this[s].bc=a.a.setTimeout(function(){b.aa(!0)},c)):b.Fa?b.Fa():b.aa(!0)},aa:function(b){var c=this[s],d=c.wa;if(!c.Ra&&!c.R){if(c.i&&!a.a.nb(c.i)||d&&d()){if(!c.Fb){this.k();return}}else c.Fb=!1;c.Ra=!0;try{this.Qc(b)}finally{c.Ra=!1}c.L||
this.k()}},Qc:function(b){var c=this[s],d=c.Va?n:!c.L,e={Hc:this,Ma:c.r,lb:c.L};a.l.Ub({Gc:e,gb:Y,m:this,Sa:d});c.r={};c.L=0;e=this.Pc(c,e);this.tb(c.T,e)&&(c.s||this.notifySubscribers(c.T,"beforeChange"),c.T=e,c.s?this.zc():b&&this.notifySubscribers(c.T));d&&this.notifySubscribers(c.T,"awake")},Pc:function(b,c){try{var d=b.jd;return b.pb?d.call(b.pb):d()}finally{a.l.end(),c.lb&&!b.s&&a.a.D(c.Ma,X),b.S=!1}},t:function(){var a=this[s];(a.S&&!a.L||a.s&&this.Qa())&&this.aa();return a.T},Ta:function(b){a.J.fn.Ta.call(this,
b);this.Fa=function(){this.Kb(this[s].T);this[s].S=!0;this.Lb(this)}},k:function(){var b=this[s];!b.s&&b.r&&a.a.D(b.r,function(a,b){b.k&&b.k()});b.i&&b.mb&&a.a.F.pc(b.i,b.mb);b.r=null;b.L=0;b.R=!0;b.S=!1;b.s=!1;b.i=null}},$={sa:function(b){var c=this,d=c[s];if(!d.R&&d.s&&"change"==b){d.s=!1;if(d.S||c.Qa())d.r=null,d.L=0,d.S=!0,c.aa();else{var e=[];a.a.D(d.r,function(a,b){e[b.Ga]=a});a.a.q(e,function(a,b){var e=d.r[a],l=c.uc(e.ia);l.Ga=b;l.na=e.na;d.r[a]=l})}d.R||c.notifySubscribers(d.T,"awake")}},
Ia:function(b){var c=this[s];c.R||"change"!=b||this.Pa("change")||(a.a.D(c.r,function(a,b){b.k&&(c.r[a]={ia:b.ia,Ga:b.Ga,na:b.na},b.k())}),c.s=!0,this.notifySubscribers(n,"asleep"))},Na:function(){var b=this[s];b.s&&(b.S||this.Qa())&&this.aa();return a.J.fn.Na.call(this)}},aa={sa:function(a){"change"!=a&&"beforeChange"!=a||this.t()}};a.a.ka&&a.a.Xa(z,a.J.fn);var R=a.N.gd;a.m[R]=a.N;z[R]=a.m;a.Xc=function(b){return a.Oa(b,a.m)};a.Yc=function(b){return a.Oa(b,a.m)&&b[s]&&b[s].Va};a.b("computed",a.m);
a.b("dependentObservable",a.m);a.b("isComputed",a.Xc);a.b("isPureComputed",a.Yc);a.b("computed.fn",z);a.G(z,"peek",z.t);a.G(z,"dispose",z.k);a.G(z,"isActive",z.ba);a.G(z,"getDependenciesCount",z.Aa);a.nc=function(b,c){if("function"===typeof b)return a.m(b,c,{pure:!0});b=a.a.extend({},b);b.pure=!0;return a.m(b,c)};a.b("pureComputed",a.nc);(function(){function b(a,f,g){g=g||new d;a=f(a);if("object"!=typeof a||null===a||a===n||a instanceof RegExp||a instanceof Date||a instanceof String||a instanceof
Number||a instanceof Boolean)return a;var k=a instanceof Array?[]:{};g.save(a,k);c(a,function(c){var d=f(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":k[c]=d;break;case "object":case "undefined":var h=g.get(d);k[c]=h!==n?h:b(d,f,g)}});return k}function c(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==typeof a.toJSON&&b("toJSON")}else for(c in a)b(c)}function d(){this.keys=[];this.Ib=[]}a.wc=function(c){if(0==arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");
return b(c,function(b){for(var c=0;a.H(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.wc(b);return a.a.Eb(b,c,d)};d.prototype={save:function(b,c){var d=a.a.o(this.keys,b);0<=d?this.Ib[d]=c:(this.keys.push(b),this.Ib.push(c))},get:function(b){b=a.a.o(this.keys,b);return 0<=b?this.Ib[b]:n}}})();a.b("toJS",a.wc);a.b("toJSON",a.toJSON);(function(){a.j={u:function(b){switch(a.a.A(b)){case "option":return!0===b.__ko__hasDomDataOptionValue__?a.a.e.get(b,a.d.options.xb):7>=a.a.C?b.getAttributeNode("value")&&
b.getAttributeNode("value").specified?b.value:b.text:b.value;case "select":return 0<=b.selectedIndex?a.j.u(b.options[b.selectedIndex]):n;default:return b.value}},ha:function(b,c,d){switch(a.a.A(b)){case "option":switch(typeof c){case "string":a.a.e.set(b,a.d.options.xb,n);"__ko__hasDomDataOptionValue__"in b&&delete b.__ko__hasDomDataOptionValue__;b.value=c;break;default:a.a.e.set(b,a.d.options.xb,c),b.__ko__hasDomDataOptionValue__=!0,b.value="number"===typeof c?c:""}break;case "select":if(""===c||
null===c)c=n;for(var e=-1,f=0,g=b.options.length,k;f<g;++f)if(k=a.j.u(b.options[f]),k==c||""==k&&c===n){e=f;break}if(d||0<=e||c===n&&1<b.size)b.selectedIndex=e;break;default:if(null===c||c===n)c="";b.value=c}}}})();a.b("selectExtensions",a.j);a.b("selectExtensions.readValue",a.j.u);a.b("selectExtensions.writeValue",a.j.ha);a.h=function(){function b(b){b=a.a.$a(b);123===b.charCodeAt(0)&&(b=b.slice(1,-1));var c=[],d=b.match(e),r,k=[],p=0;if(d){d.push(",");for(var A=0,y;y=d[A];++A){var t=y.charCodeAt(0);
if(44===t){if(0>=p){c.push(r&&k.length?{key:r,value:k.join("")}:{unknown:r||k.join("")});r=p=0;k=[];continue}}else if(58===t){if(!p&&!r&&1===k.length){r=k.pop();continue}}else 47===t&&A&&1<y.length?(t=d[A-1].match(f))&&!g[t[0]]&&(b=b.substr(b.indexOf(y)+1),d=b.match(e),d.push(","),A=-1,y="/"):40===t||123===t||91===t?++p:41===t||125===t||93===t?--p:r||k.length||34!==t&&39!==t||(y=y.slice(1,-1));k.push(y)}}return c}var c=["true","false","null","undefined"],d=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i,
e=RegExp("\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|/(?:[^/\\\\]|\\\\.)*/w*|[^\\s:,/][^,\"'{}()/:[\\]]*[^\\s,\"'{}()/:[\\]]|[^\\s]","g"),f=/[\])"'A-Za-z0-9_$]+$/,g={"in":1,"return":1,"typeof":1},k={};return{ta:[],ea:k,yb:b,Ua:function(e,m){function h(b,e){var m;if(!A){var l=a.getBindingHandler(b);if(l&&l.preprocess&&!(e=l.preprocess(e,b,h)))return;if(l=k[b])m=e,0<=a.a.o(c,m)?m=!1:(l=m.match(d),m=null===l?!1:l[1]?"Object("+l[1]+")"+l[2]:m),l=m;l&&g.push("'"+b+"':function(_z){"+m+"=_z}")}p&&(e=
"function(){return "+e+" }");f.push("'"+b+"':"+e)}m=m||{};var f=[],g=[],p=m.valueAccessors,A=m.bindingParams,y="string"===typeof e?b(e):e;a.a.q(y,function(a){h(a.key||a.unknown,a.value)});g.length&&h("_ko_property_writers","{"+g.join(",")+" }");return f.join(",")},ad:function(a,b){for(var c=0;c<a.length;c++)if(a[c].key==b)return!0;return!1},Ea:function(b,c,d,e,f){if(b&&a.H(b))!a.Ba(b)||f&&b.t()===e||b(e);else if((b=c.get("_ko_property_writers"))&&b[d])b[d](e)}}}();a.b("expressionRewriting",a.h);a.b("expressionRewriting.bindingRewriteValidators",
a.h.ta);a.b("expressionRewriting.parseObjectLiteral",a.h.yb);a.b("expressionRewriting.preProcessBindings",a.h.Ua);a.b("expressionRewriting._twoWayBindings",a.h.ea);a.b("jsonExpressionRewriting",a.h);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",a.h.Ua);(function(){function b(a){return 8==a.nodeType&&g.test(f?a.text:a.nodeValue)}function c(a){return 8==a.nodeType&&k.test(f?a.text:a.nodeValue)}function d(a,d){for(var e=a,f=1,l=[];e=e.nextSibling;){if(c(e)&&(f--,0===f))return l;l.push(e);
b(e)&&f++}if(!d)throw Error("Cannot find closing comment tag to match: "+a.nodeValue);return null}function e(a,b){var c=d(a,b);return c?0<c.length?c[c.length-1].nextSibling:a.nextSibling:null}var f=u&&"\x3c!--test--\x3e"===u.createComment("test").text,g=f?/^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,k=f?/^\x3c!--\s*\/ko\s*--\x3e$/:/^\s*\/ko\s*$/,l={ul:!0,ol:!0};a.f={Z:{},childNodes:function(a){return b(a)?d(a):a.childNodes},xa:function(c){if(b(c)){c=a.f.childNodes(c);for(var d=
0,e=c.length;d<e;d++)a.removeNode(c[d])}else a.a.ob(c)},da:function(c,d){if(b(c)){a.f.xa(c);for(var e=c.nextSibling,f=0,l=d.length;f<l;f++)e.parentNode.insertBefore(d[f],e)}else a.a.da(c,d)},mc:function(a,c){b(a)?a.parentNode.insertBefore(c,a.nextSibling):a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)},gc:function(c,d,e){e?b(c)?c.parentNode.insertBefore(d,e.nextSibling):e.nextSibling?c.insertBefore(d,e.nextSibling):c.appendChild(d):a.f.mc(c,d)},firstChild:function(a){return b(a)?!a.nextSibling||
c(a.nextSibling)?null:a.nextSibling:a.firstChild},nextSibling:function(a){b(a)&&(a=e(a));return a.nextSibling&&c(a.nextSibling)?null:a.nextSibling},Tc:b,pd:function(a){return(a=(f?a.text:a.nodeValue).match(g))?a[1]:null},kc:function(d){if(l[a.a.A(d)]){var h=d.firstChild;if(h){do if(1===h.nodeType){var f;f=h.firstChild;var g=null;if(f){do if(g)g.push(f);else if(b(f)){var k=e(f,!0);k?f=k:g=[f]}else c(f)&&(g=[f]);while(f=f.nextSibling)}if(f=g)for(g=h.nextSibling,k=0;k<f.length;k++)g?d.insertBefore(f[k],
g):d.appendChild(f[k])}while(h=h.nextSibling)}}}}})();a.b("virtualElements",a.f);a.b("virtualElements.allowedBindings",a.f.Z);a.b("virtualElements.emptyNode",a.f.xa);a.b("virtualElements.insertAfter",a.f.gc);a.b("virtualElements.prepend",a.f.mc);a.b("virtualElements.setDomNodeChildren",a.f.da);(function(){a.Q=function(){this.Fc={}};a.a.extend(a.Q.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=b.getAttribute("data-bind")||a.g.getComponentNameForNode(b);case 8:return a.f.Tc(b);
default:return!1}},getBindings:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b):null;return a.g.Ob(d,b,c,!1)},getBindingAccessors:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b,{valueAccessors:!0}):null;return a.g.Ob(d,b,c,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");case 8:return a.f.pd(b);default:return null}},parseBindingsString:function(b,c,d,e){try{var f=this.Fc,g=b+(e&&e.valueAccessors||
""),k;if(!(k=f[g])){var l,m="with($context){with($data||{}){return{"+a.h.Ua(b,e)+"}}}";l=new Function("$context","$element",m);k=f[g]=l}return k(c,d)}catch(h){throw h.message="Unable to parse bindings.\nBindings value: "+b+"\nMessage: "+h.message,h;}}});a.Q.instance=new a.Q})();a.b("bindingProvider",a.Q);(function(){function b(a){return function(){return a}}function c(a){return a()}function d(b){return a.a.Ca(a.l.w(b),function(a,c){return function(){return b()[c]}})}function e(c,e,h){return"function"===
typeof c?d(c.bind(null,e,h)):a.a.Ca(c,b)}function f(a,b){return d(this.getBindings.bind(this,a,b))}function g(b,c,d){var e,h=a.f.firstChild(c),f=a.Q.instance,m=f.preprocessNode;if(m){for(;e=h;)h=a.f.nextSibling(e),m.call(f,e);h=a.f.firstChild(c)}for(;e=h;)h=a.f.nextSibling(e),k(b,e,d)}function k(b,c,d){var e=!0,h=1===c.nodeType;h&&a.f.kc(c);if(h&&d||a.Q.instance.nodeHasBindings(c))e=m(c,null,b,d).shouldBindDescendants;e&&!r[a.a.A(c)]&&g(b,c,!h)}function l(b){var c=[],d={},e=[];a.a.D(b,function Z(h){if(!d[h]){var f=
a.getBindingHandler(h);f&&(f.after&&(e.push(h),a.a.q(f.after,function(c){if(b[c]){if(-1!==a.a.o(e,c))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+e.join(", "));Z(c)}}),e.length--),c.push({key:h,fc:f}));d[h]=!0}});return c}function m(b,d,e,h){var m=a.a.e.get(b,q);if(!d){if(m)throw Error("You cannot apply bindings multiple times to the same element.");a.a.e.set(b,q,!0)}!m&&h&&a.tc(b,e);var g;if(d&&"function"!==typeof d)g=d;else{var k=a.Q.instance,r=k.getBindingAccessors||
f,p=a.B(function(){(g=d?d(e,b):r.call(k,b,e))&&e.P&&e.P();return g},null,{i:b});g&&p.ba()||(p=null)}var u;if(g){var v=p?function(a){return function(){return c(p()[a])}}:function(a){return g[a]},s=function(){return a.a.Ca(p?p():g,c)};s.get=function(a){return g[a]&&c(v(a))};s.has=function(a){return a in g};h=l(g);a.a.q(h,function(c){var d=c.fc.init,h=c.fc.update,f=c.key;if(8===b.nodeType&&!a.f.Z[f])throw Error("The binding '"+f+"' cannot be used with virtual elements");try{"function"==typeof d&&a.l.w(function(){var a=
d(b,v(f),s,e.$data,e);if(a&&a.controlsDescendantBindings){if(u!==n)throw Error("Multiple bindings ("+u+" and "+f+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");u=f}}),"function"==typeof h&&a.B(function(){h(b,v(f),s,e.$data,e)},null,{i:b})}catch(m){throw m.message='Unable to process binding "'+f+": "+g[f]+'"\nMessage: '+m.message,m;}})}return{shouldBindDescendants:u===n}}function h(b){return b&&b instanceof a.U?b:new a.U(b)}
a.d={};var r={script:!0,textarea:!0,template:!0};a.getBindingHandler=function(b){return a.d[b]};a.U=function(b,c,d,e){var h=this,f="function"==typeof b&&!a.H(b),m,g=a.B(function(){var m=f?b():b,l=a.a.c(m);c?(c.P&&c.P(),a.a.extend(h,c),g&&(h.P=g)):(h.$parents=[],h.$root=l,h.ko=a);h.$rawData=m;h.$data=l;d&&(h[d]=l);e&&e(h,c,l);return h.$data},null,{wa:function(){return m&&!a.a.Qb(m)},i:!0});g.ba()&&(h.P=g,g.equalityComparer=null,m=[],g.Ac=function(b){m.push(b);a.a.F.oa(b,function(b){a.a.La(m,b);m.length||
(g.k(),h.P=g=n)})})};a.U.prototype.createChildContext=function(b,c,d){return new a.U(b,this,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);d&&d(a)})};a.U.prototype.extend=function(b){return new a.U(this.P||this.$data,this,null,function(c,d){c.$rawData=d.$rawData;a.a.extend(c,"function"==typeof b?b():b)})};var q=a.a.e.I(),p=a.a.e.I();a.tc=function(b,c){if(2==arguments.length)a.a.e.set(b,p,c),c.P&&c.P.Ac(b);else return a.a.e.get(b,
p)};a.Ja=function(b,c,d){1===b.nodeType&&a.f.kc(b);return m(b,c,h(d),!0)};a.Dc=function(b,c,d){d=h(d);return a.Ja(b,e(c,d,b),d)};a.eb=function(a,b){1!==b.nodeType&&8!==b.nodeType||g(h(a),b,!0)};a.Rb=function(a,b){!v&&x.jQuery&&(v=x.jQuery);if(b&&1!==b.nodeType&&8!==b.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");b=b||x.document.body;k(h(a),b,!0)};a.kb=function(b){switch(b.nodeType){case 1:case 8:var c=a.tc(b);if(c)return c;
if(b.parentNode)return a.kb(b.parentNode)}return n};a.Jc=function(b){return(b=a.kb(b))?b.$data:n};a.b("bindingHandlers",a.d);a.b("applyBindings",a.Rb);a.b("applyBindingsToDescendants",a.eb);a.b("applyBindingAccessorsToNode",a.Ja);a.b("applyBindingsToNode",a.Dc);a.b("contextFor",a.kb);a.b("dataFor",a.Jc)})();(function(b){function c(c,e){var m=f.hasOwnProperty(c)?f[c]:b,h;m?m.X(e):(m=f[c]=new a.J,m.X(e),d(c,function(b,d){var e=!(!d||!d.synchronous);g[c]={definition:b,Zc:e};delete f[c];h||e?m.notifySubscribers(b):
a.Y.Wa(function(){m.notifySubscribers(b)})}),h=!0)}function d(a,b){e("getConfig",[a],function(c){c?e("loadComponent",[a,c],function(a){b(a,c)}):b(null,null)})}function e(c,d,f,h){h||(h=a.g.loaders.slice(0));var g=h.shift();if(g){var q=g[c];if(q){var p=!1;if(q.apply(g,d.concat(function(a){p?f(null):null!==a?f(a):e(c,d,f,h)}))!==b&&(p=!0,!g.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");}else e(c,d,f,h)}else f(null)}
var f={},g={};a.g={get:function(d,e){var f=g.hasOwnProperty(d)?g[d]:b;f?f.Zc?a.l.w(function(){e(f.definition)}):a.Y.Wa(function(){e(f.definition)}):c(d,e)},Xb:function(a){delete g[a]},Jb:e};a.g.loaders=[];a.b("components",a.g);a.b("components.get",a.g.get);a.b("components.clearCachedDefinition",a.g.Xb)})();(function(){function b(b,c,d,e){function g(){0===--y&&e(k)}var k={},y=2,t=d.template;d=d.viewModel;t?f(c,t,function(c){a.g.Jb("loadTemplate",[b,c],function(a){k.template=a;g()})}):g();d?f(c,d,function(c){a.g.Jb("loadViewModel",
[b,c],function(a){k[l]=a;g()})}):g()}function c(a,b,d){if("function"===typeof b)d(function(a){return new b(a)});else if("function"===typeof b[l])d(b[l]);else if("instance"in b){var e=b.instance;d(function(){return e})}else"viewModel"in b?c(a,b.viewModel,d):a("Unknown viewModel value: "+b)}function d(b){switch(a.a.A(b)){case "script":return a.a.ma(b.text);case "textarea":return a.a.ma(b.value);case "template":if(e(b.content))return a.a.ua(b.content.childNodes)}return a.a.ua(b.childNodes)}function e(a){return x.DocumentFragment?
a instanceof DocumentFragment:a&&11===a.nodeType}function f(a,b,c){"string"===typeof b.require?O||x.require?(O||x.require)([b.require],c):a("Uses require, but no AMD loader is present"):c(b)}function g(a){return function(b){throw Error("Component '"+a+"': "+b);}}var k={};a.g.register=function(b,c){if(!c)throw Error("Invalid configuration for "+b);if(a.g.ub(b))throw Error("Component "+b+" is already registered");k[b]=c};a.g.ub=function(a){return k.hasOwnProperty(a)};a.g.od=function(b){delete k[b];
a.g.Xb(b)};a.g.Zb={getConfig:function(a,b){b(k.hasOwnProperty(a)?k[a]:null)},loadComponent:function(a,c,d){var e=g(a);f(e,c,function(c){b(a,e,c,d)})},loadTemplate:function(b,c,f){b=g(b);if("string"===typeof c)f(a.a.ma(c));else if(c instanceof Array)f(c);else if(e(c))f(a.a.V(c.childNodes));else if(c.element)if(c=c.element,x.HTMLElement?c instanceof HTMLElement:c&&c.tagName&&1===c.nodeType)f(d(c));else if("string"===typeof c){var l=u.getElementById(c);l?f(d(l)):b("Cannot find element with ID "+c)}else b("Unknown element type: "+
c);else b("Unknown template value: "+c)},loadViewModel:function(a,b,d){c(g(a),b,d)}};var l="createViewModel";a.b("components.register",a.g.register);a.b("components.isRegistered",a.g.ub);a.b("components.unregister",a.g.od);a.b("components.defaultLoader",a.g.Zb);a.g.loaders.push(a.g.Zb);a.g.Bc=k})();(function(){function b(b,e){var f=b.getAttribute("params");if(f){var f=c.parseBindingsString(f,e,b,{valueAccessors:!0,bindingParams:!0}),f=a.a.Ca(f,function(c){return a.m(c,null,{i:b})}),g=a.a.Ca(f,function(c){var e=
c.t();return c.ba()?a.m({read:function(){return a.a.c(c())},write:a.Ba(e)&&function(a){c()(a)},i:b}):e});g.hasOwnProperty("$raw")||(g.$raw=f);return g}return{$raw:{}}}a.g.getComponentNameForNode=function(b){var c=a.a.A(b);if(a.g.ub(c)&&(-1!=c.indexOf("-")||"[object HTMLUnknownElement]"==""+b||8>=a.a.C&&b.tagName===c))return c};a.g.Ob=function(c,e,f,g){if(1===e.nodeType){var k=a.g.getComponentNameForNode(e);if(k){c=c||{};if(c.component)throw Error('Cannot use the "component" binding on a custom element matching a component');
var l={name:k,params:b(e,f)};c.component=g?function(){return l}:l}}return c};var c=new a.Q;9>a.a.C&&(a.g.register=function(a){return function(b){u.createElement(b);return a.apply(this,arguments)}}(a.g.register),u.createDocumentFragment=function(b){return function(){var c=b(),f=a.g.Bc,g;for(g in f)f.hasOwnProperty(g)&&c.createElement(g);return c}}(u.createDocumentFragment))})();(function(b){function c(b,c,d){c=c.template;if(!c)throw Error("Component '"+b+"' has no template");b=a.a.ua(c);a.f.da(d,b)}
function d(a,b,c,d){var e=a.createViewModel;return e?e.call(a,d,{element:b,templateNodes:c}):d}var e=0;a.d.component={init:function(f,g,k,l,m){function h(){var a=r&&r.dispose;"function"===typeof a&&a.call(r);q=r=null}var r,q,p=a.a.V(a.f.childNodes(f));a.a.F.oa(f,h);a.m(function(){var l=a.a.c(g()),k,t;"string"===typeof l?k=l:(k=a.a.c(l.name),t=a.a.c(l.params));if(!k)throw Error("No component name specified");var n=q=++e;a.g.get(k,function(e){if(q===n){h();if(!e)throw Error("Unknown component '"+k+
"'");c(k,e,f);var g=d(e,f,p,t);e=m.createChildContext(g,b,function(a){a.$component=g;a.$componentTemplateNodes=p});r=g;a.eb(e,f)}})},null,{i:f});return{controlsDescendantBindings:!0}}};a.f.Z.component=!0})();var S={"class":"className","for":"htmlFor"};a.d.attr={update:function(b,c){var d=a.a.c(c())||{};a.a.D(d,function(c,d){d=a.a.c(d);var g=!1===d||null===d||d===n;g&&b.removeAttribute(c);8>=a.a.C&&c in S?(c=S[c],g?b.removeAttribute(c):b[c]=d):g||b.setAttribute(c,d.toString());"name"===c&&a.a.rc(b,
g?"":d.toString())})}};(function(){a.d.checked={after:["value","attr"],init:function(b,c,d){function e(){var e=b.checked,f=p?g():e;if(!a.va.Sa()&&(!l||e)){var m=a.l.w(c);if(h){var k=r?m.t():m;q!==f?(e&&(a.a.pa(k,f,!0),a.a.pa(k,q,!1)),q=f):a.a.pa(k,f,e);r&&a.Ba(m)&&m(k)}else a.h.Ea(m,d,"checked",f,!0)}}function f(){var d=a.a.c(c());b.checked=h?0<=a.a.o(d,g()):k?d:g()===d}var g=a.nc(function(){return d.has("checkedValue")?a.a.c(d.get("checkedValue")):d.has("value")?a.a.c(d.get("value")):b.value}),k=
"checkbox"==b.type,l="radio"==b.type;if(k||l){var m=c(),h=k&&a.a.c(m)instanceof Array,r=!(h&&m.push&&m.splice),q=h?g():n,p=l||h;l&&!b.name&&a.d.uniqueName.init(b,function(){return!0});a.m(e,null,{i:b});a.a.p(b,"click",e);a.m(f,null,{i:b});m=n}}};a.h.ea.checked=!0;a.d.checkedValue={update:function(b,c){b.value=a.a.c(c())}}})();a.d.css={update:function(b,c){var d=a.a.c(c());null!==d&&"object"==typeof d?a.a.D(d,function(c,d){d=a.a.c(d);a.a.bb(b,c,d)}):(d=a.a.$a(String(d||"")),a.a.bb(b,b.__ko__cssValue,
!1),b.__ko__cssValue=d,a.a.bb(b,d,!0))}};a.d.enable={update:function(b,c){var d=a.a.c(c());d&&b.disabled?b.removeAttribute("disabled"):d||b.disabled||(b.disabled=!0)}};a.d.disable={update:function(b,c){a.d.enable.update(b,function(){return!a.a.c(c())})}};a.d.event={init:function(b,c,d,e,f){var g=c()||{};a.a.D(g,function(g){"string"==typeof g&&a.a.p(b,g,function(b){var m,h=c()[g];if(h){try{var r=a.a.V(arguments);e=f.$data;r.unshift(e);m=h.apply(e,r)}finally{!0!==m&&(b.preventDefault?b.preventDefault():
b.returnValue=!1)}!1===d.get(g+"Bubble")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation())}})})}};a.d.foreach={ic:function(b){return function(){var c=b(),d=a.a.zb(c);if(!d||"number"==typeof d.length)return{foreach:c,templateEngine:a.W.sb};a.a.c(c);return{foreach:d.data,as:d.as,includeDestroyed:d.includeDestroyed,afterAdd:d.afterAdd,beforeRemove:d.beforeRemove,afterRender:d.afterRender,beforeMove:d.beforeMove,afterMove:d.afterMove,templateEngine:a.W.sb}}},init:function(b,c){return a.d.template.init(b,
a.d.foreach.ic(c))},update:function(b,c,d,e,f){return a.d.template.update(b,a.d.foreach.ic(c),d,e,f)}};a.h.ta.foreach=!1;a.f.Z.foreach=!0;a.d.hasfocus={init:function(b,c,d){function e(e){b.__ko_hasfocusUpdating=!0;var f=b.ownerDocument;if("activeElement"in f){var g;try{g=f.activeElement}catch(h){g=f.body}e=g===b}f=c();a.h.Ea(f,d,"hasfocus",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1}var f=e.bind(null,!0),g=e.bind(null,!1);a.a.p(b,"focus",f);a.a.p(b,"focusin",f);a.a.p(b,"blur",g);a.a.p(b,
"focusout",g)},update:function(b,c){var d=!!a.a.c(c());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===d||(d?b.focus():b.blur(),!d&&b.__ko_hasfocusLastValue&&b.ownerDocument.body.focus(),a.l.w(a.a.Da,null,[b,d?"focusin":"focusout"]))}};a.h.ea.hasfocus=!0;a.d.hasFocus=a.d.hasfocus;a.h.ea.hasFocus=!0;a.d.html={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.Cb(b,c())}};K("if");K("ifnot",!1,!0);K("with",!0,!1,function(a,c){return a.createChildContext(c)});var L={};
a.d.options={init:function(b){if("select"!==a.a.A(b))throw Error("options binding applies only to SELECT elements");for(;0<b.length;)b.remove(0);return{controlsDescendantBindings:!0}},update:function(b,c,d){function e(){return a.a.Ka(b.options,function(a){return a.selected})}function f(a,b,c){var d=typeof b;return"function"==d?b(a):"string"==d?a[b]:c}function g(c,e){if(A&&h)a.j.ha(b,a.a.c(d.get("value")),!0);else if(p.length){var f=0<=a.a.o(p,a.j.u(e[0]));a.a.sc(e[0],f);A&&!f&&a.l.w(a.a.Da,null,[b,
"change"])}}var k=b.multiple,l=0!=b.length&&k?b.scrollTop:null,m=a.a.c(c()),h=d.get("valueAllowUnset")&&d.has("value"),r=d.get("optionsIncludeDestroyed");c={};var q,p=[];h||(k?p=a.a.fb(e(),a.j.u):0<=b.selectedIndex&&p.push(a.j.u(b.options[b.selectedIndex])));m&&("undefined"==typeof m.length&&(m=[m]),q=a.a.Ka(m,function(b){return r||b===n||null===b||!a.a.c(b._destroy)}),d.has("optionsCaption")&&(m=a.a.c(d.get("optionsCaption")),null!==m&&m!==n&&q.unshift(L)));var A=!1;c.beforeRemove=function(a){b.removeChild(a)};
m=g;d.has("optionsAfterRender")&&"function"==typeof d.get("optionsAfterRender")&&(m=function(b,c){g(0,c);a.l.w(d.get("optionsAfterRender"),null,[c[0],b!==L?b:n])});a.a.Bb(b,q,function(c,e,g){g.length&&(p=!h&&g[0].selected?[a.j.u(g[0])]:[],A=!0);e=b.ownerDocument.createElement("option");c===L?(a.a.Za(e,d.get("optionsCaption")),a.j.ha(e,n)):(g=f(c,d.get("optionsValue"),c),a.j.ha(e,a.a.c(g)),c=f(c,d.get("optionsText"),g),a.a.Za(e,c));return[e]},c,m);a.l.w(function(){h?a.j.ha(b,a.a.c(d.get("value")),
!0):(k?p.length&&e().length<p.length:p.length&&0<=b.selectedIndex?a.j.u(b.options[b.selectedIndex])!==p[0]:p.length||0<=b.selectedIndex)&&a.a.Da(b,"change")});a.a.Nc(b);l&&20<Math.abs(l-b.scrollTop)&&(b.scrollTop=l)}};a.d.options.xb=a.a.e.I();a.d.selectedOptions={after:["options","foreach"],init:function(b,c,d){a.a.p(b,"change",function(){var e=c(),f=[];a.a.q(b.getElementsByTagName("option"),function(b){b.selected&&f.push(a.j.u(b))});a.h.Ea(e,d,"selectedOptions",f)})},update:function(b,c){if("select"!=
a.a.A(b))throw Error("values binding applies only to SELECT elements");var d=a.a.c(c()),e=b.scrollTop;d&&"number"==typeof d.length&&a.a.q(b.getElementsByTagName("option"),function(b){var c=0<=a.a.o(d,a.j.u(b));b.selected!=c&&a.a.sc(b,c)});b.scrollTop=e}};a.h.ea.selectedOptions=!0;a.d.style={update:function(b,c){var d=a.a.c(c()||{});a.a.D(d,function(c,d){d=a.a.c(d);if(null===d||d===n||!1===d)d="";b.style[c]=d})}};a.d.submit={init:function(b,c,d,e,f){if("function"!=typeof c())throw Error("The value for a submit binding must be a function");
a.a.p(b,"submit",function(a){var d,e=c();try{d=e.call(f.$data,b)}finally{!0!==d&&(a.preventDefault?a.preventDefault():a.returnValue=!1)}})}};a.d.text={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.Za(b,c())}};a.f.Z.text=!0;(function(){if(x&&x.navigator)var b=function(a){if(a)return parseFloat(a[1])},c=x.opera&&x.opera.version&&parseInt(x.opera.version()),d=x.navigator.userAgent,e=b(d.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),f=b(d.match(/Firefox\/([^ ]*)/));
if(10>a.a.C)var g=a.a.e.I(),k=a.a.e.I(),l=function(b){var c=this.activeElement;(c=c&&a.a.e.get(c,k))&&c(b)},m=function(b,c){var d=b.ownerDocument;a.a.e.get(d,g)||(a.a.e.set(d,g,!0),a.a.p(d,"selectionchange",l));a.a.e.set(b,k,c)};a.d.textInput={init:function(b,d,g){function l(c,d){a.a.p(b,c,d)}function k(){var c=a.a.c(d());if(null===c||c===n)c="";v!==n&&c===v?a.a.setTimeout(k,4):b.value!==c&&(u=c,b.value=c)}function y(){s||(v=b.value,s=a.a.setTimeout(t,4))}function t(){clearTimeout(s);v=s=n;var c=
b.value;u!==c&&(u=c,a.h.Ea(d(),g,"textInput",c))}var u=b.value,s,v,x=9==a.a.C?y:t;10>a.a.C?(l("propertychange",function(a){"value"===a.propertyName&&x(a)}),8==a.a.C&&(l("keyup",t),l("keydown",t)),8<=a.a.C&&(m(b,x),l("dragend",y))):(l("input",t),5>e&&"textarea"===a.a.A(b)?(l("keydown",y),l("paste",y),l("cut",y)):11>c?l("keydown",y):4>f&&(l("DOMAutoComplete",t),l("dragdrop",t),l("drop",t)));l("change",t);a.m(k,null,{i:b})}};a.h.ea.textInput=!0;a.d.textinput={preprocess:function(a,b,c){c("textInput",
a)}}})();a.d.uniqueName={init:function(b,c){if(c()){var d="ko_unique_"+ ++a.d.uniqueName.Ic;a.a.rc(b,d)}}};a.d.uniqueName.Ic=0;a.d.value={after:["options","foreach"],init:function(b,c,d){if("input"!=b.tagName.toLowerCase()||"checkbox"!=b.type&&"radio"!=b.type){var e=["change"],f=d.get("valueUpdate"),g=!1,k=null;f&&("string"==typeof f&&(f=[f]),a.a.ra(e,f),e=a.a.Tb(e));var l=function(){k=null;g=!1;var e=c(),f=a.j.u(b);a.h.Ea(e,d,"value",f)};!a.a.C||"input"!=b.tagName.toLowerCase()||"text"!=b.type||
"off"==b.autocomplete||b.form&&"off"==b.form.autocomplete||-1!=a.a.o(e,"propertychange")||(a.a.p(b,"propertychange",function(){g=!0}),a.a.p(b,"focus",function(){g=!1}),a.a.p(b,"blur",function(){g&&l()}));a.a.q(e,function(c){var d=l;a.a.nd(c,"after")&&(d=function(){k=a.j.u(b);a.a.setTimeout(l,0)},c=c.substring(5));a.a.p(b,c,d)});var m=function(){var e=a.a.c(c()),f=a.j.u(b);if(null!==k&&e===k)a.a.setTimeout(m,0);else if(e!==f)if("select"===a.a.A(b)){var g=d.get("valueAllowUnset"),f=function(){a.j.ha(b,
e,g)};f();g||e===a.j.u(b)?a.a.setTimeout(f,0):a.l.w(a.a.Da,null,[b,"change"])}else a.j.ha(b,e)};a.m(m,null,{i:b})}else a.Ja(b,{checkedValue:c})},update:function(){}};a.h.ea.value=!0;a.d.visible={update:function(b,c){var d=a.a.c(c()),e="none"!=b.style.display;d&&!e?b.style.display="":!d&&e&&(b.style.display="none")}};(function(b){a.d[b]={init:function(c,d,e,f,g){return a.d.event.init.call(this,c,function(){var a={};a[b]=d();return a},e,f,g)}}})("click");a.O=function(){};a.O.prototype.renderTemplateSource=
function(){throw Error("Override renderTemplateSource");};a.O.prototype.createJavaScriptEvaluatorBlock=function(){throw Error("Override createJavaScriptEvaluatorBlock");};a.O.prototype.makeTemplateSource=function(b,c){if("string"==typeof b){c=c||u;var d=c.getElementById(b);if(!d)throw Error("Cannot find template with ID "+b);return new a.v.n(d)}if(1==b.nodeType||8==b.nodeType)return new a.v.qa(b);throw Error("Unknown template type: "+b);};a.O.prototype.renderTemplate=function(a,c,d,e){a=this.makeTemplateSource(a,
e);return this.renderTemplateSource(a,c,d,e)};a.O.prototype.isTemplateRewritten=function(a,c){return!1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,c).data("isRewritten")};a.O.prototype.rewriteTemplate=function(a,c,d){a=this.makeTemplateSource(a,d);c=c(a.text());a.text(c);a.data("isRewritten",!0)};a.b("templateEngine",a.O);a.Gb=function(){function b(b,c,d,k){b=a.h.yb(b);for(var l=a.h.ta,m=0;m<b.length;m++){var h=b[m].key;if(l.hasOwnProperty(h)){var r=l[h];if("function"===typeof r){if(h=
r(b[m].value))throw Error(h);}else if(!r)throw Error("This template engine does not support the '"+h+"' binding within its templates");}}d="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+a.h.Ua(b,{valueAccessors:!0})+" } })()},'"+d.toLowerCase()+"')";return k.createJavaScriptEvaluatorBlock(d)+c}var c=/(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi,d=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;return{Oc:function(b,
c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.Gb.dd(b,c)},d)},dd:function(a,f){return a.replace(c,function(a,c,d,e,h){return b(h,c,d,f)}).replace(d,function(a,c){return b(c,"\x3c!-- ko --\x3e","#comment",f)})},Ec:function(b,c){return a.M.wb(function(d,k){var l=d.nextSibling;l&&l.nodeName.toLowerCase()===c&&a.Ja(l,b,k)})}}}();a.b("__tr_ambtns",a.Gb.Ec);(function(){a.v={};a.v.n=function(b){if(this.n=b){var c=a.a.A(b);this.ab="script"===c?1:"textarea"===c?2:"template"==c&&
b.content&&11===b.content.nodeType?3:4}};a.v.n.prototype.text=function(){var b=1===this.ab?"text":2===this.ab?"value":"innerHTML";if(0==arguments.length)return this.n[b];var c=arguments[0];"innerHTML"===b?a.a.Cb(this.n,c):this.n[b]=c};var b=a.a.e.I()+"_";a.v.n.prototype.data=function(c){if(1===arguments.length)return a.a.e.get(this.n,b+c);a.a.e.set(this.n,b+c,arguments[1])};var c=a.a.e.I();a.v.n.prototype.nodes=function(){var b=this.n;if(0==arguments.length)return(a.a.e.get(b,c)||{}).jb||(3===this.ab?
b.content:4===this.ab?b:n);a.a.e.set(b,c,{jb:arguments[0]})};a.v.qa=function(a){this.n=a};a.v.qa.prototype=new a.v.n;a.v.qa.prototype.text=function(){if(0==arguments.length){var b=a.a.e.get(this.n,c)||{};b.Hb===n&&b.jb&&(b.Hb=b.jb.innerHTML);return b.Hb}a.a.e.set(this.n,c,{Hb:arguments[0]})};a.b("templateSources",a.v);a.b("templateSources.domElement",a.v.n);a.b("templateSources.anonymousTemplate",a.v.qa)})();(function(){function b(b,c,d){var e;for(c=a.f.nextSibling(c);b&&(e=b)!==c;)b=a.f.nextSibling(e),
d(e,b)}function c(c,d){if(c.length){var e=c[0],f=c[c.length-1],g=e.parentNode,k=a.Q.instance,n=k.preprocessNode;if(n){b(e,f,function(a,b){var c=a.previousSibling,d=n.call(k,a);d&&(a===e&&(e=d[0]||b),a===f&&(f=d[d.length-1]||c))});c.length=0;if(!e)return;e===f?c.push(e):(c.push(e,f),a.a.za(c,g))}b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.Rb(d,b)});b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.M.yc(b,[d])});a.a.za(c,g)}}function d(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,
e,f,k,q){q=q||{};var p=(b&&d(b)||f||{}).ownerDocument,n=q.templateEngine||g;a.Gb.Oc(f,n,p);f=n.renderTemplate(f,k,q,p);if("number"!=typeof f.length||0<f.length&&"number"!=typeof f[0].nodeType)throw Error("Template engine must return an array of DOM nodes");p=!1;switch(e){case "replaceChildren":a.f.da(b,f);p=!0;break;case "replaceNode":a.a.qc(b,f);p=!0;break;case "ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+e);}p&&(c(f,k),q.afterRender&&a.l.w(q.afterRender,null,[f,k.$data]));
return f}function f(b,c,d){return a.H(b)?b():"function"===typeof b?b(c,d):b}var g;a.Db=function(b){if(b!=n&&!(b instanceof a.O))throw Error("templateEngine must inherit from ko.templateEngine");g=b};a.Ab=function(b,c,h,k,q){h=h||{};if((h.templateEngine||g)==n)throw Error("Set a template engine before calling renderTemplate");q=q||"replaceChildren";if(k){var p=d(k);return a.B(function(){var g=c&&c instanceof a.U?c:new a.U(a.a.c(c)),n=f(b,g.$data,g),g=e(k,q,n,g,h);"replaceNode"==q&&(k=g,p=d(k))},null,
{wa:function(){return!p||!a.a.nb(p)},i:p&&"replaceNode"==q?p.parentNode:p})}return a.M.wb(function(d){a.Ab(b,c,h,d,"replaceNode")})};a.kd=function(b,d,g,k,q){function p(a,b){c(b,s);g.afterRender&&g.afterRender(b,a);s=null}function u(a,c){s=q.createChildContext(a,g.as,function(a){a.$index=c});var d=f(b,a,s);return e(null,"ignoreTargetNode",d,s,g)}var s;return a.B(function(){var b=a.a.c(d)||[];"undefined"==typeof b.length&&(b=[b]);b=a.a.Ka(b,function(b){return g.includeDestroyed||b===n||null===b||!a.a.c(b._destroy)});
a.l.w(a.a.Bb,null,[k,b,u,g,p])},null,{i:k})};var k=a.a.e.I();a.d.template={init:function(b,c){var d=a.a.c(c());if("string"==typeof d||d.name)a.f.xa(b);else{if("nodes"in d){if(d=d.nodes||[],a.H(d))throw Error('The "nodes" option must be a plain, non-observable array.');}else d=a.f.childNodes(b);d=a.a.jc(d);(new a.v.qa(b)).nodes(d)}return{controlsDescendantBindings:!0}},update:function(b,c,d,e,f){var g=c(),s;c=a.a.c(g);d=!0;e=null;"string"==typeof c?c={}:(g=c.name,"if"in c&&(d=a.a.c(c["if"])),d&&"ifnot"in
c&&(d=!a.a.c(c.ifnot)),s=a.a.c(c.data));"foreach"in c?e=a.kd(g||b,d&&c.foreach||[],c,b,f):d?(f="data"in c?f.createChildContext(s,c.as):f,e=a.Ab(g||b,f,c,b)):a.f.xa(b);f=e;(s=a.a.e.get(b,k))&&"function"==typeof s.k&&s.k();a.a.e.set(b,k,f&&f.ba()?f:n)}};a.h.ta.template=function(b){b=a.h.yb(b);return 1==b.length&&b[0].unknown||a.h.ad(b,"name")?null:"This template engine does not support anonymous templates nested within its templates"};a.f.Z.template=!0})();a.b("setTemplateEngine",a.Db);a.b("renderTemplate",
a.Ab);a.a.dc=function(a,c,d){if(a.length&&c.length){var e,f,g,k,l;for(e=f=0;(!d||e<d)&&(k=a[f]);++f){for(g=0;l=c[g];++g)if(k.value===l.value){k.moved=l.index;l.moved=k.index;c.splice(g,1);e=g=0;break}e+=g}}};a.a.ib=function(){function b(b,d,e,f,g){var k=Math.min,l=Math.max,m=[],h,n=b.length,q,p=d.length,s=p-n||1,u=n+p+1,t,v,x;for(h=0;h<=n;h++)for(v=t,m.push(t=[]),x=k(p,h+s),q=l(0,h-1);q<=x;q++)t[q]=q?h?b[h-1]===d[q-1]?v[q-1]:k(v[q]||u,t[q-1]||u)+1:q+1:h+1;k=[];l=[];s=[];h=n;for(q=p;h||q;)p=m[h][q]-
1,q&&p===m[h][q-1]?l.push(k[k.length]={status:e,value:d[--q],index:q}):h&&p===m[h-1][q]?s.push(k[k.length]={status:f,value:b[--h],index:h}):(--q,--h,g.sparse||k.push({status:"retained",value:d[q]}));a.a.dc(s,l,!g.dontLimitMoves&&10*n);return k.reverse()}return function(a,d,e){e="boolean"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];d=d||[];return a.length<d.length?b(a,d,"added","deleted",e):b(d,a,"deleted","added",e)}}();a.b("utils.compareArrays",a.a.ib);(function(){function b(b,c,d,k,l){var m=[],
h=a.B(function(){var h=c(d,l,a.a.za(m,b))||[];0<m.length&&(a.a.qc(m,h),k&&a.l.w(k,null,[d,h,l]));m.length=0;a.a.ra(m,h)},null,{i:b,wa:function(){return!a.a.Qb(m)}});return{ca:m,B:h.ba()?h:n}}var c=a.a.e.I(),d=a.a.e.I();a.a.Bb=function(e,f,g,k,l){function m(b,c){w=q[c];v!==c&&(D[b]=w);w.qb(v++);a.a.za(w.ca,e);u.push(w);z.push(w)}function h(b,c){if(b)for(var d=0,e=c.length;d<e;d++)c[d]&&a.a.q(c[d].ca,function(a){b(a,d,c[d].ja)})}f=f||[];k=k||{};var r=a.a.e.get(e,c)===n,q=a.a.e.get(e,c)||[],p=a.a.fb(q,
function(a){return a.ja}),s=a.a.ib(p,f,k.dontLimitMoves),u=[],t=0,v=0,x=[],z=[];f=[];for(var D=[],p=[],w,C=0,B,E;B=s[C];C++)switch(E=B.moved,B.status){case "deleted":E===n&&(w=q[t],w.B&&(w.B.k(),w.B=n),a.a.za(w.ca,e).length&&(k.beforeRemove&&(u.push(w),z.push(w),w.ja===d?w=null:f[C]=w),w&&x.push.apply(x,w.ca)));t++;break;case "retained":m(C,t++);break;case "added":E!==n?m(C,E):(w={ja:B.value,qb:a.N(v++)},u.push(w),z.push(w),r||(p[C]=w))}a.a.e.set(e,c,u);h(k.beforeMove,D);a.a.q(x,k.beforeRemove?a.$:
a.removeNode);for(var C=0,r=a.f.firstChild(e),F;w=z[C];C++){w.ca||a.a.extend(w,b(e,g,w.ja,l,w.qb));for(t=0;s=w.ca[t];r=s.nextSibling,F=s,t++)s!==r&&a.f.gc(e,s,F);!w.Wc&&l&&(l(w.ja,w.ca,w.qb),w.Wc=!0)}h(k.beforeRemove,f);for(C=0;C<f.length;++C)f[C]&&(f[C].ja=d);h(k.afterMove,D);h(k.afterAdd,p)}})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.Bb);a.W=function(){this.allowTemplateRewriting=!1};a.W.prototype=new a.O;a.W.prototype.renderTemplateSource=function(b,c,d,e){if(c=(9>a.a.C?0:b.nodes)?
b.nodes():null)return a.a.V(c.cloneNode(!0).childNodes);b=b.text();return a.a.ma(b,e)};a.W.sb=new a.W;a.Db(a.W.sb);a.b("nativeTemplateEngine",a.W);(function(){a.vb=function(){var a=this.$c=function(){if(!v||!v.tmpl)return 0;try{if(0<=v.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();this.renderTemplateSource=function(b,e,f,g){g=g||u;f=f||{};if(2>a)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var k=b.data("precompiled");
k||(k=b.text()||"",k=v.template(null,"{{ko_with $item.koBindingContext}}"+k+"{{/ko_with}}"),b.data("precompiled",k));b=[e.$data];e=v.extend({koBindingContext:e},f.templateOptions);e=v.tmpl(k,b,e);e.appendTo(g.createElement("div"));v.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+a+" })()) }}"};this.addTemplate=function(a,b){u.write("<script type='text/html' id='"+a+"'>"+b+"\x3c/script>")};0<a&&(v.tmpl.tag.ko_code={open:"__.push($1 || '');"},
v.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};a.vb.prototype=new a.O;var b=new a.vb;0<b.$c&&a.Db(b);a.b("jqueryTmplTemplateEngine",a.vb)})()})})();})();
;ko.templates = {"KoButton":"<button class=\"KoButton btn\" type=\"button\" data-bind=\"visible: visible, css: css, click: bindClick( $context ), disable: getDisabled( $context ), attr: { title: title, name: name }\"><!-- ko if: (icon && icon.iconName)--><span class=\"KoButton-icon\" data-bind=\"template: $data.icon.template\"></span><!-- /ko--><!-- ko if: text--><span class=\"KoButton-text\" data-bind=\"text: text\"></span><!-- /ko--></button>","KoButtonDropDown":"<div class=\"KoButtonDropDown btn-group\" data-bind=\"visible: visible, css: { dropup: menu.dropup }\"><button class=\"btn btn-default dropdown-toggle\" type=\"button\" data-bind=\"css: css, disable: disabled, attr: { title: title, name: name }\" data-toggle=\"dropdown\"><!-- ko if: (icon && icon.iconName)--><span class=\"KoButtonDropDown-icon\" data-bind=\"template: $data.icon.template\"></span><!-- /ko--><!-- ko if: text--><span class=\"KoButtonDropDown-text\" data-bind=\"text: text\"></span><!-- /ko-->&nbsp;<span class=\"caret\"></span></button><!-- ko template: menu.template--><!-- /ko--></div>","KoButtonSplitDropDown":"<div class=\"KoButtonDropDown btn-group\" data-bind=\"visible: visible, css: { dropup: menu.dropup }\"><button class=\"btn btn-default\" type=\"button\" data-bind=\"click: click, css: css, disable: disabled, attr: { title: title, name: name }\"><!-- ko if: (icon && icon.iconName)--><span class=\"KoButtonDropDown-icon\" data-bind=\"template: $data.icon.template\"></span><!-- /ko--><!-- ko if: text--><span class=\"KoButtonDropDown-text\" data-bind=\"text: text\"></span><!-- /ko--></button><button class=\"btn btn-default dropdown-toggle\" type=\"button\" data-toggle=\"dropdown\" data-bind=\"disable: disabled\">&nbsp;<span class=\"caret\"></span></button><!-- ko template: menu.template--><!-- /ko--></div>","KoComponent":"<div data-bind=\"visible: visible, css: templateName, disable: disabled, attr: { title: title, name: name }\"></div>","KoExample":"<div class=\"KoExample\" style=\"width: 320px\"><div>KoExample is up since <span data-bind=\"text: lifeTimeDisplay()\"></span></div><div><strong style=\"margin-right: .5em; vertical-align: middle;\">something stateful</strong><input name=\"somethingStateful\" type=\"checkbox\" data-bind=\"checked: somethingStateful\" style=\"margin: 0; vertical-align: middle;\"/></div><div>template is: <span data-bind=\"text: templateName\"></span><span class=\"fa fa-refresh\" data-bind=\"click: refreshClickHandler\" style=\"margin-left: .5em; cursor: pointer;\" title=\"change\"></span></div></div>","KoExample-different":"<div class=\"KoExample-different\" style=\"width: 320px\"><div>KoExample is up since <strong data-bind=\"text: lifeTimeDisplay()\"></strong></div><div><!-- ko if: somethingStateful--><div class=\"text-success\">\"somethingStateful\"<span class=\"fa fa-check\" style=\"margin-left: .5em;\"></span></div><!-- /ko--><!-- ko ifnot: somethingStateful--><div class=\"text-danger\">\"somethingStateful\"<span class=\"fa fa-ban\" style=\"margin-left: .5em;\"></span></div><!-- /ko--></div><div>template is: <i data-bind=\"text: templateName\"></i><span class=\"fa fa-refresh\" data-bind=\"click: refreshClickHandler\" style=\"margin-left: .5em; cursor: pointer;\" title=\"change\"></span></div></div>","KoContainer":"<!-- ko template: $data.template--><!-- /ko-->","KoCounter":"<span class=\"KoCounter\" data-bind=\"attr: { title: title }, visible: visible\"><span class=\"KoCounter-icon\" data-bind=\"template: $data.icon.template\"></span><span class=\"KoCounter-count\" data-bind=\"template: $data.count.template\"></span></span>","KoDisplay":"<span class=\"KoDisplay\" data-bind=\"text: display\"></span>","KoField":"<span class=\"KoField\" data-bind=\"visible: visible, attr:{ title: title }\"><!-- ko if: Boolean(label() || icon.hasIcon())--><label><!-- ko if: icon.hasIcon--><span class=\"KoField-icon\" data-bind=\"template: icon.template\"></span><!-- /ko--><!-- ko if: label--><span data-bind=\"text: label\"></span><!-- /ko--></label><!-- /ko--><input class=\"form-control\" data-bind=\"value: value, disable: disabled, css: css, style: styleField, valueUpdate: valueUpdate, hasFocus: hasFocus, attr: { placeholder: iconPlaceholder, type: type, name: name }\"/></span>","KoFieldSelect":"<span class=\"KoField KoFieldSelect\" data-bind=\"visible: visible, attr:{ title: title }\"><!-- ko if: icon.hasIcon()--><span class=\"KoField-icon\" data-bind=\"template: icon.template\"></span><!-- /ko--><select class=\"form-control\" data-bind=\"value: value, css: css, options: options, optionsText: optionsText, optionsValue: optionsValue, optionsCaption: optionsCaption, attr: { name: name }\"></select></span>","KoFieldSelect2":"<span class=\"KoField KoFieldSelect KoFieldSelect2\" data-bind=\"visible: visible, attr:{ title: title }\"><!-- ko if: icon.hasIcon()--><span class=\"KoField-icon\" data-bind=\"template: icon.template\"></span><!-- /ko--><input class=\"form-control\" type=\"hidden\" data-bind=\"select2: select2ConfigBind, disable: disabled, attr: { name: name }, css: css, style: styleField\"/></span>","KoIcon":"<span class=\"KoIcon\" data-bind=\"css: css\"></span>","KoPictureViewer":"<div data-bind=\"attr: {class: containerClass}\" style=\"height: 100%;\"><!--div.col-xs-12(style=\"height: 100%;\")--><!-- ko if: $parent.showCaption--><h4 data-bind=\"text: displayedSource() &amp;&amp; displayedSource().caption\"></h4><!-- /ko--><div class=\"text-center\" data-bind=\"with: displayedSource\" style=\"height: 100%; align-items: center; justify-content: center; text-align: center; display: flex;\"><img style=\"margin: 0 auto;\" src=\"/static/DocCirrus/assets/images/ajax-loader-menu.gif\" data-bind=\"visible: $parent.isLoading\"/><!-- ko ifnot: $data.link--><img class=\"img-responsive\" style=\"margin: 0 auto; max-height: 100%;\" data-bind=\"event: { load: $parent.onImageLoad.bind($parent) }, attr: { src: src }, visible: !$parent.isLoading(), style: {'border-radius': $parent.borderRadius}\"/><!-- /ko--><!-- ko if: $data.link--><a data-bind=\"attr: {href: $data.link}\" target=\"_blank\"><img class=\"img-responsive\" style=\"margin: 0 auto; max-height: 100%;\" data-bind=\"event: { load: $parent.onImageLoad.bind($parent) }, attr: { src: src }, visible: !$parent.isLoading(), style: {'border-radius': $parent.borderRadius}\"/></a><!-- /ko--></div><!-- ko if: isMultiPicturePreview--><a class=\"dc-carousel-control right\" href=\"#\" data-bind=\"click: nextPicture, visible: showNextPictureButton\"><span data-bind=\"attr: {class: controlSizeClass}\"><span class=\"glyphicon glyphicon-chevron-right\"></span></span></a><a class=\"dc-carousel-control left\" href=\"#\" data-bind=\"click: lastPicture, visible: showLastPictureButton\"><span data-bind=\"attr: {class: controlSizeClass}\"><span class=\"glyphicon glyphicon-chevron-left\"></span></span></a><!-- /ko--></div>","KoPaging":"<span class=\"KoPaging\" data-bind=\"attr: { title: title }\"><span class=\"KoPaging-icon\" data-bind=\"template: $data.icon.template\"></span><span class=\"KoPaging-items\"><span class=\"input-group input-group-sm\"><input class=\"KoPaging-input-page form-control\" name=\"KoPaging-page\" data-bind=\"value: page\"/><span class=\"input-group-btn\"><!-- ko template: $data.buttonPrev.template--><!-- /ko--><!-- ko template: $data.buttonNext.template--><!-- /ko--></span></span></span><span data-bind=\"text: ' / ' + pages()\"></span></span>","KoTableHeader":"<tr class=\"KoTableHeader-row KoTableHeader-row-label\" data-bind=\"foreach: owner.columns, notifyBind: { method: $parent.rowRendered, namespace: $parent }\"><th class=\"KoTableHeader-cell\" data-bind=\"      visible: visible,      style: computedStyles,      css: {        'KoTableFixedCell': isFixed,        'KoTableHeader-hasTools': hasTools,        'KoTableColumn-isSortable': isSortable,        'KoTableColumn-isDraggable': isDraggable,        'KoTableColumn-isDroppable': isDroppable,        'KoTableColumn-isInSorters': isInSorters(),        'KoTableColumn-isNotMainSortedBy': isNotMainSortedBy()      },      click: clickLabelHandler,      event: { contextmenu: onFilterContextMenu },      template: $data.template    \"></th></tr><!-- ko if: rowWithFiltersIsAvailable--><tr class=\"KoTableHeader-row KoTableHeader-row-filter\" data-bind=\"foreach: owner.columns, notifyBind: { method: $parent.rowRendered, namespace: $parent }\"><th class=\"KoTableHeader-cell\" data-bind=\"visible: visible, style: computedStyles, css: { 'KoTableFixedCell': isFixed }\" valign=\"top\"><!-- ko switch: $data--><!-- ko case: $parent.hasColumnFilterIcon($value)--><div class=\"text-center\"><span class=\"KoTableHeader-FilterIcon glyphicon glyphicon-filter\" data-bind=\"click: $parent.onFilterIconClick, attr: { title: $parent.filterIconTitle }\"></span></div><!-- /ko--><!-- ko case: $value.isFilterable--><div data-bind=\"template: filterField.template, attr: { title: title }\"></div><!-- /ko--><!-- ko case: $default--><span style=\"height: 30px; display: block;\"><br/></span><!-- /ko--><!-- /ko--></th></tr><!-- /ko-->","KoTable":"<div class=\"KoTable\" data-bind=\"  css: {    'KoTable-renderFooterNot': !renderFooter(),    'KoTable-draggableColumns': draggableColumns,    'KoTable-draggableRows': draggableRows  }\"><!-- ko if: computedVisibilityOfUsageShortcutsRow--><div class=\"KoTable-usageShortcutsRow\" data-bind=\"visible: usageShortcutsVisible, css: { 'KoTable-usageShortcutsRow-bordered': bordered }\"><!-- ko if: usageShortcuts().length--><div style=\"display: inline-block; margin-right: 4px;\"><span class=\"KoTableHeader-FilterIcon glyphicon glyphicon-filter\" style=\"top: 3px;\" data-bind=\"click: onMultiFilterIconClick, attr: { title: filterIconTitleI18n }\"></span></div><!-- ko foreach: usageShortcuts--><button class=\"btn btn-default btn-xs\" type=\"button\" data-bind=\"text: text, css: { active: active }, attr: { title: title }, click: $parent.usageShortcutsClickHandler\"></button><!-- /ko--><!-- /ko--><!-- ko ifnot: usageShortcuts().length--><div class=\"text-center\" data-bind=\"text: i18n( 'KoUI.KoTableUsageConfiguration.usageShortcutsNoneText' )\"></div><!-- /ko--></div><!-- /ko--><div class=\"KoTable-hScroll\" data-bind=\"    style: {      paddingLeft: computedPaddingLeft    },    css: {      'KoTable-scrollable': scrollable,      'table-responsive': responsive,      'KoTable-minWidth': Boolean(tableMinWidth())    }\"><table class=\"KoTable-grid table\" data-bind=\"css: { 'table-bordered': bordered, 'table-condensed': condensed, 'table-striped': striped },      style: {        tableLayout: fixedTableLayout() ? 'fixed': '',        minWidth: _computeTableMinWidth()      }\"><!-- ko if: !haveColumnsAtLeastOneFixed()--><colgroup data-bind=\"foreach: columns\"><col data-bind=\"visible: visible, style: { width: widthComputed }\"/></colgroup><!-- /ko--><thead class=\"KoTableHeader\" data-bind=\"template: header.template\"></thead><!-- ko if: rows().length--><tbody class=\"KoTable-rows\" data-bind=\"template: { name: getTemplateNameRow, foreach: rows }, click: onBodyClick, event: { contextmenu: onBodyContextMenu }\"></tbody><!-- ko if: summaryRow() && !hideSummaryRow()--><tbody class=\"KoTable-rows KoTable-summary-rows\" data-bind=\"template: { name: getTemplateNameSummaryRow, data: summaryDataRow }\"></tbody><!-- /ko--><!-- /ko--><!-- ko ifnot: rows().length--><tbody class=\"KoTable-rows\"><tr class=\"KoTable-row-noDataToShow\"><td class=\"text-center\" data-bind=\"attr: { colspan: columns().length }, text: i18n('KoUI.KoTable.body.noDataToShow')\"></td></tr></tbody><!-- /ko--></table></div><!-- ko if: renderFooter--><table class=\"KoTable-bottom table\" data-bind=\"css: { 'table-bordered': bordered }\"><tfoot class=\"KoTableFooter\"><tr><td data-bind=\"template: $data.footer.template\"></td></tr></tfoot></table><!-- /ko--><div class=\"KoTable-drag-proxy-cursor\"><span class=\"KoTable-drag-proxy-cursor-disabled\"><span class=\"fa fa-ban\"></span></span><span class=\"KoTable-drag-proxy-cursor-enabled\"><span class=\"fa fa-check\"></span></span></div></div>","KoTableExportCsvStart":"<div class=\"form-group form-inline\"><div class=\"form-group\" data-bind=\"css: { 'has-error': fromPageError }\"><label class=\"control-label\" data-bind=\"text: i18n('KoUI.KoTable.showExportCSVStart.fromPage.label')+':'\"></label><input class=\"form-control input-sm\" name=\"fromPage\" type=\"text\" data-bind=\"textInput: fromPage\" style=\"width: 6em; margin: 0 1em;\"/></div><div class=\"form-group\" data-bind=\"css: { 'has-error': toPageError }\"><label class=\"control-label\" data-bind=\"text: i18n('KoUI.KoTable.showExportCSVStart.toPage.label')+':'\"></label><input class=\"form-control input-sm\" name=\"toPage\" type=\"text\" data-bind=\"textInput: toPage\" style=\"width: 6em; margin: 0 1em;\"/></div></div><a data-toggle=\"collapse\" data-target=\"#KoTableExportCsvStart-options\" style=\"cursor: pointer\" data-bind=\"text: i18n('KoUI.KoTable.showExportCSVStart.furtherSettings.label')\"></a><div class=\"collapse\" id=\"KoTableExportCsvStart-options\" style=\"padding-top: 8px;\"><hr style=\"margin-top: 0;\"/><table style=\"width: 100%;\"><colgroup><col style=\"width: 1%\"/><col/></colgroup><tbody><tr><th style=\"padding-right: 1em;\"><div class=\"form-group\"><strong data-bind=\"text: i18n('KoUI.KoTable.showExportCSVStart.lineSeparators.label') + ':'\"></strong></div></th><td><div class=\"form-group\"><!-- ko foreach: lineSeparators--><label class=\"radio-inline\"><input type=\"radio\" name=\"lineSeparator\" data-bind=\"checkedValue: value, checked: $parent.lineSeparator\"/><span data-bind=\"text: label\"></span></label><!-- /ko--></div></td></tr><tr><th style=\"padding-right: 1em;\"><div class=\"form-group\"><strong data-bind=\"text: i18n('KoUI.KoTable.showExportCSVStart.dataSeparators.label') + ':'\"></strong></div></th><td><div class=\"form-group form-inline\"><input class=\"form-control input-sm\" type=\"text\" name=\"dataSeparator\" data-bind=\"value: dataSeparatorText\" style=\"width: 3em\"/><span style=\"display: inline-block; margin: 0 1em;\">oder</span><!-- ko foreach: dataSeparators--><label class=\"radio-inline\"><input type=\"radio\" name=\"dataSeparator\" data-bind=\"checkedValue: value, checked: $parent.dataSeparator\"/><span data-bind=\"text: label\"></span></label><!-- /ko--></div></td></tr><tr><th style=\"padding-right: 1em;\"><div class=\"form-group\"><strong data-bind=\"text: i18n('KoUI.KoTable.showExportCSVStart.textSeparator.label') + ':'\"></strong></div></th><td><div class=\"form-group form-inline\"><input class=\"form-control input-sm\" type=\"text\" name=\"textSeparator\" data-bind=\"value: textSeparator\" style=\"width: 3em\"/></div></td></tr></tbody></table></div>","KoTableVisibleColumnsConfiguration":"<table class=\"table table-bordered\"><colgroup><col width=\"32\"/><col width=\"100%\"/></colgroup><thead><tr><th><lablel class=\"checkbox-inline\"><input type=\"checkbox\" data-bind=\"checked: isAllChecked, event: {change: selectAllChangeHandler}\"/><span style=\"font-weight: bold\" data-bind=\"text: i18n('KoUI.KoTable.visibleColumnsConfiguration.window.columns.visibility.header')\"></span></lablel></th><th data-bind=\"text: i18n('KoUI.KoTable.visibleColumnsConfiguration.window.columns.columnName.header')\"></th></tr></thead><tbody data-bind=\"foreach: columns, event: { change: visibleChangeHandler }\"><tr><td><input type=\"checkbox\" data-bind=\"checked: visible\"/></td><td><span data-bind=\"text: label\"></span></td></tr></tbody></table>","KoTableUsageConfigurationDialog":"<div class=\"KoTableUsageConfigurationDialog\"><table class=\"table\"><thead><tr><th></th><th data-bind=\"text: i18n('KoUI.KoTableUsageConfiguration.KoTableUsageConfigurationDialog.VISIBLE')\"></th><th data-bind=\"text: i18n('KoUI.KoTableUsageConfiguration.KoTableUsageConfigurationDialog.DESIGNATION')\"></th><th data-bind=\"text: i18n('KoUI.KoTableUsageConfiguration.KoTableUsageConfigurationDialog.DESCRIPTION')\"></th><th data-bind=\"text: i18n('KoUI.KoTableUsageConfiguration.KoTableUsageConfigurationDialog.ACTION')\"></th></tr></thead><tbody data-bind=\"foreach: usageConfigurationItems\"><tr><td><span class=\"KoTableUsageConfigurationDialog-dragHandle\" style=\"display: inline-block; width: 10px; margin-top: 4px; cursor: ns-resize; color: #ccc;\"><span class=\"fa fa-ellipsis-v\"></span><span class=\"fa fa-ellipsis-v\" style=\"margin-left: 1px\"></span></span></td><td class=\"text-center\"><input type=\"checkbox\" data-bind=\"checked: shortcutVisible\"/></td><td data-bind=\"css: { 'has-error': $parent.hasErrorName( name ) }\"><input class=\"form-control\" type=\"text\" data-bind=\"value: name, hasFocus: $parent.hasFocus($data)\"/></td><td><input class=\"form-control\" type=\"text\" data-bind=\"value: shortcutDescription\"/></td><td><button class=\"btn btn-default\" type=\"button\" data-bind=\"click: $parent.remove\"><span class=\"fa fa-trash\"></span></button></td></tr></tbody></table></div>","KoTableCell":"<!-- ko if: Boolean(col.renderer)--><div class=\"KoTableCell\" data-bind=\"html: col.interceptRenderOutput(col.doRender($data), $data), attr: { title: col.interceptRenderOutput(value, $data, true) }\" style=\"display: block;\"></div><!-- /ko--><!-- ko ifnot: Boolean(col.renderer)--><div class=\"KoTableCell\" data-bind=\"text: col.interceptRenderOutput(value, $data), attr: { title: col.interceptRenderOutput(value, $data, true) }\" style=\"display: block;\"></div><!-- /ko-->","KoTableCellNumbering":"<div class=\"KoTableColumnNumberingCell\" data-bind=\"html: col.doRender($data), attr: { title: col.interceptRenderOutput(col.doRender($data), $data) }\"></div>","KoTableCellRenderer":"<div class=\"KoTableCell KoTableCellRendererCell\" data-bind=\"html: col.doRender($data)\"></div>","KoTableCellDrag":"<span class=\"KoTableCellDrag\" data-bind=\"css: { 'KoTableCellDrag-isDraggable': col.owner._isRowDraggable( $context.$parentContext.$parentContext ) }\"><span class=\"fa fa-ellipsis-v\"></span><span class=\"fa fa-ellipsis-v\" style=\"margin-left: 1px\"></span></span>","KoTableCellField":"<input class=\"KoTableCellField\" type=\"checkbox\" data-bind=\"click: $parent.checkRow, disable: $parent.isRowDisabledByMeta($data), checked: $parent.isRowChecked($data), css: {'selectedRowChecked': $parent.isRowChecked($data)}\"/>","KoTableCellEditable":"<div class=\"KoTableCell KoTableCellEditable\"><div data-bind=\"css: { 'input-group': valueEditable.buttons }\"><input class=\"form-control input-sm\" data-bind=\"value: valueEditable, attr:{ title: valueEditable() }, event:{ change: col.eventEditableChange }\"/><!-- ko if: valueEditable.buttons--><div class=\"input-group-btn\" data-bind=\"foreach: valueEditable.buttons\"><!-- ko template: $data.template--><!-- /ko--></div><!-- /ko--></div></div>","KoTableCellLinked":"<input class=\"KoTableCellLinked\" type=\"checkbox\" data-bind=\"click: $parent.toggleLinkOfRow, disable: $parent.isCheckBoxDisabled($data), checked: $parent.isRowLinked($data)\"/>","KoTablePicturePreviewCell":"<div class=\"KoTableCell\"><div data-bind=\"template: pictureViewer.template\"></div></div>","KoTablePreviewCell":"<div><!-- ko if: Boolean(col.renderer)--><div class=\"KoTableCell\" style=\"display: block\" data-bind=\"html: col.interceptRenderOutput(col.doRender($data), $data), attr: { title: col.interceptRenderOutput(value, $data, true) }\"></div><!-- /ko--><!-- ko ifnot: Boolean(col.renderer)--><div class=\"KoTableCell\" data-bind=\"text: col.interceptRenderOutput(value, $data), attr: { title: col.interceptRenderOutput(value, $data, true) }\"></div><!-- /ko--><!--ko if: col.displayIcon($data)--><i style=\"margin: 0 2px;\" data-toggle=\"tooltip\" data-placement=\"bottom\" data-bind=\"css: col.iconClass, event: {mouseover: col.initTitle($data)}, click: col.iconClick($data), tooltip: {title: col.iconTitle, placement: 'bottom', trigger:'hover', html: true}\"></i><span style=\"margin: 0 1px;\" data-bind=\"text: col.count($data)\"></span><!-- /ko--></div>","KoTableColumn":"<div class=\"KoTableColumn-label-container\"><!-- ko if: Boolean(rendererHeader)--><span class=\"KoTableColumn-label\" data-bind=\"html: doRenderHeader($data), attr: { title: title }\"></span><!-- /ko--><!-- ko ifnot: Boolean(rendererHeader)--><span class=\"KoTableColumn-label\" data-bind=\"text: label, attr: { title: title }\"></span><!-- /ko--><!--ko if: hasTools--><!-- ko if: showSortConfig--><span class=\"KoTableColumnTools-sort\"><!-- ko switch: $data--><!-- ko case: !$value.isInSorters()--><span class=\"KoTableColumnTools-sort-indication\"><span class=\"KoTableColumnTools-sort-indicator\" data-bind=\"attr: { title: i18n('KoUI.KoTableColumnTools.sort.indicator.NOT.title') }\"><span class=\"fa fa-long-arrow-down\"></span><span class=\"fa fa-long-arrow-up\"></span></span></span><!-- /ko--><!-- ko case: $value.sortDirectionEnabled('DESC')--><span class=\"KoTableColumnTools-sort-indication\"><span class=\"KoTableColumnTools-sort-indicator fa fa-long-arrow-down\" data-bind=\"attr: { title: i18n('KoUI.KoTableColumnTools.sort.indicator.DESC.title') }\"></span><sup class=\"KoTableColumnTools-sort-prioritisationInSorters\" data-bind=\"text: getPrioritisationInSorters(), attr: { title: i18n('KoUI.KoTableColumnTools.sort.prioritisationInSorters.title') }\"></sup></span><!-- /ko--><!-- ko case: $value.sortDirectionEnabled('ASC')--><span class=\"KoTableColumnTools-sort-indication\"><span class=\"KoTableColumnTools-sort-indicator fa fa-long-arrow-up\" data-bind=\"attr: { title: i18n('KoUI.KoTableColumnTools.sort.indicator.ASC.title') }\"></span><sup class=\"KoTableColumnTools-sort-prioritisationInSorters\" data-bind=\"text: getPrioritisationInSorters(), attr: { title: i18n('KoUI.KoTableColumnTools.sort.prioritisationInSorters.title') }\"></sup></span><!-- /ko--><!-- /ko--></span><!-- /ko--><span>&nbsp;</span><!-- /ko--><span data-bind=\"visible: showFilterConfig\" style=\"float: right;\"><span data-bind=\"template: filterOptionsMenu.template\"></span></span></div>","KoTableColumnCheckbox":"<span class=\"KoTableColumnCheckbox\" data-bind=\"css: {'selectedRowChecked': allToggled }\"><input type=\"checkbox\" name=\"allToggled\" data-bind=\"checked: allToggled, visible: allToggleVisible, attr: {title: title}\"/></span>","KoTableColumnNumbering":"<div class=\"KoTableColumn-label-container KoTableColumnNumbering-label-container\"><span class=\"KoTableColumn-label KoTableColumnNumbering-label\" data-bind=\"text: label, attr: { title: title }\"></span></div>","KoTableColumnRenderer":"<div class=\"KoTableColumn-label-container KoTableColumnRenderer-label-container\"><span class=\"KoTableColumn-label KoTableColumnRenderer-label\" data-bind=\"text: label, attr: { title: title }\"></span></div>","KoTableColumnLinked":"<span class=\"KoTableColumnLinked\"><input type=\"checkbox\" name=\"allLinked\" data-bind=\"checked: allLinked, visible: true\"/></span>","KoTableColumnDrag":"","KoTableColumnTools":"<!-- ko if: showSortConfig--><span class=\"KoTableColumnTools-sort\"><!-- ko switch: $data--><!-- ko case: !$value.isInSorters()--><span class=\"KoTableColumnTools-sort-indication\"><span class=\"KoTableColumnTools-sort-indicator\" data-bind=\"attr: { title: i18n('KoUI.KoTableColumnTools.sort.indicator.NOT.title') }\"><span class=\"fa fa-long-arrow-down\"></span><span class=\"fa fa-long-arrow-up\"></span></span></span><!-- /ko--><!-- ko case: $value.sortDirectionEnabled('DESC')--><span class=\"KoTableColumnTools-sort-indication\"><span class=\"KoTableColumnTools-sort-indicator fa fa-long-arrow-down\" data-bind=\"attr: { title: i18n('KoUI.KoTableColumnTools.sort.indicator.DESC.title') }\"></span><sup class=\"KoTableColumnTools-sort-prioritisationInSorters\" data-bind=\"text: getPrioritisationInSorters(), attr: { title: i18n('KoUI.KoTableColumnTools.sort.prioritisationInSorters.title') }\"></sup></span><!-- /ko--><!-- ko case: $value.sortDirectionEnabled('ASC')--><span class=\"KoTableColumnTools-sort-indication\"><span class=\"KoTableColumnTools-sort-indicator fa fa-long-arrow-up\" data-bind=\"attr: { title: i18n('KoUI.KoTableColumnTools.sort.indicator.ASC.title') }\"></span><sup class=\"KoTableColumnTools-sort-prioritisationInSorters\" data-bind=\"text: getPrioritisationInSorters(), attr: { title: i18n('KoUI.KoTableColumnTools.sort.prioritisationInSorters.title') }\"></sup></span><!-- /ko--><!-- /ko--></span><!-- /ko-->","KoTablePicturePreviewColumn":"<div class=\"KoTableColumn-label-container\"><span class=\"KoTableColumn-label\" data-bind=\"text: label, attr: {title: title}\"></span></div>","KoTablePreviewColumn":"<div class=\"KoTableColumn-label-container\"><span class=\"KoTableColumn-label\" data-bind=\"text: label, attr: {title: title}\"></span><!--ko if: hasTools--><!-- ko if: showSortConfig--><span class=\"KoTableColumnTools-sort\"><!-- ko switch: $data--><!-- ko case: !$value.isInSorters()--><span class=\"KoTableColumnTools-sort-indication\"><span class=\"KoTableColumnTools-sort-indicator\" data-bind=\"attr: { title: i18n('KoUI.KoTableColumnTools.sort.indicator.NOT.title') }\"><span class=\"fa fa-long-arrow-down\"></span><span class=\"fa fa-long-arrow-up\"></span></span></span><!-- /ko--><!-- ko case: $value.sortDirectionEnabled('DESC')--><span class=\"KoTableColumnTools-sort-indication\"><span class=\"KoTableColumnTools-sort-indicator fa fa-long-arrow-down\" data-bind=\"attr: { title: i18n('KoUI.KoTableColumnTools.sort.indicator.DESC.title') }\"></span><sup class=\"KoTableColumnTools-sort-prioritisationInSorters\" data-bind=\"text: getPrioritisationInSorters(), attr: { title: i18n('KoUI.KoTableColumnTools.sort.prioritisationInSorters.title') }\"></sup></span><!-- /ko--><!-- ko case: $value.sortDirectionEnabled('ASC')--><span class=\"KoTableColumnTools-sort-indication\"><span class=\"KoTableColumnTools-sort-indicator fa fa-long-arrow-up\" data-bind=\"attr: { title: i18n('KoUI.KoTableColumnTools.sort.indicator.ASC.title') }\"></span><sup class=\"KoTableColumnTools-sort-prioritisationInSorters\" data-bind=\"text: getPrioritisationInSorters(), attr: { title: i18n('KoUI.KoTableColumnTools.sort.prioritisationInSorters.title') }\"></sup></span><!-- /ko--><!-- /ko--></span><!-- /ko--><span>&nbsp;</span><!-- /ko--><span data-bind=\"visible: showFilterConfig\" style=\"float: right;\"><span data-bind=\"template: filterOptionsMenu.template\"></span></span></div>","KoTableUsageConfiguration":"<span class=\"KoTableUsageConfiguration\" data-bind=\"visible: visible, attr: { name: name }\"><span class=\"KoTableUsageConfiguration-label\">Filter:</span><span class=\"KoTableUsageConfiguration-input\"><span class=\"form-inline\"><span data-bind=\"template: entryList.template\"></span></span></span><span class=\"KoTableUsageConfiguration-actions\"><span class=\"btn-group btn-group-sm\"><span class=\"btn-group\" data-bind=\"template: entryAdd.template\"></span><span class=\"btn-group\" data-bind=\"template: entryEdit.template\"></span><span class=\"btn-group\"><button class=\"btn btn-default btn-sm\" type=\"button\" name=\"KoTableUsageConfigurationShortcutsVisibleSwitcherClickHandler\" data-bind=\"click: usageShortcutsVisibleSwitcherClickHandler, attr: { title: i18n( 'KoUI.KoTableUsageConfiguration.KoTableUsageConfigurationShortcutsVisibleSwitcherClickHandler.title' )}\"><span style=\"display: inline-block; transform: rotate(90deg);\"><span class=\"fa fa-long-arrow-up\"></span><span class=\"fa fa-long-arrow-down\"></span></span></button></span></span></span></span>","KoTableRow":"<!-- ko if: $parent._showRowDependentCollapseRows( $context )--><tr class=\"KoTable-row\" data-bind=\"foreach: $parent.columns,    notifyBind: { method: $parent.rowRendered, namespace: $parent },    css: $parent._getCssRow( $context ),    attr: { style: $parent._getStyleRow( $context ) }  \"><td data-bind=\"template: { name: getTemplateNameCell( $context ), data: getTemplateDataCell( $context ) },    visible: visible, css: getCss( $context ), style: computedStyles  \"></td></tr><!-- /ko--><!-- ko if: $parent._showAdditionalDependentCollapseRows( $context )--><tr class=\"KoTable-row-collapse\" data-bind=\"css: $parent._getCssRowAdditionalDependentCollapseRows( $context ), attr: { style: $parent._getStyleRowAdditionalDependentCollapseRows( $context ) }\"><td>&nbsp;</td><td>&nbsp;</td><td data-bind=\"attr: { colspan: $parent.columns().length }, html: $parent.renderAdditionalDependentCollapseRows( $context ), css: $parent._getCssRowAdditionalDependentCollapseRows( $context )\"></td></tr><!-- /ko-->","KoTableSummaryRow":"<!-- ko if: $parent._showRowDependentCollapseRows( $context )--><tr class=\"KoTable-row\" data-bind=\"foreach: $parent.columns,    css: $parent._getCssRow( $context ),    attr: { style: $parent._getStyleRow( $context ) }  \"><!-- ko if: !notVisibleAtSummaryRow()--><td data-bind=\"template: { name: getTemplateNameCell( $context ), data: getTemplateDataSummaryCell( $context ) },    visible: visible, css: getCss( $context )  \"></td><!-- /ko--><!-- ko if: notVisibleAtSummaryRow()--><td data-bind=\"visible: visible, css: getCss( $context )    \"></td><!-- /ko--></tr><!-- /ko-->","KoTableSelect":"<div><!-- ko if: editMode--><table class=\"table table-condensed KoTableSelect-table\"><thead><tr data-bind=\"foreach: headers\"><th data-bind=\"text: title\"></th></tr></thead><tbody data-bind=\"foreach: rows\" style=\"max-height: 200px;\"><!-- ko if: $data.type === 'heading'--><tr><td data-bind=\"text: text\" colspan=\"100%\"></td></tr><!-- /ko--><tr data-bind=\"foreach: $data\"><!-- ko if: type === 'checkbox'--><td><input type=\"checkbox\" data-bind=\"checked: checked, attr: {value: value}\"/></td><!-- /ko--><!-- ko if: type === 'radio'--><td><input type=\"radio\" data-bind=\"checked: checked, attr: {value: value, name: name}\"/></td><!-- /ko--><!-- ko if: type === 'text'--><td data-bind=\"text: value\"></td><!-- /ko--></tr></tbody></table><!-- /ko--><!-- ko if: !editMode && displayComponent--><div data-bind=\"template: displayComponent.template\"></div><!-- /ko--></div>","KoToolbar":"<table class=\"KoToolbar\"><tbody><tr><td class=\"KoToolbar-items-leftAligned\" data-bind=\"template: $data.leftAligned.template\"></td><td class=\"KoToolbar-items-rightAligned\" data-bind=\"template: $data.rightAligned.template\"></td></tr></tbody></table>","KoToolbarSeparator":"<span class=\"KoToolbarSeparator\"></span>","KoMenu":"<ul class=\"KoMenu dropdown-menu\" role=\"menu\" data-bind=\"css: css\" test=\"example\"><!-- ko foreach: items--><!-- ko template: template--><!-- /ko--><!-- /ko--></ul>","KoMenuItem":"<li class=\"KoMenuItem\" data-bind=\"visible: visible, css: css\"><a class=\"KoMenuItem-link\" data-bind=\"click: bindClick( $context ), attr: { title: title, name: name, href: _attrHref, target: target }\"><!-- ko if: (icon && icon.iconName)--><span class=\"KoMenuItem-icon\" data-bind=\"template: $data.icon.template\"></span><!-- /ko--><!-- ko if: text--><span class=\"KoMenuItem-text\" data-bind=\"text: text\"></span><!-- /ko--><!-- ko if: html--><span class=\"KoMenuItem-html\" data-bind=\"html: html\"></span><!-- /ko--></a><!-- ko if: menu && menu.items().length--><!-- ko template: menu.template--><!-- /ko--><!-- /ko--></li>","KoMenuSeparator":"<li class=\"KoMenuSeparator divider\" role=\"separator\" data-bind=\"visible: visible, css: css\"></li>","KoNav":"<ul class=\"KoNav nav\" data-bind=\"visible: visible, css: css, disable: disabled, attr: { title: title, name: name }\"><!-- ko foreach: items--><!-- ko template: template--><!-- /ko--><!-- /ko--></ul>","KoNavItem":"<!-- ko ifnot: menu--><li class=\"KoNavItem\" data-bind=\"visible: visible, css: css, disable: disabled, attr: { title: title }\"><a data-bind=\"click: bindClick( $context ), attr: { href: _attrHref, name: name }, css: {'KoNavItem-danger': hasDanger}\"><span><!-- ko if: (icon && icon.iconName)--><span class=\"KoNavItem-icon\" data-bind=\"template: $data.icon.template\"></span><!-- /ko--><!-- ko if: text--><span class=\"KoNavItem-text\" data-bind=\"text: text\"></span><!-- /ko--><!-- ko if: html--><span class=\"KoNavItem-html\" data-bind=\"html: html\"></span><!-- /ko--><!-- ko if: badge--><span class=\"KoNavItem-badge badge\" data-bind=\"text: badge, click: _onBadgeClick, css: badgeCss, attr: { title: badgeTitle }, event: { mousedown:_onBadgeMouseDown }\"></span><!-- /ko--></span></a></li><!-- /ko--><!-- ko if: menu--><li class=\"KoNavItem dropdown\" data-bind=\"visible: visible, css: css, disable: disabled, attr: { title: title }\"><a class=\"dropdown-toggle\" data-bind=\"click: bindClick( $context ), attr: { href: _attrHref, name: name }\" data-toggle=\"dropdown\"><span><!-- ko if: (icon && icon.iconName)--><span class=\"KoNavItem-icon\" data-bind=\"template: $data.icon.template\"></span><!-- /ko--><!-- ko if: text--><span class=\"KoNavItem-text\" data-bind=\"text: text\"></span><!-- /ko--><!-- ko if: html--><span class=\"KoNavItem-html\" data-bind=\"html: html\"></span><!-- /ko--><!-- ko if: badge--><span class=\"KoNavItem-badge badge\" data-bind=\"text: badge, click: _onBadgeClick, css: badgeCss, attr: { title: badgeTitle }, event: { mousedown:_onBadgeMouseDown }\"></span><!-- /ko--></span><b class=\"caret\"></b></a><!-- ko template: menu.template--><!-- /ko--></li><!-- /ko-->","KoSchemaValue":"<!-- ko if: null !== valueWidget()--><div data-bind=\"template: {name: valueWidget().template, data: valueWidget()}\"></div><!-- /ko-->","KoTree":"<div class=\"ko-tree\"><!-- ko foreach: root.children--><ol><!-- ko template: template--><!-- /ko--></ol><!-- /ko--></div>","KoTreeItem":"<li data-bind=\"dragZone: { name: 'ko-tree-entries', dragStart: tree.onDragStart }\"><div class=\"ko-tree-text\" data-bind=\"dropZone: { accepts: 'ko-tree-entries', drop: tree.onDrop }, dragEvents: {accepts: 'ko-tree-entries', dragEnter: tree.onDragEnter, dragLeave: tree.onDragLeave}, css: {selected: tree.selectedNode() === $data, 'ko-tree-drop-target': tree.currentDropTarget() === $data}, event: {click: tree.onClick, dblclick: tree.onClick, contextmenu: tree.onContextMenu}, style: { 'background-color': bgColor, 'border-radius': '3px', 'margin-bottom': '2px' }\"><!-- ko if: icon--><span class=\"ko-tree-toggle\"><span class=\"glyphicon\" data-bind=\"css: icon\"></span><span>&nbsp;&nbsp;</span></span><!-- /ko--><span data-bind=\"html: textDisplay\"></span><span data-bind=\"if: totalCount\"><span>&nbsp;(</span><span data-bind=\"text: totalCount\"></span><span>)</span></span><!-- ko if: tree.rowActionButton()--><span class=\"pull-right\"><span data-bind=\"template: tree.rowActionButton().template, attr: {'data-id': id}\"></span><span>&nbsp;</span></span><!-- /ko--><!-- ko if: !tree.rowActionButton() && tree.showActivatedIndicators()--><span class=\"pull-right fa fa-circle\" data-bind=\"visible: !entry.isDirectory, css: activeClass, tooltip: {title: activeText}\"></span><!-- /ko--></div><!-- ko if: !isLeaf() && !loading() && children().length--><ol data-bind=\"visible: expanded\"><!-- ko foreach: children--><!-- ko template: template--><!-- /ko--><!-- /ko--></ol><!-- /ko--><!-- ko if: !isLeaf() && !loading() && !children().length--><ol data-bind=\"visible: expanded\"><!-- ko if: !noEntriesText--><li>Keine Eintrge</li><!-- /ko--><!-- ko if: noEntriesText--><li data-bind=\"text: noEntriesText\"></li><!-- /ko--></ol><!-- /ko--><!-- ko if: !isLeaf() && loading--><ol data-bind=\"visible: expanded\"><li data-bind=\"text: loadingItems\"></li></ol><!-- /ko--></li>","KoEditableTable":"<div class=\"KoEditableTable\" data-bind=\"css: { 'KoTable-renderFooterNot': !renderFooter()}\"><div class=\"KoTable-hScroll table-responsive\" data-bind=\"css: { 'KoTable-minWidth': Boolean(tableMinWidth()) }\" style=\"overflow: visible\"><table class=\"KoTable-grid table table-hover table-striped table-bordered\" data-bind=\"        style: {          'margin-bottom': 0,          tableLayout: 'fixed',          minWidth: _computeTableMinWidth        }\"><colgroup data-bind=\"foreach: columns\"><col data-bind=\"visible: visible, style: { width: widthComputed }\"/></colgroup><thead class=\"KoTableHeader\" data-bind=\"template: header.template\"></thead><!-- ko if: groups().length--><tbody class=\"KoTable-rows\" data-bind=\"click: onBodyClick\"><!-- ko foreach: groups--><!-- ko if: $parent.showGroups()--><!-- ko template: { name: $parent.getTemplateNameGroupRow(), data: $data, afterRender: afterRender }--><!-- /ko--><!-- /ko--><!-- ko template: { name: $parent.getTemplateNameRow, foreach: $data.rows }--><!-- /ko--><!-- /ko--></tbody><!-- /ko--><!-- ko ifnot: groups().length--><tbody class=\"KoTable-rows\"><tr class=\"KoTable-row-noDataToShow\"><td class=\"text-center\" data-bind=\"attr: { colspan: columns().length }, text: i18n('KoUI.KoTable.body.noDataToShow')\"></td></tr></tbody><!-- /ko--></table></div><!-- ko if: renderFooter--><table class=\"KoTable-bottom table table-bordered\"><tfoot class=\"KoTableFooter\"><tr><td data-bind=\"template: $data.footer.template\"></td></tr></tfoot></table><!-- /ko--><div class=\"KoTable-drag-proxy-cursor\"><span class=\"KoTable-drag-proxy-cursor-disabled\"><span class=\"fa fa-ban\"></span></span><span class=\"KoTable-drag-proxy-cursor-enabled\"><span class=\"fa fa-check\"></span></span></div></div>","KoEditableTableHeader":"<tr class=\"KoTableHeader-row KoTableHeader-row-label\" data-bind=\"foreach: owner.columns\"><th class=\"KoTableHeader-cell\" data-bind=\" visible: visible, css: { 'KoTableColumn-isInSorters': isInSorters() }, template: $data.template\"></th></tr>","KoEditableTableInputCell":"<!-- ko if: valueUpdate--><div class=\"form-group\" data-bind=\"hasFeedback: { field: value, toggle: value.hasError, messages: value.validationMessages }\"><input class=\"KoEditableTableInputCell form-control\" data-bind=\"value: value, valueUpdate: valueUpdate, attr: {placeholder: placeholder, type: type}, disable: disabled\"/></div><!-- /ko--><!-- ko ifnot: valueUpdate--><div class=\"form-group\" data-bind=\"hasFeedback: { field: value, toggle: value.hasError, messages: value.validationMessages }\"><input class=\"KoEditableTableInputCell form-control\" data-bind=\"textInput: value, attr: {placeholder: placeholder, type: type}, disable: disabled\"/></div><!-- /ko-->","KoEditableTableTextareaCell":"<!-- ko if: valueUpdate--><textarea class=\"KoEditableTableTextareaCell form-control\" data-bind=\"value: value, valueUpdate: valueUpdate, css: css, attr: {placeholder: placeholder}, disable:disabled\"></textarea><!-- /ko--><!-- ko ifnot: valueUpdate--><textarea class=\"KoEditableTableTextareaCell form-control\" data-bind=\"textInput: value, css: css, attr: {placeholder: placeholder}, disable:disabled\"></textarea><!-- /ko-->","KoEditableTablePairInputCell":"<!-- ko if: valueUpdate--><input class=\"hasPairInputs KoEditableTablePairInputCell form-control\" data-bind=\"value: value1, valueUpdate: valueUpdate, attr:{ placeholder: value1Placeholder }\"/><input class=\"hasPairInputs KoEditableTablePairInputCell form-control\" data-bind=\"value: value2, valueUpdate: valueUpdate, attr:{ placeholder: value2Placeholder }\"/><!-- /ko--><!-- ko ifnot: valueUpdate--><input class=\"hasPairInputs KoEditableTablePairInputCell form-control\" data-bind=\"textInput: value1, attr:{ placeholder: value1Placeholder }\"/><input class=\"hasPairInputs KoEditableTablePairInputCell form-control\" data-bind=\"textInput: value2, attr:{ placeholder: value2Placeholder }\"/><!-- /ko-->","KoEditableTableCell":"<!-- ko if: Boolean(col.renderer) && !$data.active()--><div class=\"KoTableCell text-left\" data-bind=\"html: col.interceptRenderOutput(col.doRender($data), $data)\"></div><!-- /ko--><!-- ko ifnot: Boolean(col.renderer) || $data.active()--><div class=\"KoTableCell text-left\" data-bind=\"text: col.interceptRenderOutput(value, $data)\"></div><!-- /ko--><!-- ko if: $data.active() && !$data.disabled()--><div class=\"KoTableCell\" data-bind=\"template: col.inputCell.template\" style=\"overflow: visible\"></div><!-- /ko-->","KoEditableTableCellDrag":"<span class=\"KoTableCellDrag\" data-bind=\"css: { 'KoTableCellDrag-isDraggable': col.owner._isRowDraggable( $context.$parentContext.$parentContext ) }\"><span class=\"fa fa-ellipsis-v\"></span><span class=\"fa fa-ellipsis-v\" style=\"margin-left: 1px\"></span></span>","KoEditableTableCheckboxCell":"<div class=\"KoTableCell\"><input class=\"KoEditableTableTextareaCell\" type=\"checkbox\" data-bind=\"checked: value, disable: disabled\"/></div>","KoEditableTableColumn":"<div class=\"KoTableColumn-label-container\"><span class=\"KoTableColumn-label\" data-bind=\"html: label, attr: { title: title }\"></span><i class=\"dc-info-icon\" data-bind=\"visible: !!headerTooltip, tooltip: {title: headerTooltip}\"></i></div>","KoEditableTableCheckboxColumn":"<div class=\"KoTableColumn-label-container\"><!-- ko if: selectAllCheckbox--><span class=\"KoTableColumn-label\" data-bind=\"hidden: !label, text: label, attr: { title: title }\"></span><input class=\"KoEditableTableTextareaCell\" type=\"checkbox\" data-bind=\"checked: selectAll\"/><!-- /ko--><!-- ko if: !selectAllCheckbox--><span class=\"KoTableColumn-label\" data-bind=\"text: label, attr: { title: title }\"></span><!-- /ko--></div>","KoEditableTableColumnDrag":"","KoEditableTableRow":"<tr class=\"KoTable-row\" data-bind=\"foreach: $parentContext.$parent.columns, css: $parentContext.$parent._getCssRow( $context ), attr: { style: $parentContext.$parent._getStyleRow( $context ) } \"><td data-bind=\"template: { name: getTemplateNameCell( $context ), data: getTemplateDataCell( $context ) }, visible: visible, css: getCss( $context )\"></td></tr>","KoEditableTableGroupRow":"<tr class=\"KoTable-row KoEditableTableGroupHeader\" data-bind=\"css: getCss($context)\"><td class=\"KoTableCell-isData\" data-bind=\"attr: {colspan: (defaultGroup || disabled() ) ? $parentContext.$parent.columns().length : $parentContext.$parent.columns().length - 1}, css: getCss($context)\"><!-- ko ifnot: active()--><div class=\"KoTableCell\" data-bind=\"text: displayName\"></div><!-- /ko--><!-- ko if: active()--><div class=\"form-group KoTableCell\" data-bind=\"hasFeedback: { field: displayName, toggle: displayName.hasError }\"><input class=\"KoEditableTableGroupHeaderName form-control\" data-bind=\"value: displayName, attr:{placeholder: displayName.i18n }\"/></div><!-- /ko--></td><!-- ko if: !defaultGroup && !disabled()--><td class=\"KoTableCell-isUtility\" data-bind=\"css: getCss($context)\"><div class=\"text-center\"><button class=\"btn btn-default\" data-bind=\"click: remove\" href=\"\"><i class=\"fa fa-trash-o\"></i></button></div></td><!-- /ko--></tr>","KoPrintButton":"<div class=\"KoPrintButton btn-group\" data-bind=\"visible: visible, css: { dropup: menu.dropup }\" style=\"display: inline-block; z-index: 1025;\"><button class=\"btn btn-default\" data-bind=\"css: css, disable: disabledOrMissing, attr: { title: title, name: name }, click: onDefaultPrintClick\"><!-- ko if: (icon && icon.iconName)--><span class=\"KoPrintButton-icon\" data-bind=\"template: $data.icon.template\"></span><!-- /ko--><span>&nbsp;</span><!-- ko if: text--><span class=\"KoPrintButton-text\" data-bind=\"text: text\"></span><!-- /ko--></button><div class=\"btn-group\"><button class=\"btn btn-default dropdown-toggle\" type=\"button\" data-bind=\"css: css, disable: disabled, attr: { title: title, name: name }\" data-toggle=\"dropdown\">&nbsp;<span class=\"caret\"></span></button><!-- ko template: menu.template--><!-- /ko--></div></div>","KoFileUploader":"<div class=\"well KoFileUploader\" data-bind=\"fileDrop: droppedFiles\"><div class=\"form-group row\"><div class=\"col-md-6\"><!-- ko foreach: {data: filesInProgress, as: 'fileDesc'}--><div><!-- ko if: $parent.generateDataURL--><img class=\"img-rounded thumb\" style=\"height: 125px;\" data-bind=\"attr: { src: fileDesc.dataURL }\"/><!-- /ko--><div><span data-bind=\"text: fileDesc.name\"></span><a class=\"dc-red pull-right\" data-bind=\"click: $parent.cancel\" href=\"#\"><i class=\"fa fa-times\"></i></a></div><div class=\"progress\" data-bind=\"if: $parent.showProgressBar\"><div class=\"progress-bar\" style=\"min-width: '2%'\" role=\"progressbar\" aria-valuemin=\"0\" aria-valuemax=\"100\" data-bind=\"attr: { 'aria-valuenow': $parent.getProgressBarValue($data) }, style: { width: $parent.getProgressBarWidth($data) }, html: $parent.getProgressBarText($data)\"></div></div></div><!-- /ko--><div data-bind=\"ifnot: filesInProgress().length\"><label class=\"drop-label\" data-bind=\"text: dropLabel\"></label></div></div><div class=\"col-md-6 text-right\"><input class=\"hidden\" id=\"uploadButton\" type=\"file\" multiple=\"multiple\" data-bind=\"fileUploader: uploader\"/><div class=\"btn-group\"><!-- ko template: uploadFileBtn.template--><!-- /ko--><!-- ko foreach: buttons--><!-- ko template: $data.template--><!-- /ko--><!-- /ko--></div></div></div></div>","KoDateRangeSelector":"<div class=\"date-selector\" style=\"margin-top: 5px;\"><div class=\"row\"><div class=\"col-xs-12 datepickers-wrapper\"><div class=\"row datepickers\"><div class=\"col-lg-4 col-md-4 col-sm-4\"><label data-bind=\"text: i18n('InSight2Mojit.timeSelector.customMode.START')\" style=\"display: block;margin-bottom: 5px;min-height: 22px;\"></label><div class=\"date-picker input-group\"><input class=\"form-control\" name=\"tlStartDate\" data-bind=\"datetimepicker: { value: startDate, valueReset: null, options: dateSelectorOptionsStart,onInit: dateSelectorInitStart}\"/></div></div><div class=\"col-lg-4 col-md-4 col-sm-4 period-selector\"><label style=\"display: block;margin-bottom: 5px;min-height: 22px;\"></label><select class=\"form-control\" data-bind=\"options: periodList, optionsText: 'label', optionsValue: 'value', value: switchMode,event: {change: switchModeChange}\" style=\"display: inline-block; width: calc(100% - 110px); margin-right: 5px;\"></select><div class=\"selector-buttons\" style=\"display: inline-block;\"><div data-bind=\"template: periodButtons.prevBtt.template\" style=\"display: inline-block;\"></div><div data-bind=\"template: periodButtons.todayBtt.template, style: {display: switchMode() !== 'custom' ? 'inline-block' : 'none'}\" style=\" margin-left: 4px;\"></div><div data-bind=\"template: periodButtons.nextBtt.template\" style=\"display: inline-block; margin-left: 4px;\"></div></div></div><div class=\"col-lg-4 col-md-4 col-sm-4\"><label data-bind=\"text: i18n('InSight2Mojit.timeSelector.customMode.END')\" style=\"display: block;margin-bottom: 5px;min-height: 22px;\"></label><div class=\"date-picker input-group\"><input class=\"form-control\" name=\"tlEndDate\" data-bind=\"datetimepicker: { value: endDate, valueReset: null, options: dateSelectorOptionsEnd,onInit: dateSelectorInitEnd}\"/></div></div></div></div></div></div>"};;/*
 SWITCH/CASE binding for Knockout http://knockoutjs.com/
 (c) Michael Best
 License: MIT (http://www.opensource.org/licenses/mit-license.php)
 Version 2.1.0
*/
(function(b,k){"function"===typeof define&&define.amd?define(["knockout"],k):k(b.ko)})(this,function(b){function k(a,f){var c=m(f.$switchValueAccessor());return"boolean"==typeof c?a?c:!c:"boolean"==typeof a?a:a instanceof Array?-1!==b.utils.arrayIndexOf(a,c):a==c}function v(a,b){return!k(a,b)}function w(a){return function(){return a}}function h(a,f,c){var n=f?v:k;a||(a="if");c||(c=w);return{flags:d[a].flags,init:function(f,g,l,x,e){if(!e.$switchSkipNextArray)throw Error("case binding must only be used with a switch binding");
if(e.$switchIndex!==p)throw Error("case binding cannot be nested");e.$switchIndex=e.$switchSkipNextArray.push(b.observable(!1))-1;e.$caseValue=b.observable();b.computed(function(){var a=e.$switchIndex,b=a===e.$switchSkipNextArray.length-1,c,f,d;a&&e.$switchSkipNextArray[a-1]()?(c=!1,f=!0):(c=m(g()),c===e.$else?(c=e.$switchDefault()||b,f=!1):d=f=c=n(c,e));e.$caseValue(c);e.$switchSkipNextArray[a](f);d?e.$switchDefault(!1):!f&&b&&e.$switchDefault(!0)},null,{disposeWhenNodeIsRemoved:f});if(d[a].init)return d[a].init(f,
c(e.$caseValue),l,x,e)},update:function(b,f,g,n,e){if(d[a].update)return d[a].update(b,c(e.$caseValue),g,n,e)}}}function r(a,b,c){g.allowedBindings[a]&&(g.allowedBindings[c]=!0);return h(a,"casenot"===b)}function y(a,b,c){return r(b,a,c)}function s(a,b){d[a]=h("if",b);t[a]=!1;g.allowedBindings[a]=!0;d[a].makeSubkeyHandler=y;d[a].getNamespacedHandler=r}var p;if(!b.virtualElements)throw Error("Switch-case requires at least Knockout 2.1");var g=b.virtualElements,q=b.bindingFlags||{},t=b.bindingRewriteValidators||
b.jsonExpressionRewriting.bindingRewriteValidators,m=b.utils.unwrapObservable,d=b.bindingHandlers,u={};d["switch"]={flags:q.contentBind|q.canUseVirtual|q.noValue,init:function(a,f,c,d,k){var h={$switchSkipNextArray:[],$switchValueAccessor:f,$switchDefault:b.observable(!0),$default:u,$else:u},l=[];b.computed(function(){var a=m(f());h.$value=a;b.utils.arrayForEach(l,function(b){b.$value=a})},null,{disposeWhenNodeIsRemoved:a});for(c=g.firstChild(a);a=c;)switch(c=g.nextSibling(a),a.nodeType){case 1:case 8:d=
k.extend(h),d.$switchIndex=p,b.applyBindings(d,a),d.$switchIndex!==p&&l.push(d)}return{controlsDescendantBindings:!0}},preprocess:function(a){return a||"true"}};t["switch"]=!1;g.allowedBindings["switch"]=!0;s("case");s("casenot",!0);d["case.visible"]=h("visible");d["casenot.visible"]=h("visible",!0);d["switch"].makeCaseHandler=h});
;/*
Copyright 2012 Igor Vaynberg

Version: 3.5.2 Timestamp: Sat Nov  1 14:43:36 EDT 2014

This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
General Public License version 2 (the "GPL License"). You may choose either license to govern your
use of this software only upon the condition that you accept all of the terms of either the Apache
License or the GPL License.

You may obtain a copy of the Apache License and the GPL License at:

    http://www.apache.org/licenses/LICENSE-2.0
    http://www.gnu.org/licenses/gpl-2.0.html

Unless required by applicable law or agreed to in writing, software distributed under the
Apache License or the GPL License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
the specific language governing permissions and limitations under the Apache License and the GPL License.
*/
(function ($) {
    if(typeof $.fn.each2 == "undefined") {
        $.extend($.fn, {
            /*
            * 4-10 times faster .each replacement
            * use it carefully, as it overrides jQuery context of element on each iteration
            */
            each2 : function (c) {
                var j = $([0]), i = -1, l = this.length;
                while (
                    ++i < l
                    && (j.context = j[0] = this[i])
                    && c.call(j[0], i, j) !== false //"this"=DOM, i=index, j=jQuery object
                );
                return this;
            }
        });
    }
})(jQuery);

(function ($, undefined) {
    "use strict";
    /*global document, window, jQuery, console */

    if (window.Select2 !== undefined) {
        return;
    }

    var AbstractSelect2, SingleSelect2, MultiSelect2, nextUid, sizer,
        lastMousePosition={x:0,y:0}, $document, scrollBarDimensions,

    KEY = {
        TAB: 9,
        ENTER: 13,
        ESC: 27,
        SPACE: 32,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        HOME: 36,
        END: 35,
        BACKSPACE: 8,
        DELETE: 46,
        isArrow: function (k) {
            k = k.which ? k.which : k;
            switch (k) {
            case KEY.LEFT:
            case KEY.RIGHT:
            case KEY.UP:
            case KEY.DOWN:
                return true;
            }
            return false;
        },
        isControl: function (e) {
            var k = e.which;
            switch (k) {
            case KEY.SHIFT:
            case KEY.CTRL:
            case KEY.ALT:
                return true;
            }

            if (e.metaKey) return true;

            return false;
        },
        isFunctionKey: function (k) {
            k = k.which ? k.which : k;
            return k >= 112 && k <= 123;
        }
    },
    MEASURE_SCROLLBAR_TEMPLATE = "<div class='select2-measure-scrollbar'></div>",

    DIACRITICS = {"\u24B6":"A","\uFF21":"A","\u00C0":"A","\u00C1":"A","\u00C2":"A","\u1EA6":"A","\u1EA4":"A","\u1EAA":"A","\u1EA8":"A","\u00C3":"A","\u0100":"A","\u0102":"A","\u1EB0":"A","\u1EAE":"A","\u1EB4":"A","\u1EB2":"A","\u0226":"A","\u01E0":"A","\u00C4":"A","\u01DE":"A","\u1EA2":"A","\u00C5":"A","\u01FA":"A","\u01CD":"A","\u0200":"A","\u0202":"A","\u1EA0":"A","\u1EAC":"A","\u1EB6":"A","\u1E00":"A","\u0104":"A","\u023A":"A","\u2C6F":"A","\uA732":"AA","\u00C6":"AE","\u01FC":"AE","\u01E2":"AE","\uA734":"AO","\uA736":"AU","\uA738":"AV","\uA73A":"AV","\uA73C":"AY","\u24B7":"B","\uFF22":"B","\u1E02":"B","\u1E04":"B","\u1E06":"B","\u0243":"B","\u0182":"B","\u0181":"B","\u24B8":"C","\uFF23":"C","\u0106":"C","\u0108":"C","\u010A":"C","\u010C":"C","\u00C7":"C","\u1E08":"C","\u0187":"C","\u023B":"C","\uA73E":"C","\u24B9":"D","\uFF24":"D","\u1E0A":"D","\u010E":"D","\u1E0C":"D","\u1E10":"D","\u1E12":"D","\u1E0E":"D","\u0110":"D","\u018B":"D","\u018A":"D","\u0189":"D","\uA779":"D","\u01F1":"DZ","\u01C4":"DZ","\u01F2":"Dz","\u01C5":"Dz","\u24BA":"E","\uFF25":"E","\u00C8":"E","\u00C9":"E","\u00CA":"E","\u1EC0":"E","\u1EBE":"E","\u1EC4":"E","\u1EC2":"E","\u1EBC":"E","\u0112":"E","\u1E14":"E","\u1E16":"E","\u0114":"E","\u0116":"E","\u00CB":"E","\u1EBA":"E","\u011A":"E","\u0204":"E","\u0206":"E","\u1EB8":"E","\u1EC6":"E","\u0228":"E","\u1E1C":"E","\u0118":"E","\u1E18":"E","\u1E1A":"E","\u0190":"E","\u018E":"E","\u24BB":"F","\uFF26":"F","\u1E1E":"F","\u0191":"F","\uA77B":"F","\u24BC":"G","\uFF27":"G","\u01F4":"G","\u011C":"G","\u1E20":"G","\u011E":"G","\u0120":"G","\u01E6":"G","\u0122":"G","\u01E4":"G","\u0193":"G","\uA7A0":"G","\uA77D":"G","\uA77E":"G","\u24BD":"H","\uFF28":"H","\u0124":"H","\u1E22":"H","\u1E26":"H","\u021E":"H","\u1E24":"H","\u1E28":"H","\u1E2A":"H","\u0126":"H","\u2C67":"H","\u2C75":"H","\uA78D":"H","\u24BE":"I","\uFF29":"I","\u00CC":"I","\u00CD":"I","\u00CE":"I","\u0128":"I","\u012A":"I","\u012C":"I","\u0130":"I","\u00CF":"I","\u1E2E":"I","\u1EC8":"I","\u01CF":"I","\u0208":"I","\u020A":"I","\u1ECA":"I","\u012E":"I","\u1E2C":"I","\u0197":"I","\u24BF":"J","\uFF2A":"J","\u0134":"J","\u0248":"J","\u24C0":"K","\uFF2B":"K","\u1E30":"K","\u01E8":"K","\u1E32":"K","\u0136":"K","\u1E34":"K","\u0198":"K","\u2C69":"K","\uA740":"K","\uA742":"K","\uA744":"K","\uA7A2":"K","\u24C1":"L","\uFF2C":"L","\u013F":"L","\u0139":"L","\u013D":"L","\u1E36":"L","\u1E38":"L","\u013B":"L","\u1E3C":"L","\u1E3A":"L","\u0141":"L","\u023D":"L","\u2C62":"L","\u2C60":"L","\uA748":"L","\uA746":"L","\uA780":"L","\u01C7":"LJ","\u01C8":"Lj","\u24C2":"M","\uFF2D":"M","\u1E3E":"M","\u1E40":"M","\u1E42":"M","\u2C6E":"M","\u019C":"M","\u24C3":"N","\uFF2E":"N","\u01F8":"N","\u0143":"N","\u00D1":"N","\u1E44":"N","\u0147":"N","\u1E46":"N","\u0145":"N","\u1E4A":"N","\u1E48":"N","\u0220":"N","\u019D":"N","\uA790":"N","\uA7A4":"N","\u01CA":"NJ","\u01CB":"Nj","\u24C4":"O","\uFF2F":"O","\u00D2":"O","\u00D3":"O","\u00D4":"O","\u1ED2":"O","\u1ED0":"O","\u1ED6":"O","\u1ED4":"O","\u00D5":"O","\u1E4C":"O","\u022C":"O","\u1E4E":"O","\u014C":"O","\u1E50":"O","\u1E52":"O","\u014E":"O","\u022E":"O","\u0230":"O","\u00D6":"O","\u022A":"O","\u1ECE":"O","\u0150":"O","\u01D1":"O","\u020C":"O","\u020E":"O","\u01A0":"O","\u1EDC":"O","\u1EDA":"O","\u1EE0":"O","\u1EDE":"O","\u1EE2":"O","\u1ECC":"O","\u1ED8":"O","\u01EA":"O","\u01EC":"O","\u00D8":"O","\u01FE":"O","\u0186":"O","\u019F":"O","\uA74A":"O","\uA74C":"O","\u01A2":"OI","\uA74E":"OO","\u0222":"OU","\u24C5":"P","\uFF30":"P","\u1E54":"P","\u1E56":"P","\u01A4":"P","\u2C63":"P","\uA750":"P","\uA752":"P","\uA754":"P","\u24C6":"Q","\uFF31":"Q","\uA756":"Q","\uA758":"Q","\u024A":"Q","\u24C7":"R","\uFF32":"R","\u0154":"R","\u1E58":"R","\u0158":"R","\u0210":"R","\u0212":"R","\u1E5A":"R","\u1E5C":"R","\u0156":"R","\u1E5E":"R","\u024C":"R","\u2C64":"R","\uA75A":"R","\uA7A6":"R","\uA782":"R","\u24C8":"S","\uFF33":"S","\u1E9E":"S","\u015A":"S","\u1E64":"S","\u015C":"S","\u1E60":"S","\u0160":"S","\u1E66":"S","\u1E62":"S","\u1E68":"S","\u0218":"S","\u015E":"S","\u2C7E":"S","\uA7A8":"S","\uA784":"S","\u24C9":"T","\uFF34":"T","\u1E6A":"T","\u0164":"T","\u1E6C":"T","\u021A":"T","\u0162":"T","\u1E70":"T","\u1E6E":"T","\u0166":"T","\u01AC":"T","\u01AE":"T","\u023E":"T","\uA786":"T","\uA728":"TZ","\u24CA":"U","\uFF35":"U","\u00D9":"U","\u00DA":"U","\u00DB":"U","\u0168":"U","\u1E78":"U","\u016A":"U","\u1E7A":"U","\u016C":"U","\u00DC":"U","\u01DB":"U","\u01D7":"U","\u01D5":"U","\u01D9":"U","\u1EE6":"U","\u016E":"U","\u0170":"U","\u01D3":"U","\u0214":"U","\u0216":"U","\u01AF":"U","\u1EEA":"U","\u1EE8":"U","\u1EEE":"U","\u1EEC":"U","\u1EF0":"U","\u1EE4":"U","\u1E72":"U","\u0172":"U","\u1E76":"U","\u1E74":"U","\u0244":"U","\u24CB":"V","\uFF36":"V","\u1E7C":"V","\u1E7E":"V","\u01B2":"V","\uA75E":"V","\u0245":"V","\uA760":"VY","\u24CC":"W","\uFF37":"W","\u1E80":"W","\u1E82":"W","\u0174":"W","\u1E86":"W","\u1E84":"W","\u1E88":"W","\u2C72":"W","\u24CD":"X","\uFF38":"X","\u1E8A":"X","\u1E8C":"X","\u24CE":"Y","\uFF39":"Y","\u1EF2":"Y","\u00DD":"Y","\u0176":"Y","\u1EF8":"Y","\u0232":"Y","\u1E8E":"Y","\u0178":"Y","\u1EF6":"Y","\u1EF4":"Y","\u01B3":"Y","\u024E":"Y","\u1EFE":"Y","\u24CF":"Z","\uFF3A":"Z","\u0179":"Z","\u1E90":"Z","\u017B":"Z","\u017D":"Z","\u1E92":"Z","\u1E94":"Z","\u01B5":"Z","\u0224":"Z","\u2C7F":"Z","\u2C6B":"Z","\uA762":"Z","\u24D0":"a","\uFF41":"a","\u1E9A":"a","\u00E0":"a","\u00E1":"a","\u00E2":"a","\u1EA7":"a","\u1EA5":"a","\u1EAB":"a","\u1EA9":"a","\u00E3":"a","\u0101":"a","\u0103":"a","\u1EB1":"a","\u1EAF":"a","\u1EB5":"a","\u1EB3":"a","\u0227":"a","\u01E1":"a","\u00E4":"a","\u01DF":"a","\u1EA3":"a","\u00E5":"a","\u01FB":"a","\u01CE":"a","\u0201":"a","\u0203":"a","\u1EA1":"a","\u1EAD":"a","\u1EB7":"a","\u1E01":"a","\u0105":"a","\u2C65":"a","\u0250":"a","\uA733":"aa","\u00E6":"ae","\u01FD":"ae","\u01E3":"ae","\uA735":"ao","\uA737":"au","\uA739":"av","\uA73B":"av","\uA73D":"ay","\u24D1":"b","\uFF42":"b","\u1E03":"b","\u1E05":"b","\u1E07":"b","\u0180":"b","\u0183":"b","\u0253":"b","\u24D2":"c","\uFF43":"c","\u0107":"c","\u0109":"c","\u010B":"c","\u010D":"c","\u00E7":"c","\u1E09":"c","\u0188":"c","\u023C":"c","\uA73F":"c","\u2184":"c","\u24D3":"d","\uFF44":"d","\u1E0B":"d","\u010F":"d","\u1E0D":"d","\u1E11":"d","\u1E13":"d","\u1E0F":"d","\u0111":"d","\u018C":"d","\u0256":"d","\u0257":"d","\uA77A":"d","\u01F3":"dz","\u01C6":"dz","\u24D4":"e","\uFF45":"e","\u00E8":"e","\u00E9":"e","\u00EA":"e","\u1EC1":"e","\u1EBF":"e","\u1EC5":"e","\u1EC3":"e","\u1EBD":"e","\u0113":"e","\u1E15":"e","\u1E17":"e","\u0115":"e","\u0117":"e","\u00EB":"e","\u1EBB":"e","\u011B":"e","\u0205":"e","\u0207":"e","\u1EB9":"e","\u1EC7":"e","\u0229":"e","\u1E1D":"e","\u0119":"e","\u1E19":"e","\u1E1B":"e","\u0247":"e","\u025B":"e","\u01DD":"e","\u24D5":"f","\uFF46":"f","\u1E1F":"f","\u0192":"f","\uA77C":"f","\u24D6":"g","\uFF47":"g","\u01F5":"g","\u011D":"g","\u1E21":"g","\u011F":"g","\u0121":"g","\u01E7":"g","\u0123":"g","\u01E5":"g","\u0260":"g","\uA7A1":"g","\u1D79":"g","\uA77F":"g","\u24D7":"h","\uFF48":"h","\u0125":"h","\u1E23":"h","\u1E27":"h","\u021F":"h","\u1E25":"h","\u1E29":"h","\u1E2B":"h","\u1E96":"h","\u0127":"h","\u2C68":"h","\u2C76":"h","\u0265":"h","\u0195":"hv","\u24D8":"i","\uFF49":"i","\u00EC":"i","\u00ED":"i","\u00EE":"i","\u0129":"i","\u012B":"i","\u012D":"i","\u00EF":"i","\u1E2F":"i","\u1EC9":"i","\u01D0":"i","\u0209":"i","\u020B":"i","\u1ECB":"i","\u012F":"i","\u1E2D":"i","\u0268":"i","\u0131":"i","\u24D9":"j","\uFF4A":"j","\u0135":"j","\u01F0":"j","\u0249":"j","\u24DA":"k","\uFF4B":"k","\u1E31":"k","\u01E9":"k","\u1E33":"k","\u0137":"k","\u1E35":"k","\u0199":"k","\u2C6A":"k","\uA741":"k","\uA743":"k","\uA745":"k","\uA7A3":"k","\u24DB":"l","\uFF4C":"l","\u0140":"l","\u013A":"l","\u013E":"l","\u1E37":"l","\u1E39":"l","\u013C":"l","\u1E3D":"l","\u1E3B":"l","\u017F":"l","\u0142":"l","\u019A":"l","\u026B":"l","\u2C61":"l","\uA749":"l","\uA781":"l","\uA747":"l","\u01C9":"lj","\u24DC":"m","\uFF4D":"m","\u1E3F":"m","\u1E41":"m","\u1E43":"m","\u0271":"m","\u026F":"m","\u24DD":"n","\uFF4E":"n","\u01F9":"n","\u0144":"n","\u00F1":"n","\u1E45":"n","\u0148":"n","\u1E47":"n","\u0146":"n","\u1E4B":"n","\u1E49":"n","\u019E":"n","\u0272":"n","\u0149":"n","\uA791":"n","\uA7A5":"n","\u01CC":"nj","\u24DE":"o","\uFF4F":"o","\u00F2":"o","\u00F3":"o","\u00F4":"o","\u1ED3":"o","\u1ED1":"o","\u1ED7":"o","\u1ED5":"o","\u00F5":"o","\u1E4D":"o","\u022D":"o","\u1E4F":"o","\u014D":"o","\u1E51":"o","\u1E53":"o","\u014F":"o","\u022F":"o","\u0231":"o","\u00F6":"o","\u022B":"o","\u1ECF":"o","\u0151":"o","\u01D2":"o","\u020D":"o","\u020F":"o","\u01A1":"o","\u1EDD":"o","\u1EDB":"o","\u1EE1":"o","\u1EDF":"o","\u1EE3":"o","\u1ECD":"o","\u1ED9":"o","\u01EB":"o","\u01ED":"o","\u00F8":"o","\u01FF":"o","\u0254":"o","\uA74B":"o","\uA74D":"o","\u0275":"o","\u01A3":"oi","\u0223":"ou","\uA74F":"oo","\u24DF":"p","\uFF50":"p","\u1E55":"p","\u1E57":"p","\u01A5":"p","\u1D7D":"p","\uA751":"p","\uA753":"p","\uA755":"p","\u24E0":"q","\uFF51":"q","\u024B":"q","\uA757":"q","\uA759":"q","\u24E1":"r","\uFF52":"r","\u0155":"r","\u1E59":"r","\u0159":"r","\u0211":"r","\u0213":"r","\u1E5B":"r","\u1E5D":"r","\u0157":"r","\u1E5F":"r","\u024D":"r","\u027D":"r","\uA75B":"r","\uA7A7":"r","\uA783":"r","\u24E2":"s","\uFF53":"s","\u00DF":"s","\u015B":"s","\u1E65":"s","\u015D":"s","\u1E61":"s","\u0161":"s","\u1E67":"s","\u1E63":"s","\u1E69":"s","\u0219":"s","\u015F":"s","\u023F":"s","\uA7A9":"s","\uA785":"s","\u1E9B":"s","\u24E3":"t","\uFF54":"t","\u1E6B":"t","\u1E97":"t","\u0165":"t","\u1E6D":"t","\u021B":"t","\u0163":"t","\u1E71":"t","\u1E6F":"t","\u0167":"t","\u01AD":"t","\u0288":"t","\u2C66":"t","\uA787":"t","\uA729":"tz","\u24E4":"u","\uFF55":"u","\u00F9":"u","\u00FA":"u","\u00FB":"u","\u0169":"u","\u1E79":"u","\u016B":"u","\u1E7B":"u","\u016D":"u","\u00FC":"u","\u01DC":"u","\u01D8":"u","\u01D6":"u","\u01DA":"u","\u1EE7":"u","\u016F":"u","\u0171":"u","\u01D4":"u","\u0215":"u","\u0217":"u","\u01B0":"u","\u1EEB":"u","\u1EE9":"u","\u1EEF":"u","\u1EED":"u","\u1EF1":"u","\u1EE5":"u","\u1E73":"u","\u0173":"u","\u1E77":"u","\u1E75":"u","\u0289":"u","\u24E5":"v","\uFF56":"v","\u1E7D":"v","\u1E7F":"v","\u028B":"v","\uA75F":"v","\u028C":"v","\uA761":"vy","\u24E6":"w","\uFF57":"w","\u1E81":"w","\u1E83":"w","\u0175":"w","\u1E87":"w","\u1E85":"w","\u1E98":"w","\u1E89":"w","\u2C73":"w","\u24E7":"x","\uFF58":"x","\u1E8B":"x","\u1E8D":"x","\u24E8":"y","\uFF59":"y","\u1EF3":"y","\u00FD":"y","\u0177":"y","\u1EF9":"y","\u0233":"y","\u1E8F":"y","\u00FF":"y","\u1EF7":"y","\u1E99":"y","\u1EF5":"y","\u01B4":"y","\u024F":"y","\u1EFF":"y","\u24E9":"z","\uFF5A":"z","\u017A":"z","\u1E91":"z","\u017C":"z","\u017E":"z","\u1E93":"z","\u1E95":"z","\u01B6":"z","\u0225":"z","\u0240":"z","\u2C6C":"z","\uA763":"z","\u0386":"\u0391","\u0388":"\u0395","\u0389":"\u0397","\u038A":"\u0399","\u03AA":"\u0399","\u038C":"\u039F","\u038E":"\u03A5","\u03AB":"\u03A5","\u038F":"\u03A9","\u03AC":"\u03B1","\u03AD":"\u03B5","\u03AE":"\u03B7","\u03AF":"\u03B9","\u03CA":"\u03B9","\u0390":"\u03B9","\u03CC":"\u03BF","\u03CD":"\u03C5","\u03CB":"\u03C5","\u03B0":"\u03C5","\u03C9":"\u03C9","\u03C2":"\u03C3"};

    $document = $(document);

    nextUid=(function() { var counter=1; return function() { return counter++; }; }());


    function reinsertElement(element) {
        var placeholder = $(document.createTextNode(''));

        element.before(placeholder);
        placeholder.before(element);
        placeholder.remove();
    }

    function stripDiacritics(str) {
        // Used 'uni range + named function' from http://jsperf.com/diacritics/18
        function match(a) {
            return DIACRITICS[a] || a;
        }

        return str.replace(/[^\u0000-\u007E]/g, match);
    }

    function indexOf(value, array) {
        var i = 0, l = array.length;
        for (; i < l; i = i + 1) {
            if (equal(value, array[i])) return i;
        }
        return -1;
    }

    function measureScrollbar () {
        var $template = $( MEASURE_SCROLLBAR_TEMPLATE );
        $template.appendTo(document.body);

        var dim = {
            width: $template.width() - $template[0].clientWidth,
            height: $template.height() - $template[0].clientHeight
        };
        $template.remove();

        return dim;
    }

    /**
     * Compares equality of a and b
     * @param a
     * @param b
     */
    function equal(a, b) {
        if (a === b) return true;
        if (a === undefined || b === undefined) return false;
        if (a === null || b === null) return false;
        // Check whether 'a' or 'b' is a string (primitive or object).
        // The concatenation of an empty string (+'') converts its argument to a string's primitive.
        if (a.constructor === String) return a+'' === b+''; // a+'' - in case 'a' is a String object
        if (b.constructor === String) return b+'' === a+''; // b+'' - in case 'b' is a String object
        return false;
    }

    /**
     * Splits the string into an array of values, transforming each value. An empty array is returned for nulls or empty
     * strings
     * @param string
     * @param separator
     */
    function splitVal(string, separator, transform) {
        var val, i, l;
        if (string === null || string.length < 1) return [];
        val = string.split(separator);
        for (i = 0, l = val.length; i < l; i = i + 1) val[i] = transform(val[i]);
        return val;
    }

    function getSideBorderPadding(element) {
        return element.outerWidth(false) - element.width();
    }

    function installKeyUpChangeEvent(element) {
        var key="keyup-change-value";
        element.on("keydown", function () {
            if ($.data(element, key) === undefined) {
                $.data(element, key, element.val());
            }
        });
        element.on("keyup", function () {
            var val= $.data(element, key);
            if (val !== undefined && element.val() !== val) {
                $.removeData(element, key);
                element.trigger("keyup-change");
            }
        });
    }


    /**
     * filters mouse events so an event is fired only if the mouse moved.
     *
     * filters out mouse events that occur when mouse is stationary but
     * the elements under the pointer are scrolled.
     */
    function installFilteredMouseMove(element) {
        element.on("mousemove", function (e) {
            var lastpos = lastMousePosition;
            if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
                $(e.target).trigger("mousemove-filtered", e);
            }
        });
    }

    /**
     * Debounces a function. Returns a function that calls the original fn function only if no invocations have been made
     * within the last quietMillis milliseconds.
     *
     * @param quietMillis number of milliseconds to wait before invoking fn
     * @param fn function to be debounced
     * @param ctx object to be used as this reference within fn
     * @return debounced version of fn
     */
    function debounce(quietMillis, fn, ctx) {
        ctx = ctx || undefined;
        var timeout;
        return function () {
            var args = arguments;
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function() {
                fn.apply(ctx, args);
            }, quietMillis);
        };
    }

    function installDebouncedScroll(threshold, element) {
        var notify = debounce(threshold, function (e) { element.trigger("scroll-debounced", e);});
        element.on("scroll", function (e) {
            if (indexOf(e.target, element.get()) >= 0) notify(e);
        });
    }

    function focus($el) {
        if ($el[0] === document.activeElement) return;

        /* set the focus in a 0 timeout - that way the focus is set after the processing
            of the current event has finished - which seems like the only reliable way
            to set focus */
        window.setTimeout(function() {
            var el=$el[0], pos=$el.val().length, range;

            $el.focus();

            /* make sure el received focus so we do not error out when trying to manipulate the caret.
                sometimes modals or others listeners may steal it after its set */
            var isVisible = (el.offsetWidth > 0 || el.offsetHeight > 0);
            if (isVisible && el === document.activeElement) {

                /* after the focus is set move the caret to the end, necessary when we val()
                    just before setting focus */
                if(el.setSelectionRange)
                {
                    el.setSelectionRange(pos, pos);
                }
                else if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                }
            }
        }, 0);
    }

    function getCursorInfo(el) {
        el = $(el)[0];
        var offset = 0;
        var length = 0;
        if ('selectionStart' in el) {
            offset = el.selectionStart;
            length = el.selectionEnd - offset;
        } else if ('selection' in document) {
            el.focus();
            var sel = document.selection.createRange();
            length = document.selection.createRange().text.length;
            sel.moveStart('character', -el.value.length);
            offset = sel.text.length - length;
        }
        return { offset: offset, length: length };
    }

    function killEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    function killEventImmediately(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
    }

    function measureTextWidth(e) {
        if (!sizer){
            var style = e[0].currentStyle || window.getComputedStyle(e[0], null);
            sizer = $(document.createElement("div")).css({
                position: "absolute",
                left: "-10000px",
                top: "-10000px",
                display: "none",
                fontSize: style.fontSize,
                fontFamily: style.fontFamily,
                fontStyle: style.fontStyle,
                fontWeight: style.fontWeight,
                letterSpacing: style.letterSpacing,
                textTransform: style.textTransform,
                whiteSpace: "nowrap"
            });
            sizer.attr("class","select2-sizer");
            $(document.body).append(sizer);
        }
        sizer.text(e.val());
        return sizer.width();
    }

    function syncCssClasses(dest, src, adapter) {
        var classes, replacements = [], adapted;

        classes = $.trim(dest.attr("class"));

        if (classes) {
            classes = '' + classes; // for IE which returns object

            $(classes.split(/\s+/)).each2(function() {
                if (this.indexOf("select2-") === 0) {
                    replacements.push(this);
                }
            });
        }

        classes = $.trim(src.attr("class"));

        if (classes) {
            classes = '' + classes; // for IE which returns object

            $(classes.split(/\s+/)).each2(function() {
                if (this.indexOf("select2-") !== 0) {
                    adapted = adapter(this);

                    if (adapted) {
                        replacements.push(adapted);
                    }
                }
            });
        }

        dest.attr("class", replacements.join(" "));
    }


    function markMatch(text, term, markup, escapeMarkup) {
        text = text || '';
        var match=stripDiacritics(text.toUpperCase()).indexOf(stripDiacritics(term.toUpperCase())),
            tl=term.length;

        if (match<0) {
            markup.push(escapeMarkup(text));
            return;
        }

        markup.push(escapeMarkup(text.substring(0, match)));
        markup.push("<span class='select2-match'>");
        markup.push(escapeMarkup(text.substring(match, match + tl)));
        markup.push("</span>");
        markup.push(escapeMarkup(text.substring(match + tl, text.length)));
    }

    function defaultEscapeMarkup(markup) {
        var replace_map = {
            '\\': '&#92;',
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            "/": '&#47;'
        };

        return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
            return replace_map[match];
        });
    }

    /**
     * Produces an ajax-based query function
     *
     * @param options object containing configuration parameters
     * @param options.params parameter map for the transport ajax call, can contain such options as cache, jsonpCallback, etc. see $.ajax
     * @param options.transport function that will be used to execute the ajax request. must be compatible with parameters supported by $.ajax
     * @param options.url url for the data
     * @param options.data a function(searchTerm, pageNumber, context) that should return an object containing query string parameters for the above url.
     * @param options.dataType request data type: ajax, jsonp, other datatypes supported by jQuery's $.ajax function or the transport function if specified
     * @param options.quietMillis (optional) milliseconds to wait before making the ajaxRequest, helps debounce the ajax function if invoked too often
     * @param options.results a function(remoteData, pageNumber, query) that converts data returned form the remote request to the format expected by Select2.
     *      The expected format is an object containing the following keys:
     *      results array of objects that will be used as choices
     *      more (optional) boolean indicating whether there are more results available
     *      Example: {results:[{id:1, text:'Red'},{id:2, text:'Blue'}], more:true}
     */
    function ajax(options) {
        var timeout, // current scheduled but not yet executed request
            handler = null,
            quietMillis = options.quietMillis || 100,
            ajaxUrl = options.url,
            self = this;

        return function (query) {
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                var data = options.data, // ajax data function
                    url = ajaxUrl, // ajax url string or function
                    transport = options.transport || $.fn.select2.ajaxDefaults.transport,
                    // deprecated - to be removed in 4.0  - use params instead
                    deprecated = {
                        type: options.type || 'GET', // set type of request (GET or POST)
                        cache: options.cache || false,
                        jsonpCallback: options.jsonpCallback||undefined,
                        dataType: options.dataType||"json"
                    },
                    params = $.extend({}, $.fn.select2.ajaxDefaults.params, deprecated);

                data = data ? data.call(self, query.term, query.page, query.context) : null;
                url = (typeof url === 'function') ? url.call(self, query.term, query.page, query.context) : url;

                if (handler && typeof handler.abort === "function") { handler.abort(); }

                if (options.params) {
                    if ($.isFunction(options.params)) {
                        $.extend(params, options.params.call(self));
                    } else {
                        $.extend(params, options.params);
                    }
                }

                $.extend(params, {
                    url: url,
                    dataType: options.dataType,
                    data: data,
                    success: function (data) {
                        // TODO - replace query.page with query so users have access to term, page, etc.
                        // added query as third paramter to keep backwards compatibility
                        var results = options.results(data, query.page, query);
                        query.callback(results);
                    },
                    error: function(jqXHR, textStatus, errorThrown){
                        var results = {
                            hasError: true,
                            jqXHR: jqXHR,
                            textStatus: textStatus,
                            errorThrown: errorThrown
                        };

                        query.callback(results);
                    }
                });
                handler = transport.call(self, params);
            }, quietMillis);
        };
    }

    /**
     * Produces a query function that works with a local array
     *
     * @param options object containing configuration parameters. The options parameter can either be an array or an
     * object.
     *
     * If the array form is used it is assumed that it contains objects with 'id' and 'text' keys.
     *
     * If the object form is used it is assumed that it contains 'data' and 'text' keys. The 'data' key should contain
     * an array of objects that will be used as choices. These objects must contain at least an 'id' key. The 'text'
     * key can either be a String in which case it is expected that each element in the 'data' array has a key with the
     * value of 'text' which will be used to match choices. Alternatively, text can be a function(item) that can extract
     * the text.
     */
    function local(options) {
        var data = options, // data elements
            dataText,
            tmp,
            text = function (item) { return ""+item.text; }; // function used to retrieve the text portion of a data item that is matched against the search

         if ($.isArray(data)) {
            tmp = data;
            data = { results: tmp };
        }

         if ($.isFunction(data) === false) {
            tmp = data;
            data = function() { return tmp; };
        }

        var dataItem = data();
        if (dataItem.text) {
            text = dataItem.text;
            // if text is not a function we assume it to be a key name
            if (!$.isFunction(text)) {
                dataText = dataItem.text; // we need to store this in a separate variable because in the next step data gets reset and data.text is no longer available
                text = function (item) { return item[dataText]; };
            }
        }

        return function (query) {
            var t = query.term, filtered = { results: [] }, process;
            if (t === "") {
                query.callback(data());
                return;
            }

            process = function(datum, collection) {
                var group, attr;
                datum = datum[0];
                if (datum.children) {
                    group = {};
                    for (attr in datum) {
                        if (datum.hasOwnProperty(attr)) group[attr]=datum[attr];
                    }
                    group.children=[];
                    $(datum.children).each2(function(i, childDatum) { process(childDatum, group.children); });
                    if (group.children.length || query.matcher(t, text(group), datum)) {
                        collection.push(group);
                    }
                } else {
                    if (query.matcher(t, text(datum), datum)) {
                        collection.push(datum);
                    }
                }
            };

            $(data().results).each2(function(i, datum) { process(datum, filtered.results); });
            query.callback(filtered);
        };
    }

    // TODO javadoc
    function tags(data) {
        var isFunc = $.isFunction(data);
        return function (query) {
            var t = query.term, filtered = {results: []};
            var result = isFunc ? data(query) : data;
            if ($.isArray(result)) {
                $(result).each(function () {
                    var isObject = this.text !== undefined,
                        text = isObject ? this.text : this;
                    if (t === "" || query.matcher(t, text)) {
                        filtered.results.push(isObject ? this : {id: this, text: this});
                    }
                });
                query.callback(filtered);
            }
        };
    }

    /**
     * Checks if the formatter function should be used.
     *
     * Throws an error if it is not a function. Returns true if it should be used,
     * false if no formatting should be performed.
     *
     * @param formatter
     */
    function checkFormatter(formatter, formatterName) {
        if ($.isFunction(formatter)) return true;
        if (!formatter) return false;
        if (typeof(formatter) === 'string') return true;
        throw new Error(formatterName +" must be a string, function, or falsy value");
    }

  /**
   * Returns a given value
   * If given a function, returns its output
   *
   * @param val string|function
   * @param context value of "this" to be passed to function
   * @returns {*}
   */
    function evaluate(val, context) {
        if ($.isFunction(val)) {
            var args = Array.prototype.slice.call(arguments, 2);
            return val.apply(context, args);
        }
        return val;
    }

    function countResults(results) {
        var count = 0;
        $.each(results, function(i, item) {
            if (item.children) {
                count += countResults(item.children);
            } else {
                count++;
            }
        });
        return count;
    }

    /**
     * Default tokenizer. This function uses breaks the input on substring match of any string from the
     * opts.tokenSeparators array and uses opts.createSearchChoice to create the choice object. Both of those
     * two options have to be defined in order for the tokenizer to work.
     *
     * @param input text user has typed so far or pasted into the search field
     * @param selection currently selected choices
     * @param selectCallback function(choice) callback tho add the choice to selection
     * @param opts select2's opts
     * @return undefined/null to leave the current input unchanged, or a string to change the input to the returned value
     */
    function defaultTokenizer(input, selection, selectCallback, opts) {
        var original = input, // store the original so we can compare and know if we need to tell the search to update its text
            dupe = false, // check for whether a token we extracted represents a duplicate selected choice
            token, // token
            index, // position at which the separator was found
            i, l, // looping variables
            separator; // the matched separator

        if (!opts.createSearchChoice || !opts.tokenSeparators || opts.tokenSeparators.length < 1) return undefined;

        while (true) {
            index = -1;

            for (i = 0, l = opts.tokenSeparators.length; i < l; i++) {
                separator = opts.tokenSeparators[i];
                index = input.indexOf(separator);
                if (index >= 0) break;
            }

            if (index < 0) break; // did not find any token separator in the input string, bail

            token = input.substring(0, index);
            input = input.substring(index + separator.length);

            if (token.length > 0) {
                token = opts.createSearchChoice.call(this, token, selection);
                if (token !== undefined && token !== null && opts.id(token) !== undefined && opts.id(token) !== null) {
                    dupe = false;
                    for (i = 0, l = selection.length; i < l; i++) {
                        if (equal(opts.id(token), opts.id(selection[i]))) {
                            dupe = true; break;
                        }
                    }

                    if (!dupe) selectCallback(token);
                }
            }
        }

        if (original!==input) return input;
    }

    function cleanupJQueryElements() {
        var self = this;

        $.each(arguments, function (i, element) {
            self[element].remove();
            self[element] = null;
        });
    }

    /**
     * Creates a new class
     *
     * @param superClass
     * @param methods
     */
    function clazz(SuperClass, methods) {
        var constructor = function () {};
        constructor.prototype = new SuperClass;
        constructor.prototype.constructor = constructor;
        constructor.prototype.parent = SuperClass.prototype;
        constructor.prototype = $.extend(constructor.prototype, methods);
        return constructor;
    }

    AbstractSelect2 = clazz(Object, {

        // abstract
        bind: function (func) {
            var self = this;
            return function () {
                func.apply(self, arguments);
            };
        },

        // abstract
        init: function (opts) {
            var results, search, resultsSelector = ".select2-results";

            // prepare options
            this.opts = opts = this.prepareOpts(opts);

            this.id=opts.id;

            // destroy if called on an existing component
            if (opts.element.data("select2") !== undefined &&
                opts.element.data("select2") !== null) {
                opts.element.data("select2").destroy();
            }

            this.container = this.createContainer();

            this.liveRegion = $('.select2-hidden-accessible');
            if (this.liveRegion.length == 0) {
                this.liveRegion = $("<span>", {
                        role: "status",
                        "aria-live": "polite"
                    })
                    .addClass("select2-hidden-accessible")
                    .appendTo(document.body);
            }

            this.containerId="s2id_"+(opts.element.attr("id") || "autogen"+nextUid());
            this.containerEventName= this.containerId
                .replace(/([.])/g, '_')
                .replace(/([;&,\-\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
            this.container.attr("id", this.containerId);

            this.container.attr("title", opts.element.attr("title"));

            this.body = $(document.body);

            syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);

            this.container.attr("style", opts.element.attr("style"));
            this.container.css(evaluate(opts.containerCss, this.opts.element));
            this.container.addClass(evaluate(opts.containerCssClass, this.opts.element));

            this.elementTabIndex = this.opts.element.attr("tabindex");

            // swap container for the element
            this.opts.element
                .data("select2", this)
                .attr("tabindex", "-1")
                .before(this.container)
                .on("click.select2", killEvent); // do not leak click events

            this.container.data("select2", this);

            this.dropdown = this.container.find(".select2-drop");

            syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);

            this.dropdown.addClass(evaluate(opts.dropdownCssClass, this.opts.element));
            this.dropdown.data("select2", this);
            this.dropdown.on("click", killEvent);

            this.results = results = this.container.find(resultsSelector);
            this.search = search = this.container.find("input.select2-input");

            this.queryCount = 0;
            this.resultsPage = 0;
            this.context = null;

            // initialize the container
            this.initContainer();

            this.container.on("click", killEvent);

            installFilteredMouseMove(this.results);

            this.dropdown.on("mousemove-filtered", resultsSelector, this.bind(this.highlightUnderEvent));
            this.dropdown.on("touchstart touchmove touchend", resultsSelector, this.bind(function (event) {
                this._touchEvent = true;
                this.highlightUnderEvent(event);
            }));
            this.dropdown.on("touchmove", resultsSelector, this.bind(this.touchMoved));
            this.dropdown.on("touchstart touchend", resultsSelector, this.bind(this.clearTouchMoved));

            // Waiting for a click event on touch devices to select option and hide dropdown
            // otherwise click will be triggered on an underlying element
            this.dropdown.on('click', this.bind(function (event) {
                if (this._touchEvent) {
                    this._touchEvent = false;
                    this.selectHighlighted();
                }
            }));

            installDebouncedScroll(80, this.results);
            this.dropdown.on("scroll-debounced", resultsSelector, this.bind(this.loadMoreIfNeeded));

            // do not propagate change event from the search field out of the component
            $(this.container).on("change", ".select2-input", function(e) {e.stopPropagation();});
            $(this.dropdown).on("change", ".select2-input", function(e) {e.stopPropagation();});

            // if jquery.mousewheel plugin is installed we can prevent out-of-bounds scrolling of results via mousewheel
            if ($.fn.mousewheel) {
                results.mousewheel(function (e, delta, deltaX, deltaY) {
                    var top = results.scrollTop();
                    if (deltaY > 0 && top - deltaY <= 0) {
                        results.scrollTop(0);
                        killEvent(e);
                    } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
                        results.scrollTop(results.get(0).scrollHeight - results.height());
                        killEvent(e);
                    }
                });
            }

            installKeyUpChangeEvent(search);
            search.on("keyup-change input paste", this.bind(this.updateResults));
            search.on("focus", function () { search.addClass("select2-focused"); });
            search.on("blur", function () { search.removeClass("select2-focused");});

            this.dropdown.on("mouseup", resultsSelector, this.bind(function (e) {
                if ($(e.target).closest(".select2-result-selectable").length > 0) {
                    this.highlightUnderEvent(e);
                    this.selectHighlighted(e);
                }
            }));

            // trap all mouse events from leaving the dropdown. sometimes there may be a modal that is listening
            // for mouse events outside of itself so it can close itself. since the dropdown is now outside the select2's
            // dom it will trigger the popup close, which is not what we want
            // focusin can cause focus wars between modals and select2 since the dropdown is outside the modal.
            this.dropdown.on("click mouseup mousedown touchstart touchend focusin", function (e) { e.stopPropagation(); });

            this.nextSearchTerm = undefined;

            if ($.isFunction(this.opts.initSelection)) {
                // initialize selection based on the current value of the source element
                this.initSelection();

                // if the user has provided a function that can set selection based on the value of the source element
                // we monitor the change event on the element and trigger it, allowing for two way synchronization
                this.monitorSource();
            }

            if (opts.maximumInputLength !== null) {
                this.search.attr("maxlength", opts.maximumInputLength);
            }

            var disabled = opts.element.prop("disabled");
            if (disabled === undefined) disabled = false;
            this.enable(!disabled);

            var readonly = opts.element.prop("readonly");
            if (readonly === undefined) readonly = false;
            this.readonly(readonly);

            // Calculate size of scrollbar
            scrollBarDimensions = scrollBarDimensions || measureScrollbar();

            this.autofocus = opts.element.prop("autofocus");
            opts.element.prop("autofocus", false);
            if (this.autofocus) this.focus();

            this.search.attr("placeholder", opts.searchInputPlaceholder);
        },

        // abstract
        destroy: function () {
            var element=this.opts.element, select2 = element.data("select2"), self = this;

            this.close();

            if (element.length && element[0].detachEvent && self._sync) {
                element.each(function () {
                    if (self._sync) {
                        this.detachEvent("onpropertychange", self._sync);
                    }
                });
            }
            if (this.propertyObserver) {
                this.propertyObserver.disconnect();
                this.propertyObserver = null;
            }
            this._sync = null;

            if (select2 !== undefined) {
                select2.container.remove();
                select2.liveRegion.remove();
                select2.dropdown.remove();
                element
                    .show()
                    .removeData("select2")
                    .off(".select2")
                    .prop("autofocus", this.autofocus || false);
                if (this.elementTabIndex) {
                    element.attr({tabindex: this.elementTabIndex});
                } else {
                    element.removeAttr("tabindex");
                }
                element.show();
            }

            cleanupJQueryElements.call(this,
                "container",
                "liveRegion",
                "dropdown",
                "results",
                "search"
            );
        },

        // abstract
        optionToData: function(element) {
            if (element.is("option")) {
                return {
                    id:element.prop("value"),
                    text:element.text(),
                    element: element.get(),
                    css: element.attr("class"),
                    disabled: element.prop("disabled"),
                    locked: equal(element.attr("locked"), "locked") || equal(element.data("locked"), true)
                };
            } else if (element.is("optgroup")) {
                return {
                    text:element.attr("label"),
                    children:[],
                    element: element.get(),
                    css: element.attr("class")
                };
            }
        },

        // abstract
        prepareOpts: function (opts) {
            var element, select, idKey, ajaxUrl, self = this;

            element = opts.element;

            if (element.get(0).tagName.toLowerCase() === "select") {
                this.select = select = opts.element;
            }

            if (select) {
                // these options are not allowed when attached to a select because they are picked up off the element itself
                $.each(["id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags"], function () {
                    if (this in opts) {
                        throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
                    }
                });
            }

            opts = $.extend({}, {
                populateResults: function(container, results, query) {
                    var populate, id=this.opts.id, liveRegion=this.liveRegion;

                    populate=function(results, container, depth) {

                        var i, l, result, selectable, disabled, compound, node, label, innerContainer, formatted;

                        results = opts.sortResults(results, container, query);

                        // collect the created nodes for bulk append
                        var nodes = [];
                        for (i = 0, l = results.length; i < l; i = i + 1) {

                            result=results[i];

                            disabled = (result.disabled === true);
                            selectable = (!disabled) && (id(result) !== undefined);

                            compound=result.children && result.children.length > 0;

                            node=$("<li></li>");
                            node.addClass("select2-results-dept-"+depth);
                            node.addClass("select2-result");
                            node.addClass(selectable ? "select2-result-selectable" : "select2-result-unselectable");
                            if (disabled) { node.addClass("select2-disabled"); }
                            if (compound) { node.addClass("select2-result-with-children"); }
                            node.addClass(self.opts.formatResultCssClass(result));
                            node.attr("role", "presentation");

                            label=$(document.createElement("div"));
                            label.addClass("select2-result-label");
                            label.attr("id", "select2-result-label-" + nextUid());
                            label.attr("role", "option");

                            formatted=opts.formatResult(result, label, query, self.opts.escapeMarkup);
                            if (formatted!==undefined) {
                                label.html(formatted);
                                node.append(label);
                            }


                            if (compound) {

                                innerContainer=$("<ul></ul>");
                                innerContainer.addClass("select2-result-sub");
                                populate(result.children, innerContainer, depth+1);
                                node.append(innerContainer);
                            }

                            node.data("select2-data", result);
                            nodes.push(node[0]);
                        }

                        // bulk append the created nodes
                        container.append(nodes);
                        liveRegion.text(opts.formatMatches(results.length));
                    };

                    populate(results, container, 0);
                }
            }, $.fn.select2.defaults, opts);

            if (typeof(opts.id) !== "function") {
                idKey = opts.id;
                opts.id = function (e) { return e[idKey]; };
            }

            if ($.isArray(opts.element.data("select2Tags"))) {
                if ("tags" in opts) {
                    throw "tags specified as both an attribute 'data-select2-tags' and in options of Select2 " + opts.element.attr("id");
                }
                opts.tags=opts.element.data("select2Tags");
            }

            if (select) {
                opts.query = this.bind(function (query) {
                    var data = { results: [], more: false },
                        term = query.term,
                        children, placeholderOption, process;

                    process=function(element, collection) {
                        var group;
                        if (element.is("option")) {
                            if (query.matcher(term, element.text(), element)) {
                                collection.push(self.optionToData(element));
                            }
                        } else if (element.is("optgroup")) {
                            group=self.optionToData(element);
                            element.children().each2(function(i, elm) { process(elm, group.children); });
                            if (group.children.length>0) {
                                collection.push(group);
                            }
                        }
                    };

                    children=element.children();

                    // ignore the placeholder option if there is one
                    if (this.getPlaceholder() !== undefined && children.length > 0) {
                        placeholderOption = this.getPlaceholderOption();
                        if (placeholderOption) {
                            children=children.not(placeholderOption);
                        }
                    }

                    children.each2(function(i, elm) { process(elm, data.results); });

                    query.callback(data);
                });
                // this is needed because inside val() we construct choices from options and their id is hardcoded
                opts.id=function(e) { return e.id; };
            } else {
                if (!("query" in opts)) {

                    if ("ajax" in opts) {
                        ajaxUrl = opts.element.data("ajax-url");
                        if (ajaxUrl && ajaxUrl.length > 0) {
                            opts.ajax.url = ajaxUrl;
                        }
                        opts.query = ajax.call(opts.element, opts.ajax);
                    } else if ("data" in opts) {
                        opts.query = local(opts.data);
                    } else if ("tags" in opts) {
                        opts.query = tags(opts.tags);
                        if (opts.createSearchChoice === undefined) {
                            opts.createSearchChoice = function (term) { return {id: $.trim(term), text: $.trim(term)}; };
                        }
                        if (opts.initSelection === undefined) {
                            opts.initSelection = function (element, callback) {
                                var data = [];
                                $(splitVal(element.val(), opts.separator, opts.transformVal)).each(function () {
                                    var obj = { id: this, text: this },
                                        tags = opts.tags;
                                    if ($.isFunction(tags)) tags=tags();
                                    $(tags).each(function() { if (equal(this.id, obj.id)) { obj = this; return false; } });
                                    data.push(obj);
                                });

                                callback(data);
                            };
                        }
                    }
                }
            }
            if (typeof(opts.query) !== "function") {
                throw "query function not defined for Select2 " + opts.element.attr("id");
            }

            if (opts.createSearchChoicePosition === 'top') {
                opts.createSearchChoicePosition = function(list, item) { list.unshift(item); };
            }
            else if (opts.createSearchChoicePosition === 'bottom') {
                opts.createSearchChoicePosition = function(list, item) { list.push(item); };
            }
            else if (typeof(opts.createSearchChoicePosition) !== "function")  {
                throw "invalid createSearchChoicePosition option must be 'top', 'bottom' or a custom function";
            }

            return opts;
        },

        /**
         * Monitor the original element for changes and update select2 accordingly
         */
        // abstract
        monitorSource: function () {
            var el = this.opts.element, observer, self = this;

            el.on("change.select2", this.bind(function (e) {
                if (this.opts.element.data("select2-change-triggered") !== true) {
                    this.initSelection();
                }
            }));

            this._sync = this.bind(function () {

                // sync enabled state
                var disabled = el.prop("disabled");
                if (disabled === undefined) disabled = false;
                this.enable(!disabled);

                var readonly = el.prop("readonly");
                if (readonly === undefined) readonly = false;
                this.readonly(readonly);

                if (this.container) {
                    syncCssClasses(this.container, this.opts.element, this.opts.adaptContainerCssClass);
                    this.container.addClass(evaluate(this.opts.containerCssClass, this.opts.element));
                }

                if (this.dropdown) {
                    syncCssClasses(this.dropdown, this.opts.element, this.opts.adaptDropdownCssClass);
                    this.dropdown.addClass(evaluate(this.opts.dropdownCssClass, this.opts.element));
                }

            });

            // IE8-10 (IE9/10 won't fire propertyChange via attachEventListener)
            if (el.length && el[0].attachEvent) {
                el.each(function() {
                    this.attachEvent("onpropertychange", self._sync);
                });
            }

            // safari, chrome, firefox, IE11
            observer = window.MutationObserver || window.WebKitMutationObserver|| window.MozMutationObserver;
            if (observer !== undefined) {
                if (this.propertyObserver) { delete this.propertyObserver; this.propertyObserver = null; }
                this.propertyObserver = new observer(function (mutations) {
                    $.each(mutations, self._sync);
                });
                this.propertyObserver.observe(el.get(0), { attributes:true, subtree:false });
            }
        },

        // abstract
        triggerSelect: function(data) {
            var evt = $.Event("select2-selecting", { val: this.id(data), object: data, choice: data });
            this.opts.element.trigger(evt);
            return !evt.isDefaultPrevented();
        },

        /**
         * Triggers the change event on the source element
         */
        // abstract
        triggerChange: function (details) {

            details = details || {};
            details= $.extend({}, details, { type: "change", val: this.val() });
            // prevents recursive triggering
            this.opts.element.data("select2-change-triggered", true);
            this.opts.element.trigger(details);
            this.opts.element.data("select2-change-triggered", false);

            // some validation frameworks ignore the change event and listen instead to keyup, click for selects
            // so here we trigger the click event manually
            this.opts.element.click();

            // ValidationEngine ignores the change event and listens instead to blur
            // so here we trigger the blur event manually if so desired
            if (this.opts.blurOnChange)
                this.opts.element.blur();
        },

        //abstract
        isInterfaceEnabled: function()
        {
            return this.enabledInterface === true;
        },

        // abstract
        enableInterface: function() {
            var enabled = this._enabled && !this._readonly,
                disabled = !enabled;

            if (enabled === this.enabledInterface) return false;

            this.container.toggleClass("select2-container-disabled", disabled);
            this.close();
            this.enabledInterface = enabled;

            return true;
        },

        // abstract
        enable: function(enabled) {
            if (enabled === undefined) enabled = true;
            if (this._enabled === enabled) return;
            this._enabled = enabled;

            this.opts.element.prop("disabled", !enabled);
            this.enableInterface();
        },

        // abstract
        disable: function() {
            this.enable(false);
        },

        // abstract
        readonly: function(enabled) {
            if (enabled === undefined) enabled = false;
            if (this._readonly === enabled) return;
            this._readonly = enabled;

            this.opts.element.prop("readonly", enabled);
            this.enableInterface();
        },

        // abstract
        opened: function () {
            return (this.container) ? this.container.hasClass("select2-dropdown-open") : false;
        },

        // abstract
        positionDropdown: function() {
            var $dropdown = this.dropdown,
                container = this.container,
                offset = container.offset(),
                height = container.outerHeight(false),
                width = container.outerWidth(false),
                dropHeight = $dropdown.outerHeight(false),
                $window = $(window),
                windowWidth = $window.width(),
                windowHeight = $window.height(),
                viewPortRight = $window.scrollLeft() + windowWidth,
                viewportBottom = $window.scrollTop() + windowHeight,
                dropTop = offset.top + height,
                dropLeft = offset.left,
                enoughRoomBelow = dropTop + dropHeight <= viewportBottom,
                enoughRoomAbove = (offset.top - dropHeight) >= $window.scrollTop(),
                dropWidth = $dropdown.outerWidth(false),
                enoughRoomOnRight = function() {
                    return dropLeft + dropWidth <= viewPortRight;
                },
                enoughRoomOnLeft = function() {
                    return offset.left + viewPortRight + container.outerWidth(false)  > dropWidth;
                },
                aboveNow = $dropdown.hasClass("select2-drop-above"),
                bodyOffset,
                above,
                changeDirection,
                css,
                resultsListNode;

            // always prefer the current above/below alignment, unless there is not enough room
            if (aboveNow) {
                above = true;
                if (!enoughRoomAbove && enoughRoomBelow) {
                    changeDirection = true;
                    above = false;
                }
            } else {
                above = false;
                if (!enoughRoomBelow && enoughRoomAbove) {
                    changeDirection = true;
                    above = true;
                }
            }

            //if we are changing direction we need to get positions when dropdown is hidden;
            if (changeDirection) {
                $dropdown.hide();
                offset = this.container.offset();
                height = this.container.outerHeight(false);
                width = this.container.outerWidth(false);
                dropHeight = $dropdown.outerHeight(false);
                viewPortRight = $window.scrollLeft() + windowWidth;
                viewportBottom = $window.scrollTop() + windowHeight;
                dropTop = offset.top + height;
                dropLeft = offset.left;
                dropWidth = $dropdown.outerWidth(false);
                $dropdown.show();

                // fix so the cursor does not move to the left within the search-textbox in IE
                this.focusSearch();
            }

            if (this.opts.dropdownAutoWidth) {
                resultsListNode = $('.select2-results', $dropdown)[0];
                $dropdown.addClass('select2-drop-auto-width');
                $dropdown.css('width', '');
                // Add scrollbar width to dropdown if vertical scrollbar is present
                dropWidth = $dropdown.outerWidth(false) + (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : scrollBarDimensions.width);
                dropWidth > width ? width = dropWidth : dropWidth = width;
                dropHeight = $dropdown.outerHeight(false);
            }
            else {
                this.container.removeClass('select2-drop-auto-width');
            }

            //console.log("below/ droptop:", dropTop, "dropHeight", dropHeight, "sum", (dropTop+dropHeight)+" viewport bottom", viewportBottom, "enough?", enoughRoomBelow);
            //console.log("above/ offset.top", offset.top, "dropHeight", dropHeight, "top", (offset.top-dropHeight), "scrollTop", this.body.scrollTop(), "enough?", enoughRoomAbove);

            // fix positioning when body has an offset and is not position: static
            if (this.body.css('position') !== 'static') {
                bodyOffset = this.body.offset();
                dropTop -= bodyOffset.top;
                dropLeft -= bodyOffset.left;
            }

            if (!enoughRoomOnRight() && enoughRoomOnLeft()) {
                dropLeft = offset.left + this.container.outerWidth(false) - dropWidth;
            }

            css =  {
                left: dropLeft,
                width: width
            };

            if (above) {
                css.top = offset.top - dropHeight;
                css.bottom = 'auto';
                this.container.addClass("select2-drop-above");
                $dropdown.addClass("select2-drop-above");
            }
            else {
                css.top = dropTop;
                css.bottom = 'auto';
                this.container.removeClass("select2-drop-above");
                $dropdown.removeClass("select2-drop-above");
            }
            css = $.extend(css, evaluate(this.opts.dropdownCss, this.opts.element));

            $dropdown.css(css);
        },

        // abstract
        shouldOpen: function() {
            var event;

            if (this.opened()) return false;

            if (this._enabled === false || this._readonly === true) return false;

            event = $.Event("select2-opening");
            this.opts.element.trigger(event);
            return !event.isDefaultPrevented();
        },

        // abstract
        clearDropdownAlignmentPreference: function() {
            // clear the classes used to figure out the preference of where the dropdown should be opened
            this.container.removeClass("select2-drop-above");
            this.dropdown.removeClass("select2-drop-above");
        },

        /**
         * Opens the dropdown
         *
         * @return {Boolean} whether or not dropdown was opened. This method will return false if, for example,
         * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
         */
        // abstract
        open: function () {

            if (!this.shouldOpen()) return false;

            this.opening();

            // Only bind the document mousemove when the dropdown is visible
            $document.on("mousemove.select2Event", function (e) {
                lastMousePosition.x = e.pageX;
                lastMousePosition.y = e.pageY;
            });

            return true;
        },

        /**
         * Performs the opening of the dropdown
         */
        // abstract
        opening: function() {
            var cid = this.containerEventName,
                scroll = "scroll." + cid,
                resize = "resize."+cid,
                orient = "orientationchange."+cid,
                mask;

            this.container.addClass("select2-dropdown-open").addClass("select2-container-active");

            this.clearDropdownAlignmentPreference();

            if(this.dropdown[0] !== this.body.children().last()[0]) {
                this.dropdown.detach().appendTo(this.body);
            }

            // create the dropdown mask if doesn't already exist
            mask = $("#select2-drop-mask");
            if (mask.length === 0) {
                mask = $(document.createElement("div"));
                mask.attr("id","select2-drop-mask").attr("class","select2-drop-mask");
                mask.hide();
                mask.appendTo(this.body);
                mask.on("mousedown touchstart click", function (e) {
                    // Prevent IE from generating a click event on the body
                    reinsertElement(mask);

                    var dropdown = $("#select2-drop"), self;
                    if (dropdown.length > 0) {
                        self=dropdown.data("select2");
                        if (self.opts.selectOnBlur) {
                            self.selectHighlighted({noFocus: true});
                        }
                        self.close();
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
            }

            // ensure the mask is always right before the dropdown
            if (this.dropdown.prev()[0] !== mask[0]) {
                this.dropdown.before(mask);
            }

            // move the global id to the correct dropdown
            $("#select2-drop").removeAttr("id");
            this.dropdown.attr("id", "select2-drop");

            // show the elements
            mask.show();

            this.positionDropdown();
            this.dropdown.show();
            this.positionDropdown();

            this.dropdown.addClass("select2-drop-active");

            // attach listeners to events that can change the position of the container and thus require
            // the position of the dropdown to be updated as well so it does not come unglued from the container
            var that = this;
            this.container.parents().add(window).each(function () {
                $(this).on(resize+" "+scroll+" "+orient, function (e) {
                    if (that.opened()) that.positionDropdown();
                });
            });


        },

        // abstract
        close: function () {
            if (!this.opened()) return;

            var cid = this.containerEventName,
                scroll = "scroll." + cid,
                resize = "resize."+cid,
                orient = "orientationchange."+cid;

            // unbind event listeners
            this.container.parents().add(window).each(function () { $(this).off(scroll).off(resize).off(orient); });

            this.clearDropdownAlignmentPreference();

            $("#select2-drop-mask").hide();
            this.dropdown.removeAttr("id"); // only the active dropdown has the select2-drop id
            this.dropdown.hide();
            this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");
            this.results.empty();

            // Now that the dropdown is closed, unbind the global document mousemove event
            $document.off("mousemove.select2Event");

            this.clearSearch();
            this.search.removeClass("select2-active");
            this.opts.element.trigger($.Event("select2-close"));
        },

        /**
         * Opens control, sets input value, and updates results.
         */
        // abstract
        externalSearch: function (term) {
            this.open();
            this.search.val(term);
            this.updateResults(false);
        },

        // abstract
        clearSearch: function () {

        },

        //abstract
        getMaximumSelectionSize: function() {
            return evaluate(this.opts.maximumSelectionSize, this.opts.element);
        },

        // abstract
        ensureHighlightVisible: function () {
            var results = this.results, children, index, child, hb, rb, y, more, topOffset;

            index = this.highlight();

            if (index < 0) return;

            if (index == 0) {

                // if the first element is highlighted scroll all the way to the top,
                // that way any unselectable headers above it will also be scrolled
                // into view

                results.scrollTop(0);
                return;
            }

            children = this.findHighlightableChoices().find('.select2-result-label');

            child = $(children[index]);

            topOffset = (child.offset() || {}).top || 0;

            hb = topOffset + child.outerHeight(true);

            // if this is the last child lets also make sure select2-more-results is visible
            if (index === children.length - 1) {
                more = results.find("li.select2-more-results");
                if (more.length > 0) {
                    hb = more.offset().top + more.outerHeight(true);
                }
            }

            rb = results.offset().top + results.outerHeight(false);
            if (hb > rb) {
                results.scrollTop(results.scrollTop() + (hb - rb));
            }
            y = topOffset - results.offset().top;

            // make sure the top of the element is visible
            if (y < 0 && child.css('display') != 'none' ) {
                results.scrollTop(results.scrollTop() + y); // y is negative
            }
        },

        // abstract
        findHighlightableChoices: function() {
            return this.results.find(".select2-result-selectable:not(.select2-disabled):not(.select2-selected)");
        },

        // abstract
        moveHighlight: function (delta) {
            var choices = this.findHighlightableChoices(),
                index = this.highlight();

            while (index > -1 && index < choices.length) {
                index += delta;
                var choice = $(choices[index]);
                if (choice.hasClass("select2-result-selectable") && !choice.hasClass("select2-disabled") && !choice.hasClass("select2-selected")) {
                    this.highlight(index);
                    break;
                }
            }
        },

        // abstract
        highlight: function (index) {
            var choices = this.findHighlightableChoices(),
                choice,
                data;

            if (arguments.length === 0) {
                return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
            }

            if (index >= choices.length) index = choices.length - 1;
            if (index < 0) index = 0;

            this.removeHighlight();

            choice = $(choices[index]);
            choice.addClass("select2-highlighted");

            // ensure assistive technology can determine the active choice
            this.search.attr("aria-activedescendant", choice.find(".select2-result-label").attr("id"));

            this.ensureHighlightVisible();

            this.liveRegion.text(choice.text());

            data = choice.data("select2-data");
            if (data) {
                this.opts.element.trigger({ type: "select2-highlight", val: this.id(data), choice: data });
            }
        },

        removeHighlight: function() {
            this.results.find(".select2-highlighted").removeClass("select2-highlighted");
        },

        touchMoved: function() {
            this._touchMoved = true;
        },

        clearTouchMoved: function() {
          this._touchMoved = false;
        },

        // abstract
        countSelectableResults: function() {
            return this.findHighlightableChoices().length;
        },

        // abstract
        highlightUnderEvent: function (event) {
            var el = $(event.target).closest(".select2-result-selectable");
            if (el.length > 0 && !el.is(".select2-highlighted")) {
                var choices = this.findHighlightableChoices();
                this.highlight(choices.index(el));
            } else if (el.length == 0) {
                // if we are over an unselectable item remove all highlights
                this.removeHighlight();
            }
        },

        // abstract
        loadMoreIfNeeded: function () {
            var results = this.results,
                more = results.find("li.select2-more-results"),
                below, // pixels the element is below the scroll fold, below==0 is when the element is starting to be visible
                page = this.resultsPage + 1,
                self=this,
                term=this.search.val(),
                context=this.context;

            if (more.length === 0) return;
            below = more.offset().top - results.offset().top - results.height();

            if (below <= this.opts.loadMorePadding) {
                more.addClass("select2-active");
                this.opts.query({
                        element: this.opts.element,
                        term: term,
                        page: page,
                        context: context,
                        matcher: this.opts.matcher,
                        callback: this.bind(function (data) {

                    // ignore a response if the select2 has been closed before it was received
                    if (!self.opened()) return;


                    self.opts.populateResults.call(this, results, data.results, {term: term, page: page, context:context});
                    self.postprocessResults(data, false, false);

                    if (data.more===true) {
                        more.detach().appendTo(results).html(self.opts.escapeMarkup(evaluate(self.opts.formatLoadMore, self.opts.element, page+1)));
                        window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                    } else {
                        more.remove();
                    }
                    self.positionDropdown();
                    self.resultsPage = page;
                    self.context = data.context;
                    this.opts.element.trigger({ type: "select2-loaded", items: data });
                })});
            }
        },

        /**
         * Default tokenizer function which does nothing
         */
        tokenize: function() {

        },

        /**
         * @param initial whether or not this is the call to this method right after the dropdown has been opened
         */
        // abstract
        updateResults: function (initial) {
            var search = this.search,
                results = this.results,
                opts = this.opts,
                data,
                self = this,
                input,
                term = search.val(),
                lastTerm = $.data(this.container, "select2-last-term"),
                // sequence number used to drop out-of-order responses
                queryNumber;

            // prevent duplicate queries against the same term
            if (initial !== true && lastTerm && equal(term, lastTerm)) return;

            $.data(this.container, "select2-last-term", term);

            // if the search is currently hidden we do not alter the results
            if (initial !== true && (this.showSearchInput === false || !this.opened())) {
                return;
            }

            function postRender() {
                search.removeClass("select2-active");
                self.positionDropdown();
                if (results.find('.select2-no-results,.select2-selection-limit,.select2-searching').length) {
                    self.liveRegion.text(results.text());
                }
                else {
                    self.liveRegion.text(self.opts.formatMatches(results.find('.select2-result-selectable:not(".select2-selected")').length));
                }
            }

            function render(html) {
                results.html(html);
                postRender();
            }

            queryNumber = ++this.queryCount;

            var maxSelSize = this.getMaximumSelectionSize();
            if (maxSelSize >=1) {
                data = this.data();
                if ($.isArray(data) && data.length >= maxSelSize && checkFormatter(opts.formatSelectionTooBig, "formatSelectionTooBig")) {
                    render("<li class='select2-selection-limit'>" + evaluate(opts.formatSelectionTooBig, opts.element, maxSelSize) + "</li>");
                    return;
                }
            }

            if (search.val().length < opts.minimumInputLength) {
                if (checkFormatter(opts.formatInputTooShort, "formatInputTooShort")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooShort, opts.element, search.val(), opts.minimumInputLength) + "</li>");
                } else {
                    render("");
                }
                if (initial && this.showSearch) this.showSearch(true);
                return;
            }

            if (opts.maximumInputLength && search.val().length > opts.maximumInputLength) {
                if (checkFormatter(opts.formatInputTooLong, "formatInputTooLong")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatInputTooLong, opts.element, search.val(), opts.maximumInputLength) + "</li>");
                } else {
                    render("");
                }
                return;
            }

            if (opts.formatSearching && this.findHighlightableChoices().length === 0) {
                render("<li class='select2-searching'>" + evaluate(opts.formatSearching, opts.element) + "</li>");
            }

            search.addClass("select2-active");

            this.removeHighlight();

            // give the tokenizer a chance to pre-process the input
            input = this.tokenize();
            if (input != undefined && input != null) {
                search.val(input);
            }

            this.resultsPage = 1;

            opts.query({
                element: opts.element,
                    term: search.val(),
                    page: this.resultsPage,
                    context: null,
                    matcher: opts.matcher,
                    callback: this.bind(function (data) {
                var def; // default choice

                // ignore old responses
                if (queryNumber != this.queryCount) {
                  return;
                }

                // ignore a response if the select2 has been closed before it was received
                if (!this.opened()) {
                    this.search.removeClass("select2-active");
                    return;
                }

                // handle ajax error
                if(data.hasError !== undefined && checkFormatter(opts.formatAjaxError, "formatAjaxError")) {
                    render("<li class='select2-ajax-error'>" + evaluate(opts.formatAjaxError, opts.element, data.jqXHR, data.textStatus, data.errorThrown) + "</li>");
                    return;
                }

                // save context, if any
                this.context = (data.context===undefined) ? null : data.context;
                // create a default choice and prepend it to the list
                if (this.opts.createSearchChoice && search.val() !== "") {
                    def = this.opts.createSearchChoice.call(self, search.val(), data.results);
                    if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
                        if ($(data.results).filter(
                            function () {
                                return equal(self.id(this), self.id(def));
                            }).length === 0) {
                            this.opts.createSearchChoicePosition(data.results, def);
                        }
                    }
                }

                if (data.results.length === 0 && checkFormatter(opts.formatNoMatches, "formatNoMatches")) {
                    render("<li class='select2-no-results'>" + evaluate(opts.formatNoMatches, opts.element, search.val()) + "</li>");
                    return;
                }

                results.empty();
                self.opts.populateResults.call(this, results, data.results, {term: search.val(), page: this.resultsPage, context:null});

                if (data.more === true && checkFormatter(opts.formatLoadMore, "formatLoadMore")) {
                    results.append("<li class='select2-more-results'>" + opts.escapeMarkup(evaluate(opts.formatLoadMore, opts.element, this.resultsPage)) + "</li>");
                    window.setTimeout(function() { self.loadMoreIfNeeded(); }, 10);
                }

                this.postprocessResults(data, initial);

                postRender();

                this.opts.element.trigger({ type: "select2-loaded", items: data });
            })});
        },

        // abstract
        cancel: function () {
            this.close();
        },

        // abstract
        blur: function () {
            // if selectOnBlur == true, select the currently highlighted option
            if (this.opts.selectOnBlur)
                this.selectHighlighted({noFocus: true});

            this.close();
            this.container.removeClass("select2-container-active");
            // synonymous to .is(':focus'), which is available in jquery >= 1.6
            if (this.search[0] === document.activeElement) { this.search.blur(); }
            this.clearSearch();
            this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
        },

        // abstract
        focusSearch: function () {
            focus(this.search);
        },

        // abstract
        selectHighlighted: function (options) {
            if (this._touchMoved) {
              this.clearTouchMoved();
              return;
            }
            var index=this.highlight(),
                highlighted=this.results.find(".select2-highlighted"),
                data = highlighted.closest('.select2-result').data("select2-data");

            if (data) {
                this.highlight(index);
                this.onSelect(data, options);
            } else if (options && options.noFocus) {
                this.close();
            }
        },

        // abstract
        getPlaceholder: function () {
            var placeholderOption;
            return this.opts.element.attr("placeholder") ||
                this.opts.element.attr("data-placeholder") || // jquery 1.4 compat
                this.opts.element.data("placeholder") ||
                this.opts.placeholder ||
                ((placeholderOption = this.getPlaceholderOption()) !== undefined ? placeholderOption.text() : undefined);
        },

        // abstract
        getPlaceholderOption: function() {
            if (this.select) {
                var firstOption = this.select.children('option').first();
                if (this.opts.placeholderOption !== undefined ) {
                    //Determine the placeholder option based on the specified placeholderOption setting
                    return (this.opts.placeholderOption === "first" && firstOption) ||
                           (typeof this.opts.placeholderOption === "function" && this.opts.placeholderOption(this.select));
                } else if ($.trim(firstOption.text()) === "" && firstOption.val() === "") {
                    //No explicit placeholder option specified, use the first if it's blank
                    return firstOption;
                }
            }
        },

        /**
         * Get the desired width for the container element.  This is
         * derived first from option `width` passed to select2, then
         * the inline 'style' on the original element, and finally
         * falls back to the jQuery calculated element width.
         */
        // abstract
        initContainerWidth: function () {
            function resolveContainerWidth() {
                var style, attrs, matches, i, l, attr;

                if (this.opts.width === "off") {
                    return null;
                } else if (this.opts.width === "element"){
                    return this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px';
                } else if (this.opts.width === "copy" || this.opts.width === "resolve") {
                    // check if there is inline style on the element that contains width
                    style = this.opts.element.attr('style');
                    if (style !== undefined) {
                        attrs = style.split(';');
                        for (i = 0, l = attrs.length; i < l; i = i + 1) {
                            attr = attrs[i].replace(/\s/g, '');
                            matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
                            if (matches !== null && matches.length >= 1)
                                return matches[1];
                        }
                    }

                    if (this.opts.width === "resolve") {
                        // next check if css('width') can resolve a width that is percent based, this is sometimes possible
                        // when attached to input type=hidden or elements hidden via css
                        style = this.opts.element.css('width');
                        if (style.indexOf("%") > 0) return style;

                        // finally, fallback on the calculated width of the element
                        return (this.opts.element.outerWidth(false) === 0 ? 'auto' : this.opts.element.outerWidth(false) + 'px');
                    }

                    return null;
                } else if ($.isFunction(this.opts.width)) {
                    return this.opts.width();
                } else {
                    return this.opts.width;
               }
            };

            var width = resolveContainerWidth.call(this);
            if (width !== null) {
                this.container.css("width", width);
            }
        }
    });

    SingleSelect2 = clazz(AbstractSelect2, {

        // single

        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container"
            }).html([
                "<a href='javascript:void(0)' class='select2-choice' tabindex='-1'>",
                "   <span class='select2-chosen'>&#160;</span><abbr class='select2-search-choice-close'></abbr>",
                "   <span class='select2-arrow' role='presentation'><b role='presentation'></b></span>",
                "</a>",
                "<label for='' class='select2-offscreen'></label>",
                "<input class='select2-focusser select2-offscreen' type='text' aria-haspopup='true' role='button' />",
                "<div class='select2-drop select2-display-none'>",
                "   <div class='select2-search'>",
                "       <label for='' class='select2-offscreen'></label>",
                "       <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input' role='combobox' aria-expanded='true'",
                "       aria-autocomplete='list' />",
                "   </div>",
                "   <ul class='select2-results' role='listbox'>",
                "   </ul>",
                "</div>"].join(""));
            return container;
        },

        // single
        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.focusser.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        // single
        opening: function () {
            var el, range, len;

            if (this.opts.minimumResultsForSearch >= 0) {
                this.showSearch(true);
            }

            this.parent.opening.apply(this, arguments);

            if (this.showSearchInput !== false) {
                // IE appends focusser.val() at the end of field :/ so we manually insert it at the beginning using a range
                // all other browsers handle this just fine

                this.search.val(this.focusser.val());
            }
            if (this.opts.shouldFocusInput(this)) {
                this.search.focus();
                // move the cursor to the end after focussing, otherwise it will be at the beginning and
                // new text will appear *before* focusser.val()
                el = this.search.get(0);
                if (el.createTextRange) {
                    range = el.createTextRange();
                    range.collapse(false);
                    range.select();
                } else if (el.setSelectionRange) {
                    len = this.search.val().length;
                    el.setSelectionRange(len, len);
                }
            }

            // initializes search's value with nextSearchTerm (if defined by user)
            // ignore nextSearchTerm if the dropdown is opened by the user pressing a letter
            if(this.search.val() === "") {
                if(this.nextSearchTerm != undefined){
                    this.search.val(this.nextSearchTerm);
                    this.search.select();
                }
            }

            this.focusser.prop("disabled", true).val("");
            this.updateResults(true);
            this.opts.element.trigger($.Event("select2-open"));
        },

        // single
        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);

            this.focusser.prop("disabled", false);

            if (this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
        },

        // single
        focus: function () {
            if (this.opened()) {
                this.close();
            } else {
                this.focusser.prop("disabled", false);
                if (this.opts.shouldFocusInput(this)) {
                    this.focusser.focus();
                }
            }
        },

        // single
        isFocused: function () {
            return this.container.hasClass("select2-container-active");
        },

        // single
        cancel: function () {
            this.parent.cancel.apply(this, arguments);
            this.focusser.prop("disabled", false);

            if (this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }
        },

        // single
        destroy: function() {
            $("label[for='" + this.focusser.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);

            cleanupJQueryElements.call(this,
                "selection",
                "focusser"
            );
        },

        // single
        initContainer: function () {

            var selection,
                container = this.container,
                dropdown = this.dropdown,
                idSuffix = nextUid(),
                elementLabel;

            if (this.opts.minimumResultsForSearch < 0) {
                this.showSearch(false);
            } else {
                this.showSearch(true);
            }

            this.selection = selection = container.find(".select2-choice");

            this.focusser = container.find(".select2-focusser");

            // add aria associations
            selection.find(".select2-chosen").attr("id", "select2-chosen-"+idSuffix);
            this.focusser.attr("aria-labelledby", "select2-chosen-"+idSuffix);
            this.results.attr("id", "select2-results-"+idSuffix);
            this.search.attr("aria-owns", "select2-results-"+idSuffix);

            // rewrite labels from original element to focusser
            this.focusser.attr("id", "s2id_autogen"+idSuffix);

            elementLabel = $("label[for='" + this.opts.element.attr("id") + "']");
            this.opts.element.focus(this.bind(function () { this.focus(); }));

            this.focusser.prev()
                .text(elementLabel.text())
                .attr('for', this.focusser.attr('id'));

            // Ensure the original element retains an accessible name
            var originalTitle = this.opts.element.attr("title");
            this.opts.element.attr("title", (originalTitle || elementLabel.text()));

            this.focusser.attr("tabindex", this.elementTabIndex);

            // write label for search field using the label from the focusser element
            this.search.attr("id", this.focusser.attr('id') + '_search');

            this.search.prev()
                .text($("label[for='" + this.focusser.attr('id') + "']").text())
                .attr('for', this.search.attr('id'));

            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                // filter 229 keyCodes (input method editor is processing key input)
                if (229 == e.keyCode) return;

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                    return;
                }

                switch (e.which) {
                    case KEY.UP:
                    case KEY.DOWN:
                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                        killEvent(e);
                        return;
                    case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;
                    case KEY.TAB:
                        this.selectHighlighted({noFocus: true});
                        return;
                    case KEY.ESC:
                        this.cancel(e);
                        killEvent(e);
                        return;
                }
            }));

            this.search.on("blur", this.bind(function(e) {
                // a workaround for chrome to keep the search field focussed when the scroll bar is used to scroll the dropdown.
                // without this the search field loses focus which is annoying
                if (document.activeElement === this.body.get(0)) {
                    window.setTimeout(this.bind(function() {
                        if (this.opened()) {
                            this.search.focus();
                        }
                    }), 0);
                }
            }));

            this.focusser.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                    return;
                }

                if (this.opts.openOnEnter === false && e.which === KEY.ENTER) {
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DOWN || e.which == KEY.UP
                    || (e.which == KEY.ENTER && this.opts.openOnEnter)) {

                    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) return;

                    this.open();
                    killEvent(e);
                    return;
                }

                if (e.which == KEY.DELETE || e.which == KEY.BACKSPACE) {
                    if (this.opts.allowClear) {
                        this.clear();
                    }
                    killEvent(e);
                    return;
                }
            }));


            installKeyUpChangeEvent(this.focusser);
            this.focusser.on("keyup-change input", this.bind(function(e) {
                if (this.opts.minimumResultsForSearch >= 0) {
                    e.stopPropagation();
                    if (this.opened()) return;
                    this.open();
                }
            }));

            selection.on("mousedown touchstart", "abbr", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) {
                    return;
                }

                this.clear();
                killEventImmediately(e);
                this.close();

                if (this.selection) {
                    this.selection.focus();
                }
            }));

            selection.on("mousedown touchstart", this.bind(function (e) {
                // Prevent IE from generating a click event on the body
                reinsertElement(selection);

                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }

                if (this.opened()) {
                    this.close();
                } else if (this.isInterfaceEnabled()) {
                    this.open();
                }

                killEvent(e);
            }));

            dropdown.on("mousedown touchstart", this.bind(function() {
                if (this.opts.shouldFocusInput(this)) {
                    this.search.focus();
                }
            }));

            selection.on("focus", this.bind(function(e) {
                killEvent(e);
            }));

            this.focusser.on("focus", this.bind(function(){
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            })).on("blur", this.bind(function() {
                if (!this.opened()) {
                    this.container.removeClass("select2-container-active");
                    this.opts.element.trigger($.Event("select2-blur"));
                }
            }));
            this.search.on("focus", this.bind(function(){
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
            }));

            this.initContainerWidth();
            this.opts.element.hide();
            this.setPlaceholder();

        },

        // single
        clear: function(triggerChange) {
            var data=this.selection.data("select2-data");
            if (data) { // guard against queued quick consecutive clicks
                var evt = $.Event("select2-clearing");
                this.opts.element.trigger(evt);
                if (evt.isDefaultPrevented()) {
                    return;
                }
                var placeholderOption = this.getPlaceholderOption();
                this.opts.element.val(placeholderOption ? placeholderOption.val() : "");
                this.selection.find(".select2-chosen").empty();
                this.selection.removeData("select2-data");
                this.setPlaceholder();

                if (triggerChange !== false){
                    this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
                    this.triggerChange({removed:data});
                }
            }
        },

        /**
         * Sets selection based on source element's value
         */
        // single
        initSelection: function () {
            var selected;
            if (this.isPlaceholderOptionSelected()) {
                this.updateSelection(null);
                this.close();
                this.setPlaceholder();
            } else {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(selected){
                    if (selected !== undefined && selected !== null) {
                        self.updateSelection(selected);
                        self.close();
                        self.setPlaceholder();
                        self.nextSearchTerm = self.opts.nextSearchTerm(selected, self.search.val());
                    }
                });
            }
        },

        isPlaceholderOptionSelected: function() {
            var placeholderOption;
            if (this.getPlaceholder() === undefined) return false; // no placeholder specified so no option should be considered
            return ((placeholderOption = this.getPlaceholderOption()) !== undefined && placeholderOption.prop("selected"))
                || (this.opts.element.val() === "")
                || (this.opts.element.val() === undefined)
                || (this.opts.element.val() === null);
        },

        // single
        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self=this;

            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install the selection initializer
                opts.initSelection = function (element, callback) {
                    var selected = element.find("option").filter(function() { return this.selected && !this.disabled });
                    // a single select box always has a value, no need to null check 'selected'
                    callback(self.optionToData(selected));
                };
            } else if ("data" in opts) {
                // install default initSelection when applied to hidden input and data is local
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var id = element.val();
                    //search in data by id, storing the actual matching item
                    var match = null;
                    opts.query({
                        matcher: function(term, text, el){
                            var is_match = equal(id, opts.id(el));
                            if (is_match) {
                                match = el;
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            callback(match);
                        }
                    });
                };
            }

            return opts;
        },

        // single
        getPlaceholder: function() {
            // if a placeholder is specified on a single select without a valid placeholder option ignore it
            if (this.select) {
                if (this.getPlaceholderOption() === undefined) {
                    return undefined;
                }
            }

            return this.parent.getPlaceholder.apply(this, arguments);
        },

        // single
        setPlaceholder: function () {
            var placeholder = this.getPlaceholder();

            if (this.isPlaceholderOptionSelected() && placeholder !== undefined) {

                // check for a placeholder option if attached to a select
                if (this.select && this.getPlaceholderOption() === undefined) return;

                this.selection.find(".select2-chosen").html(this.opts.escapeMarkup(placeholder));

                this.selection.addClass("select2-default");

                this.container.removeClass("select2-allowclear");
            }
        },

        // single
        postprocessResults: function (data, initial, noHighlightUpdate) {
            var selected = 0, self = this, showSearchInput = true;

            // find the selected element in the result list

            this.findHighlightableChoices().each2(function (i, elm) {
                if (equal(self.id(elm.data("select2-data")), self.opts.element.val())) {
                    selected = i;
                    return false;
                }
            });

            // and highlight it
            if (noHighlightUpdate !== false) {
                if (initial === true && selected >= 0) {
                    this.highlight(selected);
                } else {
                    this.highlight(0);
                }
            }

            // hide the search box if this is the first we got the results and there are enough of them for search

            if (initial === true) {
                var min = this.opts.minimumResultsForSearch;
                if (min >= 0) {
                    this.showSearch(countResults(data.results) >= min);
                }
            }
        },

        // single
        showSearch: function(showSearchInput) {
            if (this.showSearchInput === showSearchInput) return;

            this.showSearchInput = showSearchInput;

            this.dropdown.find(".select2-search").toggleClass("select2-search-hidden", !showSearchInput);
            this.dropdown.find(".select2-search").toggleClass("select2-offscreen", !showSearchInput);
            //add "select2-with-searchbox" to the container if search box is shown
            $(this.dropdown, this.container).toggleClass("select2-with-searchbox", showSearchInput);
        },

        // single
        onSelect: function (data, options) {

            if (!this.triggerSelect(data)) { return; }

            var old = this.opts.element.val(),
                oldData = this.data();

            this.opts.element.val(this.id(data));
            this.updateSelection(data);

            this.opts.element.trigger({ type: "select2-selected", val: this.id(data), choice: data });

            this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());
            this.close();

            if ((!options || !options.noFocus) && this.opts.shouldFocusInput(this)) {
                this.focusser.focus();
            }

            if (!equal(old, this.id(data))) {
                this.triggerChange({ added: data, removed: oldData });
            }
        },

        // single
        updateSelection: function (data) {

            if (!this.selection) { // may have been destroyed in meantime
                return;
            }

            var container=this.selection.find(".select2-chosen"), formatted, cssClass;

            this.selection.data("select2-data", data);

            container.empty();
            if (data !== null) {
                formatted=this.opts.formatSelection(data, container, this.opts.escapeMarkup);
            }
            if (formatted !== undefined) {
                container.append(formatted);
            }
            cssClass=this.opts.formatSelectionCssClass(data, container);
            if (cssClass !== undefined) {
                container.addClass(cssClass);
            }

            this.selection.removeClass("select2-default");

            if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
                this.container.addClass("select2-allowclear");
            }
        },

        // single
        val: function () {
            var val,
                triggerChange = false,
                data = null,
                self = this,
                oldData = this.data();

            if (arguments.length === 0) {
                return this.opts.element.val();
            }

            val = arguments[0];

            if (arguments.length > 1) {
                triggerChange = arguments[1];
            }

            if (this.select) {
                this.select
                    .val(val)
                    .find("option").filter(function() { return this.selected }).each2(function (i, elm) {
                        data = self.optionToData(elm);
                        return false;
                    });
                this.updateSelection(data);
                this.setPlaceholder();
                if (triggerChange) {
                    this.triggerChange({added: data, removed:oldData});
                }
            } else {
                // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
                if (!val && val !== 0) {
                    this.clear(triggerChange);
                    return;
                }
                if (this.opts.initSelection === undefined) {
                    throw new Error("cannot call val() if initSelection() is not defined");
                }
                this.opts.element.val(val);
                this.opts.initSelection(this.opts.element, function(data){
                    self.opts.element.val(!data ? "" : self.id(data));
                    self.updateSelection(data);
                    self.setPlaceholder();
                    if (triggerChange) {
                        self.triggerChange({added: data, removed:oldData});
                    }
                });
            }
        },

        // single
        clearSearch: function () {
            this.search.val("");
            this.focusser.val("");
        },

        // single
        data: function(value) {
            var data,
                triggerChange = false;

            if (arguments.length === 0) {
                data = this.selection.data("select2-data");
                if (data == undefined) data = null;
                return data;
            } else {
                if (arguments.length > 1) {
                    triggerChange = arguments[1];
                }
                if (!value) {
                    this.clear(triggerChange);
                } else {
                    data = this.data();
                    this.opts.element.val(!value ? "" : this.id(value));
                    this.updateSelection(value);
                    if (triggerChange) {
                        this.triggerChange({added: value, removed:data});
                    }
                }
            }
        }
    });

    MultiSelect2 = clazz(AbstractSelect2, {

        // multi
        createContainer: function () {
            var container = $(document.createElement("div")).attr({
                "class": "select2-container select2-container-multi"
            }).html([
                "<ul class='select2-choices'>",
                "  <li class='select2-search-field'>",
                "    <label for='' class='select2-offscreen'></label>",
                "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='select2-input'>",
                "  </li>",
                "</ul>",
                "<div class='select2-drop select2-drop-multi select2-display-none'>",
                "   <ul class='select2-results'>",
                "   </ul>",
                "</div>"].join(""));
            return container;
        },

        // multi
        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments),
                self=this;

            // TODO validate placeholder is a string if specified
            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install the selection initializer
                opts.initSelection = function (element, callback) {

                    var data = [];

                    element.find("option").filter(function() { return this.selected && !this.disabled }).each2(function (i, elm) {
                        data.push(self.optionToData(elm));
                    });
                    callback(data);
                };
            } else if ("data" in opts) {
                // install default initSelection when applied to hidden input and data is local
                opts.initSelection = opts.initSelection || function (element, callback) {
                    var ids = splitVal(element.val(), opts.separator, opts.transformVal);
                    //search in data by array of ids, storing matching items in a list
                    var matches = [];
                    opts.query({
                        matcher: function(term, text, el){
                            var is_match = $.grep(ids, function(id) {
                                return equal(id, opts.id(el));
                            }).length;
                            if (is_match) {
                                matches.push(el);
                            }
                            return is_match;
                        },
                        callback: !$.isFunction(callback) ? $.noop : function() {
                            // reorder matches based on the order they appear in the ids array because right now
                            // they are in the order in which they appear in data array
                            var ordered = [];
                            for (var i = 0; i < ids.length; i++) {
                                var id = ids[i];
                                for (var j = 0; j < matches.length; j++) {
                                    var match = matches[j];
                                    if (equal(id, opts.id(match))) {
                                        ordered.push(match);
                                        matches.splice(j, 1);
                                        break;
                                    }
                                }
                            }
                            callback(ordered);
                        }
                    });
                };
            }

            return opts;
        },

        // multi
        selectChoice: function (choice) {

            var selected = this.container.find(".select2-search-choice-focus");
            if (selected.length && choice && choice[0] == selected[0]) {

            } else {
                if (selected.length) {
                    this.opts.element.trigger("choice-deselected", selected);
                }
                selected.removeClass("select2-search-choice-focus");
                if (choice && choice.length) {
                    this.close();
                    choice.addClass("select2-search-choice-focus");
                    this.opts.element.trigger("choice-selected", choice);
                }
            }
        },

        // multi
        destroy: function() {
            $("label[for='" + this.search.attr('id') + "']")
                .attr('for', this.opts.element.attr("id"));
            this.parent.destroy.apply(this, arguments);

            cleanupJQueryElements.call(this,
                "searchContainer",
                "selection"
            );
        },

        // multi
        initContainer: function () {

            var selector = ".select2-choices", selection;

            this.searchContainer = this.container.find(".select2-search-field");
            this.selection = selection = this.container.find(selector);

            var _this = this;
            this.selection.on("click", ".select2-container:not(.select2-container-disabled) .select2-search-choice:not(.select2-locked)", function (e) {
                _this.search[0].focus();
                _this.selectChoice($(this));
            });

            // rewrite labels from original element to focusser
            this.search.attr("id", "s2id_autogen"+nextUid());

            this.search.prev()
                .text($("label[for='" + this.opts.element.attr("id") + "']").text())
                .attr('for', this.search.attr('id'));
            this.opts.element.focus(this.bind(function () { this.focus(); }));

            this.search.on("input paste", this.bind(function() {
                if (this.search.attr('placeholder') && this.search.val().length == 0) return;
                if (!this.isInterfaceEnabled()) return;
                if (!this.opened()) {
                    this.open();
                }
            }));

            this.search.attr("tabindex", this.elementTabIndex);

            this.keydowns = 0;
            this.search.on("keydown", this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;

                ++this.keydowns;
                var selected = selection.find(".select2-search-choice-focus");
                var prev = selected.prev(".select2-search-choice:not(.select2-locked)");
                var next = selected.next(".select2-search-choice:not(.select2-locked)");
                var pos = getCursorInfo(this.search);

                if (selected.length &&
                    (e.which == KEY.LEFT || e.which == KEY.RIGHT || e.which == KEY.BACKSPACE || e.which == KEY.DELETE || e.which == KEY.ENTER)) {
                    var selectedChoice = selected;
                    if (e.which == KEY.LEFT && prev.length) {
                        selectedChoice = prev;
                    }
                    else if (e.which == KEY.RIGHT) {
                        selectedChoice = next.length ? next : null;
                    }
                    else if (e.which === KEY.BACKSPACE) {
                        if (this.unselect(selected.first())) {
                            this.search.width(10);
                            selectedChoice = prev.length ? prev : next;
                        }
                    } else if (e.which == KEY.DELETE) {
                        if (this.unselect(selected.first())) {
                            this.search.width(10);
                            selectedChoice = next.length ? next : null;
                        }
                    } else if (e.which == KEY.ENTER) {
                        selectedChoice = null;
                    }

                    this.selectChoice(selectedChoice);
                    killEvent(e);
                    if (!selectedChoice || !selectedChoice.length) {
                        this.open();
                    }
                    return;
                } else if (((e.which === KEY.BACKSPACE && this.keydowns == 1)
                    || e.which == KEY.LEFT) && (pos.offset == 0 && !pos.length)) {

                    this.selectChoice(selection.find(".select2-search-choice:not(.select2-locked)").last());
                    killEvent(e);
                    return;
                } else {
                    this.selectChoice(null);
                }

                if (this.opened()) {
                    switch (e.which) {
                    case KEY.UP:
                    case KEY.DOWN:
                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                        killEvent(e);
                        return;
                    case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;
                    case KEY.TAB:
                        this.selectHighlighted({noFocus:true});
                        this.close();
                        return;
                    case KEY.ESC:
                        this.cancel(e);
                        killEvent(e);
                        return;
                    }
                }

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e)
                 || e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
                    return;
                }

                if (e.which === KEY.ENTER) {
                    if (this.opts.openOnEnter === false) {
                        return;
                    } else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                        return;
                    }
                }

                this.open();

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                }

                if (e.which === KEY.ENTER) {
                    // prevent form from being submitted
                    killEvent(e);
                }

            }));

            this.search.on("keyup", this.bind(function (e) {
                this.keydowns = 0;
                this.resizeSearch();
            })
            );

            this.search.on("blur", this.bind(function(e) {
                this.container.removeClass("select2-container-active");
                this.search.removeClass("select2-focused");
                this.selectChoice(null);
                if (!this.opened()) this.clearSearch();
                e.stopImmediatePropagation();
                this.opts.element.trigger($.Event("select2-blur"));
            }));

            this.container.on("mousedown", selector, this.bind(function (e) {
                if (!this.isInterfaceEnabled()) return;
                if ($(e.target).closest(".select2-search-choice").length > 0) {
                    // clicked inside a select2 search choice, do not open
                    return;
                }
                this.selectChoice(null);
                this.clearPlaceholder();
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.open();
                this.focusSearch();
                e.preventDefault();
            }));

            this.container.on("focus", selector, this.bind(function () {
                if (!this.isInterfaceEnabled()) return;
                if (!this.container.hasClass("select2-container-active")) {
                    this.opts.element.trigger($.Event("select2-focus"));
                }
                this.container.addClass("select2-container-active");
                this.dropdown.addClass("select2-drop-active");
                this.clearPlaceholder();
            }));

            this.initContainerWidth();
            this.opts.element.hide();

            // set the placeholder if necessary
            this.clearSearch();
        },

        // multi
        enableInterface: function() {
            if (this.parent.enableInterface.apply(this, arguments)) {
                this.search.prop("disabled", !this.isInterfaceEnabled());
            }
        },

        // multi
        initSelection: function () {
            var data;
            if (this.opts.element.val() === "" && this.opts.element.text() === "") {
                this.updateSelection([]);
                this.close();
                // set the placeholder if necessary
                this.clearSearch();
            }
            if (this.select || this.opts.element.val() !== "") {
                var self = this;
                this.opts.initSelection.call(null, this.opts.element, function(data){
                    if (data !== undefined && data !== null) {
                        self.updateSelection(data);
                        self.close();
                        // set the placeholder if necessary
                        self.clearSearch();
                    }
                });
            }
        },

        // multi
        clearSearch: function () {
            var placeholder = this.getPlaceholder(),
                maxWidth = this.getMaxSearchWidth();

            if (placeholder !== undefined  && this.getVal().length === 0 && this.search.hasClass("select2-focused") === false) {
                this.search.val(placeholder).addClass("select2-default");
                // stretch the search box to full width of the container so as much of the placeholder is visible as possible
                // we could call this.resizeSearch(), but we do not because that requires a sizer and we do not want to create one so early because of a firefox bug, see #944
                this.search.width(maxWidth > 0 ? maxWidth : this.container.css("width"));
            } else {
                this.search.val("").width(10);
            }
        },

        // multi
        clearPlaceholder: function () {
            if (this.search.hasClass("select2-default")) {
                this.search.val("").removeClass("select2-default");
            }
        },

        // multi
        opening: function () {
            this.clearPlaceholder(); // should be done before super so placeholder is not used to search
            this.resizeSearch();

            this.parent.opening.apply(this, arguments);

            this.focusSearch();

            // initializes search's value with nextSearchTerm (if defined by user)
            // ignore nextSearchTerm if the dropdown is opened by the user pressing a letter
            if(this.search.val() === "") {
                if(this.nextSearchTerm != undefined){
                    this.search.val(this.nextSearchTerm);
                    this.search.select();
                }
            }

            this.updateResults(true);
            if (this.opts.shouldFocusInput(this)) {
                this.search.focus();
            }
            this.opts.element.trigger($.Event("select2-open"));
        },

        // multi
        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);
        },

        // multi
        focus: function () {
            this.close();
            this.search.focus();
        },

        // multi
        isFocused: function () {
            return this.search.hasClass("select2-focused");
        },

        // multi
        updateSelection: function (data) {
            if (!this.selection) { // may have been destroyed in meantime
                return;
            }
            var ids = [], filtered = [], self = this;

            // filter out duplicates
            $(data).each(function () {
                if (indexOf(self.id(this), ids) < 0) {
                    ids.push(self.id(this));
                    filtered.push(this);
                }
            });
            data = filtered;

            this.selection.find(".select2-search-choice").remove();
            $(data).each(function () {
                self.addSelectedChoice(this);
            });
            self.postprocessResults();
        },

        // multi
        tokenize: function() {
            var input = this.search.val();
            input = this.opts.tokenizer.call(this, input, this.data(), this.bind(this.onSelect), this.opts);
            if (input != null && input != undefined) {
                this.search.val(input);
                if (input.length > 0) {
                    this.open();
                }
            }

        },

        // multi
        onSelect: function (data, options) {

            if (!this.triggerSelect(data) || data.text === "") { return; }

            this.addSelectedChoice(data);

            this.opts.element.trigger({ type: "selected", val: this.id(data), choice: data });

            // keep track of the search's value before it gets cleared
            this.nextSearchTerm = this.opts.nextSearchTerm(data, this.search.val());

            this.clearSearch();
            this.updateResults();

            if (this.select || !this.opts.closeOnSelect) this.postprocessResults(data, false, this.opts.closeOnSelect===true);

            if (this.opts.closeOnSelect) {
                this.close();
                this.search.width(10);
            } else {
                if (this.countSelectableResults()>0) {
                    this.search.width(10);
                    this.resizeSearch();
                    if (this.getMaximumSelectionSize() > 0 && this.val().length >= this.getMaximumSelectionSize()) {
                        // if we reached max selection size repaint the results so choices
                        // are replaced with the max selection reached message
                        this.updateResults(true);
                    } else {
                        // initializes search's value with nextSearchTerm and update search result
                        if(this.nextSearchTerm != undefined){
                            this.search.val(this.nextSearchTerm);
                            this.updateResults();
                            this.search.select();
                        }
                    }
                    this.positionDropdown();
                } else {
                    // if nothing left to select close
                    this.close();
                    this.search.width(10);
                }
            }

            // since its not possible to select an element that has already been
            // added we do not need to check if this is a new element before firing change
            this.triggerChange({ added: data });

            if (!options || !options.noFocus)
                this.focusSearch();
        },

        // multi
        cancel: function () {
            this.close();
            this.focusSearch();
        },

        addSelectedChoice: function (data) {
            var enableChoice = !data.locked,
                enabledItem = $(
                    "<li class='select2-search-choice'>" +
                    "    <div></div>" +
                    "    <a href='#' class='select2-search-choice-close' tabindex='-1'></a>" +
                    "</li>"),
                disabledItem = $(
                    "<li class='select2-search-choice select2-locked'>" +
                    "<div></div>" +
                    "</li>");
            var choice = enableChoice ? enabledItem : disabledItem,
                id = this.id(data),
                val = this.getVal(),
                formatted,
                cssClass;

            formatted=this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
            if (formatted != undefined) {
                choice.find("div").replaceWith($("<div></div>").html(formatted));
            }
            cssClass=this.opts.formatSelectionCssClass(data, choice.find("div"));
            if (cssClass != undefined) {
                choice.addClass(cssClass);
            }

            if(enableChoice){
              choice.find(".select2-search-choice-close")
                  .on("mousedown", killEvent)
                  .on("click dblclick", this.bind(function (e) {
                  if (!this.isInterfaceEnabled()) return;

                  this.unselect($(e.target));
                  this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                  killEvent(e);
                  this.close();
                  this.focusSearch();
              })).on("focus", this.bind(function () {
                  if (!this.isInterfaceEnabled()) return;
                  this.container.addClass("select2-container-active");
                  this.dropdown.addClass("select2-drop-active");
              }));
            }

            choice.data("select2-data", data);
            choice.insertBefore(this.searchContainer);

            val.push(id);
            this.setVal(val);
        },

        // multi
        unselect: function (selected) {
            var val = this.getVal(),
                data,
                index;
            selected = selected.closest(".select2-search-choice");

            if (selected.length === 0) {
                throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
            }

            data = selected.data("select2-data");

            if (!data) {
                // prevent a race condition when the 'x' is clicked really fast repeatedly the event can be queued
                // and invoked on an element already removed
                return;
            }

            var evt = $.Event("select2-removing");
            evt.val = this.id(data);
            evt.choice = data;
            this.opts.element.trigger(evt);

            if (evt.isDefaultPrevented()) {
                return false;
            }

            while((index = indexOf(this.id(data), val)) >= 0) {
                val.splice(index, 1);
                this.setVal(val);
                if (this.select) this.postprocessResults();
            }

            selected.remove();

            this.opts.element.trigger({ type: "select2-removed", val: this.id(data), choice: data });
            this.triggerChange({ removed: data });

            return true;
        },

        // multi
        postprocessResults: function (data, initial, noHighlightUpdate) {
            var val = this.getVal(),
                choices = this.results.find(".select2-result"),
                compound = this.results.find(".select2-result-with-children"),
                self = this;

            choices.each2(function (i, choice) {
                var id = self.id(choice.data("select2-data"));
                if (indexOf(id, val) >= 0) {
                    choice.addClass("select2-selected");
                    // mark all children of the selected parent as selected
                    choice.find(".select2-result-selectable").addClass("select2-selected");
                }
            });

            compound.each2(function(i, choice) {
                // hide an optgroup if it doesn't have any selectable children
                if (!choice.is('.select2-result-selectable')
                    && choice.find(".select2-result-selectable:not(.select2-selected)").length === 0) {
                    choice.addClass("select2-selected");
                }
            });

            if (this.highlight() == -1 && noHighlightUpdate !== false && this.opts.closeOnSelect === true){
                self.highlight(0);
            }

            //If all results are chosen render formatNoMatches
            if(!this.opts.createSearchChoice && !choices.filter('.select2-result:not(.select2-selected)').length > 0){
                if(!data || data && !data.more && this.results.find(".select2-no-results").length === 0) {
                    if (checkFormatter(self.opts.formatNoMatches, "formatNoMatches")) {
                        this.results.append("<li class='select2-no-results'>" + evaluate(self.opts.formatNoMatches, self.opts.element, self.search.val()) + "</li>");
                    }
                }
            }

        },

        // multi
        getMaxSearchWidth: function() {
            return this.selection.width() - getSideBorderPadding(this.search);
        },

        // multi
        resizeSearch: function () {
            var minimumWidth, left, maxWidth, containerLeft, searchWidth,
                sideBorderPadding = getSideBorderPadding(this.search);

            minimumWidth = measureTextWidth(this.search) + 10;

            left = this.search.offset().left;

            maxWidth = this.selection.width();
            containerLeft = this.selection.offset().left;

            searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;

            if (searchWidth < minimumWidth) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth < 40) {
                searchWidth = maxWidth - sideBorderPadding;
            }

            if (searchWidth <= 0) {
              searchWidth = minimumWidth;
            }

            this.search.width(Math.floor(searchWidth));
        },

        // multi
        getVal: function () {
            var val;
            if (this.select) {
                val = this.select.val();
                return val === null ? [] : val;
            } else {
                val = this.opts.element.val();
                return splitVal(val, this.opts.separator, this.opts.transformVal);
            }
        },

        // multi
        setVal: function (val) {
            var unique;
            if (this.select) {
                this.select.val(val);
            } else {
                unique = [];
                // filter out duplicates
                $(val).each(function () {
                    if (indexOf(this, unique) < 0) unique.push(this);
                });
                this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
            }
        },

        // multi
        buildChangeDetails: function (old, current) {
            var current = current.slice(0),
                old = old.slice(0);

            // remove intersection from each array
            for (var i = 0; i < current.length; i++) {
                for (var j = 0; j < old.length; j++) {
                    if (equal(this.opts.id(current[i]), this.opts.id(old[j]))) {
                        current.splice(i, 1);
                        if(i>0){
                            i--;
                        }
                        old.splice(j, 1);
                        j--;
                    }
                }
            }

            return {added: current, removed: old};
        },


        // multi
        val: function (val, triggerChange) {
            var oldData, self=this;

            if (arguments.length === 0) {
                return this.getVal();
            }

            oldData=this.data();
            if (!oldData.length) oldData=[];

            // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
            if (!val && val !== 0) {
                this.opts.element.val("");
                this.updateSelection([]);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange({added: this.data(), removed: oldData});
                }
                return;
            }

            // val is a list of ids
            this.setVal(val);

            if (this.select) {
                this.opts.initSelection(this.select, this.bind(this.updateSelection));
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(oldData, this.data()));
                }
            } else {
                if (this.opts.initSelection === undefined) {
                    throw new Error("val() cannot be called if initSelection() is not defined");
                }

                this.opts.initSelection(this.opts.element, function(data){
                    var ids=$.map(data, self.id);
                    self.setVal(ids);
                    self.updateSelection(data);
                    self.clearSearch();
                    if (triggerChange) {
                        self.triggerChange(self.buildChangeDetails(oldData, self.data()));
                    }
                });
            }
            this.clearSearch();
        },

        // multi
        onSortStart: function() {
            if (this.select) {
                throw new Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");
            }

            // collapse search field into 0 width so its container can be collapsed as well
            this.search.width(0);
            // hide the container
            this.searchContainer.hide();
        },

        // multi
        onSortEnd:function() {

            var val=[], self=this;

            // show search and move it to the end of the list
            this.searchContainer.show();
            // make sure the search container is the last item in the list
            this.searchContainer.appendTo(this.searchContainer.parent());
            // since we collapsed the width in dragStarted, we resize it here
            this.resizeSearch();

            // update selection
            this.selection.find(".select2-search-choice").each(function() {
                val.push(self.opts.id($(this).data("select2-data")));
            });
            this.setVal(val);
            this.triggerChange();
        },

        // multi
        data: function(values, triggerChange) {
            var self=this, ids, old;
            if (arguments.length === 0) {
                 return this.selection
                     .children(".select2-search-choice")
                     .map(function() { return $(this).data("select2-data"); })
                     .get();
            } else {
                old = this.data();
                if (!values) { values = []; }
                ids = $.map(values, function(e) { return self.opts.id(e); });
                this.setVal(ids);
                this.updateSelection(values);
                this.clearSearch();
                if (triggerChange) {
                    this.triggerChange(this.buildChangeDetails(old, this.data()));
                }
            }
        }
    });

    $.fn.select2 = function () {

        var args = Array.prototype.slice.call(arguments, 0),
            opts,
            select2,
            method, value, multiple,
            allowedMethods = ["val", "destroy", "opened", "open", "close", "focus", "isFocused", "container", "dropdown", "onSortStart", "onSortEnd", "enable", "disable", "readonly", "positionDropdown", "data", "search"],
            valueMethods = ["opened", "isFocused", "container", "dropdown"],
            propertyMethods = ["val", "data"],
            methodsMap = { search: "externalSearch" };

        this.each(function () {
            if (args.length === 0 || typeof(args[0]) === "object") {
                opts = args.length === 0 ? {} : $.extend({}, args[0]);
                opts.element = $(this);

                if (opts.element.get(0).tagName.toLowerCase() === "select") {
                    multiple = opts.element.prop("multiple");
                } else {
                    multiple = opts.multiple || false;
                    if ("tags" in opts) {opts.multiple = multiple = true;}
                }

                select2 = multiple ? new window.Select2["class"].multi() : new window.Select2["class"].single();
                select2.init(opts);
            } else if (typeof(args[0]) === "string") {

                if (indexOf(args[0], allowedMethods) < 0) {
                    throw "Unknown method: " + args[0];
                }

                value = undefined;
                select2 = $(this).data("select2");
                if (select2 === undefined) return;

                method=args[0];

                if (method === "container") {
                    value = select2.container;
                } else if (method === "dropdown") {
                    value = select2.dropdown;
                } else {
                    if (methodsMap[method]) method = methodsMap[method];

                    value = select2[method].apply(select2, args.slice(1));
                }
                if (indexOf(args[0], valueMethods) >= 0
                    || (indexOf(args[0], propertyMethods) >= 0 && args.length == 1)) {
                    return false; // abort the iteration, ready to return first matched value
                }
            } else {
                throw "Invalid arguments to select2 plugin: " + args;
            }
        });
        return (value === undefined) ? this : value;
    };

    // plugin defaults, accessible to users
    $.fn.select2.defaults = {
        width: "copy",
        loadMorePadding: 0,
        closeOnSelect: true,
        openOnEnter: true,
        containerCss: {},
        dropdownCss: {},
        containerCssClass: "",
        dropdownCssClass: "",
        formatResult: function(result, container, query, escapeMarkup) {
            var markup=[];
            markMatch(this.text(result), query.term, markup, escapeMarkup);
            return markup.join("");
        },
        transformVal: function(val) {
            return $.trim(val);
        },
        formatSelection: function (data, container, escapeMarkup) {
            return data ? escapeMarkup(this.text(data)) : undefined;
        },
        sortResults: function (results, container, query) {
            return results;
        },
        formatResultCssClass: function(data) {return data.css;},
        formatSelectionCssClass: function(data, container) {return undefined;},
        minimumResultsForSearch: 0,
        minimumInputLength: 0,
        maximumInputLength: null,
        maximumSelectionSize: 0,
        id: function (e) { return e == undefined ? null : e.id; },
        text: function (e) {
          if (e && this.data && this.data.text) {
            if ($.isFunction(this.data.text)) {
              return this.data.text(e);
            } else {
              return e[this.data.text];
            }
          } else {
            return e.text;
          }
        },
        matcher: function(term, text) {
            return stripDiacritics(''+text).toUpperCase().indexOf(stripDiacritics(''+term).toUpperCase()) >= 0;
        },
        separator: ",",
        tokenSeparators: [],
        tokenizer: defaultTokenizer,
        escapeMarkup: defaultEscapeMarkup,
        blurOnChange: false,
        selectOnBlur: false,
        adaptContainerCssClass: function(c) { return c; },
        adaptDropdownCssClass: function(c) { return null; },
        nextSearchTerm: function(selectedObject, currentSearchTerm) { return undefined; },
        searchInputPlaceholder: '',
        createSearchChoicePosition: 'top',
        shouldFocusInput: function (instance) {
            // Attempt to detect touch devices
            var supportsTouchEvents = (('ontouchstart' in window) ||
                                       (navigator.msMaxTouchPoints > 0));

            // Only devices which support touch events should be special cased
            if (!supportsTouchEvents) {
                return true;
            }

            // Never focus the input if search is disabled
            if (instance.opts.minimumResultsForSearch < 0) {
                return false;
            }

            return true;
        }
    };

    $.fn.select2.locales = [];

    $.fn.select2.locales['en'] = {
         formatMatches: function (matches) { if (matches === 1) { return "One result is available, press enter to select it."; } return matches + " results are available, use up and down arrow keys to navigate."; },
         formatNoMatches: function () { return "No matches found"; },
         formatAjaxError: function (jqXHR, textStatus, errorThrown) { return "Loading failed"; },
         formatInputTooShort: function (input, min) { var n = min - input.length; return "Please enter " + n + " or more character" + (n == 1 ? "" : "s"); },
         formatInputTooLong: function (input, max) { var n = input.length - max; return "Please delete " + n + " character" + (n == 1 ? "" : "s"); },
         formatSelectionTooBig: function (limit) { return "You can only select " + limit + " item" + (limit == 1 ? "" : "s"); },
         formatLoadMore: function (pageNumber) { return "Loading more results"; },
         formatSearching: function () { return "Searching"; }
    };

    $.extend($.fn.select2.defaults, $.fn.select2.locales['en']);

    $.fn.select2.ajaxDefaults = {
        transport: $.ajax,
        params: {
            type: "GET",
            cache: false,
            dataType: "json"
        }
    };

    // exports
    window.Select2 = {
        query: {
            ajax: ajax,
            local: local,
            tags: tags
        }, util: {
            debounce: debounce,
            markMatch: markMatch,
            escapeMarkup: defaultEscapeMarkup,
            stripDiacritics: stripDiacritics
        }, "class": {
            "abstract": AbstractSelect2,
            "single": SingleSelect2,
            "multi": MultiSelect2
        }
    };

}(jQuery));
;/**
 * Select2 German translation
 */
(function ($) {
    "use strict";

    $.fn.select2.locales['de'] = {
        formatNoMatches: function () { return "Keine bereinstimmungen gefunden"; },
        formatInputTooShort: function (input, min) { var n = min - input.length; return "Bitte " + n + " Zeichen mehr eingeben"; },
        formatInputTooLong: function (input, max) { var n = input.length - max; return "Bitte " + n + " Zeichen weniger eingeben"; },
        formatSelectionTooBig: function (limit) { return "Sie knnen nur " + limit + " Eintr" + (limit === 1 ? "ag" : "ge") + " auswhlen"; },
        formatLoadMore: function (pageNumber) { return "Lade mehr Ergebnisse"; },
        formatSearching: function () { return "Suche"; },
        formatMatches: function (matches) { return matches + " Ergebnis " + (matches > 1 ? "se" : "") + " verfgbar, zum Navigieren die Hoch-/Runter-Pfeiltasten verwenden."; }
    };

    $.extend($.fn.select2.defaults, $.fn.select2.locales['de']);
})(jQuery);;/*!
 * Socket.IO v2.1.1
 * (c) 2014-2018 Guillermo Rauch
 * Released under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.io=e():t.io=e()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var n={};return e.m=t,e.c=n,e.p="",e(0)}([function(t,e,n){"use strict";function r(t,e){"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{};var n,r=i(t),s=r.source,p=r.id,h=r.path,f=u[p]&&h in u[p].nsps,l=e.forceNew||e["force new connection"]||!1===e.multiplex||f;return l?(c("ignoring socket cache for %s",s),n=a(s,e)):(u[p]||(c("new io instance for %s",s),u[p]=a(s,e)),n=u[p]),r.query&&!e.query&&(e.query=r.query),n.socket(r.path,e)}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(1),s=n(7),a=n(12),c=n(3)("socket.io-client");t.exports=e=r;var u=e.managers={};e.protocol=s.protocol,e.connect=r,e.Manager=n(12),e.Socket=n(37)},function(t,e,n){(function(e){"use strict";function r(t,n){var r=t;n=n||e.location,null==t&&(t=n.protocol+"//"+n.host),"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?n.protocol+t:n.host+t),/^(https?|wss?):\/\//.test(t)||(i("protocol-less url %s",t),t="undefined"!=typeof n?n.protocol+"//"+t:"https://"+t),i("parse %s",t),r=o(t)),r.port||(/^(http|ws)$/.test(r.protocol)?r.port="80":/^(http|ws)s$/.test(r.protocol)&&(r.port="443")),r.path=r.path||"/";var s=r.host.indexOf(":")!==-1,a=s?"["+r.host+"]":r.host;return r.id=r.protocol+"://"+a+":"+r.port,r.href=r.protocol+"://"+a+(n&&n.port===r.port?"":":"+r.port),r}var o=n(2),i=n(3)("socket.io-client:url");t.exports=r}).call(e,function(){return this}())},function(t,e){var n=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,r=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];t.exports=function(t){var e=t,o=t.indexOf("["),i=t.indexOf("]");o!=-1&&i!=-1&&(t=t.substring(0,o)+t.substring(o,i).replace(/:/g,";")+t.substring(i,t.length));for(var s=n.exec(t||""),a={},c=14;c--;)a[r[c]]=s[c]||"";return o!=-1&&i!=-1&&(a.source=e,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a}},function(t,e,n){(function(r){function o(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))}function i(t){var n=this.useColors;if(t[0]=(n?"%c":"")+this.namespace+(n?" %c":" ")+t[0]+(n?"%c ":" ")+"+"+e.humanize(this.diff),n){var r="color: "+this.color;t.splice(1,0,r,"color: inherit");var o=0,i=0;t[0].replace(/%[a-zA-Z%]/g,function(t){"%%"!==t&&(o++,"%c"===t&&(i=o))}),t.splice(i,0,r)}}function s(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function a(t){try{null==t?e.storage.removeItem("debug"):e.storage.debug=t}catch(n){}}function c(){var t;try{t=e.storage.debug}catch(n){}return!t&&"undefined"!=typeof r&&"env"in r&&(t=r.env.DEBUG),t}function u(){try{return window.localStorage}catch(t){}}e=t.exports=n(5),e.log=s,e.formatArgs=i,e.save=a,e.load=c,e.useColors=o,e.storage="undefined"!=typeof chrome&&"undefined"!=typeof chrome.storage?chrome.storage.local:u(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],e.formatters.j=function(t){try{return JSON.stringify(t)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}},e.enable(c())}).call(e,n(4))},function(t,e){function n(){throw new Error("setTimeout has not been defined")}function r(){throw new Error("clearTimeout has not been defined")}function o(t){if(p===setTimeout)return setTimeout(t,0);if((p===n||!p)&&setTimeout)return p=setTimeout,setTimeout(t,0);try{return p(t,0)}catch(e){try{return p.call(null,t,0)}catch(e){return p.call(this,t,0)}}}function i(t){if(h===clearTimeout)return clearTimeout(t);if((h===r||!h)&&clearTimeout)return h=clearTimeout,clearTimeout(t);try{return h(t)}catch(e){try{return h.call(null,t)}catch(e){return h.call(this,t)}}}function s(){y&&l&&(y=!1,l.length?d=l.concat(d):m=-1,d.length&&a())}function a(){if(!y){var t=o(s);y=!0;for(var e=d.length;e;){for(l=d,d=[];++m<e;)l&&l[m].run();m=-1,e=d.length}l=null,y=!1,i(t)}}function c(t,e){this.fun=t,this.array=e}function u(){}var p,h,f=t.exports={};!function(){try{p="function"==typeof setTimeout?setTimeout:n}catch(t){p=n}try{h="function"==typeof clearTimeout?clearTimeout:r}catch(t){h=r}}();var l,d=[],y=!1,m=-1;f.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];d.push(new c(t,e)),1!==d.length||y||o(a)},c.prototype.run=function(){this.fun.apply(null,this.array)},f.title="browser",f.browser=!0,f.env={},f.argv=[],f.version="",f.versions={},f.on=u,f.addListener=u,f.once=u,f.off=u,f.removeListener=u,f.removeAllListeners=u,f.emit=u,f.prependListener=u,f.prependOnceListener=u,f.listeners=function(t){return[]},f.binding=function(t){throw new Error("process.binding is not supported")},f.cwd=function(){return"/"},f.chdir=function(t){throw new Error("process.chdir is not supported")},f.umask=function(){return 0}},function(t,e,n){function r(t){var n,r=0;for(n in t)r=(r<<5)-r+t.charCodeAt(n),r|=0;return e.colors[Math.abs(r)%e.colors.length]}function o(t){function n(){if(n.enabled){var t=n,r=+new Date,i=r-(o||r);t.diff=i,t.prev=o,t.curr=r,o=r;for(var s=new Array(arguments.length),a=0;a<s.length;a++)s[a]=arguments[a];s[0]=e.coerce(s[0]),"string"!=typeof s[0]&&s.unshift("%O");var c=0;s[0]=s[0].replace(/%([a-zA-Z%])/g,function(n,r){if("%%"===n)return n;c++;var o=e.formatters[r];if("function"==typeof o){var i=s[c];n=o.call(t,i),s.splice(c,1),c--}return n}),e.formatArgs.call(t,s);var u=n.log||e.log||console.log.bind(console);u.apply(t,s)}}var o;return n.namespace=t,n.enabled=e.enabled(t),n.useColors=e.useColors(),n.color=r(t),n.destroy=i,"function"==typeof e.init&&e.init(n),e.instances.push(n),n}function i(){var t=e.instances.indexOf(this);return t!==-1&&(e.instances.splice(t,1),!0)}function s(t){e.save(t),e.names=[],e.skips=[];var n,r=("string"==typeof t?t:"").split(/[\s,]+/),o=r.length;for(n=0;n<o;n++)r[n]&&(t=r[n].replace(/\*/g,".*?"),"-"===t[0]?e.skips.push(new RegExp("^"+t.substr(1)+"$")):e.names.push(new RegExp("^"+t+"$")));for(n=0;n<e.instances.length;n++){var i=e.instances[n];i.enabled=e.enabled(i.namespace)}}function a(){e.enable("")}function c(t){if("*"===t[t.length-1])return!0;var n,r;for(n=0,r=e.skips.length;n<r;n++)if(e.skips[n].test(t))return!1;for(n=0,r=e.names.length;n<r;n++)if(e.names[n].test(t))return!0;return!1}function u(t){return t instanceof Error?t.stack||t.message:t}e=t.exports=o.debug=o["default"]=o,e.coerce=u,e.disable=a,e.enable=s,e.enabled=c,e.humanize=n(6),e.instances=[],e.names=[],e.skips=[],e.formatters={}},function(t,e){function n(t){if(t=String(t),!(t.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t);if(e){var n=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return n*p;case"days":case"day":case"d":return n*u;case"hours":case"hour":case"hrs":case"hr":case"h":return n*c;case"minutes":case"minute":case"mins":case"min":case"m":return n*a;case"seconds":case"second":case"secs":case"sec":case"s":return n*s;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return n;default:return}}}}function r(t){return t>=u?Math.round(t/u)+"d":t>=c?Math.round(t/c)+"h":t>=a?Math.round(t/a)+"m":t>=s?Math.round(t/s)+"s":t+"ms"}function o(t){return i(t,u,"day")||i(t,c,"hour")||i(t,a,"minute")||i(t,s,"second")||t+" ms"}function i(t,e,n){if(!(t<e))return t<1.5*e?Math.floor(t/e)+" "+n:Math.ceil(t/e)+" "+n+"s"}var s=1e3,a=60*s,c=60*a,u=24*c,p=365.25*u;t.exports=function(t,e){e=e||{};var i=typeof t;if("string"===i&&t.length>0)return n(t);if("number"===i&&isNaN(t)===!1)return e["long"]?o(t):r(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))}},function(t,e,n){function r(){}function o(t){var n=""+t.type;if(e.BINARY_EVENT!==t.type&&e.BINARY_ACK!==t.type||(n+=t.attachments+"-"),t.nsp&&"/"!==t.nsp&&(n+=t.nsp+","),null!=t.id&&(n+=t.id),null!=t.data){var r=i(t.data);if(r===!1)return g;n+=r}return f("encoded %j as %s",t,n),n}function i(t){try{return JSON.stringify(t)}catch(e){return!1}}function s(t,e){function n(t){var n=d.deconstructPacket(t),r=o(n.packet),i=n.buffers;i.unshift(r),e(i)}d.removeBlobs(t,n)}function a(){this.reconstructor=null}function c(t){var n=0,r={type:Number(t.charAt(0))};if(null==e.types[r.type])return h("unknown packet type "+r.type);if(e.BINARY_EVENT===r.type||e.BINARY_ACK===r.type){for(var o="";"-"!==t.charAt(++n)&&(o+=t.charAt(n),n!=t.length););if(o!=Number(o)||"-"!==t.charAt(n))throw new Error("Illegal attachments");r.attachments=Number(o)}if("/"===t.charAt(n+1))for(r.nsp="";++n;){var i=t.charAt(n);if(","===i)break;if(r.nsp+=i,n===t.length)break}else r.nsp="/";var s=t.charAt(n+1);if(""!==s&&Number(s)==s){for(r.id="";++n;){var i=t.charAt(n);if(null==i||Number(i)!=i){--n;break}if(r.id+=t.charAt(n),n===t.length)break}r.id=Number(r.id)}if(t.charAt(++n)){var a=u(t.substr(n)),c=a!==!1&&(r.type===e.ERROR||y(a));if(!c)return h("invalid payload");r.data=a}return f("decoded %s as %j",t,r),r}function u(t){try{return JSON.parse(t)}catch(e){return!1}}function p(t){this.reconPack=t,this.buffers=[]}function h(t){return{type:e.ERROR,data:"parser error: "+t}}var f=n(3)("socket.io-parser"),l=n(8),d=n(9),y=n(10),m=n(11);e.protocol=4,e.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],e.CONNECT=0,e.DISCONNECT=1,e.EVENT=2,e.ACK=3,e.ERROR=4,e.BINARY_EVENT=5,e.BINARY_ACK=6,e.Encoder=r,e.Decoder=a;var g=e.ERROR+'"encode error"';r.prototype.encode=function(t,n){if(f("encoding packet %j",t),e.BINARY_EVENT===t.type||e.BINARY_ACK===t.type)s(t,n);else{var r=o(t);n([r])}},l(a.prototype),a.prototype.add=function(t){var n;if("string"==typeof t)n=c(t),e.BINARY_EVENT===n.type||e.BINARY_ACK===n.type?(this.reconstructor=new p(n),0===this.reconstructor.reconPack.attachments&&this.emit("decoded",n)):this.emit("decoded",n);else{if(!m(t)&&!t.base64)throw new Error("Unknown type: "+t);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");n=this.reconstructor.takeBinaryData(t),n&&(this.reconstructor=null,this.emit("decoded",n))}},a.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()},p.prototype.takeBinaryData=function(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){var e=d.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null},p.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]}},function(t,e,n){function r(t){if(t)return o(t)}function o(t){for(var e in r.prototype)t[e]=r.prototype[e];return t}t.exports=r,r.prototype.on=r.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},r.prototype.once=function(t,e){function n(){this.off(t,n),e.apply(this,arguments)}return n.fn=e,this.on(t,n),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n=this._callbacks["$"+t];if(!n)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var r,o=0;o<n.length;o++)if(r=n[o],r===e||r.fn===e){n.splice(o,1);break}return this},r.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),n=this._callbacks["$"+t];if(n){n=n.slice(0);for(var r=0,o=n.length;r<o;++r)n[r].apply(this,e)}return this},r.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},r.prototype.hasListeners=function(t){return!!this.listeners(t).length}},function(t,e,n){(function(t){function r(t,e){if(!t)return t;if(s(t)){var n={_placeholder:!0,num:e.length};return e.push(t),n}if(i(t)){for(var o=new Array(t.length),a=0;a<t.length;a++)o[a]=r(t[a],e);return o}if("object"==typeof t&&!(t instanceof Date)){var o={};for(var c in t)o[c]=r(t[c],e);return o}return t}function o(t,e){if(!t)return t;if(t&&t._placeholder)return e[t.num];if(i(t))for(var n=0;n<t.length;n++)t[n]=o(t[n],e);else if("object"==typeof t)for(var r in t)t[r]=o(t[r],e);return t}var i=n(10),s=n(11),a=Object.prototype.toString,c="function"==typeof t.Blob||"[object BlobConstructor]"===a.call(t.Blob),u="function"==typeof t.File||"[object FileConstructor]"===a.call(t.File);e.deconstructPacket=function(t){var e=[],n=t.data,o=t;return o.data=r(n,e),o.attachments=e.length,{packet:o,buffers:e}},e.reconstructPacket=function(t,e){return t.data=o(t.data,e),t.attachments=void 0,t},e.removeBlobs=function(t,e){function n(t,a,p){if(!t)return t;if(c&&t instanceof Blob||u&&t instanceof File){r++;var h=new FileReader;h.onload=function(){p?p[a]=this.result:o=this.result,--r||e(o)},h.readAsArrayBuffer(t)}else if(i(t))for(var f=0;f<t.length;f++)n(t[f],f,t);else if("object"==typeof t&&!s(t))for(var l in t)n(t[l],l,t)}var r=0,o=t;n(o),r||e(o)}}).call(e,function(){return this}())},function(t,e){var n={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==n.call(t)}},function(t,e){(function(e){function n(t){return r&&e.Buffer.isBuffer(t)||o&&(t instanceof e.ArrayBuffer||i(t))}t.exports=n;var r="function"==typeof e.Buffer&&"function"==typeof e.Buffer.isBuffer,o="function"==typeof e.ArrayBuffer,i=function(){return o&&"function"==typeof e.ArrayBuffer.isView?e.ArrayBuffer.isView:function(t){return t.buffer instanceof e.ArrayBuffer}}()}).call(e,function(){return this}())},function(t,e,n){"use strict";function r(t,e){if(!(this instanceof r))return new r(t,e);t&&"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new l({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==e.timeout?2e4:e.timeout),this.readyState="closed",this.uri=t,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var n=e.parser||c;this.encoder=new n.Encoder,this.decoder=new n.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(13),s=n(37),a=n(8),c=n(7),u=n(39),p=n(40),h=n(3)("socket.io-client:manager"),f=n(36),l=n(41),d=Object.prototype.hasOwnProperty;t.exports=r,r.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var t in this.nsps)d.call(this.nsps,t)&&this.nsps[t].emit.apply(this.nsps[t],arguments)},r.prototype.updateSocketIds=function(){for(var t in this.nsps)d.call(this.nsps,t)&&(this.nsps[t].id=this.generateId(t))},r.prototype.generateId=function(t){return("/"===t?"":t+"#")+this.engine.id},a(r.prototype),r.prototype.reconnection=function(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection},r.prototype.reconnectionAttempts=function(t){return arguments.length?(this._reconnectionAttempts=t,this):this._reconnectionAttempts},r.prototype.reconnectionDelay=function(t){return arguments.length?(this._reconnectionDelay=t,this.backoff&&this.backoff.setMin(t),this):this._reconnectionDelay},r.prototype.randomizationFactor=function(t){return arguments.length?(this._randomizationFactor=t,this.backoff&&this.backoff.setJitter(t),this):this._randomizationFactor},r.prototype.reconnectionDelayMax=function(t){return arguments.length?(this._reconnectionDelayMax=t,this.backoff&&this.backoff.setMax(t),this):this._reconnectionDelayMax},r.prototype.timeout=function(t){return arguments.length?(this._timeout=t,this):this._timeout},r.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()},r.prototype.open=r.prototype.connect=function(t,e){if(h("readyState %s",this.readyState),~this.readyState.indexOf("open"))return this;h("opening %s",this.uri),this.engine=i(this.uri,this.opts);var n=this.engine,r=this;this.readyState="opening",this.skipReconnect=!1;var o=u(n,"open",function(){r.onopen(),t&&t()}),s=u(n,"error",function(e){if(h("connect_error"),r.cleanup(),r.readyState="closed",r.emitAll("connect_error",e),t){var n=new Error("Connection error");n.data=e,t(n)}else r.maybeReconnectOnOpen()});if(!1!==this._timeout){var a=this._timeout;h("connect attempt will timeout after %d",a);var c=setTimeout(function(){h("connect attempt timed out after %d",a),o.destroy(),n.close(),n.emit("error","timeout"),r.emitAll("connect_timeout",a)},a);this.subs.push({destroy:function(){clearTimeout(c)}})}return this.subs.push(o),this.subs.push(s),this},r.prototype.onopen=function(){h("open"),this.cleanup(),this.readyState="open",this.emit("open");var t=this.engine;this.subs.push(u(t,"data",p(this,"ondata"))),this.subs.push(u(t,"ping",p(this,"onping"))),this.subs.push(u(t,"pong",p(this,"onpong"))),this.subs.push(u(t,"error",p(this,"onerror"))),this.subs.push(u(t,"close",p(this,"onclose"))),this.subs.push(u(this.decoder,"decoded",p(this,"ondecoded")))},r.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")},r.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)},r.prototype.ondata=function(t){this.decoder.add(t)},r.prototype.ondecoded=function(t){this.emit("packet",t)},r.prototype.onerror=function(t){h("error",t),this.emitAll("error",t)},r.prototype.socket=function(t,e){function n(){~f(o.connecting,r)||o.connecting.push(r)}var r=this.nsps[t];if(!r){r=new s(this,t,e),this.nsps[t]=r;var o=this;r.on("connecting",n),r.on("connect",function(){r.id=o.generateId(t)}),this.autoConnect&&n()}return r},r.prototype.destroy=function(t){var e=f(this.connecting,t);~e&&this.connecting.splice(e,1),this.connecting.length||this.close()},r.prototype.packet=function(t){h("writing packet %j",t);var e=this;t.query&&0===t.type&&(t.nsp+="?"+t.query),e.encoding?e.packetBuffer.push(t):(e.encoding=!0,this.encoder.encode(t,function(n){for(var r=0;r<n.length;r++)e.engine.write(n[r],t.options);e.encoding=!1,e.processPacketQueue()}))},r.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var t=this.packetBuffer.shift();this.packet(t)}},r.prototype.cleanup=function(){h("cleanup");for(var t=this.subs.length,e=0;e<t;e++){var n=this.subs.shift();n.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()},r.prototype.close=r.prototype.disconnect=function(){h("disconnect"),this.skipReconnect=!0,this.reconnecting=!1,"opening"===this.readyState&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()},r.prototype.onclose=function(t){h("onclose"),this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",t),this._reconnection&&!this.skipReconnect&&this.reconnect()},r.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var t=this;if(this.backoff.attempts>=this._reconnectionAttempts)h("reconnect failed"),this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();h("will wait %dms before reconnect attempt",e),this.reconnecting=!0;var n=setTimeout(function(){t.skipReconnect||(h("attempting reconnect"),t.emitAll("reconnect_attempt",t.backoff.attempts),t.emitAll("reconnecting",t.backoff.attempts),t.skipReconnect||t.open(function(e){e?(h("reconnect attempt error"),t.reconnecting=!1,t.reconnect(),t.emitAll("reconnect_error",e.data)):(h("reconnect success"),t.onreconnect())}))},e);this.subs.push({destroy:function(){clearTimeout(n)}})}},r.prototype.onreconnect=function(){var t=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",t)}},function(t,e,n){t.exports=n(14),t.exports.parser=n(21)},function(t,e,n){(function(e){function r(t,n){if(!(this instanceof r))return new r(t,n);n=n||{},t&&"object"==typeof t&&(n=t,t=null),t?(t=p(t),n.hostname=t.host,n.secure="https"===t.protocol||"wss"===t.protocol,n.port=t.port,t.query&&(n.query=t.query)):n.host&&(n.hostname=p(n.host).host),this.secure=null!=n.secure?n.secure:e.location&&"https:"===location.protocol,n.hostname&&!n.port&&(n.port=this.secure?"443":"80"),this.agent=n.agent||!1,this.hostname=n.hostname||(e.location?location.hostname:"localhost"),this.port=n.port||(e.location&&location.port?location.port:this.secure?443:80),this.query=n.query||{},"string"==typeof this.query&&(this.query=h.decode(this.query)),this.upgrade=!1!==n.upgrade,this.path=(n.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!n.forceJSONP,this.jsonp=!1!==n.jsonp,this.forceBase64=!!n.forceBase64,this.enablesXDR=!!n.enablesXDR,this.timestampParam=n.timestampParam||"t",this.timestampRequests=n.timestampRequests,this.transports=n.transports||["polling","websocket"],this.transportOptions=n.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=n.policyPort||843,this.rememberUpgrade=n.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=n.onlyBinaryUpgrades,this.perMessageDeflate=!1!==n.perMessageDeflate&&(n.perMessageDeflate||{}),!0===this.perMessageDeflate&&(this.perMessageDeflate={}),this.perMessageDeflate&&null==this.perMessageDeflate.threshold&&(this.perMessageDeflate.threshold=1024),this.pfx=n.pfx||null,this.key=n.key||null,this.passphrase=n.passphrase||null,this.cert=n.cert||null,this.ca=n.ca||null,this.ciphers=n.ciphers||null,this.rejectUnauthorized=void 0===n.rejectUnauthorized||n.rejectUnauthorized,this.forceNode=!!n.forceNode;var o="object"==typeof e&&e;o.global===o&&(n.extraHeaders&&Object.keys(n.extraHeaders).length>0&&(this.extraHeaders=n.extraHeaders),n.localAddress&&(this.localAddress=n.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,this.open()}function o(t){var e={};for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);return e}var i=n(15),s=n(8),a=n(3)("engine.io-client:socket"),c=n(36),u=n(21),p=n(2),h=n(30);t.exports=r,r.priorWebsocketSuccess=!1,s(r.prototype),r.protocol=u.protocol,r.Socket=r,r.Transport=n(20),r.transports=n(15),r.parser=n(21),r.prototype.createTransport=function(t){a('creating transport "%s"',t);var e=o(this.query);e.EIO=u.protocol,e.transport=t;var n=this.transportOptions[t]||{};this.id&&(e.sid=this.id);var r=new i[t]({query:e,socket:this,agent:n.agent||this.agent,hostname:n.hostname||this.hostname,port:n.port||this.port,secure:n.secure||this.secure,path:n.path||this.path,forceJSONP:n.forceJSONP||this.forceJSONP,jsonp:n.jsonp||this.jsonp,forceBase64:n.forceBase64||this.forceBase64,enablesXDR:n.enablesXDR||this.enablesXDR,timestampRequests:n.timestampRequests||this.timestampRequests,timestampParam:n.timestampParam||this.timestampParam,policyPort:n.policyPort||this.policyPort,pfx:n.pfx||this.pfx,key:n.key||this.key,passphrase:n.passphrase||this.passphrase,cert:n.cert||this.cert,ca:n.ca||this.ca,ciphers:n.ciphers||this.ciphers,rejectUnauthorized:n.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:n.perMessageDeflate||this.perMessageDeflate,extraHeaders:n.extraHeaders||this.extraHeaders,forceNode:n.forceNode||this.forceNode,localAddress:n.localAddress||this.localAddress,requestTimeout:n.requestTimeout||this.requestTimeout,protocols:n.protocols||void 0});return r},r.prototype.open=function(){var t;if(this.rememberUpgrade&&r.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)t="websocket";else{if(0===this.transports.length){var e=this;return void setTimeout(function(){e.emit("error","No transports available")},0)}t=this.transports[0]}this.readyState="opening";try{t=this.createTransport(t)}catch(n){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)},r.prototype.setTransport=function(t){a("setting transport %s",t.name);var e=this;this.transport&&(a("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners()),this.transport=t,t.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})},r.prototype.probe=function(t){function e(){if(f.onlyBinaryUpgrades){var e=!this.supportsBinary&&f.transport.supportsBinary;h=h||e}h||(a('probe transport "%s" opened',t),p.send([{type:"ping",data:"probe"}]),p.once("packet",function(e){if(!h)if("pong"===e.type&&"probe"===e.data){if(a('probe transport "%s" pong',t),f.upgrading=!0,f.emit("upgrading",p),!p)return;r.priorWebsocketSuccess="websocket"===p.name,a('pausing current transport "%s"',f.transport.name),f.transport.pause(function(){h||"closed"!==f.readyState&&(a("changing transport and sending upgrade packet"),u(),f.setTransport(p),p.send([{type:"upgrade"}]),f.emit("upgrade",p),p=null,f.upgrading=!1,f.flush())})}else{a('probe transport "%s" failed',t);var n=new Error("probe error");n.transport=p.name,f.emit("upgradeError",n)}}))}function n(){h||(h=!0,u(),p.close(),p=null)}function o(e){var r=new Error("probe error: "+e);r.transport=p.name,n(),a('probe transport "%s" failed because of error: %s',t,e),f.emit("upgradeError",r)}function i(){o("transport closed")}function s(){o("socket closed")}function c(t){p&&t.name!==p.name&&(a('"%s" works - aborting "%s"',t.name,p.name),n())}function u(){p.removeListener("open",e),p.removeListener("error",o),p.removeListener("close",i),f.removeListener("close",s),f.removeListener("upgrading",c)}a('probing transport "%s"',t);var p=this.createTransport(t,{probe:1}),h=!1,f=this;r.priorWebsocketSuccess=!1,p.once("open",e),p.once("error",o),p.once("close",i),this.once("close",s),this.once("upgrading",c),p.open()},r.prototype.onOpen=function(){if(a("socket open"),this.readyState="open",r.priorWebsocketSuccess="websocket"===this.transport.name,this.emit("open"),this.flush(),"open"===this.readyState&&this.upgrade&&this.transport.pause){a("starting upgrade probes");for(var t=0,e=this.upgrades.length;t<e;t++)this.probe(this.upgrades[t])}},r.prototype.onPacket=function(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(a('socket receive: type "%s", data "%s"',t.type,t.data),this.emit("packet",t),this.emit("heartbeat"),t.type){case"open":this.onHandshake(JSON.parse(t.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=t.data,this.onError(e);break;case"message":this.emit("data",t.data),this.emit("message",t.data)}else a('packet received with socket readyState "%s"',this.readyState)},r.prototype.onHandshake=function(t){this.emit("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.onOpen(),"closed"!==this.readyState&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))},r.prototype.onHeartbeat=function(t){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){"closed"!==e.readyState&&e.onClose("ping timeout")},t||e.pingInterval+e.pingTimeout)},r.prototype.setPing=function(){var t=this;clearTimeout(t.pingIntervalTimer),t.pingIntervalTimer=setTimeout(function(){a("writing ping packet - expecting pong within %sms",t.pingTimeout),t.ping(),t.onHeartbeat(t.pingTimeout)},t.pingInterval)},r.prototype.ping=function(){var t=this;this.sendPacket("ping",function(){t.emit("ping")})},r.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emit("drain"):this.flush()},r.prototype.flush=function(){"closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(a("flushing %d packets in socket",this.writeBuffer.length),this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))},r.prototype.write=r.prototype.send=function(t,e,n){return this.sendPacket("message",t,e,n),this},r.prototype.sendPacket=function(t,e,n,r){if("function"==typeof e&&(r=e,e=void 0),"function"==typeof n&&(r=n,n=null),"closing"!==this.readyState&&"closed"!==this.readyState){n=n||{},n.compress=!1!==n.compress;var o={type:t,data:e,options:n};this.emit("packetCreate",o),this.writeBuffer.push(o),r&&this.once("flush",r),this.flush()}},r.prototype.close=function(){function t(){r.onClose("forced close"),a("socket closing - telling transport to close"),r.transport.close()}function e(){r.removeListener("upgrade",e),r.removeListener("upgradeError",e),t()}function n(){r.once("upgrade",e),r.once("upgradeError",e)}if("opening"===this.readyState||"open"===this.readyState){this.readyState="closing";var r=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?n():t()}):this.upgrading?n():t()}return this},r.prototype.onError=function(t){a("socket error %j",t),r.priorWebsocketSuccess=!1,this.emit("error",t),this.onClose("transport error",t)},r.prototype.onClose=function(t,e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){a('socket close with reason: "%s"',t);var n=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",t,e),n.writeBuffer=[],n.prevBufferLen=0}},r.prototype.filterUpgrades=function(t){for(var e=[],n=0,r=t.length;n<r;n++)~c(this.transports,t[n])&&e.push(t[n]);return e}}).call(e,function(){return this}())},function(t,e,n){(function(t){function r(e){var n,r=!1,a=!1,c=!1!==e.jsonp;if(t.location){var u="https:"===location.protocol,p=location.port;
    p||(p=u?443:80),r=e.hostname!==location.hostname||p!==e.port,a=e.secure!==u}if(e.xdomain=r,e.xscheme=a,n=new o(e),"open"in n&&!e.forceJSONP)return new i(e);if(!c)throw new Error("JSONP disabled");return new s(e)}var o=n(16),i=n(18),s=n(33),a=n(34);e.polling=r,e.websocket=a}).call(e,function(){return this}())},function(t,e,n){(function(e){var r=n(17);t.exports=function(t){var n=t.xdomain,o=t.xscheme,i=t.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!n||r))return new XMLHttpRequest}catch(s){}try{if("undefined"!=typeof XDomainRequest&&!o&&i)return new XDomainRequest}catch(s){}if(!n)try{return new(e[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(s){}}}).call(e,function(){return this}())},function(t,e){try{t.exports="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(n){t.exports=!1}},function(t,e,n){(function(e){function r(){}function o(t){if(c.call(this,t),this.requestTimeout=t.requestTimeout,this.extraHeaders=t.extraHeaders,e.location){var n="https:"===location.protocol,r=location.port;r||(r=n?443:80),this.xd=t.hostname!==e.location.hostname||r!==t.port,this.xs=t.secure!==n}}function i(t){this.method=t.method||"GET",this.uri=t.uri,this.xd=!!t.xd,this.xs=!!t.xs,this.async=!1!==t.async,this.data=void 0!==t.data?t.data:null,this.agent=t.agent,this.isBinary=t.isBinary,this.supportsBinary=t.supportsBinary,this.enablesXDR=t.enablesXDR,this.requestTimeout=t.requestTimeout,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.extraHeaders=t.extraHeaders,this.create()}function s(){for(var t in i.requests)i.requests.hasOwnProperty(t)&&i.requests[t].abort()}var a=n(16),c=n(19),u=n(8),p=n(31),h=n(3)("engine.io-client:polling-xhr");t.exports=o,t.exports.Request=i,p(o,c),o.prototype.supportsBinary=!0,o.prototype.request=function(t){return t=t||{},t.uri=this.uri(),t.xd=this.xd,t.xs=this.xs,t.agent=this.agent||!1,t.supportsBinary=this.supportsBinary,t.enablesXDR=this.enablesXDR,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized,t.requestTimeout=this.requestTimeout,t.extraHeaders=this.extraHeaders,new i(t)},o.prototype.doWrite=function(t,e){var n="string"!=typeof t&&void 0!==t,r=this.request({method:"POST",data:t,isBinary:n}),o=this;r.on("success",e),r.on("error",function(t){o.onError("xhr post error",t)}),this.sendXhr=r},o.prototype.doPoll=function(){h("xhr poll");var t=this.request(),e=this;t.on("data",function(t){e.onData(t)}),t.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=t},u(i.prototype),i.prototype.create=function(){var t={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized;var n=this.xhr=new a(t),r=this;try{h("xhr open %s: %s",this.method,this.uri),n.open(this.method,this.uri,this.async);try{if(this.extraHeaders){n.setDisableHeaderCheck&&n.setDisableHeaderCheck(!0);for(var o in this.extraHeaders)this.extraHeaders.hasOwnProperty(o)&&n.setRequestHeader(o,this.extraHeaders[o])}}catch(s){}if("POST"===this.method)try{this.isBinary?n.setRequestHeader("Content-type","application/octet-stream"):n.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(s){}try{n.setRequestHeader("Accept","*/*")}catch(s){}"withCredentials"in n&&(n.withCredentials=!0),this.requestTimeout&&(n.timeout=this.requestTimeout),this.hasXDR()?(n.onload=function(){r.onLoad()},n.onerror=function(){r.onError(n.responseText)}):n.onreadystatechange=function(){if(2===n.readyState)try{var t=n.getResponseHeader("Content-Type");r.supportsBinary&&"application/octet-stream"===t&&(n.responseType="arraybuffer")}catch(e){}4===n.readyState&&(200===n.status||1223===n.status?r.onLoad():setTimeout(function(){r.onError(n.status)},0))},h("xhr data %s",this.data),n.send(this.data)}catch(s){return void setTimeout(function(){r.onError(s)},0)}e.document&&(this.index=i.requestsCount++,i.requests[this.index]=this)},i.prototype.onSuccess=function(){this.emit("success"),this.cleanup()},i.prototype.onData=function(t){this.emit("data",t),this.onSuccess()},i.prototype.onError=function(t){this.emit("error",t),this.cleanup(!0)},i.prototype.cleanup=function(t){if("undefined"!=typeof this.xhr&&null!==this.xhr){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=r:this.xhr.onreadystatechange=r,t)try{this.xhr.abort()}catch(n){}e.document&&delete i.requests[this.index],this.xhr=null}},i.prototype.onLoad=function(){var t;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch(n){}t="application/octet-stream"===e?this.xhr.response||this.xhr.responseText:this.xhr.responseText}catch(n){this.onError(n)}null!=t&&this.onData(t)},i.prototype.hasXDR=function(){return"undefined"!=typeof e.XDomainRequest&&!this.xs&&this.enablesXDR},i.prototype.abort=function(){this.cleanup()},i.requestsCount=0,i.requests={},e.document&&(e.attachEvent?e.attachEvent("onunload",s):e.addEventListener&&e.addEventListener("beforeunload",s,!1))}).call(e,function(){return this}())},function(t,e,n){function r(t){var e=t&&t.forceBase64;p&&!e||(this.supportsBinary=!1),o.call(this,t)}var o=n(20),i=n(30),s=n(21),a=n(31),c=n(32),u=n(3)("engine.io-client:polling");t.exports=r;var p=function(){var t=n(16),e=new t({xdomain:!1});return null!=e.responseType}();a(r,o),r.prototype.name="polling",r.prototype.doOpen=function(){this.poll()},r.prototype.pause=function(t){function e(){u("paused"),n.readyState="paused",t()}var n=this;if(this.readyState="pausing",this.polling||!this.writable){var r=0;this.polling&&(u("we are currently polling - waiting to pause"),r++,this.once("pollComplete",function(){u("pre-pause polling complete"),--r||e()})),this.writable||(u("we are currently writing - waiting to pause"),r++,this.once("drain",function(){u("pre-pause writing complete"),--r||e()}))}else e()},r.prototype.poll=function(){u("polling"),this.polling=!0,this.doPoll(),this.emit("poll")},r.prototype.onData=function(t){var e=this;u("polling got data %s",t);var n=function(t,n,r){return"opening"===e.readyState&&e.onOpen(),"close"===t.type?(e.onClose(),!1):void e.onPacket(t)};s.decodePayload(t,this.socket.binaryType,n),"closed"!==this.readyState&&(this.polling=!1,this.emit("pollComplete"),"open"===this.readyState?this.poll():u('ignoring poll - transport state "%s"',this.readyState))},r.prototype.doClose=function(){function t(){u("writing close packet"),e.write([{type:"close"}])}var e=this;"open"===this.readyState?(u("transport open - closing"),t()):(u("transport not open - deferring close"),this.once("open",t))},r.prototype.write=function(t){var e=this;this.writable=!1;var n=function(){e.writable=!0,e.emit("drain")};s.encodePayload(t,this.supportsBinary,function(t){e.doWrite(t,n)})},r.prototype.uri=function(){var t=this.query||{},e=this.secure?"https":"http",n="";!1!==this.timestampRequests&&(t[this.timestampParam]=c()),this.supportsBinary||t.sid||(t.b64=1),t=i.encode(t),this.port&&("https"===e&&443!==Number(this.port)||"http"===e&&80!==Number(this.port))&&(n=":"+this.port),t.length&&(t="?"+t);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+n+this.path+t}},function(t,e,n){function r(t){this.path=t.path,this.hostname=t.hostname,this.port=t.port,this.secure=t.secure,this.query=t.query,this.timestampParam=t.timestampParam,this.timestampRequests=t.timestampRequests,this.readyState="",this.agent=t.agent||!1,this.socket=t.socket,this.enablesXDR=t.enablesXDR,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.forceNode=t.forceNode,this.extraHeaders=t.extraHeaders,this.localAddress=t.localAddress}var o=n(21),i=n(8);t.exports=r,i(r.prototype),r.prototype.onError=function(t,e){var n=new Error(t);return n.type="TransportError",n.description=e,this.emit("error",n),this},r.prototype.open=function(){return"closed"!==this.readyState&&""!==this.readyState||(this.readyState="opening",this.doOpen()),this},r.prototype.close=function(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this},r.prototype.send=function(t){if("open"!==this.readyState)throw new Error("Transport not open");this.write(t)},r.prototype.onOpen=function(){this.readyState="open",this.writable=!0,this.emit("open")},r.prototype.onData=function(t){var e=o.decodePacket(t,this.socket.binaryType);this.onPacket(e)},r.prototype.onPacket=function(t){this.emit("packet",t)},r.prototype.onClose=function(){this.readyState="closed",this.emit("close")}},function(t,e,n){(function(t){function r(t,n){var r="b"+e.packets[t.type]+t.data.data;return n(r)}function o(t,n,r){if(!n)return e.encodeBase64Packet(t,r);var o=t.data,i=new Uint8Array(o),s=new Uint8Array(1+o.byteLength);s[0]=v[t.type];for(var a=0;a<i.length;a++)s[a+1]=i[a];return r(s.buffer)}function i(t,n,r){if(!n)return e.encodeBase64Packet(t,r);var o=new FileReader;return o.onload=function(){t.data=o.result,e.encodePacket(t,n,!0,r)},o.readAsArrayBuffer(t.data)}function s(t,n,r){if(!n)return e.encodeBase64Packet(t,r);if(g)return i(t,n,r);var o=new Uint8Array(1);o[0]=v[t.type];var s=new k([o.buffer,t.data]);return r(s)}function a(t){try{t=d.decode(t,{strict:!1})}catch(e){return!1}return t}function c(t,e,n){for(var r=new Array(t.length),o=l(t.length,n),i=function(t,n,o){e(n,function(e,n){r[t]=n,o(e,r)})},s=0;s<t.length;s++)i(s,t[s],o)}var u,p=n(22),h=n(23),f=n(24),l=n(25),d=n(26);t&&t.ArrayBuffer&&(u=n(28));var y="undefined"!=typeof navigator&&/Android/i.test(navigator.userAgent),m="undefined"!=typeof navigator&&/PhantomJS/i.test(navigator.userAgent),g=y||m;e.protocol=3;var v=e.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},b=p(v),w={type:"error",data:"parser error"},k=n(29);e.encodePacket=function(e,n,i,a){"function"==typeof n&&(a=n,n=!1),"function"==typeof i&&(a=i,i=null);var c=void 0===e.data?void 0:e.data.buffer||e.data;if(t.ArrayBuffer&&c instanceof ArrayBuffer)return o(e,n,a);if(k&&c instanceof t.Blob)return s(e,n,a);if(c&&c.base64)return r(e,a);var u=v[e.type];return void 0!==e.data&&(u+=i?d.encode(String(e.data),{strict:!1}):String(e.data)),a(""+u)},e.encodeBase64Packet=function(n,r){var o="b"+e.packets[n.type];if(k&&n.data instanceof t.Blob){var i=new FileReader;return i.onload=function(){var t=i.result.split(",")[1];r(o+t)},i.readAsDataURL(n.data)}var s;try{s=String.fromCharCode.apply(null,new Uint8Array(n.data))}catch(a){for(var c=new Uint8Array(n.data),u=new Array(c.length),p=0;p<c.length;p++)u[p]=c[p];s=String.fromCharCode.apply(null,u)}return o+=t.btoa(s),r(o)},e.decodePacket=function(t,n,r){if(void 0===t)return w;if("string"==typeof t){if("b"===t.charAt(0))return e.decodeBase64Packet(t.substr(1),n);if(r&&(t=a(t),t===!1))return w;var o=t.charAt(0);return Number(o)==o&&b[o]?t.length>1?{type:b[o],data:t.substring(1)}:{type:b[o]}:w}var i=new Uint8Array(t),o=i[0],s=f(t,1);return k&&"blob"===n&&(s=new k([s])),{type:b[o],data:s}},e.decodeBase64Packet=function(t,e){var n=b[t.charAt(0)];if(!u)return{type:n,data:{base64:!0,data:t.substr(1)}};var r=u.decode(t.substr(1));return"blob"===e&&k&&(r=new k([r])),{type:n,data:r}},e.encodePayload=function(t,n,r){function o(t){return t.length+":"+t}function i(t,r){e.encodePacket(t,!!s&&n,!1,function(t){r(null,o(t))})}"function"==typeof n&&(r=n,n=null);var s=h(t);return n&&s?k&&!g?e.encodePayloadAsBlob(t,r):e.encodePayloadAsArrayBuffer(t,r):t.length?void c(t,i,function(t,e){return r(e.join(""))}):r("0:")},e.decodePayload=function(t,n,r){if("string"!=typeof t)return e.decodePayloadAsBinary(t,n,r);"function"==typeof n&&(r=n,n=null);var o;if(""===t)return r(w,0,1);for(var i,s,a="",c=0,u=t.length;c<u;c++){var p=t.charAt(c);if(":"===p){if(""===a||a!=(i=Number(a)))return r(w,0,1);if(s=t.substr(c+1,i),a!=s.length)return r(w,0,1);if(s.length){if(o=e.decodePacket(s,n,!1),w.type===o.type&&w.data===o.data)return r(w,0,1);var h=r(o,c+i,u);if(!1===h)return}c+=i,a=""}else a+=p}return""!==a?r(w,0,1):void 0},e.encodePayloadAsArrayBuffer=function(t,n){function r(t,n){e.encodePacket(t,!0,!0,function(t){return n(null,t)})}return t.length?void c(t,r,function(t,e){var r=e.reduce(function(t,e){var n;return n="string"==typeof e?e.length:e.byteLength,t+n.toString().length+n+2},0),o=new Uint8Array(r),i=0;return e.forEach(function(t){var e="string"==typeof t,n=t;if(e){for(var r=new Uint8Array(t.length),s=0;s<t.length;s++)r[s]=t.charCodeAt(s);n=r.buffer}e?o[i++]=0:o[i++]=1;for(var a=n.byteLength.toString(),s=0;s<a.length;s++)o[i++]=parseInt(a[s]);o[i++]=255;for(var r=new Uint8Array(n),s=0;s<r.length;s++)o[i++]=r[s]}),n(o.buffer)}):n(new ArrayBuffer(0))},e.encodePayloadAsBlob=function(t,n){function r(t,n){e.encodePacket(t,!0,!0,function(t){var e=new Uint8Array(1);if(e[0]=1,"string"==typeof t){for(var r=new Uint8Array(t.length),o=0;o<t.length;o++)r[o]=t.charCodeAt(o);t=r.buffer,e[0]=0}for(var i=t instanceof ArrayBuffer?t.byteLength:t.size,s=i.toString(),a=new Uint8Array(s.length+1),o=0;o<s.length;o++)a[o]=parseInt(s[o]);if(a[s.length]=255,k){var c=new k([e.buffer,a.buffer,t]);n(null,c)}})}c(t,r,function(t,e){return n(new k(e))})},e.decodePayloadAsBinary=function(t,n,r){"function"==typeof n&&(r=n,n=null);for(var o=t,i=[];o.byteLength>0;){for(var s=new Uint8Array(o),a=0===s[0],c="",u=1;255!==s[u];u++){if(c.length>310)return r(w,0,1);c+=s[u]}o=f(o,2+c.length),c=parseInt(c);var p=f(o,0,c);if(a)try{p=String.fromCharCode.apply(null,new Uint8Array(p))}catch(h){var l=new Uint8Array(p);p="";for(var u=0;u<l.length;u++)p+=String.fromCharCode(l[u])}i.push(p),o=f(o,c)}var d=i.length;i.forEach(function(t,o){r(e.decodePacket(t,n,!0),o,d)})}}).call(e,function(){return this}())},function(t,e){t.exports=Object.keys||function(t){var e=[],n=Object.prototype.hasOwnProperty;for(var r in t)n.call(t,r)&&e.push(r);return e}},function(t,e,n){(function(e){function r(t){if(!t||"object"!=typeof t)return!1;if(o(t)){for(var n=0,i=t.length;n<i;n++)if(r(t[n]))return!0;return!1}if("function"==typeof e.Buffer&&e.Buffer.isBuffer&&e.Buffer.isBuffer(t)||"function"==typeof e.ArrayBuffer&&t instanceof ArrayBuffer||s&&t instanceof Blob||a&&t instanceof File)return!0;if(t.toJSON&&"function"==typeof t.toJSON&&1===arguments.length)return r(t.toJSON(),!0);for(var c in t)if(Object.prototype.hasOwnProperty.call(t,c)&&r(t[c]))return!0;return!1}var o=n(10),i=Object.prototype.toString,s="function"==typeof e.Blob||"[object BlobConstructor]"===i.call(e.Blob),a="function"==typeof e.File||"[object FileConstructor]"===i.call(e.File);t.exports=r}).call(e,function(){return this}())},function(t,e){t.exports=function(t,e,n){var r=t.byteLength;if(e=e||0,n=n||r,t.slice)return t.slice(e,n);if(e<0&&(e+=r),n<0&&(n+=r),n>r&&(n=r),e>=r||e>=n||0===r)return new ArrayBuffer(0);for(var o=new Uint8Array(t),i=new Uint8Array(n-e),s=e,a=0;s<n;s++,a++)i[a]=o[s];return i.buffer}},function(t,e){function n(t,e,n){function o(t,r){if(o.count<=0)throw new Error("after called too many times");--o.count,t?(i=!0,e(t),e=n):0!==o.count||i||e(null,r)}var i=!1;return n=n||r,o.count=t,0===t?e():o}function r(){}t.exports=n},function(t,e,n){var r;(function(t,o){!function(i){function s(t){for(var e,n,r=[],o=0,i=t.length;o<i;)e=t.charCodeAt(o++),e>=55296&&e<=56319&&o<i?(n=t.charCodeAt(o++),56320==(64512&n)?r.push(((1023&e)<<10)+(1023&n)+65536):(r.push(e),o--)):r.push(e);return r}function a(t){for(var e,n=t.length,r=-1,o="";++r<n;)e=t[r],e>65535&&(e-=65536,o+=w(e>>>10&1023|55296),e=56320|1023&e),o+=w(e);return o}function c(t,e){if(t>=55296&&t<=57343){if(e)throw Error("Lone surrogate U+"+t.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function u(t,e){return w(t>>e&63|128)}function p(t,e){if(0==(4294967168&t))return w(t);var n="";return 0==(4294965248&t)?n=w(t>>6&31|192):0==(4294901760&t)?(c(t,e)||(t=65533),n=w(t>>12&15|224),n+=u(t,6)):0==(4292870144&t)&&(n=w(t>>18&7|240),n+=u(t,12),n+=u(t,6)),n+=w(63&t|128)}function h(t,e){e=e||{};for(var n,r=!1!==e.strict,o=s(t),i=o.length,a=-1,c="";++a<i;)n=o[a],c+=p(n,r);return c}function f(){if(b>=v)throw Error("Invalid byte index");var t=255&g[b];if(b++,128==(192&t))return 63&t;throw Error("Invalid continuation byte")}function l(t){var e,n,r,o,i;if(b>v)throw Error("Invalid byte index");if(b==v)return!1;if(e=255&g[b],b++,0==(128&e))return e;if(192==(224&e)){if(n=f(),i=(31&e)<<6|n,i>=128)return i;throw Error("Invalid continuation byte")}if(224==(240&e)){if(n=f(),r=f(),i=(15&e)<<12|n<<6|r,i>=2048)return c(i,t)?i:65533;throw Error("Invalid continuation byte")}if(240==(248&e)&&(n=f(),r=f(),o=f(),i=(7&e)<<18|n<<12|r<<6|o,i>=65536&&i<=1114111))return i;throw Error("Invalid UTF-8 detected")}function d(t,e){e=e||{};var n=!1!==e.strict;g=s(t),v=g.length,b=0;for(var r,o=[];(r=l(n))!==!1;)o.push(r);return a(o)}var y="object"==typeof e&&e,m=("object"==typeof t&&t&&t.exports==y&&t,"object"==typeof o&&o);m.global!==m&&m.window!==m||(i=m);var g,v,b,w=String.fromCharCode,k={version:"2.1.2",encode:h,decode:d};r=function(){return k}.call(e,n,e,t),!(void 0!==r&&(t.exports=r))}(this)}).call(e,n(27)(t),function(){return this}())},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children=[],t.webpackPolyfill=1),t}},function(t,e){!function(){"use strict";for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n=new Uint8Array(256),r=0;r<t.length;r++)n[t.charCodeAt(r)]=r;e.encode=function(e){var n,r=new Uint8Array(e),o=r.length,i="";for(n=0;n<o;n+=3)i+=t[r[n]>>2],i+=t[(3&r[n])<<4|r[n+1]>>4],i+=t[(15&r[n+1])<<2|r[n+2]>>6],i+=t[63&r[n+2]];return o%3===2?i=i.substring(0,i.length-1)+"=":o%3===1&&(i=i.substring(0,i.length-2)+"=="),i},e.decode=function(t){var e,r,o,i,s,a=.75*t.length,c=t.length,u=0;"="===t[t.length-1]&&(a--,"="===t[t.length-2]&&a--);var p=new ArrayBuffer(a),h=new Uint8Array(p);for(e=0;e<c;e+=4)r=n[t.charCodeAt(e)],o=n[t.charCodeAt(e+1)],i=n[t.charCodeAt(e+2)],s=n[t.charCodeAt(e+3)],h[u++]=r<<2|o>>4,h[u++]=(15&o)<<4|i>>2,h[u++]=(3&i)<<6|63&s;return p}}()},function(t,e){(function(e){function n(t){for(var e=0;e<t.length;e++){var n=t[e];if(n.buffer instanceof ArrayBuffer){var r=n.buffer;if(n.byteLength!==r.byteLength){var o=new Uint8Array(n.byteLength);o.set(new Uint8Array(r,n.byteOffset,n.byteLength)),r=o.buffer}t[e]=r}}}function r(t,e){e=e||{};var r=new i;n(t);for(var o=0;o<t.length;o++)r.append(t[o]);return e.type?r.getBlob(e.type):r.getBlob()}function o(t,e){return n(t),new Blob(t,e||{})}var i=e.BlobBuilder||e.WebKitBlobBuilder||e.MSBlobBuilder||e.MozBlobBuilder,s=function(){try{var t=new Blob(["hi"]);return 2===t.size}catch(e){return!1}}(),a=s&&function(){try{var t=new Blob([new Uint8Array([1,2])]);return 2===t.size}catch(e){return!1}}(),c=i&&i.prototype.append&&i.prototype.getBlob;t.exports=function(){return s?a?e.Blob:o:c?r:void 0}()}).call(e,function(){return this}())},function(t,e){e.encode=function(t){var e="";for(var n in t)t.hasOwnProperty(n)&&(e.length&&(e+="&"),e+=encodeURIComponent(n)+"="+encodeURIComponent(t[n]));return e},e.decode=function(t){for(var e={},n=t.split("&"),r=0,o=n.length;r<o;r++){var i=n[r].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}},function(t,e){t.exports=function(t,e){var n=function(){};n.prototype=e.prototype,t.prototype=new n,t.prototype.constructor=t}},function(t,e){"use strict";function n(t){var e="";do e=s[t%a]+e,t=Math.floor(t/a);while(t>0);return e}function r(t){var e=0;for(p=0;p<t.length;p++)e=e*a+c[t.charAt(p)];return e}function o(){var t=n(+new Date);return t!==i?(u=0,i=t):t+"."+n(u++)}for(var i,s="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),a=64,c={},u=0,p=0;p<a;p++)c[s[p]]=p;o.encode=n,o.decode=r,t.exports=o},function(t,e,n){(function(e){function r(){}function o(t){i.call(this,t),this.query=this.query||{},a||(e.___eio||(e.___eio=[]),a=e.___eio),this.index=a.length;var n=this;a.push(function(t){n.onData(t)}),this.query.j=this.index,e.document&&e.addEventListener&&e.addEventListener("beforeunload",function(){n.script&&(n.script.onerror=r)},!1)}var i=n(19),s=n(31);t.exports=o;var a,c=/\n/g,u=/\\n/g;s(o,i),o.prototype.supportsBinary=!1,o.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),i.prototype.doClose.call(this)},o.prototype.doPoll=function(){var t=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(e){t.onError("jsonp poll error",e)};var n=document.getElementsByTagName("script")[0];n?n.parentNode.insertBefore(e,n):(document.head||document.body).appendChild(e),this.script=e;var r="undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent);r&&setTimeout(function(){var t=document.createElement("iframe");document.body.appendChild(t),document.body.removeChild(t)},100)},o.prototype.doWrite=function(t,e){function n(){r(),e()}function r(){if(o.iframe)try{o.form.removeChild(o.iframe)}catch(t){o.onError("jsonp polling iframe removal error",t)}try{var e='<iframe src="javascript:0" name="'+o.iframeId+'">';i=document.createElement(e)}catch(t){i=document.createElement("iframe"),i.name=o.iframeId,i.src="javascript:0"}i.id=o.iframeId,o.form.appendChild(i),o.iframe=i}var o=this;if(!this.form){var i,s=document.createElement("form"),a=document.createElement("textarea"),p=this.iframeId="eio_iframe_"+this.index;s.className="socketio",s.style.position="absolute",s.style.top="-1000px",s.style.left="-1000px",s.target=p,s.method="POST",s.setAttribute("accept-charset","utf-8"),a.name="d",s.appendChild(a),document.body.appendChild(s),this.form=s,this.area=a}this.form.action=this.uri(),r(),t=t.replace(u,"\\\n"),this.area.value=t.replace(c,"\\n");try{this.form.submit()}catch(h){}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){"complete"===o.iframe.readyState&&n()}:this.iframe.onload=n}}).call(e,function(){return this}())},function(t,e,n){(function(e){function r(t){var e=t&&t.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=t.perMessageDeflate,this.usingBrowserWebSocket=h&&!t.forceNode,this.protocols=t.protocols,this.usingBrowserWebSocket||(l=o),i.call(this,t)}var o,i=n(20),s=n(21),a=n(30),c=n(31),u=n(32),p=n(3)("engine.io-client:websocket"),h=e.WebSocket||e.MozWebSocket;if("undefined"==typeof window)try{o=n(35)}catch(f){}var l=h;l||"undefined"!=typeof window||(l=o),t.exports=r,c(r,i),r.prototype.name="websocket",r.prototype.supportsBinary=!0,r.prototype.doOpen=function(){if(this.check()){var t=this.uri(),e=this.protocols,n={agent:this.agent,perMessageDeflate:this.perMessageDeflate};n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized,this.extraHeaders&&(n.headers=this.extraHeaders),this.localAddress&&(n.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket?e?new l(t,e):new l(t):new l(t,e,n)}catch(r){return this.emit("error",r)}void 0===this.ws.binaryType&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}},r.prototype.addEventListeners=function(){var t=this;this.ws.onopen=function(){t.onOpen()},this.ws.onclose=function(){t.onClose()},this.ws.onmessage=function(e){t.onData(e.data)},this.ws.onerror=function(e){t.onError("websocket error",e)}},r.prototype.write=function(t){function n(){r.emit("flush"),setTimeout(function(){r.writable=!0,r.emit("drain")},0)}var r=this;this.writable=!1;for(var o=t.length,i=0,a=o;i<a;i++)!function(t){s.encodePacket(t,r.supportsBinary,function(i){if(!r.usingBrowserWebSocket){var s={};if(t.options&&(s.compress=t.options.compress),r.perMessageDeflate){var a="string"==typeof i?e.Buffer.byteLength(i):i.length;a<r.perMessageDeflate.threshold&&(s.compress=!1)}}try{r.usingBrowserWebSocket?r.ws.send(i):r.ws.send(i,s)}catch(c){p("websocket closed before onclose event")}--o||n()})}(t[i])},r.prototype.onClose=function(){i.prototype.onClose.call(this)},r.prototype.doClose=function(){"undefined"!=typeof this.ws&&this.ws.close()},r.prototype.uri=function(){var t=this.query||{},e=this.secure?"wss":"ws",n="";this.port&&("wss"===e&&443!==Number(this.port)||"ws"===e&&80!==Number(this.port))&&(n=":"+this.port),this.timestampRequests&&(t[this.timestampParam]=u()),this.supportsBinary||(t.b64=1),t=a.encode(t),t.length&&(t="?"+t);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+n+this.path+t},r.prototype.check=function(){return!(!l||"__initialize"in l&&this.name===r.prototype.name)}}).call(e,function(){return this}())},function(t,e){},function(t,e){var n=[].indexOf;t.exports=function(t,e){if(n)return t.indexOf(e);for(var r=0;r<t.length;++r)if(t[r]===e)return r;return-1}},function(t,e,n){"use strict";function r(t,e,n){this.io=t,this.nsp=e,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,this.flags={},n&&n.query&&(this.query=n.query),this.io.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(7),s=n(8),a=n(38),c=n(39),u=n(40),p=n(3)("socket.io-client:socket"),h=n(30),f=n(23);t.exports=e=r;var l={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},d=s.prototype.emit;s(r.prototype),r.prototype.subEvents=function(){if(!this.subs){var t=this.io;this.subs=[c(t,"open",u(this,"onopen")),c(t,"packet",u(this,"onpacket")),c(t,"close",u(this,"onclose"))]}},r.prototype.open=r.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.open(),"open"===this.io.readyState&&this.onopen(),this.emit("connecting"),this)},r.prototype.send=function(){var t=a(arguments);return t.unshift("message"),this.emit.apply(this,t),this},r.prototype.emit=function(t){if(l.hasOwnProperty(t))return d.apply(this,arguments),this;var e=a(arguments),n={type:(void 0!==this.flags.binary?this.flags.binary:f(e))?i.BINARY_EVENT:i.EVENT,data:e};return n.options={},n.options.compress=!this.flags||!1!==this.flags.compress,"function"==typeof e[e.length-1]&&(p("emitting packet with ack id %d",this.ids),this.acks[this.ids]=e.pop(),n.id=this.ids++),this.connected?this.packet(n):this.sendBuffer.push(n),this.flags={},this},r.prototype.packet=function(t){t.nsp=this.nsp,this.io.packet(t)},r.prototype.onopen=function(){if(p("transport is open - connecting"),"/"!==this.nsp)if(this.query){var t="object"===o(this.query)?h.encode(this.query):this.query;p("sending connect packet with query %s",t),this.packet({type:i.CONNECT,query:t})}else this.packet({type:i.CONNECT})},r.prototype.onclose=function(t){p("close (%s)",t),this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",t)},r.prototype.onpacket=function(t){var e=t.nsp===this.nsp,n=t.type===i.ERROR&&"/"===t.nsp;if(e||n)switch(t.type){case i.CONNECT:this.onconnect();break;case i.EVENT:this.onevent(t);break;case i.BINARY_EVENT:this.onevent(t);break;case i.ACK:this.onack(t);break;case i.BINARY_ACK:this.onack(t);break;case i.DISCONNECT:this.ondisconnect();break;case i.ERROR:this.emit("error",t.data)}},r.prototype.onevent=function(t){var e=t.data||[];p("emitting event %j",e),null!=t.id&&(p("attaching ack callback to event"),e.push(this.ack(t.id))),this.connected?d.apply(this,e):this.receiveBuffer.push(e)},r.prototype.ack=function(t){var e=this,n=!1;return function(){if(!n){n=!0;var r=a(arguments);p("sending ack %j",r),e.packet({type:f(r)?i.BINARY_ACK:i.ACK,id:t,data:r})}}},r.prototype.onack=function(t){var e=this.acks[t.id];"function"==typeof e?(p("calling ack %s with %j",t.id,t.data),e.apply(this,t.data),delete this.acks[t.id]):p("bad ack %s",t.id)},r.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emit("connect"),this.emitBuffered()},r.prototype.emitBuffered=function(){var t;for(t=0;t<this.receiveBuffer.length;t++)d.apply(this,this.receiveBuffer[t]);for(this.receiveBuffer=[],t=0;t<this.sendBuffer.length;t++)this.packet(this.sendBuffer[t]);this.sendBuffer=[]},r.prototype.ondisconnect=function(){p("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")},r.prototype.destroy=function(){if(this.subs){for(var t=0;t<this.subs.length;t++)this.subs[t].destroy();this.subs=null}this.io.destroy(this)},r.prototype.close=r.prototype.disconnect=function(){return this.connected&&(p("performing disconnect (%s)",this.nsp),this.packet({type:i.DISCONNECT})),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},r.prototype.compress=function(t){return this.flags.compress=t,this},r.prototype.binary=function(t){return this.flags.binary=t,this}},function(t,e){function n(t,e){var n=[];e=e||0;for(var r=e||0;r<t.length;r++)n[r-e]=t[r];return n}t.exports=n},function(t,e){"use strict";function n(t,e,n){return t.on(e,n),{destroy:function(){t.removeListener(e,n)}}}t.exports=n},function(t,e){var n=[].slice;t.exports=function(t,e){if("string"==typeof e&&(e=t[e]),"function"!=typeof e)throw new Error("bind() requires a function");var r=n.call(arguments,2);return function(){return e.apply(t,r.concat(n.call(arguments)))}}},function(t,e){function n(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}t.exports=n,n.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),n=Math.floor(e*this.jitter*t);t=0==(1&Math.floor(10*e))?t-n:t+n}return 0|Math.min(t,this.max)},n.prototype.reset=function(){this.attempts=0},n.prototype.setMin=function(t){this.ms=t},n.prototype.setMax=function(t){this.max=t},n.prototype.setJitter=function(t){this.jitter=t}}])});
;//
// the below code is a copy of the standard polyfill adapter.js
//
/*global easyrtc */
var easyrtc_constantStrings = {
    "unableToEnterRoom":"Unable to enter room {0} because {1}" ,
    "resolutionWarning": "Requested video size of {0}x{1} but got size of {2}x{3}",
    "badUserName": "Illegal username {0}",
    "localMediaError": "Error getting local media stream: {0}",
    "miscSignalError": "Miscellaneous error from signalling server. It may be ignorable.",
    "noServer": "Unable to reach the EasyRTC signalling server.",
    "badsocket": "Socket.io connect event fired with bad websocket.",
    "icf": "Internal communications failure",
    "statsNotSupported":"call statistics not supported by this browser, try Chrome.",
    "noWebrtcSupport":"Your browser doesn't appear to support WebRTC.",
    "gumFailed":"Failed to get access to local media. Error code was {0}.",
    "requireAudioOrVideo":"At least one of audio and video must be provided"
};
var
    attachMediaStream = null,
    reattachMediaStream = null,
    webrtcDetectedBrowser = null,
    webrtcDetectedVersion = null,
    wRTCPeerConnection,
    wRTCSessionDescription,
    wRTCIceCandidate,
    nGetUserMedia,
    createIceServer;
if (navigator.mozGetUserMedia) {
    // console.log("This appears to be Firefox");

    webrtcDetectedBrowser = "firefox";

    //
    // better version detection for gecko based browsers provided by
    // Kvin Poulet.
    //
    var matches = navigator.userAgent.match( /\srv:([0-9]+)\./ );
    if( matches !== null && matches.length > 1 ) {
        webrtcDetectedVersion = parseInt( matches[ 1 ] );
    }

    // The RTCPeerConnection object.
    wRTCPeerConnection = window.mozRTCPeerConnection;
    // The RTCSessionDescription object.
    wRTCSessionDescription = window.mozRTCSessionDescription;
    // The RTCIceCandidate object.
    wRTCIceCandidate = window.mozRTCIceCandidate;
    // Get UserMedia (only difference is the prefix).
    // Code from Adam Barth.
    nGetUserMedia = navigator.mozGetUserMedia.bind( navigator );
    // Creates iceServer from the url for FF.
    createIceServer = function( url, username, password ) {
        var iceServer = null;
        var url_parts = url.split( ':' );
        var turn_url_parts;
        if( url_parts[ 0 ].indexOf( 'stun' ) === 0 ) {
            // Create iceServer with stun url.
            iceServer = { 'url': url };
        } else if( url_parts[ 0 ].indexOf( 'turn' ) === 0 &&
                   (url.indexOf( 'transport=udp' ) !== -1 ||
                    url.indexOf( '?transport' ) === -1) ) {
            // Create iceServer with turn url.
            // Ignore the transport parameter from TURN url.
            turn_url_parts = url.split( "?" );
            iceServer = {
                'url': turn_url_parts[ 0 ],
                'credential': password,
                'username': username
            };
        }
        return iceServer;
    };
    // Attach a media stream to an element.
    attachMediaStream = function( element, stream ) {
        //        console.log("Attaching media stream");
        if (typeof element.mozSrcObject !== 'undefined') {
            element.mozSrcObject = stream;
        } else if (typeof element.srcObject !== 'undefined') {
            element.srcObject = stream;
        } else if (typeof element.src !== 'undefined') {
            element.src = URL.createObjectURL(stream);
        } else {
            console.log('Error attaching stream to element.');
        }
        element.play();
    };
    reattachMediaStream = function( to, from ) {
        //        console.log("Reattaching media stream");
        to.mozSrcObject = from.mozSrcObject;
        to.play();
    };
} else if (navigator.webkitGetUserMedia) {
//    console.log("This appears to be Chrome");

    webrtcDetectedBrowser = "chrome";
    webrtcDetectedVersion = parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2]);
    // Creates iceServer from the url for Chrome.
    createIceServer = function(url, username, password) {
        var iceServer = null;
        var url_turn_parts;
        var url_parts = url.split(':');
        if (url_parts[0].indexOf('stun') === 0) {
// Create iceServer with stun url.
            iceServer = {'url': url};
        } else if (url_parts[0].indexOf('turn') === 0) {
            if (webrtcDetectedVersion < 28) {
// For pre-M28 chrome versions use old TURN format.
                url_turn_parts = url.split("turn:");
                iceServer = {'url': 'turn:' + username + '@' + url_turn_parts[1],
                    'credential': password};
            } else {
// For Chrome M28 & above use new TURN format.
                iceServer = {'url': url,
                    'credential': password,
                    'username': username};
            }
        }
        return iceServer;
    };
    // The RTCPeerConnection object.
    wRTCPeerConnection = window.webkitRTCPeerConnection;

    wRTCSessionDescription = window.RTCSessionDescription;
    wRTCIceCandidate = window.RTCIceCandidate;

    // Get UserMedia (only difference is the prefix).
    // Code from Adam Barth.
    nGetUserMedia = navigator.webkitGetUserMedia.bind(navigator);
    // Attach a media stream to an element.
    attachMediaStream = function(element, stream) {
        if (typeof element.srcObject !== 'undefined') {
            element.srcObject = stream;
        } else if (typeof element.mozSrcObject !== 'undefined') {
            element.mozSrcObject = stream;
        } else if (typeof element.src !== 'undefined') {
            element.src = URL.createObjectURL(stream);
        } else {
            console.log('Error attaching stream to element.');
        }
    };
    reattachMediaStream = function(to, from) {
        to.src = from.src;
    };
    // The representation of tracks in a stream is changed in M26.
    // Unify them for earlier Chrome versions in the coexisting period.
    if (!webkitMediaStream.prototype.getVideoTracks) {
        webkitMediaStream.prototype.getVideoTracks = function() {
            return this.videoTracks;
        };
        webkitMediaStream.prototype.getAudioTracks = function() {
            return this.audioTracks;
        };
    }

// New syntax of getXXXStreams method in M26.
    if (!wRTCPeerConnection.prototype.getLocalStreams) {
        wRTCPeerConnection.prototype.getLocalStreams = function() {
            return this.localStreams;
        };
        wRTCPeerConnection.prototype.getRemoteStreams = function() {
            return this.remoteStreams;
        };
    }
} else {
    wRTCPeerConnection = window.RTCPeerConnection || function(){};
    wRTCSessionDescription = window.RTCSessionDescription || function(){};
    wRTCIceCandidate = window.RTCIceCandidate || function(){};
    nGetUserMedia = navigator.getUserMedia && navigator.getUserMedia.bind( navigator ) || function(){};
    attachMediaStream = function(element, stream) {
        if (typeof element.srcObject !== 'undefined') {
            element.srcObject = stream;
        } else if (typeof element.src !== 'undefined') {
            element.src = URL.createObjectURL(stream);
        } else {
            console.log('Error attaching stream to element.');
        }
    };
    reattachMediaStream = function(to, from) {
        to.srcObject = from.srcObject;
        to.src = from.src;
    };
    createIceServer = function(url, username, password) {
        var iceServer = null,
            url_turn_parts,
            url_parts = url.split(':');
        if (url_parts[0].indexOf('stun') === 0) {
            // Create iceServer with stun url.
            iceServer = {'url': url};
        } else if (url_parts[0].indexOf('turn') === 0) {
                // For Chrome M28 & above use new TURN format.
                iceServer = {'url': url,
                    'credential': password,
                    'username': username};
        }
        return iceServer;
    };
    console.log("Browser may not appear to be WebRTC-capable");
}

if (!createIceServer) {
    createIceServer = function(url, username, credential) {
        return {'url': url, 'credential': credential, 'username': username};
    };
}/** @class
 *@version 1.0.13
 *<p>
 * Provides client side support for the EasyRTC framework.
 * Please see the easyrtc_client_api.md and easyrtc_client_tutorial.md
 * for more details.</p>
 *
 *<p>
 *copyright Copyright (c) 2014, Priologic Software Inc.
 *All rights reserved.</p>
 *
 *<p>
 *Redistribution and use in source and binary forms, with or without
 *modification, are permitted provided that the following conditions are met:
 *</p>
 * <ul>
 *   <li> Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer. </li>
 *   <li> Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution. </li>
 *</ul>
 *<p>
 *THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 *LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 *CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *POSSIBILITY OF SUCH DAMAGE.
 *</p>
 */

var Easyrtc = function() {
    var self = this;
    var isFirefox = (webrtcDetectedBrowser === "firefox");
    var autoInitUserMedia = true;
    var sdpLocalFilter = null,
            sdpRemoteFilter = null;
    var iceCandidateFilter = null;
    
    var connectionOptions =  {
                'connect timeout': 10000,
                'force new connection': true
            };
   
    /**
     * Sets functions which filter sdp records before calling setLocalDescription or setRemoteDescription.
     * This is advanced functionality which can break things, easily. See the easyrtc_rates.js file for a
     * filter builder.
     * @param {Function} localFilter a function that takes an sdp string and returns an sdp string.
     * @param {Function} remoteFilter a function that takes an sdp string and returns an sdp string.
     */
    this.setSdpFilters = function(localFilter, remoteFilter) {
        sdpLocalFilter = localFilter;
        sdpRemoteFilter = remoteFilter;
    };

        /**
         * true - FF, false - Chrome
         * @method isFirefox
         * @returns {boolean}
         */
        this.isFireFox = function() {
            return isFirefox;
        };

   /**
    * Sets a function which filters IceCandidate records being sent or received.
    *
    * Candidate records can be received while they are being generated locally (before being 
    * sent to a peer), and after they are received by the peer. The filter receives two arguments, the candidate record and a boolean 
    * flag that is true for a candidate being received from another peer,  
    * and false for a candidate that was generated locally. The candidate record has the form:
    *  {type: 'candidate', label: sdpMLineIndex, id: sdpMid, candidate: candidateString}
    * The function should return one of the following: the input candidate record, a modified candidate record, or null (indicating that the
    * candidate should be discarded).
    * @param {Function} filter
    * @param {String} isIncoming 
    * @return an ice candidate record or null.
    */
   this.setIceCandidateFilter = function(filter) {
      iceCandidateFilter = filter;
   };

    /**
     * Controls whether a default local media stream should be acquired automatically during calls and accepts
     * if a list of streamNames is not supplied. The default is true, which mimicks the behaviour of earlier releases
     * that didn't support multiple streams. This function should be called before easyrtc.call or before entering an 
     * accept  callback.
     * @param {Boolean} flag true to allocate a default local media stream.
     */
    this.setAutoInitUserMedia = function(flag) {
        autoInitUserMedia = !!flag;
    };
    /**
     * This function performs a printf like formatting. It actually takes an unlimited
     * number of arguments, the declared arguments arg1, arg2, arg3 are present just for
     * documentation purposes.
     * @param {String} format A string like "abcd{1}efg{2}hij{1}."
     * @param {String} arg1 The value that replaces {1}
     * @param {String} arg2 The value that replaces {2}
     * @param {String} arg3 The value that replaces {3}
     * @returns {String} the formatted string.
     */
    this.format = function(/*format, arg1, arg2, arg3*/) {
        var formatted = arguments[0];
        for (var i = 1; i < arguments.length; i++) {
            var regexp = new RegExp('\\{' + (i - 1) + '\\}', 'gi');
            formatted = formatted.replace(regexp, arguments[i]);
        }
        return formatted;
    };
    /** @private */
    var haveAudioVideo = {audio: false, video: false};
//
// Maps a key to a language specific string using the easyrtc_constantStrings map.
// Defaults to the key if the key can not be found, but outputs a warning in that case.
// This function is only used internally by easyrtc.js 
//
    /**
     * @private
     * @param {String} key
     */
    this.getConstantString = function(key) {
        if (easyrtc_constantStrings[key]) {
            return easyrtc_constantStrings[key];
        }
        else {
            console.warn("Could not find key='" + key + "' in easyrtc_constantStrings");
            return key;
        }
    };
    //
    // this is a list of the events supported by the generalized event listener.
    //
    var allowedEvents = {
        roomOccupant: true,  // this receives the list of everybody in any room you belong to
        roomOccupants: true  // this receives a {roomName:..., occupants:...} value for a specific room
    };
    //
    // A map of eventListeners. The key is the event type.
    var eventListeners = {};
    /** This function checks if an attempt was made to add an event listener or 
     * or emit an unlisted event, since such is typically a typo. 
     * @private
     * @param {String} eventName
     * @param {String} callingFunction the name of the calling function.
     */
    function event(eventName/*, callingFunction*/) {
        if (typeof eventName !== 'string') {
            self.showError(self.errCodes.DEVELOPER_ERR, src + " called without a string as the first argument");
            throw "developer error";
        }
        if (!allowedEvents[eventName]) {
            self.showError(self.errCodes.DEVELOPER_ERR, src + " called with a bad event name = " + eventName);
            throw "developer error";
        }
    }

    /**
     * Adds an event listener for a particular type of event.
     * Currently the only eventName supported is "roomOccupant".
     * @param {String} eventName the type of the event
     * @param {Function} eventListener the function that expects the event. 
     * The eventListener gets called with the eventName as it's first argument, and the event
     * data as it's second argument.
     * @returns {void}
     */
    this.addEventListener = function(eventName, eventListener) {
        event(eventName, "addEventListener");
        if (typeof eventListener !== 'function') {
            self.showError(self.errCodes.DEVELOPER_ERR, "addEventListener called with a non-function for second argument");
            throw "developer error";
        }
        //
        // remove the event listener if it's already present so we don't end up with two copies
        //
        self.removeEventListener(eventName, eventListener);
        if (!eventListeners[eventName]) {
            eventListeners[eventName] = [];
        }
        eventListeners[eventName][eventListeners[eventName].length] = eventListener;
    };
    /**
     * Removes an event listener. 
     * @param {String} eventName
     * @param {Function} eventListener
     */
    this.removeEventListener = function(eventName, eventListener) {
        event(eventName, "removeEventListener");
        var listeners = eventListeners[eventName];
        var i = 0;
        if (listeners) {
            for (i = 0; i < listeners.length; i++) {
                if (listeners[i] === eventListener) {
                    if (i < listeners.length - 1) {
                        listeners[i] = listeners[listeners.length - 1];
                    }
                    listeners.length = listeners.length - 1;
                }
            }
        }
    };
    /**
     * Emits an event, or in otherwords, calls all the eventListeners for a 
     * particular event.
     * @param {String} eventName
     * @param {Object} eventData
     */
    this.emitEvent = function(eventName, eventData) {
        event(eventName, "emitEvent");
        var listeners = eventListeners[eventName];
        var i = 0;
        if (listeners) {
            for (i = 0; i < listeners.length; i++) {
                listeners[i](eventName, eventData);
            }
        }
    };
    /** Error codes that the EasyRTC will use in the errorCode field of error object passed
     *  to error handler set by easyrtc.setOnError. The error codes are short printable strings.
     * @type Object
     */
    this.errCodes = {
        BAD_NAME: "BAD_NAME", // a user name wasn't of the desired form
        CALL_ERR: "CALL_ERR", // something went wrong creating the peer connection
        DEVELOPER_ERR: "DEVELOPER_ERR", // the developer using the EasyRTC library made a mistake
        SYSTEM_ERR: "SYSTEM_ERR", // probably an error related to the network
        CONNECT_ERR: "CONNECT_ERR", // error occurred when trying to create a connection
        MEDIA_ERR: "MEDIA_ERR", // unable to get the local media
        MEDIA_WARNING: "MEDIA_WARNING", // didn't get the desired resolution
        INTERNAL_ERR: "INTERNAL_ERR",
        PEER_GONE: "PEER_GONE", // peer doesn't exist
        ALREADY_CONNECTED: "ALREADY_CONNECTED",
        BAD_CREDENTIAL: "BAD_CREDENTIAL",
        ICECANDIDATE_ERR: "ICECANDIDATE_ERROR"
    };
    this.apiVersion = "1.0.13";
    /** Most basic message acknowledgment object */
    this.ackMessage = {msgType: "ack"};
    /** Regular expression pattern for user ids. This will need modification to support non US character sets */
    this.usernameRegExp = /^(.){1,64}$/;
    //
    // A map of ids to local media streams.
    //
    var namedLocalMediaStreams = {};
    var sessionFields = [];
    var receivedMediaContraints = {
        'mandatory': {
            'OfferToReceiveAudio': true,
            'OfferToReceiveVideo': true
        }
    };
    /**
     * Control whether the client requests audio from a peer during a call.
     * Must be called before the call to have an effect.
     * @param value - true to receive audio, false otherwise. The default is true.
     */
    this.enableAudioReceive = function(value) {
        receivedMediaContraints.mandatory.OfferToReceiveAudio = value;
    };
    /**
     * Control whether the client requests video from a peer during a call.
     * Must be called before the call to have an effect.
     * @param value - true to receive video, false otherwise. The default is true.
     */
    this.enableVideoReceive = function(value) {
        receivedMediaContraints.mandatory.OfferToReceiveVideo = value;
    };

    function getSourceList(callback, sourceType) {
        if (MediaStreamTrack.getSources) {
            MediaStreamTrack.getSources(function(sources) {
                var results = [];
                for (var i = 0; i < sources.length; i++) {
                    var source = sources[i];
                    if (source.kind == sourceType) {
                        results.push(source);
                    }
                }
                callback(results);
            });
        }
        else {
            callback([]);
        }
    }

    /**
     * Gets a list of the available audio sources (ie, cameras)
     * @param {Function} callback receives list of {label:String, id:String, kind:"audio"}
     * Note: the label string always seems to be the empty string if you aren't using https.
     * Note: not supported by Firefox. 
     * @example  easyrtc.getAudioSourceList( function(list) {
     *               var i;
     *               for( i = 0; i < list.length; i++ ) {
     *                   console.log("label=" + list[i].label + ", id= " + list[i].id);
     *               }
     *          });
     */
    this.getAudioSourceList = function(callback){
       getSourceList(callback, "audio");
    };

    /**
     * Gets a list of the available video sources (ie, cameras)
     * @param {Function} callback receives list of {facing:String, label:String, id:String, kind:"video"}
     * Note: the label string always seems to be the empty string if you aren't using https.
     * Note: not supported by Firefox. 
     * @example  easyrtc.getVideoSourceList( function(list) {
     *               var i;
     *               for( i = 0; i < list.length; i++ ) {
     *                   console.log("label=" + list[i].label + ", id= " + list[i].id);
     *               }
     *          });
     */
    this.getVideoSourceList = function(callback) {
       getSourceList(callback, "video");
    };

    /** @private */
    var audioEnabled = true;
    /** @private */
    var videoEnabled = true;
    /** @private */
    var dataChannelName = "dc";
    /** @private */
    this.debugPrinter = null;
    /** Your easyrtcid */
    this.myEasyrtcid = "";
    /** @private */
    var oldConfig = {};
    /** @private */
    var offersPending = {};
    /** @private */
    var selfRoomJoinTime = 0;
    /** The height of the local media stream video in pixels. This field is set an indeterminate period
     * of time after easyrtc.initMediaSource succeeds. Note: in actuality, the dimensions of a video stream
     * change dynamically in response to external factors, you should check the videoWidth and videoHeight attributes
     * of your video objects before you use them for pixel specific operations.
     */
    this.nativeVideoHeight = 0;
    /** The width of the local media stream video in pixels. This field is set an indeterminate period
     * of time after easyrtc.initMediaSource succeeds.  Note: in actuality, the dimensions of a video stream
     * change dynamically in response to external factors, you should check the videoWidth and videoHeight attributes
     * of your video objects before you use them for pixel specific operations.
     */
    this.nativeVideoWidth = 0;
    /** @private */
    var credential = null;
    /** The rooms the user is in. This only applies to room oriented applications and is set at the same
     * time a token is received. 
     */
    this.roomJoin = {};
    /** Checks if the supplied string is a valid user name (standard identifier rules)
     * @param {String} name
     * @return {Boolean} true for a valid user name
     * @example
     *    var name = document.getElementById('nameField').value;
     *    if( !easyrtc.isNameValid(name)){
     *        console.error("Bad user name");
     *    }
     */
    this.isNameValid = function(name) {
        return self.usernameRegExp.test(name);
    };
    /**
     * This function sets the name of the cookie that client side library will look for
     * and transmit back to the server as it's easyrtcsid in the first message.
     * @param {String} cookieId
     */
    this.setCookieId = function(cookieId) {
        self.cookieId = cookieId;
    };
    /**
     * This method allows you to join a single room. It may be called multiple times to be in
     * multiple rooms simultaneously. It may be called before or after connecting to the server.
     * Note: the successCB and failureDB will only be called if you are already connected to the server.
     * @param {String} roomName the room to be joined.
     * @param {String} roomParameters application specific parameters, can be null.
     * @param {Function} successCB called once, with a roomName as it's argument, once the room is joined.
     * @param {Function} failureCB called if the room can not be joined. The arguments of failureCB are errorCode, errorText, roomName.
     */
    this.joinRoom = function(roomName, roomParameters, successCB, failureCB) {
        if (self.roomJoin[roomName]) {
            console.error("Developer error: attempt to join room " + roomName + " which you are already in.");
            return;
        }

        var newRoomData = {roomName: roomName};
        if (roomParameters) {
            try {
                JSON.stringify(roomParameters);
            } catch (error) {
                self.showError(self.errCodes.DEVELOPER_ERR, "non-jsonable parameter to easyrtc.joinRoom");
                throw "Developer error, see application error messages";
            }
            var parameters = {};
            for (var key in roomParameters) {
                if (roomParameters.hasOwnProperty(key)) {
                    parameters[key] = roomParameters[key];
                }
            }
            newRoomData.roomParameter = parameters;
        }
        var msgData = {
            roomJoin: {}
        };
        var roomData;
        var signallingSuccess, signallingFailure;
        if (self.webSocket) {

            msgData.roomJoin[roomName] = newRoomData;
            signallingSuccess = function(msgType, msgData) {

                roomData = msgData.roomData;
                self.roomJoin[roomName] = newRoomData;
                if (successCB) {
                    successCB(roomName);
                }

                processRoomData(roomData);
            };
            signallingFailure = function(errorCode, errorText) {
                if (failureCB) {
                    failureCB(errorCode, errorText, roomName);
                }
                else {
                    self.showError(errorCode, self.format(self.getConstantString("unableToEnterRoom"), roomName, errorText));
                }
            };
            sendSignalling(null, "roomJoin", msgData, signallingSuccess, signallingFailure);
        }
        else {
            self.roomJoin[roomName] = newRoomData;
        }

    };
    /**
     * This function allows you to leave a single room. Note: the successCB and failureDB
     *  arguments are optional and will only be called if you are already connected to the server.
     * @param {String} roomName
     * @param {Function} successCallback - A function which expects a roomName.
     * @param {Function} failureCallback - A function which expects the following arguments: errorCode, errorText, roomName.
     * @example
     *    easyrtc.leaveRoom("freds_room");
     *    easyrtc.leaveRoom("freds_room", function(roomName){ console.log("left the room")},
     *                       function(errorCode, errorText, roomName){ console.log("left the room")});
     */
    this.leaveRoom = function(roomName, successCallback, failureCallback) {
        var roomItem;
        if (self.roomJoin[roomName]) {
            if (!self.webSocket) {
                delete self.roomJoin[roomName];
            }
            else {
                roomItem = {};
                roomItem[roomName] = {roomName: roomName};
                sendSignalling(null, "roomLeave", {roomLeave: roomItem},
                function(msgType, msgData) {
                    var roomData = msgData.roomData;
                    processRoomData(roomData);
                    if (successCallback) {
                        successCallback(roomName);
                    }
                },
                        function(errorCode, errorText) {
                            if (failureCallback) {
                                failureCallback(errorCode, errorText, roomName);
                            }
                        });
            }
        }
    };
    /** @private */
    this._desiredVideoProperties = {}; // default camera


    /**
     * Specify particular video source. Call this before you call easyrtc.initMediaSource().
     * Note: this function isn't supported by Firefox.
     * @param {String} videoSrcId is a id value from one of the entries fetched by getVideoSourceList. null for default.
     * @example easyrtc.setVideoSrc( videoSrcId);
     */
    this.setVideoSource = function(videoSrcId) {
        self._desiredVideoProperties.videoSrcId = videoSrcId;
        delete self._desiredVideoProperties.screenCapture;
    };
    /**
     * Temporary alias for easyrtc.setVideoSource
     */
    this.setVideoSrc = this.setVideoSource;
    delete this._desiredVideoProperties.screenCapture;
    /** This function is used to set the dimensions of the local camera, usually to get HD.
     *  If called, it must be called before calling easyrtc.initMediaSource (explicitly or implicitly).
     *  assuming it is supported. If you don't pass any parameters, it will default to 720p dimensions.
     * @param {Number} width in pixels
     * @param {Number} height in pixels
     * @param {number} frameRate is optional
     * @example
     *    easyrtc.setVideoDims(1280,720);
     * @example
     *    easyrtc.setVideoDims();
     */
    this.setVideoDims = function(width, height, frameRate) {
        if (!width) {
            width = 1280;
            height = 720;
        }
        self._desiredVideoProperties.width = width;
        self._desiredVideoProperties.height = height;
        if (frameRate !== undefined) {
            self._desiredVideoProperties.frameRate = frameRate;
        }
    };
    /** This function requests that screen capturing be used to provide the local media source
     * rather than a webcam. If you have multiple screens, they are composited side by side.
     * Note: this functionality is not supported by Firefox, has to be called before calling initMediaSource (or easyApp), we don't currently supply a way to 
     * turn it off (once it's on), only works if the website is hosted SSL (https), and the image quality is rather 
     * poor going across a network because it tries to transmit so much data. In short, screen sharing
     * through WebRTC isn't worth using at this point, but it is provided here so people can try it out.
     * @example
     *    easyrtc.setScreenCapture();
     * @deprecated: use easyrtc.initScreenCapture (same parameters as easyrtc.initMediaSource.
     */
    this.setScreenCapture = function(enableScreenCapture) {
        self._desiredVideoProperties.screenCapture = (enableScreenCapture !== false);
    };
    this.setScreenCaptureMode = function( mode ) {
        self._desiredVideoProperties.screenCaptureMode = mode;
    };
    /**
     * Builds the constraint object passed to getUserMedia.
     * @returns {Object} mediaConstraints
     */
    self.getUserMediaConstraints = function() {
        var constraints = {};
        //
        // _presetMediaConstraints allow you to provide your own contraints to be used
        // with initMediaSource.
        //
        if (self._presetMediaConstraints) {
            constraints = self._presetMediaConstraints;
            delete self._presetMediaConstraints;
            return constraints;
        }
        else if (self._desiredVideoProperties.screenCapture) {
            return {
                video: {
                    mozMediaSource: self._desiredVideoProperties.screenCaptureMode,
                    mediaSource: self._desiredVideoProperties.screenCaptureMode
                },
                audio: false
            };
        }
        else if (!videoEnabled) {
            constraints.video = false;
        }
        else {
            constraints.video = {mandatory: {}, optional: []};
            if (self._desiredVideoProperties.width) {
                constraints.video.mandatory.maxWidth = self._desiredVideoProperties.width;
                constraints.video.mandatory.minWidth = self._desiredVideoProperties.width;
            }
            if (self._desiredVideoProperties.width) {
                constraints.video.mandatory.maxHeight = self._desiredVideoProperties.height;
                constraints.video.mandatory.minHeight = self._desiredVideoProperties.height;
            }
            if (self._desiredVideoProperties.frameRate) {
                constraints.video.mandatory.maxFrameRate = self._desiredVideoProperties.frameRate;
            }
            if (self._desiredVideoProperties.videoSrcId) {
                constraints.video.optional.push({sourceId: self._desiredVideoProperties.videoSrcId});
            }
            // hack for opera
            if (constraints.video.mandatory.length === 0 && constraints.video.optional.length === 0) {
                constraints.video = true;
            }
        }
        constraints.audio = audioEnabled;
        return constraints;
    };
    /** Set the application name. Applications can only communicate with other applications
     * that share the same API Key and application name. There is no predefined set of application
     * names. Maximum length is
     * @param {String} name
     * @example
     *    easyrtc.setApplicationName('simpleAudioVideo');
     */
    this.setApplicationName = function(name) {
        self.applicationName = name;
    };
    /** Enable or disable logging to the console.
     * Note: if you want to control the printing of debug messages, override the
     *    easyrtc.debugPrinter variable with a function that takes a message string as it's argument.
     *    This is exactly what easyrtc.enableDebug does when it's enable argument is true.
     * @param {Boolean} enable - true to turn on debugging, false to turn off debugging. Default is false.
     * @example
     *    easyrtc.enableDebug(true);
     */
    this.enableDebug = function(enable) {
        if (enable) {
            self.debugPrinter = function(message) {
                var stackString = new Error().stack;
                var srcLine = "location unknown";
                if (stackString) {
                    var stackFrameStrings = stackString.split('\n');
                    srcLine = "";
                    if (stackFrameStrings.length >= 3) {
                        srcLine = stackFrameStrings[2];
                    }
                }
                console.log("debug " + (new Date()).toISOString() + " : " + message + " [" + srcLine + "]");
            };
        }
        else {
            self.debugPrinter = null;
        }
    };
//
// this is a temporary version used until we connect to the server.
//
    this.updatePresence = function(state, statusText) {
        self.presenceShow = state;
        self.presenceStatus = statusText;
    };
    /**
     * Determines if the local browser supports WebRTC GetUserMedia (access to camera and microphone).
     * @returns {Boolean} True getUserMedia is supported.
     */
    this.supportsGetUserMedia = function() {
        return !!nGetUserMedia;
    };
    /**
     * Determines if the local browser supports WebRTC Peer connections to the extent of being able to do video chats.
     * @returns {Boolean} True if Peer connections are supported.
     */
    this.supportsPeerConnections = function() {
        if (!self.supportsGetUserMedia()) {
            return false;
        }
        if (!wRTCPeerConnection) {
            return false;
        }
        try {
            self.createRTCPeerConnection({"iceServers": []}, null);
        } catch (oops) {
            return false;
        }
        return true;
    };
    /** @private
     * @param pc_config ice configuration array
     * @param optionalStuff peer constraints.
     */
    /** @private
     * @param pc_config ice configuration array
     * @param optionalStuff peer constraints.
     */
    this.createRTCPeerConnection = function(pc_config, optionalStuff) {
        if (wRTCPeerConnection) {
            prepareIceServers( pc_config );
            return new wRTCPeerConnection(pc_config, optionalStuff);
        }
        else {
            throw "Your browser doesn't support webRTC (RTCPeerConnection)";
        }
    };


    function prepareIceServers(pcConfig) {
        var newIceServers = [],
            i,
            server;
        if (pcConfig && pcConfig.iceServers) {
            for ( i = 0; i < pcConfig.iceServers.length; i++) {
                server = pcConfig.iceServers[i];
                if (!server.hasOwnProperty('urls') &&
                    server.hasOwnProperty('url')) {
                    server = JSON.parse(JSON.stringify(server));
                    server.urls = server.url;
                    delete server.url;
                    newIceServers.push(server);
                } else {
                    newIceServers.push(pcConfig.iceServers[i]);
                }
            }
            pcConfig.iceServers = newIceServers;
        }
    }
//
// this should really be part of adapter.js
// Versions of chrome < 31 don't support reliable data channels transport.
// Firefox does.
//
    this.getDatachannelConstraints = function() {
        if (webrtcDetectedBrowser === "chrome" && webrtcDetectedVersion < 31) {
            return {reliable: false};
        }
        else {
            return {reliable: true};
        }
    };
    /** @private */
    haveAudioVideo = {
        audio: false,
        video: false
    };
    /** @private */
    var dataEnabled = false;
    /** @private */
    var serverPath = null;
    /** @private */
    var roomOccupantListener = null;
    /** @private */
    var onDataChannelOpen = null;
    /** @private */
    var onDataChannelClose = null;
    /** @private */
    var lastLoggedInList = {};
    /** @private */
    var receivePeer = {msgTypes: {}};
    /** @private */
    var receiveServerCB = null;
    /** @private */
    var updateConfigurationInfo = function() {

    }; // dummy placeholder for when we aren't connected
//
//
//  peerConns is a map from caller names to the below object structure
//     {  startedAV: boolean,  -- true if we have traded audio/video streams
//        dataChannelS: RTPDataChannel for outgoing messages if present
//        dataChannelR: RTPDataChannel for incoming messages if present
//        dataChannelReady: true if the data channel can be used for sending yet
//        connectTime: timestamp when the connection was started
//        sharingAudio: true if audio is being shared
//        sharingVideo: true if video is being shared
//        cancelled: temporarily true if a connection was cancelled by the peer asking to initiate it
//        candidatesToSend: SDP candidates temporarily queued
//        streamsAddedAcks: ack callbacks waiting for stream received messages
//        pc: RTCPeerConnection
//        mediaStream: mediaStream
//     function callSuccessCB(string) - see the easyrtc.call documentation.
//        function callFailureCB(errorCode, string) - see the easyrtc.call documentation.
//        function wasAcceptedCB(boolean,string) - see the easyrtc.call documentation.
//     }
//
    /** @private */
    var peerConns = {};
//
// a map keeping track of whom we've requested a call with so we don't try to
// call them a second time before they've responded.
//
    /** @private */
    var acceptancePending = {};
    /**
     * Disconnect from the EasyRTC server.
     * @example
     *    easyrtc.disconnect();
     */
    this.disconnect = function() {
    };
    /** @private
     * @param caller
     * @param helper
     */
    this.acceptCheck = function(caller, helper) {
        helper(true);
    };
    /** @private
     * @param easyrtcid
     * @param stream
     */
    this.streamAcceptor = function(/*easyrtcid, stream*/) {
    };
    /** @private
     * @param easyrtcid
     */
    this.onStreamClosed = function(/*easyrtcid*/) {
    };
    /** @private
     * @param easyrtcid
     */
    this.callCancelled = function(/*easyrtcid*/) {
    };
    /**
     * This function gets the statistics for a particular peer connection.
     * @param {String} peerId
     * @param {Function} callback gets the peerid and a map of {userDefinedKey: value}. If there is no peer connection to peerId, then the map will
     *  have a value of {connected:false}. 
     * @param {Object} filter depends on whether Chrome or Firefox is used. See the default filters for guidance.
     * It is still experimental.
     */
    this.getPeerStatistics = function(peerId, callback, filter) {
        if (isFirefox) {
            self.getFirefoxPeerStatistics(peerId, callback, filter);
        }
        else {
            self.getChromePeerStatistics(peerId, callback, filter);
        }
    };
    this.getFirefoxPeerStatistics = function(peerId, callback, filter) {


        if (!peerConns[peerId]) {
            callback(peerId, {"connected": false});
        }
        else if (peerConns[peerId].pc.getStats) {
            peerConns[peerId].pc.getStats(null, function(stats) {
                var items = {};
                var candidates = {};
                var activeId = null;
                var srcKey;
                //
                // the stats objects has a group of entries. Each entry is either an rtcp, rtp entry
                // or a candidate entry. 
                //
                stats.forEach(function(entry) {
                    var majorKey;
                    var subKey;
                    if (entry.type.match(/boundrtp/)) {
                        if (entry.id.match(/audio/)) {
                            majorKey = entry.type + "_audio";
                        }
                        else if (entry.id.match(/video/)) {
                            majorKey = entry.type + "_video";
                        }
                        else {
                            return;
                        }
                        for (subKey in entry) {
                            if (entry.hasOwnProperty(subKey)) {
                                items[majorKey + "." + subKey] = entry[subKey];
                            }
                        }
                    }
                    else {
                        if( entry.hasOwnProperty("ipAddress") && entry.hasOwnProperty("id")) {
                            candidates[entry.id] = entry.ipAddress + ":" + 
                                  entry.portNumber;
                        }
                        else if( entry.hasOwnProperty("selected") && 
                                 entry.hasOwnProperty("remoteCandidateId") && 
                                 entry.selected ) {
                            activeId =  entry.remoteCandidateId;
                        } 
                    }
                });

                if( activeId ) {
                    items.irefoxRemoteAddress = candidates[activeId];
                }
                if (!filter) {
                    callback(peerId, items);
                }
                else {
                    var filteredItems = {};
                    for (srcKey in filter) {
                        if (filter.hasOwnProperty(srcKey) && items.hasOwnProperty(srcKey)) {
                            filteredItems[ filter[srcKey]] = items[srcKey];
                        }
                    }
                    callback(peerId, filteredItems);
                }
            },
                    function(error) {
                        console.log("unable to get statistics", error);
                    });
        }
        else {
            callback(peerId, {"statistics": self.getConstantString("statsNotSupported")});
        }
    };
    this.getChromePeerStatistics = function(peerId, callback, filter) {

        if (!peerConns[peerId]) {
            callback(peerId, {"connected": false});
        }
        else if (peerConns[peerId].pc.getStats) {

            peerConns[peerId].pc.getStats(function(stats) {

                var localStats = {};
                var part, parts = stats.result();
                var i, j;
                var itemKeys;
                var itemKey;
                var names;
                var userKey;
                var partNames = [];
                var partList;
                var bestBytes = 0;
                var bestI;
                var turnAddress = null;
                var hasActive, curReceived;
                var localAddress, remoteAddress;
                if (!filter) {
                    for (i = 0; i < parts.length; i++) {
                        names = parts[i].names();
                        localStats[parts[i].id] = {};
                        for (j = 0; j < names.length; j++) {
                            itemKey = names[j];
                            localStats[parts[i].id][itemKey] = parts[i].stat(itemKey);
                        }
                    }
                }
                else {
                    for (i = 0; i < parts.length; i++) {
                        partNames[i] = {};
                        //
                        // convert the names into a dictionary
                        //
                        names = parts[i].names();
                        for (j = 0; j < names.length; j++) {
                            partNames[i][names[j]] = true;
                        }

                        //
                        // a chrome-firefox connection results in several activeConnections. 
                        // we only want one, so we look for the one with the most data being received on it.
                        //
                        if (partNames[i].googRemoteAddress && partNames[i].googActiveConnection) {
                            hasActive = parts[i].local.stat("googActiveConnection");
                            if (hasActive === true || hasActive === "true") {
                                curReceived = parseInt(parts[i].stat("bytesReceived")) +
                                        parseInt(parts[i].stat("bytesSent"));
                                if (curReceived > bestBytes) {
                                    bestI = i;
                                    bestBytes = curReceived;
                                }
                            }
                        }
                    }

                    for (i = 0; i < parts.length; i++) {
                        //
                        // discard info from any inactive connection.
                        //
                        if (partNames[i].googActiveConnection) {
                            if (i !== bestI) {
                                partNames[i] = {};
                            }
                            else {
                                localAddress = parts[i].stat("googLocalAddress").split(":")[0];
                                remoteAddress = parts[i].stat("googRemoteAddress").split(":")[0];
                                if (self.isTurnServer(localAddress)) {
                                    turnAddress = localAddress;
                                }
                                else if (self.isTurnServer(remoteAddress)) {
                                    turnAddress = remoteAddress;
                                }
                            }
                        }
                    }

                    for (i = 0; i < filter.length; i++) {
                        itemKeys = filter[i];
                        partList = [];
                        part = null;
                        for (j = 0; j < parts.length; j++) {
                            var fullMatch = true;
                            for (itemKey in itemKeys) {
                                if (itemKeys.hasOwnProperty(itemKey) && !partNames[j][itemKey]) {
                                    fullMatch = false;
                                    break;
                                }
                            }
                            if (fullMatch && parts[j]) {
                                partList.push(parts[j]);
                            }
                        }
                        if (partList.length === 1) {
                            for (j = 0; j < partList.length; j++) {
                                part = partList[j];
                                if (part.local) {
                                    for (itemKey in itemKeys) {
                                        if (itemKeys.hasOwnProperty(itemKey)) {
                                            userKey = itemKeys[itemKey];
                                            localStats[userKey] = part.stat(itemKey);
                                        }
                                    }
                                }
                            }
                        }
                        else if (partList.length > 1) {
                            for (itemKey in itemKeys) {
                                if (itemKeys.hasOwnProperty(itemKey)) {
                                    localStats[itemKeys[itemKey]] = [];
                                }
                            }
                            for (j = 0; j < partList.length; j++) {
                                part = partList[j];
                                if (part.local) {
                                    for (itemKey in itemKeys) {
                                        if (itemKeys.hasOwnProperty(itemKey)) {
                                            userKey = itemKeys[itemKey];
                                            localStats[userKey].push(part.stat(itemKey));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (localStats.remoteAddress && turnAddress) {
                    localStats.remoteAddress = turnAddress;
                }
                callback(peerId, localStats);
            });
        }
        else {
            callback(peerId, {"statistics": self.getConstantString("statsNotSupported")});
        }
    };
    this.chromeStatsFilter = [
        {
            "googTransmitBitrate": "transmitBitRate",
            "googActualEncBitrate": "encodeRate",
            "googAvailableSendBandwidth": "availableSendRate"
        },
        {
            "googCodecName": "audioCodec",
            "googTypingNoiseState": "typingNoise",
            "packetsSent": "audioPacketsSent",
            "bytesSent": "audioBytesSent"
        },
        {
            "googCodecName": "videoCodec",
            "googFrameRateSent": "outFrameRate",
            "packetsSent": "videoPacketsSent",
            "bytesSent": "videoBytesSent"
        },
        {
            "packetsLost": "videoPacketsLost",
            "packetsReceived": "videoPacketsReceived",
            "bytesReceived": "videoBytesReceived",
            "googFrameRateOutput": "frameRateOut"
        },
        {
            "packetsLost": "audioPacketsLost",
            "packetsReceived": "audioPacketsReceived",
            "bytesReceived": "audioBytesReceived",
            "audioOutputLevel": "audioOutputLevel"
        },
        {
            "googRemoteAddress": "remoteAddress",
            "googActiveConnection": "activeConnection"
        },
        {
            "audioInputLevel": "audioInputLevel"
        }
    ];
    this.firefoxStatsFilter = {
        "outboundrtp_audio.bytesSent": "audioBytesSent",
        "outboundrtp_video.bytesSent": "videoBytesSent",
        "inboundrtp_video.bytesReceived": "videoBytesReceived",
        "inboundrtp_audio.bytesReceived": "audioBytesReceived",
        "outboundrtp_audio.packetsSent": "audioPacketsSent",
        "outboundrtp_video.packetsSent": "videoPacketsSent",
        "inboundrtp_video.packetsReceived": "videoPacketsReceived",
        "inboundrtp_audio.packetsReceived": "audioPacketsReceived",
        "inboundrtp_video.packetsLost": "videoPacketsLost",
        "inboundrtp_audio.packetsLost": "audioPacketsLost",
        "firefoxRemoteAddress": "remoteAddress"
    };
    this.standardStatsFilter = isFirefox ? self.firefoxStatsFilter : self.chromeStatsFilter;
    /** Provide a set of application defined fields that will be part of this instances
     * configuration information. This data will get sent to other peers via the websocket
     * path.
     * @param {String} roomName - the room the field is attached to.
     * @param {String} fieldName - the name of the field.
     * @param {Object} fieldValue - the value of the field.
     * @example
     *   easyrtc.setRoomApiField("trekkieRoom",  "favorite_alien", "Mr Spock");
     *   easyrtc.setRoomOccupantListener( function(roomName, list){
     *      for( var i in list ){
     *         console.log("easyrtcid=" + i + " favorite alien is " + list[i].apiFields.favorite_alien);
     *      }
     *   });
     */
    this.setRoomApiField = function(roomName, fieldName, fieldValue) {
        //
        // if we're not connected yet, we'll just cache the fields until we are.
        //
        if (!self._roomApiFields) {
            self._roomApiFields = {};
        }
        if (!fieldName && !fieldValue) {
            delete self._roomApiFields[roomName];
            return;
        }

        if (!self._roomApiFields[roomName]) {
            self._roomApiFields[roomName] = {};
        }
        if (fieldValue !== undefined && fieldValue !== null) {
            if (typeof fieldValue === "object") {
                try {
                    JSON.stringify(fieldValue);
                }
                catch (jsonError) {
                    self.showError(self.errCodes.DEVELOPER_ERR, "easyrtc.setRoomApiField passed bad object ");
                    return;
                }
            }
            self._roomApiFields[roomName][fieldName] = {fieldName: fieldName, fieldValue: fieldValue};
        }
        else {
            delete self._roomApiFields[roomName][fieldName];
        }
        if (self.webSocketConnected) {
            _enqueueSendRoomApi(roomName);
        }
    };
    var roomApiFieldTimer = null;
    /** @private
     * @param {String} roomName
     */
    function _enqueueSendRoomApi(roomName) {
//
// Rather than issue the send request immediately, we set a timer so we can accumulate other
// calls
//
        if (roomApiFieldTimer) {
            clearTimeout(roomApiFieldTimer);
        }
        roomApiFieldTimer = setTimeout(function() {
            _sendRoomApiFields(roomName, self._roomApiFields[roomName]);
            roomApiFieldTimer = null;
        }, 10);
    }
    /**
     *  @private
     *  @param roomName
     * @param fields
     */
    function _sendRoomApiFields(roomName, fields) {
        var fieldAsString = JSON.stringify(fields);
        JSON.parse(fieldAsString);
        var dataToShip = {
            msgType: "setRoomApiField",
            msgData: {
                setRoomApiField: {
                    roomName: roomName,
                    field: fields
                }
            }
        };
        self.webSocket.json.emit("easyrtcCmd", dataToShip,
                function(ackMsg) {
                    if (ackMsg.msgType === "error") {
                        self.showError(ackMsg.msgData.errorCode, ackMsg.msgData.errorText);
                    }
                }
        );
    }
    /** Default error reporting function. The default implementation displays error messages
     *  in a programmatically created div with the id easyrtcErrorDialog. The div has title
     *  component with a class name of easyrtcErrorDialog_title. The error messages get added to a
     *  container with the id easyrtcErrorDialog_body. Each error message is a text node inside a div
     *  with a class of easyrtcErrorDialog_element. There is an "okay" button with the className of easyrtcErrorDialog_okayButton.
     *  @param {String} messageCode An error message code
     *  @param {String} message the error message text without any markup.
     *  @example
     *      easyrtc.showError("BAD_NAME", "Invalid username");
     */
    this.showError = function(messageCode, message) {
        self.onError({errorCode: messageCode, errorText: message});
    };
    /** @private
     * @param errorObject
     */
    this.onError = function(errorObject) {
        if (self.debugPrinter) {
            self.debugPrinter("saw error " + errorObject.errorText);
        }
        var errorDiv = document.getElementById('easyrtcErrorDialog');
        var errorBody;
        if (!errorDiv) {
            errorDiv = document.createElement("div");
            errorDiv.id = 'easyrtcErrorDialog';
            var title = document.createElement("div");
            title.innerHTML = "Error messages";
            title.className = "easyrtcErrorDialog_title";
            errorDiv.appendChild(title);
            errorBody = document.createElement("div");
            errorBody.id = "easyrtcErrorDialog_body";
            errorDiv.appendChild(errorBody);
            var clearButton = document.createElement("button");
            clearButton.appendChild(document.createTextNode("Okay"));
            clearButton.className = "easyrtcErrorDialog_okayButton";
            clearButton.onclick = function() {
                errorBody.innerHTML = ""; // remove all inner nodes
                errorDiv.style.display = "none";
            };
            errorDiv.appendChild(clearButton);
            document.body.appendChild(errorDiv);
        }

        errorBody = document.getElementById("easyrtcErrorDialog_body");
        var messageNode = document.createElement("div");
        messageNode.className = 'easyrtcErrorDialog_element';
        messageNode.appendChild(document.createTextNode(errorObject.errorText));
        errorBody.appendChild(messageNode);
        errorDiv.style.display = "block";
    };
//
// easyrtc.createObjectURL builds a URL from a media stream.
// Arguments:
//     mediaStream - a media stream object.
// The video object in Chrome expects a URL.
//
    /** @private
     * @param mediaStream */
    this.createObjectURL = function(mediaStream) {
        var errMessage;
        if (window.URL && window.URL.createObjectURL) {
            return window.URL.createObjectURL(mediaStream);
        }
        else if (window.webkitURL && window.webkitURL.createObjectURL) {
            return window.webkit.createObjectURL(mediaStream);
        }
        else {
            errMessage = "Your browsers does not support URL.createObjectURL.";
            if (self.debugPrinter) {
                self.debugPrinter("saw exception " + errMessage);
            }
            throw errMessage;
        }
    };
    /**
     * A convenience function to ensure that a string doesn't have symbols that will be interpreted by HTML.
     * @param {String} idString
     * @return {String} The cleaned string.
     * @example
     *     console.log( easyrtc.cleanId('&hello'));
     */
    this.cleanId = function(idString) {
        var MAP = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;'
        };
        return idString.replace(/[&<>]/g, function(c) {
            return MAP[c];
        });
    };
    /** Set a callback that will be invoked when the application enters or leaves a room.
     *
     * @param {Function} handler - the first parameter is true for entering a room, false for leaving a room. The second parameter is the room name.
     * @example
     *   easyrtc.setRoomEntryListener(function(entry, roomName){
     *       if( entry ){
     *           console.log("entering room " + roomName);
     *       }
     *       else{
     *           console.log("leaving room " + roomName);
     *       }
     *   });
     */
    self.setRoomEntryListener = function(handler) {
        self.roomEntryListener = handler;
    };
    /** Set the callback that will be invoked when the list of people logged in changes.
     * The callback expects to receive a room name argument, and
     *  a map whose ideas are easyrtcids and whose values are in turn maps
     * supplying user specific information. The inner maps have the following keys:
     *  username, applicationName, browserFamily, browserMajor, osFamily, osMajor, deviceFamily.
     *  The third argument is the listener is the innerMap for the connections own data (not needed by most applications).
     * @param {Function} listener
     * @example
     *   easyrtc.setRoomOccupantListener( function(roomName, list, selfInfo){
     *      for( var i in list ){
     *         ("easyrtcid=" + i + " belongs to user " + list[i].username);
     *      }
     *   });
     */
    self.setRoomOccupantListener = function(listener) {
        roomOccupantListener = listener;
    };
    /**
     * Sets a callback that is called when a data channel is open and ready to send data.
     * The callback will be called with an easyrtcid as it's sole argument.
     * @param {Function} listener
     * @example
     *    easyrtc.setDataChannelOpenListener( function(easyrtcid){
     *         easyrtc.sendDataP2P(easyrtcid, "greeting", "hello");
     *    });
     */
    this.setDataChannelOpenListener = function(listener) {
        onDataChannelOpen = listener;
    };
    /** Sets a callback that is called when a previously open data channel closes.
     * The callback will be called with an easyrtcid as it's sole argument.
     * @param {Function} listener
     * @example
     *    easyrtc.setDataChannelCloseListener( function(easyrtcid){
     *            ("No longer connected to " + easyrtc.idToName(easyrtcid));
     *    });
     */
    this.setDataChannelCloseListener = function(listener) {
        onDataChannelClose = listener;
    };
    /** Returns the number of live peer connections the client has.
     * @return {Number}
     * @example
     *    ("You have " + easyrtc.getConnectionCount() + " peer connections");
     */
    this.getConnectionCount = function() {
        var count = 0;
        var i;
        for (i in peerConns) {
            if (peerConns.hasOwnProperty(i)) {
                if (self.getConnectStatus(i) === self.IS_CONNECTED) {
                    count++;
                }
            }
        }
        return count;
    };
    /** Sets whether audio is transmitted by the local user in any subsequent calls.
     * @param {Boolean} enabled true to include audio, false to exclude audio. The default is true.
     * @example
     *      easyrtc.enableAudio(false);
     */
    this.enableAudio = function(enabled) {
        audioEnabled = enabled;
    };
    /**
     *Sets whether video is transmitted by the local user in any subsequent calls.
     * @param {Boolean} enabled - true to include video, false to exclude video. The default is true.
     * @example
     *      easyrtc.enableVideo(false);
     */
    this.enableVideo = function(enabled) {
        videoEnabled = enabled;
    };
    /**
     * Sets whether WebRTC data channels are used to send inter-client messages.
     * This is only the messages that applications explicitly send to other applications, not the WebRTC signaling messages.
     * @param {Boolean} enabled  true to use data channels, false otherwise. The default is false.
     * @example
     *     easyrtc.enableDataChannels(true);
     */
    this.enableDataChannels = function(enabled) {
        dataEnabled = enabled;
    };
    /**
     * @private
     * @param {Boolean} enable
     * @param {Array} tracks - an array of MediaStreamTrack
     */
    function enableMediaTracks(enable, tracks) {
        var i;
        if (tracks) {
            for (i = 0; i < tracks.length; i++) {
                var track = tracks[i];
                track.enabled = enable;
            }
        }
    }


    //
    // fetches a stream by name. Treat a null/undefined streamName as "default".
    //
    function getLocalMediaStreamByName(streamName) {
        if (!streamName) {
            streamName = "default";
        }
        if (namedLocalMediaStreams.hasOwnProperty(streamName)) {
            return namedLocalMediaStreams[streamName];
        }
        else {
            return null;
        }
    }

    /**
     * Returns the user assigned id's of currently active local media streams.
     * @return {Array}
     */
    this.getLocalMediaIds = function() {
        return Object.keys(namedLocalMediaStreams);
    };

    function buildMediaIds() {
        var mediaMap = {};
        var streamName;
        for (streamName in namedLocalMediaStreams) {
            mediaMap[streamName] = namedLocalMediaStreams[streamName].id || "default";
        }
        return mediaMap;
    }


    function registerLocalMediaStreamByName(stream, streamName) {
        var roomName;
        if (!streamName) {
            streamName = "default";
        }
        stream.streamName = streamName;
        namedLocalMediaStreams[streamName] = stream;
        if (streamName !== "default") {
            var mediaIds = buildMediaIds();
            for (roomName in self.roomData) {
                self.setRoomApiField(roomName, "mediaIds", mediaIds);
            }
        }
    }

    /**
      * Allow an externally created mediastream (ie, created by another 
      * library) to be used within easyrtc. Tracking when it closes
      * must be done by the supplying party.
      */
    this.register3rdPartyLocalMediaStream = function(stream, streamName) {
       return registerLocalMediaStreamByName(stream, streamName);
    };
    //
    // look up a stream's name from the stream.id
    //
    function getNameOfRemoteStream(easyrtcId, webrtcstreamId) {
        var roomName;
        var mediaIds;
        var streamName;
        if (!webrtcstreamId) {
            webrtcstreamId = "default";
        }
        if (peerConns[easyrtcId]) {
            streamName = peerConns[easyrtcId].remoteStreamIdToName[webrtcstreamId];
            if (streamName) {
                return streamName;
            }
        }

        for (roomName in self.roomData) {
            mediaIds = self.getRoomApiField(roomName, easyrtcId, "mediaIds");
            if (!mediaIds) {
                continue;
            }
            for (streamName in mediaIds) {
                if (mediaIds.hasOwnProperty(streamName) &&
                        mediaIds[streamName] === webrtcstreamId) {
                    return streamName;
                }
            }
            //
            // a stream from chrome to firefox will be missing it's id/label.
            // there is no correct solution. 
            //
            if( isFirefox ) {
               // if there is a stream called default, return it in preference
               if( mediaIds["default"] ) {
                   return "default"; 
               }
               //
               // otherwise return the first name we find. If there is more than
               // one, complain to Mozilla.
               //
               for( var anyName in mediaIds ) {
                   return anyName;
               }
            }
        }
        return undefined;
    }

    this.getNameOfRemoteStream = function(easyrtcId, webrtcStream){
        if(typeof webrtcStream == "string") {
            return getNameOfRemoteStream(easyrtcId, webrtcStream);
        }
        else if( webrtcStream.id) {
            return getNameOfRemoteStream(easyrtcId, webrtcStream.id);
        }
    };

    function closeLocalMediaStreamByName(streamName) {
        if (!streamName) {
            streamName = "default";
        }
        var stream = self.getLocalStream(streamName);
        if (!stream) {
            return;
        }
        var streamId = stream.id || "default";
        if (namedLocalMediaStreams[streamName]) {


            for (var id in peerConns) {
                if (peerConns.hasOwnProperty(id)) {
                    try {
                        peerConns[id].pc.removeStream(stream);
                    } catch (err) {
                    }
                    self.sendPeerMessage(id, "__closingMediaStream", {streamId: streamId, streamName: streamName});
                }
            }
            try {
                namedLocalMediaStreams[streamName].stop();
            } catch (err) {
                // not worth reporting an error at this location
                // since we didn't want the media stream anyhow.
            }
            delete namedLocalMediaStreams[streamName];
            if (streamName !== "default") {
                var mediaIds = buildMediaIds();
                for (var roomName in self.roomData) {
                    self.setRoomApiField(roomName, "mediaIds", mediaIds);
                }
            }
        }
    }
    /**
     * Close the local media stream. You usually need to close the existing media stream
     * of a camera before reacquring it at a different resolution.
     * @param {String} streamName - an option stream name.
     */
    this.closeLocalMediaStream = function(streamName) {
        return closeLocalMediaStreamByName(streamName);
    };

    /**
     * Alias for closeLocalMediaStream
     */
    this.closeLocalStream = this.closeLocalMediaStream;
    /**
     * This function is used to enable and disable the local camera. If you disable the
     * camera, video objects display it will "freeze" until the camera is re-enabled. *
     * By default, a camera is enabled.
     * @param {Boolean} enable - true to enable the camera, false to disable it.
     * @param {String} streamName - the name of the stream, optional.
     */
    this.enableCamera = function(enable, streamName) {
        var stream = getLocalMediaStreamByName(streamName);
        if (stream && stream.getVideoTracks) {
            enableMediaTracks(enable, stream.getVideoTracks());
        }
    };
    /**
     * This function is used to enable and disable the local microphone. If you disable
     * the microphone, sounds stops being transmitted to your peers. By default, the microphone
     * is enabled.
     * @param {Boolean} enable - true to enable the microphone, false to disable it.
     * @param {String} streamName - an optional streamName
     */
    this.enableMicrophone = function(enable, streamName) {
        var stream = getLocalMediaStreamByName(streamName);
        if (stream && stream.getAudioTracks) {
            enableMediaTracks(enable, stream.getAudioTracks());
        }
    };
    /**
     * Mute a video object.
     * @param {String} videoObjectName - A DOMObject or the id of the DOMObject.
     * @param {Boolean} mute - true to mute the video object, false to unmute it.
     */
    self.muteVideoObject = function(videoObjectName, mute) {
        var videoObject;
        if (typeof (videoObjectName) === 'string') {
            videoObject = document.getElementById(videoObjectName);
            if (!videoObject) {
                throw "Unknown video object " + videoObjectName;
            }
        }
        else if (!videoObjectName) {
            throw "muteVideoObject passed a null";
        }
        else {
            videoObject = videoObjectName;
        }
        videoObject.muted = !!mute;
    };
    /**
     * Returns a URL for your local camera and microphone.
     *  It can be called only after easyrtc.initMediaSource has succeeded.
     *  It returns a url that can be used as a source by the Chrome video element or the &lt;canvas&gt; element.
     *  @param {String} streamName - an option stream name.
     *  @return {URL}
     *  @example
     *      document.getElementById("myVideo").src = easyrtc.getLocalStreamAsUrl();
     */
    self.getLocalStreamAsUrl = function(streamName) {
        var stream = getLocalMediaStreamByName(streamName);
        if (stream === null) {
            throw "Developer error: attempt to get a MediaStream without invoking easyrtc.initMediaSource successfully";
        }
        return self.createObjectURL(stream);
    };
    /**
     * Returns a media stream for your local camera and microphone.
     *  It can be called only after easyrtc.initMediaSource has succeeded.
     *  It returns a stream that can be used as an argument to easyrtc.setVideoObjectSrc.
     *  Returns null if there is no local media stream acquired yet.
     * @return {MediaStream}
     * @example
     *    easyrtc.setVideoObjectSrc( document.getElementById("myVideo"), easyrtc.getLocalStream());
     */
    this.getLocalStream = function(streamName) {
        return getLocalMediaStreamByName(streamName) || null;
    };
    /** Clears the media stream on a video object.
     *
     * @param {Object} element the video object.
     * @example
     *    easyrtc.clearMediaStream( document.getElementById('selfVideo'));
     *
     */
    this.clearMediaStream = function(element) {
        if (typeof element.srcObject !== 'undefined') {
            element.srcObject = null;
        } else if (typeof element.mozSrcObject !== 'undefined') {
            element.mozSrcObject = null;
        } else if (typeof element.src !== 'undefined') {
            //noinspection JSUndefinedPropertyAssignment
            element.src = "";
        }
    };
    /**
     *  Sets a video or audio object from a media stream.
     *  Chrome uses the src attribute and expects a URL, while firefox
     *  uses the mozSrcObject and expects a stream. This procedure hides
     *  that from you.
     *  If the media stream is from a local webcam, you may want to add the
     *  easyrtcMirror class to the video object so it looks like a proper mirror.
     *  The easyrtcMirror class is defined in this.css.
     *  Which is could be added using the same path of easyrtc.js file to an HTML file
     *  @param {Object} videoObject an HTML5 video object
     *  @param {MediaStream|String} stream a media stream as returned by easyrtc.getLocalStream or your stream acceptor.
     * @example
     *    easyrtc.setVideoObjectSrc( document.getElementById("myVideo"), easyrtc.getLocalStream());
     *
     */
    this.setVideoObjectSrc = function(videoObject, stream) {
        if (stream && stream !== "") {
            videoObject.autoplay = true;
            attachMediaStream(videoObject, stream);
            videoObject.play();
        }
        else {
            self.clearMediaStream(videoObject);
        }
    };


    /**
     * This function builds a new named local media stream from a set of existing audio and video tracks from other media streams.
     * @param {String} streamName is the name of the new media stream.
     * @param {Array} audioTracks is an array of MediaStreamTracks
     * @param {Array} videoTracks is an array of MediaStreamTracks
     * @returns {MediaStream} the track created.
     * @example
     *    easyrtc.buildLocalMediaStream("myComposedStream",
     *             easyrtc.getLocalStream("camera1").getVideoTracks(),
     *             easyrtc.getLocalStream("camera2").getAudioTracks());
     */
    this.buildLocalMediaStream = function(streamName, audioTracks, videoTracks) {
        var i;
        if (typeof streamName !== 'string') {
            easyrtc.showError(this.errCodes.DEVELOPER_ERR, 
               "easyrtc.buildLocalMediaStream not supplied a stream name");
            return null;
        }

         var streamToClone = null;
         for(var key in namedLocalMediaStreams ) {
            if( namedLocalMediaStreams.hasOwnProperty(key)) {
              streamToClone = namedLocalMediaStreams[key];
              if(streamToClone) {
                  break;
              }
            }
         }
         if( !streamToClone ) {
            for(key in peerConns) {
                var remoteStreams = peerConns[key].pc.getRemoteStreams();
                if( remoteStreams && remoteStreams.length > 1 ) {
                    streamToClone = remoteStreams[0];
                }
            }
         }
         if( !streamToClone ){
            self.showError(self.errCodes.DEVELOPER_ERR, 
             "Attempt to create a mediastream without one to clone from");
            return null;
         }

         //
         // clone whatever mediastream we found, and remove any of it's 
         // tracks.
         //
         var mediaClone = streamToClone.clone();
         var oldTracks = mediaClone.getTracks();

        if (audioTracks) {
            for (i = 0; i < audioTracks.length; i++) {
                mediaClone.addTrack(audioTracks[i].clone());
            }
        }

        if (videoTracks) {
            for (i = 0; i < videoTracks.length; i++) {
                mediaClone.addTrack(videoTracks[i].clone());
            }
        }

        for( i = 0; i < oldTracks.length; i++ ) {
            mediaClone.removeTrack(oldTracks[i]);
        }

        registerLocalMediaStreamByName(mediaClone, streamName);
        return mediaClone;
    };

    /* @private*/
    /** Load Easyrtc Stylesheet.
     *   Easyrtc Stylesheet define easyrtcMirror class and some basic css class for using easyrtc.js.
     *   That way, developers can override it or use it's own css file minified css or package.
     * @example
     *       easyrtc.loadStylesheet();
     *
     */
    this.loadStylesheet = function() {

        //
        // check to see if we already have an easyrtc.css file loaded
        // if we do, we can exit immediately.
        //
        var links = document.getElementsByTagName("link");
        var cssIndex, css;
        for (cssIndex in links) {
            if (links.hasOwnProperty(cssIndex)) {
                css = links[cssIndex];
                if (css.href && (css.href.match(/\/easyrtc.css/))) {
                    return;
                }
            }
        }
        //
        // add the easyrtc.css file since it isn't present
        //
        var easySheet = document.createElement("link");
        easySheet.setAttribute("rel", "stylesheet");
        easySheet.setAttribute("type", "text/css");
        easySheet.setAttribute("href", "/easyrtc/easyrtc.css");
        var headSection = document.getElementsByTagName("head")[0];
        var firstHead = headSection.childNodes[0];
        headSection.insertBefore(easySheet, firstHead);
    };
    /** @private
     * @param {String} x */
    this.formatError = function(x) {
        var name, result;
        if (x === null || typeof x === 'undefined') {
            return "null";
        }
        if (typeof x === 'string') {
            return x;
        }
        else if (x.type && x.description) {
            return x.type + " : " + x.description;
        }
        else if (typeof x === 'object') {
            try {
                return JSON.stringify(x);
            }
            catch (oops) {
                result = "{";
                for (name in x) {
                    if (x.hasOwnProperty(name)) {
                        if (typeof x[name] === 'string') {
                            result = result + name + "='" + x[name] + "' ";
                        }
                    }
                }
                result = result + "}";
                return result;
            }
        }
        else {
            return "Strange case";
        }
    };
    /** Initializes your access to a local camera and microphone.
     *  Failure could be caused a browser that didn't support WebRTC, or by the user
     * not granting permission.
     * If you are going to call easyrtc.enableAudio or easyrtc.enableVideo, you need to do it before
     * calling easyrtc.initMediaSource.
     * @param {function(Object)} successCallback - will be called with localmedia stream on success. 
     * @param {function(String,String)} errorCallback - is called with an error code and error description.
     * @param {String} streamName - an optional name for the media source so you can use multiple cameras and screen share simultaneously.
     * @example
     *       easyrtc.initMediaSource(
     *          function(mediastream){
     *              easyrtc.setVideoObjectSrc( document.getElementById("mirrorVideo"), mediastream);
     *          },
     *          function(errorCode, errorText){
     *               easyrtc.showError(errorCode, errorText);
     *          });
     *
     */
    this.initMediaSource = function(successCallback, errorCallback, streamName) {

        if (self.debugPrinter) {
            self.debugPrinter("about to request local media");
        }

        if (!streamName) {
            streamName = "default";
        }

        haveAudioVideo = {
            audio: audioEnabled,
            video: videoEnabled
        };
        if (!errorCallback) {
            errorCallback = function(errorCode, errorText) {
                var message = "easyrtc.initMediaSource: " + self.formatError(errorText);
                if (self.debugPrinter) {
                    self.debugPrinter(message);
                }
                self.showError(self.errCodes.MEDIA_ERR, message);
            };
        }

        if (!self.supportsGetUserMedia()) {
            errorCallback(self.errCodes.MEDIA_ERR, self.getConstantString("noWebrtcSupport"));
            return;
        }


        if (!successCallback) {
            self.showError(self.errCodes.DEVELOPER_ERR,
                    "easyrtc.initMediaSource not supplied a successCallback");
            return;
        }


        var mode = self.getUserMediaConstraints();
        /** @private
         * @param {Object} stream - A mediaStream object.
         *  */
        var onUserMediaSuccess = function(stream) {
            if (self.debugPrinter) {
                self.debugPrinter("getUserMedia success callback entered");
            }

            if (self.debugPrinter) {
                self.debugPrinter("successfully got local media");
            }

            stream.streamName = streamName;
            registerLocalMediaStreamByName(stream, streamName);
            var videoObj, triesLeft, tryToGetSize, ele;
            if (haveAudioVideo.video) {
                videoObj = document.createElement('video');
                videoObj.muted = true;
                triesLeft = 30;
                tryToGetSize = function() {
                    if (videoObj.videoWidth > 0 || triesLeft < 0) {
                        self.nativeVideoWidth = videoObj.videoWidth;
                        self.nativeVideoHeight = videoObj.videoHeight;
                        if (self._desiredVideoProperties.height &&
                                (self.nativeVideoHeight !== self._desiredVideoProperties.height ||
                                        self.nativeVideoWidth !== self._desiredVideoProperties.width)) {
                            self.showError(self.errCodes.MEDIA_WARNING,
                                    self.format(self.getConstantString("resolutionWarning"),
                                    self._desiredVideoProperties.width, self._desiredVideoProperties.height,
                                    self.nativeVideoWidth, self.nativeVideoHeight));
                        }
                        self.setVideoObjectSrc(videoObj, "");
                        if (videoObj.removeNode) {
                            videoObj.removeNode(true);
                        }
                        else {
                            ele = document.createElement('div');
                            ele.appendChild(videoObj);
                            ele.removeChild(videoObj);
                        }

                        updateConfigurationInfo();
                        if (successCallback) {
                            successCallback(stream);
                        }
                    }
                    else {
                        triesLeft -= 1;
                        setTimeout(tryToGetSize, 300);
                    }
                };
                self.setVideoObjectSrc(videoObj, stream);
                tryToGetSize();
            }
            else {
                updateConfigurationInfo();
                if (successCallback) {
                    successCallback(stream);
                }
            }
        };
        /** @private
         * @param {String} error
         */
        var onUserMediaError = function(error) {
            console.log("getusermedia failed");
            if (self.debugPrinter) {
                self.debugPrinter("failed to get local media");
            }
            var errText;
            if (typeof error === 'string') {
                errText = error;
            }
            else if (error.name) {
                errText = error.name;
            }
            else {
                errText = "Unknown";
            }
            if (errorCallback) {
                console.log("invoking error callback", errText);
                errorCallback(self.errCodes.MEDIA_ERR, self.format(self.getConstantString("gumFailed"), errText));
            }
            closeLocalMediaStreamByName(streamName);
            haveAudioVideo = {
                audio: false,
                video: false
            };
            updateConfigurationInfo();
        };
        if (!audioEnabled && !videoEnabled) {
            onUserMediaError(self.getConstantString("requireAudioOrVideo"));
            return;
        }

        function getCurrentTime() {
            return (new Date()).getTime();
        }

        var firstCallTime;
        function tryAgain(error) {
            var currentTime = getCurrentTime();
            if (currentTime < firstCallTime + 1000) {
                console.log("Trying getUserMedia a second time");
                setTimeout(function() {
                    nGetUserMedia(mode, onUserMediaSuccess, onUserMediaError);
                }, 3000);
            }
            else {
                onUserMediaError(error);
            }
        }

        if (videoEnabled || audioEnabled) {
            //
            // getUserMedia sometimes fails the first time I call it. I suspect it's a page loading
            // issue. So I'm going to try adding a 3 second delay to allow things to settle down first.
            // In addition, I'm going to try again after 3 seconds.
            //


            setTimeout(function() {
                try {
                    firstCallTime = getCurrentTime();
                    nGetUserMedia(mode, onUserMediaSuccess, tryAgain);
                } catch (e) {
                    tryAgain(e);
                }
            }, 1000);
        }
        else {
            onUserMediaSuccess(null);
        }
    };
    /**
     * Sets the callback used to decide whether to accept or reject an incoming call.
     * @param {Function} acceptCheck takes the arguments (callerEasyrtcid, acceptor).     
     * The acceptCheck callback is passed an easyrtcid and an aceptor function. The acceptor function should be called with either
     * a true value (accept the call) or false value( reject the call) as it's first argument, and optionally,
     * an array of local media streamNames as a second argument.
     * @example
     *      easyrtc.setAcceptChecker( function(easyrtcid, acceptor){
     *           if( easyrtc.idToName(easyrtcid) === 'Fred' ){
     *              acceptor(true);
     *           }
     *           else if( easyrtc.idToName(easyrtcid) === 'Barney' ){
     *              setTimeout( function(){ 
     acceptor(true, ['myOtherCam']); // myOtherCam presumed to a streamName
     }, 10000);
     *           }
     *           else{
     *              acceptor(false);
     *           }
     *      });
     */
    this.setAcceptChecker = function(acceptCheck) {
        self.acceptCheck = acceptCheck;
    };
    /**
     * easyrtc.setStreamAcceptor sets a callback to receive media streams from other peers, independent
     * of where the call was initiated (caller or callee).
     * @param {Function} acceptor takes arguments (caller, mediaStream, mediaStreamName)
     * @example
     *  easyrtc.setStreamAcceptor(function(easyrtcid, stream, streamName){
     *     document.getElementById('callerName').innerHTML = easyrtc.idToName(easyrtcid);
     *     easyrtc.setVideoObjectSrc( document.getElementById("callerVideo"), stream);
     *  });
     */
    this.setStreamAcceptor = function(acceptor) {
        self.streamAcceptor = acceptor;
    };
    /** Sets the easyrtc.onError field to a user specified function.
     * @param {Function} errListener takes an object of the form {errorCode: String, errorText: String}
     * @example
     *    easyrtc.setOnError( function(errorObject){
     *        document.getElementById("errMessageDiv").innerHTML += errorObject.errorText;
     *    });
     */
    self.setOnError = function(errListener) {
        self.onError = errListener;
    };
    /**
     * Sets the callCancelled callback. This will be called when a remote user
     * initiates a call to you, but does a "hangup" before you have a chance to get his video stream.
     * @param {Function} callCancelled takes an easyrtcid as an argument and a boolean that indicates whether
     *  the call was explicitly cancelled remotely (true), or actually accepted by the user attempting a call to
     *  the same party.
     * @example
     *     easyrtc.setCallCancelled( function(easyrtcid, explicitlyCancelled){
     *        if( explicitlyCancelled ){
     *            console.log(easyrtc.idToName(easyrtcid) + " stopped trying to reach you");
     *         }
     *         else{
     *            console.log("Implicitly called "  + easyrtc.idToName(easyrtcid));
     *         }
     *     });
     */
    this.setCallCancelled = function(callCancelled) {
        self.callCancelled = callCancelled;
    };
    /**  Sets a callback to receive notification of a media stream closing. The usual
     *  use of this is to clear the source of your video object so you aren't left with
     *  the last frame of the video displayed on it.
     *  @param {Function} onStreamClosed takes an easyrtcid as it's first parameter, the stream as it's second argument, and name of the video stream as it's third.
     *  @example
     *     easyrtc.setOnStreamClosed( function(easyrtcid, stream, streamName){
     *         easyrtc.setVideoObjectSrc( document.getElementById("callerVideo"), "");
     *         ( easyrtc.idToName(easyrtcid) + " closed stream " + stream.id + " " + streamName);
     *     });
     */
    this.setOnStreamClosed = function(onStreamClosed) {
        self.onStreamClosed = onStreamClosed;
    };
    /** @deprecated No longer supported by Google.
     * Sets the bandwidth for sending video data.
     * Setting the rate too low will cause connection attempts to fail. 40 is probably good lower limit.
     * The default is 50. A value of zero will remove bandwidth limits.
     * @param {Number} kbitsPerSecond is rate in kilobits per second.
     * @example
     *    easyrtc.setVideoBandwidth( 40);
     */
    this.setVideoBandwidth = function(/*kbitsPerSecond*/) {
        self.showError("easyrtc.setVideoBandwidth is deprecated, it no longer has an effect.");
    };
    /** Determines whether the current browser supports the new data channels.
     * EasyRTC will not open up connections with the old data channels.
     * @returns {Boolean}
     */
    this.supportsDataChannels = function() {
        if (navigator.userAgent.match(/android/i)) {
            return webrtcDetectedVersion >= 34;
        }
        else {
            return (webrtcDetectedBrowser === "firefox" || webrtcDetectedVersion >= 32);
        }
    };
    /**
     * Sets a listener for data sent from another client (either peer to peer or via websockets).
     * If no msgType or source is provided, the listener applies to all events that aren't otherwise handled.
     * If a msgType but no source is provided, the listener applies to all messages of that msgType that aren't otherwise handled.
     * If a msgType and a source is provided, the listener applies to only message of the specified type coming from the specified peer.
     * The most specific case takes priority over the more general.
     * @param {Function} listener has the signature (easyrtcid, msgType, msgData, targeting).
     *   msgType is a string. targeting is null if the message was received using WebRTC data channels, otherwise it
     *   is an object that contains one or more of the following string valued elements {targetEasyrtcid, targetGroup, targetRoom}.
     * @param {String} msgType - a string, optional.
     * @param {String} source - the sender's easyrtcid, optional.
     * @example
     *     easyrtc.setPeerListener( function(easyrtcid, msgType, msgData, targeting){
     *         console.log("From " + easyrtc.idToName(easyrtcid) +
     *             " sent the following data " + JSON.stringify(msgData));
     *     });
     *     easyrtc.setPeerListener( function(easyrtcid, msgType, msgData, targeting){
     *         console.log("From " + easyrtc.idToName(easyrtcid) +
     *             " sent the following data " + JSON.stringify(msgData));
     *     }, 'food', 'dkdjdekj44--');
     *     easyrtc.setPeerListener( function(easyrtcid, msgType, msgData, targeting){
     *         console.log("From " + easyrtcid +
     *             " sent the following data " + JSON.stringify(msgData));
     *     }, 'drink');
     *
     *
     */
    this.setPeerListener = function(listener, msgType, source) {
        if (!msgType) {
            receivePeer.cb = listener;
        }
        else {
            if (!receivePeer.msgTypes[msgType]) {
                receivePeer.msgTypes[msgType] = {sources: {}};
            }
            if (!source) {
                receivePeer.msgTypes[msgType].cb = listener;
            }
            else {
                receivePeer.msgTypes[msgType].sources[source] = {cb: listener};
            }
        }
    };
    /* This function serves to distribute peer messages to the various peer listeners */
    /** @private
     * @param {String} easyrtcid
     * @param {Object} msg - needs to contain a msgType and a msgData field.
     * @param {Object} targeting
     */
    this.receivePeerDistribute = function(easyrtcid, msg, targeting) {
        var msgType = msg.msgType;
        var msgData = msg.msgData;
        if (!msgType) {
            console.log("received peer message without msgType", msg);
            return;
        }

        if (receivePeer.msgTypes[msgType]) {
            if (receivePeer.msgTypes[msgType].sources[easyrtcid] &&
                    receivePeer.msgTypes[msgType].sources[easyrtcid].cb) {
                receivePeer.msgTypes[msgType].sources[easyrtcid].cb(easyrtcid, msgType, msgData, targeting);
                return;
            }
            if (receivePeer.msgTypes[msgType].cb) {
                receivePeer.msgTypes[msgType].cb(easyrtcid, msgType, msgData, targeting);
                return;
            }
        }
        if (receivePeer.cb) {
            receivePeer.cb(easyrtcid, msgType, msgData, targeting);
        }
    };
    /**
     * Sets a listener for messages from the server.
     * @param {Function} listener has the signature (msgType, msgData, targeting)
     * @example
     *     easyrtc.setServerListener( function(msgType, msgData, targeting){
     *         ("The Server sent the following message " + JSON.stringify(msgData));
     *     });
     */
    this.setServerListener = function(listener) {
        receiveServerCB = listener;
    };
    /**
     * Sets the url of the Socket server.
     * The node.js server is great as a socket server, but it doesn't have
     * all the hooks you'd like in a general web server, like PHP or Python
     * plug-ins. By setting the serverPath your application can get it's regular
     * pages from a regular web server, but the EasyRTC library can still reach the
     * socket server.
     * @param {String} socketUrl
     * @param {Object} options an optional dictionary of options for socket.io's connect method. 
     * The default is {'connect timeout': 10000,'force new connection': true }
     * @example
     *     easyrtc.setSocketUrl(":8080", options);
     */
    this.setSocketUrl = function(socketUrl, options) {
        if (self.debugPrinter) {
            self.debugPrinter("WebRTC signaling server URL set to " + socketUrl);
        }
        serverPath = socketUrl;
        if( options ) {
            connectionOptions = options;
        }
    };
    /**
     * Sets the user name associated with the connection.
     * @param {String} username must obey standard identifier conventions.
     * @returns {Boolean} true if the call succeeded, false if the username was invalid.
     * @example
     *    if( !easyrtc.setUsername("JohnSmith") ){
     *        console.error("bad user name);
     *
     */
    this.setUsername = function(username) {
        if( self.myEasyrtcid ) {
            easyrtc.showError(easyrtc.errCodes.DEVELOPER_ERR, "easyrtc.setUsername called after authentication");
            return false;
        }
        else if (self.isNameValid(username)) {
            self.username = username;
            return true;
        }
        else {
            self.showError(self.errCodes.BAD_NAME, self.format(self.getConstantString("badUserName"), username));
            return false;
        }
    };
    /**
     * Get an array of easyrtcids that are using a particular username
     * @param {String} username - the username of interest.
     * @param {String} room - an optional room name argument limiting results to a particular room.
     * @returns {Array} an array of {easyrtcid:id, roomName: roomName}.
     */
    this.usernameToIds = function(username, room) {
        var results = [];
        var id, roomName;
        for (roomName in lastLoggedInList) {
            if (!lastLoggedInList.hasOwnProperty(roomName)) {
                continue;
            }
            if (room && roomName !== room) {
                continue;
            }
            for (id in lastLoggedInList[roomName]) {
                if (!lastLoggedInList[roomName].hasOwnProperty(id)) {
                    continue;
                }
                if (lastLoggedInList[roomName][id].username === username) {
                    results.push({
                        easyrtcid: id,
                        roomName: roomName
                    });
                }
            }
        }
        return results;
    };
    /**
     * Returns another peers API field, if it exists.
     * @param {type} roomName
     * @param {type} easyrtcid
     * @param {type} fieldName
     * @returns {Object}  Undefined if the attribute does not exist, its value otherwise.
     */
    this.getRoomApiField = function(roomName, easyrtcid, fieldName) {
        if (lastLoggedInList[roomName] &&
                lastLoggedInList[roomName][easyrtcid] &&
                lastLoggedInList[roomName][easyrtcid].apiField &&
                lastLoggedInList[roomName][easyrtcid].apiField[fieldName]) {
            return lastLoggedInList[roomName][easyrtcid].apiField[fieldName].fieldValue;
        }
        else {
            return undefined;
        }
    };
    /**
     * Set the authentication credential if needed.
     * @param {Object} credentialParm - a JSONable object.
     */
    this.setCredential = function(credentialParm) {
        try {
            JSON.stringify(credentialParm);
            credential = credentialParm;
            return true;
        }
        catch (oops) {
            self.showError(self.errCodes.BAD_CREDENTIAL, "easyrtc.setCredential passed a non-JSON-able object");
            throw "easyrtc.setCredential passed a non-JSON-able object";
        }
    };
    /**
     * Sets the listener for socket disconnection by external (to the API) reasons.
     * @param {Function} disconnectListener takes no arguments and is not called as a result of calling easyrtc.disconnect.
     * @example
     *    easyrtc.setDisconnectListener(function(){
     *        easyrtc.showError("SYSTEM-ERROR", "Lost our connection to the socket server");
     *    });
     */
    this.setDisconnectListener = function(disconnectListener) {
        self.disconnectListener = disconnectListener;
    };
    /**
     * Convert an easyrtcid to a user name. This is useful for labeling buttons and messages
     * regarding peers.
     * @param {String} easyrtcid
     * @return {String} the username associated with the easyrtcid, or the easyrtcid if there is
     * no associated username.
     * @example
     *    console.log(easyrtcid + " is actually " + easyrtc.idToName(easyrtcid));
     */
    this.idToName = function(easyrtcid) {
        var roomName;
        for (roomName in lastLoggedInList) {
            if (!lastLoggedInList.hasOwnProperty(roomName)) {
                continue;
            }
            if (lastLoggedInList[roomName][easyrtcid]) {
                if (lastLoggedInList[roomName][easyrtcid].username) {
                    return lastLoggedInList[roomName][easyrtcid].username;
                }
            }
        }
        return easyrtcid;
    };
    /* used in easyrtc.connect */
    /** @private */
    this.webSocket = null;
    var pc_config = {};
    var pc_config_to_use = null;
    var use_fresh_ice_each_peer = false;
    /**
     * Determines whether fresh ice server configuration should be requested from the server for each peer connection.
     * @param {Boolean} value the default is false.
     */
    this.setUseFreshIceEachPeerConnection = function(value) {
        use_fresh_ice_each_peer = value;
    };
    /**
     * Returns the last ice config supplied by the EasyRTC server. This function is not normally used, it is provided
     * for people who want to try filtering ice server configuration on the client.
     * @return {Object} which has the form {iceServers:[ice_server_entry, ice_server_entry, ...]}
     */
    this.getServerIce = function() {
        return pc_config;
    };
    /**
     * Sets the ice server configuration that will be used in subsequent calls. You only need this function if you are filtering
     * the ice server configuration on the client or if you are using TURN certificates that have a very short lifespan.
     * @param {Object} ice An object with iceServers element containing an array of ice server entries.
     * @example
     *     easyrtc.setIceUsedInCalls( {"iceServers": [
     *      {
     *			"url": "stun:stun.sipgate.net"
     *		},
     *      {
     *         "url": "stun:217.10.68.152"
     *      },
     *      {
     *         "url": "stun:stun.sipgate.net:10000"
     *      }
     *      ]});
     *      easyrtc.call(...);
     */
    this.setIceUsedInCalls = function(ice) {
        if (!ice.iceServers) {
            easyrtc.showError(easyrtc.errCodes.DEVELOPER_ERR, "Bad ice configuration passed to easyrtc.setIceUsedInCalls");
        }
        else {
            pc_config_to_use = ice;
        }
    };
    var closedChannel = null;
    /** @private
     * @param easyrtcid
     * @param checkAudio
     */
    function _haveTracks(easyrtcid, checkAudio, streamName) {
        var stream, peerConnObj;
        if (!easyrtcid) {
            stream = getLocalMediaStreamByName(streamName);
        }
        else {
            peerConnObj = peerConns[easyrtcid];
            if (!peerConnObj) {
                console.error("Developer error: haveTracks called about a peer you don't have a connection to");
                return false;
            }
            stream = peerConnObj.getRemoteStreamByName(streamName);
        }
        if (!stream) {
            return false;
        }

        var tracks;
        try {
            if (checkAudio) {
                tracks = stream.getAudioTracks();
            }
            else {
                tracks = stream.getVideoTracks();
            }
        } catch (oops) {
            return true;
        }
        if (!tracks){
            return false;
        }
        return tracks.length > 0;
    }
    /** Determines if a particular peer2peer connection has an audio track.
     * @param {String} easyrtcid - the id of the other caller in the connection. If easyrtcid is not supplied, checks the local media.
     * @param {String} streamName - an optional stream id.
     * @return {Boolean} true if there is an audio track or the browser can't tell us.
     */
    this.haveAudioTrack = function(easyrtcid, streamName) {
        return _haveTracks(easyrtcid, true, streamName);
    };
    /** Determines if a particular peer2peer connection has a video track.
     * @param {String} easyrtcid - the id of the other caller in the connection. If easyrtcid is not supplied, checks the local media.
     * @param {String} streamName - an optional stream id.     *
     * @return {Boolean} true if there is an video track or the browser can't tell us.
     */
    this.haveVideoTrack = function(easyrtcid, streamName) {
        return _haveTracks(easyrtcid, false, streamName);
    };
    /**
     * Gets a data field associated with a room.
     * @param {String} roomName - the name of the room.
     * @param {String} fieldName - the name of the field.
     * @return {Object} dataValue - the value of the field if present, undefined if not present.
     */
    this.getRoomField = function(roomName, fieldName) {
        var fields = self.getRoomFields(roomName);
        if (!fields || !fields[fieldName]){
            return undefined;
        }
        return fields[fieldName].fieldValue;
    };
//
// Experimental function to determine if statistics gathering is supported.
//
    this.supportsStatistics = function() {
        var peer;
        try {
            peer = new wRTCPeerConnection({iceServers: []}, {});
            return !!peer.getStats;
        }
        catch (err) {
            return false;
        }
    };
    /**
     * Connects to the EasyRTC signaling server. You must connect before trying to
     * call other users.
     * @param {String} applicationName is a string that identifies the application so that different applications can have different
     *        lists of users. Note that the server configuration specifies a regular expression that is used to check application names
     *        for validity. The default pattern is that of an identifier, spaces are not allowed.
     * @param {Function} successCallback (easyrtcId, roomOwner) - is called on successful connect. easyrtcId is the
     *   unique name that the client is known to the server by. A client usually only needs it's own easyrtcId for debugging purposes.
     *       roomOwner is true if the user is the owner of a room. It's value is random if the user is in multiple rooms.
     * @param {Function} errorCallback (errorCode, errorText) - is called on unsuccessful connect. if null, an alert is called instead.
     *  The errorCode takes it's value from easyrtc.errCodes.
     * @example
     *   easyrtc.connect("mychat_app",
     *                   function(easyrtcid, roomOwner){
     *                       if( roomOwner){ console.log("I'm the room owner"); }
     *                       console.log("my id is " + easyrtcid);
     *                   },
     *                   function(errorText){
     *                       console.log("failed to connect ", erFrText);
     *                   });
     */

    var fields = null;
    function isEmptyObj(obj) {
        if (obj === null || obj === undefined) {
            return true;
        }
        var key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                return false;
            }
        }
        return true;
    }

    //
// easyrtc.disconnect performs a clean disconnection of the client from the server.
//
    function disconnectBody() {
        var key;
        self.loggingOut = true;
        offersPending = {};
        acceptancePending = {};
        self.disconnecting = true;
        closedChannel = self.webSocket;
        if (self.webSocketConnected) {
            if (!preallocatedSocketIo) {
                self.webSocket.close();
            }
            self.webSocketConnected = false;
        }
        self.hangupAll();
        if (roomOccupantListener) {
            for (key in lastLoggedInList) {
                if (lastLoggedInList.hasOwnProperty(key)) {
                    roomOccupantListener(key, {}, false);
                }
            }
        }
        lastLoggedInList = {};
        self.emitEvent("roomOccupant", {});
        self.roomData = {};
        self.roomJoin = {};
        self.loggingOut = false;
        self.myEasyrtcid = null;
        self.disconnecting = false;
        oldConfig = {};
    }
    this.disconnect = function() {

        if (self.debugPrinter) {
            self.debugPrinter("attempt to disconnect from WebRTC signalling server");
        }

        self.disconnecting = true;
        self.hangupAll();
        self.loggingOut = true;
        //
        // The hangupAll may try to send configuration information back to the server.
        // Collecting that information is asynchronous, we don't actually close the
        // connection until it's had a chance to be sent. We allocate 100ms for collecting
        // the info, so 250ms should be sufficient for the disconnecting.
        //
        setTimeout(function() {
            if (self.webSocket) {
                try {
                    self.webSocket.disconnect();
                } catch (e) {
                    // we don't really care if this fails.
                }

                closedChannel = self.webSocket;
                self.webSocket = 0;
            }
            self.loggingOut = false;
            self.disconnecting = false;
            if (roomOccupantListener) {
                roomOccupantListener(null, {}, false);
            }
            self.emitEvent("roomOccupant", {});
            oldConfig = {};
        }, 250);
    };
    //
    // This function is used to send WebRTC signaling messages to another client. These messages all the form:
    //   destUser: some id or null
    //   msgType: one of ["offer"/"answer"/"candidate","reject","hangup", "getRoomList"]
    //   msgData: either null or an SDP record
    //   successCallback: a function with the signature  function(msgType, wholeMsg);
    //   errorCallback: a function with signature function(errorCode, errorText)
    //
    function sendSignalling(destUser, msgType, msgData, successCallback, errorCallback) {
        if (!self.webSocket) {
            throw "Attempt to send message without a valid connection to the server.";
        }
        else {
            var dataToShip = {
                msgType: msgType
            };
            if (destUser) {
                dataToShip.targetEasyrtcid = destUser;
            }
            if (msgData) {
                dataToShip.msgData = msgData;
            }

            if (self.debugPrinter) {
                self.debugPrinter("sending socket message " + JSON.stringify(dataToShip));
            }
            self.webSocket.json.emit("easyrtcCmd", dataToShip,
                    function(ackMsg) {
                        if (ackMsg.msgType !== "error") {
                            if (!ackMsg.hasOwnProperty("msgData")) {
                                ackMsg.msgData = null;
                            }
                            if (successCallback) {
                                successCallback(ackMsg.msgType, ackMsg.msgData);
                            }
                        }
                        else {
                            if (errorCallback) {
                                errorCallback(ackMsg.msgData.errorCode, ackMsg.msgData.errorText);
                            }
                            else {
                                self.showError(ackMsg.msgData.errorCode, ackMsg.msgData.errorText);
                            }
                        }
                    }
            );
        }
    }


    /**
     *Sends data to another user using previously established data channel. This method will
     * fail if no data channel has been established yet. Unlike the easyrtc.sendWS method,
     * you can't send a dictionary, convert dictionaries to strings using JSON.stringify first.
     * What data types you can send, and how large a data type depends on your browser.
     * @param {String} destUser (an easyrtcid)
     * @param {String} msgType - the type of message being sent (application specific).
     * @param {Object} msgData - a JSONable object.
     * @example
     *     easyrtc.sendDataP2P(someEasyrtcid, "roomData", {room:499, bldgNum:'asd'});
     */
    this.sendDataP2P = function(destUser, msgType, msgData) {

        var flattenedData = JSON.stringify({msgType: msgType, msgData: msgData});
        if (self.debugPrinter) {
            self.debugPrinter("sending p2p message to " + destUser + " with data=" + JSON.stringify(flattenedData));
        }

        if (!peerConns[destUser]) {
            self.showError(self.errCodes.DEVELOPER_ERR, "Attempt to send data peer to peer without a connection to " + destUser + ' first.');
        }
        else if (!peerConns[destUser].dataChannelS) {
            self.showError(self.errCodes.DEVELOPER_ERR, "Attempt to send data peer to peer without establishing a data channel to " + destUser + ' first.');
        }
        else if (!peerConns[destUser].dataChannelReady) {
            self.showError(self.errCodes.DEVELOPER_ERR, "Attempt to use data channel to " + destUser + " before it's ready to send.");
        }
        else {
            try {
                peerConns[destUser].dataChannelS.send(flattenedData);
            } catch (oops) {
                console.log("error=", oops);
                throw oops;
            }
        }
    };
    /** Sends data to another user using websockets. The easyrtc.sendServerMessage or easyrtc.sendPeerMessage methods
     * are wrappers for this method; application code should use them instead.
     * @param {String} destination - either a string containing the easyrtcId of the other user, or an object containing some subset of the following fields: targetEasyrtcid, targetGroup, targetRoom.
     * Specifying multiple fields restricts the scope of the destination (operates as a logical AND, not a logical OR).
     * @param {String} msgType -the type of message being sent (application specific).
     * @param {Object} msgData - a JSONable object.
     * @param {Function} ackhandler - by default, the ackhandler handles acknowledgments from the server that your message was delivered to it's destination.
     * However, application logic in the server can over-ride this. If you leave this null, a stub ackHandler will be used. The ackHandler
     * gets passed a message with the same msgType as your outgoing message, or a message type of "error" in which case
     * msgData will contain a errorCode and errorText fields.
     * @example
     *    easyrtc.sendDataWS(someEasyrtcid, "setPostalAddress", {room:499, bldgNum:'asd'},
     *      function(ackMsg){
     *          console.log("saw the following acknowledgment " + JSON.stringify(ackMsg));
     *      }
     *    );
     */
    this.sendDataWS = function(destination, msgType, msgData, ackhandler) {
        if (self.debugPrinter) {
            self.debugPrinter("sending client message via websockets to " + destination + " with data=" + JSON.stringify(msgData));
        }
        if (!ackhandler) {
            ackhandler = function(msg) {
                if (msg.msgType === "error") {
                    self.showError(msg.msgData.errorCode, msg.msgData.errorText);
                }
            };
        }

        var outgoingMessage = {
            msgType: msgType,
            msgData: msgData
        };
        if (destination) {
            if (typeof destination === 'string') {
                outgoingMessage.targetEasyrtcid = destination;
            }
            else if (typeof destination === 'object') {
                if (destination.targetEasyrtcid) {
                    outgoingMessage.targetEasyrtcid = destination.targetEasyrtcid;
                }
                if (destination.targetRoom) {
                    outgoingMessage.targetRoom = destination.targetRoom;
                }
                if (destination.targetGroup) {
                    outgoingMessage.targetGroup = destination.targetGroup;
                }
            }
        }


        if (self.webSocket) {
            self.webSocket.json.emit("easyrtcMsg", outgoingMessage, ackhandler);
        }
        else {
            if (self.debugPrinter) {
                self.debugPrinter("websocket failed because no connection to server");
            }
            throw "Attempt to send message without a valid connection to the server.";
        }
    };
    /** Sends data to another user. This method uses data channels if one has been set up, or websockets otherwise.
     * @param {String} destUser - a string containing the easyrtcId of the other user.
     * Specifying multiple fields restricts the scope of the destination (operates as a logical AND, not a logical OR).
     * @param {String} msgType -the type of message being sent (application specific).
     * @param {Object} msgData - a JSONable object.
     * @param {Function} ackHandler - a function which receives acknowledgments. May only be invoked in
     *  the websocket case.
     * @example
     *    easyrtc.sendData(someEasyrtcid, "roomData",  {room:499, bldgNum:'asd'},
     *       function ackHandler(msgType, msgData);
     *    );
     */
    this.sendData = function(destUser, msgType, msgData, ackHandler) {
        if (peerConns[destUser] && peerConns[destUser].dataChannelReady) {
            self.sendDataP2P(destUser, msgType, msgData);
        }
        else {
            self.sendDataWS(destUser, msgType, msgData, ackHandler);
        }
    };
    /**
     * Sends a message to another peer on the easyrtcMsg channel.
     * @param {String} destination - either a string containing the easyrtcId of the other user, or an object containing some subset of the following fields: targetEasyrtcid, targetGroup, targetRoom.
     * Specifying multiple fields restricts the scope of the destination (operates as a logical AND, not a logical OR).
     * @param {String} msgType - the type of message being sent (application specific).
     * @param {Object} msgData - a JSONable object with the message contents.
     * @param {function(String, Object)} successCB - a callback function with results from the server.
     * @param {function(String, String)} failureCB - a callback function to handle errors.
     * @example
     *     easyrtc.sendPeerMessage(otherUser, 'offer_candy', {candy_name:'mars'},
     *             function(msgType, msgBody ){
     *                console.log("message was sent");
     *             },
     *             function(errorCode, errorText){
     *                console.log("error was " + errorText);
     *             });
     */
    this.sendPeerMessage = function(destination, msgType, msgData, successCB, failureCB) {
        if (!destination) {
            console.error("Developer error, destination was null in sendPeerMessage");
        }

        if (self.debugPrinter) {
            self.debugPrinter("sending peer message " + JSON.stringify(msgData));
        }
        function ackHandler(response) {
            if (response.msgType === "error") {
                if (failureCB) {
                    failureCB(response.msgData.errorCode, response.msgData.errorText);
                }
            }
            else {
                if (successCB) {
                    // firefox complains if you pass an undefined as an parameter.
                    successCB(response.msgType, response.msgData ? response.msgData : null);
                }
            }
        }

        self.sendDataWS(destination, msgType, msgData, ackHandler);
    };
    /**
     * Sends a message to the application code in the server (ie, on the easyrtcMsg channel).
     * @param {String} msgType - the type of message being sent (application specific).
     * @param {Object} msgData - a JSONable object with the message contents.
     * @param {function(String, Object)} successCB - a callback function with results from the server.
     * @param {function(String, String)} failureCB - a callback function to handle errors.
     * @example
     *     easyrtc.sendServerMessage('get_candy', {candy_name:'mars'},
     *             function(msgType, msgData ){
     *                console.log("got candy count of " + msgData.barCount);
     *             },
     *             function(errorCode, errorText){
     *                console.log("error was " + errorText);
     *             });
     */
    this.sendServerMessage = function(msgType, msgData, successCB, failureCB) {
        if (self.debugPrinter) {
            var dataToShip = {msgType: msgType, msgData: msgData};
            self.debugPrinter("sending server message " + JSON.stringify(dataToShip));
        }
        function ackhandler(response) {
            if (response.msgType === "error") {
                if (failureCB) {
                    failureCB(response.msgData.errorCode, response.msgData.errorText);
                }
            }
            else {
                if (successCB) {
                    successCB(response.msgType, response.msgData ? response.msgData : null);
                }
            }
        }

        self.sendDataWS(null, msgType, msgData, ackhandler);
    };
    /** Sends the server a request for the list of rooms the user can see.
     * You must have already be connected to use this function.
     * @param {function(Object)} callback - on success, this function is called with a map of the form  { roomName:{"roomName":String, "numberClients": Number}}.
     * The roomName appears as both the key to the map, and as the value of the "roomName" field.
     * @param {function(String, String)} errorCallback   is called on failure. It gets an errorCode and errorText as it's too arguments.
     * @example
     *    easyrtc.getRoomList(
     *        function(roomList){
     *           for(roomName in roomList){
     *              console.log("saw room " + roomName);
     *           }
     *         },
     *         function(errorCode, errorText){
     *            easyrtc.showError(errorCode, errorText);
     *         }
     *    );
     */
    this.getRoomList = function(callback, errorCallback) {
        sendSignalling(null, "getRoomList", null,
                function(msgType, msgData) {
                    callback(msgData.roomList);
                },
                function(errorCode, errorText) {
                    if (errorCallback) {
                        errorCallback(errorCode, errorText);
                    }
                    else {
                        self.showError(errorCode, errorText);
                    }
                }
        );
    };
    /** Value returned by easyrtc.getConnectStatus if the other user isn't connected to us. */
    this.NOT_CONNECTED = "not connected";
    /** Value returned by easyrtc.getConnectStatus if the other user is in the process of getting connected */
    this.BECOMING_CONNECTED = "connection in progress to us.";
    /** Value returned by easyrtc.getConnectStatus if the other user is connected to us. */
    this.IS_CONNECTED = "is connected";
    /**
     * Check if the client has a peer-2-peer connection to another user.
     * The return values are text strings so you can use them in debugging output.
     *  @param {String} otherUser - the easyrtcid of the other user.
     *  @return {String} one of the following values: easyrtc.NOT_CONNECTED, easyrtc.BECOMING_CONNECTED, easyrtc.IS_CONNECTED
     *  @example
     *     if( easyrtc.getConnectStatus(otherEasyrtcid) == easyrtc.NOT_CONNECTED ){
     *         easyrtc.call(otherEasyrtcid,
     *                  function(){ console.log("success"); },
     *                  function(){ console.log("failure"); });
     *     }
     */
    this.getConnectStatus = function(otherUser) {
        if (!peerConns.hasOwnProperty(otherUser)) {
            return self.NOT_CONNECTED;
        }
        var peer = peerConns[otherUser];
        if ((peer.sharingAudio || peer.sharingVideo) && !peer.startedAV) {
            return self.BECOMING_CONNECTED;
        }
        else if (peer.sharingData && !peer.dataChannelReady) {
            return self.BECOMING_CONNECTED;
        }
        else {
            return self.IS_CONNECTED;
        }
    };
        /**
         *  @method  getConnectedPeers
         * @returns {Array}
         */
        this.getConnectedUsers = function() {
            var i, results = [];
            for (i in peerConns) {
                if (peerConns.hasOwnProperty(i)) {
                    results.push( i );
                }
            }
            return results;
        };


    /**
     * @private
     */
    function buildPeerConstraints() {
        var options = [];
        options.push({'DtlsSrtpKeyAgreement': 'true'}); // for interoperability
        return {optional: options};
    }


    /**
     *  Initiates a call to another user. If it succeeds, the streamAcceptor callback will be called.
     * @param {String} otherUser - the easyrtcid of the peer being called.
     * @param {Function} callSuccessCB (otherCaller, mediaType) - is called when the datachannel is established or the MediaStream is established. mediaType will have a value of "audiovideo" or "datachannel"
     * @param {Function} callFailureCB (errorCode, errMessage) - is called if there was a system error interfering with the call.
     * @param {Function} wasAcceptedCB (wasAccepted:boolean,otherUser:string) - is called when a call is accepted or rejected by another party. It can be left null.
     * @param {Array} streamNames - optional array of streamNames.
     * @example
     *    easyrtc.call( otherEasyrtcid,
     *        function(easyrtcid, mediaType){
     *           console.log("Got mediaType " + mediaType + " from " + easyrtc.idToName(easyrtcid));
     *        },
     *        function(errorCode, errMessage){
     *           console.log("call to  " + easyrtc.idToName(otherEasyrtcid) + " failed:" + errMessage);
     *        },
     *        function(wasAccepted, easyrtcid){
     *            if( wasAccepted ){
     *               console.log("call accepted by " + easyrtc.idToName(easyrtcid));
     *            }
     *            else{
     *                console.log("call rejected" + easyrtc.idToName(easyrtcid));
     *            }
     *        });
     */
    this.call = function(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB, streamNames) {

        if (streamNames) {
            if (typeof streamNames === "string") { // accept a string argument if passed.
                streamNames = [streamNames];
            }
            else if (streamNames.length === undefined) {
                easyrtc.showError(self.errCodes.DEVELOPER_ERR, "easyrtc.call passed bad streamNames");
                return;
            }
        }

        if (self.debugPrinter) {
            self.debugPrinter("initiating peer to peer call to " + otherUser +
                    " audio=" + audioEnabled +
                    " video=" + videoEnabled +
                    " data=" + dataEnabled);
        }

        if (!self.supportsPeerConnections()) {
            callFailureCB(self.errCodes.CALL_ERR, self.getConstantString("noWebrtcSupport"));
            return;
        }

        var message;
        //
        // If we are sharing audio/video and we haven't allocated the local media stream yet,
        // we'll do so, recalling ourself on success.
        //
        if (!streamNames && autoInitUserMedia) {
            var stream = self.getLocalStream();
            if (!stream && (audioEnabled || videoEnabled)) {
                self.initMediaSource(function() {
                    self.call(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB);
                }, callFailureCB);
                return;
            }
        }

        if (!self.webSocket) {
            message = "Attempt to make a call prior to connecting to service";
            if (self.debugPrinter) {
                self.debugPrinter(message);
            }
            throw message;
        }

        //
        // If B calls A, and then A calls B before accepting, then A should treat the attempt to
        // call B as a positive offer to B's offer.
        //
        if (offersPending[otherUser]) {
            wasAcceptedCB(true);
            doAnswer(otherUser, offersPending[otherUser], streamNames);
            delete offersPending[otherUser];
            self.callCancelled(otherUser, false);
            return;
        }

        // do we already have a pending call?
        if (typeof acceptancePending[otherUser] !== 'undefined') {
            message = "Call already pending acceptance";
            if (self.debugPrinter) {
                self.debugPrinter(message);
            }
            callFailureCB(self.errCodes.ALREADY_CONNECTED, message);
            return;
        }

        if (use_fresh_ice_each_peer) {
            self.getFreshIceConfig(function(succeeded) {
                if (succeeded) {
                    callBody(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB, streamNames);
                }
                else {
                    callFailureCB(self.errCodes.CALL_ERR, "Attempt to get fresh ice configuration failed");
                }
            });
        }
        else {
            callBody(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB, streamNames);
        }
    };
    function callBody(otherUser, callSuccessCB, callFailureCB, wasAcceptedCB, streamNames) {
        acceptancePending[otherUser] = true;
        var pc = buildPeerConnection(otherUser, true, callFailureCB, streamNames);
        if (!pc) {
            message = "buildPeerConnection failed, call not completed";
            if (self.debugPrinter) {
                self.debugPrinter(message);
            }
            throw message;
        }

        peerConns[otherUser].callSuccessCB = callSuccessCB;
        peerConns[otherUser].callFailureCB = callFailureCB;
        peerConns[otherUser].wasAcceptedCB = wasAcceptedCB;
        var peerConnObj = peerConns[otherUser];
        var setLocalAndSendMessage0 = function(sessionDescription) {
            if (peerConnObj.cancelled) {
                return;
            }
            var sendOffer = function() {

                sendSignalling(otherUser, "offer", sessionDescription, null, callFailureCB);
            };
            if (sdpLocalFilter) {
                sessionDescription.sdp = sdpLocalFilter(sessionDescription.sdp);
            }
            pc.setLocalDescription(sessionDescription, sendOffer,
                    function(errorText) {
                        callFailureCB(self.errCodes.CALL_ERR, errorText);
                    });
        };
        setTimeout(function() {
            //
            // if the call was cancelled, we don't want to continue getting the offer.
            // we can tell the call was cancelled because there won't be a peerConn object
            // for it.
            //
            if( !peerConns[otherUser]) {
                return;
            }
            pc.createOffer(setLocalAndSendMessage0, function(errorObj) {
                callFailureCB(self.errCodes.CALL_ERR, JSON.stringify(errorObj));
            },
                    receivedMediaContraints);
        }, 100);
    }
    function hangupBody(otherUser) {
        var i;
        if (self.debugPrinter) {
            self.debugPrinter("Hanging up on " + otherUser);
        }
        clearQueuedMessages(otherUser);
        if (peerConns[otherUser]) {
            if (peerConns[otherUser].pc) {
                var remoteStreams = peerConns[otherUser].pc.getRemoteStreams();
                for (i = 0; i < remoteStreams.length; i++) {
                    if( !remoteStreams[i].ended ) {
                        emitOnStreamClosed(otherUser, remoteStreams[i]);
                        try {
                            remoteStreams[i].close();
                        } catch (err) {
                        }
                    }
                }
                //
                // todo: may need to add a few lines here for closing the data channels
                //
                try {
                    peerConns[otherUser].pc.close();
                } catch (err) {
                }
            }

            peerConns[otherUser].cancelled = true;
            delete peerConns[otherUser];
            if (self.webSocket) {
                sendSignalling(otherUser, "hangup", null, function() {
                }, function(errorCode, errorText) {
                    if (self.debugPrinter) {
                        self.debugPrinter("hangup failed:" + errorText);
                    }
                });
            }
            if (acceptancePending[otherUser]) {
                delete acceptancePending[otherUser];
            }
        }
    }

    /**
     * Hang up on a particular user or all users.
     *  @param {String} otherUser - the easyrtcid of the person to hang up on.
     *  @example
     *     easyrtc.hangup(someEasyrtcid);
     */
    this.hangup = function(otherUser) {
        hangupBody(otherUser);
        updateConfigurationInfo();
    };
    /**
     * Hangs up on all current connections.
     * @example
     *    easyrtc.hangupAll();
     */
    this.hangupAll = function() {

        var sawAConnection = false;
        for (var otherUser in peerConns) {
            if (!peerConns.hasOwnProperty(otherUser)) {
                continue;
            }
            sawAConnection = true;
            hangupBody(otherUser);
        }

        if (sawAConnection) {
            updateConfigurationInfo();
        }
    };
    /** Checks to see if data channels work between two peers.
     * @param {String} otherUser - the other peer.
     * @returns {Boolean} true if data channels work and are ready to be used
     *   between the two peers.
     */
    this.doesDataChannelWork = function(otherUser) {
        if (!peerConns[otherUser]) {
            return false;
        }
        return !!peerConns[otherUser].dataChannelReady;
    };
    /**
     * Return the media stream shared by a particular peer. This is needed when you
     * add a stream in the middle of a call.
     * @param {String} easyrtcid the peer.
     * @param {String} remotestreamName an optional argument supplying the streamName.
     * @returns {Object} A mediaStream.
     */
    this.getRemoteStream = function(easyrtcid, remotestreamName) {
        if (!peerConns[easyrtcid]) {
            self.showError(self.errCodes.DEVELOPER_ERR, "attempt to get stream of uncalled party");
            throw "Developer err: no such stream";
        }
        else {
            return peerConns[easyrtcid].getRemoteStreamByName(remotestreamName);
        }
    };

    this.getPeerConnsObject = function(){
        return peerConns;
    };
    /**
     * Assign a local streamName to a remote stream so that it can be forwarded to other callers.
     * @param {String} easyrtcid the peer supplying the remote stream
     * @param {String} remotestreamName the streamName supplied by the peer.
     * @param {String} localstreamName streamName used when passing the stream to other peers.
     * @example
     *    easyrtc.makeLocalStreamFromRemoteStream(sourcePeer, "default", "forwardedStream");
     *    easyrtc.call(nextPeer, callSuccessCB, callFailureCB, wasAcceptedCB, ["forwardedStream"]);
     */
    this.makeLocalStreamFromRemoteStream = function(easyrtcid, remotestreamName, localstreamName) {
        if (!streamName) {
            streamName = "default";
        }
        var remoteStream;
        if (peerConns[easyrtcid].pc) {
            remoteStream = peerConns[easyrtcid].getRemoteStreamByName(remotestreamName);
            if (remoteStream) {
                registerLocalMediaStreamByName(remoteStream, localstreamName);
            }
            else {
                throw "Developer err: no such stream";
            }
        }
        else {
            throw "Developer err: no such peer ";
        }
    };

    /**
     * Add a named local stream to a call.
     * @param {String} easyrtcId The id of client receiving the stream.
     * @param {String} streamName The name of the stream.
     * @param {Function} receiptHandler is a function that gets called when the other side sends a message
     *   that the stream has been received. The receiptHandler gets called with an easyrtcid and a stream name. This
     *   argument is optional.
     */
    this.addStreamToCall = function(easyrtcId, streamName, receiptHandler) {
        if( !streamName) {
            streamName = "default";
        }
        var stream = getLocalMediaStreamByName(streamName);
        if (!stream) {
            console.log("attempt to add nonexistent stream " + streamName);
        }
        else if (!peerConns[easyrtcId] || !peerConns[easyrtcId].pc) {
            console.log("Can't add stream before a call has started.");
        }
        else {
            var pc = peerConns[easyrtcId].pc;
            peerConns[easyrtcId].enableNegotiateListener = true;
            pc.addStream(stream);
            if( receiptHandler ) {
                peerConns[easyrtcId].streamsAddedAcks[streamName] = receiptHandler;
            }
        }
    };

    //
    // these three listeners support the ability to add/remove additional mediastreams on the fly.
    //
    this.setPeerListener(function(easyrtcid, msgType, msgData) {
        if (!peerConns[easyrtcid] || !peerConns[easyrtcid].pc) {
            easyrtc.showError(self.errCodes.DEVELOPER_ERR, 
                  "Attempt to add additional stream before establishing the base call.");
        }
        else {
            var sdp = msgData.sdp;
            var pc = peerConns[easyrtcid].pc;

            var setLocalAndSendMessage1 = function(sessionDescription) {
                var sendAnswer = function() {
                   if (self.debugPrinter) {
                       self.debugPrinter("sending answer");
                   }
                   function onSignalSuccess() {
                   }
   
                   function onSignalFailure(errorCode, errorText) {
                       delete peerConns[easyrtcid];
                       self.showError(errorCode, errorText);
                   }
   
                   sendSignalling(easyrtcid, "answer", sessionDescription,
                           onSignalSuccess, onSignalFailure);
                   peerConns[easyrtcid].connectionAccepted = true;
                   sendQueuedCandidates(easyrtcid, onSignalSuccess, onSignalFailure);
               };

               if (sdpLocalFilter) {
                   sessionDescription.sdp = sdpLocalFilter(sessionDescription.sdp);
               }
               pc.setLocalDescription(sessionDescription, sendAnswer, function(/*message*/) {
                   self.showError(self.errCodes.INTERNAL_ERR, "setLocalDescription: " + msgData);
               });
            };

            var invokeCreateAnswer = function() {
               pc.createAnswer(setLocalAndSendMessage1,
                    function(message) {
                        self.showError(self.errCodes.INTERNAL_ERR, "create-answer: " + message);
                    },
                    receivedMediaContraints);
               self.sendPeerMessage(easyrtcid, "__gotAddedMediaStream", {sdp: sdp});
            };

            if (self.debugPrinter) {
                self.debugPrinter("about to call setRemoteDescription in doAnswer");
            }
            try {

                if (sdpRemoteFilter) {
                    sdp.sdp = sdpRemoteFilter(sdp.sdp);
                }
                pc.setRemoteDescription(new wRTCSessionDescription(sdp),
                   invokeCreateAnswer, function(message) {
                    self.showError(self.errCodes.INTERNAL_ERR, "set-remote-description: " + message);
                });
            } catch (srdError) {
                console.log("set remote description failed");
                if (self.debugPrinter) {
                    self.debugPrinter("saw exception in setRemoteDescription");
                }
                self.showError(self.errCodes.INTERNAL_ERR, "setRemoteDescription failed: " + srdError.message);
            }
        }
    }, "__addedMediaStream");
    this.setPeerListener(function(easyrtcid, msgType, msgData) {
        if (!peerConns[easyrtcid] || !peerConns[easyrtcid].pc) {
        }
        else {
            var sdp = msgData.sdp;
            if (sdpRemoteFilter) {
                sdp.sdp = sdpRemoteFilter(sdp.sdp);
            }
            var pc = peerConns[easyrtcid].pc;
            pc.setRemoteDescription(new wRTCSessionDescription(sdp), function(){},
                    function(message) {
                       self.showError(self.errCodes.INTERNAL_ERR, "set-remote-description: " + message);
                    });
        }

    }, "__gotAddedMediaStream");
    this.setPeerListener(function(easyrtcid, msgType, msgData) {
        if (!peerConns[easyrtcid] || !peerConns[easyrtcid].pc) {
        }
        else {
            var stream = peerConns[easyrtcid].getRemoteStreamByName(msgData.streamName);
            if (stream) {
                onRemoveStreamHelper(easyrtcid, stream, msgData.streamName);
                stream.ended = true;
            }
        }

    }, "__closingMediaStream");
    function onRemoveStreamHelper(easyrtcid, stream) {
        if (peerConns[easyrtcid]) {
            emitOnStreamClosed(easyrtcid, stream);
            updateConfigurationInfo();
            if( peerConns[easyrtcid].pc ) {
                 try {
                    peerConns[easyrtcid].pc.removeStream(stream);
                 } catch( err) {}
            }
           
        }
    }


    this.dumpPeerConnectionInfo = function() {
        var i;
        for (var peer in peerConns) {
            console.log("For peer " + peer);
            var pc = peerConns[peer].pc;
            var remotes = pc.getRemoteStreams();
            var remoteIds = [];
            for (i = 0; i < remotes.length; i++) {
                remoteIds.push(remotes[i].id);
            }
            var locals = pc.getLocalStreams();
            var localIds = [];
            for (i = 0; i < locals.length; i++) {
                localIds.push(locals[i].id);
            }
            console.log("    " + JSON.stringify({local: localIds, remote: remoteIds}));
        }
    };


    function buildPeerConnection(otherUser, isInitiator, failureCB, streamNames) {
        var pc;
        var message;
        var newPeerConn;
        var iceConfig = pc_config_to_use ? pc_config_to_use : pc_config;
        if (self.debugPrinter) {
            self.debugPrinter("building peer connection to " + otherUser);
        }

        //
        // we don't support data channels on chrome versions < 31
        //
        try {
            pc = self.createRTCPeerConnection(iceConfig, buildPeerConstraints());
            if (!pc) {
                message = "Unable to create PeerConnection object, check your ice configuration(" +
                        JSON.stringify(ice_config) + ")";
                if (self.debugPrinter) {
                    self.debugPrinter(message);
                }
                throw(message);
            }

            //
            // turn off data channel support if the browser doesn't support it.
            //
            if (dataEnabled && typeof pc.createDataChannel === 'undefined') {
                dataEnabled = false;
            }
            pc.onnegotiationneeded = function(event) {
                if( peerConns[otherUser].enableNegotiateListener ) {
                    pc.createOffer(function(sdp) {
                        if (sdpLocalFilter) {
                            sdp.sdp = sdpLocalFilter(sdp.sdp);
                        }
                        pc.setLocalDescription(sdp, function() {
                            self.sendPeerMessage(otherUser, "__addedMediaStream", {sdp: sdp});
                        }, function() {
                        });
                    }, function(errorObj) {
                        console.log("unexpected error in creating offer");
                    });
                }
            };

            pc.onconnection = function() {
                if (self.debugPrinter) {
                    self.debugPrinter("onconnection called prematurely");
                }
            };
            newPeerConn = {
                pc: pc,
                candidatesToSend: [],
                startedAV: false,
                connectionAccepted: false,
                isInitiator: isInitiator,
                remoteStreamIdToName: {},
                streamsAddedAcks: {},
                liveRemoteStreams: {},
                getRemoteStreamByName: function(streamName) {
                    var remoteStreams = pc.getRemoteStreams();
                    var i = 0;
                    var keyToMatch = null;
                    var roomName;
                    if (!streamName) {
                        streamName = "default";
                    }

                    if (streamName === "default") {
                        if (remoteStreams.length > 0) {
                            return remoteStreams[0];
                        }
                        else {
                            return null;
                        }
                    }
                    for (roomName in self.roomData) {
                        var mediaIds = self.getRoomApiField(roomName, otherUser, "mediaIds");
                        keyToMatch = mediaIds ? mediaIds[streamName] : null;
                        if (keyToMatch) {
                            break;
                        }
                    }
                    if (!keyToMatch) {
                        self.showError(self.errCodes.DEVELOPER_ERR, "remote peer does not have media stream called " + streamName);
                    }

                    for (i = 0; i < remoteStreams.length; i++) {
                        var remoteId;
                        if (remoteStreams[i].hasOwnProperty("id")) {
                            remoteId = remoteStreams[i].id;
                        }
                        else {
                            remoteId = "default";
                        }

                        if (!keyToMatch || remoteId === keyToMatch) {
                            return remoteStreams[i];
                        }

                    }
                    return null;
                }
                //                var remoteStreams = peerConns[i].pc.getRemoteStreams();
            };
            pc.onicecandidate = function(event) {
                if (newPeerConn.cancelled) {
                    return;
                }
                var candidateData;
                if (event.candidate && peerConns[otherUser]) {
                    candidateData = {
                        type: 'candidate',
                        label: event.candidate.sdpMLineIndex,
                        id: event.candidate.sdpMid,
                        candidate: event.candidate.candidate
                    };

                    if( iceCandidateFilter ) {
                       candidateData = iceCandidateFilter(candidateData, false);
                       if( !candidateData ) {
                          return;
                       }
                    } 
                    //
                    // some candidates include ip addresses of turn servers. we'll want those 
                    // later so we can see if our actual connection uses a turn server.
                    // The keyword "relay" in the candidate identifies it as referencing a 
                    // turn server. The \d symbol in the regular expression matches a number.
                    // 
                    if (event.candidate.candidate.indexOf("typ relay") > 0) {
                        var ipAddress = event.candidate.candidate.match(/(udp|tcp) \d+ (\d+\.\d+\.\d+\.\d+)/i)[2];
                        self._turnServers[ipAddress] = true;
                    }

                    if (peerConns[otherUser].connectionAccepted) {
                        sendSignalling(otherUser, "candidate", candidateData, null, function() {
                            failureCB(self.errCodes.PEER_GONE, "Candidate disappeared");
                        });
                    }
                    else {
                        peerConns[otherUser].candidatesToSend.push(candidateData);
                    }
                }
            };
            pc.onaddstream = function(event) {
                if (self.debugPrinter) {
                    self.debugPrinter("saw incoming media stream");
                }
                if (newPeerConn.cancelled){
                    return;
                }

                if (!peerConns[otherUser].startedAV) {
                    peerConns[otherUser].startedAV = true;
                    peerConns[otherUser].sharingAudio = haveAudioVideo.audio;
                    peerConns[otherUser].sharingVideo = haveAudioVideo.video;
                    peerConns[otherUser].connectTime = new Date().getTime();
                    if (peerConns[otherUser].callSuccessCB) {
                        if (peerConns[otherUser].sharingAudio || peerConns[otherUser].sharingVideo) {
                            peerConns[otherUser].callSuccessCB(otherUser, "audiovideo");
                        }
                    }
                    if (audioEnabled || videoEnabled) {
                        updateConfiguration();
                    }
                }
                var remoteName = getNameOfRemoteStream(otherUser, event.stream.id || "default");
                if (!remoteName) {
                    remoteName = "default";
                }
                peerConns[otherUser].remoteStreamIdToName[event.stream.id || "default"] = remoteName;
                peerConns[otherUser].liveRemoteStreams[remoteName] = true;
                event.stream.streamName = remoteName;
                if (self.streamAcceptor) {
                    self.streamAcceptor(otherUser, event.stream, remoteName);
                    //
                    // Inform the other user that the stream they provided has been received.
                    // This should be moved into signalling at some point
                    //
                    self.sendDataWS(otherUser, "easyrtc_streamReceived", {streamName:remoteName},function(){});
                }
            };
            pc.onremovestream = function(event) {
                if (self.debugPrinter) {
                    self.debugPrinter("saw remove on remote media stream");
                }
                onRemoveStreamHelper(otherUser, event.stream, event.stream.id || "default");
            };
            peerConns[otherUser] = newPeerConn;
        } catch (e) {
            if (self.debugPrinter) {
                self.debugPrinter(JSON.stringify(e));
            }
            failureCB(self.errCodes.SYSTEM_ERR, e.message);
            return null;
        }

        var i, stream;
        if (streamNames) {
            for (i = 0; i < streamNames.length; i++) {
                stream = getLocalMediaStreamByName(streamNames[i]);
                if (stream) {
                    pc.addStream(stream);
                }
                else {
                    console.log("Developer error, attempt to access unknown local media stream " + streamNames[i]);
                }
            }
        }
        else if (autoInitUserMedia && (videoEnabled || audioEnabled)) {
            stream = self.getLocalStream();
            pc.addStream(stream);
        }

        //
        // This function handles data channel message events.
        //
        function dataChannelMessageHandler(event) {
            if (self.debugPrinter) {
                self.debugPrinter("saw dataChannel.onmessage event: " + JSON.stringify(event.data));
            }

            if (event.data === "dataChannelPrimed") {
                self.sendDataWS(otherUser, "dataChannelPrimed", "");
            }
            else {
                //
                // Chrome and Firefox Interop is passing a event with a strange data="", perhaps
                // as it's own form of priming message. Comparing the data against "" doesn't
                // work, so I'm going with parsing and trapping the parse error.
                // 
                try {
                    var msg = JSON.parse(event.data);
                    if (msg) {
                        self.receivePeerDistribute(otherUser, msg, null);
                    }
                }
                catch (err) {
                }
            }
        }

        function initOutGoingChannel(otherUser) {
            if (self.debugPrinter) {
                self.debugPrinter("saw initOutgoingChannel call");
            }
            var dataChannel = pc.createDataChannel(dataChannelName, self.getDatachannelConstraints());
            peerConns[otherUser].dataChannelS = dataChannel;
            peerConns[otherUser].dataChannelR = dataChannel;
            dataChannel.onmessage = dataChannelMessageHandler;
            dataChannel.onopen = function(/*event*/) {
                if (self.debugPrinter) {
                    self.debugPrinter("saw dataChannel.onopen event");
                }
                if (peerConns[otherUser]) {
                    dataChannel.send("dataChannelPrimed");
                }
            };
            dataChannel.onclose = function(/*event*/) {
                if (self.debugPrinter) {
                    self.debugPrinter("saw dataChannelS.onclose event");
                }
                if (peerConns[otherUser]) {
                    peerConns[otherUser].dataChannelReady = false;
                    delete peerConns[otherUser].dataChannelS;
                }
                if (onDataChannelClose) {
                    onDataChannelClose(otherUser);
                }

                updateConfigurationInfo();
            };
        }

        function initIncomingChannel(otherUser) {
            if (self.debugPrinter) {
                self.debugPrinter("initializing incoming channel handler for " + otherUser);
            }

            peerConns[otherUser].pc.ondatachannel = function(event) {

                if (self.debugPrinter) {
                    self.debugPrinter("saw incoming data channel");
                }

                var dataChannel = event.channel;
                peerConns[otherUser].dataChannelR = dataChannel;
                peerConns[otherUser].dataChannelS = dataChannel;
                peerConns[otherUser].dataChannelReady = true;
                dataChannel.onmessage = dataChannelMessageHandler;
                dataChannel.onclose = function(/*event*/) {
                    if (self.debugPrinter) {
                        self.debugPrinter("saw dataChannelR.onclose event");
                    }
                    if (peerConns[otherUser]) {
                        peerConns[otherUser].dataChannelReady = false;
                        delete peerConns[otherUser].dataChannelR;
                    }
                    if (onDataChannelClose) {
                        onDataChannelClose(otherUser);
                    }

                    updateConfigurationInfo();
                };
                dataChannel.onopen = function(/*event*/) {
                    if (self.debugPrinter) {
                        self.debugPrinter("saw dataChannel.onopen event");
                    }
                    if (peerConns[otherUser]) {
                        dataChannel.send("dataChannelPrimed");
                    }
                };
            };
        }

        //
        //  added for interoperability
        //
        var doDataChannels = dataEnabled;
        if (doDataChannels) {

            // check if both sides have the same browser and versions 
        }

        if (doDataChannels) {
            self.setPeerListener(function() {
                peerConns[otherUser].dataChannelReady = true;
                if (peerConns[otherUser].callSuccessCB) {
                    peerConns[otherUser].callSuccessCB(otherUser, "datachannel");
                }
                if (onDataChannelOpen) {
                    onDataChannelOpen(otherUser, true);
                }
                updateConfigurationInfo();
            }, "dataChannelPrimed", otherUser);
            if (isInitiator) {
                try {

                    initOutGoingChannel(otherUser);
                } catch (channelErrorEvent) {
                    console.log("failed to init outgoing channel");
                    failureCB(self.errCodes.SYSTEM_ERR,
                            self.formatError(channelErrorEvent));
                }
            }
            if (!isInitiator) {
                initIncomingChannel(otherUser);
            }
        }

        pc.onconnection = function() {
            if (self.debugPrinter) {
                self.debugPrinter("setup pc.onconnection ");
            }
        };

        //
        // Temporary support for responding to acknowledgements of about streams being added.
        //
        self.setPeerListener(function(easyrtcid, msgType, msgData/*, targeting*/){
             if( newPeerConn.streamsAddedAcks[msgData.streamName]) {
                 (newPeerConn.streamsAddedAcks[msgData.streamName])(easyrtcid, msgData.streamName);
                 delete newPeerConn.streamsAddedAcks[msgData.streamName];
             }
        }, "easyrtc_streamReceived", otherUser);
        return pc;
    };
    function doAnswer(caller, msgData, streamNames) {
        if (!streamNames && autoInitUserMedia) {
            var localStream = self.getLocalStream();
            if (!localStream && (videoEnabled || audioEnabled)) {
                self.initMediaSource(
                        function() {
                            doAnswer(caller, msgData);
                        },
                        function(errorCode, errorObj) {
                            self.showError(self.errCodes.MEDIA_ERR, self.format(self.getConstantString("localMediaError")));
                        });
                return;
            }
        }
        if (use_fresh_ice_each_peer) {
            self.getFreshIceConfig(function(succeeded) {
                if (succeeded) {
                    doAnswerBody(caller, msgData, streamNames);
                }
                else {
                    self.showError(self.errCodes.CALL_ERR, "Failed to get fresh ice config");
                }
            });
        }
        else {
            doAnswerBody(caller, msgData, streamNames);
        }
    };

    function doAnswerBody(caller, msgData, streamNames) {
        var pc = buildPeerConnection(caller, false, function(message) {
            self.showError(self.errCodes.SYSTEM_ERR, message);
        }, streamNames);
        var newPeerConn = peerConns[caller];
        if (!pc) {
            if (self.debugPrinter) {
                self.debugPrinter("buildPeerConnection failed. Call not answered");
            }
            return;
        }
        var setLocalAndSendMessage1 = function(sessionDescription) {
            if (newPeerConn.cancelled){
                return;
            }
            var sendAnswer = function() {
                if (self.debugPrinter) {
                    self.debugPrinter("sending answer");
                }
                function onSignalSuccess() {
                }

                function onSignalFailure(errorCode, errorText) {
                    delete peerConns[caller];
                    self.showError(errorCode, errorText);
                }

                sendSignalling(caller, "answer", sessionDescription,
                        onSignalSuccess, onSignalFailure);
                peerConns[caller].connectionAccepted = true;
                sendQueuedCandidates(caller, onSignalSuccess, onSignalFailure);
                if (pc.connectDataConnection) {
                    if (self.debugPrinter) {
                        self.debugPrinter("calling connectDataConnection(5002,5001)");
                    }
                    pc.connectDataConnection(5002, 5001);
                }
            };
            if (sdpLocalFilter) {
                sessionDescription.sdp = sdpLocalFilter(sessionDescription.sdp);
            }
            pc.setLocalDescription(sessionDescription, sendAnswer, function(message) {
                self.showError(self.errCodes.INTERNAL_ERR, "setLocalDescription: " + message);
            });
        };
        var sd = null;

        sd = new wRTCSessionDescription(msgData);

        if (self.debugPrinter) {
            self.debugPrinter("sdp ||  " + JSON.stringify(sd));
        }
        var invokeCreateAnswer = function() {
            if (newPeerConn.cancelled){
                return;
            }
            pc.createAnswer(setLocalAndSendMessage1,
                    function(message) {
                        self.showError(self.errCodes.INTERNAL_ERR, "create-answer: " + message);
                    },
                    receivedMediaContraints);
        };
        if (self.debugPrinter) {
            self.debugPrinter("about to call setRemoteDescription in doAnswer");
        }
        try {

            if (sdpRemoteFilter) {
                sd.sdp = sdpRemoteFilter(sd.sdp);
            }
            pc.setRemoteDescription(sd, invokeCreateAnswer, function(message) {
                self.showError(self.errCodes.INTERNAL_ERR, "set-remote-description: " + message);
            });
        } catch (srdError) {
            console.log("set remote description failed");
            if (self.debugPrinter) {
                self.debugPrinter("saw exception in setRemoteDescription");
            }
            self.showError(self.errCodes.INTERNAL_ERR, "setRemoteDescription failed: " + srdError.message);
        }
    }
    //
    // This function calls the users onStreamClosed handler, passing it the easyrtcid of the peer, the stream itself,
    // and the name of the stream.
    //
    function emitOnStreamClosed(easyrtcid, stream) {
        if (!peerConns[easyrtcid]) {
            return;
        }
        var streamName;
        var id;
        if (stream.hasOwnProperty("id")) {
            id = stream.id;
        }
        else {
            id = "default";
        }
        streamName = peerConns[easyrtcid].remoteStreamIdToName[id] || "default";
        if (peerConns[easyrtcid].liveRemoteStreams[streamName] &&
            self.onStreamClosed) {
            delete peerConns[easyrtcid].liveRemoteStreams[streamName];
            self.onStreamClosed(easyrtcid, stream, streamName);
        }
        delete peerConns[easyrtcid].remoteStreamIdToName[id];
    }

    var onRemoteHangup = function(caller) {
        delete offersPending[caller];
        if (self.debugPrinter) {
            self.debugPrinter("Saw onRemote hangup event");
        }
        if (peerConns[caller]) {
            peerConns[caller].cancelled = true;
            if (peerConns[caller].pc) {
                //
                // close any remote streams.
                //
                var remoteStreams = peerConns[caller].pc.getRemoteStreams();
                if (remoteStreams) {
                    var i;
                    for (i = 0; i < remoteStreams.length; i++) {
                        emitOnStreamClosed(caller, remoteStreams[i]);
                        try {
                            remoteStreams[i].stop();
                        } catch (err) {
                            console.error( err.toString() );
                        }

                    }
                }

                try {
                    peerConns[caller].pc.close();
                } catch (anyErrors) {
                }
            }
            else {
                if (self.callCancelled) {
                    self.callCancelled(caller, true);
                }
            }
            delete peerConns[caller];
            updateConfigurationInfo();
        }
        else {
            if (self.callCancelled) {
                self.callCancelled(caller, true);
            }
        }
    };
    var queuedMessages = {};
    function clearQueuedMessages(caller) {
        queuedMessages[caller] = {
            candidates: []
        };
    }
    //
    // checks to see if a particular peer is in any room at all.
    //
    function isPeerInAnyRoom(id) {
        var roomName;
        for (roomName in lastLoggedInList) {
            if (!lastLoggedInList.hasOwnProperty(roomName)) {
                continue;
            }
            if (lastLoggedInList[roomName][id]) {
                return true;
            }
        }
        return false;
    }

    /**
      * Checks to see if a particular peer is present in any room.
      * If it isn't, we assume it's logged out. 
      * @param easyrtcid the easyrtcId of the peer.
      */
    this.isPeerInAnyRoom = function(easyrtcId) {
         return isPeerInAnyRoom(easyrtcId);
    };

    //
    //
    //
    function processLostPeers(peersInRoom) {
        var id;
        //
        // check to see the person is still in at least one room. If not, we'll hangup
        // on them. This isn't the correct behavior, but it's the best we can do without
        // changes to the server.
        //
        for (id in peerConns) {
            if (peerConns.hasOwnProperty(id) &&
                    typeof peersInRoom[id] === 'undefined') {
                if (!isPeerInAnyRoom(id)) {
                    if (peerConns[id].pc || peerConns[id].isInitiator) {
                        onRemoteHangup(id);
                    }
                    delete offersPending[id];
                    delete acceptancePending[id];
                    clearQueuedMessages(id);
                }
            }
        }

        for (id in offersPending) {
            if (offersPending.hasOwnProperty(id) && !isPeerInAnyRoom(id)) {
                onRemoteHangup(id);
                clearQueuedMessages(id);
                delete offersPending[id];
                delete acceptancePending[id];
            }
        }

        for (id in acceptancePending) {
            if (acceptancePending.hasOwnProperty(id) && !isPeerInAnyRoom(id)) {
                onRemoteHangup(id);
                clearQueuedMessages(id);
                delete acceptancePending[id];
            }
        }

    }

    /**
     * The idea of aggregating timers is that there are events that convey state and these can fire more frequently
    * than desired. Aggregating timers allow a bunch of events to be collapsed into one by only firing the last
    * event.
     * @private
    */
    var aggregatingTimers = {};

    /**
     * This function sets a timeout for a function to be called with the feature that if another
     * invocation comes along within a particular interval (with the same key), the second invocation
     * replaces the first. To prevent a continuous stream of events from preventing a callback from ever
     * firing, we'll collapse no more than 20 events.
     * @param {String} key A key used to identify callbacks that should be aggregated.
     * @param {Function} callback The callback to invoke.
     * @param {Number} period The aggregating period in milliseconds.
     * @private
     */
    function addAggregatingTimer(key, callback, period) {
        if( !period) {
            period = 100; // 0.1 second
        }
        var counter = 0;
        if( aggregatingTimers[key]) {
            clearTimeout(aggregatingTimers[key].timer);
            counter = aggregatingTimers[key].counter;
        }
        if( counter > 20) {
            delete aggregatingTimers[key];
            callback();
        }
        else {
            aggregatingTimers[key] = {counter: counter +1};
            aggregatingTimers[key].timer = setTimeout(function () {
                delete aggregatingTimers[key];
                callback();
            }, period);
        }
    }

    //
    // this function gets called for each room when there is a room update.
    //
    function processOccupantList(roomName, occupantList) {
        var myInfo = null;
        self.reducedList = {};
        var id;
        for (id in occupantList) {
            if (occupantList.hasOwnProperty(id)) {
                if (id === self.myEasyrtcid) {
                    myInfo = occupantList[id];
                }
                else {
                    self.reducedList[id] = occupantList[id];
                }
            }
        }
        //
        // processLostPeers detects peers that have gone away and performs
        // house keeping accordingly.
        //
        processLostPeers(self.reducedList);
        //
        //
        //
        addAggregatingTimer("roomOccupants&" + roomName, function(){
            if (roomOccupantListener) {
                roomOccupantListener(roomName, self.reducedList, myInfo);
            }
            self.emitEvent("roomOccupants", {roomName:roomName, occupants:lastLoggedInList});
        }, 100);

    }

    function sendQueuedCandidates(peer, onSignalSuccess, onSignalFailure) {
        var i;
        for (i = 0; i < peerConns[peer].candidatesToSend.length; i++) {
            sendSignalling(
                    peer,
                    "candidate",
                    peerConns[peer].candidatesToSend[i],
                    onSignalSuccess,
                    onSignalFailure
                    );
        }
    }

    var onChannelMsg = function(msg, ackAcceptorFunc) {

        var targeting = {};
        if (ackAcceptorFunc) {
            ackAcceptorFunc(self.ackMessage);
        }
        if (msg.targetEasyrtcid) {
            targeting.targetEasyrtcid = msg.targetEasyrtcid;
        }
        if (msg.targetRoom) {
            targeting.targetRoom = msg.targetRoom;
        }
        if (msg.targetGroup) {
            targeting.targetGroup = msg.targetGroup;
        }
        if (msg.senderEasyrtcid) {
            self.receivePeerDistribute(msg.senderEasyrtcid, msg, targeting);
        }
        else {
            if (receiveServerCB) {
                receiveServerCB(msg.msgType, msg.msgData, targeting);
            }
            else {
                console.log("Unhandled server message " + JSON.stringify(msg));
            }
        }
    };
    var onChannelCmd = function(msg, ackAcceptorFn) {

        var caller = msg.senderEasyrtcid;
        var msgType = msg.msgType;
        var msgData = msg.msgData;
        var pc;
        if (self.debugPrinter) {
            self.debugPrinter('received message of type ' + msgType);
        }

        if (typeof queuedMessages[caller] === "undefined") {
            clearQueuedMessages(caller);
        }

        var processCandidateBody = function(caller, msgData) {
            var candidate = null;

            if( iceCandidateFilter ) {
               msgData = iceCandidateFilter(msgData, true);
               if( !msgData ) {
                  return;
               }
            } 


            candidate = new wRTCIceCandidate({
                sdpMLineIndex: msgData.label,
                candidate: msgData.candidate
            });

            pc = peerConns[caller].pc;

            function iceAddSuccess() {}
            function iceAddFailure(domError) {
                easyrtc.showError(self.errCodes.ICECANDIDATE_ERR, "bad ice candidate (" + domError.name + "): " + 
                    JSON.stringify(candidate));
            }
            pc.addIceCandidate(candidate, iceAddSuccess, iceAddFailure);

            if (msgData.candidate.indexOf("typ relay") > 0) {
                var ipAddress = msgData.candidate.match(/(udp|tcp) \d+ (\d+\.\d+\.\d+\.\d+)/i)[1];
                self._turnServers[ipAddress] = true;
            }
        };
        var flushCachedCandidates = function(caller) {
            var i;
            if (queuedMessages[caller]) {
                for (i = 0; i < queuedMessages[caller].candidates.length; i++) {
                    processCandidateBody(caller, queuedMessages[caller].candidates[i]);
                }
                delete queuedMessages[caller];
            }
        };
        var processOffer = function(caller, msgData) {

            var helper = function(wasAccepted, streamNames) {

                if (streamNames) {
                    if (typeof streamNames === "string") {
                        streamNames = [streamNames];
                    }
                    else if (streamNames.length === undefined) {
                        easyrtc.showError(self.errCodes.DEVELOPER_ERR, "accept callback passed invalid streamNames");
                        return;
                    }
                }
                if (self.debugPrinter) {
                    self.debugPrinter("offer accept=" + wasAccepted);
                }
                delete offersPending[caller];
                if (!self.supportsPeerConnections()) {
                    // callFailureCB(self.errCodes.CALL_ERR, self.getConstantString("noWebrtcSupport"));
                    console.error( self.errCodes.CALL_ERR );
                    return;
                }

                if (wasAccepted) {
                    doAnswer(caller, msgData, streamNames);
                    flushCachedCandidates(caller);
                }
                else {
                    sendSignalling(caller, "reject", null, null, null);
                    clearQueuedMessages(caller);
                }
            };
            //
            // There is a very rare case of two callers sending each other offers
            // before receiving the others offer. In such a case, the caller with the
            // greater valued easyrtcid will delete its pending call information and do a
            // simple answer to the other caller's offer.
            //
            if (acceptancePending[caller] && caller < self.myEasyrtcid) {
                delete acceptancePending[caller];
                if (queuedMessages[caller]) {
                    delete queuedMessages[caller];
                }
                if (peerConns[caller].wasAcceptedCB) {
                    peerConns[caller].wasAcceptedCB(true, caller);
                }
                delete peerConns[caller];
                helper(true);
                return;
            }

            offersPending[caller] = msgData;
            if (!self.acceptCheck) {
                helper(true);
            }
            else {
                self.acceptCheck(caller, helper);
            }
        };
        function processReject(caller) {
            delete acceptancePending[caller];
            if (queuedMessages[caller]) {
                delete queuedMessages[caller];
            }
            if (peerConns[caller]) {
                if (peerConns[caller].wasAcceptedCB) {
                    peerConns[caller].wasAcceptedCB(false, caller);
                }
                delete peerConns[caller];
            }
        }

        function processAnswer(caller, msgData) {



            delete acceptancePending[caller];

            //
            // if we've discarded the peer connection, ignore the answer.
            //
            if (!peerConns[caller]) {
                return;
            }
            peerConns[caller].connectionAccepted = true;



            if (peerConns[caller].wasAcceptedCB) {
                peerConns[caller].wasAcceptedCB(true, caller);
            }

            var onSignalSuccess = function() {

            };
            var onSignalFailure = function(errorCode, errorText) {
                if (peerConns[caller]) {
                    delete peerConns[caller];
                }
                self.showError(errorCode, errorText);
            };
            // peerConns[caller].startedAV = true;
            sendQueuedCandidates(caller, onSignalSuccess, onSignalFailure);
            pc = peerConns[caller].pc;
            var sd = null;

            sd = new wRTCSessionDescription(msgData);

            if (!sd) {
                throw "Could not create the RTCSessionDescription";
            }

            if (self.debugPrinter) {
                self.debugPrinter("about to call initiating setRemoteDescription");
            }
            try {
                if (sdpRemoteFilter) {
                    sd.sdp = sdpRemoteFilter(sd.sdp);
                }
                pc.setRemoteDescription(sd, function() {
                    if (pc.connectDataConnection) {
                        if (self.debugPrinter) {
                            self.debugPrinter("calling connectDataConnection(5001,5002)");
                        }
                        pc.connectDataConnection(5001, 5002); // these are like ids for data channels
                    }
                }, function(message){
                     console.log("setRemoteDescription failed ", message);
                 });
            } catch (smdException) {
                console.log("setRemoteDescription failed ", smdException);
            }
            flushCachedCandidates(caller);
        }

        function processCandidateQueue(caller, msgData) {

            if (peerConns[caller] && peerConns[caller].pc) {
                processCandidateBody(caller, msgData);
            }
            else {
                if (!peerConns[caller]) {
                    queuedMessages[caller] = {
                        candidates: []
                    };
                }
                queuedMessages[caller].candidates.push(msgData);
            }
        }

        switch (msgType) {
            case "sessionData":
                processSessionData(msgData.sessionData);
                break;
            case "roomData":
                processRoomData(msgData.roomData);
                break;
            case "iceConfig":
                processIceConfig(msgData.iceConfig);
                break;
            case "forwardToUrl":
                if (msgData.newWindow) {
                    window.open(msgData.forwardToUrl.url);
                }
                else {
                    window.location.href = msgData.forwardToUrl.url;
                }
                break;
            case "offer":
                processOffer(caller, msgData);
                break;
            case "reject":
                processReject(caller);
                break;
            case "answer":
                processAnswer(caller, msgData);
                break;
            case "candidate":
                processCandidateQueue(caller, msgData);
                break;
            case "hangup":
                onRemoteHangup(caller);
                clearQueuedMessages(caller);
                break;
            case "error":
                self.showError(msg.errorCode, msg.errorText);
                break;
            default:
                console.error("received unknown message type from server, msgType is " + msgType);
                return;
        }

        if (ackAcceptorFn) {
            ackAcceptorFn(self.ackMessage);
        }
    };
    function connectToWSServer(successCallback, errorCallback) {
        var i;
        if (preallocatedSocketIo) {
            self.webSocket = preallocatedSocketIo;
        }
        else if (!self.webSocket) {
            try {
               self.webSocket = io.connect(serverPath, connectionOptions);
            } catch(socketErr) {
               errorCallback( self.errCodes.SYSTEM_ERROR, 
                     socketErr.toString());
               return;
            }
            if (!self.webSocket) {
                throw "io.connect failed";
            }
        }
        else {
            for (i in self.websocketListeners) {
                if (!self.websocketListeners.hasOwnProperty(i)) {
                    continue;
                }
                self.webSocket.removeEventListener(self.websocketListeners[i].event,
                        self.websocketListeners[i].handler);
            }
        }
        self.websocketListeners = [];
        function addSocketListener(event, handler) {
            self.webSocket.on(event, handler);
            self.websocketListeners.push({event: event, handler: handler});
        }

        addSocketListener("close", function(/*event*/) {
            console.log("the web socket closed");
        });
        addSocketListener('error', function(/*event*/) {
            function handleErrorEvent() {
                if (self.myEasyrtcid) {
                    //
                    // socket.io version 1 got rid of the socket member, moving everything up one level.
                    //
                    if (self.webSocket.connected || (self.webSocket.socket && self.webSocket.socket.connected)) {
                        self.showError(self.errCodes.SIGNAL_ERROR, self.getConstantString("miscSignalError"));
                    }
                    else {
                        /* socket server went down. this will generate a 'disconnect' event as well, so skip this event */
                        errorCallback(self.errCodes.CONNECT_ERR, self.getConstantString("noServer"));
                    }
                }
                else {
                    errorCallback(self.errCodes.CONNECT_ERR, self.getConstantString("noServer"));
                }
            }
            handleErrorEvent();
        });
        function connectHandler(/*event*/) {
            self.webSocketConnected = true;
            if (!self.webSocket) {
                self.showError(self.errCodes.CONNECT_ERR, self.getConstantString("badsocket"));
            }

            if (self.debugPrinter) {
                self.debugPrinter("saw socketserver onconnect event");
            }
            if (self.webSocketConnected) {
                sendAuthenticate(successCallback, errorCallback);
            }
            else {
                errorCallback(self.errCodes.SIGNAL_ERROR, self.getConstantString("icf"));
            }
        }
        if (preallocatedSocketIo && preallocatedSocketIo.socket.connected) {
            connectHandler(null);
        } else {
            addSocketListener("connect", connectHandler);
        }
        addSocketListener("easyrtcMsg", onChannelMsg);
        addSocketListener("easyrtcCmd", onChannelCmd);
        addSocketListener("disconnect", function(/* code, reason, wasClean */) {
            self.webSocketConnected = false;
            updateConfigurationInfo = function() {
            }; // dummy update function
            oldConfig = {};
            disconnectBody();
            if (self.disconnectListener) {
                self.disconnectListener();
            }
        });
    }


    function buildDeltaRecord(added, deleted/*, modified*/) {
        function objectNotEmpty(obj) {
            var i;
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    return true;
                }
            }
            return false;
        }

        var result = {};
        if (objectNotEmpty(added)) {
            result.added = added;
        }

        if (objectNotEmpty(deleted)) {
            result.deleted = deleted;
        }

        if (objectNotEmpty(result)) {
            return result;
        }
        else {
            return null;
        }
    }

    function findDeltas(oldVersion, newVersion) {
        var i;
        var added = {}, deleted = {};
        var subPart;
        for (i in newVersion) {
            if (newVersion.hasOwnProperty(i)) {
                if (oldVersion === null || typeof oldVersion[i] === 'undefined') {
                    added[i] = newVersion[i];
                }
                else if (typeof newVersion[i] === 'object') {
                    subPart = findDeltas(oldVersion[i], newVersion[i]);
                    if (subPart !== null) {
                        added[i] = newVersion[i];
                    }
                }
                else if (newVersion[i] !== oldVersion[i]) {
                    added[i] = newVersion[i];
                }
            }
        }
        for (i in oldVersion) {
            if (!newVersion.hasOwnProperty(i)) {
                // do nothing
            }
            else if (typeof newVersion[i] === 'undefined') {
                deleted = oldVersion[i];
            }
        }

        return buildDeltaRecord(added, deleted);
    }

//
// this function collects configuration info that will be sent to the server.
// It returns that information, leaving it the responsibility of the caller to
// do the actual sending.
//
    function collectConfigurationInfo(/* forAuthentication */) {
        var p2pList = {};
        var i;
        for (i in peerConns) {
            if (!peerConns.hasOwnProperty(i)) {
                continue;
            }
            p2pList[i] = {
                connectTime: peerConns[i].connectTime,
                isInitiator: !!peerConns[i].isInitiator
            };
        }

        var newConfig = {
            userSettings: {
                sharingAudio: !!haveAudioVideo.audio,
                sharingVideo: !!haveAudioVideo.video,
                sharingData: !!dataEnabled,
                nativeVideoWidth: self.nativeVideoWidth,
                nativeVideoHeight: self.nativeVideoHeight,
                windowWidth: window.innerWidth,
                windowHeight: window.innerHeight,
                screenWidth: window.screen.width,
                screenHeight: window.screen.height,
                cookieEnabled: navigator.cookieEnabled,
                os: navigator.oscpu,
                language: navigator.language
            }
        };
        if (!isEmptyObj(p2pList)) {
            newConfig.p2pList = p2pList;
        }
        return newConfig;
    }
    function updateConfiguration() {

        var newConfig = collectConfigurationInfo(false);
        //
        // we need to give the getStats calls a chance to fish out the data.
        // The longest I've seen it take is 5 milliseconds so 100 should be overkill.
        //
        var sendDeltas = function() {
            var alteredData = findDeltas(oldConfig, newConfig);
            //
            // send all the configuration information that changes during the session
            //
            if (alteredData) {
                if (self.debugPrinter) {
                    self.debugPrinter("cfg=" + JSON.stringify(alteredData.added));
                }
                if (self.webSocket) {
                    sendSignalling(null, "setUserCfg", {setUserCfg: alteredData.added}, null, null);
                }
            }
            oldConfig = newConfig;
        };
        if (oldConfig === {}) {
            sendDeltas();
        }
        else {
            setTimeout(sendDeltas, 100);
        }
    }

    updateConfigurationInfo = function() {
        updateConfiguration();
    };
    /**
     * Sets the presence state on the server.
     * @param {String} state - one of 'away','chat','dnd','xa'
     * @param {String} statusText - User configurable status string. May be length limited.
     * @example   easyrtc.updatePresence('dnd', 'sleeping');
     */
    this.updatePresence = function(state, statusText) {
        self.presenceShow = state;
        self.presenceStatus = statusText;
        if (self.webSocketConnected) {
            sendSignalling(null, 'setPresence', {setPresence: {'show': state, 'status': statusText}}, null);
        }
    };
    /**
     * Fetch the collection of session fields as a map. The map has the structure:
     *  {key1: {"fieldName": key1, "fieldValue": value1}, ...,
     *   key2: {"fieldName": key2, "fieldValue": value2}
     *  }
     * @returns {Object}
     */
    this.getSessionFields = function() {
        return sessionFields;
    };
    /**
     * Fetch the value of a session field by name.
     * @param {String} name - name of the session field to be fetched.
     * @returns the field value (which can be anything). Returns undefined if the field does not exist.
     */
    this.getSessionField = function(name) {
        if (sessionFields[name]) {
            return sessionFields[name].fieldValue;
        }
        else {
            return undefined;
        }
    };
    function processSessionData(sessionData) {
        if (sessionData) {
            if (sessionData.easyrtcsid) {
                self.easyrtcsid = sessionData.easyrtcsid;
            }
            if (sessionData.field) {
                sessionFields = sessionData.field;
            }
        }
    }


    function processRoomData(roomData) {
        self.roomData = roomData;
        var roomName;
        var stuffToRemove;
        var stuffToAdd;
        var id, removeId;
        for (roomName in self.roomData) {
            if (!self.roomData.hasOwnProperty(roomName)) {
                continue;
            }
            if (roomData[roomName].roomStatus === "join") {
                if (!(self.roomJoin[roomName])) {
                    self.roomJoin[roomName] = roomData[roomName];
                }
                var mediaIds = buildMediaIds();
                if (mediaIds !== {}) {
                    self.setRoomApiField(roomName, "mediaIds", mediaIds);
                }
            }
            else if (roomData[roomName].roomStatus === "leave") {
                if (self.roomEntryListener) {
                    self.roomEntryListener(false, roomName);
                }
                delete self.roomJoin[roomName];
                delete lastLoggedInList[roomName];
                continue;
            }

            if (roomData[roomName].clientList) {
                lastLoggedInList[roomName] = roomData[roomName].clientList;
            }
            else if (roomData[roomName].clientListDelta) {
                stuffToAdd = roomData[roomName].clientListDelta.updateClient;
                if (stuffToAdd) {
                    for (id in stuffToAdd) {
                        if (!stuffToAdd.hasOwnProperty(id)) {
                            continue;
                        }
                        if (!lastLoggedInList[roomName]) {
                            lastLoggedInList[roomName] = [];
                        }
                        lastLoggedInList[roomName][id] = stuffToAdd[id];
                    }
                }
                stuffToRemove = roomData[roomName].clientListDelta.removeClient;
                if (stuffToRemove && lastLoggedInList[roomName]) {
                    for (removeId in stuffToRemove) {
                        if (stuffToRemove.hasOwnProperty(removeId)) {
                            delete lastLoggedInList[roomName][removeId];
                        }
                    }
                }
            }
            if (self.roomJoin[roomName] && roomData[roomName].field) {
                fields.rooms[roomName] = roomData[roomName].field;
            }
            if (roomData[roomName].roomStatus === "join") {
                if (self.roomEntryListener) {
                    self.roomEntryListener(true, roomName);
                }
            }
            processOccupantList(roomName, lastLoggedInList[roomName]);
        }
        self.emitEvent("roomOccupant", lastLoggedInList);
    }

    /**
     * Returns an array of easyrtcid's of peers in a particular room.
     * @param roomName
     * @returns {Array} of easyrtcids or null if the client is not in the room.
     * @example
     *     var occupants = easyrtc.getRoomOccupants("default");
     *     var i;
     *     for( i = 0; i < occupants.length; i++ ) {
     *         console.log( occupants[i] + " is in the room");
     *     }
     */
    this.getRoomOccupantsAsArray = function(roomName) {
        if (!lastLoggedInList[roomName]) {
            return null;
        }
        else {
            return Object.keys(lastLoggedInList[roomName]);
        }
    }

    /**
     * Returns a map of easyrtcid's of peers in a particular room. You should only test elements in the map to see if they are
     * null; their actual values are not guaranteed to be the same in different releases.
     * @param roomName
     * @returns {Object} of easyrtcids or null if the client is not in the room.
     * @example
     *      if( easyrtc.getRoomOccupantsAsMap("default")[some_easyrtcid]) {
     *          console.log("yep, " + some_easyrtcid + " is in the room");
     *      }
     */
    this.getRoomOccupantsAsMap = function(roomName) {
        return lastLoggedInList[roomName];
    }

    /**
     * Returns true if the ipAddress parameter was the address of a turn server. This is done by checking against information
     * collected during peer to peer calls. Don't expect it to work before the first call, or to identify turn servers that aren't
     * in the ice config.
     * @param ipAddress
     * @returns {boolean} true if ip address is known to be that of a turn server, false otherwise.
     */
    this.isTurnServer = function(ipAddress) {
        return !!self._turnServers[ipAddress];
    };
    function processIceConfig(iceConfig) {
        pc_config = {iceServers: []};
        self._turnServers = {};
        var i;
        var item, fixedItem, ipAddress;
        if (!createIceServer) {
            return;
        }
        for (i = 0; i < iceConfig.iceServers.length; i++) {
            item = iceConfig.iceServers[i];
            if (item.url.indexOf('turn:') === 0) {
                if (item.username) {
                    fixedItem = createIceServer(item.url, item.username, item.credential);
                }
                else {
                    self.showError("Developer error", "Iceserver entry doesn't have a username: " + JSON.stringify(item));
                }
                ipAddress = item.url.split(/[@:&]/g)[1];
                self._turnServers[ipAddress] = true;
            }
            else { // is stun server entry
                fixedItem = item;
            }
            if (fixedItem) {
                pc_config.iceServers.push(fixedItem);
            }
        }
        prepareIceServers( pc_config );
    }

    /**
     * Request fresh ice config information from the server.
     * This should be done periodically by long running applications.
     * @param {Function} callback is called with a value of true on success, false on failure.
     */
    this.getFreshIceConfig = function(callback) {
        var dataToShip = {
            msgType: "getIceConfig",
            msgData: {}
        };
        if (!callback) {
            callback = function() {
            };
        }
        self.webSocket.json.emit("easyrtcCmd", dataToShip,
                function(ackMsg) {
                    if (ackMsg.msgType === "iceConfig") {
                        processIceConfig(ackMsg.msgData.iceConfig);
                        callback(true);
                    }
                    else {
                        self.showError(ackMsg.msgData.errorCode, ackMsg.msgData.errorText);
                        callback(false);
                    }
                }
        );
    };
    function processToken(msg) {
        if (self.debugPrinter) {
            self.debugPrinter("entered process token");
        }
        var msgData = msg.msgData;
        if (msgData.easyrtcid) {
            self.myEasyrtcid = msgData.easyrtcid;
        }
        if (msgData.field) {
            fields.connection = msgData.field;
        }
        if (msgData.iceConfig) {
            processIceConfig(msgData.iceConfig);
        }

        if (msgData.sessionData) {
            processSessionData(msgData.sessionData);
        }

        if (msgData.roomData) {
            processRoomData(msgData.roomData);
        }

        if (msgData.application.field) {
            fields.application = msgData.application.field;
        }

    }

    function sendAuthenticate(successCallback, errorCallback) {
        //
        // find our easyrtcsid
        //  
        var cookies, target, i;
        var easyrtcsid = null;
        if (self.cookieId && document.cookie) {
            cookies = document.cookie.split(/[; ]/g);
            target = self.cookieId + "=";
            for (i = 0; i < cookies.length; i++) {
                if (cookies[i].indexOf(target) === 0) {
                    easyrtcsid = cookies[i].substring(target.length);
                }
            }
        }

        if (!self.roomJoin) {
            self.roomJoin = {};
        }

        var msgData = {
            apiVersion: self.apiVersion,
            applicationName: self.applicationName,
            setUserCfg: collectConfigurationInfo(true)
        };
        if (self.presenceShow) {
            msgData.setPresence = {show: self.presenceShow, status: self.presenceStatus};
        }
        if (self.username) {
            msgData.username = self.username;
        }
        if (self.roomJoin && !isEmptyObj(self.roomJoin)) {
            msgData.roomJoin = self.roomJoin;
        }
        if (easyrtcsid) {
            msgData.easyrtcsid = easyrtcsid;
        }
        if (credential) {
            msgData.credential = credential;
        }

        self.webSocket.json.emit("easyrtcAuth",
                {msgType: "authenticate",
                    msgData: msgData
                },
        function(msg) {
            var room;
            if (msg.msgType === "error") {
                errorCallback(msg.msgData.errorCode, msg.msgData.errorText);
                self.roomJoin = {};
            }
            else {
                processToken(msg);
                if (self._roomApiFields) {
                    for (room in self._roomApiFields) {
                        if (self._roomApiFields.hasOwnProperty(room)) {
                            _enqueueSendRoomApi(room, self._roomApiFields[room]);
                        }
                    }
                }

                if (successCallback) {
                    successCallback(self.myEasyrtcid);
                }
            }
        }
        );
    }

    /** Get a list of the rooms you are in. You must be connected to call this function.
     * @returns {Object} A map whose keys are the room names
     */
    this.getRoomsJoined = function() {
        var roomsIn = {};
        var key;
        for (key in self.roomJoin) {
            if (self.roomJoin.hasOwnProperty(key)) {
                roomsIn[key] = true;
            }
        }
        return roomsIn;
    };
    /** Get server defined fields associated with a particular room. Only valid
     * after a connection has been made.
     * @param {String} roomName - the name of the room you want the fields for.
     * @returns {Object} A dictionary containing entries of the form {key:{'fieldName':key, 'fieldValue':value1}} or undefined
     * if you are not connected to the room.
     */
    this.getRoomFields = function(roomName) {
        if (!fields || !fields.rooms || !fields.rooms[roomName]){
            return undefined;
        }
        return fields.rooms[roomName];
    };
    /** Get server defined fields associated with the current application. Only valid
     * after a connection has been made.
     * @returns {Object} A dictionary containing entries of the form {key:{'fieldName':key, 'fieldValue':value1}}
     */
    this.getApplicationFields = function() {
        return fields.application;
    };
    /** Get server defined fields associated with the connection. Only valid
     * after a connection has been made.
     * @returns {Object} A dictionary containing entries of the form {key:{'fieldName':key, 'fieldValue':value1}}
     */
    this.getConnectionFields = function() {
        return fields.connection;
    };
// this flag controls whether the easyApp routine adds close buttons to the caller
// video objects

    /** @private */
    var autoAddCloseButtons = true;
    /** By default, the easyApp routine sticks a "close" button on top of each caller
     * video object that it manages. Call this function(before calling easyApp) to disable that particular feature.
     * @example
     *    easyrtc.dontAddCloseButtons();
     */
    this.dontAddCloseButtons = function() {
        autoAddCloseButtons = false;
    };
    /**
     * Validates that the video ids correspond to dom objects.
     * @param {String} monitorVideoId
     * @param {Array} videoIds
     * @returns {Boolean}
     * @private
     */
    function _validateVideoIds(monitorVideoId, videoIds) {
        var i;
        // verify that video ids were not typos.
        if (monitorVideoId && !document.getElementById(monitorVideoId)) {
            self.showError(self.errCodes.DEVELOPER_ERR, "The monitor video id passed to easyApp was bad, saw " + monitorVideoId);
            return false;
        }

        for (i in videoIds) {
            if (!videoIds.hasOwnProperty(i)) {
                continue;
            }
            var name = videoIds[i];
            if (!document.getElementById(name)) {
                self.showError(self.errCodes.DEVELOPER_ERR, "The caller video id '" + name + "' passed to easyApp was bad.");
                return false;
            }
        }
        return true;
    };
    /**
     * This is a helper function for the easyApp method. It manages the assignment of video streams
     * to video objects. It assumes
     * @param {String} monitorVideoId is the id of the mirror video tag.
     * @param {Array} videoIds is an array of ids of the caller video tags.
     * @private
     */
    function easyAppBody(monitorVideoId, videoIds) {
        var numPEOPLE = videoIds.length;
        var videoIdsP = videoIds;
        var refreshPane = 0;
        var onCall = null, onHangup = null;

        if (!videoIdsP) {
            videoIdsP = [];
        }

        easyrtc.addEventListener("roomOccupants", 
            function(eventName, eventData) {
                var i;
                for (i = 0; i < numPEOPLE; i++) {
                    var video = getIthVideo(i);
                    if (!videoIsFree(video)) {
		        if( !easyrtc.isPeerInAnyRoom(video.dataset.caller)){
                           if( onHangup ) {
                               onHangup(i, easyrtc.dataset.caller);
                           }
                           easyrtc.dataset.caller = null;
                        }
                    }
                }
            }
        );

        function videoIsFree(obj) {
            return (obj.dataset.caller === "" || obj.dataset.caller === null || obj.dataset.caller === undefined);
        }

        if (!_validateVideoIds(monitorVideoId, videoIdsP)) {
            throw "bad video element id";
        }

        if (monitorVideoId) {
            document.getElementById(monitorVideoId).muted = "muted";
        }

        /** Sets an event handler that gets called when an incoming MediaStream is assigned 
         * to a video object. The name is poorly chosen and reflects a simpler era when you could
         * only have one media stream per peer connection.
         * @param {Function} cb has the signature function(easyrtcid, slot){}
         * @example
         *   easyrtc.setOnCall( function(easyrtcid, slot){
         *      console.log("call with " + easyrtcid + "established");
         *   });
         */
        self.setOnCall = function(cb) {
            onCall = cb;
        };
        /** Sets an event handler that gets called when a call is ended.
         * it's only purpose (so far) is to support transitions on video elements.
         x     * this function is only defined after easyrtc.easyApp is called.
         * The slot is parameter is the index into the array of video ids.
         * Note: if you call easyrtc.getConnectionCount() from inside your callback
         * it's count will reflect the number of connections before the hangup started.
         * @param {Function} cb has the signature function(easyrtcid, slot){}
         * @example
         *   easyrtc.setOnHangup( function(easyrtcid, slot){
         *      console.log("call with " + easyrtcid + "ended");
         *   });
         */
        self.setOnHangup = function(cb) {
            onHangup = cb;
        };

        function getIthVideo(i) {
            if (videoIdsP[i]) {
                return document.getElementById(videoIdsP[i]);
            }
            else {
                return null;
            }
        }


        self.getIthCaller = function(i) {
            if (i < 0 || i > videoIdsP.length) {
                return null;
            }
            var vid = getIthVideo(i);
            return vid.dataset.caller;
        };

        self.getSlotOfCaller = function(easyrtcid) {
            var i;
            for (i = 0; i < numPEOPLE; i++) {
                if (self.getIthCaller(i) === easyrtcid) {
                    return i;
                }
            }
            return -1; // caller not connected
        };
        function hideVideo(video) {
            self.setVideoObjectSrc(video, "");
            video.style.visibility = "hidden";
        }

        self.setOnStreamClosed(function(caller) {
            var i;
            for (i = 0; i < numPEOPLE; i++) {
                var video = getIthVideo(i);
                if (video.dataset.caller === caller) {
                    hideVideo(video);
                    video.dataset.caller = "";
                    if (onHangup) {
                        onHangup(caller, i);
                    }
                }
            }
        });
        //
        // Only accept incoming calls if we have a free video object to display
        // them in.
        //
        self.setAcceptChecker(function(caller, helper) {
            var i;
            for (i = 0; i < numPEOPLE; i++) {
                var video = getIthVideo(i);
                if (videoIsFree(video)) {
                    helper(true);
                    return;
                }
            }
            helper(false);
        });
        self.setStreamAcceptor(function(caller, stream) {
            var i;
            if (self.debugPrinter) {
                self.debugPrinter("stream acceptor called");
            }
            function showVideo(video, stream) {
                self.setVideoObjectSrc(video, stream);
                if (video.style.visibility) {
                    video.style.visibility = 'visible';
                }
            }

            var video;
            if (refreshPane && videoIsFree(refreshPane)) {
                showVideo(refreshPane, stream);
                if (onCall) {
                    onCall(caller, refreshPane);
                }
                refreshPane = null;
                return;
            }
            for (i = 0; i < numPEOPLE; i++) {
                video = getIthVideo(i);
                if (video.dataset.caller === caller) {
                    showVideo(video, stream);
                    if (onCall) {
                        onCall(caller, i);
                    }
                    return;
                }
            }

            for (i = 0; i < numPEOPLE; i++) {
                video = getIthVideo(i);
                if (!video.dataset.caller || videoIsFree(video)) {
                    video.dataset.caller = caller;
                    if (onCall) {
                        onCall(caller, i);
                    }
                    showVideo(video, stream);
                    return;
                }
            }
//
// no empty slots, so drop whatever caller we have in the first slot and use that one.
//
            video = getIthVideo(0);
            if (video) {
                self.hangup(video.dataset.caller);
                showVideo(video, stream);
                if (onCall) {
                    onCall(caller, 0);
                }
            }
            video.dataset.caller = caller;
        });
        (function() {
            var addControls, parentDiv, closeButton, i;
            if (autoAddCloseButtons) {

                addControls = function(video) {
                    parentDiv = video.parentNode;
                    video.dataset.caller = "";
                    closeButton = document.createElement("div");
                    closeButton.className = "easyrtc_closeButton";
                    closeButton.onclick = function() {
                        if (video.dataset.caller) {
                            self.hangup(video.dataset.caller);
                            hideVideo(video);
                            video.dataset.caller = "";
                        }
                    };
                    parentDiv.appendChild(closeButton);
                };
                for (i = 0; i < numPEOPLE; i++) {
                    addControls(getIthVideo(i));
                }
            }
        })();
        var monitorVideo = null;
        if (videoEnabled && monitorVideoId !== null) {
            monitorVideo = document.getElementById(monitorVideoId);
            if (!monitorVideo) {
                console.error("Programmer error: no object called " + monitorVideoId);
                return;
            }
            monitorVideo.muted = "muted";
            monitorVideo.defaultMuted = true;
        }


    }
    /**
     * Provides a layer on top of the easyrtc.initMediaSource and easyrtc.connect, assign the local media stream to
     * the video object identified by monitorVideoId, assign remote video streams to
     * the video objects identified by videoIds, and then call onReady. One of it's
     * side effects is to add hangup buttons to the remote video objects, buttons
     * that only appear when you hover over them with the mouse cursor. This method will also add the
     * easyrtcMirror class to the monitor video object so that it behaves like a mirror.
     *  @param {String} applicationName - name of the application.
     *  @param {String} monitorVideoId - the id of the video object used for monitoring the local stream.
     *  @param {Array} videoIds - an array of video object ids (strings)
     *  @param {Function} onReady - a callback function used on success. It is called with the easyrtcId this peer is known to the server as.
     *  @param {Function} onFailure - a callback function used on failure (failed to get local media or a connection of the signaling server).
     *  @example
     *     easyrtc.easyApp('multiChat', 'selfVideo', ['remote1', 'remote2', 'remote3'],
     *              function(easyrtcId){
     *                  console.log("successfully connected, I am " + easyrtcId);
     *              },
     *              function(errorCode, errorText){
     *                  console.log(errorText);
     *              );
     */
    this.easyApp = function(applicationName, monitorVideoId, videoIds, onReady, onFailure) {
        var gotMediaCallback = null,
                gotConnectionCallback = null;
        easyAppBody(monitorVideoId, videoIds);
        self.setGotMedia = function(gotMediaCB) {
            gotMediaCallback = gotMediaCB;
        };
        /** Sets an event handler that gets called when a connection to the signaling
         * server has or has not been made. Can only be called after calling easyrtc.easyApp.
         * @param {Function} gotConnectionCB has the signature (gotConnection, errorText)
         * @example
         *    easyrtc.setGotConnection( function(gotConnection, errorText){
         *        if( gotConnection ){
         *            console.log("Successfully connected to signaling server");
         *        }
         *        else{
         *            console.log("Failed to connect to signaling server because: " + errorText);
         *        }
         *    });
         */
        self.setGotConnection = function(gotConnectionCB) {
            gotConnectionCallback = gotConnectionCB;
        };
        var nextInitializationStep;
        nextInitializationStep = function(/* token */) {
            if (gotConnectionCallback) {
                gotConnectionCallback(true, "");
            }
            onReady(self.myEasyrtcid);
        };
        function postGetUserMedia() {
            if (gotMediaCallback) {
                gotMediaCallback(true, null);
            }
            if( null !== monitorVideoId ) {
                self.setVideoObjectSrc( document.getElementById( monitorVideoId ), self.getLocalStream() );
            }
            function connectError(errorCode, errorText) {
                if (gotConnectionCallback) {
                    gotConnectionCallback(false, errorText);
                }
                else if (onFailure) {
                    onFailure(self.errCodes.CONNECT_ERR, errorText);
                }
                else {
                    self.showError(self.errCodes.CONNECT_ERR, errorText);
                }
            }

            self.connect(applicationName, nextInitializationStep, connectError);
        }

        var stream = getLocalMediaStreamByName(null);
        if (stream) {
            postGetUserMedia();
        }
        else {
            self.initMediaSource(
                    postGetUserMedia,
                    function(errorCode, errorText) {
                        if (gotMediaCallback) {
                            gotMediaCallback(false, errorText);
                        }
                        else if (onFailure) {
                            onFailure(self.errCodes.MEDIA_ERR, errorText);
                        }
                        else {
                            self.showError(self.errCodes.MEDIA_ERR, errorText);
                        }
                    },
                    null // default stream
                    );
        }
    };
    /**
     *
     * @deprecated now called easyrtc.easyApp.
     */
    this.initManaged = this.easyApp;
    var preallocatedSocketIo = null;
    /**
     * Supply a socket.io connection that will be used instead of allocating a new socket.
     * The expected usage is that you allocate a websocket, assign options to it, call
     * easyrtc.useThisSocketConnection, followed by easyrtc.connect or easyrtc.easyApp. Easyrtc will not attempt to
     * close sockets that were supplied with easyrtc.useThisSocketConnection.
     * @param {Object} alreadyAllocatedSocketIo A value allocated with the connect method of socket.io.
     */
    this.useThisSocketConnection = function(alreadyAllocatedSocketIo) {
        preallocatedSocketIo = alreadyAllocatedSocketIo;
    }
    /**
     * Connect to the easyrtc signaling server.
     * @param applicationName
     * @param successCallback
     * @param errorCallback
     */
    this.connect = function(applicationName, successCallback, errorCallback) {

        if (!window.io) {
            self.showError("Developer error", "Your HTML has not included the socket.io.js library");
        }

        if (!preallocatedSocketIo && self.webSocket) {
            console.error("Developer error: attempt to connect when already connected to socket server");
            return;
        }
        pc_config = {};
        closedChannel = null;
        oldConfig = {}; // used internally by updateConfiguration
        queuedMessages = {};
        self.applicationName = applicationName;
        fields = {
            rooms: {},
            application: {},
            connection: {}
        };
        if (self.debugPrinter) {
            self.debugPrinter("attempt to connect to WebRTC signalling server with application name=" + applicationName);
        }

        if( null === errorCallback ) {
            errorCallback = function( errorCode, errorText ) {
                console.error( "easyrtc.connect: " + errorText );
            };
}

        connectToWSServer(successCallback, errorCallback);
    };
};
window.easyrtc = new Easyrtc();

;/** @class
 *@version 1.0.13
 *<p>
 * Provides support file and data transfer support to easyrtc.
 * </p>
 *<p>
 *copyright Copyright (c) 2014, Priologic Software Inc.
 *All rights reserved.</p>
 *
 *<p>
 *Redistribution and use in source and binary forms, with or without
 *modification, are permitted provided that the following conditions are met:
 *</p>
 * <ul>
 *   <li> Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer. </li>
 *   <li> Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution. </li>
 *</ul>
 *<p>
 *THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 *LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 *CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *POSSIBILITY OF SUCH DAMAGE.
 *</p>
 */


var easyrtc_ft = {};

/**
 * Establish an area as a drag-n-drop drop site for files.
 * @param {DOMString} droptargetName - the id of the drag-and-drop site or the actual DOM object.
 * @param {Function} filesHandler - function that accepts an array of File's.
 */
easyrtc_ft.buildDragNDropRegion = function(droptargetName, filesHandler) {
    var droptarget;
    if (typeof droptargetName === 'string') {
        droptarget = document.getElementById(droptargetName);
        if (!droptarget) {
            alert("Developer error: attempt to call BuildFileSender on unknown object " + droptargetName);
            throw("unknown object " + droptargetName);
        }
    }
    else {
        droptarget = droptargetName;
    }


    function ignore(e) {
        e.stopPropagation();
        e.preventDefault();
        return false;
    }

    function drageventcancel(e) {
        if (e.preventDefault)
            e.preventDefault(); // required by FF + Safari
        e.dataTransfer.dropEffect = 'copy'; // tells the browser what drop effect is allowed here
        return false; // required by IE
    }

    function dropHandler(e) {
        removeClass(droptarget, dropCueClass);
        var dt = e.dataTransfer;
        var files = dt.files;
        if (dt.files.length > 0) {
            try {
                filesHandler(files);
            } catch (errorEvent) {
                console.log("dragndrop errorEvent", errorEvent);
            }
        }
        return ignore(e);
    }


    var dropCueClass = "easyrtcfiledrop";

    function dragEnterHandler(e) {
        addClass(droptarget, dropCueClass);
        return drageventcancel(e);
    }


    function dragLeaveHandler(e) {
        removeClass(droptarget, dropCueClass);
        return drageventcancel(e);
    }

    var addEvent = (function() {
        if (document.addEventListener) {
            return function(el, type, fn) {
                if (el && el.nodeName || el === window) {
                    el.addEventListener(type, fn, false);
                } else if (el && el.length) {
                    for (var i = 0; i < el.length; i++) {
                        addEvent(el[i], type, fn);
                    }
                }
            };
        } else {
            return function(el, type, fn) {
                if (el && el.nodeName || el === window) {
                    el.attachEvent('on' + type, function() {
                        return fn.call(el, window.event);
                    });
                } else if (el && el.length) {
                    for (var i = 0; i < el.length; i++) {
                        addEvent(el[i], type, fn);
                    }
                }
            };
        }
    })();

    droptarget.ondrop = dropHandler;
    droptarget.ondragenter = dragEnterHandler;
    droptarget.ondragleave = dragLeaveHandler;
    droptarget.ondragover = drageventcancel;

    function addClass(target, classname) {
        if (target.className) {
            if (target.className.indexOf(classname, 0) >= 0) {
                return;
            }
            else {
                target.className = target.className + " " + classname;
            }
        }
        else {
            target.className = classname;
        }
        target.className = target.className.replace("  ", " ");
    }

    function removeClass(target, classname) {
        if (!target.className) {
            return;
        }
        target.className = target.className.replace(classname, "").replace("  ", " ");
    }
};

/**
 * Builds a function that can be used to send a group of files to a peer.
 * @param {String} destUser easyrtcid of the person being sent to.
 * @param {Function} progressListener - if provided, is called with the following objects:
 *    {status:"waiting"}  // once a file offer has been sent but not accepted or rejected yet
 *    {status:"started_file", name: filename}
 *    {status:"working", name:filename, position:position_in_file, size:size_of_current_file, numFiles:number_of_files_left}
 *    {status:"cancelled"}  // if the remote user cancels the sending
 *    {status:"done"}       // when the file is done
 *    the progressListener should always return true for normal operation, false to cancel a filetransfer.
 * @return {Function} an object that accepts an array of File (the Files to be sent), and a boolean
 *   argument that is true if the files are binary, false if they are text.
 *   It is safe to treat all files as binary, it will just require more bandwidth.
 */
easyrtc_ft.buildFileSender = function(destUser, progressListener) {
    var droptarget;
    var seq = 0;
    var positionAcked = 0;
    var filePosition = 0;
    var filesOffered = [];
    var filesBeingSent = [];
    var sendStarted = false;
    var curFile = null;
    var curFileSize;
    var filesAreBinary;
    var maxChunkSize = 10 * 1024;
    var waitingForAck = false;
    var ackThreshold = 100 * 1024; // send is allowed to be 150KB ahead of receiver
    var filesWaiting = [];
    var haveFilesWaiting = false;

    if (!progressListener) {
        progressListener = function() {
            return true;
        };
    }

    var roomOccupantListener = function(eventType, eventData) {
        var roomName;
        var foundUser = false;
        for (roomName in eventData) {
            if (eventData[roomName][destUser]) {
                foundUser = true;
            }
        }
        if (!foundUser) {
            easyrtc.removeEventListener("roomOccupant", roomOccupantListener);
            if (filesBeingSent.length > 0 || filesOffered.length > 0) {
                progressListener({status: "cancelled"});
            }
        }
    };
    easyrtc.addEventListener("roomOccupant", roomOccupantListener);
    //
    // if a file offer is rejected, we delete references to it.
    //
    function fileOfferRejected(sender, msgType, msgData, targeting) {
        if (!msgData.seq)
            return;
        delete filesOffered[msgData.seq];
        progressListener({status: "rejected"});
        filesOffered.length = 0;
        sendFilesWaiting();
    }
    //
    // if a file offer is accepted, initiate sending of files.
    //
    function fileOfferAccepted(sender, msgType, msgData, targeting) {
        if (!msgData.seq || !filesOffered[msgData.seq])
            return;
        var alreadySending = filesBeingSent.length > 0;
        for (var i = 0; i < filesOffered[msgData.seq].length; i++) {
            filesBeingSent.push(filesOffered[msgData.seq][i]);
        }
        delete filesOffered[msgData.seq];
        if (!alreadySending) {
            filePosition = 0;
            sendChunk(); // this starts the file reading
        }
    }

    function fileCancelReceived(sender, msgType, msgData, targeting) {
        filesBeingSent.empty();
        progressListener({status: "cancelled"});
        filesOffered.length = 0;
        filesBeingSent.length = 0;
        sendStarted = false;
        sendFilesWaiting();
    }

    function packageAckReceived(sender, msgType, msgData) {
        positionAcked = msgData.positionAck;
        if (waitingForAck && filePosition < positionAcked + ackThreshold) {
            waitingForAck = false;
            sendChunk();
        }
    }

    easyrtc.setPeerListener(fileOfferRejected, "filesReject", destUser);
    easyrtc.setPeerListener(fileOfferAccepted, "filesAccept", destUser);
    easyrtc.setPeerListener(fileCancelReceived, "filesCancel", destUser);
    easyrtc.setPeerListener(packageAckReceived, "filesAck", destUser);


    var outseq = 0;

    function sendChunk() {
        if (!curFile) {
            if (filesBeingSent.length === 0) {
                outseq = 0;
                easyrtc.sendData(destUser, "filesChunk", {done: "all"});
                filesOffered.length = 0;
                progressListener({status: "done"});
                sendFilesWaiting();
                return;
            }
            else {
                curFile = filesBeingSent.shift();
                progressListener({status: "started_file", name: curFile.name});
                curFileSize = curFile.size;
                positionAcked = 0;
                waitingForAck = false;
                easyrtc.sendData(destUser, "filesChunk", {name: curFile.name, type: curFile.type, outseq: outseq, size: curFile.size});
                outseq++;
            }
        }

        var amountToRead = Math.min(maxChunkSize, curFileSize - filePosition);
        if (!progressListener({status: "working", name: curFile.name, position: filePosition, size: curFileSize, numFiles: filesBeingSent.length + 1})) {
            filesOffered.length = 0;
            filePosition = 0;
            easyrtc.sendData(destUser, "filesChunk", {done: "cancelled"});
            sendFilesWaiting();
            return;
        }

        var nextLocation = filePosition + amountToRead;
        var blobSlice = curFile.slice(filePosition, nextLocation);
        var reader = new FileReader();
        reader.onloadend = function(evt) {
            if (evt.target.readyState === FileReader.DONE) { // DONE == 2
                var binaryString = evt.target.result;
                var maxchar = 32, minchar = 32;
                for (var pp = 0; pp < binaryString.length; pp++) {
                    var oneChar = binaryString.charCodeAt(pp);
                    maxchar = Math.max(maxchar, oneChar);
                    minchar = Math.min(minchar, oneChar);
                }
                var maxPacketSize = 400; // size in bytes
                for (var pos = 0; pos < binaryString.length; pos += maxPacketSize) {
                    var packetLen = Math.min(maxPacketSize, amountToRead - pos);
                    var packetData = binaryString.substring(pos, pos + packetLen);
                    var packetObject = {outseq: outseq};
                    if (filesAreBinary) {
                        packetObject.data64 = btoa(packetData);
                    }
                    else {
                        packetObject.datatxt = packetData;
                    }
                    easyrtc.sendData(destUser, "filesChunk", packetObject);
                    outseq++;
                }
                if (nextLocation >= curFileSize) {
                    easyrtc.sendData(destUser, "filesChunk", {done: "file"});
                }
                if (filePosition < positionAcked + ackThreshold) {
                    sendChunk();
                }
                else {
                    waitingForAck = true;
                }
            }
        };

        reader.readAsBinaryString(blobSlice);
        filePosition = nextLocation;

        //  advance to the next file if we've read all of this file
        if (nextLocation >= curFileSize) {
            curFile = null;
            filePosition = 0;
        }
    }

    function sendFilesWaiting() {
        haveFilesWaiting = false;
        if (filesWaiting.length > 0) {
            setTimeout(function() {
                var fileset = filesWaiting.shift();
                sendFilesOffer(fileset.files, fileset.areBinary);
            }, 240);
        }
    }


    function sendFilesOffer(files, areBinary) {
        if (haveFilesWaiting) {
            filesWaiting.push({files: files, areBinary: areBinary});
        }
        else {
            haveFilesWaiting = true;
            filesAreBinary = areBinary;
            progressListener({status: "waiting"});
            var fileNameList = [];
            for (var i = 0; i < files.length; i++) {
                fileNameList[i] = {name: files[i].name, size: files[i].size};
            }
            seq++;
            filesOffered[seq] = files;
            easyrtc.sendDataWS(destUser, "filesOffer", {seq: seq, fileNameList: fileNameList});
        }
    }
    return sendFilesOffer;
};


/**
 * Enable datachannel based file receiving. The received blobs get passed to the statusCB in the 'eof' typed message.
 * @param {Function(otherGuy,fileNameList, wasAccepted} acceptRejectCB - this function is called when another peer
 * (otherGuy) offers to send you a list of files. this function should call it's wasAccepted function with true to
 * allow those files to be sent, or false to disallow them.
 * @param {Function} blobAcceptor - this function is called three arguments arguments: the suppliers easyrtcid, a blob and a filename. It is responsible for
 * saving the blob to the file, usually using easyrtc_ft.saveAs.
 * @param {type} statusCB  - this function is called with the current state of file receiving. It is passed two arguments:
 * otherGuy - the easyrtcid of the person sending the files. *
 * msg - one of the following structures:
 * {status:"done", reason:"accept_failed"}
 * {status:"done", reason:"success"}
 * {status:"done", reason:"cancelled"}
 * {status:"eof"},
 * {status:"started_file, name:"filename"}
 * {status:"progress", name:filename,
 *    received:received_size_in_bytes,
 *    size:file_size_in_bytes }
 *  @example
 *
 *    easyrtc_ft(
 *       function(otherGuy, filenamelist, wasAccepted) {  wasAccepted(true);},
 *       function(otherGuy, blob, filename) { easyrtc_ft(blob, filename);},
 *       function(otherGuy, status) {  console.log("status:" + JSON.stringify(status))}
 *     );
 */
easyrtc_ft.buildFileReceiver = function(acceptRejectCB, blobAcceptor, statusCB) {
    var userStreams = {};
    var ackThreshold = 10000; // receiver is allowed to be 10KB behind of sender
    var positionAcked = 0;

    var roomOccupantListener = function(eventType, eventData) {
        var user;
        var foundUser;
        var roomName;
        for (destUser in userStreams) {
            foundUser = false;
            for (roomName in eventData) {
                if (eventData[roomName][destUser]) {
                    foundUser = true;
                }
            }
            if (!foundUser) {
                easyrtc.removeEventListener("roomOccupant", roomOccupantListener);
                statusCB(destUser, {status: "done", reason: "cancelled"});
                delete userStreams[destUser];
            }
        }
    };
    easyrtc.addEventListener("roomOccupant", roomOccupantListener);

    function fileOfferHandler(otherGuy, msgType, msgData) {
        if (!userStreams[otherGuy]) {
            userStreams[otherGuy] = {};
        }
        acceptRejectCB(otherGuy, msgData.fileNameList, function(wasAccepted) {
            var ackHandler = function(ackMesg) {

                if (ackMesg.msgType === "error") {
                    statusCB(otherGuy, {status: "done", reason: "accept_failed"});
                    delete userStreams[otherGuy];
                }
                else {
                    statusCB(otherGuy, {status: "started"});
                }
            };
            if (wasAccepted) {
                userStreams[otherGuy] = {
                    groupSeq: msgData.seq,
                    nextPacketSeq: 0
                };
                easyrtc.sendDataWS(otherGuy, "filesAccept", {seq: msgData.seq}, ackHandler);
            }
            else {
                easyrtc.sendDataWS(otherGuy, "filesReject", {seq: msgData.seq});
                delete userStreams[otherGuy];
                statusCB(otherGuy, {status: "rejected"});
            }
        });
    }


    function fileChunkHandler(otherGuy, msgType, msgData) {
        var i;
        var userStream = userStreams[otherGuy];
        if (!userStream) {
            return;
        }
        if (msgData.done) {
            switch (msgData.done) {
                case "file":
                    var blob = new Blob(userStream.currentData, {type: userStream.currentFileType});
                    blobAcceptor(otherGuy, blob, userStream.currentFileName);
                    statusCB(otherGuy, {status: "eof", name: userStream.currentFileName});
                    blob = null;
                    positionAcked = 0;
                    userStream.currentData = [];
                    break;
                case "all":
                    statusCB(otherGuy, {status: "done", reason: "success"});
                    break;
                case "cancelled":
                    delete userStreams[otherGuy];
                    statusCB(otherGuy, {status: "done", reason: "cancelled"});
                    break;
            }
        }
        else if (msgData.name) {
            statusCB(otherGuy, {status: "started_file", name: msgData.name});
            userStream.currentFileName = msgData.name;
            userStream.currentFileType = msgData.type;
            userStream.lengthReceived = 0;
            userStream.lengthExpected = msgData.size;
            userStream.currentData = [];
        }
        else if (msgData.data64 || msgData.datatxt) {
            var binData;
            if (msgData.data64) {
                binData = atob(msgData.data64);
            }
            else {
                binData = msgData.datatxt;
            }
            var n = binData.length;
            var binheap = new Uint8Array(n);
            for (i = 0; i < n; i += 1) {
                binheap[i] = binData.charCodeAt(i);
            }
            userStream.lengthReceived += n;
            if (!userStream.currentData) {
                console.log("Lost my currentData!!!");
            }
            userStream.currentData.push(binheap);

            statusCB(otherGuy, {
                status: "progress",
                name: userStream.currentFileName,
                received: userStream.lengthReceived,
                size: userStream.lengthExpected});
            if (userStream.lengthReceived > positionAcked + ackThreshold) {
                positionAcked = userStream.lengthReceived;
                easyrtc.sendData(otherGuy, "filesAck", {positionAck: positionAcked});
            }
        }
        else {
            console.log("Unexpected data structure in filesChunk=", msgData);
        }
    }

    easyrtc.setPeerListener(fileOfferHandler, "filesOffer");
    easyrtc.setPeerListener(fileChunkHandler, "filesChunk");
};

/** This is a wrapper around Eli Grey's saveAs function. This saves to the browser's downloads directory.
 * @param {Blob} Blob - the data to be saved.
 * @param {String} filename - the name of the file the blob should be written to.
 */
easyrtc_ft.saveAs = (function() {
    /* FileSaver.js
     * A saveAs() FileSaver implementation.
     * 2013-01-23
     *
     * By Eli Grey, http://eligrey.com
     * License: X11/MIT
     *   See LICENSE.md
     */

    /*global self */
    /*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
     plusplus: true */

    /*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

    var saveAs = window.saveAs
            || (navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
            || (function(view) {

        var
                doc = view.document
                // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet
                , get_URL = function() {
            return view.URL || view.webkitURL || view;
        }
        , URL = view.URL || view.webkitURL || view
                , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
                , can_use_save_link = !view.externalHost && "download" in save_link
                , click = function(node) {
            var event = doc.createEvent("MouseEvents");
            event.initMouseEvent(
                    "click", true, false, view, 0, 0, 0, 0, 0
                    , false, false, false, false, 0, null
                    );
            node.dispatchEvent(event);
        }
        , webkit_req_fs = view.webkitRequestFileSystem
                , req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
                , throw_outside = function(ex) {
            (view.setImmediate || view.setTimeout)(function() {
                throw ex;
            }, 0);
        }
        , force_saveable_type = "application/octet-stream"
                , fs_min_size = 0
                , deletion_queue = []
                , process_deletion_queue = function() {
            var i = deletion_queue.length;
            while (i--) {
                var file = deletion_queue[i];
                if (typeof file === "string") { // file is an object URL
                    URL.revokeObjectURL(file);
                } else { // file is a File
                    file.remove();
                }
            }
            deletion_queue.length = 0; // clear queue
        }
        , dispatch = function(filesaver, event_types, event) {
            event_types = [].concat(event_types);
            var i = event_types.length;
            while (i--) {
                var listener = filesaver["on" + event_types[i]];
                if (typeof listener === "function") {
                    try {
                        listener.call(filesaver, event || filesaver);
                    } catch (ex) {
                        throw_outside(ex);
                    }
                }
            }
        }
        , FileSaver = function(blob, name) {
            // First try a.download, then web filesystem, then object URLs
            var
                    filesaver = this
                    , type = blob.type
                    , blob_changed = false
                    , object_url
                    , target_view
                    , get_object_url = function() {
                var object_url = get_URL().createObjectURL(blob);
                deletion_queue.push(object_url);
                return object_url;
            }
            , dispatch_all = function() {
                dispatch(filesaver, "writestart progress write writeend".split(" "));
            }
            // on any filesys errors revert to saving with object URLs
            , fs_error = function() {
                // don't create more object URLs than needed
                if (blob_changed || !object_url) {
                    object_url = get_object_url(blob);
                }
                if (target_view) {
                    target_view.location.href = object_url;
                } else {
                    window.open(object_url, "_blank");
                }
                filesaver.readyState = filesaver.DONE;
                dispatch_all();
            }
            , abortable = function(func) {
                return function() {
                    if (filesaver.readyState !== filesaver.DONE) {
                        return func.apply(this, arguments);
                    }
                    else {
                        return null;
                    }
                };
            }
            , create_if_not_found = {create: true, exclusive: false}
            , slice
                    ;
            filesaver.readyState = filesaver.INIT;
            if (!name) {
                name = "download";
            }
            if (can_use_save_link) {
                object_url = get_object_url(blob);
                save_link.href = object_url;
                save_link.download = name;
                click(save_link);
                filesaver.readyState = filesaver.DONE;
                dispatch_all();
                return;
            }
            // Object and web filesystem URLs have a problem saving in Google Chrome when
            // viewed in a tab, so I force save with application/octet-stream
            // http://code.google.com/p/chromium/issues/detail?id=91158
            if (view.chrome && type && type !== force_saveable_type) {
                slice = blob.slice || blob.webkitSlice;
                blob = slice.call(blob, 0, blob.size, force_saveable_type);
                blob_changed = true;
            }
            // Since I can't be sure that the guessed media type will trigger a download
            // in WebKit, I append .download to the filename.
            // https://bugs.webkit.org/show_bug.cgi?id=65440
            if (webkit_req_fs && name !== "download") {
                name += ".download";
            }
            if (type === force_saveable_type || webkit_req_fs) {
                target_view = view;
            }
            if (!req_fs) {
                fs_error();
                return;
            }
            fs_min_size += blob.size;
            req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
                fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
                    var save = function() {
                        dir.getFile(name, create_if_not_found, abortable(function(file) {
                            file.createWriter(abortable(function(writer) {
                                writer.onwriteend = function(event) {
                                    target_view.location.href = file.toURL();
                                    deletion_queue.push(file);
                                    filesaver.readyState = filesaver.DONE;
                                    dispatch(filesaver, "writeend", event);
                                };
                                writer.onerror = function() {
                                    var error = writer.error;
                                    if (error.code !== error.ABORT_ERR) {
                                        fs_error();
                                    }
                                };
                                "writestart progress write abort".split(" ").forEach(function(event) {
                                    writer["on" + event] = filesaver["on" + event];
                                });
                                writer.write(blob);
                                filesaver.abort = function() {
                                    writer.abort();
                                    filesaver.readyState = filesaver.DONE;
                                };
                                filesaver.readyState = filesaver.WRITING;
                            }), fs_error);
                        }), fs_error);
                    };
                    dir.getFile(name, {create: false}, abortable(function(file) {
                        // delete file if it already exists
                        file.remove();
                        save();
                    }), abortable(function(ex) {
                        if (ex.code === ex.NOT_FOUND_ERR) {
                            save();
                        } else {
                            fs_error();
                        }
                    }));
                }), fs_error);
            }), fs_error);
        }
        , FS_proto = FileSaver.prototype
                , saveAs = function(blob, name) {
            return new FileSaver(blob, name);
        }
        ;
        FS_proto.abort = function() {
            var filesaver = this;
            filesaver.readyState = filesaver.DONE;
            dispatch(filesaver, "abort");
        };
        FS_proto.readyState = FS_proto.INIT = 0;
        FS_proto.WRITING = 1;
        FS_proto.DONE = 2;

        FS_proto.error =
                FS_proto.onwritestart =
                FS_proto.onprogress =
                FS_proto.onwrite =
                FS_proto.onabort =
                FS_proto.onerror =
                FS_proto.onwriteend =
                null;

        view.addEventListener("unload", process_deletion_queue, false);
        return saveAs;
    }(self));

    return saveAs;
})();
;'use strict';

// Last time updated: 2018-03-02 2:58:16 AM UTC

// ________________
// RecordRTC v5.4.7

// Open-Sourced: https://github.com/muaz-khan/RecordRTC

// --------------------------------------------------
// Muaz Khan     - www.MuazKhan.com
// MIT License   - www.WebRTC-Experiment.com/licence
// --------------------------------------------------

// ____________
// RecordRTC.js

/**
 * {@link https://github.com/muaz-khan/RecordRTC|RecordRTC} is a WebRTC JavaScript library for audio/video as well as screen activity recording. It supports Chrome, Firefox, Opera, Android, and Microsoft Edge. Platforms: Linux, Mac and Windows. 
 * @summary Record audio, video or screen inside the browser.
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link http://www.MuazKhan.com|Muaz Khan}
 * @typedef RecordRTC
 * @class
 * @example
 * var recorder = RecordRTC(mediaStream or [arrayOfMediaStream], {
 *     type: 'video', // audio or video or gif or canvas
 *     recorderType: MediaStreamRecorder || CanvasRecorder || StereoAudioRecorder || Etc
 * });
 * recorder.startRecording();
 * @see For further information:
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.
 * @param {object} config - {type:"video", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, desiredSampRate: 16000, video: HTMLVideoElement, etc.}
 */

function RecordRTC(mediaStream, config) {
    if (!mediaStream) {
        throw 'First parameter is required.';
    }

    config = config || {
        type: 'video'
    };

    config = new RecordRTCConfiguration(mediaStream, config);

    // a reference to user's recordRTC object
    var self = this;

    function startRecording(config2) {
        if (!!config2) {
            // allow users to set options using startRecording method
            // config2 is similar to main "config" object (second parameter over RecordRTC constructor)
            config = new RecordRTCConfiguration(mediaStream, config2);
        }

        if (!config.disableLogs) {
            console.log('started recording ' + config.type + ' stream.');
        }

        if (mediaRecorder) {
            mediaRecorder.clearRecordedData();
            mediaRecorder.record();

            setState('recording');

            if (self.recordingDuration) {
                handleRecordingDuration();
            }
            return self;
        }

        initRecorder(function() {
            if (self.recordingDuration) {
                handleRecordingDuration();
            }
        });

        return self;
    }

    function initRecorder(initCallback) {
        if (initCallback) {
            config.initCallback = function() {
                initCallback();
                initCallback = config.initCallback = null; // recorder.initRecorder should be call-backed once.
            };
        }

        var Recorder = new GetRecorderType(mediaStream, config);

        mediaRecorder = new Recorder(mediaStream, config);
        mediaRecorder.record();

        setState('recording');

        if (!config.disableLogs) {
            console.log('Initialized recorderType:', mediaRecorder.constructor.name, 'for output-type:', config.type);
        }
    }

    function stopRecording(callback) {
        callback = callback || function() {};

        if (!mediaRecorder) {
            warningLog();
            return;
        }

        if (self.state === 'paused') {
            self.resumeRecording();

            setTimeout(function() {
                stopRecording(callback);
            }, 1);
            return;
        }

        if (self.state !== 'recording' && !config.disableLogs) {
            console.warn('Recording state should be: "recording", however current state is: ', self.state);
        }

        if (!config.disableLogs) {
            console.log('Stopped recording ' + config.type + ' stream.');
        }

        if (config.type !== 'gif') {
            mediaRecorder.stop(_callback);
        } else {
            mediaRecorder.stop();
            _callback();
        }

        setState('stopped');

        function _callback(__blob) {
            if (!mediaRecorder) {
                if (typeof callback.call === 'function') {
                    callback.call(self, '');
                } else {
                    callback('');
                }
                return;
            }

            Object.keys(mediaRecorder).forEach(function(key) {
                if (typeof mediaRecorder[key] === 'function') {
                    return;
                }

                self[key] = mediaRecorder[key];
            });

            var blob = mediaRecorder.blob;

            if (!blob) {
                if (__blob) {
                    mediaRecorder.blob = blob = __blob;
                } else {
                    throw 'Recording failed.';
                }
            }

            if (blob && !config.disableLogs) {
                console.log(blob.type, '->', bytesToSize(blob.size));
            }

            if (callback) {
                var url = URL.createObjectURL(blob);

                if (typeof callback.call === 'function') {
                    callback.call(self, url);
                } else {
                    callback(url);
                }
            }

            if (!config.autoWriteToDisk) {
                return;
            }

            getDataURL(function(dataURL) {
                var parameter = {};
                parameter[config.type + 'Blob'] = dataURL;
                DiskStorage.Store(parameter);
            });
        }
    }

    function pauseRecording() {
        if (!mediaRecorder) {
            warningLog();
            return;
        }

        if (self.state !== 'recording') {
            if (!config.disableLogs) {
                console.warn('Unable to pause the recording. Recording state: ', self.state);
            }
            return;
        }

        setState('paused');

        mediaRecorder.pause();

        if (!config.disableLogs) {
            console.log('Paused recording.');
        }
    }

    function resumeRecording() {
        if (!mediaRecorder) {
            warningLog();
            return;
        }

        if (self.state !== 'paused') {
            if (!config.disableLogs) {
                console.warn('Unable to resume the recording. Recording state: ', self.state);
            }
            return;
        }

        setState('recording');

        // not all libs have this method yet
        mediaRecorder.resume();

        if (!config.disableLogs) {
            console.log('Resumed recording.');
        }
    }

    function readFile(_blob) {
        postMessage(new FileReaderSync().readAsDataURL(_blob));
    }

    function getDataURL(callback, _mediaRecorder) {
        if (!callback) {
            throw 'Pass a callback function over getDataURL.';
        }

        var blob = _mediaRecorder ? _mediaRecorder.blob : (mediaRecorder || {}).blob;

        if (!blob) {
            if (!config.disableLogs) {
                console.warn('Blob encoder did not finish its job yet.');
            }

            setTimeout(function() {
                getDataURL(callback, _mediaRecorder);
            }, 1000);
            return;
        }

        if (typeof Worker !== 'undefined' && !navigator.mozGetUserMedia) {
            var webWorker = processInWebWorker(readFile);

            webWorker.onmessage = function(event) {
                callback(event.data);
            };

            webWorker.postMessage(blob);
        } else {
            var reader = new FileReader();
            reader.readAsDataURL(blob);
            reader.onload = function(event) {
                callback(event.target.result);
            };
        }

        function processInWebWorker(_function) {
            var blob = URL.createObjectURL(new Blob([_function.toString(),
                'this.onmessage =  function (e) {' + _function.name + '(e.data);}'
            ], {
                type: 'application/javascript'
            }));

            var worker = new Worker(blob);
            URL.revokeObjectURL(blob);
            return worker;
        }
    }

    function handleRecordingDuration(counter) {
        counter = counter || 0;

        if (self.state === 'paused') {
            setTimeout(function() {
                handleRecordingDuration(counter);
            }, 1000);
            return;
        }

        if (self.state === 'stopped') {
            return;
        }

        if (counter >= self.recordingDuration) {
            stopRecording(self.onRecordingStopped);
            return;
        }

        counter += 1000; // 1-second

        setTimeout(function() {
            handleRecordingDuration(counter);
        }, 1000);
    }

    function setState(state) {
        if (!self) {
            return;
        }

        self.state = state;

        if (typeof self.onStateChanged.call === 'function') {
            self.onStateChanged.call(self, state);
        } else {
            self.onStateChanged(state);
        }
    }

    var WARNING = 'It seems that recorder is destroyed or "startRecording" is not invoked for ' + config.type + ' recorder.';

    function warningLog() {
        if (config.disableLogs === true) {
            return;
        }

        console.warn(WARNING);
    }

    var mediaRecorder;

    var returnObject = {
        /**
         * This method starts the recording.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * var recorder = RecordRTC(mediaStream, {
         *     type: 'video'
         * });
         * recorder.startRecording();
         */
        startRecording: startRecording,

        /**
         * This method stops the recording. It is strongly recommended to get "blob" or "URI" inside the callback to make sure all recorders finished their job.
         * @param {function} callback - Callback to get the recorded blob.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     // use either "this" or "recorder" object; both are identical
         *     video.src = this.toURL();
         *     var blob = this.getBlob();
         * });
         */
        stopRecording: stopRecording,

        /**
         * This method pauses the recording. You can resume recording using "resumeRecording" method.
         * @method
         * @memberof RecordRTC
         * @instance
         * @todo Firefox is unable to pause the recording. Fix it.
         * @example
         * recorder.pauseRecording();  // pause the recording
         * recorder.resumeRecording(); // resume again
         */
        pauseRecording: pauseRecording,

        /**
         * This method resumes the recording.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.pauseRecording();  // first of all, pause the recording
         * recorder.resumeRecording(); // now resume it
         */
        resumeRecording: resumeRecording,

        /**
         * This method initializes the recording.
         * @method
         * @memberof RecordRTC
         * @instance
         * @todo This method should be deprecated.
         * @example
         * recorder.initRecorder();
         */
        initRecorder: initRecorder,

        /**
         * Ask RecordRTC to auto-stop the recording after 5 minutes.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * var fiveMinutes = 5 * 1000 * 60;
         * recorder.setRecordingDuration(fiveMinutes, function() {
         *    var blob = this.getBlob();
         *    video.src = this.toURL();
         * });
         * 
         * // or otherwise
         * recorder.setRecordingDuration(fiveMinutes).onRecordingStopped(function() {
         *    var blob = this.getBlob();
         *    video.src = this.toURL();
         * });
         */
        setRecordingDuration: function(recordingDuration, callback) {
            if (typeof recordingDuration === 'undefined') {
                throw 'recordingDuration is required.';
            }

            if (typeof recordingDuration !== 'number') {
                throw 'recordingDuration must be a number.';
            }

            self.recordingDuration = recordingDuration;
            self.onRecordingStopped = callback || function() {};

            return {
                onRecordingStopped: function(callback) {
                    self.onRecordingStopped = callback;
                }
            };
        },

        /**
         * This method can be used to clear/reset all the recorded data.
         * @method
         * @memberof RecordRTC
         * @instance
         * @todo Figure out the difference between "reset" and "clearRecordedData" methods.
         * @example
         * recorder.clearRecordedData();
         */
        clearRecordedData: function() {
            if (!mediaRecorder) {
                warningLog();
                return;
            }

            mediaRecorder.clearRecordedData();

            if (!config.disableLogs) {
                console.log('Cleared old recorded data.');
            }
        },

        /**
         * Get the recorded blob. Use this method inside the "stopRecording" callback.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     var blob = this.getBlob();
         *
         *     var file = new File([blob], 'filename.webm', {
         *         type: 'video/webm'
         *     });
         *
         *     var formData = new FormData();
         *     formData.append('file', file); // upload "File" object rather than a "Blob"
         *     uploadToServer(formData);
         * });
         * @returns {Blob} Returns recorded data as "Blob" object.
         */
        getBlob: function() {
            if (!mediaRecorder) {
                warningLog();
                return;
            }

            return mediaRecorder.blob;
        },

        /**
         * Get data-URI instead of Blob.
         * @param {function} callback - Callback to get the Data-URI.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     recorder.getDataURL(function(dataURI) {
         *         video.src = dataURI;
         *     });
         * });
         */
        getDataURL: getDataURL,

        /**
         * Get virtual/temporary URL. Usage of this URL is limited to current tab.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     video.src = this.toURL();
         * });
         * @returns {String} Returns a virtual/temporary URL for the recorded "Blob".
         */
        toURL: function() {
            if (!mediaRecorder) {
                warningLog();
                return;
            }

            return URL.createObjectURL(mediaRecorder.blob);
        },

        /**
         * Get internal recording object (i.e. internal module) e.g. MutliStreamRecorder, MediaStreamRecorder, StereoAudioRecorder or WhammyRecorder etc.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * var internal = recorder.getInternalRecorder();
         * if(internal instanceof MultiStreamRecorder) {
         *     internal.addStreams([newAudioStream]);
         *     internal.resetVideoStreams([screenStream]);
         * }
         * @returns {Object} Returns internal recording object.
         */
        getInternalRecorder: function() {
            return mediaRecorder;
        },

        /**
         * Invoke save-as dialog to save the recorded blob into your disk.
         * @param {string} fileName - Set your own file name.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     this.save('file-name');
         *
         *     // or manually:
         *     invokeSaveAsDialog(this.getBlob(), 'filename.webm');
         * });
         */
        save: function(fileName) {
            if (!mediaRecorder) {
                warningLog();
                return;
            }

            invokeSaveAsDialog(mediaRecorder.blob, fileName);
        },

        /**
         * This method gets a blob from indexed-DB storage.
         * @param {function} callback - Callback to get the recorded blob.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.getFromDisk(function(dataURL) {
         *     video.src = dataURL;
         * });
         */
        getFromDisk: function(callback) {
            if (!mediaRecorder) {
                warningLog();
                return;
            }

            RecordRTC.getFromDisk(config.type, callback);
        },

        /**
         * This method appends an array of webp images to the recorded video-blob. It takes an "array" object.
         * @type {Array.<Array>}
         * @param {Array} arrayOfWebPImages - Array of webp images.
         * @method
         * @memberof RecordRTC
         * @instance
         * @todo This method should be deprecated.
         * @example
         * var arrayOfWebPImages = [];
         * arrayOfWebPImages.push({
         *     duration: index,
         *     image: 'data:image/webp;base64,...'
         * });
         * recorder.setAdvertisementArray(arrayOfWebPImages);
         */
        setAdvertisementArray: function(arrayOfWebPImages) {
            config.advertisement = [];

            var length = arrayOfWebPImages.length;
            for (var i = 0; i < length; i++) {
                config.advertisement.push({
                    duration: i,
                    image: arrayOfWebPImages[i]
                });
            }
        },

        /**
         * It is equivalent to <code class="str">"recorder.getBlob()"</code> method. Usage of "getBlob" is recommended, though.
         * @property {Blob} blob - Recorded Blob can be accessed using this property.
         * @memberof RecordRTC
         * @instance
         * @readonly
         * @example
         * recorder.stopRecording(function() {
         *     var blob = this.blob;
         *
         *     // below one is recommended
         *     var blob = this.getBlob();
         * });
         */
        blob: null,

        /**
         * This works only with {recorderType:StereoAudioRecorder}. Use this property on "stopRecording" to verify the encoder's sample-rates.
         * @property {number} bufferSize - Buffer-size used to encode the WAV container
         * @memberof RecordRTC
         * @instance
         * @readonly
         * @example
         * recorder.stopRecording(function() {
         *     alert('Recorder used this buffer-size: ' + this.bufferSize);
         * });
         */
        bufferSize: 0,

        /**
         * This works only with {recorderType:StereoAudioRecorder}. Use this property on "stopRecording" to verify the encoder's sample-rates.
         * @property {number} sampleRate - Sample-rates used to encode the WAV container
         * @memberof RecordRTC
         * @instance
         * @readonly
         * @example
         * recorder.stopRecording(function() {
         *     alert('Recorder used these sample-rates: ' + this.sampleRate);
         * });
         */
        sampleRate: 0,

        /**
         * {recorderType:StereoAudioRecorder} returns ArrayBuffer object.
         * @property {ArrayBuffer} buffer - Audio ArrayBuffer, supported only in Chrome.
         * @memberof RecordRTC
         * @instance
         * @readonly
         * @example
         * recorder.stopRecording(function() {
         *     var arrayBuffer = this.buffer;
         *     alert(arrayBuffer.byteLength);
         * });
         */
        buffer: null,

        /**
         * This method resets the recorder. So that you can reuse single recorder instance many times.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.reset();
         * recorder.startRecording();
         */
        reset: function() {
            if (mediaRecorder && typeof mediaRecorder.clearRecordedData === 'function') {
                mediaRecorder.clearRecordedData();
            }
            mediaRecorder = null;
            setState('inactive');
            self.blob = null;
        },

        /**
         * This method is called whenever recorder's state changes. Use this as an "event".
         * @property {String} state - A recorder's state can be: recording, paused, stopped or inactive.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.onStateChanged = function(state) {
         *     console.log('Recorder state: ', state);
         * };
         */
        onStateChanged: function(state) {
            if (!config.disableLogs) {
                console.log('Recorder state changed:', state);
            }
        },

        /**
         * A recorder can have inactive, recording, paused or stopped states.
         * @property {String} state - A recorder's state can be: recording, paused, stopped or inactive.
         * @memberof RecordRTC
         * @static
         * @readonly
         * @example
         * // this looper function will keep you updated about the recorder's states.
         * (function looper() {
         *     document.querySelector('h1').innerHTML = 'Recorder's state is: ' + recorder.state;
         *     if(recorder.state === 'stopped') return; // ignore+stop
         *     setTimeout(looper, 1000); // update after every 3-seconds
         * })();
         * recorder.startRecording();
         */
        state: 'inactive',

        /**
         * Get recorder's readonly state.
         * @method
         * @memberof RecordRTC
         * @example
         * var state = recorder.getState();
         * @returns {String} Returns recording state.
         */
        getState: function() {
            return self.state;
        },

        /**
         * Destroy RecordRTC instance. Clear all recorders and objects.
         * @method
         * @memberof RecordRTC
         * @example
         * recorder.destroy();
         */
        destroy: function() {
            var disableLogs = config.disableLogs;

            config.disableLogs = true;
            self.reset();
            config = {};
            setState('destroyed');
            returnObject = self = null;

            if (Storage.AudioContextConstructor) {
                Storage.AudioContextConstructor.close();
                Storage.AudioContextConstructor = null;
            }

            if (!disableLogs) {
                console.warn('RecordRTC is destroyed.');
            }
        },

        /**
         * RecordRTC version number
         * @property {String} version - Release version number.
         * @memberof RecordRTC
         * @static
         * @readonly
         * @example
         * alert(recorder.version);
         */
        version: '5.4.7'
    };

    if (!this) {
        self = returnObject;
        return returnObject;
    }

    // if someone wants to use RecordRTC with the "new" keyword.
    for (var prop in returnObject) {
        this[prop] = returnObject[prop];
    }

    self = this;

    return returnObject;
}

RecordRTC.version = '5.4.7';

if (typeof module !== 'undefined' /* && !!module.exports*/ ) {
    module.exports = RecordRTC;
}

if (typeof define === 'function' && define.amd) {
    define('RecordRTC', [], function() {
        return RecordRTC;
    });
}

RecordRTC.getFromDisk = function(type, callback) {
    if (!callback) {
        throw 'callback is mandatory.';
    }

    console.log('Getting recorded ' + (type === 'all' ? 'blobs' : type + ' blob ') + ' from disk!');
    DiskStorage.Fetch(function(dataURL, _type) {
        if (type !== 'all' && _type === type + 'Blob' && callback) {
            callback(dataURL);
        }

        if (type === 'all' && callback) {
            callback(dataURL, _type.replace('Blob', ''));
        }
    });
};

/**
 * This method can be used to store recorded blobs into IndexedDB storage.
 * @param {object} options - {audio: Blob, video: Blob, gif: Blob}
 * @method
 * @memberof RecordRTC
 * @example
 * RecordRTC.writeToDisk({
 *     audio: audioBlob,
 *     video: videoBlob,
 *     gif  : gifBlob
 * });
 */
RecordRTC.writeToDisk = function(options) {
    console.log('Writing recorded blob(s) to disk!');
    options = options || {};
    if (options.audio && options.video && options.gif) {
        options.audio.getDataURL(function(audioDataURL) {
            options.video.getDataURL(function(videoDataURL) {
                options.gif.getDataURL(function(gifDataURL) {
                    DiskStorage.Store({
                        audioBlob: audioDataURL,
                        videoBlob: videoDataURL,
                        gifBlob: gifDataURL
                    });
                });
            });
        });
    } else if (options.audio && options.video) {
        options.audio.getDataURL(function(audioDataURL) {
            options.video.getDataURL(function(videoDataURL) {
                DiskStorage.Store({
                    audioBlob: audioDataURL,
                    videoBlob: videoDataURL
                });
            });
        });
    } else if (options.audio && options.gif) {
        options.audio.getDataURL(function(audioDataURL) {
            options.gif.getDataURL(function(gifDataURL) {
                DiskStorage.Store({
                    audioBlob: audioDataURL,
                    gifBlob: gifDataURL
                });
            });
        });
    } else if (options.video && options.gif) {
        options.video.getDataURL(function(videoDataURL) {
            options.gif.getDataURL(function(gifDataURL) {
                DiskStorage.Store({
                    videoBlob: videoDataURL,
                    gifBlob: gifDataURL
                });
            });
        });
    } else if (options.audio) {
        options.audio.getDataURL(function(audioDataURL) {
            DiskStorage.Store({
                audioBlob: audioDataURL
            });
        });
    } else if (options.video) {
        options.video.getDataURL(function(videoDataURL) {
            DiskStorage.Store({
                videoBlob: videoDataURL
            });
        });
    } else if (options.gif) {
        options.gif.getDataURL(function(gifDataURL) {
            DiskStorage.Store({
                gifBlob: gifDataURL
            });
        });
    }
};

// __________________________
// RecordRTC-Configuration.js

/**
 * {@link RecordRTCConfiguration} is an inner/private helper for {@link RecordRTC}.
 * @summary It configures the 2nd parameter passed over {@link RecordRTC} and returns a valid "config" object.
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link http://www.MuazKhan.com|Muaz Khan}
 * @typedef RecordRTCConfiguration
 * @class
 * @example
 * var options = RecordRTCConfiguration(mediaStream, options);
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {type:"video", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, getNativeBlob:true, etc.}
 */

function RecordRTCConfiguration(mediaStream, config) {
    if (!config.recorderType && !config.type) {
        if (!!config.audio && !!config.video) {
            config.type = 'video';
        } else if (!!config.audio && !config.video) {
            config.type = 'audio';
        }
    }

    if (config.recorderType && !config.type) {
        if (config.recorderType === WhammyRecorder || config.recorderType === CanvasRecorder) {
            config.type = 'video';
        } else if (config.recorderType === GifRecorder) {
            config.type = 'gif';
        } else if (config.recorderType === StereoAudioRecorder) {
            config.type = 'audio';
        } else if (config.recorderType === MediaStreamRecorder) {
            if (mediaStream.getAudioTracks().length && mediaStream.getVideoTracks().length) {
                config.type = 'video';
            } else if (mediaStream.getAudioTracks().length && !mediaStream.getVideoTracks().length) {
                config.type = 'audio';
            } else if (!mediaStream.getAudioTracks().length && mediaStream.getVideoTracks().length) {
                config.type = 'audio';
            } else {
                // config.type = 'UnKnown';
            }
        }
    }

    if (typeof MediaStreamRecorder !== 'undefined' && typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype) {
        if (!config.mimeType) {
            config.mimeType = 'video/webm';
        }

        if (!config.type) {
            config.type = config.mimeType.split('/')[0];
        }

        if (!config.bitsPerSecond) {
            // config.bitsPerSecond = 128000;
        }
    }

    // consider default type=audio
    if (!config.type) {
        if (config.mimeType) {
            config.type = config.mimeType.split('/')[0];
        }
        if (!config.type) {
            config.type = 'audio';
        }
    }

    return config;
}

// __________________
// GetRecorderType.js

/**
 * {@link GetRecorderType} is an inner/private helper for {@link RecordRTC}.
 * @summary It returns best recorder-type available for your browser.
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link http://www.MuazKhan.com|Muaz Khan}
 * @typedef GetRecorderType
 * @class
 * @example
 * var RecorderType = GetRecorderType(options);
 * var recorder = new RecorderType(options);
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {type:"video", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}
 */

function GetRecorderType(mediaStream, config) {
    var recorder;

    // StereoAudioRecorder can work with all three: Edge, Firefox and Chrome
    // todo: detect if it is Edge, then auto use: StereoAudioRecorder
    if (isChrome || isEdge || isOpera) {
        // Media Stream Recording API has not been implemented in chrome yet;
        // That's why using WebAudio API to record stereo audio in WAV format
        recorder = StereoAudioRecorder;
    }

    if (typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype && !isChrome) {
        recorder = MediaStreamRecorder;
    }

    // video recorder (in WebM format)
    if (config.type === 'video' && (isChrome || isOpera)) {
        recorder = WhammyRecorder;
    }

    // video recorder (in Gif format)
    if (config.type === 'gif') {
        recorder = GifRecorder;
    }

    // html2canvas recording!
    if (config.type === 'canvas') {
        recorder = CanvasRecorder;
    }

    if (isMediaRecorderCompatible() && recorder !== CanvasRecorder && recorder !== GifRecorder && typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype) {
        if ((mediaStream.getVideoTracks && mediaStream.getVideoTracks().length) || (mediaStream.getAudioTracks && mediaStream.getAudioTracks().length)) {
            // audio-only recording
            if (config.type === 'audio') {
                if (typeof MediaRecorder.isTypeSupported === 'function' && MediaRecorder.isTypeSupported('audio/webm')) {
                    recorder = MediaStreamRecorder;
                }
                // else recorder = StereoAudioRecorder;
            } else {
                // video or screen tracks
                if (typeof MediaRecorder.isTypeSupported === 'function' && MediaRecorder.isTypeSupported('video/webm')) {
                    recorder = MediaStreamRecorder;
                }
            }
        }
    }

    if (config.recorderType) {
        recorder = config.recorderType;
    }

    if (mediaStream instanceof Array && mediaStream.length) {
        recorder = MultiStreamRecorder;
    }

    if (!config.disableLogs && !!recorder && !!recorder.name) {
        console.log('Using recorderType:', recorder.name || recorder.constructor.name);
    }

    return recorder;
}

// _____________
// MRecordRTC.js

/**
 * MRecordRTC runs on top of {@link RecordRTC} to bring multiple recordings in a single place, by providing simple API.
 * @summary MRecordRTC stands for "Multiple-RecordRTC".
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link http://www.MuazKhan.com|Muaz Khan}
 * @typedef MRecordRTC
 * @class
 * @example
 * var recorder = new MRecordRTC();
 * recorder.addStream(MediaStream);
 * recorder.mediaType = {
 *     audio: true, // or StereoAudioRecorder or MediaStreamRecorder
 *     video: true, // or WhammyRecorder or MediaStreamRecorder
 *     gif: true    // or GifRecorder
 * };
 * // mimeType is optional and should be set only in advance cases.
 * recorder.mimeType = {
 *     audio: 'audio/wav',
 *     video: 'video/webm',
 *     gif:   'image/gif'
 * };
 * recorder.startRecording();
 * @see For further information:
 * @see {@link https://github.com/muaz-khan/RecordRTC/tree/master/MRecordRTC|MRecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @requires {@link RecordRTC}
 */

function MRecordRTC(mediaStream) {

    /**
     * This method attaches MediaStream object to {@link MRecordRTC}.
     * @param {MediaStream} mediaStream - A MediaStream object, either fetched using getUserMedia API, or generated using captureStreamUntilEnded or WebAudio API.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.addStream(MediaStream);
     */
    this.addStream = function(_mediaStream) {
        if (_mediaStream) {
            mediaStream = _mediaStream;
        }
    };

    /**
     * This property can be used to set the recording type e.g. audio, or video, or gif, or canvas.
     * @property {object} mediaType - {audio: true, video: true, gif: true}
     * @memberof MRecordRTC
     * @example
     * var recorder = new MRecordRTC();
     * recorder.mediaType = {
     *     audio: true, // TRUE or StereoAudioRecorder or MediaStreamRecorder
     *     video: true, // TRUE or WhammyRecorder or MediaStreamRecorder
     *     gif  : true  // TRUE or GifRecorder
     * };
     */
    this.mediaType = {
        audio: true,
        video: true
    };

    /**
     * This method starts recording.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.startRecording();
     */
    this.startRecording = function() {
        var mediaType = this.mediaType;
        var recorderType;
        var mimeType = this.mimeType || {
            audio: null,
            video: null,
            gif: null
        };

        if (typeof mediaType.audio !== 'function' && isMediaRecorderCompatible() && mediaStream.getAudioTracks && !mediaStream.getAudioTracks().length) {
            mediaType.audio = false;
        }

        if (typeof mediaType.video !== 'function' && isMediaRecorderCompatible() && mediaStream.getVideoTracks && !mediaStream.getVideoTracks().length) {
            mediaType.video = false;
        }

        if (typeof mediaType.gif !== 'function' && isMediaRecorderCompatible() && mediaStream.getVideoTracks && !mediaStream.getVideoTracks().length) {
            mediaType.gif = false;
        }

        if (!mediaType.audio && !mediaType.video && !mediaType.gif) {
            throw 'MediaStream must have either audio or video tracks.';
        }

        if (!!mediaType.audio) {
            recorderType = null;
            if (typeof mediaType.audio === 'function') {
                recorderType = mediaType.audio;
            }

            this.audioRecorder = new RecordRTC(mediaStream, {
                type: 'audio',
                bufferSize: this.bufferSize,
                sampleRate: this.sampleRate,
                numberOfAudioChannels: this.numberOfAudioChannels || 2,
                disableLogs: this.disableLogs,
                recorderType: recorderType,
                mimeType: mimeType.audio,
                timeSlice: this.timeSlice,
                onTimeStamp: this.onTimeStamp
            });

            if (!mediaType.video) {
                this.audioRecorder.startRecording();
            }
        }

        if (!!mediaType.video) {
            recorderType = null;
            if (typeof mediaType.video === 'function') {
                recorderType = mediaType.video;
            }

            var newStream = mediaStream;

            if (isMediaRecorderCompatible() && !!mediaType.audio && typeof mediaType.audio === 'function') {
                var videoTrack = mediaStream.getVideoTracks()[0];

                if (!!navigator.mozGetUserMedia) {
                    newStream = new MediaStream();
                    newStream.addTrack(videoTrack);

                    if (recorderType && recorderType === WhammyRecorder) {
                        // Firefox does NOT support webp-encoding yet
                        recorderType = MediaStreamRecorder;
                    }
                } else {
                    newStream = new MediaStream([videoTrack]);
                }
            }

            this.videoRecorder = new RecordRTC(newStream, {
                type: 'video',
                video: this.video,
                canvas: this.canvas,
                frameInterval: this.frameInterval || 10,
                disableLogs: this.disableLogs,
                recorderType: recorderType,
                mimeType: mimeType.video,
                timeSlice: this.timeSlice,
                onTimeStamp: this.onTimeStamp
            });

            if (!mediaType.audio) {
                this.videoRecorder.startRecording();
            }
        }

        if (!!mediaType.audio && !!mediaType.video) {
            var self = this;

            // this line prevents StereoAudioRecorder
            // todo: fix it
            if (isMediaRecorderCompatible() /* && !this.audioRecorder */ ) {
                self.audioRecorder = null;
                self.videoRecorder.startRecording();
            } else {
                self.videoRecorder.initRecorder(function() {
                    self.audioRecorder.initRecorder(function() {
                        // Both recorders are ready to record things accurately
                        self.videoRecorder.startRecording();
                        self.audioRecorder.startRecording();
                    });
                });
            }
        }

        if (!!mediaType.gif) {
            recorderType = null;
            if (typeof mediaType.gif === 'function') {
                recorderType = mediaType.gif;
            }
            this.gifRecorder = new RecordRTC(mediaStream, {
                type: 'gif',
                frameRate: this.frameRate || 200,
                quality: this.quality || 10,
                disableLogs: this.disableLogs,
                recorderType: recorderType,
                mimeType: mimeType.gif
            });
            this.gifRecorder.startRecording();
        }
    };

    /**
     * This method stops recording.
     * @param {function} callback - Callback function is invoked when all encoders finished their jobs.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.stopRecording(function(recording){
     *     var audioBlob = recording.audio;
     *     var videoBlob = recording.video;
     *     var gifBlob   = recording.gif;
     * });
     */
    this.stopRecording = function(callback) {
        callback = callback || function() {};

        if (this.audioRecorder) {
            this.audioRecorder.stopRecording(function(blobURL) {
                callback(blobURL, 'audio');
            });
        }

        if (this.videoRecorder) {
            this.videoRecorder.stopRecording(function(blobURL) {
                callback(blobURL, 'video');
            });
        }

        if (this.gifRecorder) {
            this.gifRecorder.stopRecording(function(blobURL) {
                callback(blobURL, 'gif');
            });
        }
    };

    /**
     * This method pauses recording.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.pauseRecording();
     */
    this.pauseRecording = function() {
        if (this.audioRecorder) {
            this.audioRecorder.pauseRecording();
        }

        if (this.videoRecorder) {
            this.videoRecorder.pauseRecording();
        }

        if (this.gifRecorder) {
            this.gifRecorder.pauseRecording();
        }
    };

    /**
     * This method resumes recording.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.resumeRecording();
     */
    this.resumeRecording = function() {
        if (this.audioRecorder) {
            this.audioRecorder.resumeRecording();
        }

        if (this.videoRecorder) {
            this.videoRecorder.resumeRecording();
        }

        if (this.gifRecorder) {
            this.gifRecorder.resumeRecording();
        }
    };

    /**
     * This method can be used to manually get all recorded blobs.
     * @param {function} callback - All recorded blobs are passed back to the "callback" function.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.getBlob(function(recording){
     *     var audioBlob = recording.audio;
     *     var videoBlob = recording.video;
     *     var gifBlob   = recording.gif;
     * });
     * // or
     * var audioBlob = recorder.getBlob().audio;
     * var videoBlob = recorder.getBlob().video;
     */
    this.getBlob = function(callback) {
        var output = {};

        if (this.audioRecorder) {
            output.audio = this.audioRecorder.getBlob();
        }

        if (this.videoRecorder) {
            output.video = this.videoRecorder.getBlob();
        }

        if (this.gifRecorder) {
            output.gif = this.gifRecorder.getBlob();
        }

        if (callback) {
            callback(output);
        }

        return output;
    };

    /**
     * Destroy all recorder instances.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.destroy();
     */
    this.destroy = function() {
        if (this.audioRecorder) {
            this.audioRecorder.destroy();
            this.audioRecorder = null;
        }

        if (this.videoRecorder) {
            this.videoRecorder.destroy();
            this.videoRecorder = null;
        }

        if (this.gifRecorder) {
            this.gifRecorder.destroy();
            this.gifRecorder = null;
        }
    };

    /**
     * This method can be used to manually get all recorded blobs' DataURLs.
     * @param {function} callback - All recorded blobs' DataURLs are passed back to the "callback" function.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.getDataURL(function(recording){
     *     var audioDataURL = recording.audio;
     *     var videoDataURL = recording.video;
     *     var gifDataURL   = recording.gif;
     * });
     */
    this.getDataURL = function(callback) {
        this.getBlob(function(blob) {
            if (blob.audio && blob.video) {
                getDataURL(blob.audio, function(_audioDataURL) {
                    getDataURL(blob.video, function(_videoDataURL) {
                        callback({
                            audio: _audioDataURL,
                            video: _videoDataURL
                        });
                    });
                });
            } else if (blob.audio) {
                getDataURL(blob.audio, function(_audioDataURL) {
                    callback({
                        audio: _audioDataURL
                    });
                });
            } else if (blob.video) {
                getDataURL(blob.video, function(_videoDataURL) {
                    callback({
                        video: _videoDataURL
                    });
                });
            }
        });

        function getDataURL(blob, callback00) {
            if (typeof Worker !== 'undefined') {
                var webWorker = processInWebWorker(function readFile(_blob) {
                    postMessage(new FileReaderSync().readAsDataURL(_blob));
                });

                webWorker.onmessage = function(event) {
                    callback00(event.data);
                };

                webWorker.postMessage(blob);
            } else {
                var reader = new FileReader();
                reader.readAsDataURL(blob);
                reader.onload = function(event) {
                    callback00(event.target.result);
                };
            }
        }

        function processInWebWorker(_function) {
            var blob = URL.createObjectURL(new Blob([_function.toString(),
                'this.onmessage =  function (e) {' + _function.name + '(e.data);}'
            ], {
                type: 'application/javascript'
            }));

            var worker = new Worker(blob);
            var url;
            if (typeof URL !== 'undefined') {
                url = URL;
            } else if (typeof webkitURL !== 'undefined') {
                url = webkitURL;
            } else {
                throw 'Neither URL nor webkitURL detected.';
            }
            url.revokeObjectURL(blob);
            return worker;
        }
    };

    /**
     * This method can be used to ask {@link MRecordRTC} to write all recorded blobs into IndexedDB storage.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.writeToDisk();
     */
    this.writeToDisk = function() {
        RecordRTC.writeToDisk({
            audio: this.audioRecorder,
            video: this.videoRecorder,
            gif: this.gifRecorder
        });
    };

    /**
     * This method can be used to invoke a save-as dialog for all recorded blobs.
     * @param {object} args - {audio: 'audio-name', video: 'video-name', gif: 'gif-name'}
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.save({
     *     audio: 'audio-file-name',
     *     video: 'video-file-name',
     *     gif  : 'gif-file-name'
     * });
     */
    this.save = function(args) {
        args = args || {
            audio: true,
            video: true,
            gif: true
        };

        if (!!args.audio && this.audioRecorder) {
            this.audioRecorder.save(typeof args.audio === 'string' ? args.audio : '');
        }

        if (!!args.video && this.videoRecorder) {
            this.videoRecorder.save(typeof args.video === 'string' ? args.video : '');
        }
        if (!!args.gif && this.gifRecorder) {
            this.gifRecorder.save(typeof args.gif === 'string' ? args.gif : '');
        }
    };
}

/**
 * This method can be used to get all recorded blobs from IndexedDB storage.
 * @param {string} type - 'all' or 'audio' or 'video' or 'gif'
 * @param {function} callback - Callback function to get all stored blobs.
 * @method
 * @memberof MRecordRTC
 * @example
 * MRecordRTC.getFromDisk('all', function(dataURL, type){
 *     if(type === 'audio') { }
 *     if(type === 'video') { }
 *     if(type === 'gif')   { }
 * });
 */
MRecordRTC.getFromDisk = RecordRTC.getFromDisk;

/**
 * This method can be used to store recorded blobs into IndexedDB storage.
 * @param {object} options - {audio: Blob, video: Blob, gif: Blob}
 * @method
 * @memberof MRecordRTC
 * @example
 * MRecordRTC.writeToDisk({
 *     audio: audioBlob,
 *     video: videoBlob,
 *     gif  : gifBlob
 * });
 */
MRecordRTC.writeToDisk = RecordRTC.writeToDisk;

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.MRecordRTC = MRecordRTC;
}

var browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';

(function(that) {
    if (!that) {
        return;
    }

    if (typeof window !== 'undefined') {
        return;
    }

    if (typeof global === 'undefined') {
        return;
    }

    global.navigator = {
        userAgent: browserFakeUserAgent,
        getUserMedia: function() {}
    };

    if (!global.console) {
        global.console = {};
    }

    if (typeof global.console.log === 'undefined' || typeof global.console.error === 'undefined') {
        global.console.error = global.console.log = global.console.log || function() {
            console.log(arguments);
        };
    }

    if (typeof document === 'undefined') {
        /*global document:true */
        that.document = {};

        document.createElement = document.captureStream = document.mozCaptureStream = function() {
            var obj = {
                getContext: function() {
                    return obj;
                },
                play: function() {},
                pause: function() {},
                drawImage: function() {},
                toDataURL: function() {
                    return '';
                }
            };
            return obj;
        };

        that.HTMLVideoElement = function() {};
    }

    if (typeof location === 'undefined') {
        /*global location:true */
        that.location = {
            protocol: 'file:',
            href: '',
            hash: ''
        };
    }

    if (typeof screen === 'undefined') {
        /*global screen:true */
        that.screen = {
            width: 0,
            height: 0
        };
    }

    if (typeof URL === 'undefined') {
        /*global screen:true */
        that.URL = {
            createObjectURL: function() {
                return '';
            },
            revokeObjectURL: function() {
                return '';
            }
        };
    }

    /*global window:true */
    that.window = global;
})(typeof global !== 'undefined' ? global : null);

// _____________________________
// Cross-Browser-Declarations.js

// animation-frame used in WebM recording

/*jshint -W079 */
var requestAnimationFrame = window.requestAnimationFrame;
if (typeof requestAnimationFrame === 'undefined') {
    if (typeof webkitRequestAnimationFrame !== 'undefined') {
        /*global requestAnimationFrame:true */
        requestAnimationFrame = webkitRequestAnimationFrame;
    } else if (typeof mozRequestAnimationFrame !== 'undefined') {
        /*global requestAnimationFrame:true */
        requestAnimationFrame = mozRequestAnimationFrame;
    } else if (typeof msRequestAnimationFrame !== 'undefined') {
        /*global requestAnimationFrame:true */
        requestAnimationFrame = msRequestAnimationFrame;
    } else if (typeof requestAnimationFrame === 'undefined') {
        // via: https://gist.github.com/paulirish/1579671
        var lastTime = 0;

        /*global requestAnimationFrame:true */
        requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = setTimeout(function() {
                callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    }
}

/*jshint -W079 */
var cancelAnimationFrame = window.cancelAnimationFrame;
if (typeof cancelAnimationFrame === 'undefined') {
    if (typeof webkitCancelAnimationFrame !== 'undefined') {
        /*global cancelAnimationFrame:true */
        cancelAnimationFrame = webkitCancelAnimationFrame;
    } else if (typeof mozCancelAnimationFrame !== 'undefined') {
        /*global cancelAnimationFrame:true */
        cancelAnimationFrame = mozCancelAnimationFrame;
    } else if (typeof msCancelAnimationFrame !== 'undefined') {
        /*global cancelAnimationFrame:true */
        cancelAnimationFrame = msCancelAnimationFrame;
    } else if (typeof cancelAnimationFrame === 'undefined') {
        /*global cancelAnimationFrame:true */
        cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
    }
}

// WebAudio API representer
var AudioContext = window.AudioContext;

if (typeof AudioContext === 'undefined') {
    if (typeof webkitAudioContext !== 'undefined') {
        /*global AudioContext:true */
        AudioContext = webkitAudioContext;
    }

    if (typeof mozAudioContext !== 'undefined') {
        /*global AudioContext:true */
        AudioContext = mozAudioContext;
    }
}

/*jshint -W079 */
var URL = window.URL;

if (typeof URL === 'undefined' && typeof webkitURL !== 'undefined') {
    /*global URL:true */
    URL = webkitURL;
}

if (typeof navigator !== 'undefined' && typeof navigator.getUserMedia === 'undefined') { // maybe window.navigator?
    if (typeof navigator.webkitGetUserMedia !== 'undefined') {
        navigator.getUserMedia = navigator.webkitGetUserMedia;
    }

    if (typeof navigator.mozGetUserMedia !== 'undefined') {
        navigator.getUserMedia = navigator.mozGetUserMedia;
    }
}

var isEdge = navigator.userAgent.indexOf('Edge') !== -1 && (!!navigator.msSaveBlob || !!navigator.msSaveOrOpenBlob);
var isOpera = !!window.opera || navigator.userAgent.indexOf('OPR/') !== -1;
var isSafari = navigator.userAgent.toLowerCase().indexOf('safari/') > -1;
var isChrome = (!isOpera && !isEdge && !!navigator.webkitGetUserMedia) || isElectron() || isSafari;

var MediaStream = window.MediaStream;

if (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {
    MediaStream = webkitMediaStream;
}

/*global MediaStream:true */
if (typeof MediaStream !== 'undefined') {
    if (!('getVideoTracks' in MediaStream.prototype)) {
        MediaStream.prototype.getVideoTracks = function() {
            if (!this.getTracks) {
                return [];
            }

            var tracks = [];
            this.getTracks().forEach(function(track) {
                if (track.kind.toString().indexOf('video') !== -1) {
                    tracks.push(track);
                }
            });
            return tracks;
        };

        MediaStream.prototype.getAudioTracks = function() {
            if (!this.getTracks) {
                return [];
            }

            var tracks = [];
            this.getTracks().forEach(function(track) {
                if (track.kind.toString().indexOf('audio') !== -1) {
                    tracks.push(track);
                }
            });
            return tracks;
        };
    }

    // override "stop" method for all browsers
    if (typeof MediaStream.prototype.stop === 'undefined') {
        MediaStream.prototype.stop = function() {
            this.getTracks().forEach(function(track) {
                track.stop();
            });
        };
    }
}

// below function via: http://goo.gl/B3ae8c
/**
 * @param {number} bytes - Pass bytes and get formafted string.
 * @returns {string} - formafted string
 * @example
 * bytesToSize(1024*1024*5) === '5 GB'
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */
function bytesToSize(bytes) {
    var k = 1000;
    var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    if (bytes === 0) {
        return '0 Bytes';
    }
    var i = parseInt(Math.floor(Math.log(bytes) / Math.log(k)), 10);
    return (bytes / Math.pow(k, i)).toPrecision(3) + ' ' + sizes[i];
}

/**
 * @param {Blob} file - File or Blob object. This parameter is required.
 * @param {string} fileName - Optional file name e.g. "Recorded-Video.webm"
 * @example
 * invokeSaveAsDialog(blob or file, [optional] fileName);
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */
function invokeSaveAsDialog(file, fileName) {
    if (!file) {
        throw 'Blob object is required.';
    }

    if (!file.type) {
        try {
            file.type = 'video/webm';
        } catch (e) {}
    }

    var fileExtension = (file.type || 'video/webm').split('/')[1];

    if (fileName && fileName.indexOf('.') !== -1) {
        var splitted = fileName.split('.');
        fileName = splitted[0];
        fileExtension = splitted[1];
    }

    var fileFullName = (fileName || (Math.round(Math.random() * 9999999999) + 888888888)) + '.' + fileExtension;

    if (typeof navigator.msSaveOrOpenBlob !== 'undefined') {
        return navigator.msSaveOrOpenBlob(file, fileFullName);
    } else if (typeof navigator.msSaveBlob !== 'undefined') {
        return navigator.msSaveBlob(file, fileFullName);
    }

    var hyperlink = document.createElement('a');
    hyperlink.href = URL.createObjectURL(file);
    hyperlink.download = fileFullName;

    hyperlink.style = 'display:none;opacity:0;color:transparent;';
    (document.body || document.documentElement).appendChild(hyperlink);

    if (typeof hyperlink.click === 'function') {
        hyperlink.click();
    } else {
        hyperlink.target = '_blank';
        hyperlink.dispatchEvent(new MouseEvent('click', {
            view: window,
            bubbles: true,
            cancelable: true
        }));
    }

    URL.revokeObjectURL(hyperlink.href);
}

/**
 * from: https://github.com/cheton/is-electron/blob/master/index.js
 **/
function isElectron() {
    // Renderer process
    if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {
        return true;
    }

    // Main process
    if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) {
        return true;
    }

    // Detect the user agent when the `nodeIntegration` option is set to true
    if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {
        return true;
    }

    return false;
}

function setSrcObject(stream, element, ignoreCreateObjectURL) {
    if ('createObjectURL' in URL && !ignoreCreateObjectURL) {
        try {
            element.src = URL.createObjectURL(stream);
        } catch (e) {
            setSrcObject(stream, element, true);
            return;
        }
    } else if ('srcObject' in element) {
        element.srcObject = stream;
    } else if ('mozSrcObject' in element) {
        element.mozSrcObject = stream;
    } else {
        alert('createObjectURL/srcObject both are not supported.');
    }
}

// __________ (used to handle stuff like http://goo.gl/xmE5eg) issue #129
// Storage.js

/**
 * Storage is a standalone object used by {@link RecordRTC} to store reusable objects e.g. "new AudioContext".
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link http://www.MuazKhan.com|Muaz Khan}
 * @example
 * Storage.AudioContext === webkitAudioContext
 * @property {webkitAudioContext} AudioContext - Keeps a reference to AudioContext object.
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */

var Storage = {};

if (typeof AudioContext !== 'undefined') {
    Storage.AudioContext = AudioContext;
} else if (typeof webkitAudioContext !== 'undefined') {
    Storage.AudioContext = webkitAudioContext;
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.Storage = Storage;
}

function isMediaRecorderCompatible() {
    var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
    var isChrome = (!!window.chrome && !isOpera) || isElectron();
    var isFirefox = typeof window.InstallTrigger !== 'undefined';

    if (isFirefox) {
        return true;
    }

    var nVer = navigator.appVersion;
    var nAgt = navigator.userAgent;
    var fullVersion = '' + parseFloat(navigator.appVersion);
    var majorVersion = parseInt(navigator.appVersion, 10);
    var nameOffset, verOffset, ix;

    if (isChrome || isOpera) {
        verOffset = nAgt.indexOf('Chrome');
        fullVersion = nAgt.substring(verOffset + 7);
    }

    // trim the fullVersion string at semicolon/space if present
    if ((ix = fullVersion.indexOf(';')) !== -1) {
        fullVersion = fullVersion.substring(0, ix);
    }

    if ((ix = fullVersion.indexOf(' ')) !== -1) {
        fullVersion = fullVersion.substring(0, ix);
    }

    majorVersion = parseInt('' + fullVersion, 10);

    if (isNaN(majorVersion)) {
        fullVersion = '' + parseFloat(navigator.appVersion);
        majorVersion = parseInt(navigator.appVersion, 10);
    }

    return majorVersion >= 49;
}

// ______________________
// MediaStreamRecorder.js

/**
 * MediaStreamRecorder is an abstraction layer for {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}. It is used by {@link RecordRTC} to record MediaStream(s) in both Chrome and Firefox.
 * @summary Runs top over {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}.
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link https://github.com/muaz-khan|Muaz Khan}
 * @typedef MediaStreamRecorder
 * @class
 * @example
 * var config = {
 *     mimeType: 'video/webm', // vp8, vp9, h264, mkv, opus/vorbis
 *     audioBitsPerSecond : 256 * 8 * 1024,
 *     videoBitsPerSecond : 256 * 8 * 1024,
 *     bitsPerSecond: 256 * 8 * 1024,  // if this is provided, skip above two
 *     checkForInactiveTracks: true,
 *     timeSlice: 1000, // concatenate intervals based blobs
 *     ondataavailable: function() {} // get intervals based blobs
 * }
 * var recorder = new MediaStreamRecorder(mediaStream, config);
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 *
 *     // or
 *     var blob = recorder.blob;
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {disableLogs:true, initCallback: function, mimeType: "video/webm", timeSlice: 1000}
 * @throws Will throw an error if first argument "MediaStream" is missing. Also throws error if "MediaRecorder API" are not supported by the browser.
 */

function MediaStreamRecorder(mediaStream, config) {
    var self = this;

    if (typeof mediaStream === 'undefined') {
        throw 'First argument "MediaStream" is required.';
    }

    if (typeof MediaRecorder === 'undefined') {
        throw 'Your browser does not supports Media Recorder API. Please try other modules e.g. WhammyRecorder or StereoAudioRecorder.';
    }

    config = config || {
        // bitsPerSecond: 256 * 8 * 1024,
        mimeType: 'video/webm'
    };

    if (config.type === 'audio') {
        if (mediaStream.getVideoTracks().length && mediaStream.getAudioTracks().length) {
            var stream;
            if (!!navigator.mozGetUserMedia) {
                stream = new MediaStream();
                stream.addTrack(mediaStream.getAudioTracks()[0]);
            } else {
                // webkitMediaStream
                stream = new MediaStream(mediaStream.getAudioTracks());
            }
            mediaStream = stream;
        }

        if (!config.mimeType || config.mimeType.toString().toLowerCase().indexOf('audio') === -1) {
            config.mimeType = isChrome ? 'audio/webm' : 'audio/ogg';
        }

        if (config.mimeType && config.mimeType.toString().toLowerCase() !== 'audio/ogg' && !!navigator.mozGetUserMedia) {
            // forcing better codecs on Firefox (via #166)
            config.mimeType = 'audio/ogg';
        }
    }

    var arrayOfBlobs = [];

    /**
     * This method returns array of blobs. Use only with "timeSlice". Its useful to preview recording anytime, without using the "stop" method.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * var arrayOfBlobs = recorder.getArrayOfBlobs();
     * @returns {Array} Returns array of recorded blobs.
     */
    this.getArrayOfBlobs = function() {
        return arrayOfBlobs;
    };

    /**
     * This method records MediaStream.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * recorder.record();
     */
    this.record = function() {
        // set defaults
        self.blob = null;
        self.clearRecordedData();
        self.timestamps = [];
        allStates = [];
        arrayOfBlobs = [];

        var recorderHints = config;

        if (!config.disableLogs) {
            console.log('Passing following config over MediaRecorder API.', recorderHints);
        }

        if (mediaRecorder) {
            // mandatory to make sure Firefox doesn't fails to record streams 3-4 times without reloading the page.
            mediaRecorder = null;
        }

        if (isChrome && !isMediaRecorderCompatible()) {
            // to support video-only recording on stable
            recorderHints = 'video/vp8';
        }

        if (typeof MediaRecorder.isTypeSupported === 'function' && recorderHints.mimeType) {
            if (!MediaRecorder.isTypeSupported(recorderHints.mimeType)) {
                if (!config.disableLogs) {
                    console.warn('MediaRecorder API seems unable to record mimeType:', recorderHints.mimeType);
                }

                recorderHints.mimeType = config.type === 'audio' ? 'audio/webm' : 'video/webm';
            }
        }

        // using MediaRecorder API here
        try {
            mediaRecorder = new MediaRecorder(mediaStream, recorderHints);

            // reset
            config.mimeType = recorderHints.mimeType;
        } catch (e) {
            // chrome-based fallback
            mediaRecorder = new MediaRecorder(mediaStream);
        }

        // old hack?
        if (recorderHints.mimeType && !MediaRecorder.isTypeSupported && 'canRecordMimeType' in mediaRecorder && mediaRecorder.canRecordMimeType(recorderHints.mimeType) === false) {
            if (!config.disableLogs) {
                console.warn('MediaRecorder API seems unable to record mimeType:', recorderHints.mimeType);
            }
        }

        // Dispatching OnDataAvailable Handler
        mediaRecorder.ondataavailable = function(e) {
            if (e.data) {
                allStates.push('ondataavailable: ' + bytesToSize(e.data.size));
            }

            if (typeof config.timeSlice === 'number') {
                if (e.data && e.data.size && e.data.size > 100) {
                    arrayOfBlobs.push(e.data);
                    updateTimeStamp();

                    if (typeof config.ondataavailable === 'function') {
                        // intervals based blobs
                        var blob = config.getNativeBlob ? e.data : new Blob([e.data], {
                            type: getMimeType(recorderHints)
                        });
                        config.ondataavailable(blob);
                    }
                }
                return;
            }

            if (!e.data || !e.data.size || e.data.size < 100 || self.blob) {
                // make sure that stopRecording always getting fired
                // even if there is invalid data
                if (self.recordingCallback) {
                    self.recordingCallback(new Blob([], {
                        type: getMimeType(recorderHints)
                    }));
                    self.recordingCallback = null;
                }
                return;
            }

            self.blob = config.getNativeBlob ? e.data : new Blob([e.data], {
                type: getMimeType(recorderHints)
            });

            if (self.recordingCallback) {
                self.recordingCallback(self.blob);
                self.recordingCallback = null;
            }
        };

        mediaRecorder.onstart = function() {
            allStates.push('started');
        };

        mediaRecorder.onpause = function() {
            allStates.push('paused');
        };

        mediaRecorder.onresume = function() {
            allStates.push('resumed');
        };

        mediaRecorder.onstop = function() {
            allStates.push('stopped');
        };

        mediaRecorder.onerror = function(error) {
            allStates.push('error: ' + error);

            if (!config.disableLogs) {
                // via: https://w3c.github.io/mediacapture-record/MediaRecorder.html#exception-summary
                if (error.name.toString().toLowerCase().indexOf('invalidstate') !== -1) {
                    console.error('The MediaRecorder is not in a state in which the proposed operation is allowed to be executed.', error);
                } else if (error.name.toString().toLowerCase().indexOf('notsupported') !== -1) {
                    console.error('MIME type (', recorderHints.mimeType, ') is not supported.', error);
                } else if (error.name.toString().toLowerCase().indexOf('security') !== -1) {
                    console.error('MediaRecorder security error', error);
                }

                // older code below
                else if (error.name === 'OutOfMemory') {
                    console.error('The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute.', error);
                } else if (error.name === 'IllegalStreamModification') {
                    console.error('A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute.', error);
                } else if (error.name === 'OtherRecordingError') {
                    console.error('Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute.', error);
                } else if (error.name === 'GenericError') {
                    console.error('The UA cannot provide the codec or recording option that has been requested.', error);
                } else {
                    console.error('MediaRecorder Error', error);
                }
            }

            (function(looper) {
                if (!self.manuallyStopped && mediaRecorder && mediaRecorder.state === 'inactive') {
                    delete config.timeslice;

                    // 10 minutes, enough?
                    mediaRecorder.start(10 * 60 * 1000);
                    return;
                }

                setTimeout(looper, 1000);
            })();

            if (mediaRecorder.state !== 'inactive' && mediaRecorder.state !== 'stopped') {
                mediaRecorder.stop();
            }
        };

        if (typeof config.timeSlice === 'number') {
            updateTimeStamp();
            mediaRecorder.start(config.timeSlice);
        } else {
            // default is 60 minutes; enough?
            // use config => {timeSlice: 1000} otherwise

            mediaRecorder.start(3.6e+6);
        }

        if (config.initCallback) {
            config.initCallback(); // old code
        }
    };

    /**
     * @property {Array} timestamps - Array of time stamps
     * @memberof MediaStreamRecorder
     * @example
     * console.log(recorder.timestamps);
     */
    this.timestamps = [];

    function updateTimeStamp() {
        self.timestamps.push(new Date().getTime());

        if (typeof config.onTimeStamp === 'function') {
            config.onTimeStamp(self.timestamps[self.timestamps.length - 1], self.timestamps);
        }
    }

    function getMimeType(secondObject) {
        if (mediaRecorder && mediaRecorder.mimeType) {
            return mediaRecorder.mimeType;
        }

        return secondObject.mimeType || 'video/webm';
    }

    /**
     * This method stops recording MediaStream.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     */
    this.stop = function(callback) {
        callback = callback || function() {};

        self.manuallyStopped = true; // used inside the mediaRecorder.onerror

        if (!mediaRecorder) {
            return;
        }

        this.recordingCallback = callback;

        if (mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }

        if (typeof config.timeSlice === 'number') {
            setTimeout(function() {
                self.blob = new Blob(arrayOfBlobs, {
                    type: getMimeType(config)
                });

                self.recordingCallback(self.blob);
            }, 100);
        }
    };

    /**
     * This method pauses the recording process.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * recorder.pause();
     */
    this.pause = function() {
        if (!mediaRecorder) {
            return;
        }

        if (mediaRecorder.state === 'recording') {
            mediaRecorder.pause();
        }
    };

    /**
     * This method resumes the recording process.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * recorder.resume();
     */
    this.resume = function() {
        if (!mediaRecorder) {
            return;
        }

        if (mediaRecorder.state === 'paused') {
            mediaRecorder.resume();
        }
    };

    /**
     * This method resets currently recorded data.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * recorder.clearRecordedData();
     */
    this.clearRecordedData = function() {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            self.stop(clearRecordedDataCB);
        }

        clearRecordedDataCB();
    };

    function clearRecordedDataCB() {
        arrayOfBlobs = [];
        mediaRecorder = null;
        self.timestamps = [];
    }

    // Reference to "MediaRecorder" object
    var mediaRecorder;

    /**
     * Access to native MediaRecorder API
     * @method
     * @memberof MediaStreamRecorder
     * @instance
     * @example
     * var internal = recorder.getInternalRecorder();
     * internal.ondataavailable = function() {}; // override
     * internal.stream, internal.onpause, internal.onstop, etc.
     * @returns {Object} Returns internal recording object.
     */
    this.getInternalRecorder = function() {
        return mediaRecorder;
    };

    function isMediaStreamActive() {
        if ('active' in mediaStream) {
            if (!mediaStream.active) {
                return false;
            }
        } else if ('ended' in mediaStream) { // old hack
            if (mediaStream.ended) {
                return false;
            }
        }
        return true;
    }

    /**
     * @property {Blob} blob - Recorded data as "Blob" object.
     * @memberof MediaStreamRecorder
     * @example
     * recorder.stop(function() {
     *     var blob = recorder.blob;
     * });
     */
    this.blob = null;


    /**
     * Get MediaRecorder readonly state.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * var state = recorder.getState();
     * @returns {String} Returns recording state.
     */
    this.getState = function() {
        if (!mediaRecorder) {
            return 'inactive';
        }

        return mediaRecorder.state || 'inactive';
    };

    // list of all recording states
    var allStates = [];

    /**
     * Get MediaRecorder all recording states.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * var state = recorder.getAllStates();
     * @returns {Array} Returns all recording states
     */
    this.getAllStates = function() {
        return allStates;
    };

    // if any Track within the MediaStream is muted or not enabled at any time, 
    // the browser will only record black frames 
    // or silence since that is the content produced by the Track
    // so we need to stopRecording as soon as any single track ends.
    if (typeof config.checkForInactiveTracks === 'undefined') {
        config.checkForInactiveTracks = false; // disable to minimize CPU usage
    }

    var self = this;

    // this method checks if media stream is stopped
    // or if any track is ended.
    (function looper() {
        if (!mediaRecorder || config.checkForInactiveTracks === false) {
            return;
        }

        if (isMediaStreamActive() === false) {
            if (!config.disableLogs) {
                console.log('MediaStream seems stopped.');
            }
            self.stop();
            return;
        }

        setTimeout(looper, 1000); // check every second
    })();

    // for debugging
    this.name = 'MediaStreamRecorder';
    this.toString = function() {
        return this.name;
    };
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.MediaStreamRecorder = MediaStreamRecorder;
}

// source code from: http://typedarray.org/wp-content/projects/WebAudioRecorder/script.js
// https://github.com/mattdiamond/Recorderjs#license-mit
// ______________________
// StereoAudioRecorder.js

/**
 * StereoAudioRecorder is a standalone class used by {@link RecordRTC} to bring "stereo" audio-recording in chrome.
 * @summary JavaScript standalone object for stereo audio recording.
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link http://www.MuazKhan.com|Muaz Khan}
 * @typedef StereoAudioRecorder
 * @class
 * @example
 * var recorder = new StereoAudioRecorder(MediaStream, {
 *     sampleRate: 44100,
 *     bufferSize: 4096
 * });
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {sampleRate: 44100, bufferSize: 4096, numberOfAudioChannels: 1, etc.}
 */

function StereoAudioRecorder(mediaStream, config) {
    if (!mediaStream.getAudioTracks().length) {
        throw 'Your stream has no audio tracks.';
    }

    config = config || {};

    var self = this;

    // variables
    var leftchannel = [];
    var rightchannel = [];
    var recording = false;
    var recordingLength = 0;
    var jsAudioNode;

    var numberOfAudioChannels = 2;

    /**
     * Set sample rates such as 8K or 16K. Reference: http://stackoverflow.com/a/28977136/552182
     * @property {number} desiredSampRate - Desired Bits per sample * 1000
     * @memberof StereoAudioRecorder
     * @instance
     * @example
     * var recorder = StereoAudioRecorder(mediaStream, {
     *   desiredSampRate: 16 * 1000 // bits-per-sample * 1000
     * });
     */
    var desiredSampRate = config.desiredSampRate;

    // backward compatibility
    if (config.leftChannel === true) {
        numberOfAudioChannels = 1;
    }

    if (config.numberOfAudioChannels === 1) {
        numberOfAudioChannels = 1;
    }

    if (!numberOfAudioChannels || numberOfAudioChannels < 1) {
        numberOfAudioChannels = 2;
    }

    if (!config.disableLogs) {
        console.log('StereoAudioRecorder is set to record number of channels: ', numberOfAudioChannels);
    }

    // if any Track within the MediaStream is muted or not enabled at any time, 
    // the browser will only record black frames 
    // or silence since that is the content produced by the Track
    // so we need to stopRecording as soon as any single track ends.
    if (typeof config.checkForInactiveTracks === 'undefined') {
        config.checkForInactiveTracks = true;
    }

    function isMediaStreamActive() {
        if (config.checkForInactiveTracks === false) {
            // always return "true"
            return true;
        }

        if ('active' in mediaStream) {
            if (!mediaStream.active) {
                return false;
            }
        } else if ('ended' in mediaStream) { // old hack
            if (mediaStream.ended) {
                return false;
            }
        }
        return true;
    }

    /**
     * This method records MediaStream.
     * @method
     * @memberof StereoAudioRecorder
     * @example
     * recorder.record();
     */
    this.record = function() {
        if (isMediaStreamActive() === false) {
            throw 'Please make sure MediaStream is active.';
        }

        resetVariables();

        isAudioProcessStarted = isPaused = false;
        recording = true;

        if (typeof config.timeSlice !== 'undefined') {
            looper();
        }
    };

    function mergeLeftRightBuffers(config, callback) {
        function mergeAudioBuffers(config, cb) {
            var numberOfAudioChannels = config.numberOfAudioChannels;

            // todo: "slice(0)" --- is it causes loop? Should be removed?
            var leftBuffers = config.leftBuffers.slice(0);
            var rightBuffers = config.rightBuffers.slice(0);
            var sampleRate = config.sampleRate;
            var internalInterleavedLength = config.internalInterleavedLength;
            var desiredSampRate = config.desiredSampRate;

            if (numberOfAudioChannels === 2) {
                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);
                rightBuffers = mergeBuffers(rightBuffers, internalInterleavedLength);

                if (desiredSampRate) {
                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);
                    rightBuffers = interpolateArray(rightBuffers, desiredSampRate, sampleRate);
                }
            }

            if (numberOfAudioChannels === 1) {
                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);

                if (desiredSampRate) {
                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);
                }
            }

            // set sample rate as desired sample rate
            if (desiredSampRate) {
                sampleRate = desiredSampRate;
            }

            // for changing the sampling rate, reference:
            // http://stackoverflow.com/a/28977136/552182
            function interpolateArray(data, newSampleRate, oldSampleRate) {
                var fitCount = Math.round(data.length * (newSampleRate / oldSampleRate));
                var newData = [];
                var springFactor = Number((data.length - 1) / (fitCount - 1));
                newData[0] = data[0];
                for (var i = 1; i < fitCount - 1; i++) {
                    var tmp = i * springFactor;
                    var before = Number(Math.floor(tmp)).toFixed();
                    var after = Number(Math.ceil(tmp)).toFixed();
                    var atPoint = tmp - before;
                    newData[i] = linearInterpolate(data[before], data[after], atPoint);
                }
                newData[fitCount - 1] = data[data.length - 1];
                return newData;
            }

            function linearInterpolate(before, after, atPoint) {
                return before + (after - before) * atPoint;
            }

            function mergeBuffers(channelBuffer, rLength) {
                var result = new Float64Array(rLength);
                var offset = 0;
                var lng = channelBuffer.length;

                for (var i = 0; i < lng; i++) {
                    var buffer = channelBuffer[i];
                    result.set(buffer, offset);
                    offset += buffer.length;
                }

                return result;
            }

            function interleave(leftChannel, rightChannel) {
                var length = leftChannel.length + rightChannel.length;

                var result = new Float64Array(length);

                var inputIndex = 0;

                for (var index = 0; index < length;) {
                    result[index++] = leftChannel[inputIndex];
                    result[index++] = rightChannel[inputIndex];
                    inputIndex++;
                }
                return result;
            }

            function writeUTFBytes(view, offset, string) {
                var lng = string.length;
                for (var i = 0; i < lng; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            // interleave both channels together
            var interleaved;

            if (numberOfAudioChannels === 2) {
                interleaved = interleave(leftBuffers, rightBuffers);
            }

            if (numberOfAudioChannels === 1) {
                interleaved = leftBuffers;
            }

            var interleavedLength = interleaved.length;

            // create wav file
            var resultingBufferLength = 44 + interleavedLength * 2;

            var buffer = new ArrayBuffer(resultingBufferLength);

            var view = new DataView(buffer);

            // RIFF chunk descriptor/identifier 
            writeUTFBytes(view, 0, 'RIFF');

            // RIFF chunk length
            view.setUint32(4, 44 + interleavedLength * 2, true);

            // RIFF type 
            writeUTFBytes(view, 8, 'WAVE');

            // format chunk identifier 
            // FMT sub-chunk
            writeUTFBytes(view, 12, 'fmt ');

            // format chunk length 
            view.setUint32(16, 16, true);

            // sample format (raw)
            view.setUint16(20, 1, true);

            // stereo (2 channels)
            view.setUint16(22, numberOfAudioChannels, true);

            // sample rate 
            view.setUint32(24, sampleRate, true);

            // byte rate (sample rate * block align)
            view.setUint32(28, sampleRate * 2, true);

            // block align (channel count * bytes per sample) 
            view.setUint16(32, numberOfAudioChannels * 2, true);

            // bits per sample 
            view.setUint16(34, 16, true);

            // data sub-chunk
            // data chunk identifier 
            writeUTFBytes(view, 36, 'data');

            // data chunk length 
            view.setUint32(40, interleavedLength * 2, true);

            // write the PCM samples
            var lng = interleavedLength;
            var index = 44;
            var volume = 1;
            for (var i = 0; i < lng; i++) {
                view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);
                index += 2;
            }

            if (cb) {
                return cb({
                    buffer: buffer,
                    view: view
                });
            }

            postMessage({
                buffer: buffer,
                view: view
            });
        }

        if (isEdge || isOpera || isSafari || config.noWorker) {
            mergeAudioBuffers(config, function(data) {
                callback(data.buffer, data.view);
            });
            return;
        }


        var webWorker = processInWebWorker(mergeAudioBuffers);

        webWorker.onmessage = function(event) {
            callback(event.data.buffer, event.data.view);

            // release memory
            URL.revokeObjectURL(webWorker.workerURL);
        };

        webWorker.postMessage(config);
    }

    function processInWebWorker(_function) {
        var workerURL = URL.createObjectURL(new Blob([_function.toString(),
            ';this.onmessage =  function (e) {' + _function.name + '(e.data);}'
        ], {
            type: 'application/javascript'
        }));

        var worker = new Worker(workerURL);
        worker.workerURL = workerURL;
        return worker;
    }

    /**
     * This method stops recording MediaStream.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof StereoAudioRecorder
     * @example
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     */
    this.stop = function(callback) {
        callback = callback || function() {};

        // stop recording
        recording = false;

        mergeLeftRightBuffers({
            desiredSampRate: desiredSampRate,
            sampleRate: sampleRate,
            numberOfAudioChannels: numberOfAudioChannels,
            internalInterleavedLength: recordingLength,
            leftBuffers: leftchannel,
            rightBuffers: numberOfAudioChannels === 1 ? [] : rightchannel
        }, function(buffer, view) {
            /**
             * @property {Blob} blob - The recorded blob object.
             * @memberof StereoAudioRecorder
             * @example
             * recorder.stop(function(){
             *     var blob = recorder.blob;
             * });
             */
            self.blob = new Blob([view], {
                type: 'audio/wav'
            });

            /**
             * @property {ArrayBuffer} buffer - The recorded buffer object.
             * @memberof StereoAudioRecorder
             * @example
             * recorder.stop(function(){
             *     var buffer = recorder.buffer;
             * });
             */
            self.buffer = new ArrayBuffer(view.buffer.byteLength);

            /**
             * @property {DataView} view - The recorded data-view object.
             * @memberof StereoAudioRecorder
             * @example
             * recorder.stop(function(){
             *     var view = recorder.view;
             * });
             */
            self.view = view;

            self.sampleRate = desiredSampRate || sampleRate;
            self.bufferSize = bufferSize;

            // recorded audio length
            self.length = recordingLength;

            isAudioProcessStarted = false;

            if (callback) {
                callback(self.blob);
            }
        });
    };

    if (!Storage.AudioContextConstructor) {
        Storage.AudioContextConstructor = new Storage.AudioContext();
    }

    var context = Storage.AudioContextConstructor;

    // creates an audio node from the microphone incoming stream
    var audioInput = context.createMediaStreamSource(mediaStream);

    var legalBufferValues = [0, 256, 512, 1024, 2048, 4096, 8192, 16384];

    /**
     * From the spec: This value controls how frequently the audioprocess event is
     * dispatched and how many sample-frames need to be processed each call.
     * Lower values for buffer size will result in a lower (better) latency.
     * Higher values will be necessary to avoid audio breakup and glitches
     * The size of the buffer (in sample-frames) which needs to
     * be processed each time onprocessaudio is called.
     * Legal values are (256, 512, 1024, 2048, 4096, 8192, 16384).
     * @property {number} bufferSize - Buffer-size for how frequently the audioprocess event is dispatched.
     * @memberof StereoAudioRecorder
     * @example
     * recorder = new StereoAudioRecorder(mediaStream, {
     *     bufferSize: 4096
     * });
     */

    // "0" means, let chrome decide the most accurate buffer-size for current platform.
    var bufferSize = typeof config.bufferSize === 'undefined' ? 4096 : config.bufferSize;

    if (legalBufferValues.indexOf(bufferSize) === -1) {
        if (!config.disableLogs) {
            console.warn('Legal values for buffer-size are ' + JSON.stringify(legalBufferValues, null, '\t'));
        }
    }

    if (context.createJavaScriptNode) {
        jsAudioNode = context.createJavaScriptNode(bufferSize, numberOfAudioChannels, numberOfAudioChannels);
    } else if (context.createScriptProcessor) {
        jsAudioNode = context.createScriptProcessor(bufferSize, numberOfAudioChannels, numberOfAudioChannels);
    } else {
        throw 'WebAudio API has no support on this browser.';
    }

    // connect the stream to the script processor
    audioInput.connect(jsAudioNode);

    if (!config.bufferSize) {
        bufferSize = jsAudioNode.bufferSize; // device buffer-size
    }

    /**
     * The sample rate (in sample-frames per second) at which the
     * AudioContext handles audio. It is assumed that all AudioNodes
     * in the context run at this rate. In making this assumption,
     * sample-rate converters or "varispeed" processors are not supported
     * in real-time processing.
     * The sampleRate parameter describes the sample-rate of the
     * linear PCM audio data in the buffer in sample-frames per second.
     * An implementation must support sample-rates in at least
     * the range 22050 to 96000.
     * @property {number} sampleRate - Buffer-size for how frequently the audioprocess event is dispatched.
     * @memberof StereoAudioRecorder
     * @example
     * recorder = new StereoAudioRecorder(mediaStream, {
     *     sampleRate: 44100
     * });
     */
    var sampleRate = typeof config.sampleRate !== 'undefined' ? config.sampleRate : context.sampleRate || 44100;

    if (sampleRate < 22050 || sampleRate > 96000) {
        // Ref: http://stackoverflow.com/a/26303918/552182
        if (!config.disableLogs) {
            console.warn('sample-rate must be under range 22050 and 96000.');
        }
    }

    if (!config.disableLogs) {
        console.log('sample-rate', sampleRate);
        console.log('buffer-size', bufferSize);

        if (config.desiredSampRate) {
            console.log('Desired sample-rate', config.desiredSampRate);
        }
    }

    var isPaused = false;
    /**
     * This method pauses the recording process.
     * @method
     * @memberof StereoAudioRecorder
     * @example
     * recorder.pause();
     */
    this.pause = function() {
        isPaused = true;
    };

    /**
     * This method resumes the recording process.
     * @method
     * @memberof StereoAudioRecorder
     * @example
     * recorder.resume();
     */
    this.resume = function() {
        if (isMediaStreamActive() === false) {
            throw 'Please make sure MediaStream is active.';
        }

        if (!recording) {
            if (!config.disableLogs) {
                console.log('Seems recording has been restarted.');
            }
            this.record();
            return;
        }

        isPaused = false;
    };

    /**
     * This method resets currently recorded data.
     * @method
     * @memberof StereoAudioRecorder
     * @example
     * recorder.clearRecordedData();
     */
    this.clearRecordedData = function() {
        config.checkForInactiveTracks = false;

        if (recording) {
            this.stop(clearRecordedDataCB);
        }

        clearRecordedDataCB();
    };

    function resetVariables() {
        leftchannel = [];
        rightchannel = [];
        recordingLength = 0;
        isAudioProcessStarted = false;
        recording = false;
        isPaused = false;
        context = null;

        self.leftchannel = leftchannel;
        self.rightchannel = rightchannel;
        self.numberOfAudioChannels = numberOfAudioChannels;
        self.desiredSampRate = desiredSampRate;
        self.sampleRate = sampleRate;
        self.recordingLength = recordingLength;

        intervalsBasedBuffers = {
            left: [],
            right: [],
            recordingLength: 0
        };
    }

    function clearRecordedDataCB() {
        if (jsAudioNode) {
            jsAudioNode.onaudioprocess = null;
            jsAudioNode.disconnect();
            jsAudioNode = null;
        }

        if (audioInput) {
            audioInput.disconnect();
            audioInput = null;
        }

        resetVariables();
    }

    // for debugging
    this.name = 'StereoAudioRecorder';
    this.toString = function() {
        return this.name;
    };

    var isAudioProcessStarted = false;

    function onAudioProcessDataAvailable(e) {
        if (isPaused) {
            return;
        }

        if (isMediaStreamActive() === false) {
            if (!config.disableLogs) {
                console.log('MediaStream seems stopped.');
            }
            jsAudioNode.disconnect();
            recording = false;
        }

        if (!recording) {
            if (audioInput) {
                audioInput.disconnect();
                audioInput = null;
            }
            return;
        }

        /**
         * This method is called on "onaudioprocess" event's first invocation.
         * @method {function} onAudioProcessStarted
         * @memberof StereoAudioRecorder
         * @example
         * recorder.onAudioProcessStarted: function() { };
         */
        if (!isAudioProcessStarted) {
            isAudioProcessStarted = true;
            if (config.onAudioProcessStarted) {
                config.onAudioProcessStarted();
            }

            if (config.initCallback) {
                config.initCallback();
            }
        }

        var left = e.inputBuffer.getChannelData(0);

        // we clone the samples
        var chLeft = new Float32Array(left);
        leftchannel.push(chLeft);

        if (numberOfAudioChannels === 2) {
            var right = e.inputBuffer.getChannelData(1);
            var chRight = new Float32Array(right);
            rightchannel.push(chRight);
        }

        recordingLength += bufferSize;

        // export raw PCM
        self.recordingLength = recordingLength;

        if (typeof config.timeSlice !== 'undefined') {
            intervalsBasedBuffers.recordingLength += bufferSize;
            intervalsBasedBuffers.left.push(chLeft);

            if (numberOfAudioChannels === 2) {
                intervalsBasedBuffers.right.push(chRight);
            }
        }
    }

    jsAudioNode.onaudioprocess = onAudioProcessDataAvailable;

    // to prevent self audio to be connected with speakers
    jsAudioNode.connect(context.destination);

    // export raw PCM
    this.leftchannel = leftchannel;
    this.rightchannel = rightchannel;
    this.numberOfAudioChannels = numberOfAudioChannels;
    this.desiredSampRate = desiredSampRate;
    this.sampleRate = sampleRate;
    self.recordingLength = recordingLength;

    // helper for intervals based blobs
    var intervalsBasedBuffers = {
        left: [],
        right: [],
        recordingLength: 0
    };

    // this looper is used to support intervals based blobs (via timeSlice+ondataavailable)
    function looper() {
        if (!recording || typeof config.ondataavailable !== 'function' || typeof config.timeSlice === 'undefined') {
            return;
        }

        if (intervalsBasedBuffers.left.length) {
            mergeLeftRightBuffers({
                desiredSampRate: desiredSampRate,
                sampleRate: sampleRate,
                numberOfAudioChannels: numberOfAudioChannels,
                internalInterleavedLength: intervalsBasedBuffers.recordingLength,
                leftBuffers: intervalsBasedBuffers.left,
                rightBuffers: numberOfAudioChannels === 1 ? [] : intervalsBasedBuffers.right
            }, function(buffer, view) {
                var blob = new Blob([view], {
                    type: 'audio/wav'
                });
                config.ondataavailable(blob);

                setTimeout(looper, config.timeSlice);
            });

            intervalsBasedBuffers = {
                left: [],
                right: [],
                recordingLength: 0
            };
        } else {
            setTimeout(looper, config.timeSlice);
        }
    }
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.StereoAudioRecorder = StereoAudioRecorder;
}

// _________________
// CanvasRecorder.js

/**
 * CanvasRecorder is a standalone class used by {@link RecordRTC} to bring HTML5-Canvas recording into video WebM. It uses HTML2Canvas library and runs top over {@link Whammy}.
 * @summary HTML2Canvas recording into video WebM.
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link http://www.MuazKhan.com|Muaz Khan}
 * @typedef CanvasRecorder
 * @class
 * @example
 * var recorder = new CanvasRecorder(htmlElement, { disableLogs: true, useWhammyRecorder: true });
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {HTMLElement} htmlElement - querySelector/getElementById/getElementsByTagName[0]/etc.
 * @param {object} config - {disableLogs:true, initCallback: function}
 */

function CanvasRecorder(htmlElement, config) {
    if (typeof html2canvas === 'undefined') {
        throw 'Please link: https://cdn.webrtc-experiment.com/screenshot.js';
    }

    config = config || {};
    if (!config.frameInterval) {
        config.frameInterval = 10;
    }

    // via DetectRTC.js
    var isCanvasSupportsStreamCapturing = false;
    ['captureStream', 'mozCaptureStream', 'webkitCaptureStream'].forEach(function(item) {
        if (item in document.createElement('canvas')) {
            isCanvasSupportsStreamCapturing = true;
        }
    });

    var _isChrome = (!!window.webkitRTCPeerConnection || !!window.webkitGetUserMedia) && !!window.chrome;

    var chromeVersion = 50;
    var matchArray = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
    if (_isChrome && matchArray && matchArray[2]) {
        chromeVersion = parseInt(matchArray[2], 10);
    }

    if (_isChrome && chromeVersion < 52) {
        isCanvasSupportsStreamCapturing = false;
    }

    var globalCanvas, mediaStreamRecorder;

    if (isCanvasSupportsStreamCapturing) {
        if (!config.disableLogs) {
            console.log('Your browser supports both MediRecorder API and canvas.captureStream!');
        }

        if (htmlElement instanceof HTMLCanvasElement) {
            globalCanvas = htmlElement;
        } else if (htmlElement instanceof CanvasRenderingContext2D) {
            globalCanvas = htmlElement.canvas;
        } else {
            throw 'Please pass either HTMLCanvasElement or CanvasRenderingContext2D.';
        }
    } else if (!!navigator.mozGetUserMedia) {
        if (!config.disableLogs) {
            console.error('Canvas recording is NOT supported in Firefox.');
        }
    }

    var isRecording;

    /**
     * This method records Canvas.
     * @method
     * @memberof CanvasRecorder
     * @example
     * recorder.record();
     */
    this.record = function() {
        isRecording = true;

        if (isCanvasSupportsStreamCapturing && !config.useWhammyRecorder) {
            // CanvasCaptureMediaStream
            var canvasMediaStream;
            if ('captureStream' in globalCanvas) {
                canvasMediaStream = globalCanvas.captureStream(25); // 25 FPS
            } else if ('mozCaptureStream' in globalCanvas) {
                canvasMediaStream = globalCanvas.mozCaptureStream(25);
            } else if ('webkitCaptureStream' in globalCanvas) {
                canvasMediaStream = globalCanvas.webkitCaptureStream(25);
            }

            try {
                var mdStream = new MediaStream();
                mdStream.addTrack(canvasMediaStream.getVideoTracks()[0]);
                canvasMediaStream = mdStream;
            } catch (e) {}

            if (!canvasMediaStream) {
                throw 'captureStream API are NOT available.';
            }

            // Note: Jan 18, 2016 status is that, 
            // Firefox MediaRecorder API can't record CanvasCaptureMediaStream object.
            mediaStreamRecorder = new MediaStreamRecorder(canvasMediaStream, {
                mimeType: 'video/webm'
            });
            mediaStreamRecorder.record();
        } else {
            whammy.frames = [];
            lastTime = new Date().getTime();
            drawCanvasFrame();
        }

        if (config.initCallback) {
            config.initCallback();
        }
    };

    this.getWebPImages = function(callback) {
        if (htmlElement.nodeName.toLowerCase() !== 'canvas') {
            callback();
            return;
        }

        var framesLength = whammy.frames.length;
        whammy.frames.forEach(function(frame, idx) {
            var framesRemaining = framesLength - idx;
            if (!config.disableLogs) {
                console.log(framesRemaining + '/' + framesLength + ' frames remaining');
            }

            if (config.onEncodingCallback) {
                config.onEncodingCallback(framesRemaining, framesLength);
            }

            var webp = frame.image.toDataURL('image/webp', 1);
            whammy.frames[idx].image = webp;
        });

        if (!config.disableLogs) {
            console.log('Generating WebM');
        }

        callback();
    };

    /**
     * This method stops recording Canvas.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof CanvasRecorder
     * @example
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     */
    this.stop = function(callback) {
        isRecording = false;

        var that = this;

        if (isCanvasSupportsStreamCapturing && mediaStreamRecorder) {
            mediaStreamRecorder.stop(callback);
            return;
        }

        this.getWebPImages(function() {
            /**
             * @property {Blob} blob - Recorded frames in video/webm blob.
             * @memberof CanvasRecorder
             * @example
             * recorder.stop(function() {
             *     var blob = recorder.blob;
             * });
             */
            whammy.compile(function(blob) {
                if (!config.disableLogs) {
                    console.log('Recording finished!');
                }

                that.blob = blob;

                if (that.blob.forEach) {
                    that.blob = new Blob([], {
                        type: 'video/webm'
                    });
                }

                if (callback) {
                    callback(that.blob);
                }

                whammy.frames = [];
            });
        });
    };

    var isPausedRecording = false;

    /**
     * This method pauses the recording process.
     * @method
     * @memberof CanvasRecorder
     * @example
     * recorder.pause();
     */
    this.pause = function() {
        isPausedRecording = true;

        if (mediaStreamRecorder instanceof MediaStreamRecorder) {
            mediaStreamRecorder.pause();
            return;
        }
    };

    /**
     * This method resumes the recording process.
     * @method
     * @memberof CanvasRecorder
     * @example
     * recorder.resume();
     */
    this.resume = function() {
        isPausedRecording = false;

        if (mediaStreamRecorder instanceof MediaStreamRecorder) {
            mediaStreamRecorder.resume();
            return;
        }

        if (!isRecording) {
            this.record();
        }
    };

    /**
     * This method resets currently recorded data.
     * @method
     * @memberof CanvasRecorder
     * @example
     * recorder.clearRecordedData();
     */
    this.clearRecordedData = function() {
        if (isRecording) {
            this.stop(clearRecordedDataCB);
        }
        clearRecordedDataCB();
    };

    function clearRecordedDataCB() {
        whammy.frames = [];
        isRecording = false;
        isPausedRecording = false;
    }

    // for debugging
    this.name = 'CanvasRecorder';
    this.toString = function() {
        return this.name;
    };

    function cloneCanvas() {
        //create a new canvas
        var newCanvas = document.createElement('canvas');
        var context = newCanvas.getContext('2d');

        //set dimensions
        newCanvas.width = htmlElement.width;
        newCanvas.height = htmlElement.height;

        //apply the old canvas to the new one
        context.drawImage(htmlElement, 0, 0);

        //return the new canvas
        return newCanvas;
    }

    function drawCanvasFrame() {
        if (isPausedRecording) {
            lastTime = new Date().getTime();
            return setTimeout(drawCanvasFrame, 500);
        }

        if (htmlElement.nodeName.toLowerCase() === 'canvas') {
            var duration = new Date().getTime() - lastTime;
            // via #206, by Jack i.e. @Seymourr
            lastTime = new Date().getTime();

            whammy.frames.push({
                image: cloneCanvas(),
                duration: duration
            });

            if (isRecording) {
                setTimeout(drawCanvasFrame, config.frameInterval);
            }
            return;
        }

        html2canvas(htmlElement, {
            grabMouse: typeof config.showMousePointer === 'undefined' || config.showMousePointer,
            onrendered: function(canvas) {
                var duration = new Date().getTime() - lastTime;
                if (!duration) {
                    return setTimeout(drawCanvasFrame, config.frameInterval);
                }

                // via #206, by Jack i.e. @Seymourr
                lastTime = new Date().getTime();

                whammy.frames.push({
                    image: canvas.toDataURL('image/webp', 1),
                    duration: duration
                });

                if (isRecording) {
                    setTimeout(drawCanvasFrame, config.frameInterval);
                }
            }
        });
    }

    var lastTime = new Date().getTime();

    var whammy = new Whammy.Video(100);
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.CanvasRecorder = CanvasRecorder;
}

// _________________
// WhammyRecorder.js

/**
 * WhammyRecorder is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It runs top over {@link Whammy}.
 * @summary Video recording feature in Chrome.
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link http://www.MuazKhan.com|Muaz Khan}
 * @typedef WhammyRecorder
 * @class
 * @example
 * var recorder = new WhammyRecorder(mediaStream);
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
 * @param {object} config - {disableLogs: true, initCallback: function, video: HTMLVideoElement, etc.}
 */

function WhammyRecorder(mediaStream, config) {

    config = config || {};

    if (!config.frameInterval) {
        config.frameInterval = 10;
    }

    if (!config.disableLogs) {
        console.log('Using frames-interval:', config.frameInterval);
    }

    /**
     * This method records video.
     * @method
     * @memberof WhammyRecorder
     * @example
     * recorder.record();
     */
    this.record = function() {
        if (!config.width) {
            config.width = 320;
        }

        if (!config.height) {
            config.height = 240;
        }

        if (!config.video) {
            config.video = {
                width: config.width,
                height: config.height
            };
        }

        if (!config.canvas) {
            config.canvas = {
                width: config.width,
                height: config.height
            };
        }

        canvas.width = config.canvas.width || 320;
        canvas.height = config.canvas.height || 240;

        context = canvas.getContext('2d');

        // setting defaults
        if (config.video && config.video instanceof HTMLVideoElement) {
            video = config.video.cloneNode();

            if (config.initCallback) {
                config.initCallback();
            }
        } else {
            video = document.createElement('video');

            setSrcObject(mediaStream, video);

            video.onloadedmetadata = function() { // "onloadedmetadata" may NOT work in FF?
                if (config.initCallback) {
                    config.initCallback();
                }
            };

            video.width = config.video.width;
            video.height = config.video.height;
        }

        video.muted = true;
        video.play();

        lastTime = new Date().getTime();
        whammy = new Whammy.Video();

        if (!config.disableLogs) {
            console.log('canvas resolutions', canvas.width, '*', canvas.height);
            console.log('video width/height', video.width || canvas.width, '*', video.height || canvas.height);
        }

        drawFrames(config.frameInterval);
    };

    /**
     * Draw and push frames to Whammy
     * @param {integer} frameInterval - set minimum interval (in milliseconds) between each time we push a frame to Whammy
     */
    function drawFrames(frameInterval) {
        frameInterval = typeof frameInterval !== 'undefined' ? frameInterval : 10;

        var duration = new Date().getTime() - lastTime;
        if (!duration) {
            return setTimeout(drawFrames, frameInterval, frameInterval);
        }

        if (isPausedRecording) {
            lastTime = new Date().getTime();
            return setTimeout(drawFrames, 100);
        }

        // via #206, by Jack i.e. @Seymourr
        lastTime = new Date().getTime();

        if (video.paused) {
            // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316
            // Tweak for Android Chrome
            video.play();
        }

        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        whammy.frames.push({
            duration: duration,
            image: canvas.toDataURL('image/webp')
        });

        if (!isStopDrawing) {
            setTimeout(drawFrames, frameInterval, frameInterval);
        }
    }

    function asyncLoop(o) {
        var i = -1,
            length = o.length;

        (function loop() {
            i++;
            if (i === length) {
                o.callback();
                return;
            }

            // "setTimeout" added by Jim McLeod
            setTimeout(function() {
                o.functionToLoop(loop, i);
            }, 1);
        })();
    }


    /**
     * remove black frames from the beginning to the specified frame
     * @param {Array} _frames - array of frames to be checked
     * @param {number} _framesToCheck - number of frame until check will be executed (-1 - will drop all frames until frame not matched will be found)
     * @param {number} _pixTolerance - 0 - very strict (only black pixel color) ; 1 - all
     * @param {number} _frameTolerance - 0 - very strict (only black frame color) ; 1 - all
     * @returns {Array} - array of frames
     */
    // pull#293 by @volodalexey
    function dropBlackFrames(_frames, _framesToCheck, _pixTolerance, _frameTolerance, callback) {
        var localCanvas = document.createElement('canvas');
        localCanvas.width = canvas.width;
        localCanvas.height = canvas.height;
        var context2d = localCanvas.getContext('2d');
        var resultFrames = [];

        var checkUntilNotBlack = _framesToCheck === -1;
        var endCheckFrame = (_framesToCheck && _framesToCheck > 0 && _framesToCheck <= _frames.length) ?
            _framesToCheck : _frames.length;
        var sampleColor = {
            r: 0,
            g: 0,
            b: 0
        };
        var maxColorDifference = Math.sqrt(
            Math.pow(255, 2) +
            Math.pow(255, 2) +
            Math.pow(255, 2)
        );
        var pixTolerance = _pixTolerance && _pixTolerance >= 0 && _pixTolerance <= 1 ? _pixTolerance : 0;
        var frameTolerance = _frameTolerance && _frameTolerance >= 0 && _frameTolerance <= 1 ? _frameTolerance : 0;
        var doNotCheckNext = false;

        asyncLoop({
            length: endCheckFrame,
            functionToLoop: function(loop, f) {
                var matchPixCount, endPixCheck, maxPixCount;

                var finishImage = function() {
                    if (!doNotCheckNext && maxPixCount - matchPixCount <= maxPixCount * frameTolerance) {
                        // console.log('removed black frame : ' + f + ' ; frame duration ' + _frames[f].duration);
                    } else {
                        // console.log('frame is passed : ' + f);
                        if (checkUntilNotBlack) {
                            doNotCheckNext = true;
                        }
                        resultFrames.push(_frames[f]);
                    }
                    loop();
                };

                if (!doNotCheckNext) {
                    var image = new Image();
                    image.onload = function() {
                        context2d.drawImage(image, 0, 0, canvas.width, canvas.height);
                        var imageData = context2d.getImageData(0, 0, canvas.width, canvas.height);
                        matchPixCount = 0;
                        endPixCheck = imageData.data.length;
                        maxPixCount = imageData.data.length / 4;

                        for (var pix = 0; pix < endPixCheck; pix += 4) {
                            var currentColor = {
                                r: imageData.data[pix],
                                g: imageData.data[pix + 1],
                                b: imageData.data[pix + 2]
                            };
                            var colorDifference = Math.sqrt(
                                Math.pow(currentColor.r - sampleColor.r, 2) +
                                Math.pow(currentColor.g - sampleColor.g, 2) +
                                Math.pow(currentColor.b - sampleColor.b, 2)
                            );
                            // difference in color it is difference in color vectors (r1,g1,b1) <=> (r2,g2,b2)
                            if (colorDifference <= maxColorDifference * pixTolerance) {
                                matchPixCount++;
                            }
                        }
                        finishImage();
                    };
                    image.src = _frames[f].image;
                } else {
                    finishImage();
                }
            },
            callback: function() {
                resultFrames = resultFrames.concat(_frames.slice(endCheckFrame));

                if (resultFrames.length <= 0) {
                    // at least one last frame should be available for next manipulation
                    // if total duration of all frames will be < 1000 than ffmpeg doesn't work well...
                    resultFrames.push(_frames[_frames.length - 1]);
                }
                callback(resultFrames);
            }
        });
    }

    var isStopDrawing = false;

    /**
     * This method stops recording video.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof WhammyRecorder
     * @example
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     */
    this.stop = function(callback) {
        callback = callback || function() {};

        isStopDrawing = true;

        var _this = this;
        // analyse of all frames takes some time!
        setTimeout(function() {
            // e.g. dropBlackFrames(frames, 10, 1, 1) - will cut all 10 frames
            // e.g. dropBlackFrames(frames, 10, 0.5, 0.5) - will analyse 10 frames
            // e.g. dropBlackFrames(frames, 10) === dropBlackFrames(frames, 10, 0, 0) - will analyse 10 frames with strict black color
            dropBlackFrames(whammy.frames, -1, null, null, function(frames) {
                whammy.frames = frames;

                // to display advertisement images!
                if (config.advertisement && config.advertisement.length) {
                    whammy.frames = config.advertisement.concat(whammy.frames);
                }

                /**
                 * @property {Blob} blob - Recorded frames in video/webm blob.
                 * @memberof WhammyRecorder
                 * @example
                 * recorder.stop(function() {
                 *     var blob = recorder.blob;
                 * });
                 */
                whammy.compile(function(blob) {
                    _this.blob = blob;

                    if (_this.blob.forEach) {
                        _this.blob = new Blob([], {
                            type: 'video/webm'
                        });
                    }

                    if (callback) {
                        callback(_this.blob);
                    }
                });
            });
        }, 10);
    };

    var isPausedRecording = false;

    /**
     * This method pauses the recording process.
     * @method
     * @memberof WhammyRecorder
     * @example
     * recorder.pause();
     */
    this.pause = function() {
        isPausedRecording = true;
    };

    /**
     * This method resumes the recording process.
     * @method
     * @memberof WhammyRecorder
     * @example
     * recorder.resume();
     */
    this.resume = function() {
        isPausedRecording = false;

        if (isStopDrawing) {
            this.record();
        }
    };

    /**
     * This method resets currently recorded data.
     * @method
     * @memberof WhammyRecorder
     * @example
     * recorder.clearRecordedData();
     */
    this.clearRecordedData = function() {
        if (!isStopDrawing) {
            this.stop(clearRecordedDataCB);
        }
        clearRecordedDataCB();
    };

    function clearRecordedDataCB() {
        whammy.frames = [];
        isStopDrawing = true;
        isPausedRecording = false;
    }

    // for debugging
    this.name = 'WhammyRecorder';
    this.toString = function() {
        return this.name;
    };

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');

    var video;
    var lastTime;
    var whammy;
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.WhammyRecorder = WhammyRecorder;
}

// https://github.com/antimatter15/whammy/blob/master/LICENSE
// _________
// Whammy.js

// todo: Firefox now supports webp for webm containers!
// their MediaRecorder implementation works well!
// should we provide an option to record via Whammy.js or MediaRecorder API is a better solution?

/**
 * Whammy is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It is written by {@link https://github.com/antimatter15|antimatter15}
 * @summary A real time javascript webm encoder based on a canvas hack.
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link http://www.MuazKhan.com|Muaz Khan}
 * @typedef Whammy
 * @class
 * @example
 * var recorder = new Whammy().Video(15);
 * recorder.add(context || canvas || dataURL);
 * var output = recorder.compile();
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */

var Whammy = (function() {
    // a more abstract-ish API

    function WhammyVideo(duration) {
        this.frames = [];
        this.duration = duration || 1;
        this.quality = 0.8;
    }

    /**
     * Pass Canvas or Context or image/webp(string) to {@link Whammy} encoder.
     * @method
     * @memberof Whammy
     * @example
     * recorder = new Whammy().Video(0.8, 100);
     * recorder.add(canvas || context || 'image/webp');
     * @param {string} frame - Canvas || Context || image/webp
     * @param {number} duration - Stick a duration (in milliseconds)
     */
    WhammyVideo.prototype.add = function(frame, duration) {
        if ('canvas' in frame) { //CanvasRenderingContext2D
            frame = frame.canvas;
        }

        if ('toDataURL' in frame) {
            frame = frame.toDataURL('image/webp', this.quality);
        }

        if (!(/^data:image\/webp;base64,/ig).test(frame)) {
            throw 'Input must be formatted properly as a base64 encoded DataURI of type image/webp';
        }
        this.frames.push({
            image: frame,
            duration: duration || this.duration
        });
    };

    function processInWebWorker(_function) {
        var blob = URL.createObjectURL(new Blob([_function.toString(),
            'this.onmessage =  function (e) {' + _function.name + '(e.data);}'
        ], {
            type: 'application/javascript'
        }));

        var worker = new Worker(blob);
        URL.revokeObjectURL(blob);
        return worker;
    }

    function whammyInWebWorker(frames) {
        function ArrayToWebM(frames) {
            var info = checkFrames(frames);
            if (!info) {
                return [];
            }

            var clusterMaxDuration = 30000;

            var EBML = [{
                'id': 0x1a45dfa3, // EBML
                'data': [{
                    'data': 1,
                    'id': 0x4286 // EBMLVersion
                }, {
                    'data': 1,
                    'id': 0x42f7 // EBMLReadVersion
                }, {
                    'data': 4,
                    'id': 0x42f2 // EBMLMaxIDLength
                }, {
                    'data': 8,
                    'id': 0x42f3 // EBMLMaxSizeLength
                }, {
                    'data': 'webm',
                    'id': 0x4282 // DocType
                }, {
                    'data': 2,
                    'id': 0x4287 // DocTypeVersion
                }, {
                    'data': 2,
                    'id': 0x4285 // DocTypeReadVersion
                }]
            }, {
                'id': 0x18538067, // Segment
                'data': [{
                    'id': 0x1549a966, // Info
                    'data': [{
                        'data': 1e6, //do things in millisecs (num of nanosecs for duration scale)
                        'id': 0x2ad7b1 // TimecodeScale
                    }, {
                        'data': 'whammy',
                        'id': 0x4d80 // MuxingApp
                    }, {
                        'data': 'whammy',
                        'id': 0x5741 // WritingApp
                    }, {
                        'data': doubleToString(info.duration),
                        'id': 0x4489 // Duration
                    }]
                }, {
                    'id': 0x1654ae6b, // Tracks
                    'data': [{
                        'id': 0xae, // TrackEntry
                        'data': [{
                            'data': 1,
                            'id': 0xd7 // TrackNumber
                        }, {
                            'data': 1,
                            'id': 0x73c5 // TrackUID
                        }, {
                            'data': 0,
                            'id': 0x9c // FlagLacing
                        }, {
                            'data': 'und',
                            'id': 0x22b59c // Language
                        }, {
                            'data': 'V_VP8',
                            'id': 0x86 // CodecID
                        }, {
                            'data': 'VP8',
                            'id': 0x258688 // CodecName
                        }, {
                            'data': 1,
                            'id': 0x83 // TrackType
                        }, {
                            'id': 0xe0, // Video
                            'data': [{
                                'data': info.width,
                                'id': 0xb0 // PixelWidth
                            }, {
                                'data': info.height,
                                'id': 0xba // PixelHeight
                            }]
                        }]
                    }]
                }]
            }];

            //Generate clusters (max duration)
            var frameNumber = 0;
            var clusterTimecode = 0;
            while (frameNumber < frames.length) {

                var clusterFrames = [];
                var clusterDuration = 0;
                do {
                    clusterFrames.push(frames[frameNumber]);
                    clusterDuration += frames[frameNumber].duration;
                    frameNumber++;
                } while (frameNumber < frames.length && clusterDuration < clusterMaxDuration);

                var clusterCounter = 0;
                var cluster = {
                    'id': 0x1f43b675, // Cluster
                    'data': getClusterData(clusterTimecode, clusterCounter, clusterFrames)
                }; //Add cluster to segment
                EBML[1].data.push(cluster);
                clusterTimecode += clusterDuration;
            }

            return generateEBML(EBML);
        }

        function getClusterData(clusterTimecode, clusterCounter, clusterFrames) {
            return [{
                'data': clusterTimecode,
                'id': 0xe7 // Timecode
            }].concat(clusterFrames.map(function(webp) {
                var block = makeSimpleBlock({
                    discardable: 0,
                    frame: webp.data.slice(4),
                    invisible: 0,
                    keyframe: 1,
                    lacing: 0,
                    trackNum: 1,
                    timecode: Math.round(clusterCounter)
                });
                clusterCounter += webp.duration;
                return {
                    data: block,
                    id: 0xa3
                };
            }));
        }

        // sums the lengths of all the frames and gets the duration

        function checkFrames(frames) {
            if (!frames[0]) {
                postMessage({
                    error: 'Something went wrong. Maybe WebP format is not supported in the current browser.'
                });
                return;
            }

            var width = frames[0].width,
                height = frames[0].height,
                duration = frames[0].duration;

            for (var i = 1; i < frames.length; i++) {
                duration += frames[i].duration;
            }
            return {
                duration: duration,
                width: width,
                height: height
            };
        }

        function numToBuffer(num) {
            var parts = [];
            while (num > 0) {
                parts.push(num & 0xff);
                num = num >> 8;
            }
            return new Uint8Array(parts.reverse());
        }

        function strToBuffer(str) {
            return new Uint8Array(str.split('').map(function(e) {
                return e.charCodeAt(0);
            }));
        }

        function bitsToBuffer(bits) {
            var data = [];
            var pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : '';
            bits = pad + bits;
            for (var i = 0; i < bits.length; i += 8) {
                data.push(parseInt(bits.substr(i, 8), 2));
            }
            return new Uint8Array(data);
        }

        function generateEBML(json) {
            var ebml = [];
            for (var i = 0; i < json.length; i++) {
                var data = json[i].data;

                if (typeof data === 'object') {
                    data = generateEBML(data);
                }

                if (typeof data === 'number') {
                    data = bitsToBuffer(data.toString(2));
                }

                if (typeof data === 'string') {
                    data = strToBuffer(data);
                }

                var len = data.size || data.byteLength || data.length;
                var zeroes = Math.ceil(Math.ceil(Math.log(len) / Math.log(2)) / 8);
                var sizeToString = len.toString(2);
                var padded = (new Array((zeroes * 7 + 7 + 1) - sizeToString.length)).join('0') + sizeToString;
                var size = (new Array(zeroes)).join('0') + '1' + padded;

                ebml.push(numToBuffer(json[i].id));
                ebml.push(bitsToBuffer(size));
                ebml.push(data);
            }

            return new Blob(ebml, {
                type: 'video/webm'
            });
        }

        function toBinStrOld(bits) {
            var data = '';
            var pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : '';
            bits = pad + bits;
            for (var i = 0; i < bits.length; i += 8) {
                data += String.fromCharCode(parseInt(bits.substr(i, 8), 2));
            }
            return data;
        }

        function makeSimpleBlock(data) {
            var flags = 0;

            if (data.keyframe) {
                flags |= 128;
            }

            if (data.invisible) {
                flags |= 8;
            }

            if (data.lacing) {
                flags |= (data.lacing << 1);
            }

            if (data.discardable) {
                flags |= 1;
            }

            if (data.trackNum > 127) {
                throw 'TrackNumber > 127 not supported';
            }

            var out = [data.trackNum | 0x80, data.timecode >> 8, data.timecode & 0xff, flags].map(function(e) {
                return String.fromCharCode(e);
            }).join('') + data.frame;

            return out;
        }

        function parseWebP(riff) {
            var VP8 = riff.RIFF[0].WEBP[0];

            var frameStart = VP8.indexOf('\x9d\x01\x2a'); // A VP8 keyframe starts with the 0x9d012a header
            for (var i = 0, c = []; i < 4; i++) {
                c[i] = VP8.charCodeAt(frameStart + 3 + i);
            }

            var width, height, tmp;

            //the code below is literally copied verbatim from the bitstream spec
            tmp = (c[1] << 8) | c[0];
            width = tmp & 0x3FFF;
            tmp = (c[3] << 8) | c[2];
            height = tmp & 0x3FFF;
            return {
                width: width,
                height: height,
                data: VP8,
                riff: riff
            };
        }

        function getStrLength(string, offset) {
            return parseInt(string.substr(offset + 4, 4).split('').map(function(i) {
                var unpadded = i.charCodeAt(0).toString(2);
                return (new Array(8 - unpadded.length + 1)).join('0') + unpadded;
            }).join(''), 2);
        }

        function parseRIFF(string) {
            var offset = 0;
            var chunks = {};

            while (offset < string.length) {
                var id = string.substr(offset, 4);
                var len = getStrLength(string, offset);
                var data = string.substr(offset + 4 + 4, len);
                offset += 4 + 4 + len;
                chunks[id] = chunks[id] || [];

                if (id === 'RIFF' || id === 'LIST') {
                    chunks[id].push(parseRIFF(data));
                } else {
                    chunks[id].push(data);
                }
            }
            return chunks;
        }

        function doubleToString(num) {
            return [].slice.call(
                new Uint8Array((new Float64Array([num])).buffer), 0).map(function(e) {
                return String.fromCharCode(e);
            }).reverse().join('');
        }

        var webm = new ArrayToWebM(frames.map(function(frame) {
            var webp = parseWebP(parseRIFF(atob(frame.image.slice(23))));
            webp.duration = frame.duration;
            return webp;
        }));

        postMessage(webm);
    }

    /**
     * Encodes frames in WebM container. It uses WebWorkinvoke to invoke 'ArrayToWebM' method.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof Whammy
     * @example
     * recorder = new Whammy().Video(0.8, 100);
     * recorder.compile(function(blob) {
     *    // blob.size - blob.type
     * });
     */
    WhammyVideo.prototype.compile = function(callback) {
        var webWorker = processInWebWorker(whammyInWebWorker);

        webWorker.onmessage = function(event) {
            if (event.data.error) {
                console.error(event.data.error);
                return;
            }
            callback(event.data);
        };

        webWorker.postMessage(this.frames);
    };

    return {
        /**
         * A more abstract-ish API.
         * @method
         * @memberof Whammy
         * @example
         * recorder = new Whammy().Video(0.8, 100);
         * @param {?number} speed - 0.8
         * @param {?number} quality - 100
         */
        Video: WhammyVideo
    };
})();

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.Whammy = Whammy;
}

// ______________ (indexed-db)
// DiskStorage.js

/**
 * DiskStorage is a standalone object used by {@link RecordRTC} to store recorded blobs in IndexedDB storage.
 * @summary Writing blobs into IndexedDB.
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link http://www.MuazKhan.com|Muaz Khan}
 * @example
 * DiskStorage.Store({
 *     audioBlob: yourAudioBlob,
 *     videoBlob: yourVideoBlob,
 *     gifBlob  : yourGifBlob
 * });
 * DiskStorage.Fetch(function(dataURL, type) {
 *     if(type === 'audioBlob') { }
 *     if(type === 'videoBlob') { }
 *     if(type === 'gifBlob')   { }
 * });
 * // DiskStorage.dataStoreName = 'recordRTC';
 * // DiskStorage.onError = function(error) { };
 * @property {function} init - This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.
 * @property {function} Fetch - This method fetches stored blobs from IndexedDB.
 * @property {function} Store - This method stores blobs in IndexedDB.
 * @property {function} onError - This function is invoked for any known/unknown error.
 * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */


var DiskStorage = {
    /**
     * This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.
     * @method
     * @memberof DiskStorage
     * @internal
     * @example
     * DiskStorage.init();
     */
    init: function() {
        var self = this;

        if (typeof indexedDB === 'undefined' || typeof indexedDB.open === 'undefined') {
            console.error('IndexedDB API are not available in this browser.');
            return;
        }

        var dbVersion = 1;
        var dbName = this.dbName || location.href.replace(/\/|:|#|%|\.|\[|\]/g, ''),
            db;
        var request = indexedDB.open(dbName, dbVersion);

        function createObjectStore(dataBase) {
            dataBase.createObjectStore(self.dataStoreName);
        }

        function putInDB() {
            var transaction = db.transaction([self.dataStoreName], 'readwrite');

            if (self.videoBlob) {
                transaction.objectStore(self.dataStoreName).put(self.videoBlob, 'videoBlob');
            }

            if (self.gifBlob) {
                transaction.objectStore(self.dataStoreName).put(self.gifBlob, 'gifBlob');
            }

            if (self.audioBlob) {
                transaction.objectStore(self.dataStoreName).put(self.audioBlob, 'audioBlob');
            }

            function getFromStore(portionName) {
                transaction.objectStore(self.dataStoreName).get(portionName).onsuccess = function(event) {
                    if (self.callback) {
                        self.callback(event.target.result, portionName);
                    }
                };
            }

            getFromStore('audioBlob');
            getFromStore('videoBlob');
            getFromStore('gifBlob');
        }

        request.onerror = self.onError;

        request.onsuccess = function() {
            db = request.result;
            db.onerror = self.onError;

            if (db.setVersion) {
                if (db.version !== dbVersion) {
                    var setVersion = db.setVersion(dbVersion);
                    setVersion.onsuccess = function() {
                        createObjectStore(db);
                        putInDB();
                    };
                } else {
                    putInDB();
                }
            } else {
                putInDB();
            }
        };
        request.onupgradeneeded = function(event) {
            createObjectStore(event.target.result);
        };
    },
    /**
     * This method fetches stored blobs from IndexedDB.
     * @method
     * @memberof DiskStorage
     * @internal
     * @example
     * DiskStorage.Fetch(function(dataURL, type) {
     *     if(type === 'audioBlob') { }
     *     if(type === 'videoBlob') { }
     *     if(type === 'gifBlob')   { }
     * });
     */
    Fetch: function(callback) {
        this.callback = callback;
        this.init();

        return this;
    },
    /**
     * This method stores blobs in IndexedDB.
     * @method
     * @memberof DiskStorage
     * @internal
     * @example
     * DiskStorage.Store({
     *     audioBlob: yourAudioBlob,
     *     videoBlob: yourVideoBlob,
     *     gifBlob  : yourGifBlob
     * });
     */
    Store: function(config) {
        this.audioBlob = config.audioBlob;
        this.videoBlob = config.videoBlob;
        this.gifBlob = config.gifBlob;

        this.init();

        return this;
    },
    /**
     * This function is invoked for any known/unknown error.
     * @method
     * @memberof DiskStorage
     * @internal
     * @example
     * DiskStorage.onError = function(error){
     *     alerot( JSON.stringify(error) );
     * };
     */
    onError: function(error) {
        console.error(JSON.stringify(error, null, '\t'));
    },

    /**
     * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.
     * @memberof DiskStorage
     * @internal
     * @example
     * DiskStorage.dataStoreName = 'recordRTC';
     */
    dataStoreName: 'recordRTC',
    dbName: null
};

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.DiskStorage = DiskStorage;
}

// ______________
// GifRecorder.js

/**
 * GifRecorder is standalone calss used by {@link RecordRTC} to record video or canvas into animated gif.
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link http://www.MuazKhan.com|Muaz Khan}
 * @typedef GifRecorder
 * @class
 * @example
 * var recorder = new GifRecorder(mediaStream || canvas || context, { onGifPreview: function, onGifRecordingStarted: function, width: 1280, height: 720, frameRate: 200, quality: 10 });
 * recorder.record();
 * recorder.stop(function(blob) {
 *     img.src = URL.createObjectURL(blob);
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - MediaStream object or HTMLCanvasElement or CanvasRenderingContext2D.
 * @param {object} config - {disableLogs:true, initCallback: function, width: 320, height: 240, frameRate: 200, quality: 10}
 */

function GifRecorder(mediaStream, config) {
    if (typeof GIFEncoder === 'undefined') {
        var script = document.createElement('script');
        script.src = 'https://cdn.webrtc-experiment.com/gif-recorder.js';
        (document.body || document.documentElement).appendChild(script);
    }

    config = config || {};

    var isHTMLObject = mediaStream instanceof CanvasRenderingContext2D || mediaStream instanceof HTMLCanvasElement;

    /**
     * This method records MediaStream.
     * @method
     * @memberof GifRecorder
     * @example
     * recorder.record();
     */
    this.record = function() {
        if (typeof GIFEncoder === 'undefined') {
            setTimeout(self.record, 1000);
            return;
        }

        if (!isLoadedMetaData) {
            setTimeout(self.record, 1000);
            return;
        }

        if (!isHTMLObject) {
            if (!config.width) {
                config.width = video.offsetWidth || 320;
            }

            if (!config.height) {
                config.height = video.offsetHeight || 240;
            }

            if (!config.video) {
                config.video = {
                    width: config.width,
                    height: config.height
                };
            }

            if (!config.canvas) {
                config.canvas = {
                    width: config.width,
                    height: config.height
                };
            }

            canvas.width = config.canvas.width || 320;
            canvas.height = config.canvas.height || 240;

            video.width = config.video.width || 320;
            video.height = config.video.height || 240;
        }

        // external library to record as GIF images
        gifEncoder = new GIFEncoder();

        // void setRepeat(int iter) 
        // Sets the number of times the set of GIF frames should be played. 
        // Default is 1; 0 means play indefinitely.
        gifEncoder.setRepeat(0);

        // void setFrameRate(Number fps) 
        // Sets frame rate in frames per second. 
        // Equivalent to setDelay(1000/fps).
        // Using "setDelay" instead of "setFrameRate"
        gifEncoder.setDelay(config.frameRate || 200);

        // void setQuality(int quality) 
        // Sets quality of color quantization (conversion of images to the 
        // maximum 256 colors allowed by the GIF specification). 
        // Lower values (minimum = 1) produce better colors, 
        // but slow processing significantly. 10 is the default, 
        // and produces good color mapping at reasonable speeds. 
        // Values greater than 20 do not yield significant improvements in speed.
        gifEncoder.setQuality(config.quality || 10);

        // Boolean start() 
        // This writes the GIF Header and returns false if it fails.
        gifEncoder.start();

        if (typeof config.onGifRecordingStarted === 'function') {
            config.onGifRecordingStarted();
        }

        startTime = Date.now();

        function drawVideoFrame(time) {
            if (self.clearedRecordedData === true) {
                return;
            }

            if (isPausedRecording) {
                return setTimeout(function() {
                    drawVideoFrame(time);
                }, 100);
            }

            lastAnimationFrame = requestAnimationFrame(drawVideoFrame);

            if (typeof lastFrameTime === undefined) {
                lastFrameTime = time;
            }

            // ~10 fps
            if (time - lastFrameTime < 90) {
                return;
            }

            if (!isHTMLObject && video.paused) {
                // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316
                // Tweak for Android Chrome
                video.play();
            }

            if (!isHTMLObject) {
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
            }

            if (config.onGifPreview) {
                config.onGifPreview(canvas.toDataURL('image/png'));
            }

            gifEncoder.addFrame(context);
            lastFrameTime = time;
        }

        lastAnimationFrame = requestAnimationFrame(drawVideoFrame);

        if (config.initCallback) {
            config.initCallback();
        }
    };

    /**
     * This method stops recording MediaStream.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof GifRecorder
     * @example
     * recorder.stop(function(blob) {
     *     img.src = URL.createObjectURL(blob);
     * });
     */
    this.stop = function(callback) {
        callback = callback || function() {};

        if (lastAnimationFrame) {
            cancelAnimationFrame(lastAnimationFrame);
        }

        endTime = Date.now();

        /**
         * @property {Blob} blob - The recorded blob object.
         * @memberof GifRecorder
         * @example
         * recorder.stop(function(){
         *     var blob = recorder.blob;
         * });
         */
        this.blob = new Blob([new Uint8Array(gifEncoder.stream().bin)], {
            type: 'image/gif'
        });

        callback(this.blob);

        // bug: find a way to clear old recorded blobs
        gifEncoder.stream().bin = [];
    };

    var isPausedRecording = false;

    /**
     * This method pauses the recording process.
     * @method
     * @memberof GifRecorder
     * @example
     * recorder.pause();
     */
    this.pause = function() {
        isPausedRecording = true;
    };

    /**
     * This method resumes the recording process.
     * @method
     * @memberof GifRecorder
     * @example
     * recorder.resume();
     */
    this.resume = function() {
        isPausedRecording = false;
    };

    /**
     * This method resets currently recorded data.
     * @method
     * @memberof GifRecorder
     * @example
     * recorder.clearRecordedData();
     */
    this.clearRecordedData = function() {
        self.clearedRecordedData = true;
        clearRecordedDataCB();
    };

    function clearRecordedDataCB() {
        if (gifEncoder) {
            gifEncoder.stream().bin = [];
        }
    }

    // for debugging
    this.name = 'GifRecorder';
    this.toString = function() {
        return this.name;
    };

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');

    if (isHTMLObject) {
        if (mediaStream instanceof CanvasRenderingContext2D) {
            context = mediaStream;
            canvas = context.canvas;
        } else if (mediaStream instanceof HTMLCanvasElement) {
            context = mediaStream.getContext('2d');
            canvas = mediaStream;
        }
    }

    var isLoadedMetaData = true;

    if (!isHTMLObject) {
        var video = document.createElement('video');
        video.muted = true;
        video.autoplay = true;

        isLoadedMetaData = false;
        video.onloadedmetadata = function() {
            isLoadedMetaData = true;
        };

        setSrcObject(mediaStream, video);

        video.play();
    }

    var lastAnimationFrame = null;
    var startTime, endTime, lastFrameTime;

    var gifEncoder;

    var self = this;
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.GifRecorder = GifRecorder;
}

// Last time updated: 2018-03-02 2:56:28 AM UTC

// ________________________
// MultiStreamsMixer v1.0.5

// Open-Sourced: https://github.com/muaz-khan/MultiStreamsMixer

// --------------------------------------------------
// Muaz Khan     - www.MuazKhan.com
// MIT License   - www.WebRTC-Experiment.com/licence
// --------------------------------------------------

function MultiStreamsMixer(arrayOfMediaStreams) {

    // requires: chrome://flags/#enable-experimental-web-platform-features

    var videos = [];
    var isStopDrawingFrames = false;

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.style = 'opacity:0;position:absolute;z-index:-1;top: -100000000;left:-1000000000; margin-top:-1000000000;margin-left:-1000000000;';
    (document.body || document.documentElement).appendChild(canvas);

    this.disableLogs = false;
    this.frameInterval = 10;

    this.width = 360;
    this.height = 240;

    // use gain node to prevent echo
    this.useGainNode = true;

    var self = this;

    // _____________________________
    // Cross-Browser-Declarations.js

    // WebAudio API representer
    var AudioContext = window.AudioContext;

    if (typeof AudioContext === 'undefined') {
        if (typeof webkitAudioContext !== 'undefined') {
            /*global AudioContext:true */
            AudioContext = webkitAudioContext;
        }

        if (typeof mozAudioContext !== 'undefined') {
            /*global AudioContext:true */
            AudioContext = mozAudioContext;
        }
    }

    /*jshint -W079 */
    var URL = window.URL;

    if (typeof URL === 'undefined' && typeof webkitURL !== 'undefined') {
        /*global URL:true */
        URL = webkitURL;
    }

    if (typeof navigator !== 'undefined' && typeof navigator.getUserMedia === 'undefined') { // maybe window.navigator?
        if (typeof navigator.webkitGetUserMedia !== 'undefined') {
            navigator.getUserMedia = navigator.webkitGetUserMedia;
        }

        if (typeof navigator.mozGetUserMedia !== 'undefined') {
            navigator.getUserMedia = navigator.mozGetUserMedia;
        }
    }

    var MediaStream = window.MediaStream;

    if (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {
        MediaStream = webkitMediaStream;
    }

    /*global MediaStream:true */
    if (typeof MediaStream !== 'undefined') {
        if (!('getVideoTracks' in MediaStream.prototype)) {
            MediaStream.prototype.getVideoTracks = function() {
                if (!this.getTracks) {
                    return [];
                }

                var tracks = [];
                this.getTracks.forEach(function(track) {
                    if (track.kind.toString().indexOf('video') !== -1) {
                        tracks.push(track);
                    }
                });
                return tracks;
            };

            MediaStream.prototype.getAudioTracks = function() {
                if (!this.getTracks) {
                    return [];
                }

                var tracks = [];
                this.getTracks.forEach(function(track) {
                    if (track.kind.toString().indexOf('audio') !== -1) {
                        tracks.push(track);
                    }
                });
                return tracks;
            };
        }

        // override "stop" method for all browsers
        if (typeof MediaStream.prototype.stop === 'undefined') {
            MediaStream.prototype.stop = function() {
                this.getTracks().forEach(function(track) {
                    track.stop();
                });
            };
        }
    }

    var Storage = {};

    if (typeof AudioContext !== 'undefined') {
        Storage.AudioContext = AudioContext;
    } else if (typeof webkitAudioContext !== 'undefined') {
        Storage.AudioContext = webkitAudioContext;
    }

    function setSrcObject(stream, element, ignoreCreateObjectURL) {
        if ('createObjectURL' in URL && !ignoreCreateObjectURL) {
            try {
                element.src = URL.createObjectURL(stream);
            } catch (e) {
                setSrcObject(stream, element, true);
                return;
            }
        } else if ('srcObject' in element) {
            element.srcObject = stream;
        } else if ('mozSrcObject' in element) {
            element.mozSrcObject = stream;
        } else {
            alert('createObjectURL/srcObject both are not supported.');
        }
    }

    this.startDrawingFrames = function() {
        drawVideosToCanvas();
    };

    function drawVideosToCanvas() {
        if (isStopDrawingFrames) {
            return;
        }

        var videosLength = videos.length;

        var fullcanvas = false;
        var remaining = [];
        videos.forEach(function(video) {
            if (!video.stream) {
                video.stream = {};
            }

            if (video.stream.fullcanvas) {
                fullcanvas = video;
            } else {
                remaining.push(video);
            }
        });

        if (fullcanvas) {
            canvas.width = fullcanvas.stream.width;
            canvas.height = fullcanvas.stream.height;
        } else if (remaining.length) {
            canvas.width = videosLength > 1 ? remaining[0].width * 2 : remaining[0].width;

            var height = 1;
            if (videosLength === 3 || videosLength === 4) {
                height = 2;
            }
            if (videosLength === 5 || videosLength === 6) {
                height = 3;
            }
            if (videosLength === 7 || videosLength === 8) {
                height = 4;
            }
            if (videosLength === 9 || videosLength === 10) {
                height = 5;
            }
            canvas.height = remaining[0].height * height;
        } else {
            canvas.width = self.width || 360;
            canvas.height = self.height || 240;
        }

        if (fullcanvas && fullcanvas instanceof HTMLVideoElement) {
            drawImage(fullcanvas);
        }

        remaining.forEach(function(video, idx) {
            drawImage(video, idx);
        });

        setTimeout(drawVideosToCanvas, self.frameInterval);
    }

    function drawImage(video, idx) {
        if (isStopDrawingFrames) {
            return;
        }

        var x = 0;
        var y = 0;
        var width = video.width;
        var height = video.height;

        if (idx === 1) {
            x = video.width;
        }

        if (idx === 2) {
            y = video.height;
        }

        if (idx === 3) {
            x = video.width;
            y = video.height;
        }

        if (idx === 4) {
            y = video.height * 2;
        }

        if (idx === 5) {
            x = video.width;
            y = video.height * 2;
        }

        if (idx === 6) {
            y = video.height * 3;
        }

        if (idx === 7) {
            x = video.width;
            y = video.height * 3;
        }

        if (typeof video.stream.left !== 'undefined') {
            x = video.stream.left;
        }

        if (typeof video.stream.top !== 'undefined') {
            y = video.stream.top;
        }

        if (typeof video.stream.width !== 'undefined') {
            width = video.stream.width;
        }

        if (typeof video.stream.height !== 'undefined') {
            height = video.stream.height;
        }

        context.drawImage(video, x, y, width, height);

        if (typeof video.stream.onRender === 'function') {
            video.stream.onRender(context, x, y, width, height, idx);
        }
    }

    function getMixedStream() {
        isStopDrawingFrames = false;
        var mixedVideoStream = getMixedVideoStream();

        var mixedAudioStream = getMixedAudioStream();
        if (mixedAudioStream) {
            mixedAudioStream.getAudioTracks().forEach(function(track) {
                mixedVideoStream.addTrack(track);
            });
        }

        var fullcanvas;
        arrayOfMediaStreams.forEach(function(stream) {
            if (stream.fullcanvas) {
                fullcanvas = true;
            }
        });

        return mixedVideoStream;
    }

    function getMixedVideoStream() {
        resetVideoStreams();

        var capturedStream;

        if ('captureStream' in canvas) {
            capturedStream = canvas.captureStream();
        } else if ('mozCaptureStream' in canvas) {
            capturedStream = canvas.mozCaptureStream();
        } else if (!self.disableLogs) {
            console.error('Upgrade to latest Chrome or otherwise enable this flag: chrome://flags/#enable-experimental-web-platform-features');
        }

        var videoStream = new MediaStream();

        capturedStream.getVideoTracks().forEach(function(track) {
            videoStream.addTrack(track);
        });

        canvas.stream = videoStream;

        return videoStream;
    }

    function getMixedAudioStream() {
        // via: @pehrsons
        if (!Storage.AudioContextConstructor) {
            Storage.AudioContextConstructor = new Storage.AudioContext();
        }

        self.audioContext = Storage.AudioContextConstructor;

        self.audioSources = [];

        if (self.useGainNode === true) {
            self.gainNode = self.audioContext.createGain();
            self.gainNode.connect(self.audioContext.destination);
            self.gainNode.gain.value = 0; // don't hear self
        }

        var audioTracksLength = 0;
        arrayOfMediaStreams.forEach(function(stream) {
            if (!stream.getAudioTracks().length) {
                return;
            }

            audioTracksLength++;

            var audioSource = self.audioContext.createMediaStreamSource(stream);

            if (self.useGainNode === true) {
                audioSource.connect(self.gainNode);
            }

            self.audioSources.push(audioSource);
        });

        if (!audioTracksLength) {
            return;
        }

        self.audioDestination = self.audioContext.createMediaStreamDestination();
        self.audioSources.forEach(function(audioSource) {
            audioSource.connect(self.audioDestination);
        });
        return self.audioDestination.stream;
    }

    function getVideo(stream) {
        var video = document.createElement('video');

        setSrcObject(stream, video);

        video.muted = true;
        video.volume = 0;

        video.width = stream.width || self.width || 360;
        video.height = stream.height || self.height || 240;

        video.play();

        return video;
    }

    this.appendStreams = function(streams) {
        if (!streams) {
            throw 'First parameter is required.';
        }

        if (!(streams instanceof Array)) {
            streams = [streams];
        }

        arrayOfMediaStreams.concat(streams);

        streams.forEach(function(stream) {
            if (stream.getVideoTracks().length) {
                var video = getVideo(stream);
                video.stream = stream;
                videos.push(video);
            }

            if (stream.getAudioTracks().length && self.audioContext) {
                var audioSource = self.audioContext.createMediaStreamSource(stream);
                audioSource.connect(self.audioDestination);
                self.audioSources.push(audioSource);
            }
        });
    };

    this.releaseStreams = function() {
        videos = [];
        isStopDrawingFrames = true;

        if (self.gainNode) {
            self.gainNode.disconnect();
            self.gainNode = null;
        }

        if (self.audioSources.length) {
            self.audioSources.forEach(function(source) {
                source.disconnect();
            });
            self.audioSources = [];
        }

        if (self.audioDestination) {
            self.audioDestination.disconnect();
            self.audioDestination = null;
        }

        if (self.audioContext) {
            self.audioContext.close();
        }

        self.audioContext = null;

        context.clearRect(0, 0, canvas.width, canvas.height);

        if (canvas.stream) {
            canvas.stream.stop();
            canvas.stream = null;
        }
    };

    this.resetVideoStreams = function(streams) {
        if (streams && !(streams instanceof Array)) {
            streams = [streams];
        }

        resetVideoStreams(streams);
    };

    function resetVideoStreams(streams) {
        videos = [];
        streams = streams || arrayOfMediaStreams;

        // via: @adrian-ber
        streams.forEach(function(stream) {
            if (!stream.getVideoTracks().length) {
                return;
            }

            var video = getVideo(stream);
            video.stream = stream;
            videos.push(video);
        });
    }

    // for debugging
    this.name = 'MultiStreamsMixer';
    this.toString = function() {
        return this.name;
    };

    this.getMixedStream = getMixedStream;

}

// ______________________
// MultiStreamRecorder.js

/*
 * Video conference recording, using captureStream API along with WebAudio and Canvas2D API.
 */

/**
 * MultiStreamRecorder can record multiple videos in single container.
 * @summary Multi-videos recorder.
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link http://www.MuazKhan.com|Muaz Khan}
 * @typedef MultiStreamRecorder
 * @class
 * @example
 * var options = {
 *     mimeType: 'video/webm'
 * }
 * var recorder = new MultiStreamRecorder(ArrayOfMediaStreams, options);
 * recorder.record();
 * recorder.stop(function(blob) {
 *     video.src = URL.createObjectURL(blob);
 *
 *     // or
 *     var blob = recorder.blob;
 * });
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStreams} mediaStreams - Array of MediaStreams.
 * @param {object} config - {disableLogs:true, frameInterval: 1, mimeType: "video/webm"}
 */

function MultiStreamRecorder(arrayOfMediaStreams, options) {
    arrayOfMediaStreams = arrayOfMediaStreams || [];
    var self = this;

    var mixer;
    var mediaRecorder;

    options = options || {
        mimeType: 'video/webm',
        video: {
            width: 360,
            height: 240
        }
    };

    if (!options.frameInterval) {
        options.frameInterval = 10;
    }

    if (!options.video) {
        options.video = {};
    }

    if (!options.video.width) {
        options.video.width = 360;
    }

    if (!options.video.height) {
        options.video.height = 240;
    }

    /**
     * This method records all MediaStreams.
     * @method
     * @memberof MultiStreamRecorder
     * @example
     * recorder.record();
     */
    this.record = function() {
        // github/muaz-khan/MultiStreamsMixer
        mixer = new MultiStreamsMixer(arrayOfMediaStreams);

        if (getVideoTracks().length) {
            mixer.frameInterval = options.frameInterval || 10;
            mixer.width = options.video.width || 360;
            mixer.height = options.video.height || 240;
            mixer.startDrawingFrames();
        }

        if (options.previewStream && typeof options.previewStream === 'function') {
            options.previewStream(mixer.getMixedStream());
        }

        // record using MediaRecorder API
        mediaRecorder = new MediaStreamRecorder(mixer.getMixedStream(), options);
        mediaRecorder.record();
    };

    function getVideoTracks() {
        var tracks = [];
        arrayOfMediaStreams.forEach(function(stream) {
            stream.getVideoTracks().forEach(function(track) {
                tracks.push(track);
            });
        });
        return tracks;
    }

    /**
     * This method stops recording MediaStream.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof MultiStreamRecorder
     * @example
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     */
    this.stop = function(callback) {
        if (!mediaRecorder) {
            return;
        }

        mediaRecorder.stop(function(blob) {
            self.blob = blob;

            callback(blob);

            self.clearRecordedData();
        });
    };

    /**
     * This method pauses the recording process.
     * @method
     * @memberof MultiStreamRecorder
     * @example
     * recorder.pause();
     */
    this.pause = function() {
        if (mediaRecorder) {
            mediaRecorder.pause();
        }
    };

    /**
     * This method resumes the recording process.
     * @method
     * @memberof MultiStreamRecorder
     * @example
     * recorder.resume();
     */
    this.resume = function() {
        if (mediaRecorder) {
            mediaRecorder.resume();
        }
    };

    /**
     * This method resets currently recorded data.
     * @method
     * @memberof MultiStreamRecorder
     * @example
     * recorder.clearRecordedData();
     */
    this.clearRecordedData = function() {
        if (mediaRecorder) {
            mediaRecorder.clearRecordedData();
            mediaRecorder = null;
        }

        if (mixer) {
            mixer.releaseStreams();
            mixer = null;
        }
    };

    /**
     * Add extra media-streams to existing recordings.
     * @method
     * @memberof MultiStreamRecorder
     * @param {MediaStreams} mediaStreams - Array of MediaStreams
     * @example
     * recorder.addStreams([newAudioStream, newVideoStream]);
     */
    this.addStreams = function(streams) {
        if (!streams) {
            throw 'First parameter is required.';
        }

        if (!(streams instanceof Array)) {
            streams = [streams];
        }

        arrayOfMediaStreams.concat(streams);

        if (!mediaRecorder || !mixer) {
            return;
        }

        mixer.appendStreams(streams);
    };

    /**
     * Reset videos during live recording. Replace old videos e.g. replace cameras with full-screen.
     * @method
     * @memberof MultiStreamRecorder
     * @param {MediaStreams} mediaStreams - Array of MediaStreams
     * @example
     * recorder.resetVideoStreams([newVideo1, newVideo2]);
     */
    this.resetVideoStreams = function(streams) {
        if (!mixer) {
            return;
        }

        if (streams && !(streams instanceof Array)) {
            streams = [streams];
        }

        mixer.resetVideoStreams(streams);
    };

    // for debugging
    this.name = 'MultiStreamRecorder';
    this.toString = function() {
        return this.name;
    };
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.MultiStreamRecorder = MultiStreamRecorder;
}

// _____________________
// RecordRTC.promises.js

/**
 * RecordRTCPromisesHandler adds promises support in {@link RecordRTC}. Try a {@link https://github.com/muaz-khan/RecordRTC/blob/master/simple-demos/RecordRTCPromisesHandler.html|demo here}
 * @summary Promises for {@link RecordRTC}
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link http://www.MuazKhan.com|Muaz Khan}
 * @typedef RecordRTCPromisesHandler
 * @class
 * @example
 * var recorder = new RecordRTCPromisesHandler(mediaStream, options);
 * recorder.startRecording()
 *         .then(successCB)
 *         .catch(errorCB);
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.
 * @param {object} config - {type:"video", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}
 * @throws Will throw an error if "new" keyword is not used to initiate "RecordRTCPromisesHandler". Also throws error if first argument "MediaStream" is missing.
 * @requires {@link RecordRTC}
 */

function RecordRTCPromisesHandler(mediaStream, options) {
    if (!this) {
        throw 'Use "new RecordRTCPromisesHandler()"';
    }

    if (typeof mediaStream === 'undefined') {
        throw 'First argument "MediaStream" is required.';
    }

    var self = this;

    /**
     * @property {Blob} blob - Access/reach the native {@link RecordRTC} object.
     * @memberof RecordRTCPromisesHandler
     * @example
     * var internal = recorder.recordRTC.getInternalRecorder();
     * alert(internal instanceof MediaStreamRecorder);
     */
    self.recordRTC = new RecordRTC(mediaStream, options);

    /**
     * This method records MediaStream.
     * @method
     * @memberof RecordRTCPromisesHandler
     * @example
     * recorder.startRecording()
     *         .then(successCB)
     *         .catch(errorCB);
     */
    this.startRecording = function() {
        return new Promise(function(resolve, reject) {
            try {
                self.recordRTC.startRecording();
                resolve();
            } catch (e) {
                reject(e);
            }
        });
    };

    /**
     * This method stops the recording.
     * @method
     * @memberof RecordRTCPromisesHandler
     * @example
     * recorder.stopRecording().then(function() {
     *     var blob = recorder.getBlob();
     * }).catch(errorCB);
     */
    this.stopRecording = function() {
        return new Promise(function(resolve, reject) {
            try {
                self.recordRTC.stopRecording(function(url) {
                    self.blob = self.recordRTC.getBlob();
                    resolve(url);
                });
            } catch (e) {
                reject(e);
            }
        });
    };

    /**
     * This method returns data-url for the recorded blob.
     * @method
     * @memberof RecordRTCPromisesHandler
     * @example
     * recorder.stopRecording().then(function() {
     *     recorder.getDataURL().then(function(dataURL) {
     *         window.open(dataURL);
     *     }).catch(errorCB);;
     * }).catch(errorCB);
     */
    this.getDataURL = function(callback) {
        return new Promise(function(resolve, reject) {
            try {
                self.recordRTC.getDataURL(function(dataURL) {
                    resolve(dataURL);
                });
            } catch (e) {
                reject(e);
            }
        });
    };

    /**
     * This method returns the recorded blob.
     * @method
     * @memberof RecordRTCPromisesHandler
     * @example
     * recorder.stopRecording().then(function() {
     *     var blob = recorder.getBlob();
     * }).catch(errorCB);
     */
    this.getBlob = function() {
        return self.recordRTC.getBlob();
    };

    /**
     * @property {Blob} blob - Recorded data as "Blob" object.
     * @memberof RecordRTCPromisesHandler
     * @example
     * recorder.stopRecording().then(function() {
     *     var blob = recorder.getBlob();
     * }).catch(errorCB);
     */
    this.blob = null;
}

if (typeof RecordRTC !== 'undefined') {
    RecordRTC.RecordRTCPromisesHandler = RecordRTCPromisesHandler;
}
;/*!
 * wavesurfer.js 2.1.3 (2019-01-21)
 * https://github.com/katspaugh/wavesurfer.js
 * @license BSD-3-Clause
 */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("WaveSurfer",[],t):"object"==typeof exports?exports.WaveSurfer=t():e.WaveSurfer=t()}(window,function(){return function(r){var n={};function i(e){if(n[e])return n[e].exports;var t=n[e]={i:e,l:!1,exports:{}};return r[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}return i.m=r,i.c=n,i.d=function(e,t,r){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)i.d(r,n,function(e){return t[e]}.bind(null,n));return r},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=4)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"ajax",{enumerable:!0,get:function(){return n.default}}),Object.defineProperty(t,"getId",{enumerable:!0,get:function(){return i.default}}),Object.defineProperty(t,"max",{enumerable:!0,get:function(){return a.default}}),Object.defineProperty(t,"min",{enumerable:!0,get:function(){return s.default}}),Object.defineProperty(t,"Observer",{enumerable:!0,get:function(){return o.default}}),Object.defineProperty(t,"extend",{enumerable:!0,get:function(){return u.default}}),Object.defineProperty(t,"style",{enumerable:!0,get:function(){return l.default}}),Object.defineProperty(t,"requestAnimationFrame",{enumerable:!0,get:function(){return c.default}}),Object.defineProperty(t,"frame",{enumerable:!0,get:function(){return h.default}}),Object.defineProperty(t,"debounce",{enumerable:!0,get:function(){return f.default}}),Object.defineProperty(t,"preventClick",{enumerable:!0,get:function(){return d.default}});var n=p(r(5)),i=p(r(6)),a=p(r(7)),s=p(r(8)),o=p(r(1)),u=p(r(9)),l=p(r(10)),c=p(r(2)),h=p(r(11)),f=p(r(12)),d=p(r(13));function p(e){return e&&e.__esModule?e:{default:e}}},function(e,t,r){"use strict";function i(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.handlers=null}var t,r,n;return t=e,(r=[{key:"on",value:function(e,t){var r=this;this.handlers||(this.handlers={});var n=this.handlers[e];return n||(n=this.handlers[e]=[]),n.push(t),{name:e,callback:t,un:function(e,t){return r.un(e,t)}}}},{key:"un",value:function(e,t){if(this.handlers){var r,n=this.handlers[e];if(n)if(t)for(r=n.length-1;0<=r;r--)n[r]==t&&n.splice(r,1);else n.length=0}}},{key:"unAll",value:function(){this.handlers=null}},{key:"once",value:function(i,a){var s=this;return this.on(i,function e(){for(var t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];a.apply(s,r),setTimeout(function(){s.un(i,e)},0)})}},{key:"fireEvent",value:function(e){for(var t=arguments.length,r=new Array(1<t?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];if(this.handlers){var i=this.handlers[e];i&&i.forEach(function(e){e.apply(void 0,r)})}}}])&&i(t.prototype,r),n&&i(t,n),e}();t.default=n,e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=(window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(e,t){return setTimeout(e,1e3/60)}).bind(window);t.default=n,e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=function(e){{if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)if(Object.prototype.hasOwnProperty.call(e,r)){var n=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,r):{};n.get||n.set?Object.defineProperty(t,r,n):t[r]=e[r]}return t.default=e,t}}(r(0));function i(e){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){return!t||"object"!==i(t)&&"function"!=typeof t?function(e){if(void 0!==e)return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(e):t}function o(e){return(o=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function u(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function l(e,t,r){return t&&u(e.prototype,t),r&&u(e,r),e}function c(e,t){return(c=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}var h="playing",f="paused",d="finished",p=function(e){function i(e){var t,r,n;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,i),(n=s(this,o(i).call(this))).audioContext=null,n.offlineAudioContext=null,n.stateBehaviors=(a(t={},h,{init:function(){this.addOnAudioProcess()},getPlayedPercents:function(){var e=this.getDuration();return this.getCurrentTime()/e||0},getCurrentTime:function(){return this.startPosition+this.getPlayedTime()}}),a(t,f,{init:function(){this.removeOnAudioProcess()},getPlayedPercents:function(){var e=this.getDuration();return this.getCurrentTime()/e||0},getCurrentTime:function(){return this.startPosition}}),a(t,d,{init:function(){this.removeOnAudioProcess(),this.fireEvent("finish")},getPlayedPercents:function(){return 1},getCurrentTime:function(){return this.getDuration()}}),t),n.params=e,n.ac=e.audioContext||n.getAudioContext(),n.lastPlay=n.ac.currentTime,n.startPosition=0,n.scheduledPause=null,n.states=(a(r={},h,Object.create(n.stateBehaviors[h])),a(r,f,Object.create(n.stateBehaviors[f])),a(r,d,Object.create(n.stateBehaviors[d])),r),n.analyser=null,n.buffer=null,n.filters=[],n.gainNode=null,n.mergedPeaks=null,n.offlineAc=null,n.peaks=null,n.playbackRate=1,n.analyser=null,n.scriptNode=null,n.source=null,n.splitPeaks=[],n.state=null,n.explicitDuration=null,n}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&c(e,t)}(i,n.Observer),l(i,[{key:"supportsWebAudio",value:function(){return!(!window.AudioContext&&!window.webkitAudioContext)}},{key:"getAudioContext",value:function(){return window.WaveSurferAudioContext||(window.WaveSurferAudioContext=new(window.AudioContext||window.webkitAudioContext)),window.WaveSurferAudioContext}},{key:"getOfflineAudioContext",value:function(e){return window.WaveSurferOfflineAudioContext||(window.WaveSurferOfflineAudioContext=new(window.OfflineAudioContext||window.webkitOfflineAudioContext)(1,2,e)),window.WaveSurferOfflineAudioContext}}]),l(i,[{key:"init",value:function(){this.createVolumeNode(),this.createScriptNode(),this.createAnalyserNode(),this.setState(f),this.setPlaybackRate(this.params.audioRate),this.setLength(0)}},{key:"disconnectFilters",value:function(){this.filters&&(this.filters.forEach(function(e){e&&e.disconnect()}),this.filters=null,this.analyser.connect(this.gainNode))}},{key:"setState",value:function(e){this.state!==this.states[e]&&(this.state=this.states[e],this.state.init.call(this))}},{key:"setFilter",value:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];this.setFilters(t)}},{key:"setFilters",value:function(e){this.disconnectFilters(),e&&e.length&&(this.filters=e,this.analyser.disconnect(),e.reduce(function(e,t){return e.connect(t),t},this.analyser).connect(this.gainNode))}},{key:"createScriptNode",value:function(){this.params.audioScriptProcessor?this.scriptNode=this.params.audioScriptProcessor:this.ac.createScriptProcessor?this.scriptNode=this.ac.createScriptProcessor(i.scriptBufferSize):this.scriptNode=this.ac.createJavaScriptNode(i.scriptBufferSize),this.scriptNode.connect(this.ac.destination)}},{key:"addOnAudioProcess",value:function(){var t=this;this.scriptNode.onaudioprocess=function(){var e=t.getCurrentTime();e>=t.getDuration()?(t.setState(d),t.fireEvent("pause")):e>=t.scheduledPause?t.pause():t.state===t.states[h]&&t.fireEvent("audioprocess",e)}}},{key:"removeOnAudioProcess",value:function(){this.scriptNode.onaudioprocess=function(){}}},{key:"createAnalyserNode",value:function(){this.analyser=this.ac.createAnalyser(),this.analyser.connect(this.gainNode)}},{key:"createVolumeNode",value:function(){this.ac.createGain?this.gainNode=this.ac.createGain():this.gainNode=this.ac.createGainNode(),this.gainNode.connect(this.ac.destination)}},{key:"setSinkId",value:function(e){if(e){var t=new window.Audio;if(!t.setSinkId)return Promise.reject(new Error("setSinkId is not supported in your browser"));t.autoplay=!0;var r=this.ac.createMediaStreamDestination();return this.gainNode.disconnect(),this.gainNode.connect(r),t.srcObject=r.stream,t.setSinkId(e)}return Promise.reject(new Error("Invalid deviceId: "+e))}},{key:"setVolume",value:function(e){this.gainNode.gain.setValueAtTime(e,this.ac.currentTime)}},{key:"getVolume",value:function(){return this.gainNode.gain.value}},{key:"decodeArrayBuffer",value:function(e,t,r){this.offlineAc||(this.offlineAc=this.getOfflineAudioContext(this.ac&&this.ac.sampleRate?this.ac.sampleRate:44100)),this.offlineAc.decodeAudioData(e,function(e){return t(e)},r)}},{key:"setPeaks",value:function(e,t){this.explicitDuration=t,this.peaks=e}},{key:"setLength",value:function(e){if(!this.mergedPeaks||e!=2*this.mergedPeaks.length-1+2){this.splitPeaks=[],this.mergedPeaks=[];var t,r=this.buffer?this.buffer.numberOfChannels:1;for(t=0;t<r;t++)this.splitPeaks[t]=[],this.splitPeaks[t][2*(e-1)]=0,this.splitPeaks[t][2*(e-1)+1]=0;this.mergedPeaks[2*(e-1)]=0,this.mergedPeaks[2*(e-1)+1]=0}}},{key:"getPeaks",value:function(e,t,r){if(this.peaks)return this.peaks;if(t=t||0,r=r||e-1,this.setLength(e),!this.buffer)return this.params.splitChannels?this.splitPeaks:this.mergedPeaks;if(!this.buffer.length){var n=this.createBuffer(1,4096,this.sampleRate);this.buffer=n.buffer}var i,a=this.buffer.length/e,s=~~(a/10)||1,o=this.buffer.numberOfChannels;for(i=0;i<o;i++){var u=this.splitPeaks[i],l=this.buffer.getChannelData(i),c=void 0;for(c=t;c<=r;c++){var h=~~(c*a),f=~~(h+a),d=0,p=0,v=void 0;for(v=h;v<f;v+=s){var y=l[v];p<y&&(p=y),y<d&&(d=y)}u[2*c]=p,u[2*c+1]=d,(0==i||p>this.mergedPeaks[2*c])&&(this.mergedPeaks[2*c]=p),(0==i||d<this.mergedPeaks[2*c+1])&&(this.mergedPeaks[2*c+1]=d)}}return this.params.splitChannels?this.splitPeaks:this.mergedPeaks}},{key:"getPlayedPercents",value:function(){return this.state.getPlayedPercents.call(this)}},{key:"disconnectSource",value:function(){this.source&&this.source.disconnect()}},{key:"destroy",value:function(){this.isPaused()||this.pause(),this.unAll(),this.buffer=null,this.disconnectFilters(),this.disconnectSource(),this.gainNode.disconnect(),this.scriptNode.disconnect(),this.analyser.disconnect(),this.params.closeAudioContext&&("function"==typeof this.ac.close&&"closed"!=this.ac.state&&this.ac.close(),this.ac=null,this.params.audioContext?this.params.audioContext=null:window.WaveSurferAudioContext=null,window.WaveSurferOfflineAudioContext=null)}},{key:"load",value:function(e){this.startPosition=0,this.lastPlay=this.ac.currentTime,this.buffer=e,this.createSource()}},{key:"createSource",value:function(){this.disconnectSource(),this.source=this.ac.createBufferSource(),this.source.start=this.source.start||this.source.noteGrainOn,this.source.stop=this.source.stop||this.source.noteOff,this.source.playbackRate.setValueAtTime(this.playbackRate,this.ac.currentTime),this.source.buffer=this.buffer,this.source.connect(this.analyser)}},{key:"isPaused",value:function(){return this.state!==this.states[h]}},{key:"getDuration",value:function(){return this.buffer?this.buffer.duration:this.explicitDuration?this.explicitDuration:0}},{key:"seekTo",value:function(e,t){if(this.buffer)return(this.scheduledPause=null)==e&&(e=this.getCurrentTime())>=this.getDuration()&&(e=0),null==t&&(t=this.getDuration()),this.startPosition=e,this.lastPlay=this.ac.currentTime,this.state===this.states[d]&&this.setState(f),{start:e,end:t}}},{key:"getPlayedTime",value:function(){return(this.ac.currentTime-this.lastPlay)*this.playbackRate}},{key:"play",value:function(e,t){if(this.buffer){this.createSource();var r=this.seekTo(e,t);e=r.start,t=r.end,this.scheduledPause=t,this.source.start(0,e,t-e),"suspended"==this.ac.state&&this.ac.resume&&this.ac.resume(),this.setState(h),this.fireEvent("play")}}},{key:"pause",value:function(){this.scheduledPause=null,this.startPosition+=this.getPlayedTime(),this.source&&this.source.stop(0),this.setState(f),this.fireEvent("pause")}},{key:"getCurrentTime",value:function(){return this.state.getCurrentTime.call(this)}},{key:"getPlaybackRate",value:function(){return this.playbackRate}},{key:"setPlaybackRate",value:function(e){e=e||1,this.isPaused()?this.playbackRate=e:(this.pause(),this.playbackRate=e,this.play())}}]),i}();(t.default=p).scriptBufferSize=256,e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var i=function(e){{if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)if(Object.prototype.hasOwnProperty.call(e,r)){var n=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,r):{};n.get||n.set?Object.defineProperty(t,r,n):t[r]=e[r]}return t.default=e,t}}(r(0)),a=n(r(14)),s=n(r(3)),o=n(r(16)),u=n(r(17));function n(e){return e&&e.__esModule?e:{default:e}}function l(e){return(l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function c(e,t){return!t||"object"!==l(t)&&"function"!=typeof t?d(e):t}function h(e){return(h=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function f(e,t){return(f=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function d(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function p(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function v(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function y(e,t,r){return t&&v(e.prototype,t),r&&v(e,r),e}var m=function(e){function n(e){var t;if(p(this,n),(t=c(this,h(n).call(this))).defaultParams={audioContext:null,audioScriptProcessor:null,audioRate:1,autoCenter:!0,backend:"WebAudio",barHeight:1,barGap:null,container:null,cursorColor:"#333",cursorWidth:1,dragSelection:!0,fillParent:!0,forceDecode:!1,height:128,hideScrollbar:!1,interact:!0,loopSelection:!0,maxCanvasWidth:4e3,mediaContainer:null,mediaControls:!1,mediaType:"audio",minPxPerSec:20,normalize:!1,partialRender:!1,pixelRatio:window.devicePixelRatio||screen.deviceXDPI/screen.logicalXDPI,plugins:[],progressColor:"#555",removeMediaElementOnDestroy:!0,renderer:a.default,responsive:!1,scrollParent:!1,skipLength:2,splitChannels:!1,waveColor:"#999",xhr:{}},t.backends={MediaElement:o.default,WebAudio:s.default},t.util=i,t.params=i.extend({},t.defaultParams,e),t.container="string"==typeof e.container?document.querySelector(t.params.container):t.params.container,!t.container)throw new Error("Container element not found");if(null==t.params.mediaContainer?t.mediaContainer=t.container:"string"==typeof t.params.mediaContainer?t.mediaContainer=document.querySelector(t.params.mediaContainer):t.mediaContainer=t.params.mediaContainer,!t.mediaContainer)throw new Error("Media Container element not found");if(t.params.maxCanvasWidth<=1)throw new Error("maxCanvasWidth must be greater than 1");if(t.params.maxCanvasWidth%2==1)throw new Error("maxCanvasWidth must be an even number");if(t.savedVolume=0,t.isMuted=!1,t.tmpEvents=[],t.currentAjax=null,t.arraybuffer=null,t.drawer=null,t.backend=null,t.peakCache=null,"function"!=typeof t.params.renderer)throw new Error("Renderer parameter is invalid");t.Drawer=t.params.renderer,t.Backend=t.backends[t.params.backend],t.initialisedPluginList={},t.isDestroyed=!1,t.isReady=!1;var r=0;return t._onResize=i.debounce(function(){r==t.drawer.wrapper.clientWidth||t.params.scrollParent||(r=t.drawer.wrapper.clientWidth,t.drawer.fireEvent("redraw"))},"number"==typeof t.params.responsive?t.params.responsive:100),c(t,d(d(t)))}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&f(e,t)}(n,i.Observer),y(n,null,[{key:"create",value:function(e){return new n(e).init()}}]),y(n,[{key:"init",value:function(){return this.registerPlugins(this.params.plugins),this.createDrawer(),this.createBackend(),this.createPeakCache(),this}},{key:"registerPlugins",value:function(e){var t=this;return e.forEach(function(e){return t.addPlugin(e)}),e.forEach(function(e){e.deferInit||t.initPlugin(e.name)}),this.fireEvent("plugins-registered",e),this}},{key:"addPlugin",value:function(t){var r=this;if(!t.name)throw new Error("Plugin does not have a name!");if(!t.instance)throw new Error("Plugin ".concat(t.name," does not have an instance property!"));t.staticProps&&Object.keys(t.staticProps).forEach(function(e){r[e]=t.staticProps[e]});var n=t.instance;return Object.getOwnPropertyNames(i.Observer.prototype).forEach(function(e){n.prototype[e]=i.Observer.prototype[e]}),this[t.name]=new n(t.params||{},this),this.fireEvent("plugin-added",t.name),this}},{key:"initPlugin",value:function(e){if(!this[e])throw new Error("Plugin ".concat(e," has not been added yet!"));return this.initialisedPluginList[e]&&this.destroyPlugin(e),this[e].init(),this.initialisedPluginList[e]=!0,this.fireEvent("plugin-initialised",e),this}},{key:"destroyPlugin",value:function(e){if(!this[e])throw new Error("Plugin ".concat(e," has not been added yet and cannot be destroyed!"));if(!this.initialisedPluginList[e])throw new Error("Plugin ".concat(e," is not active and cannot be destroyed!"));if("function"!=typeof this[e].destroy)throw new Error("Plugin ".concat(e," does not have a destroy function!"));return this[e].destroy(),delete this.initialisedPluginList[e],this.fireEvent("plugin-destroyed",e),this}},{key:"destroyAllPlugins",value:function(){var t=this;Object.keys(this.initialisedPluginList).forEach(function(e){return t.destroyPlugin(e)})}},{key:"createDrawer",value:function(){var r=this;this.drawer=new this.Drawer(this.container,this.params),this.drawer.init(),this.fireEvent("drawer-created",this.drawer),!1!==this.params.responsive&&(window.addEventListener("resize",this._onResize,!0),window.addEventListener("orientationchange",this._onResize,!0)),this.drawer.on("redraw",function(){r.drawBuffer(),r.drawer.progress(r.backend.getPlayedPercents())}),this.drawer.on("click",function(e,t){setTimeout(function(){return r.seekTo(t)},0)}),this.drawer.on("scroll",function(e){r.params.partialRender&&r.drawBuffer(),r.fireEvent("scroll",e)})}},{key:"createBackend",value:function(){var t=this;this.backend&&this.backend.destroy(),"AudioElement"==this.params.backend&&(this.params.backend="MediaElement"),"WebAudio"!=this.params.backend||this.Backend.prototype.supportsWebAudio.call(null)||(this.params.backend="MediaElement"),this.backend=new this.Backend(this.params),this.backend.init(),this.fireEvent("backend-created",this.backend),this.backend.on("finish",function(){t.drawer.progress(t.backend.getPlayedPercents()),t.fireEvent("finish")}),this.backend.on("play",function(){return t.fireEvent("play")}),this.backend.on("pause",function(){return t.fireEvent("pause")}),this.backend.on("audioprocess",function(e){t.drawer.progress(t.backend.getPlayedPercents()),t.fireEvent("audioprocess",e)})}},{key:"createPeakCache",value:function(){this.params.partialRender&&(this.peakCache=new u.default)}},{key:"getDuration",value:function(){return this.backend.getDuration()}},{key:"getCurrentTime",value:function(){return this.backend.getCurrentTime()}},{key:"setCurrentTime",value:function(e){e>=this.getDuration()?this.seekTo(1):this.seekTo(e/this.getDuration())}},{key:"play",value:function(e,t){var r=this;return this.fireEvent("interaction",function(){return r.play(e,t)}),this.backend.play(e,t)}},{key:"pause",value:function(){if(!this.backend.isPaused())return this.backend.pause()}},{key:"playPause",value:function(){return this.backend.isPaused()?this.play():this.pause()}},{key:"isPlaying",value:function(){return!this.backend.isPaused()}},{key:"skipBackward",value:function(e){this.skip(-e||-this.params.skipLength)}},{key:"skipForward",value:function(e){this.skip(e||this.params.skipLength)}},{key:"skip",value:function(e){var t=this.getDuration()||1,r=this.getCurrentTime()||0;r=Math.max(0,Math.min(t,r+(e||0))),this.seekAndCenter(r/t)}},{key:"seekAndCenter",value:function(e){this.seekTo(e),this.drawer.recenter(e)}},{key:"seekTo",value:function(e){var t=this;if("number"!=typeof e||!isFinite(e)||e<0||1<e)return console.error("Error calling wavesurfer.seekTo, parameter must be a number between 0 and 1!");this.fireEvent("interaction",function(){return t.seekTo(e)});var r=this.backend.isPaused();r||this.backend.pause();var n=this.params.scrollParent;this.params.scrollParent=!1,this.backend.seekTo(e*this.getDuration()),this.drawer.progress(e),r||this.backend.play(),this.params.scrollParent=n,this.fireEvent("seek",e)}},{key:"stop",value:function(){this.pause(),this.seekTo(0),this.drawer.progress(0)}},{key:"setSinkId",value:function(e){return this.backend.setSinkId(e)}},{key:"setVolume",value:function(e){this.backend.setVolume(e),this.fireEvent("volume",e)}},{key:"getVolume",value:function(){return this.backend.getVolume()}},{key:"setPlaybackRate",value:function(e){this.backend.setPlaybackRate(e)}},{key:"getPlaybackRate",value:function(){return this.backend.getPlaybackRate()}},{key:"toggleMute",value:function(){this.setMute(!this.isMuted)}},{key:"setMute",value:function(e){e!==this.isMuted&&(e?(this.savedVolume=this.backend.getVolume(),this.backend.setVolume(0),this.isMuted=!0,this.fireEvent("volume",0)):(this.backend.setVolume(this.savedVolume),this.isMuted=!1,this.fireEvent("volume",this.savedVolume))),this.fireEvent("mute",this.isMuted)}},{key:"getMute",value:function(){return this.isMuted}},{key:"isReady",value:function(){return this.isReady}},{key:"getFilters",value:function(){return this.backend.filters||[]}},{key:"toggleScroll",value:function(){this.params.scrollParent=!this.params.scrollParent,this.drawBuffer()}},{key:"toggleInteraction",value:function(){this.params.interact=!this.params.interact}},{key:"getWaveColor",value:function(){return this.params.waveColor}},{key:"setWaveColor",value:function(e){this.params.waveColor=e,this.drawBuffer()}},{key:"getProgressColor",value:function(){return this.params.progressColor}},{key:"setProgressColor",value:function(e){this.params.progressColor=e,this.drawBuffer()}},{key:"getCursorColor",value:function(){return this.params.cursorColor}},{key:"setCursorColor",value:function(e){this.params.cursorColor=e,this.drawer.updateCursor()}},{key:"getHeight",value:function(){return this.params.height}},{key:"setHeight",value:function(e){this.params.height=e,this.drawer.setHeight(e*this.params.pixelRatio),this.drawBuffer()}},{key:"drawBuffer",value:function(){var e,t=Math.round(this.getDuration()*this.params.minPxPerSec*this.params.pixelRatio),r=this.drawer.getWidth(),n=t,i=this.drawer.getScrollX(),a=Math.max(i+r,n);if(this.params.fillParent&&(!this.params.scrollParent||t<r)&&(i=0,a=n=r),this.params.partialRender){var s,o=this.peakCache.addRangeToPeakCache(n,i,a);for(s=0;s<o.length;s++)e=this.backend.getPeaks(n,o[s][0],o[s][1]),this.drawer.drawPeaks(e,n,o[s][0],o[s][1])}else e=this.backend.getPeaks(n,i,a),this.drawer.drawPeaks(e,n,i,a);this.fireEvent("redraw",e,n)}},{key:"zoom",value:function(e){this.params.scrollParent=e?(this.params.minPxPerSec=e,!0):(this.params.minPxPerSec=this.defaultParams.minPxPerSec,!1),this.drawBuffer(),this.drawer.progress(this.backend.getPlayedPercents()),this.drawer.recenter(this.getCurrentTime()/this.getDuration()),this.fireEvent("zoom",e)}},{key:"loadArrayBuffer",value:function(e){var t=this;this.decodeArrayBuffer(e,function(e){t.isDestroyed||t.loadDecodedBuffer(e)})}},{key:"loadDecodedBuffer",value:function(e){this.backend.load(e),this.drawBuffer(),this.fireEvent("ready"),this.isReady=!0}},{key:"loadBlob",value:function(e){var t=this,r=new FileReader;r.addEventListener("progress",function(e){return t.onProgress(e)}),r.addEventListener("load",function(e){return t.loadArrayBuffer(e.target.result)}),r.addEventListener("error",function(){return t.fireEvent("error","Error reading file")}),r.readAsArrayBuffer(e),this.empty()}},{key:"load",value:function(e,t,r,n){if(this.empty(),r){var i={"Preload is not 'auto', 'none' or 'metadata'":-1===["auto","metadata","none"].indexOf(r),"Peaks are not provided":!t,"Backend is not of type MediaElement":"MediaElement"!==this.params.backend,"Url is not of type string":"string"!=typeof e},a=Object.keys(i).filter(function(e){return i[e]});a.length&&(console.warn("Preload parameter of wavesurfer.load will be ignored because:\n\t- "+a.join("\n\t- ")),r=null)}switch(this.params.backend){case"WebAudio":return this.loadBuffer(e,t,n);case"MediaElement":return this.loadMediaElement(e,t,r,n)}}},{key:"loadBuffer",value:function(t,e,r){var n=this,i=function(e){return e&&n.tmpEvents.push(n.once("ready",e)),n.getArrayBuffer(t,function(e){return n.loadArrayBuffer(e)})};if(!e)return i();this.backend.setPeaks(e,r),this.drawBuffer(),this.tmpEvents.push(this.once("interaction",i))}},{key:"loadMediaElement",value:function(e,t,r,n){var i=this,a=e;if("string"==typeof e)this.backend.load(a,this.mediaContainer,t,r);else{var s=e;this.backend.loadElt(s,t),a=s.src}this.tmpEvents.push(this.backend.once("canplay",function(){i.drawBuffer(),i.fireEvent("ready"),i.isReady=!0}),this.backend.once("error",function(e){return i.fireEvent("error",e)})),t&&this.backend.setPeaks(t,n),t&&!this.params.forceDecode||!this.backend.supportsWebAudio()||this.getArrayBuffer(a,function(e){i.decodeArrayBuffer(e,function(e){i.backend.buffer=e,i.backend.setPeaks(null),i.drawBuffer(),i.fireEvent("waveform-ready")})})}},{key:"decodeArrayBuffer",value:function(t,r){var n=this;this.arraybuffer=t,this.backend.decodeArrayBuffer(t,function(e){n.isDestroyed||n.arraybuffer!=t||(r(e),n.arraybuffer=null)},function(){return n.fireEvent("error","Error decoding audiobuffer")})}},{key:"getArrayBuffer",value:function(e,r){var n=this,t=i.ajax({url:e,responseType:"arraybuffer",xhr:this.params.xhr});return this.currentAjax=t,this.tmpEvents.push(t.on("progress",function(e){n.onProgress(e)}),t.on("success",function(e,t){r(e),n.currentAjax=null}),t.on("error",function(e){n.fireEvent("error","XHR error: "+e.target.statusText),n.currentAjax=null})),t}},{key:"onProgress",value:function(e){var t;t=e.lengthComputable?e.loaded/e.total:e.loaded/(e.loaded+1e6),this.fireEvent("loading",Math.round(100*t),e.target)}},{key:"exportPCM",value:function(e,t,r,n){e=e||1024,n=n||0,t=t||1e4,r=r||!1;var i=this.backend.getPeaks(e,n),a=[].map.call(i,function(e){return Math.round(e*t)/t}),s=JSON.stringify(a);return r||window.open("data:application/json;charset=utf-8,"+encodeURIComponent(s)),s}},{key:"exportImage",value:function(e,t){return e||(e="image/png"),t||(t=1),this.drawer.getImage(e,t)}},{key:"cancelAjax",value:function(){this.currentAjax&&(this.currentAjax.xhr.abort(),this.currentAjax=null)}},{key:"clearTmpEvents",value:function(){this.tmpEvents.forEach(function(e){return e.un()})}},{key:"empty",value:function(){this.backend.isPaused()||(this.stop(),this.backend.disconnectSource()),this.isReady=!1,this.cancelAjax(),this.clearTmpEvents(),this.drawer.progress(0),this.drawer.setWidth(0),this.drawer.drawPeaks({length:this.drawer.getWidth()},0)}},{key:"destroy",value:function(){this.destroyAllPlugins(),this.fireEvent("destroy"),this.cancelAjax(),this.clearTmpEvents(),this.unAll(),!1!==this.params.responsive&&(window.removeEventListener("resize",this._onResize,!0),window.removeEventListener("orientationchange",this._onResize,!0)),this.backend.destroy(),this.drawer.destroy(),this.isDestroyed=!0,this.isReady=!1,this.arraybuffer=null}}]),n}();(t.default=m).VERSION="2.1.3",m.util=i,e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=new i.default,r=new XMLHttpRequest,n=!1;r.open(e.method||"GET",e.url,!0),r.responseType=e.responseType||"json",e.xhr&&(e.xhr.requestHeaders&&e.xhr.requestHeaders.forEach(function(e){r.setRequestHeader(e.key,e.value)}),e.xhr.withCredentials&&(r.withCredentials=!0));return r.addEventListener("progress",function(e){t.fireEvent("progress",e),e.lengthComputable&&e.loaded==e.total&&(n=!0)}),r.addEventListener("load",function(e){n||t.fireEvent("progress",e),t.fireEvent("load",e),200==r.status||206==r.status?t.fireEvent("success",r.response,e):t.fireEvent("error",e)}),r.addEventListener("error",function(e){return t.fireEvent("error",e)}),r.send(),t.xhr=r,t};var n,i=(n=r(1))&&n.__esModule?n:{default:n};e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return"wavesurfer_"+Math.random().toString(32).substring(2)},e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(t){var r=-1/0;return Object.keys(t).forEach(function(e){t[e]>r&&(r=t[e])}),r},e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(t){var r=Number(1/0);return Object.keys(t).forEach(function(e){t[e]<r&&(r=t[e])}),r},e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(r){for(var e=arguments.length,t=new Array(1<e?e-1:0),n=1;n<e;n++)t[n-1]=arguments[n];return t.forEach(function(t){Object.keys(t).forEach(function(e){r[e]=t[e]})}),r},e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(t,r){return Object.keys(r).forEach(function(e){t.style[e]!==r[e]&&(t.style[e]=r[e])}),t},e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(n){return function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return(0,i.default)(function(){return n.apply(void 0,t)})}};var n,i=(n=r(2))&&n.__esModule?n:{default:n};e.exports=t.default},function(e,t){function r(t,r,n){var i,a,s,o,u;function l(){var e=Date.now()-o;e<r&&0<=e?i=setTimeout(l,r-e):(i=null,n||(u=t.apply(s,a),s=a=null))}null==r&&(r=100);var e=function(){s=this,a=arguments,o=Date.now();var e=n&&!i;return i||(i=setTimeout(l,r)),e&&(u=t.apply(s,a),s=a=null),u};return e.clear=function(){i&&(clearTimeout(i),i=null)},e.flush=function(){i&&(u=t.apply(s,a),s=a=null,clearTimeout(i),i=null)},e}r.debounce=r,e.exports=r},function(e,t,r){"use strict";function n(e){e.stopPropagation(),document.body.removeEventListener("click",n,!0)}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){document.body.addEventListener("click",n,!0)},e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n,a=(n=r(15))&&n.__esModule?n:{default:n},f=function(e){{if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)if(Object.prototype.hasOwnProperty.call(e,r)){var n=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,r):{};n.get||n.set?Object.defineProperty(t,r,n):t[r]=e[r]}return t.default=e,t}}(r(0));function i(e){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function s(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function o(e,t){return!t||"object"!==i(t)&&"function"!=typeof t?function(e){if(void 0!==e)return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(e):t}function u(e){return(u=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function l(e,t){return(l=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}var c=function(e){function n(e,t){var r;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,n),(r=o(this,u(n).call(this,e,t))).maxCanvasWidth=t.maxCanvasWidth,r.maxCanvasElementWidth=Math.round(t.maxCanvasWidth/t.pixelRatio),r.hasProgressCanvas=t.waveColor!=t.progressColor,r.halfPixel=.5/t.pixelRatio,r.canvases=[],r.progressWave=null,r}var t,r,i;return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&l(e,t)}(n,a.default),t=n,(r=[{key:"init",value:function(){this.createWrapper(),this.createElements()}},{key:"createElements",value:function(){this.progressWave=this.wrapper.appendChild(this.style(document.createElement("wave"),{position:"absolute",zIndex:3,left:0,top:0,bottom:0,overflow:"hidden",width:"0",display:"none",boxSizing:"border-box",borderRightStyle:"solid",pointerEvents:"none"})),this.addCanvas(),this.updateCursor()}},{key:"updateCursor",value:function(){this.style(this.progressWave,{borderRightWidth:this.params.cursorWidth+"px",borderRightColor:this.params.cursorColor})}},{key:"updateSize",value:function(){for(var n=this,e=Math.round(this.width/this.params.pixelRatio),t=Math.ceil(e/this.maxCanvasElementWidth);this.canvases.length<t;)this.addCanvas();for(;this.canvases.length>t;)this.removeCanvas();this.canvases.forEach(function(e,t){var r=n.maxCanvasWidth+2*Math.ceil(n.params.pixelRatio/2);t==n.canvases.length-1&&(r=n.width-n.maxCanvasWidth*(n.canvases.length-1)),n.updateDimensions(e,r,n.height),n.clearWaveForEntry(e)})}},{key:"addCanvas",value:function(){var e={},t=this.maxCanvasElementWidth*this.canvases.length;e.wave=this.wrapper.appendChild(this.style(document.createElement("canvas"),{position:"absolute",zIndex:2,left:t+"px",top:0,bottom:0,height:"100%",pointerEvents:"none"})),e.waveCtx=e.wave.getContext("2d"),this.hasProgressCanvas&&(e.progress=this.progressWave.appendChild(this.style(document.createElement("canvas"),{position:"absolute",left:t+"px",top:0,bottom:0,height:"100%"})),e.progressCtx=e.progress.getContext("2d")),this.canvases.push(e)}},{key:"removeCanvas",value:function(){var e=this.canvases.pop();e.wave.parentElement.removeChild(e.wave),this.hasProgressCanvas&&e.progress.parentElement.removeChild(e.progress)}},{key:"updateDimensions",value:function(e,t,r){var n=Math.round(t/this.params.pixelRatio),i=Math.round(this.width/this.params.pixelRatio);e.start=e.waveCtx.canvas.offsetLeft/i||0,e.end=e.start+n/i,e.waveCtx.canvas.width=t,e.waveCtx.canvas.height=r,this.style(e.waveCtx.canvas,{width:n+"px"}),this.style(this.progressWave,{display:"block"}),this.hasProgressCanvas&&(e.progressCtx.canvas.width=t,e.progressCtx.canvas.height=r,this.style(e.progressCtx.canvas,{width:n+"px"}))}},{key:"clearWave",value:function(){var t=this;this.canvases.forEach(function(e){return t.clearWaveForEntry(e)})}},{key:"clearWaveForEntry",value:function(e){e.waveCtx.clearRect(0,0,e.waveCtx.canvas.width,e.waveCtx.canvas.height),this.hasProgressCanvas&&e.progressCtx.clearRect(0,0,e.progressCtx.canvas.width,e.progressCtx.canvas.height)}},{key:"drawBars",value:function(e,t,v,y){var m=this;return this.prepareDraw(e,t,v,y,function(e){var t=e.absmax,r=e.hasMinVals,n=(e.height,e.offsetY),i=e.halfH,a=e.peaks;if(void 0!==v){var s,o=r?2:1,u=a.length/o,l=m.params.barWidth*m.params.pixelRatio,c=l+(null===m.params.barGap?Math.max(m.params.pixelRatio,~~(l/2)):Math.max(m.params.pixelRatio,m.params.barGap*m.params.pixelRatio)),h=u/m.width,f=y;for(s=v;s<f;s+=c){var d=a[Math.floor(s*h*o)]||0,p=Math.round(d/t*i);m.fillRect(s+m.halfPixel,i-p+n,l+m.halfPixel,2*p)}}})}},{key:"drawWave",value:function(e,t,l,c){var h=this;return this.prepareDraw(e,t,l,c,function(e){var t=e.absmax,r=e.hasMinVals,n=(e.height,e.offsetY),i=e.halfH,a=e.peaks;if(!r){var s,o=[],u=a.length;for(s=0;s<u;s++)o[2*s]=a[s],o[2*s+1]=-a[s];a=o}void 0!==l&&h.drawLine(a,t,i,n,l,c),h.fillRect(0,i+n-h.halfPixel,h.width,h.halfPixel)})}},{key:"drawLine",value:function(t,r,n,i,a,s){var o=this;this.canvases.forEach(function(e){o.setFillStyles(e),o.drawLineToContext(e,e.waveCtx,t,r,n,i,a,s),o.drawLineToContext(e,e.progressCtx,t,r,n,i,a,s)})}},{key:"drawLineToContext",value:function(e,t,r,n,i,a,s,o){if(t){var u=r.length/2,l=this.params.fillParent&&this.width!=u?this.width/u:1,c=Math.round(u*e.start),h=Math.round(u*e.end)+1;if(!(o<c||h<s)){var f,d,p=Math.min(c,s),v=Math.max(h,o);for(t.beginPath(),t.moveTo((p-c)*l+this.halfPixel,i+a),f=p;f<v;f++){var y=r[2*f]||0,m=Math.round(y/n*i);t.lineTo((f-c)*l+this.halfPixel,i-m+a)}for(d=v-1;p<=d;d--){var b=r[2*d+1]||0,g=Math.round(b/n*i);t.lineTo((d-c)*l+this.halfPixel,i-g+a)}t.closePath(),t.fill()}}}},{key:"fillRect",value:function(e,t,r,n){var i,a=Math.floor(e/this.maxCanvasWidth),s=Math.min(Math.ceil((e+r)/this.maxCanvasWidth)+1,this.canvases.length);for(i=a;i<s;i++){var o=this.canvases[i],u=i*this.maxCanvasWidth,l={x1:Math.max(e,i*this.maxCanvasWidth),y1:t,x2:Math.min(e+r,i*this.maxCanvasWidth+o.waveCtx.canvas.width),y2:t+n};l.x1<l.x2&&(this.setFillStyles(o),this.fillRectToContext(o.waveCtx,l.x1-u,l.y1,l.x2-l.x1,l.y2-l.y1),this.fillRectToContext(o.progressCtx,l.x1-u,l.y1,l.x2-l.x1,l.y2-l.y1))}}},{key:"prepareDraw",value:function(s,o,u,l,c){var h=this;return f.frame(function(){if(s[0]instanceof Array){var e=s;if(h.params.splitChannels)return h.setHeight(e.length*h.params.height*h.params.pixelRatio),e.forEach(function(e,t){return h.prepareDraw(e,t,u,l,c)});s=e[0]}var t=1/h.params.barHeight;if(h.params.normalize){var r=f.max(s),n=f.min(s);t=r<-n?-n:r}var i=[].some.call(s,function(e){return e<0}),a=h.params.height*h.params.pixelRatio;return c({absmax:t,hasMinVals:i,height:a,offsetY:a*o||0,halfH:a/2,peaks:s})})()}},{key:"fillRectToContext",value:function(e,t,r,n,i){e&&e.fillRect(t,r,n,i)}},{key:"setFillStyles",value:function(e){e.waveCtx.fillStyle=this.params.waveColor,this.hasProgressCanvas&&(e.progressCtx.fillStyle=this.params.progressColor)}},{key:"getImage",value:function(t,r){var e=this.canvases.map(function(e){return e.wave.toDataURL(t,r)});return 1<e.length?e:e[0]}},{key:"updateProgress",value:function(e){this.style(this.progressWave,{width:e+"px"})}}])&&s(t.prototype,r),i&&s(t,i),n}();t.default=c,e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var a=function(e){{if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)if(Object.prototype.hasOwnProperty.call(e,r)){var n=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,r):{};n.get||n.set?Object.defineProperty(t,r,n):t[r]=e[r]}return t.default=e,t}}(r(0));function n(e){return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function s(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function o(e,t){return!t||"object"!==n(t)&&"function"!=typeof t?function(e){if(void 0!==e)return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(e):t}function u(e){return(u=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function l(e,t){return(l=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}var i=function(e){function n(e,t){var r;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,n),(r=o(this,u(n).call(this))).container=e,r.params=t,r.width=0,r.height=t.height*r.params.pixelRatio,r.lastPos=0,r.wrapper=null,r}var t,r,i;return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&l(e,t)}(n,a.Observer),t=n,(r=[{key:"style",value:function(e,t){return a.style(e,t)}},{key:"createWrapper",value:function(){this.wrapper=this.container.appendChild(document.createElement("wave")),this.style(this.wrapper,{display:"block",position:"relative",userSelect:"none",webkitUserSelect:"none",height:this.params.height+"px"}),(this.params.fillParent||this.params.scrollParent)&&this.style(this.wrapper,{width:"100%",overflowX:this.params.hideScrollbar?"hidden":"auto",overflowY:"hidden"}),this.setupWrapperEvents()}},{key:"handleEvent",value:function(e,t){!t&&e.preventDefault();var r,n=e.targetTouches?e.targetTouches[0].clientX:e.clientX,i=this.wrapper.getBoundingClientRect(),a=this.width,s=this.getWidth();return!this.params.fillParent&&a<s?1<(r=(n-i.left)*(this.params.pixelRatio/a)||0)&&(r=1):r=(n-i.left+this.wrapper.scrollLeft)/this.wrapper.scrollWidth||0,r}},{key:"setupWrapperEvents",value:function(){var n=this;this.wrapper.addEventListener("click",function(e){var t=n.wrapper.offsetHeight-n.wrapper.clientHeight;if(0!=t){var r=n.wrapper.getBoundingClientRect();if(e.clientY>=r.bottom-t)return}n.params.interact&&n.fireEvent("click",e,n.handleEvent(e))}),this.wrapper.addEventListener("scroll",function(e){return n.fireEvent("scroll",e)})}},{key:"drawPeaks",value:function(e,t,r,n){this.setWidth(t)||this.clearWave(),this.params.barWidth?this.drawBars(e,0,r,n):this.drawWave(e,0,r,n)}},{key:"resetScroll",value:function(){null!==this.wrapper&&(this.wrapper.scrollLeft=0)}},{key:"recenter",value:function(e){var t=this.wrapper.scrollWidth*e;this.recenterOnPosition(t,!0)}},{key:"recenterOnPosition",value:function(e,t){var r=this.wrapper.scrollLeft,n=~~(this.wrapper.clientWidth/2),i=this.wrapper.scrollWidth-this.wrapper.clientWidth,a=e-n,s=a-r;if(0!=i){if(!t&&-n<=s&&s<n){a=r+(s=Math.max(-5,Math.min(5,s)))}(a=Math.max(0,Math.min(i,a)))!=r&&(this.wrapper.scrollLeft=a)}}},{key:"getScrollX",value:function(){var e=this.params.pixelRatio,t=Math.round(this.wrapper.scrollLeft*e);if(this.params.scrollParent){var r=~~(this.wrapper.scrollWidth*e-this.getWidth());t=Math.min(r,Math.max(0,t))}return t}},{key:"getWidth",value:function(){return Math.round(this.container.clientWidth*this.params.pixelRatio)}},{key:"setWidth",value:function(e){return this.width!=e&&(this.width=e,this.params.fillParent||this.params.scrollParent?this.style(this.wrapper,{width:""}):this.style(this.wrapper,{width:~~(this.width/this.params.pixelRatio)+"px"}),this.updateSize(),!0)}},{key:"setHeight",value:function(e){return e!=this.height&&(this.height=e,this.style(this.wrapper,{height:~~(this.height/this.params.pixelRatio)+"px"}),this.updateSize(),!0)}},{key:"progress",value:function(e){var t=1/this.params.pixelRatio,r=Math.round(e*this.width)*t;if(r<this.lastPos||r-this.lastPos>=t){if(this.lastPos=r,this.params.scrollParent&&this.params.autoCenter){var n=~~(this.wrapper.scrollWidth*e);this.recenterOnPosition(n)}this.updateProgress(r)}}},{key:"destroy",value:function(){this.unAll(),this.wrapper&&(this.wrapper.parentNode==this.container&&this.container.removeChild(this.wrapper),this.wrapper=null)}},{key:"updateCursor",value:function(){}},{key:"updateSize",value:function(){}},{key:"drawBars",value:function(e,t,r,n){}},{key:"drawWave",value:function(e,t,r,n){}},{key:"clearWave",value:function(){}},{key:"updateProgress",value:function(e){}}])&&s(t.prototype,r),i&&s(t,i),n}();t.default=i,e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n,a=(n=r(3))&&n.__esModule?n:{default:n};!function(e){{if(e&&e.__esModule)return;var t={};if(null!=e)for(var r in e)if(Object.prototype.hasOwnProperty.call(e,r)){var n=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,r):{};n.get||n.set?Object.defineProperty(t,r,n):t[r]=e[r]}t.default=e}}(r(0));function i(e){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function s(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function o(e,t){return!t||"object"!==i(t)&&"function"!=typeof t?function(e){if(void 0!==e)return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(e):t}function u(e,t,r){return(u="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,r){var n=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=l(e)););return e}(e,t);if(n){var i=Object.getOwnPropertyDescriptor(n,t);return i.get?i.get.call(r):i.value}})(e,t,r||e)}function l(e){return(l=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function c(e,t){return(c=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}var h=function(e){function n(e){var t;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,n),(t=o(this,l(n).call(this,e))).params=e,t.media={currentTime:0,duration:0,paused:!0,playbackRate:1,play:function(){},pause:function(){},volume:0},t.mediaType=e.mediaType.toLowerCase(),t.elementPosition=e.elementPosition,t.peaks=null,t.playbackRate=1,t.volume=1,t.buffer=null,t.onPlayEnd=null,t}var t,r,i;return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&c(e,t)}(n,a.default),t=n,(r=[{key:"init",value:function(){this.setPlaybackRate(this.params.audioRate),this.createTimer()}},{key:"createTimer",value:function(){var t=this;this.on("play",function e(){t.isPaused()||(t.fireEvent("audioprocess",t.getCurrentTime()),(window.requestAnimationFrame||window.webkitRequestAnimationFrame)(e))}),this.on("pause",function(){t.fireEvent("audioprocess",t.getCurrentTime())})}},{key:"load",value:function(e,t,r,n){var i=document.createElement(this.mediaType);i.controls=this.params.mediaControls,i.autoplay=this.params.autoplay||!1,i.preload=null==n?"auto":n,i.src=e,i.style.width="100%";var a=t.querySelector(this.mediaType);a&&t.removeChild(a),t.appendChild(i),this._load(i,r)}},{key:"loadElt",value:function(e,t){e.controls=this.params.mediaControls,e.autoplay=this.params.autoplay||!1,this._load(e,t)}},{key:"_load",value:function(e,t){var r=this;"function"==typeof e.load&&e.load(),e.addEventListener("error",function(){r.fireEvent("error","Error loading media element")}),e.addEventListener("canplay",function(){r.fireEvent("canplay")}),e.addEventListener("ended",function(){r.fireEvent("finish")}),e.addEventListener("play",function(){r.fireEvent("play")}),e.addEventListener("pause",function(){r.fireEvent("pause")}),this.media=e,this.peaks=t,this.onPlayEnd=null,this.buffer=null,this.setPlaybackRate(this.playbackRate),this.setVolume(this.volume)}},{key:"isPaused",value:function(){return!this.media||this.media.paused}},{key:"getDuration",value:function(){if(this.explicitDuration)return this.explicitDuration;var e=(this.buffer||this.media).duration;return 1/0<=e&&(e=this.media.seekable.end(0)),e}},{key:"getCurrentTime",value:function(){return this.media&&this.media.currentTime}},{key:"getPlayedPercents",value:function(){return this.getCurrentTime()/this.getDuration()||0}},{key:"getPlaybackRate",value:function(){return this.playbackRate||this.media.playbackRate}},{key:"setPlaybackRate",value:function(e){this.playbackRate=e||1,this.media.playbackRate=this.playbackRate}},{key:"seekTo",value:function(e){null!=e&&(this.media.currentTime=e),this.clearPlayEnd()}},{key:"play",value:function(e,t){this.seekTo(e);var r=this.media.play();return t&&this.setPlayEnd(t),r}},{key:"pause",value:function(){var e;return this.media&&(e=this.media.pause()),this.clearPlayEnd(),e}},{key:"setPlayEnd",value:function(t){var r=this;this._onPlayEnd=function(e){t<=e&&(r.pause(),r.seekTo(t))},this.on("audioprocess",this._onPlayEnd)}},{key:"clearPlayEnd",value:function(){this._onPlayEnd&&(this.un("audioprocess",this._onPlayEnd),this._onPlayEnd=null)}},{key:"getPeaks",value:function(e,t,r){return this.buffer?u(l(n.prototype),"getPeaks",this).call(this,e,t,r):this.peaks||[]}},{key:"setSinkId",value:function(e){return e?this.media.setSinkId?this.media.setSinkId(e):Promise.reject(new Error("setSinkId is not supported in your browser")):Promise.reject(new Error("Invalid deviceId: "+e))}},{key:"getVolume",value:function(){return this.volume||this.media.volume}},{key:"setVolume",value:function(e){this.volume=e,this.media.volume=this.volume}},{key:"destroy",value:function(){this.pause(),this.unAll(),this.params.removeMediaElementOnDestroy&&this.media&&this.media.parentNode&&this.media.parentNode.removeChild(this.media),this.media=null}}])&&s(t.prototype,r),i&&s(t,i),n}();t.default=h,e.exports=t.default},function(e,t,r){"use strict";function i(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.clearPeakCache()}var t,r,n;return t=e,(r=[{key:"clearPeakCache",value:function(){this.peakCacheRanges=[],this.peakCacheLength=-1}},{key:"addRangeToPeakCache",value:function(e,t,r){e!=this.peakCacheLength&&(this.clearPeakCache(),this.peakCacheLength=e);for(var n=[],i=0;i<this.peakCacheRanges.length&&this.peakCacheRanges[i]<t;)i++;for(i%2==0&&n.push(t);i<this.peakCacheRanges.length&&this.peakCacheRanges[i]<=r;)n.push(this.peakCacheRanges[i]),i++;i%2==0&&n.push(r),n=n.filter(function(e,t,r){return 0==t?e!=r[t+1]:t==r.length-1?e!=r[t-1]:e!=r[t-1]&&e!=r[t+1]}),this.peakCacheRanges=this.peakCacheRanges.concat(n),this.peakCacheRanges=this.peakCacheRanges.sort(function(e,t){return e-t}).filter(function(e,t,r){return 0==t?e!=r[t+1]:t==r.length-1?e!=r[t-1]:e!=r[t-1]&&e!=r[t+1]});var a=[];for(i=0;i<n.length;i+=2)a.push([n[i],n[i+1]]);return a}},{key:"getCacheRanges",value:function(){var e,t=[];for(e=0;e<this.peakCacheRanges.length;e+=2)t.push([this.peakCacheRanges[e],this.peakCacheRanges[e+1]]);return t}}])&&i(t.prototype,r),n&&i(t,n),e}();t.default=n,e.exports=t.default}])});
//# sourceMappingURL=wavesurfer.min.js.map
/*!
 * wavesurfer.js 2.1.3 (2019-01-21)
 * https://github.com/katspaugh/wavesurfer.js
 * @license BSD-3-Clause
 */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("microphone",[],t):"object"==typeof exports?exports.microphone=t():(e.WaveSurfer=e.WaveSurfer||{},e.WaveSurfer.microphone=t())}(window,function(){return function(r){var i={};function n(e){if(i[e])return i[e].exports;var t=i[e]={i:e,l:!1,exports:{}};return r[e].call(t.exports,t,t.exports,n),t.l=!0,t.exports}return n.m=r,n.c=i,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(r,i,function(e){return t[e]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="localhost:8080/dist/plugin/",n(n.s=5)}({5:function(e,t,r){"use strict";function i(e,t){for(var r=0;r<t.length;r++){var i=t[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function n(e,t,r){return t&&i(e.prototype,t),r&&i(e,r),e}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var o=function(){function i(e,t){var r=this;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,i),this.params=e,this.wavesurfer=t,this.active=!1,this.paused=!1,this.browser=this.detectBrowser(),this.reloadBufferFunction=function(e){return r.reloadBuffer(e)};void 0===navigator.mediaDevices&&(navigator.mediaDevices={}),void 0===navigator.mediaDevices.getUserMedia&&(navigator.mediaDevices.getUserMedia=function(r,e,t){var i=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return i?new Promise(function(e,t){i.call(navigator,r,e,t)}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}),this.constraints=this.params.constraints||{video:!1,audio:!0},this.bufferSize=this.params.bufferSize||4096,this.numberOfInputChannels=this.params.numberOfInputChannels||1,this.numberOfOutputChannels=this.params.numberOfOutputChannels||1,this._onBackendCreated=function(){r.micContext=r.wavesurfer.backend.getAudioContext()}}return n(i,null,[{key:"create",value:function(e){return{name:"microphone",deferInit:!(!e||!e.deferInit)&&e.deferInit,params:e,instance:i}}}]),n(i,[{key:"init",value:function(){this.wavesurfer.on("backend-created",this._onBackendCreated),this.wavesurfer.backend&&this._onBackendCreated()}},{key:"destroy",value:function(){this.paused=!0,this.wavesurfer.un("backend-created",this._onBackendCreated),this.stop()}},{key:"start",value:function(){var t=this;navigator.mediaDevices.getUserMedia(this.constraints).then(function(e){return t.gotStream(e)}).catch(function(e){return t.deviceError(e)})}},{key:"togglePlay",value:function(){this.active?(this.paused=!this.paused,this.paused?this.pause():this.play()):this.start()}},{key:"play",value:function(){this.paused=!1,this.connect()}},{key:"pause",value:function(){this.paused=!0,this.disconnect()}},{key:"stop",value:function(){this.active&&(this.stopDevice(),this.wavesurfer.empty())}},{key:"stopDevice",value:function(){if(this.active=!1,this.disconnect(),this.stream){if(("chrome"===this.browser.browser&&45<=this.browser.version||"firefox"===this.browser.browser&&44<=this.browser.version||"edge"===this.browser.browser||"safari"===this.browser.browser)&&this.stream.getTracks)return void this.stream.getTracks().forEach(function(e){return e.stop()});this.stream.stop()}}},{key:"connect",value:function(){void 0!==this.stream&&("edge"===this.browser.browser&&(this.localAudioBuffer=this.micContext.createBuffer(this.numberOfInputChannels,this.bufferSize,this.micContext.sampleRate)),this.mediaStreamSource=this.micContext.createMediaStreamSource(this.stream),this.levelChecker=this.micContext.createScriptProcessor(this.bufferSize,this.numberOfInputChannels,this.numberOfOutputChannels),this.mediaStreamSource.connect(this.levelChecker),this.levelChecker.connect(this.micContext.destination),this.levelChecker.onaudioprocess=this.reloadBufferFunction)}},{key:"disconnect",value:function(){void 0!==this.mediaStreamSource&&this.mediaStreamSource.disconnect(),void 0!==this.levelChecker&&(this.levelChecker.disconnect(),this.levelChecker.onaudioprocess=void 0),void 0!==this.localAudioBuffer&&(this.localAudioBuffer=void 0)}},{key:"reloadBuffer",value:function(e){if(!this.paused)if(this.wavesurfer.empty(),"edge"===this.browser.browser){var t,r;for(t=0,r=Math.min(this.localAudioBuffer.numberOfChannels,e.inputBuffer.numberOfChannels);t<r;t++)this.localAudioBuffer.getChannelData(t).set(e.inputBuffer.getChannelData(t));this.wavesurfer.loadDecodedBuffer(this.localAudioBuffer)}else this.wavesurfer.loadDecodedBuffer(e.inputBuffer)}},{key:"gotStream",value:function(e){this.stream=e,this.active=!0,this.play(),this.fireEvent("deviceReady",e)}},{key:"deviceError",value:function(e){this.fireEvent("deviceError",e)}},{key:"extractVersion",value:function(e,t,r){var i=e.match(t);return i&&i.length>=r&&parseInt(i[r],10)}},{key:"detectBrowser",value:function(){var e={browser:null,version:null,minVersion:null};return"undefined"!=typeof window&&window.navigator?navigator.mozGetUserMedia?(e.browser="firefox",e.version=this.extractVersion(navigator.userAgent,/Firefox\/(\d+)\./,1),e.minVersion=31):navigator.webkitGetUserMedia?(e.browser="chrome",e.version=this.extractVersion(navigator.userAgent,/Chrom(e|ium)\/(\d+)\./,2),e.minVersion=38):navigator.mediaDevices&&navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)?(e.browser="edge",e.version=this.extractVersion(navigator.userAgent,/Edge\/(\d+).(\d+)$/,2),e.minVersion=10547):window.RTCPeerConnection&&navigator.userAgent.match(/AppleWebKit\/(\d+)\./)?(e.browser="safari",e.minVersion=11,e.version=this.extractVersion(navigator.userAgent,/AppleWebKit\/(\d+)\./,1)):e.browser="Not a supported browser.":e.browser="Not a supported browser.",e}}]),i}();t.default=o,e.exports=t.default}})});
//# sourceMappingURL=wavesurfer.microphone.min.js.map
//
//

/*!
 * wavesurfer.js 2.1.3 (2019-01-21)
 * https://github.com/katspaugh/wavesurfer.js
 * @license BSD-3-Clause
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("regions", [], factory);
	else if(typeof exports === 'object')
		exports["regions"] = factory();
	else
		root["WaveSurfer"] = root["WaveSurfer"] || {}, root["WaveSurfer"]["regions"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "localhost:8080/dist/plugin/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/plugin/regions.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/plugin/regions.js":
/*!*******************************!*\
  !*** ./src/plugin/regions.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * (Single) Region plugin class
 *
 * Must be turned into an observer before instantiating. This is done in
 * RegionsPlugin (main plugin class)
 *
 * @extends {Observer}
 */
var Region =
/*#__PURE__*/
function () {
  function Region(params, ws) {
    var _this = this;

    _classCallCheck(this, Region);

    this.wavesurfer = ws;
    this.wrapper = ws.drawer.wrapper;
    this.util = ws.util;
    this.style = this.util.style;
    this.id = params.id == null ? ws.util.getId() : params.id;
    this.start = Number(params.start) || 0;
    this.end = params.end == null ? // small marker-like region
    this.start + 4 / this.wrapper.scrollWidth * this.wavesurfer.getDuration() : Number(params.end);
    this.resize = params.resize === undefined ? true : Boolean(params.resize);
    this.drag = params.drag === undefined ? true : Boolean(params.drag);
    this.loop = Boolean(params.loop);
    this.color = params.color || 'rgba(0, 0, 0, 0.1)';
    this.data = params.data || {};
    this.attributes = params.attributes || {};
    this.maxLength = params.maxLength;
    this.minLength = params.minLength;

    this._onRedraw = function () {
      return _this.updateRender();
    };

    this.scroll = params.scroll !== false && ws.params.scrollParent;
    this.scrollSpeed = params.scrollSpeed || 1;
    this.scrollThreshold = params.scrollThreshold || 10;
    this.bindInOut();
    this.render();
    this.wavesurfer.on('zoom', this._onRedraw);
    this.wavesurfer.on('redraw', this._onRedraw);
    this.wavesurfer.fireEvent('region-created', this);
  }
  /* Update region params. */


  _createClass(Region, [{
    key: "update",
    value: function update(params) {
      if (null != params.start) {
        this.start = Number(params.start);
      }

      if (null != params.end) {
        this.end = Number(params.end);
      }

      if (null != params.loop) {
        this.loop = Boolean(params.loop);
      }

      if (null != params.color) {
        this.color = params.color;
      }

      if (null != params.data) {
        this.data = params.data;
      }

      if (null != params.resize) {
        this.resize = Boolean(params.resize);
      }

      if (null != params.drag) {
        this.drag = Boolean(params.drag);
      }

      if (null != params.maxLength) {
        this.maxLength = Number(params.maxLength);
      }

      if (null != params.minLength) {
        this.minLength = Number(params.minLength);
      }

      if (null != params.attributes) {
        this.attributes = params.attributes;
      }

      this.updateRender();
      this.fireEvent('update');
      this.wavesurfer.fireEvent('region-updated', this);
    }
    /* Remove a single region. */

  }, {
    key: "remove",
    value: function remove() {
      if (this.element) {
        this.wrapper.removeChild(this.element);
        this.element = null;
        this.fireEvent('remove');
        this.wavesurfer.un('zoom', this._onRedraw);
        this.wavesurfer.un('redraw', this._onRedraw);
        this.wavesurfer.fireEvent('region-removed', this);
      }
    }
    /* Play the audio region. */

  }, {
    key: "play",
    value: function play() {
      this.wavesurfer.play(this.start, this.end);
      this.fireEvent('play');
      this.wavesurfer.fireEvent('region-play', this);
    }
    /* Play the region in loop. */

  }, {
    key: "playLoop",
    value: function playLoop() {
      var _this2 = this;

      this.play();
      this.once('out', function () {
        return _this2.playLoop();
      });
    }
    /* Render a region as a DOM element. */

  }, {
    key: "render",
    value: function render() {
      var regionEl = document.createElement('region');
      regionEl.className = 'wavesurfer-region';
      regionEl.title = this.formatTime(this.start, this.end);
      regionEl.setAttribute('data-id', this.id);

      for (var attrname in this.attributes) {
        regionEl.setAttribute('data-region-' + attrname, this.attributes[attrname]);
      }

      var width = this.wrapper.scrollWidth;
      this.style(regionEl, {
        position: 'absolute',
        zIndex: 2,
        height: '100%',
        top: '0px'
      });
      /* Resize handles */

      if (this.resize) {
        var handleLeft = regionEl.appendChild(document.createElement('handle'));
        var handleRight = regionEl.appendChild(document.createElement('handle'));
        handleLeft.className = 'wavesurfer-handle wavesurfer-handle-start';
        handleRight.className = 'wavesurfer-handle wavesurfer-handle-end';
        var css = {
          cursor: 'col-resize',
          position: 'absolute',
          left: '0px',
          top: '0px',
          width: '1%',
          maxWidth: '4px',
          height: '100%'
        };
        this.style(handleLeft, css);
        this.style(handleRight, css);
        this.style(handleRight, {
          left: '100%'
        });
      }

      this.element = this.wrapper.appendChild(regionEl);
      this.updateRender();
      this.bindEvents(regionEl);
    }
  }, {
    key: "formatTime",
    value: function formatTime(start, end) {
      return (start == end ? [start] : [start, end]).map(function (time) {
        return [Math.floor(time % 3600 / 60), // minutes
        ('00' + Math.floor(time % 60)).slice(-2) // seconds
        ].join(':');
      }).join('-');
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;
    }
    /* Update element's position, width, color. */

  }, {
    key: "updateRender",
    value: function updateRender() {
      var dur = this.wavesurfer.getDuration();
      var width = this.getWidth();

      if (this.start < 0) {
        this.start = 0;
        this.end = this.end - this.start;
      }

      if (this.end > dur) {
        this.end = dur;
        this.start = dur - (this.end - this.start);
      }

      if (this.minLength != null) {
        this.end = Math.max(this.start + this.minLength, this.end);
      }

      if (this.maxLength != null) {
        this.end = Math.min(this.start + this.maxLength, this.end);
      }

      if (this.element != null) {
        // Calculate the left and width values of the region such that
        // no gaps appear between regions.
        var left = Math.round(this.start / dur * width);
        var regionWidth = Math.round(this.end / dur * width) - left;
        this.style(this.element, {
          left: left + 'px',
          width: regionWidth + 'px',
          backgroundColor: this.color,
          cursor: this.drag ? 'move' : 'default'
        });

        for (var attrname in this.attributes) {
          this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);
        }

        this.element.title = this.formatTime(this.start, this.end);
      }
    }
    /* Bind audio events. */

  }, {
    key: "bindInOut",
    value: function bindInOut() {
      var _this3 = this;

      this.firedIn = false;
      this.firedOut = false;

      var onProcess = function onProcess(time) {
        if (!_this3.firedOut && _this3.firedIn && (_this3.start >= Math.round(time * 100) / 100 || _this3.end <= Math.round(time * 100) / 100)) {
          _this3.firedOut = true;
          _this3.firedIn = false;

          _this3.fireEvent('out');

          _this3.wavesurfer.fireEvent('region-out', _this3);
        }

        if (!_this3.firedIn && _this3.start <= time && _this3.end > time) {
          _this3.firedIn = true;
          _this3.firedOut = false;

          _this3.fireEvent('in');

          _this3.wavesurfer.fireEvent('region-in', _this3);
        }
      };

      this.wavesurfer.backend.on('audioprocess', onProcess);
      this.on('remove', function () {
        _this3.wavesurfer.backend.un('audioprocess', onProcess);
      });
      /* Loop playback. */

      this.on('out', function () {
        if (_this3.loop) {
          _this3.wavesurfer.play(_this3.start);
        }
      });
    }
    /* Bind DOM events. */

  }, {
    key: "bindEvents",
    value: function bindEvents() {
      var _this4 = this;

      this.element.addEventListener('mouseenter', function (e) {
        _this4.fireEvent('mouseenter', e);

        _this4.wavesurfer.fireEvent('region-mouseenter', _this4, e);
      });
      this.element.addEventListener('mouseleave', function (e) {
        _this4.fireEvent('mouseleave', e);

        _this4.wavesurfer.fireEvent('region-mouseleave', _this4, e);
      });
      this.element.addEventListener('click', function (e) {
        e.preventDefault();

        _this4.fireEvent('click', e);

        _this4.wavesurfer.fireEvent('region-click', _this4, e);
      });
      this.element.addEventListener('dblclick', function (e) {
        e.stopPropagation();
        e.preventDefault();

        _this4.fireEvent('dblclick', e);

        _this4.wavesurfer.fireEvent('region-dblclick', _this4, e);
      });
      /* Drag or resize on mousemove. */

      (this.drag || this.resize) && function () {
        var container = _this4.wavesurfer.drawer.container;

        var duration = _this4.wavesurfer.getDuration();

        var scrollSpeed = _this4.scrollSpeed;
        var scrollThreshold = _this4.scrollThreshold;
        var startTime;
        var touchId;
        var drag;
        var maxScroll;
        var resize;
        var updated = false;
        var scrollDirection;
        var wrapperRect; // Scroll when the user is dragging within the threshold

        var edgeScroll = function edgeScroll(e) {
          if (!scrollDirection || !drag && !resize) {
            return;
          } // Update scroll position


          var scrollLeft = _this4.wrapper.scrollLeft + scrollSpeed * scrollDirection;
          _this4.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft)); // Update time

          var time = _this4.wavesurfer.drawer.handleEvent(e) * duration;
          var delta = time - startTime;
          startTime = time; // Continue dragging or resizing

          drag ? _this4.onDrag(delta) : _this4.onResize(delta, resize); // Repeat

          window.requestAnimationFrame(function () {
            edgeScroll(e);
          });
        };

        var onDown = function onDown(e) {
          if (e.touches && e.touches.length > 1) {
            return;
          }

          touchId = e.targetTouches ? e.targetTouches[0].identifier : null;
          e.stopPropagation();
          startTime = _this4.wavesurfer.drawer.handleEvent(e, true) * duration; // Store for scroll calculations

          maxScroll = _this4.wrapper.scrollWidth - _this4.wrapper.clientWidth;
          wrapperRect = _this4.wrapper.getBoundingClientRect();

          if (e.target.tagName.toLowerCase() == 'handle') {
            if (e.target.classList.contains('wavesurfer-handle-start')) {
              resize = 'start';
            } else {
              resize = 'end';
            }
          } else {
            drag = true;
            resize = false;
          }
        };

        var onUp = function onUp(e) {
          if (e.touches && e.touches.length > 1) {
            return;
          }

          if (drag || resize) {
            drag = false;
            scrollDirection = null;
            resize = false;
          }

          if (updated) {
            updated = false;

            _this4.util.preventClick();

            _this4.fireEvent('update-end', e);

            _this4.wavesurfer.fireEvent('region-update-end', _this4, e);
          }
        };

        var onMove = function onMove(e) {
          if (e.touches && e.touches.length > 1) {
            return;
          }

          if (e.targetTouches && e.targetTouches[0].identifier != touchId) {
            return;
          }

          if (drag || resize) {
            var oldTime = startTime;
            var time = _this4.wavesurfer.drawer.handleEvent(e) * duration;
            var delta = time - startTime;
            startTime = time; // Drag

            if (_this4.drag && drag) {
              updated = updated || !!delta;

              _this4.onDrag(delta);
            } // Resize


            if (_this4.resize && resize) {
              updated = updated || !!delta;

              _this4.onResize(delta, resize);
            }

            if (_this4.scroll && container.clientWidth < _this4.wrapper.scrollWidth) {
              if (drag) {
                // The threshold is not between the mouse and the container edge
                // but is between the region and the container edge
                var regionRect = _this4.element.getBoundingClientRect();

                var x = regionRect.left - wrapperRect.left; // Check direction

                if (time < oldTime && x >= 0) {
                  scrollDirection = -1;
                } else if (time > oldTime && x + regionRect.width <= wrapperRect.right) {
                  scrollDirection = 1;
                } // Check that we are still beyond the threshold


                if (scrollDirection === -1 && x > scrollThreshold || scrollDirection === 1 && x + regionRect.width < wrapperRect.right - scrollThreshold) {
                  scrollDirection = null;
                }
              } else {
                // Mouse based threshold
                var _x = e.clientX - wrapperRect.left; // Check direction


                if (_x <= scrollThreshold) {
                  scrollDirection = -1;
                } else if (_x >= wrapperRect.right - scrollThreshold) {
                  scrollDirection = 1;
                } else {
                  scrollDirection = null;
                }
              }

              scrollDirection && edgeScroll(e);
            }
          }
        };

        _this4.element.addEventListener('mousedown', onDown);

        _this4.element.addEventListener('touchstart', onDown);

        _this4.wrapper.addEventListener('mousemove', onMove);

        _this4.wrapper.addEventListener('touchmove', onMove);

        document.body.addEventListener('mouseup', onUp);
        document.body.addEventListener('touchend', onUp);

        _this4.on('remove', function () {
          document.body.removeEventListener('mouseup', onUp);
          document.body.removeEventListener('touchend', onUp);

          _this4.wrapper.removeEventListener('mousemove', onMove);

          _this4.wrapper.removeEventListener('touchmove', onMove);
        });

        _this4.wavesurfer.on('destroy', function () {
          document.body.removeEventListener('mouseup', onUp);
          document.body.removeEventListener('touchend', onUp);
        });
      }();
    }
  }, {
    key: "onDrag",
    value: function onDrag(delta) {
      var maxEnd = this.wavesurfer.getDuration();

      if (this.end + delta > maxEnd || this.start + delta < 0) {
        return;
      }

      this.update({
        start: this.start + delta,
        end: this.end + delta
      });
    }
  }, {
    key: "onResize",
    value: function onResize(delta, direction) {
      if (direction == 'start') {
        this.update({
          start: Math.min(this.start + delta, this.end),
          end: Math.max(this.start + delta, this.end)
        });
      } else {
        this.update({
          start: Math.min(this.end + delta, this.start),
          end: Math.max(this.end + delta, this.start)
        });
      }
    }
  }]);

  return Region;
}();
/**
 * @typedef {Object} RegionsPluginParams
 * @property {?boolean} dragSelection Enable creating regions by dragging with
 * the mouse
 * @property {?RegionParams[]} regions Regions that should be added upon
 * initialisation
 * @property {number} slop=2 The sensitivity of the mouse dragging
 * @property {?boolean} deferInit Set to true to manually call
 * `initPlugin('regions')`
 */

/**
 * @typedef {Object} RegionParams
 * @desc The parameters used to describe a region.
 * @example wavesurfer.addRegion(regionParams);
 * @property {string} id=random The id of the region
 * @property {number} start=0 The start position of the region (in seconds).
 * @property {number} end=0 The end position of the region (in seconds).
 * @property {?boolean} loop Whether to loop the region when played back.
 * @property {boolean} drag=true Allow/disallow dragging the region.
 * @property {boolean} resize=true Allow/disallow resizing the region.
 * @property {string} [color='rgba(0, 0, 0, 0.1)'] HTML color code.
 */

/**
 * Regions are visual overlays on waveform that can be used to play and loop
 * portions of audio. Regions can be dragged and resized.
 *
 * Visual customization is possible via CSS (using the selectors
 * `.wavesurfer-region` and `.wavesurfer-handle`).
 *
 * @implements {PluginClass}
 * @extends {Observer}
 *
 * @example
 * // es6
 * import RegionsPlugin from 'wavesurfer.regions.js';
 *
 * // commonjs
 * var RegionsPlugin = require('wavesurfer.regions.js');
 *
 * // if you are using <script> tags
 * var RegionsPlugin = window.WaveSurfer.regions;
 *
 * // ... initialising wavesurfer with the plugin
 * var wavesurfer = WaveSurfer.create({
 *   // wavesurfer options ...
 *   plugins: [
 *     RegionsPlugin.create({
 *       // plugin options ...
 *     })
 *   ]
 * });
 */


var RegionsPlugin =
/*#__PURE__*/
function () {
  _createClass(RegionsPlugin, null, [{
    key: "create",

    /**
     * Regions plugin definition factory
     *
     * This function must be used to create a plugin definition which can be
     * used by wavesurfer to correctly instantiate the plugin.
     *
     * @param {RegionsPluginParams} params parameters use to initialise the plugin
     * @return {PluginDefinition} an object representing the plugin
     */
    value: function create(params) {
      return {
        name: 'regions',
        deferInit: params && params.deferInit ? params.deferInit : false,
        params: params,
        staticProps: {
          initRegions: function initRegions() {
            console.warn('Deprecated initRegions! Use wavesurfer.initPlugins("regions") instead!');
            this.initPlugin('regions');
          },
          addRegion: function addRegion(options) {
            if (!this.initialisedPluginList.regions) {
              this.initPlugin('regions');
            }

            return this.regions.add(options);
          },
          clearRegions: function clearRegions() {
            this.regions && this.regions.clear();
          },
          enableDragSelection: function enableDragSelection(options) {
            if (!this.initialisedPluginList.regions) {
              this.initPlugin('regions');
            }

            this.regions.enableDragSelection(options);
          },
          disableDragSelection: function disableDragSelection() {
            this.regions.disableDragSelection();
          }
        },
        instance: RegionsPlugin
      };
    }
  }]);

  function RegionsPlugin(params, ws) {
    var _this5 = this;

    _classCallCheck(this, RegionsPlugin);

    this.params = params;
    this.wavesurfer = ws;
    this.util = ws.util; // turn the plugin instance into an observer

    var observerPrototypeKeys = Object.getOwnPropertyNames(this.util.Observer.prototype);
    observerPrototypeKeys.forEach(function (key) {
      Region.prototype[key] = _this5.util.Observer.prototype[key];
    });
    this.wavesurfer.Region = Region; // Id-based hash of regions.

    this.list = {};

    this._onReady = function () {
      _this5.wrapper = _this5.wavesurfer.drawer.wrapper;

      if (_this5.params.regions) {
        _this5.params.regions.forEach(function (region) {
          _this5.add(region);
        });
      }

      if (_this5.params.dragSelection) {
        _this5.enableDragSelection(_this5.params);
      }
    };
  }

  _createClass(RegionsPlugin, [{
    key: "init",
    value: function init() {
      // Check if ws is ready
      if (this.wavesurfer.isReady) {
        this._onReady();
      }

      this.wavesurfer.on('ready', this._onReady);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.wavesurfer.un('ready', this._onReady);
      this.disableDragSelection();
      this.clear();
    }
    /* Add a region. */

  }, {
    key: "add",
    value: function add(params) {
      var _this6 = this;

      var region = new this.wavesurfer.Region(params, this.wavesurfer);
      this.list[region.id] = region;
      region.on('remove', function () {
        delete _this6.list[region.id];
      });
      return region;
    }
    /* Remove all regions. */

  }, {
    key: "clear",
    value: function clear() {
      var _this7 = this;

      Object.keys(this.list).forEach(function (id) {
        _this7.list[id].remove();
      });
    }
  }, {
    key: "enableDragSelection",
    value: function enableDragSelection(params) {
      var _this8 = this;

      var slop = params.slop || 2;
      var container = this.wavesurfer.drawer.container;
      var scroll = params.scroll !== false && this.wavesurfer.params.scrollParent;
      var scrollSpeed = params.scrollSpeed || 1;
      var scrollThreshold = params.scrollThreshold || 10;
      var drag;
      var duration = this.wavesurfer.getDuration();
      var maxScroll;
      var start;
      var region;
      var touchId;
      var pxMove = 0;
      var scrollDirection;
      var wrapperRect; // Scroll when the user is dragging within the threshold

      var edgeScroll = function edgeScroll(e) {
        if (!region || !scrollDirection) {
          return;
        } // Update scroll position


        var scrollLeft = _this8.wrapper.scrollLeft + scrollSpeed * scrollDirection;
        _this8.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft)); // Update range

        var end = _this8.wavesurfer.drawer.handleEvent(e);

        region.update({
          start: Math.min(end * duration, start * duration),
          end: Math.max(end * duration, start * duration)
        }); // Check that there is more to scroll and repeat

        if (scrollLeft < maxScroll && scrollLeft > 0) {
          window.requestAnimationFrame(function () {
            edgeScroll(e);
          });
        }
      };

      var eventDown = function eventDown(e) {
        if (e.touches && e.touches.length > 1) {
          return;
        }

        duration = _this8.wavesurfer.getDuration();
        touchId = e.targetTouches ? e.targetTouches[0].identifier : null; // Store for scroll calculations

        maxScroll = _this8.wrapper.scrollWidth - _this8.wrapper.clientWidth;
        wrapperRect = _this8.wrapper.getBoundingClientRect();
        drag = true;
        start = _this8.wavesurfer.drawer.handleEvent(e, true);
        region = null;
        scrollDirection = null;
      };

      this.wrapper.addEventListener('mousedown', eventDown);
      this.wrapper.addEventListener('touchstart', eventDown);
      this.on('disable-drag-selection', function () {
        _this8.wrapper.removeEventListener('touchstart', eventDown);

        _this8.wrapper.removeEventListener('mousedown', eventDown);
      });

      var eventUp = function eventUp(e) {
        if (e.touches && e.touches.length > 1) {
          return;
        }

        drag = false;
        pxMove = 0;
        scrollDirection = null;

        if (region) {
          _this8.util.preventClick();

          region.fireEvent('update-end', e);

          _this8.wavesurfer.fireEvent('region-update-end', region, e);
        }

        region = null;
      };

      this.wrapper.addEventListener('mouseup', eventUp);
      this.wrapper.addEventListener('touchend', eventUp);
      document.body.addEventListener('mouseup', eventUp);
      document.body.addEventListener('touchend', eventUp);
      this.on('disable-drag-selection', function () {
        document.body.removeEventListener('mouseup', eventUp);
        document.body.removeEventListener('touchend', eventUp);

        _this8.wrapper.removeEventListener('touchend', eventUp);

        _this8.wrapper.removeEventListener('mouseup', eventUp);
      });

      var eventMove = function eventMove(e) {
        if (!drag) {
          return;
        }

        if (++pxMove <= slop) {
          return;
        }

        if (e.touches && e.touches.length > 1) {
          return;
        }

        if (e.targetTouches && e.targetTouches[0].identifier != touchId) {
          return;
        }

        if (!region) {
          region = _this8.add(params || {});
        }

        var end = _this8.wavesurfer.drawer.handleEvent(e);

        region.update({
          start: Math.min(end * duration, start * duration),
          end: Math.max(end * duration, start * duration)
        }); // If scrolling is enabled

        if (scroll && container.clientWidth < _this8.wrapper.scrollWidth) {
          // Check threshold based on mouse
          var x = e.clientX - wrapperRect.left;

          if (x <= scrollThreshold) {
            scrollDirection = -1;
          } else if (x >= wrapperRect.right - scrollThreshold) {
            scrollDirection = 1;
          } else {
            scrollDirection = null;
          }

          scrollDirection && edgeScroll(e);
        }
      };

      this.wrapper.addEventListener('mousemove', eventMove);
      this.wrapper.addEventListener('touchmove', eventMove);
      this.on('disable-drag-selection', function () {
        _this8.wrapper.removeEventListener('touchmove', eventMove);

        _this8.wrapper.removeEventListener('mousemove', eventMove);
      });
    }
  }, {
    key: "disableDragSelection",
    value: function disableDragSelection() {
      this.fireEvent('disable-drag-selection');
    }
    /* Get current region
     *  The smallest region that contains the current time.
     *  If several such regions exist, we take the first.
     *  Return null if none exist. */

  }, {
    key: "getCurrentRegion",
    value: function getCurrentRegion() {
      var _this9 = this;

      var time = this.wavesurfer.getCurrentTime();
      var min = null;
      Object.keys(this.list).forEach(function (id) {
        var cur = _this9.list[id];

        if (cur.start <= time && cur.end >= time) {
          if (!min || cur.end - cur.start < min.end - min.start) {
            min = cur;
          }
        }
      });
      return min;
    }
  }]);

  return RegionsPlugin;
}();

exports.default = RegionsPlugin;
module.exports = exports.default;

/***/ })

/******/ });
});
//# sourceMappingURL=wavesurfer.regions.js.map

;(function(self) {
  var Module = self.Mp3LameEncoderConfig;

// The Module object: Our interface to the outside world. We import
// and export values on it, and do the work to get that through
// closure compiler if necessary. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to do an eval in order to handle the closure compiler
// case, where this code here is minified but Module was defined
// elsewhere (e.g. case 4 above). We also need to check if Module
// already exists (e.g. case 3 above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module;
if (!Module) Module = (typeof Module !== 'undefined' ? Module : null) || {};

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
for (var key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

// The environment setup code below is customized to use Module.
// *** Environment setup code ***
var ENVIRONMENT_IS_WEB = typeof window === 'object';
var ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function' && !ENVIRONMENT_IS_WEB;
// Three configurations we can be running in:
// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)
// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)
// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)
var ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (ENVIRONMENT_IS_NODE) {
  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  if (!Module['print']) Module['print'] = function print(x) {
    process['stdout'].write(x + '\n');
  };
  if (!Module['printErr']) Module['printErr'] = function printErr(x) {
    process['stderr'].write(x + '\n');
  };

  var nodeFS = require('fs');
  var nodePath = require('path');

  Module['read'] = function read(filename, binary) {
    filename = nodePath['normalize'](filename);
    var ret = nodeFS['readFileSync'](filename);
    // The path is absolute if the normalized version is the same as the resolved.
    if (!ret && filename != nodePath['resolve'](filename)) {
      filename = path.join(__dirname, '..', 'src', filename);
      ret = nodeFS['readFileSync'](filename);
    }
    if (ret && !binary) ret = ret.toString();
    return ret;
  };

  Module['readBinary'] = function readBinary(filename) { return Module['read'](filename, true) };

  Module['load'] = function load(f) {
    globalEval(read(f));
  };

  if (!Module['thisProgram']) {
    if (process['argv'].length > 1) {
      Module['thisProgram'] = process['argv'][1].replace(/\\/g, '/');
    } else {
      Module['thisProgram'] = 'unknown-program';
    }
  }

  Module['arguments'] = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });

  Module['inspect'] = function () { return '[Emscripten Module object]'; };
}
else if (ENVIRONMENT_IS_SHELL) {
  if (!Module['print']) Module['print'] = print;
  if (typeof printErr != 'undefined') Module['printErr'] = printErr; // not present in v8 or older sm

  if (typeof read != 'undefined') {
    Module['read'] = read;
  } else {
    Module['read'] = function read() { throw 'no read() available (jsc?)' };
  }

  Module['readBinary'] = function readBinary(f) {
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    var data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    Module['arguments'] = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

}
else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  Module['read'] = function read(url) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send(null);
    return xhr.responseText;
  };

  if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  if (typeof console !== 'undefined') {
    if (!Module['print']) Module['print'] = function print(x) {
      console.log(x);
    };
    if (!Module['printErr']) Module['printErr'] = function printErr(x) {
      console.log(x);
    };
  } else {
    // Probably a worker, and without console.log. We can do very little here...
    var TRY_USE_DUMP = false;
    if (!Module['print']) Module['print'] = (TRY_USE_DUMP && (typeof(dump) !== "undefined") ? (function(x) {
      dump(x);
    }) : (function(x) {
      // self.postMessage(x); // enable this if you want stdout to be sent as messages
    }));
  }

  if (ENVIRONMENT_IS_WORKER) {
    Module['load'] = importScripts;
  }

  if (typeof Module['setWindowTitle'] === 'undefined') {
    Module['setWindowTitle'] = function(title) { document.title = title };
  }
}
else {
  // Unreachable because SHELL is dependant on the others
  throw 'Unknown runtime environment. Where are we?';
}

function globalEval(x) {
  eval.call(null, x);
}
if (!Module['load'] && Module['read']) {
  Module['load'] = function load(f) {
    globalEval(Module['read'](f));
  };
}
if (!Module['print']) {
  Module['print'] = function(){};
}
if (!Module['printErr']) {
  Module['printErr'] = Module['print'];
}
if (!Module['arguments']) {
  Module['arguments'] = [];
}
if (!Module['thisProgram']) {
  Module['thisProgram'] = './this.program';
}

// *** Environment setup code ***

// Closure helpers
Module.print = Module['print'];
Module.printErr = Module['printErr'];

// Callbacks
Module['preRun'] = [];
Module['postRun'] = [];

// Merge back in the overrides
for (var key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}



// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in: 
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at: 
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

//========================================
// Runtime code shared with compiler
//========================================

var Runtime = {
  setTempRet0: function (value) {
    tempRet0 = value;
  },
  getTempRet0: function () {
    return tempRet0;
  },
  stackSave: function () {
    return STACKTOP;
  },
  stackRestore: function (stackTop) {
    STACKTOP = stackTop;
  },
  getNativeTypeSize: function (type) {
    switch (type) {
      case 'i1': case 'i8': return 1;
      case 'i16': return 2;
      case 'i32': return 4;
      case 'i64': return 8;
      case 'float': return 4;
      case 'double': return 8;
      default: {
        if (type[type.length-1] === '*') {
          return Runtime.QUANTUM_SIZE; // A pointer
        } else if (type[0] === 'i') {
          var bits = parseInt(type.substr(1));
          assert(bits % 8 === 0);
          return bits/8;
        } else {
          return 0;
        }
      }
    }
  },
  getNativeFieldSize: function (type) {
    return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
  },
  STACK_ALIGN: 16,
  prepVararg: function (ptr, type) {
    if (type === 'double' || type === 'i64') {
      // move so the load is aligned
      if (ptr & 7) {
        assert((ptr & 7) === 4);
        ptr += 4;
      }
    } else {
      assert((ptr & 3) === 0);
    }
    return ptr;
  },
  getAlignSize: function (type, size, vararg) {
    // we align i64s and doubles on 64-bit boundaries, unlike x86
    if (!vararg && (type == 'i64' || type == 'double')) return 8;
    if (!type) return Math.min(size, 8); // align structures internally to 64 bits
    return Math.min(size || (type ? Runtime.getNativeFieldSize(type) : 0), Runtime.QUANTUM_SIZE);
  },
  dynCall: function (sig, ptr, args) {
    if (args && args.length) {
      if (!args.splice) args = Array.prototype.slice.call(args);
      args.splice(0, 0, ptr);
      return Module['dynCall_' + sig].apply(null, args);
    } else {
      return Module['dynCall_' + sig].call(null, ptr);
    }
  },
  functionPointers: [],
  addFunction: function (func) {
    for (var i = 0; i < Runtime.functionPointers.length; i++) {
      if (!Runtime.functionPointers[i]) {
        Runtime.functionPointers[i] = func;
        return 2*(1 + i);
      }
    }
    throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';
  },
  removeFunction: function (index) {
    Runtime.functionPointers[(index-2)/2] = null;
  },
  warnOnce: function (text) {
    if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
    if (!Runtime.warnOnce.shown[text]) {
      Runtime.warnOnce.shown[text] = 1;
      Module.printErr(text);
    }
  },
  funcWrappers: {},
  getFuncWrapper: function (func, sig) {
    assert(sig);
    if (!Runtime.funcWrappers[sig]) {
      Runtime.funcWrappers[sig] = {};
    }
    var sigCache = Runtime.funcWrappers[sig];
    if (!sigCache[func]) {
      sigCache[func] = function dynCall_wrapper() {
        return Runtime.dynCall(sig, func, arguments);
      };
    }
    return sigCache[func];
  },
  getCompilerSetting: function (name) {
    throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work';
  },
  stackAlloc: function (size) { var ret = STACKTOP;STACKTOP = (STACKTOP + size)|0;STACKTOP = (((STACKTOP)+15)&-16); return ret; },
  staticAlloc: function (size) { var ret = STATICTOP;STATICTOP = (STATICTOP + size)|0;STATICTOP = (((STATICTOP)+15)&-16); return ret; },
  dynamicAlloc: function (size) { var ret = DYNAMICTOP;DYNAMICTOP = (DYNAMICTOP + size)|0;DYNAMICTOP = (((DYNAMICTOP)+15)&-16); if (DYNAMICTOP >= TOTAL_MEMORY) { var success = enlargeMemory(); if (!success) { DYNAMICTOP = ret; return 0; } }; return ret; },
  alignMemory: function (size,quantum) { var ret = size = Math.ceil((size)/(quantum ? quantum : 16))*(quantum ? quantum : 16); return ret; },
  makeBigInt: function (low,high,unsigned) { var ret = (unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0))); return ret; },
  GLOBAL_BASE: 8,
  QUANTUM_SIZE: 4,
  __dummy__: 0
}


Module['Runtime'] = Runtime;



//========================================
// Runtime essentials
//========================================

var __THREW__ = 0; // Used in checking for thrown exceptions.

var ABORT = false; // whether we are quitting the application. no code should run after this. set in exit() and abort()
var EXITSTATUS = 0;

var undef = 0;
// tempInt is used for 32-bit signed values or smaller. tempBigInt is used
// for 32-bit unsigned values or more than 32 bits. TODO: audit all uses of tempInt
var tempValue, tempInt, tempBigInt, tempInt2, tempBigInt2, tempPair, tempBigIntI, tempBigIntR, tempBigIntS, tempBigIntP, tempBigIntD, tempDouble, tempFloat;
var tempI64, tempI64b;
var tempRet0, tempRet1, tempRet2, tempRet3, tempRet4, tempRet5, tempRet6, tempRet7, tempRet8, tempRet9;

function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

var globalScope = this;

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  if (!func) {
    try {
      func = eval('_' + ident); // explicit lookup
    } catch(e) {}
  }
  assert(func, 'Cannot call unknown function ' + ident + ' (perhaps LLVM optimizations or closure removed it?)');
  return func;
}

var cwrap, ccall;
(function(){
  var JSfuncs = {
    // Helpers for cwrap -- it can't refer to Runtime directly because it might
    // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find
    // out what the minified function name is.
    'stackSave': function() {
      Runtime.stackSave()
    },
    'stackRestore': function() {
      Runtime.stackRestore()
    },
    // type conversion from js to c
    'arrayToC' : function(arr) {
      var ret = Runtime.stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    },
    'stringToC' : function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        ret = Runtime.stackAlloc((str.length << 2) + 1);
        writeStringToMemory(str, ret);
      }
      return ret;
    }
  };
  // For fast lookup of conversion functions
  var toC = {'string' : JSfuncs['stringToC'], 'array' : JSfuncs['arrayToC']};

  // C calling interface. 
  ccall = function ccallFunc(ident, returnType, argTypes, args, opts) {
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0) stack = Runtime.stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func.apply(null, cArgs);
    if (returnType === 'string') ret = Pointer_stringify(ret);
    if (stack !== 0) {
      if (opts && opts.async) {
        EmterpreterAsync.asyncFinalizers.push(function() {
          Runtime.stackRestore(stack);
        });
        return;
      }
      Runtime.stackRestore(stack);
    }
    return ret;
  }

  var sourceRegex = /^function\s*\(([^)]*)\)\s*{\s*([^*]*?)[\s;]*(?:return\s*(.*?)[;\s]*)?}$/;
  function parseJSFunc(jsfunc) {
    // Match the body and the return value of a javascript function source
    var parsed = jsfunc.toString().match(sourceRegex).slice(1);
    return {arguments : parsed[0], body : parsed[1], returnValue: parsed[2]}
  }
  var JSsource = {};
  for (var fun in JSfuncs) {
    if (JSfuncs.hasOwnProperty(fun)) {
      // Elements of toCsource are arrays of three items:
      // the code, and the return value
      JSsource[fun] = parseJSFunc(JSfuncs[fun]);
    }
  }

  
  cwrap = function cwrap(ident, returnType, argTypes) {
    argTypes = argTypes || [];
    var cfunc = getCFunc(ident);
    // When the function takes numbers and returns a number, we can just return
    // the original function
    var numericArgs = argTypes.every(function(type){ return type === 'number'});
    var numericRet = (returnType !== 'string');
    if ( numericRet && numericArgs) {
      return cfunc;
    }
    // Creation of the arguments list (["$1","$2",...,"$nargs"])
    var argNames = argTypes.map(function(x,i){return '$'+i});
    var funcstr = "(function(" + argNames.join(',') + ") {";
    var nargs = argTypes.length;
    if (!numericArgs) {
      // Generate the code needed to convert the arguments from javascript
      // values to pointers
      funcstr += 'var stack = ' + JSsource['stackSave'].body + ';';
      for (var i = 0; i < nargs; i++) {
        var arg = argNames[i], type = argTypes[i];
        if (type === 'number') continue;
        var convertCode = JSsource[type + 'ToC']; // [code, return]
        funcstr += 'var ' + convertCode.arguments + ' = ' + arg + ';';
        funcstr += convertCode.body + ';';
        funcstr += arg + '=' + convertCode.returnValue + ';';
      }
    }

    // When the code is compressed, the name of cfunc is not literally 'cfunc' anymore
    var cfuncname = parseJSFunc(function(){return cfunc}).returnValue;
    // Call the function
    funcstr += 'var ret = ' + cfuncname + '(' + argNames.join(',') + ');';
    if (!numericRet) { // Return type can only by 'string' or 'number'
      // Convert the result to a string
      var strgfy = parseJSFunc(function(){return Pointer_stringify}).returnValue;
      funcstr += 'ret = ' + strgfy + '(ret);';
    }
    if (!numericArgs) {
      // If we had a stack, restore it
      funcstr += JSsource['stackRestore'].body.replace('()', '(stack)') + ';';
    }
    funcstr += 'return ret})';
    return eval(funcstr);
  };
})();
Module["cwrap"] = cwrap;
Module["ccall"] = ccall;


function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)]=value; break;
      case 'i8': HEAP8[((ptr)>>0)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}
Module['setValue'] = setValue;


function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for setValue: ' + type);
    }
  return null;
}
Module['getValue'] = getValue;

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_STATIC = 2; // Cannot be freed
var ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk
var ALLOC_NONE = 4; // Do not allocate
Module['ALLOC_NORMAL'] = ALLOC_NORMAL;
Module['ALLOC_STACK'] = ALLOC_STACK;
Module['ALLOC_STATIC'] = ALLOC_STATIC;
Module['ALLOC_DYNAMIC'] = ALLOC_DYNAMIC;
Module['ALLOC_NONE'] = ALLOC_NONE;

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var ptr = ret, stop;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(slab, ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    if (typeof curr === 'function') {
      curr = Runtime.getFunctionIndex(curr);
    }

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = Runtime.getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}
Module['allocate'] = allocate;

// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
function getMemory(size) {
  if (!staticSealed) return Runtime.staticAlloc(size);
  if ((typeof _sbrk !== 'undefined' && !_sbrk.called) || !runtimeInitialized) return Runtime.dynamicAlloc(size);
  return _malloc(size);
}
Module['getMemory'] = getMemory;

function Pointer_stringify(ptr, /* optional */ length) {
  if (length === 0 || !ptr) return '';
  // TODO: use TextDecoder
  // Find the length, and check for UTF while doing so
  var hasUtf = 0;
  var t;
  var i = 0;
  while (1) {
    t = HEAPU8[(((ptr)+(i))>>0)];
    hasUtf |= t;
    if (t == 0 && !length) break;
    i++;
    if (length && i == length) break;
  }
  if (!length) length = i;

  var ret = '';

  if (hasUtf < 128) {
    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack
    var curr;
    while (length > 0) {
      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
      ret = ret ? ret + curr : curr;
      ptr += MAX_CHUNK;
      length -= MAX_CHUNK;
    }
    return ret;
  }
  return Module['UTF8ToString'](ptr);
}
Module['Pointer_stringify'] = Pointer_stringify;

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAP8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}
Module['AsciiToString'] = AsciiToString;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}
Module['stringToAscii'] = stringToAscii;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

function UTF8ArrayToString(u8Array, idx) {
  var u0, u1, u2, u3, u4, u5;

  var str = '';
  while (1) {
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    u0 = u8Array[idx++];
    if (!u0) return str;
    if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
    u1 = u8Array[idx++] & 63;
    if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
    u2 = u8Array[idx++] & 63;
    if ((u0 & 0xF0) == 0xE0) {
      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
    } else {
      u3 = u8Array[idx++] & 63;
      if ((u0 & 0xF8) == 0xF0) {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;
      } else {
        u4 = u8Array[idx++] & 63;
        if ((u0 & 0xFC) == 0xF8) {
          u0 = ((u0 & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;
        } else {
          u5 = u8Array[idx++] & 63;
          u0 = ((u0 & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;
        }
      }
    }
    if (u0 < 0x10000) {
      str += String.fromCharCode(u0);
    } else {
      var ch = u0 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    }
  }
}
Module['UTF8ArrayToString'] = UTF8ArrayToString;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function UTF8ToString(ptr) {
  return UTF8ArrayToString(HEAPU8, ptr);
}
Module['UTF8ToString'] = UTF8ToString;

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null 
//                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      outU8Array[outIdx++] = 0xC0 | (u >> 6);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      outU8Array[outIdx++] = 0xE0 | (u >> 12);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x1FFFFF) {
      if (outIdx + 3 >= endIdx) break;
      outU8Array[outIdx++] = 0xF0 | (u >> 18);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x3FFFFFF) {
      if (outIdx + 4 >= endIdx) break;
      outU8Array[outIdx++] = 0xF8 | (u >> 24);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 5 >= endIdx) break;
      outU8Array[outIdx++] = 0xFC | (u >> 30);
      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  outU8Array[outIdx] = 0;
  return outIdx - startIdx;
}
Module['stringToUTF8Array'] = stringToUTF8Array;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
}
Module['stringToUTF8'] = stringToUTF8;

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      ++len;
    } else if (u <= 0x7FF) {
      len += 2;
    } else if (u <= 0xFFFF) {
      len += 3;
    } else if (u <= 0x1FFFFF) {
      len += 4;
    } else if (u <= 0x3FFFFFF) {
      len += 5;
    } else {
      len += 6;
    }
  }
  return len;
}
Module['lengthBytesUTF8'] = lengthBytesUTF8;

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function UTF16ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
    if (codeUnit == 0)
      return str;
    ++i;
    // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
    str += String.fromCharCode(codeUnit);
  }
}
Module['UTF16ToString'] = UTF16ToString;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null 
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)]=codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)]=0;
  return outPtr - startPtr;
}
Module['stringToUTF16'] = stringToUTF16;

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}
Module['lengthBytesUTF16'] = lengthBytesUTF16;

function UTF32ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0)
      return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}
Module['UTF32ToString'] = UTF32ToString;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null 
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)]=codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)]=0;
  return outPtr - startPtr;
}
Module['stringToUTF32'] = stringToUTF32;

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}
Module['lengthBytesUTF32'] = lengthBytesUTF32;

function demangle(func) {
  var hasLibcxxabi = !!Module['___cxa_demangle'];
  if (hasLibcxxabi) {
    try {
      var buf = _malloc(func.length);
      writeStringToMemory(func.substr(1), buf);
      var status = _malloc(4);
      var ret = Module['___cxa_demangle'](buf, 0, 0, status);
      if (getValue(status, 'i32') === 0 && ret) {
        return Pointer_stringify(ret);
      }
      // otherwise, libcxxabi failed, we can try ours which may return a partial result
    } catch(e) {
      // failure when using libcxxabi, we can try ours which may return a partial result
    } finally {
      if (buf) _free(buf);
      if (status) _free(status);
      if (ret) _free(ret);
    }
  }
  var i = 3;
  // params, etc.
  var basicTypes = {
    'v': 'void',
    'b': 'bool',
    'c': 'char',
    's': 'short',
    'i': 'int',
    'l': 'long',
    'f': 'float',
    'd': 'double',
    'w': 'wchar_t',
    'a': 'signed char',
    'h': 'unsigned char',
    't': 'unsigned short',
    'j': 'unsigned int',
    'm': 'unsigned long',
    'x': 'long long',
    'y': 'unsigned long long',
    'z': '...'
  };
  var subs = [];
  var first = true;
  function dump(x) {
    //return;
    if (x) Module.print(x);
    Module.print(func);
    var pre = '';
    for (var a = 0; a < i; a++) pre += ' ';
    Module.print (pre + '^');
  }
  function parseNested() {
    i++;
    if (func[i] === 'K') i++; // ignore const
    var parts = [];
    while (func[i] !== 'E') {
      if (func[i] === 'S') { // substitution
        i++;
        var next = func.indexOf('_', i);
        var num = func.substring(i, next) || 0;
        parts.push(subs[num] || '?');
        i = next+1;
        continue;
      }
      if (func[i] === 'C') { // constructor
        parts.push(parts[parts.length-1]);
        i += 2;
        continue;
      }
      var size = parseInt(func.substr(i));
      var pre = size.toString().length;
      if (!size || !pre) { i--; break; } // counter i++ below us
      var curr = func.substr(i + pre, size);
      parts.push(curr);
      subs.push(curr);
      i += pre + size;
    }
    i++; // skip E
    return parts;
  }
  function parse(rawList, limit, allowVoid) { // main parser
    limit = limit || Infinity;
    var ret = '', list = [];
    function flushList() {
      return '(' + list.join(', ') + ')';
    }
    var name;
    if (func[i] === 'N') {
      // namespaced N-E
      name = parseNested().join('::');
      limit--;
      if (limit === 0) return rawList ? [name] : name;
    } else {
      // not namespaced
      if (func[i] === 'K' || (first && func[i] === 'L')) i++; // ignore const and first 'L'
      var size = parseInt(func.substr(i));
      if (size) {
        var pre = size.toString().length;
        name = func.substr(i + pre, size);
        i += pre + size;
      }
    }
    first = false;
    if (func[i] === 'I') {
      i++;
      var iList = parse(true);
      var iRet = parse(true, 1, true);
      ret += iRet[0] + ' ' + name + '<' + iList.join(', ') + '>';
    } else {
      ret = name;
    }
    paramLoop: while (i < func.length && limit-- > 0) {
      //dump('paramLoop');
      var c = func[i++];
      if (c in basicTypes) {
        list.push(basicTypes[c]);
      } else {
        switch (c) {
          case 'P': list.push(parse(true, 1, true)[0] + '*'); break; // pointer
          case 'R': list.push(parse(true, 1, true)[0] + '&'); break; // reference
          case 'L': { // literal
            i++; // skip basic type
            var end = func.indexOf('E', i);
            var size = end - i;
            list.push(func.substr(i, size));
            i += size + 2; // size + 'EE'
            break;
          }
          case 'A': { // array
            var size = parseInt(func.substr(i));
            i += size.toString().length;
            if (func[i] !== '_') throw '?';
            i++; // skip _
            list.push(parse(true, 1, true)[0] + ' [' + size + ']');
            break;
          }
          case 'E': break paramLoop;
          default: ret += '?' + c; break paramLoop;
        }
      }
    }
    if (!allowVoid && list.length === 1 && list[0] === 'void') list = []; // avoid (void)
    if (rawList) {
      if (ret) {
        list.push(ret + '?');
      }
      return list;
    } else {
      return ret + flushList();
    }
  }
  var parsed = func;
  try {
    // Special-case the entry point, since its name differs from other name mangling.
    if (func == 'Object._main' || func == '_main') {
      return 'main()';
    }
    if (typeof func === 'number') func = Pointer_stringify(func);
    if (func[0] !== '_') return func;
    if (func[1] !== '_') return func; // C function
    if (func[2] !== 'Z') return func;
    switch (func[3]) {
      case 'n': return 'operator new()';
      case 'd': return 'operator delete()';
    }
    parsed = parse();
  } catch(e) {
    parsed += '?';
  }
  if (parsed.indexOf('?') >= 0 && !hasLibcxxabi) {
    Runtime.warnOnce('warning: a problem occurred in builtin C++ name demangling; build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');
  }
  return parsed;
}

function demangleAll(text) {
  return text.replace(/__Z[\w\d_]+/g, function(x) { var y = demangle(x); return x === y ? x : (x + ' [' + y + ']') });
}

function jsStackTrace() {
  var err = new Error();
  if (!err.stack) {
    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
    // so try that as a special-case.
    try {
      throw new Error(0);
    } catch(e) {
      err = e;
    }
    if (!err.stack) {
      return '(no stack trace available)';
    }
  }
  return err.stack.toString();
}

function stackTrace() {
  return demangleAll(jsStackTrace());
}
Module['stackTrace'] = stackTrace;

// Memory management

var PAGE_SIZE = 4096;

function alignMemoryPage(x) {
  if (x % 4096 > 0) {
    x += (4096 - (x % 4096));
  }
  return x;
}

var HEAP;
var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

var STATIC_BASE = 0, STATICTOP = 0, staticSealed = false; // static area
var STACK_BASE = 0, STACKTOP = 0, STACK_MAX = 0; // stack area
var DYNAMIC_BASE = 0, DYNAMICTOP = 0; // dynamic area handled by sbrk


function enlargeMemory() {
  abort('Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.');
}


var TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;
var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;

var totalMemory = 64*1024;
while (totalMemory < TOTAL_MEMORY || totalMemory < 2*TOTAL_STACK) {
  if (totalMemory < 16*1024*1024) {
    totalMemory *= 2;
  } else {
    totalMemory += 16*1024*1024
  }
}
if (totalMemory !== TOTAL_MEMORY) {
  Module.printErr('increasing TOTAL_MEMORY to ' + totalMemory + ' to be compliant with the asm.js spec (and given that TOTAL_STACK=' + TOTAL_STACK + ')');
  TOTAL_MEMORY = totalMemory;
}

// Initialize the runtime's memory
// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && !!(new Int32Array(1)['subarray']) && !!(new Int32Array(1)['set']),
       'JS engine does not provide full typed array support');

var buffer;
buffer = new ArrayBuffer(TOTAL_MEMORY);
HEAP8 = new Int8Array(buffer);
HEAP16 = new Int16Array(buffer);
HEAP32 = new Int32Array(buffer);
HEAPU8 = new Uint8Array(buffer);
HEAPU16 = new Uint16Array(buffer);
HEAPU32 = new Uint32Array(buffer);
HEAPF32 = new Float32Array(buffer);
HEAPF64 = new Float64Array(buffer);

// Endianness check (note: assumes compiler arch was little-endian)
HEAP32[0] = 255;
assert(HEAPU8[0] === 255 && HEAPU8[3] === 0, 'Typed arrays 2 must be run on a little-endian system');

Module['HEAP'] = HEAP;
Module['buffer'] = buffer;
Module['HEAP8'] = HEAP8;
Module['HEAP16'] = HEAP16;
Module['HEAP32'] = HEAP32;
Module['HEAPU8'] = HEAPU8;
Module['HEAPU16'] = HEAPU16;
Module['HEAPU32'] = HEAPU32;
Module['HEAPF32'] = HEAPF32;
Module['HEAPF64'] = HEAPF64;

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback();
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Runtime.dynCall('v', func);
      } else {
        Runtime.dynCall('vi', func, [callback.arg]);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the runtime has exited

var runtimeInitialized = false;
var runtimeExited = false;


function preRun() {
  // compatibility - merge in anything from Module['preRun'] at this time
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function ensureInitRuntime() {
  if (runtimeInitialized) return;
  runtimeInitialized = true;
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  callRuntimeCallbacks(__ATEXIT__);
  runtimeExited = true;
}

function postRun() {
  // compatibility - merge in anything from Module['postRun'] at this time
  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}
Module['addOnPreRun'] = Module.addOnPreRun = addOnPreRun;

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}
Module['addOnInit'] = Module.addOnInit = addOnInit;

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}
Module['addOnPreMain'] = Module.addOnPreMain = addOnPreMain;

function addOnExit(cb) {
  __ATEXIT__.unshift(cb);
}
Module['addOnExit'] = Module.addOnExit = addOnExit;

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}
Module['addOnPostRun'] = Module.addOnPostRun = addOnPostRun;

// Tools


function intArrayFromString(stringy, dontAddNull, length /* optional */) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}
Module['intArrayFromString'] = intArrayFromString;

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}
Module['intArrayToString'] = intArrayToString;

function writeStringToMemory(string, buffer, dontAddNull) {
  var array = intArrayFromString(string, dontAddNull);
  var i = 0;
  while (i < array.length) {
    var chr = array[i];
    HEAP8[(((buffer)+(i))>>0)]=chr;
    i = i + 1;
  }
}
Module['writeStringToMemory'] = writeStringToMemory;

function writeArrayToMemory(array, buffer) {
  for (var i = 0; i < array.length; i++) {
    HEAP8[((buffer++)>>0)]=array[i];
  }
}
Module['writeArrayToMemory'] = writeArrayToMemory;

function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;
}
Module['writeAsciiToMemory'] = writeAsciiToMemory;

function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}


// check for imul support, and also for correctness ( https://bugs.webkit.org/show_bug.cgi?id=126345 )
if (!Math['imul'] || Math['imul'](0xffffffff, 5) !== -5) Math['imul'] = function imul(a, b) {
  var ah  = a >>> 16;
  var al = a & 0xffff;
  var bh  = b >>> 16;
  var bl = b & 0xffff;
  return (al*bl + ((ah*bl + al*bh) << 16))|0;
};
Math.imul = Math['imul'];


if (!Math['clz32']) Math['clz32'] = function(x) {
  x = x >>> 0;
  for (var i = 0; i < 32; i++) {
    if (x & (1 << (31 - i))) return i;
  }
  return 32;
};
Math.clz32 = Math['clz32']

var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_min = Math.min;
var Math_clz32 = Math.clz32;

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// PRE_RUN_ADDITIONS (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
}
Module['addRunDependency'] = addRunDependency;
function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}
Module['removeRunDependency'] = removeRunDependency;

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data



var memoryInitializer = null;



// === Body ===

var ASM_CONSTS = [];




STATIC_BASE = 8;

STATICTOP = STATIC_BASE + 96992;
  /* global initializers */  __ATINIT__.push();
  

/* memory initializer */ allocate([69,114,114,111,114,58,32,99,97,110,39,116,32,97,108,108,111,99,97,116,101,32,86,98,114,70,114,97,109,101,115,32,98,117,102,102,101,114,10,0,0,0,0,0,193,192,0,0,129,193,0,0,64,1,0,0,1,195,0,0,192,3,0,0,128,2,0,0,65,194,0,0,1,198,0,0,192,6,0,0,128,7,0,0,65,199,0,0,0,5,0,0,193,197,0,0,129,196,0,0,64,4,0,0,1,204,0,0,192,12,0,0,128,13,0,0,65,205,0,0,0,15,0,0,193,207,0,0,129,206,0,0,64,14,0,0,0,10,0,0,193,202,0,0,129,203,0,0,64,11,0,0,1,201,0,0,192,9,0,0,128,8,0,0,65,200,0,0,1,216,0,0,192,24,0,0,128,25,0,0,65,217,0,0,0,27,0,0,193,219,0,0,129,218,0,0,64,26,0,0,0,30,0,0,193,222,0,0,129,223,0,0,64,31,0,0,1,221,0,0,192,29,0,0,128,28,0,0,65,220,0,0,0,20,0,0,193,212,0,0,129,213,0,0,64,21,0,0,1,215,0,0,192,23,0,0,128,22,0,0,65,214,0,0,1,210,0,0,192,18,0,0,128,19,0,0,65,211,0,0,0,17,0,0,193,209,0,0,129,208,0,0,64,16,0,0,1,240,0,0,192,48,0,0,128,49,0,0,65,241,0,0,0,51,0,0,193,243,0,0,129,242,0,0,64,50,0,0,0,54,0,0,193,246,0,0,129,247,0,0,64,55,0,0,1,245,0,0,192,53,0,0,128,52,0,0,65,244,0,0,0,60,0,0,193,252,0,0,129,253,0,0,64,61,0,0,1,255,0,0,192,63,0,0,128,62,0,0,65,254,0,0,1,250,0,0,192,58,0,0,128,59,0,0,65,251,0,0,0,57,0,0,193,249,0,0,129,248,0,0,64,56,0,0,0,40,0,0,193,232,0,0,129,233,0,0,64,41,0,0,1,235,0,0,192,43,0,0,128,42,0,0,65,234,0,0,1,238,0,0,192,46,0,0,128,47,0,0,65,239,0,0,0,45,0,0,193,237,0,0,129,236,0,0,64,44,0,0,1,228,0,0,192,36,0,0,128,37,0,0,65,229,0,0,0,39,0,0,193,231,0,0,129,230,0,0,64,38,0,0,0,34,0,0,193,226,0,0,129,227,0,0,64,35,0,0,1,225,0,0,192,33,0,0,128,32,0,0,65,224,0,0,1,160,0,0,192,96,0,0,128,97,0,0,65,161,0,0,0,99,0,0,193,163,0,0,129,162,0,0,64,98,0,0,0,102,0,0,193,166,0,0,129,167,0,0,64,103,0,0,1,165,0,0,192,101,0,0,128,100,0,0,65,164,0,0,0,108,0,0,193,172,0,0,129,173,0,0,64,109,0,0,1,175,0,0,192,111,0,0,128,110,0,0,65,174,0,0,1,170,0,0,192,106,0,0,128,107,0,0,65,171,0,0,0,105,0,0,193,169,0,0,129,168,0,0,64,104,0,0,0,120,0,0,193,184,0,0,129,185,0,0,64,121,0,0,1,187,0,0,192,123,0,0,128,122,0,0,65,186,0,0,1,190,0,0,192,126,0,0,128,127,0,0,65,191,0,0,0,125,0,0,193,189,0,0,129,188,0,0,64,124,0,0,1,180,0,0,192,116,0,0,128,117,0,0,65,181,0,0,0,119,0,0,193,183,0,0,129,182,0,0,64,118,0,0,0,114,0,0,193,178,0,0,129,179,0,0,64,115,0,0,1,177,0,0,192,113,0,0,128,112,0,0,65,176,0,0,0,80,0,0,193,144,0,0,129,145,0,0,64,81,0,0,1,147,0,0,192,83,0,0,128,82,0,0,65,146,0,0,1,150,0,0,192,86,0,0,128,87,0,0,65,151,0,0,0,85,0,0,193,149,0,0,129,148,0,0,64,84,0,0,1,156,0,0,192,92,0,0,128,93,0,0,65,157,0,0,0,95,0,0,193,159,0,0,129,158,0,0,64,94,0,0,0,90,0,0,193,154,0,0,129,155,0,0,64,91,0,0,1,153,0,0,192,89,0,0,128,88,0,0,65,152,0,0,1,136,0,0,192,72,0,0,128,73,0,0,65,137,0,0,0,75,0,0,193,139,0,0,129,138,0,0,64,74,0,0,0,78,0,0,193,142,0,0,129,143,0,0,64,79,0,0,1,141,0,0,192,77,0,0,128,76,0,0,65,140,0,0,0,68,0,0,193,132,0,0,129,133,0,0,64,69,0,0,1,135,0,0,192,71,0,0,128,70,0,0,65,134,0,0,1,130,0,0,192,66,0,0,128,67,0,0,65,131,0,0,0,65,0,0,193,129,0,0,129,128,0,0,64,64,0,0,115,116,114,97,110,103,101,32,101,114,114,111,114,32,102,108,117,115,104,105,110,103,32,98,117,102,102,101,114,32,46,46,46,32,10,0,0,0,0,0,69,114,114,111,114,58,32,77,65,88,95,72,69,65,68,69,82,95,66,85,70,32,116,111,111,32,115,109,97,108,108,32,105,110,32,98,105,116,115,116,114,101,97,109,46,99,32,10,0,0,0,0,0,0,0,0,73,110,116,101,114,110,97,108,32,98,117,102,102,101,114,32,105,110,99,111,110,115,105,115,116,101,110,99,121,46,32,102,108,117,115,104,98,105,116,115,32,60,62,32,82,101,115,118,83,105,122,101,0,0,0,0,98,105,116,32,114,101,115,101,114,118,111,105,114,32,101,114,114,111,114,58,32,10,108,51,95,115,105,100,101,45,62,109,97,105,110,95,100,97,116,97,95,98,101,103,105,110,58,32,37,105,32,10,82,101,115,118,111,105,114,32,115,105,122,101,58,32,32,32,32,32,32,32,32,32,32,32,32,32,37,105,32,10,114,101,115,118,32,100,114,97,105,110,32,40,112,111,115,116,41,32,32,32,32,32,32,32,32,32,37,105,32,10,114,101,115,118,32,100,114,97,105,110,32,40,112,114,101,41,32,32,32,32,32,32,32,32,32,32,37,105,32,10,104,101,97,100,101,114,32,97,110,100,32,115,105,100,101,105,110,102,111,58,32,32,32,32,32,32,37,105,32,10,100,97,116,97,32,98,105,116,115,58,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,37,105,32,10,116,111,116,97,108,32,98,105,116,115,58,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,37,105,32,40,114,101,109,97,105,110,100,101,114,58,32,37,105,41,32,10,98,105,116,115,112,101,114,102,114,97,109,101,58,32,32,32,32,32,32,32,32,32,32,32,32,32,37,105,32,10,0,0,84,104,105,115,32,105,115,32,97,32,102,97,116,97,108,32,101,114,114,111,114,46,32,32,73,116,32,104,97,115,32,115,101,118,101,114,97,108,32,112,111,115,115,105,98,108,101,32,99,97,117,115,101,115,58,0,57,48,37,37,32,32,76,65,77,69,32,99,111,109,112,105,108,101,100,32,119,105,116,104,32,98,117,103,103,121,32,118,101,114,115,105,111,110,32,111,102,32,103,99,99,32,117,115,105,110,103,32,97,100,118,97,110,99,101,100,32,111,112,116,105,109,105,122,97,116,105,111,110,115,0,0,0,0,0,0,32,57,37,37,32,32,89,111,117,114,32,115,121,115,116,101,109,32,105,115,32,111,118,101,114,99,108,111,99,107,101,100,0,0,0,0,0,0,0,0,32,49,37,37,32,32,98,117,103,32,105,110,32,76,65,77,69,32,101,110,99,111,100,105,110,103,32,108,105,98,114,97,114,121,0,0,0,0,0,0,0,128,64,192,32,160,96,224,16,144,80,208,48,176,112,240,8,136,72,200,40,168,104,232,24,152,88,216,56,184,120,248,4,132,68,196,36,164,100,228,20,148,84,212,52,180,116,244,12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254], "i8", ALLOC_NONE, Runtime.GLOBAL_BASE);
/* memory initializer */ allocate([94,131,108,63,21,239,195,62,109,196,126,63,54,189,200,61,67,236,127,63,176,10,201,60,196,254,127,63,136,15,201,59,88,88,88,0,0,0,0,0,37,108,117,0,0,0,0,0,105,109,97,103,101,47,112,110,103,0,0,0,0,0,0,0,105,109,97,103,101,47,103,105,102,0,0,0,0,0,0,0,105,109,97,103,101,47,106,112,101,103,0,0,0,0,0,0,37,100,0,0,0,0,0,0,128,187,0,0,0,0,0,0,0,0,208,64,0,0,0,0,0,0,208,64,148,92,0,0,68,172,0,0,0,0,0,0,0,0,208,64,0,0,0,0,0,0,208,64,20,85,0,0,0,125,0,0,0,0,208,64,0,0,0,65,102,102,166,64,0,0,208,64,184,61,0,0,192,93,0,0,0,0,0,65,0,0,8,65,102,102,166,64,0,0,192,64,74,46,0,0,34,86,0,0,0,0,8,65,246,40,16,65,102,102,166,64,0,0,208,64,140,42,0,0,128,62,0,0,246,40,16,65,102,102,22,65,205,204,156,64,0,0,208,64,223,30,0,0,224,46,0,0,102,102,22,65,154,153,25,65,0,0,144,64,0,0,192,64,40,23,0,0,17,43,0,0,154,153,25,65,102,102,30,65,51,51,163,64,0,0,208,64,70,21,0,0,64,31,0,0,102,102,30,65,0,0,32,65,205,204,156,64,0,0,208,64,112,15,0,0,8,0,0,0,208,7,0,0,16,0,0,0,116,14,0,0,24,0,0,0,60,15,0,0,32,0,0,0,124,21,0,0,40,0,0,0,88,27,0,0,48,0,0,0,76,29,0,0,56,0,0,0,16,39,0,0,64,0,0,0,248,42,0,0,80,0,0,0,188,52,0,0,96,0,0,0,252,58,0,0,112,0,0,0,240,60,0,0,128,0,0,0,104,66,0,0,160,0,0,0,92,68,0,0,192,0,0,0,168,72,0,0,224,0,0,0,200,75,0,0,0,1,0,0,244,76,0,0,64,1,0,0,20,80,0,0,44,76,0,0,56,74,0,0,168,72,0,0,80,70,0,0,92,68,0,0,128,62,0,0,240,60,0,0,52,58,0,0,212,48,0,0,16,39,0,0,110,15,0,0,0,0,0,0,192,93,0,0,44,76,0,0,68,72,0,0,80,70,0,0,92,68,0,0,104,66,0,0,116,64,0,0,240,60,0,0,96,59,0,0,62,28,0,0,110,15,0,0,0,0,0,0,44,76,0,0,56,74,0,0,68,72,0,0,80,70,0,0,92,68,0,0,116,64,0,0,140,60,0,0,164,56,0,0,212,48,0,0,28,37,0,0,110,15,0,0,0,0,0,0,102,102,182,64,0,0,208,64,154,153,233,64,51,51,3,65,0,0,32,65,102,102,62,65,0,0,80,65,0,0,96,65,0,0,112,65,0,0,132,65,87,97,114,110,105,110,103,58,32,104,105,103,104,112,97,115,115,32,102,105,108,116,101,114,32,100,105,115,97,98,108,101,100,46,32,32,104,105,103,104,112,97,115,115,32,102,114,101,113,117,101,110,99,121,32,116,111,111,32,115,109,97,108,108,10,0,0,0,0,0,0,0,69,114,114,111,114,58,32,99,97,110,39,116,32,97,108,108,111,99,97,116,101,32,105,110,95,98,117,102,102,101,114,32,98,117,102,102,101,114,10,0,0,0,0,0,1,0,0,0,16,0,0,0,17,0,0,0,8,0,0,0,9,0,0,0,24,0,0,0,25,0,0,0,4,0,0,0,5,0,0,0,20,0,0,0,21,0,0,0,12,0,0,0,13,0,0,0,28,0,0,0,29,0,0,0,2,0,0,0,3,0,0,0,18,0,0,0,19,0,0,0,10,0,0,0,11,0,0,0,26,0,0,0,27,0,0,0,6,0,0,0,7,0,0,0,22,0,0,0,23,0,0,0,14,0,0,0,15,0,0,0,30,0,0,0,31,0,0,0,0,27,134,42,204,204,52,43,33,78,132,43,252,247,157,43,88,156,166,43,252,247,157,43,33,78,132,43,204,204,52,43,0,27,134,42,83,248,191,44,254,169,171,44,146,50,149,44,159,129,122,44,239,29,73,44,62,186,23,44,116,173,207,43,133,159,107,43,183,89,146,42,83,248,191,172,254,169,171,172,146,50,149,172,159,129,122,172,239,29,73,172,62,186,23,172,116,173,207,171,133,159,107,171,183,89,146,170,0,27,134,170,204,204,52,171,33,78,132,171,252,247,157,171,88,156,166,171,252,247,157,171,33,78,132,171,204,204,52,171,0,27,134,170,0,27,134,42,204,204,52,43,33,78,132,43,252,247,157,43,88,156,166,43,252,247,157,43,33,78,132,43,204,204,52,43,0,27,134,42,83,248,191,44,254,169,171,44,146,50,149,44,159,129,122,44,239,29,73,44,62,186,23,44,116,173,207,43,133,159,107,43,183,89,146,42,37,39,192,172,51,37,173,172,234,209,152,172,227,84,131,172,249,175,89,172,11,14,43,172,102,34,244,171,201,49,137,171,74,123,157,170,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,72,144,128,170,174,79,227,170,5,174,113,170,234,207,6,62,205,19,212,62,139,111,68,63,255,175,139,63,23,208,166,63,117,235,200,63,190,226,245,63,122,130,26,64,105,251,74,64,185,87,144,64,107,16,243,64,233,58,183,65,92,28,124,63,187,141,36,63,68,29,175,62,178,143,112,63,212,208,49,190,125,27,68,191,215,179,93,63,0,0,0,63,254,181,3,191,218,134,241,190,2,115,160,190,116,71,58,190,29,176,193,189,135,203,39,189,29,161,104,188,70,123,114,187,168,132,91,63,216,185,97,63,221,26,115,63,129,186,123,63,65,218,126,63,253,200,127,63,101,249,127,63,141,255,127,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,72,144,128,42,174,79,227,42,5,174,113,42,37,39,192,44,51,37,173,44,234,209,152,44,227,84,131,44,249,175,89,44,11,14,43,44,102,34,244,43,201,49,137,43,74,123,157,42,83,248,191,172,254,169,171,172,146,50,149,172,159,129,122,172,239,29,73,172,62,186,23,172,116,173,207,171,133,159,107,171,183,89,146,170,0,27,134,170,204,204,52,171,33,78,132,171,252,247,157,171,88,156,166,171,252,247,157,171,33,78,132,171,204,204,52,171,0,27,134,170,121,207,23,190,138,59,1,66,164,51,148,67,155,200,92,68,202,167,45,70,175,40,132,68,192,222,152,67,129,155,246,65,199,156,118,64,77,183,109,66,194,101,49,68,74,15,165,69,82,45,182,197,71,104,76,196,73,213,153,194,66,4,147,192,94,6,104,63,54,189,72,62,3,97,30,190,44,76,9,66,68,231,150,67,96,102,76,68,47,215,52,70,17,168,147,68,117,204,160,67,46,219,249,65,68,124,109,64,146,154,86,66,183,10,43,68,136,68,163,69,35,243,198,197,129,62,99,196,80,169,179,194,43,42,173,192,1,24,82,63,194,197,199,62,223,144,36,190,144,150,16,66,32,15,152,67,140,47,55,68,113,86,59,70,101,128,162,68,120,164,167,67,193,231,251,65,149,237,87,64,209,237,60,66,46,47,35,68,80,99,160,69,178,232,215,197,240,127,122,196,100,62,207,194,121,91,195,192,207,220,61,63,49,160,20,63,61,91,42,190,177,1,23,66,106,129,151,67,98,254,28,68,14,27,65,70,229,136,176,68,246,95,173,67,75,201,252,65,52,59,74,64,173,80,34,66,178,10,26,68,170,126,156,69,83,240,232,197,121,249,136,196,253,124,236,194,231,48,218,192,193,13,43,63,21,239,67,63,139,188,47,190,75,118,28,66,177,43,149,67,81,195,251,67,92,30,70,70,161,146,189,68,23,254,177,67,116,41,251,65,165,166,58,64,77,48,7,66,62,185,15,68,225,169,151,69,144,236,249,197,102,184,148,196,253,164,5,195,130,12,247,192,196,112,25,63,234,90,113,63,120,177,52,190,11,224,32,66,197,255,144,67,75,169,179,67,9,89,74,70,63,131,201,68,227,108,181,67,12,94,248,65,73,159,52,64,49,233,215,65,148,121,4,68,250,250,145,69,153,95,5,198,224,82,160,196,230,149,21,195,193,75,10,193,185,213,8,63,218,57,142,63,244,54,185,190,93,45,36,66,238,197,138,67,123,163,67,67,193,197,77,70,150,52,212,68,118,180,183,67,208,116,244,65,169,3,34,64,173,143,160,65,68,192,240,67,195,135,139,69,122,165,13,198,28,180,171,196,130,42,38,195,136,83,25,193,112,40,242,62,153,103,162,63,55,74,189,190,167,146,37,66,148,165,130,67,182,247,78,65,135,96,80,70,71,144,221,68,247,225,184,67,182,2,238,65,153,191,25,64,113,224,84,65,226,71,215,67,116,104,132,69,186,183,21,198,32,182,182,196,153,32,55,195,248,124,43,193,205,19,212,62,243,4,181,63,187,232,192,190,91,122,38,66,227,13,113,67,88,242,59,195,65,40,82,70,237,132,229,68,213,190,184,67,201,3,232,65,16,147,4,64,105,242,216,64,110,227,188,67,47,102,121,69,214,134,29,198,81,62,193,196,85,96,72,195,235,212,61,193,80,50,183,62,3,228,197,63,71,16,196,190,73,155,36,66,18,122,88,67,23,20,203,195,140,28,83,70,216,249,235,68,185,166,183,67,247,22,225,65,11,250,244,63,71,16,196,62,69,237,161,67,91,2,105,69,239,4,37,198,124,38,203,196,16,160,89,195,54,63,80,193,66,80,155,62,49,219,212,63,46,15,21,191,242,108,33,66,98,51,60,67,83,17,32,196,220,60,83,70,70,243,240,68,238,104,181,67,38,192,215,65,112,137,223,63,88,12,180,192,157,166,134,67,47,214,87,69,149,32,44,198,6,85,212,196,16,196,106,195,193,157,98,193,212,63,128,62,152,197,225,63,57,182,22,191,234,239,28,66,206,194,27,67,244,79,94,196,226,141,82,70,182,97,244,68,249,56,178,67,221,40,207,65,124,229,200,63,57,233,50,193,16,207,86,67,160,18,70,69,73,205,50,198,21,165,220,196,104,176,123,195,1,246,119,193,175,175,75,62,94,131,236,63,230,143,74,191,36,147,21,66,35,102,239,66,16,227,143,196,201,17,81,70,166,76,246,68,130,2,174,67,22,218,197,65,28,72,177,63,12,95,131,193,224,12,33,67,81,229,51,69,247,251,56,198,140,255,227,196,139,36,134,195,184,137,134,193,100,229,23,62,11,250,244,63,223,202,75,191,201,237,12,66,223,9,160,66,174,0,178,196,45,207,78,70,187,185,246,68,213,254,168,67,51,80,186,65,197,91,178,63,32,204,168,193,139,247,216,66,54,123,33,69,232,158,62,198,230,72,234,196,148,31,142,195,218,232,144,193,220,181,201,61,190,20,251,63,15,177,127,191,152,64,2,66,94,213,19,66,106,66,213,196,38,205,75,70,66,172,245,68,70,55,163,67,112,102,177,65,251,108,153,63,81,248,202,193,231,35,102,66,180,6,15,69,179,170,67,198,226,90,239,196,151,161,149,195,66,6,155,193,60,57,73,61,109,196,254,63,54,211,37,70,68,177,165,69,175,113,104,68,69,51,54,68,128,12,144,67,180,213,129,66,2,0,241,65,34,63,131,64,49,19,72,70,167,49,243,68,86,182,156,67,170,105,166,65,251,100,249,68,112,3,16,65,17,158,233,193,0,0,0,0,0,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,102,102,166,64,0,0,250,66,102,102,134,192,154,153,201,192,154,153,153,64,0,0,128,63,0,0,0,0,0,0,0,0,2,0,0,0,21,0,0,0,236,81,120,63,0,0,160,64,0,0,200,66,1,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,154,153,169,64,0,0,250,66,102,102,102,192,51,51,179,192,0,0,144,64,0,0,192,63,0,0,0,0,0,0,0,0,2,0,0,0,21,0,0,0,205,204,172,63,0,0,160,64,0,0,200,66,2,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,51,51,179,64,0,0,250,66,205,204,12,192,0,0,96,192,51,51,51,64,0,0,0,64,0,0,0,0,0,0,0,0,2,0,0,0,21,0,0,0,82,184,190,63,0,0,160,64,0,0,200,66,3,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,154,153,185,64,0,0,2,67,102,102,230,191,51,51,51,192,102,102,38,64,0,0,64,64,0,0,128,192,0,0,0,0,2,0,0,0,20,0,0,0,133,235,209,63,0,0,160,64,0,0,200,66,4,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,0,0,192,64,0,0,7,67,51,51,51,191,205,204,140,191,205,204,140,63,0,0,96,64,0,0,0,193,0,0,0,0,2,0,0,0,0,0,0,0,184,30,229,63,0,0,160,64,0,0,200,66,5,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,205,204,204,64,0,0,12,67,0,0,0,63,205,204,204,62,0,0,240,192,0,0,128,64,0,0,64,193,23,183,81,57,0,0,0,0,0,0,0,0,154,153,249,63,0,0,160,64,0,0,200,66,6,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,51,51,211,64,0,0,17,67,31,133,43,63,102,102,38,63,51,51,107,193,0,0,208,64,0,0,152,193,23,183,209,57,0,0,0,0,0,0,0,0,51,51,19,64,0,0,160,64,0,0,200,66,7,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,51,51,211,64,0,0,17,67,205,204,76,63,0,0,64,63,154,153,157,193,0,0,0,65,0,0,176,193,82,73,29,58,0,0,0,0,0,0,0,0,205,204,44,64,0,0,160,64,0,0,200,66,8,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,51,51,211,64,0,0,17,67,154,153,153,63,51,51,147,63,0,0,220,193,0,0,32,65,0,0,184,193,52,128,55,58,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,64,0,0,200,66,9,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,51,51,211,64,0,0,17,67,205,204,204,63,205,204,204,63,0,0,16,194,0,0,48,65,0,0,200,193,23,183,81,58,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,64,0,0,200,66,10,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,51,51,211,64,0,0,17,67,0,0,0,64,0,0,0,64,0,0,16,194,0,0,64,65,0,0,200,193,23,183,81,58,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,64,0,0,200,66,0,0,0,0,0,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,102,102,134,64,0,0,200,65,154,153,217,192,154,153,217,192,51,51,227,64,0,0,128,63,0,0,0,0,0,0,0,0,2,0,0,0,31,0,0,0,0,0,128,63,0,0,160,64,0,0,200,66,1,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,102,102,134,64,0,0,200,65,154,153,153,192,154,153,153,192,205,204,172,64,51,51,179,63,0,0,128,191,0,0,0,0,2,0,0,0,27,0,0,0,178,157,143,63,0,0,160,64,0,0,196,66,2,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,102,102,134,64,0,0,200,65,102,102,38,192,102,102,38,192,205,204,108,64,0,0,0,64,0,0,64,192,0,0,0,0,2,0,0,0,23,0,0,0,47,221,164,63,0,0,160,64,0,0,194,66,3,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,102,102,134,64,0,0,200,65,205,204,204,191,205,204,204,191,0,0,0,64,0,0,0,64,0,0,160,192,0,0,0,0,2,0,0,0,18,0,0,0,223,79,189,63,0,0,160,64,0,0,192,66,4,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,102,102,134,64,0,0,200,65,0,0,0,128,0,0,0,128,0,0,0,0,0,0,0,64,0,0,0,193,0,0,0,0,2,0,0,0,12,0,0,0,16,88,217,63,0,0,160,64,0,0,190,66,5,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,102,102,134,64,0,0,200,65,102,102,166,63,102,102,166,63,0,0,192,192,0,0,96,64,0,0,48,193,0,0,0,0,2,0,0,0,8,0,0,0,154,153,249,63,0,0,160,64,102,102,188,66,6,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,0,0,144,64,0,0,200,66,205,204,12,64,51,51,19,64,0,0,64,193,0,0,192,64,0,0,96,193,0,0,0,0,2,0,0,0,4,0,0,0,199,75,15,64,0,0,64,64,205,204,187,66,7,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,154,153,153,64,0,0,72,67,205,204,44,64,205,204,44,64,0,0,144,193,0,0,16,65,0,0,136,193,0,0,0,0,2,0,0,0,0,0,0,0,225,122,36,64,0,0,128,63,51,51,187,66,8,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,154,153,169,64,0,0,150,67,51,51,51,64,51,51,51,64,0,0,168,193,0,0,32,65,0,0,184,193,23,183,81,57,0,0,0,0,0,0,0,0,47,221,60,64,0,0,0,0,154,153,186,66,9,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,51,51,211,64,0,0,150,67,51,51,51,64,51,51,51,64,0,0,184,193,0,0,48,65,0,0,200,193,82,73,29,58,0,0,0,0,0,0,0,0,254,212,88,64,0,0,0,0,154,153,186,66,10,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,0,0,200,65,0,0,150,67,51,51,51,64,51,51,51,64,0,0,200,193,0,0,64,65,0,0,216,193,10,215,35,59,0,0,0,0,0,0,0,0,0,0,96,64,0,0,0,0,154,153,186,66,0,0,0,0,8,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,51,51,211,64,0,0,17,67,51,51,115,63,0,0,0,0,0,0,240,193,0,0,48,65,82,73,157,58,1,0,0,0,16,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,51,51,211,64,0,0,17,67,51,51,115,63,0,0,0,0,0,0,200,193,0,0,48,65,111,18,131,58,1,0,0,0,24,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,51,51,211,64,0,0,17,67,51,51,115,63,0,0,0,0,0,0,160,193,0,0,48,65,111,18,131,58,1,0,0,0,32,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,51,51,211,64,0,0,17,67,51,51,115,63,0,0,0,0,0,0,112,193,0,0,48,65,111,18,131,58,1,0,0,0,40,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,51,51,211,64,0,0,17,67,51,51,115,63,0,0,0,0,0,0,32,193,0,0,48,65,250,237,107,58,1,0,0,0,48,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,51,51,211,64,0,0,17,67,51,51,115,63,0,0,0,0,0,0,32,193,0,0,48,65,250,237,107,58,1,0,0,0,56,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,51,51,211,64,0,0,17,67,51,51,115,63,0,0,0,0,0,0,192,192,0,0,48,65,23,183,81,58,1,0,0,0,64,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,51,51,211,64,0,0,17,67,51,51,115,63,0,0,0,0,0,0,0,192,0,0,48,65,23,183,81,58,1,0,0,0,80,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,51,51,211,64,0,0,17,67,51,51,115,63,0,0,0,0,0,0,0,0,0,0,0,65,52,128,55,58,1,0,0,0,96,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,0,0,32,64,51,51,211,64,0,0,17,67,51,51,115,63,0,0,0,0,0,0,128,63,0,0,176,64,82,73,29,58,1,0,0,0,112,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,0,0,16,64,51,51,211,64,0,0,17,67,51,51,115,63,0,0,0,0,0,0,0,64,0,0,144,64,111,18,3,58,1,0,0,0,128,0,0,0,9,0,0,0,9,0,0,0,0,0,0,0,154,153,249,63,205,204,204,64,0,0,12,67,51,51,115,63,0,0,0,0,0,0,64,64,0,0,128,64,23,183,81,57,1,0,0,0,160,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,184,30,229,63,0,0,192,64,0,0,7,67,51,51,115,63,0,0,0,192,0,0,160,64,0,0,96,64,0,0,0,0,1,0,0,0,192,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,82,184,190,63,51,51,179,64,0,0,250,66,236,81,120,63,0,0,128,192,0,0,224,64,0,0,64,64,0,0,0,0,0,0,0,0,224,0,0,0,9,0,0,0,9,0,0,0,1,0,0,0,0,0,160,63,102,102,166,64,0,0,250,66,72,225,122,63,0,0,192,192,0,0,16,65,0,0,0,64,0,0,0,0,0,0,0,0,0,1,0,0,9,0,0,0,9,0,0,0,1,0,0,0,236,81,120,63,102,102,166,64,0,0,250,66,0,0,128,63,0,0,0,193,0,0,32,65,0,0,128,63,0,0,0,0,0,0,0,0,64,1,0,0,9,0,0,0,9,0,0,0,1,0,0,0,102,102,102,63,102,102,166,64,0,0,250,66,0,0,128,63,0,0,32,193,0,0,64,65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,0,0,0,0,0,0,128,63,54,89,75,63,152,134,33,63,152,134,33,63,152,134,33,63,152,134,33,63,152,134,33,63,250,155,128,62,153,158,240,61,0,0,0,0,0,0,0,0,0,0,0,0,137,158,227,63,229,83,236,63,167,94,245,63,155,20,249,63,14,217,252,63,123,143,234,63,218,151,217,63,226,132,191,63,124,145,168,63,0,0,128,63,0,0,0,0,0,0,0,0,205,204,60,65,154,153,89,65,154,153,137,65,0,0,0,66,0,0,58,66,51,51,77,66,0,0,102,66,51,51,134,66,0,0,143,66,51,51,169,66,51,51,195,66,0,0,2,67,154,153,217,64,154,153,185,64,154,153,185,64,205,204,204,64,0,0,208,64,102,102,30,65,154,153,65,65,102,102,102,65,0,0,112,65,51,51,151,65,205,204,172,65,51,51,215,65,205,204,8,66,205,204,32,66,51,51,59,66,0,0,98,66,205,204,114,66,205,204,147,66,102,102,171,66,205,204,186,66,51,51,252,66,0,0,0,0,205,204,236,192,205,204,236,192,205,204,236,192,0,0,24,193,205,204,236,192,51,51,195,192,0,0,176,192,102,102,150,192,102,102,150,192,102,102,150,192,102,102,150,192,0,0,0,0,73,78,84,69,82,78,65,76,32,69,82,82,79,82,32,73,78,32,86,66,82,32,78,69,87,32,67,79,68,69,44,32,112,108,101,97,115,101,32,115,101,110,100,32,98,117,103,32,114,101,112,111,114,116,10,0,6,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,9,0,0,0,9,0,0,0,9,0,0,0,9,0,0,0,6,0,0,0,9,0,0,0,9,0,0,0,9,0,0,0,6,0,0,0,5,0,0,0,7,0,0,0,3,0,0,0,9,0,0,0,9,0,0,0,12,0,0,0,6,0,0,0,6,0,0,0,9,0,0,0,12,0,0,0,6,0,0,0,11,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,12,0,0,0,12,0,0,0,12,0,0,0,0,0,0,0,6,0,0,0,15,0,0,0,12,0,0,0,0,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,3,0,0,0,12,0,0,0,9,0,0,0,9,0,0,0,6,0,0,0,6,0,0,0,12,0,0,0,9,0,0,0,6,0,0,0,8,0,0,0,8,0,0,0,5,0,0,0,0,0,0,0,15,0,0,0,12,0,0,0,9,0,0,0,0,0,0,0,6,0,0,0,18,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,12,0,0,0,18,0,0,0,24,0,0,0,30,0,0,0,36,0,0,0,44,0,0,0,54,0,0,0,66,0,0,0,80,0,0,0,96,0,0,0,116,0,0,0,140,0,0,0,168,0,0,0,200,0,0,0,238,0,0,0,28,1,0,0,80,1,0,0,140,1,0,0,208,1,0,0,10,2,0,0,64,2,0,0,0,0,0,0,4,0,0,0,8,0,0,0,12,0,0,0,18,0,0,0,24,0,0,0,32,0,0,0,42,0,0,0,56,0,0,0,74,0,0,0,100,0,0,0,132,0,0,0,174,0,0,0,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,12,0,0,0,18,0,0,0,24,0,0,0,30,0,0,0,36,0,0,0,44,0,0,0,54,0,0,0,66,0,0,0,80,0,0,0,96,0,0,0,114,0,0,0,136,0,0,0,162,0,0,0,194,0,0,0,232,0,0,0,22,1,0,0,76,1,0,0,138,1,0,0,208,1,0,0,28,2,0,0,64,2,0,0,0,0,0,0,4,0,0,0,8,0,0,0,12,0,0,0,18,0,0,0,26,0,0,0,36,0,0,0,48,0,0,0,62,0,0,0,80,0,0,0,104,0,0,0,136,0,0,0,180,0,0,0,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,12,0,0,0,18,0,0,0,24,0,0,0,30,0,0,0,36,0,0,0,44,0,0,0,54,0,0,0,66,0,0,0,80,0,0,0,96,0,0,0,116,0,0,0,140,0,0,0,168,0,0,0,200,0,0,0,238,0,0,0,28,1,0,0,80,1,0,0,140,1,0,0,208,1,0,0,10,2,0,0,64,2,0,0,0,0,0,0,4,0,0,0,8,0,0,0,12,0,0,0,18,0,0,0,26,0,0,0,36,0,0,0,48,0,0,0,62,0,0,0,80,0,0,0,104,0,0,0,134,0,0,0,174,0,0,0,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,8,0,0,0,12,0,0,0,16,0,0,0,20,0,0,0,24,0,0,0,30,0,0,0,36,0,0,0,44,0,0,0,52,0,0,0,62,0,0,0,74,0,0,0,90,0,0,0,110,0,0,0,134,0,0,0,162,0,0,0,196,0,0,0,238,0,0,0,32,1,0,0,86,1,0,0,162,1,0,0,64,2,0,0,0,0,0,0,4,0,0,0,8,0,0,0,12,0,0,0,16,0,0,0,22,0,0,0,30,0,0,0,40,0,0,0,52,0,0,0,66,0,0,0,84,0,0,0,106,0,0,0,136,0,0,0,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,8,0,0,0,12,0,0,0,16,0,0,0,20,0,0,0,24,0,0,0,30,0,0,0,36,0,0,0,42,0,0,0,50,0,0,0,60,0,0,0,72,0,0,0,88,0,0,0,106,0,0,0,128,0,0,0,156,0,0,0,190,0,0,0,230,0,0,0,20,1,0,0,74,1,0,0,128,1,0,0,64,2,0,0,0,0,0,0,4,0,0,0,8,0,0,0,12,0,0,0,16,0,0,0,22,0,0,0,28,0,0,0,38,0,0,0,50,0,0,0,64,0,0,0,80,0,0,0,100,0,0,0,126,0,0,0,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,8,0,0,0,12,0,0,0,16,0,0,0,20,0,0,0,24,0,0,0,30,0,0,0,36,0,0,0,44,0,0,0,54,0,0,0,66,0,0,0,82,0,0,0,102,0,0,0,126,0,0,0,156,0,0,0,194,0,0,0,240,0,0,0,40,1,0,0,108,1,0,0,192,1,0,0,38,2,0,0,64,2,0,0,0,0,0,0,4,0,0,0,8,0,0,0,12,0,0,0,16,0,0,0,22,0,0,0,30,0,0,0,42,0,0,0,58,0,0,0,78,0,0,0,104,0,0,0,138,0,0,0,180,0,0,0,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,12,0,0,0,18,0,0,0,24,0,0,0,30,0,0,0,36,0,0,0,44,0,0,0,54,0,0,0,66,0,0,0,80,0,0,0,96,0,0,0,116,0,0,0,140,0,0,0,168,0,0,0,200,0,0,0,238,0,0,0,28,1,0,0,80,1,0,0,140,1,0,0,208,1,0,0,10,2,0,0,64,2,0,0,0,0,0,0,4,0,0,0,8,0,0,0,12,0,0,0,18,0,0,0,26,0,0,0,36,0,0,0,48,0,0,0,62,0,0,0,80,0,0,0,104,0,0,0,134,0,0,0,174,0,0,0,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,12,0,0,0,18,0,0,0,24,0,0,0,30,0,0,0,36,0,0,0,44,0,0,0,54,0,0,0,66,0,0,0,80,0,0,0,96,0,0,0,116,0,0,0,140,0,0,0,168,0,0,0,200,0,0,0,238,0,0,0,28,1,0,0,80,1,0,0,140,1,0,0,208,1,0,0,10,2,0,0,64,2,0,0,0,0,0,0,4,0,0,0,8,0,0,0,12,0,0,0,18,0,0,0,26,0,0,0,36,0,0,0,48,0,0,0,62,0,0,0,80,0,0,0,104,0,0,0,134,0,0,0,174,0,0,0,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,24,0,0,0,36,0,0,0,48,0,0,0,60,0,0,0,72,0,0,0,88,0,0,0,108,0,0,0,132,0,0,0,160,0,0,0,192,0,0,0,232,0,0,0,24,1,0,0,80,1,0,0,144,1,0,0,220,1,0,0,54,2,0,0,56,2,0,0,58,2,0,0,60,2,0,0,62,2,0,0,64,2,0,0,0,0,0,0,8,0,0,0,16,0,0,0,24,0,0,0,36,0,0,0,52,0,0,0,72,0,0,0,96,0,0,0,124,0,0,0,160,0,0,0,162,0,0,0,164,0,0,0,166,0,0,0,192], "i8", ALLOC_NONE, Runtime.GLOBAL_BASE+6448);
/* memory initializer */ allocate([1,4,3,5,0,0,0,0,1,5,5,7,5,8,7,9,5,7,7,9,7,9,9,10,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,192,72,1,0,56,65,1,0,3,0,0,0,0,0,0,0,200,72,1,0,224,72,1,0,3,0,0,0,0,0,0,0,240,72,1,0,8,73,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,24,73,1,0,56,73,1,0,4,0,0,0,0,0,0,0,72,73,1,0,104,73,1,0,6,0,0,0,0,0,0,0,120,73,1,0,192,73,1,0,6,0,0,0,0,0,0,0,232,73,1,0,48,74,1,0,6,0,0,0,0,0,0,0,88,74,1,0,160,74,1,0,8,0,0,0,0,0,0,0,200,74,1,0,72,75,1,0,8,0,0,0,0,0,0,0,136,75,1,0,8,76,1,0,8,0,0,0,0,0,0,0,72,76,1,0,200,76,1,0,16,0,0,0,0,0,0,0,8,77,1,0,8,79,1,0,0,0,0,0,0,0,0,0,0,0,0,0,8,80,1,0,16,0,0,0,0,0,0,0,8,81,1,0,8,83,1,0,1,0,0,0,1,0,0,0,8,84,1,0,8,86,1,0,2,0,0,0,3,0,0,0,8,84,1,0,8,86,1,0,3,0,0,0,7,0,0,0,8,84,1,0,8,86,1,0,4,0,0,0,15,0,0,0,8,84,1,0,8,86,1,0,6,0,0,0,63,0,0,0,8,84,1,0,8,86,1,0,8,0,0,0,255,0,0,0,8,84,1,0,8,86,1,0,10,0,0,0,255,3,0,0,8,84,1,0,8,86,1,0,13,0,0,0,255,31,0,0,8,84,1,0,8,86,1,0,4,0,0,0,15,0,0,0,8,87,1,0,8,89,1,0,5,0,0,0,31,0,0,0,8,87,1,0,8,89,1,0,6,0,0,0,63,0,0,0,8,87,1,0,8,89,1,0,7,0,0,0,127,0,0,0,8,87,1,0,8,89,1,0,8,0,0,0,255,0,0,0,8,87,1,0,8,89,1,0,9,0,0,0,255,1,0,0,8,87,1,0,8,89,1,0,11,0,0,0,255,7,0,0,8,87,1,0,8,89,1,0,13,0,0,0,255,31,0,0,8,87,1,0,8,89,1,0,0,0,0,0,0,0,0,0,8,90,1,0,64,65,1,0,0,0,0,0,0,0,0,0,40,90,1,0,80,65,1,0,4,0,1,0,5,0,5,0,7,0,7,0,8,0,9,0,9,0,10,0,10,0,10,0,10,0,11,0,11,0,11,0,11,0,12,0,12,0,12,0,12,0,12,0,12,0,13,0,12,0,13,0,12,0,13,0,13,0,14,0,10,0,10,0,5,0,4,0,6,0,6,0,7,0,8,0,8,0,9,0,9,0,10,0,10,0,11,0,10,0,11,0,11,0,11,0,11,0,12,0,11,0,12,0,12,0,12,0,12,0,13,0,12,0,14,0,12,0,13,0,12,0,14,0,10,0,10,0,7,0,7,0,7,0,8,0,8,0,9,0,9,0,10,0,9,0,11,0,10,0,11,0,10,0,12,0,11,0,12,0,11,0,13,0,11,0,12,0,11,0,13,0,12,0,13,0,12,0,13,0,12,0,14,0,13,0,14,0,9,0,11,0,8,0,9,0,8,0,9,0,9,0,10,0,9,0,11,0,10,0,11,0,10,0,12,0,10,0,12,0,11,0,12,0,11,0,13,0,11,0,13,0,11,0,14,0,12,0,14,0,12,0,14,0,12,0,15,0,12,0,15,0,9,0,12,0,9,0,10,0,9,0,10,0,9,0,11,0,10,0,11,0,10,0,12,0,10,0,12,0,10,0,13,0,11,0,13,0,11,0,13,0,11,0,14,0,12,0,14,0,12,0,14,0,12,0,15,0,12,0,15,0,13,0,15,0,9,0,11,0,10,0,10,0,9,0,10,0,10,0,11,0,10,0,11,0,10,0,12,0,10,0,13,0,11,0,13,0,11,0,14,0,11,0,13,0,11,0,14,0,12,0,14,0,12,0,15,0,12,0,15,0,12,0,15,0,12,0,16,0,9,0,12,0,10,0,11,0,10,0,11,0,10,0,11,0,10,0,12,0,10,0,13,0,11,0,13,0,11,0,13,0,11,0,13,0,11,0,14,0,12,0,14,0,12,0,14,0,12,0,14,0,12,0,15,0,12,0,15,0,13,0,16,0,9,0,12,0,11,0,11,0,10,0,11,0,10,0,12,0,10,0,12,0,11,0,13,0,11,0,13,0,11,0,13,0,11,0,14,0,12,0,14,0,12,0,15,0,12,0,15,0,12,0,15,0,12,0,15,0,13,0,17,0,13,0,17,0,10,0,12,0,11,0,11,0,11,0,12,0,11,0,12,0,11,0,13,0,11,0,13,0,11,0,13,0,11,0,14,0,11,0,14,0,11,0,15,0,12,0,15,0,12,0,15,0,12,0,15,0,12,0,16,0,13,0,16,0,13,0,16,0,10,0,12,0,11,0,12,0,11,0,12,0,11,0,12,0,11,0,13,0,11,0,13,0,11,0,14,0,11,0,14,0,12,0,15,0,12,0,15,0,12,0,15,0,12,0,15,0,12,0,16,0,13,0,15,0,13,0,16,0,13,0,15,0,10,0,13,0,12,0,12,0,11,0,13,0,11,0,12,0,11,0,13,0,11,0,14,0,12,0,14,0,12,0,14,0,12,0,14,0,12,0,15,0,12,0,16,0,12,0,16,0,13,0,16,0,13,0,17,0,13,0,17,0,13,0,16,0,10,0,12,0,12,0,13,0,12,0,13,0,11,0,13,0,11,0,13,0,11,0,14,0,12,0,14,0,12,0,15,0,12,0,16,0,12,0,16,0,12,0,16,0,12,0,16,0,13,0,16,0,13,0,16,0,13,0,15,0,13,0,16,0,10,0,13,0,12,0,13,0,12,0,14,0,12,0,14,0,12,0,14,0,12,0,14,0,12,0,15,0,12,0,15,0,12,0,15,0,12,0,15,0,12,0,17,0,13,0,16,0,13,0,16,0,13,0,16,0,13,0,16,0,13,0,18,0,10,0,13,0,12,0,15,0,12,0,14,0,12,0,14,0,12,0,14,0,12,0,15,0,12,0,15,0,12,0,16,0,12,0,16,0,13,0,16,0,13,0,18,0,13,0,17,0,13,0,17,0,13,0,17,0,13,0,19,0,13,0,17,0,10,0,13,0,13,0,14,0,12,0,15,0,12,0,13,0,12,0,14,0,12,0,16,0,12,0,16,0,12,0,15,0,13,0,16,0,13,0,16,0,13,0,17,0,13,0,18,0,13,0,17,0,13,0,19,0,13,0,17,0,13,0,16,0,10,0,13,0,9,0,10,0,9,0,10,0,9,0,10,0,9,0,11,0,9,0,11,0,9,0,12,0,9,0,12,0,9,0,12,0,9,0,13,0,9,0,13,0,9,0,13,0,10,0,13,0,10,0,13,0,10,0,13,0,10,0,13,0,6,0,10,0,2,0,1,0,3,0,4,0,7,0,7,0,4,0,4,0,4,0,5,0,7,0,7,0,6,0,6,0,7,0,7,0,8,0,8,0,0,0,0,0,3,0,1,0,4,0,4,0,6,0,7,0,8,0,8,0,4,0,4,0,4,0,5,0,6,0,8,0,7,0,9,0,5,0,7,0,6,0,8,0,7,0,9,0,8,0,10,0,7,0,8,0,7,0,8,0,8,0,9,0,9,0,10,0,0,0,0,0,8,0,0,0,16,0,0,0,24,0,0,0,32,0,0,0,40,0,0,0,48,0,0,0,56,0,0,0,64,0,0,0,80,0,0,0,96,0,0,0,112,0,0,0,128,0,0,0,144,0,0,0,160,0,0,0,255,255,255,255,0,0,0,0,32,0,0,0,40,0,0,0,48,0,0,0,56,0,0,0,64,0,0,0,80,0,0,0,96,0,0,0,112,0,0,0,128,0,0,0,160,0,0,0,192,0,0,0,224,0,0,0,0,1,0,0,64,1,0,0,255,255,255,255,0,0,0,0,8,0,0,0,16,0,0,0,24,0,0,0,32,0,0,0,40,0,0,0,48,0,0,0,56,0,0,0,64,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,6,0,0,0,11,0,0,0,16,0,0,0,21,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,2,0,1,0,3,0,1,0,1,0,3,0,2,0,0,0,0,0,0,0,0,0,1,4,7,4,5,7,6,7,8,0,0,0,0,0,0,0,3,0,2,0,1,0,1,0,1,0,1,0,3,0,2,0,0,0,0,0,0,0,0,0,2,3,7,4,4,7,6,7,8,0,0,0,0,0,0,0,1,0,2,0,6,0,5,0,3,0,1,0,4,0,4,0,7,0,5,0,7,0,1,0,6,0,1,0,1,0,0,0,1,4,7,8,4,5,8,9,7,8,9,10,8,8,9,10,7,0,3,0,5,0,1,0,6,0,2,0,3,0,2,0,5,0,4,0,4,0,1,0,3,0,3,0,2,0,0,0,3,4,6,8,4,4,6,7,5,6,7,8,7,7,8,9,1,0,2,0,10,0,19,0,16,0,10,0,3,0,3,0,7,0,10,0,5,0,3,0,11,0,4,0,13,0,17,0,8,0,4,0,12,0,11,0,18,0,15,0,11,0,2,0,7,0,6,0,9,0,14,0,3,0,1,0,6,0,4,0,5,0,3,0,2,0,0,0,1,4,7,9,9,10,4,6,8,9,9,10,7,7,9,10,10,11,8,9,10,11,11,11,8,9,10,11,11,12,9,10,11,12,12,12,0,0,0,0,3,0,4,0,6,0,18,0,12,0,5,0,5,0,1,0,2,0,16,0,9,0,3,0,7,0,3,0,5,0,14,0,7,0,3,0,19,0,17,0,15,0,13,0,10,0,4,0,13,0,5,0,8,0,11,0,5,0,1,0,12,0,4,0,4,0,1,0,1,0,0,0,2,4,7,9,9,10,4,4,6,10,10,10,7,6,8,10,10,11,9,10,10,11,11,12,9,9,10,11,12,12,10,10,11,11,13,13,0,0,0,0,7,0,5,0,9,0,14,0,15,0,7,0,6,0,4,0,5,0,5,0,6,0,7,0,7,0,6,0,8,0,8,0,8,0,5,0,15,0,6,0,9,0,10,0,5,0,1,0,11,0,7,0,9,0,6,0,4,0,1,0,14,0,4,0,6,0,2,0,6,0,0,0,3,4,6,7,9,10,4,5,6,7,8,10,5,6,7,8,9,10,7,7,8,9,9,10,8,8,9,9,10,11,9,9,10,10,11,11,0,0,0,0,1,0,2,0,10,0,23,0,35,0,30,0,12,0,17,0,3,0,3,0,8,0,12,0,18,0,21,0,12,0,7,0,11,0,9,0,15,0,21,0,32,0,40,0,19,0,6,0,14,0,13,0,22,0,34,0,46,0,23,0,18,0,7,0,20,0,19,0,33,0,47,0,27,0,22,0,9,0,3,0,31,0,22,0,41,0,26,0,21,0,20,0,5,0,3,0,14,0,13,0,10,0,11,0,16,0,6,0,5,0,1,0,9,0,8,0,7,0,8,0,4,0,4,0,2,0,0,0,1,4,7,9,10,10,10,11,4,6,8,9,10,11,10,10,7,8,9,10,11,12,11,11,8,9,10,11,12,12,11,12,9,10,11,12,12,12,12,12,10,11,12,12,13,13,12,13,9,10,11,12,12,12,13,13,10,10,11,12,12,13,13,13,3,0,4,0,10,0,24,0,34,0,33,0,21,0,15,0,5,0,3,0,4,0,10,0,32,0,17,0,11,0,10,0,11,0,7,0,13,0,18,0,30,0,31,0,20,0,5,0,25,0,11,0,19,0,59,0,27,0,18,0,12,0,5,0,35,0,33,0,31,0,58,0,30,0,16,0,7,0,5,0,28,0,26,0,32,0,19,0,17,0,15,0,8,0,14,0,14,0,12,0,9,0,13,0,14,0,9,0,4,0,1,0,11,0,4,0,6,0,6,0,6,0,3,0,2,0,0,0,2,4,6,8,9,10,9,10,4,5,6,8,10,10,9,10,6,7,8,9,10,11,10,10,8,8,9,11,10,12,10,11,9,10,10,11,11,12,11,12,9,10,11,12,12,13,12,13,9,9,9,10,11,12,12,12,9,9,10,11,12,12,12,12,9,0,6,0,16,0,33,0,41,0,39,0,38,0,26,0,7,0,5,0,6,0,9,0,23,0,16,0,26,0,11,0,17,0,7,0,11,0,14,0,21,0,30,0,10,0,7,0,17,0,10,0,15,0,12,0,18,0,28,0,14,0,5,0,32,0,13,0,22,0,19,0,18,0,16,0,9,0,5,0,40,0,17,0,31,0,29,0,17,0,13,0,4,0,2,0,27,0,12,0,11,0,15,0,10,0,7,0,4,0,1,0,27,0,12,0,8,0,12,0,6,0,3,0,1,0,0,0,4,4,6,8,9,10,10,10,4,5,6,7,9,9,10,10,6,6,7,8,9,10,9,10,7,7,8,8,9,10,10,10,8,8,9,9,10,10,10,11,9,9,10,10,10,11,10,11,9,9,9,10,10,11,11,12,10,10,10,11,11,11,11,12,1,0,5,0,14,0,21,0,34,0,51,0,46,0,71,0,42,0,52,0,68,0,52,0,67,0,44,0,43,0,19,0,3,0,4,0,12,0,19,0,31,0,26,0,44,0,33,0,31,0,24,0,32,0,24,0,31,0,35,0,22,0,14,0,15,0,13,0,23,0,36,0,59,0,49,0,77,0,65,0,29,0,40,0,30,0,40,0,27,0,33,0,42,0,16,0,22,0,20,0,37,0,61,0,56,0,79,0,73,0,64,0,43,0,76,0,56,0,37,0,26,0,31,0,25,0,14,0,35,0,16,0,60,0,57,0,97,0,75,0,114,0,91,0,54,0,73,0,55,0,41,0,48,0,53,0,23,0,24,0,58,0,27,0,50,0,96,0,76,0,70,0,93,0,84,0,77,0,58,0,79,0,29,0,74,0,49,0,41,0,17,0,47,0,45,0,78,0,74,0,115,0,94,0,90,0,79,0,69,0,83,0,71,0,50,0,59,0,38,0,36,0,15,0,72,0,34,0,56,0,95,0,92,0,85,0,91,0,90,0,86,0,73,0,77,0,65,0,51,0,44,0,43,0,42,0,43,0,20,0,30,0,44,0,55,0,78,0,72,0,87,0,78,0,61,0,46,0,54,0,37,0,30,0,20,0,16,0,53,0,25,0,41,0,37,0,44,0,59,0,54,0,81,0,66,0,76,0,57,0,54,0,37,0,18,0,39,0,11,0,35,0,33,0,31,0,57,0,42,0,82,0,72,0,80,0,47,0,58,0,55,0,21,0,22,0,26,0,38,0,22,0,53,0,25,0,23,0,38,0,70,0,60,0,51,0,36,0,55,0,26,0,34,0,23,0,27,0,14,0,9,0,7,0,34,0,32,0,28,0,39,0,49,0,75,0,30,0,52,0,48,0,40,0,52,0,28,0,18,0,17,0,9,0,5,0,45,0,21,0,34,0,64,0,56,0,50,0,49,0,45,0,31,0,19,0,12,0,15,0,10,0,7,0,6,0,3,0,48,0,23,0,20,0,39,0,36,0,35,0,53,0,21,0,16,0,23,0,13,0,10,0,6,0,1,0,4,0,2,0,16,0,15,0,17,0,27,0,25,0,20,0,29,0,11,0,17,0,12,0,16,0,8,0,1,0,1,0,0,0,1,0,1,5,7,8,9,10,10,11,10,11,12,12,13,13,14,14,4,6,8,9,10,10,11,11,11,11,12,12,13,14,14,14,7,8,9,10,11,11,12,12,11,12,12,13,13,14,15,15,8,9,10,11,11,12,12,12,12,13,13,13,13,14,15,15,9,9,11,11,12,12,13,13,12,13,13,14,14,15,15,16,10,10,11,12,12,12,13,13,13,13,14,13,15,15,16,16,10,11,12,12,13,13,13,13,13,14,14,14,15,15,16,16,11,11,12,13,13,13,14,14,14,14,15,15,15,16,18,18,10,10,11,12,12,13,13,14,14,14,14,15,15,16,17,17,11,11,12,12,13,13,13,15,14,15,15,16,16,16,18,17,11,12,12,13,13,14,14,15,14,15,16,15,16,17,18,19,12,12,12,13,14,14,14,14,15,15,15,16,17,17,17,18,12,13,13,14,14,15,14,15,16,16,17,17,17,18,18,18,13,13,14,15,15,15,16,16,16,16,16,17,18,17,18,18,14,14,14,15,15,15,17,16,16,19,17,17,17,19,18,18,13,14,15,16,16,16,17,16,17,17,18,18,21,20,21,18,1,5,7,9,10,10,11,11,12,12,12,13,13,13,14,11,4,6,8,9,10,11,11,11,12,12,12,13,14,13,14,11,7,8,9,10,11,11,12,12,13,12,13,13,13,14,14,12,9,9,10,11,11,12,12,12,13,13,14,14,14,15,15,13,10,10,11,11,12,12,13,13,13,14,14,14,15,15,15,12,10,10,11,11,12,13,13,14,13,14,14,15,15,15,16,13,11,11,11,12,13,13,13,13,14,14,14,14,15,15,16,13,11,11,12,12,13,13,13,14,14,15,15,15,15,17,17,13,11,12,12,13,13,13,14,14,15,15,15,15,16,16,16,13,12,12,12,13,13,14,14,15,15,15,15,16,15,16,15,14,12,13,12,13,14,14,14,14,15,16,16,16,17,17,16,13,13,13,13,13,14,14,15,16,16,16,16,16,16,15,16,14,13,14,14,14,14,15,15,15,15,17,16,16,16,16,18,14,15,14,14,14,15,15,16,16,16,18,17,17,17,19,17,14,14,15,13,14,16,16,15,16,16,17,18,17,19,17,16,14,11,11,11,12,12,13,13,13,14,14,14,14,14,14,14,12,7,0,12,0,18,0,53,0,47,0,76,0,124,0,108,0,89,0,123,0,108,0,119,0,107,0,81,0,122,0,63,0,13,0,5,0,16,0,27,0,46,0,36,0,61,0,51,0,42,0,70,0,52,0,83,0,65,0,41,0,59,0,36,0,19,0,17,0,15,0,24,0,41,0,34,0,59,0,48,0,40,0,64,0,50,0,78,0,62,0,80,0,56,0,33,0,29,0,28,0,25,0,43,0,39,0,63,0,55,0,93,0,76,0,59,0,93,0,72,0,54,0,75,0,50,0,29,0,52,0,22,0,42,0,40,0,67,0,57,0,95,0,79,0,72,0,57,0,89,0,69,0,49,0,66,0,46,0,27,0,77,0,37,0,35,0,66,0,58,0,52,0,91,0,74,0,62,0,48,0,79,0,63,0,90,0,62,0,40,0,38,0,125,0,32,0,60,0,56,0,50,0,92,0,78,0,65,0,55,0,87,0,71,0,51,0,73,0,51,0,70,0,30,0,109,0,53,0,49,0,94,0,88,0,75,0,66,0,122,0,91,0,73,0,56,0,42,0,64,0,44,0,21,0,25,0,90,0,43,0,41,0,77,0,73,0,63,0,56,0,92,0,77,0,66,0,47,0,67,0,48,0,53,0,36,0,20,0,71,0,34,0,67,0,60,0,58,0,49,0,88,0,76,0,67,0,106,0,71,0,54,0,38,0,39,0,23,0,15,0,109,0,53,0,51,0,47,0,90,0,82,0,58,0,57,0,48,0,72,0,57,0,41,0,23,0,27,0,62,0,9,0,86,0,42,0,40,0,37,0,70,0,64,0,52,0,43,0,70,0,55,0,42,0,25,0,29,0,18,0,11,0,11,0,118,0,68,0,30,0,55,0,50,0,46,0,74,0,65,0,49,0,39,0,24,0,16,0,22,0,13,0,14,0,7,0,91,0,44,0,39,0,38,0,34,0,63,0,52,0,45,0,31,0,52,0,28,0,19,0,14,0,8,0,9,0,3,0,123,0,60,0,58,0,53,0,47,0,43,0,32,0,22,0,37,0,24,0,17,0,12,0,15,0,10,0,2,0,1,0,71,0,37,0,34,0,30,0,28,0,20,0,17,0,26,0,21,0,16,0,10,0,6,0,8,0,6,0,2,0,0,0,3,5,6,8,8,9,10,10,10,11,11,12,12,12,13,14,5,5,7,8,9,9,10,10,10,11,11,12,12,12,13,13,6,7,7,8,9,9,10,10,10,11,11,12,12,13,13,13,7,8,8,9,9,10,10,11,11,11,12,12,12,13,13,13,8,8,9,9,10,10,11,11,11,11,12,12,12,13,13,13,9,9,9,10,10,10,11,11,11,11,12,12,13,13,13,14,10,9,10,10,10,11,11,11,11,12,12,12,13,13,14,14,10,10,10,11,11,11,11,12,12,12,12,12,13,13,13,14,10,10,10,11,11,11,11,12,12,12,12,13,13,14,14,14,10,10,11,11,11,11,12,12,12,13,13,13,13,14,14,14,11,11,11,11,12,12,12,12,12,13,13,13,13,14,15,14,11,11,11,11,12,12,12,12,13,13,13,13,14,14,14,15,12,12,11,12,12,12,13,13,13,13,13,13,14,14,15,15,12,12,12,12,12,13,13,13,13,14,14,14,14,14,15,15,13,13,13,13,13,13,13,13,14,14,14,14,15,15,14,15,13,13,13,13,13,13,13,14,14,14,14,14,15,15,15,15,1,0,5,0,14,0,44,0,74,0,63,0,110,0,93,0,172,0,149,0,138,0,242,0,225,0,195,0,120,1,17,0,3,0,4,0,12,0,20,0,35,0,62,0,53,0,47,0,83,0,75,0,68,0,119,0,201,0,107,0,207,0,9,0,15,0,13,0,23,0,38,0,67,0,58,0,103,0,90,0,161,0,72,0,127,0,117,0,110,0,209,0,206,0,16,0,45,0,21,0,39,0,69,0,64,0,114,0,99,0,87,0,158,0,140,0,252,0,212,0,199,0,131,1,109,1,26,0,75,0,36,0,68,0,65,0,115,0,101,0,179,0,164,0,155,0,8,1,246,0,226,0,139,1,126,1,106,1,9,0,66,0,30,0,59,0,56,0,102,0,185,0,173,0,9,1,142,0,253,0,232,0,144,1,132,1,122,1,189,1,16,0,111,0,54,0,52,0,100,0,184,0,178,0,160,0,133,0,1,1,244,0,228,0,217,0,129,1,110,1,203,2,10,0,98,0,48,0,91,0,88,0,165,0,157,0,148,0,5,1,248,0,151,1,141,1,116,1,124,1,121,3,116,3,8,0,85,0,84,0,81,0,159,0,156,0,143,0,4,1,249,0,171,1,145,1,136,1,127,1,215,2,201,2,196,2,7,0,154,0,76,0,73,0,141,0,131,0,0,1,245,0,170,1,150,1,138,1,128,1,223,2,103,1,198,2,96,1,11,0,139,0,129,0,67,0,125,0,247,0,233,0,229,0,219,0,137,1,231,2,225,2,208,2,117,3,114,3,183,1,4,0,243,0,120,0,118,0,115,0,227,0,223,0,140,1,234,2,230,2,224,2,209,2,200,2,194,2,223,0,180,1,6,0,202,0,224,0,222,0,218,0,216,0,133,1,130,1,125,1,108,1,120,3,187,1,195,2,184,1,181,1,192,6,4,0,235,2,211,0,210,0,208,0,114,1,123,1,222,2,211,2,202,2,199,6,115,3,109,3,108,3,131,13,97,3,2,0,121,1,113,1,102,0,187,0,214,2,210,2,102,1,199,2,197,2,98,3,198,6,103,3,130,13,102,3,178,1,0,0,12,0,10,0,7,0,11,0,10,0,17,0,11,0,9,0,13,0,12,0,10,0,7,0,5,0,3,0,1,0,3,0,1,5,7,9,10,10,11,11,12,12,12,13,13,13,14,10,4,6,8,9,10,11,11,11,12,12,12,13,14,13,14,10,7,8,9,10,11,11,12,12,13,12,13,13,13,14,14,11,9,9,10,11,11,12,12,12,13,13,14,14,14,15,15,12,10,10,11,11,12,12,13,13,13,14,14,14,15,15,15,11,10,10,11,11,12,13,13,14,13,14,14,15,15,15,16,12,11,11,11,12,13,13,13,13,14,14,14,14,15,15,16,12,11,11,12,12,13,13,13,14,14,15,15,15,15,17,17,12,11,12,12,13,13,13,14,14,15,15,15,15,16,16,16,12,12,12,12,13,13,14,14,15,15,15,15,16,15,16,15,13,12,13,12,13,14,14,14,14,15,16,16,16,17,17,16,12,13,13,13,13,14,14,15,16,16,16,16,16,16,15,16,13,13,14,14,14,14,15,15,15,15,17,16,16,16,16,18,13,15,14,14,14,15,15,16,16,16,18,17,17,17,19,17,13,14,15,13,14,16,16,15,16,16,17,18,17,19,17,16,13,10,10,10,11,11,12,12,12,13,13,13,13,13,13,13,10,15,0,13,0,46,0,80,0,146,0,6,1,248,0,178,1,170,1,157,2,141,2,137,2,109,2,5,2,8,4,88,0,14,0,12,0,21,0,38,0,71,0,130,0,122,0,216,0,209,0,198,0,71,1,89,1,63,1,41,1,23,1,42,0,47,0,22,0,41,0,74,0,68,0,128,0,120,0,221,0,207,0,194,0,182,0,84,1,59,1,39,1,29,2,18,0,81,0,39,0,75,0,70,0,134,0,125,0,116,0,220,0,204,0,190,0,178,0,69,1,55,1,37,1,15,1,16,0,147,0,72,0,69,0,135,0,127,0,118,0,112,0,210,0,200,0,188,0,96,1,67,1,50,1,29,1,28,2,14,0,7,1,66,0,129,0,126,0,119,0,114,0,214,0,202,0,192,0,180,0,85,1,61,1,45,1,25,1,6,1,12,0,249,0,123,0,121,0,117,0,113,0,215,0,206,0,195,0,185,0,91,1,74,1,52,1,35,1,16,1,8,2,10,0,179,1,115,0,111,0,109,0,211,0,203,0,196,0,187,0,97,1,76,1,57,1,42,1,27,1,19,2,125,1,17,0,171,1,212,0,208,0,205,0,201,0,193,0,186,0,177,0,169,0,64,1,47,1,30,1,12,1,2,2,121,1,16,0,79,1,199,0,197,0,191,0,189,0,181,0,174,0,77,1,65,1,49,1,33,1,19,1,9,2,123,1,115,1,11,0,156,2,184,0,183,0,179,0,175,0,88,1,75,1,58,1,48,1,34,1,21,1,18,2,127,1,117,1,110,1,10,0,140,2,90,1,171,0,168,0,164,0,62,1,53,1,43,1,31,1,20,1,7,1,1,2,119,1,112,1,106,1,6,0,136,2,66,1,60,1,56,1,51,1,46,1,36,1,28,1,13,1,5,1,0,2,120,1,114,1,108,1,103,1,4,0,108,2,44,1,40,1,38,1,32,1,26,1,17,1,10,1,3,2,124,1,118,1,113,1,109,1,105,1,101,1,2,0,9,4,24,1,22,1,18,1,11,1,8,1,3,1,126,1,122,1,116,1,111,1,107,1,104,1,102,1,100,1,0,0,43,0,20,0,19,0,17,0,15,0,13,0,11,0,9,0,7,0,6,0,4,0,7,0,5,0,3,0,1,0,3,0,4,5,7,8,9,10,10,11,11,12,12,12,12,12,13,10,5,6,7,8,9,10,10,11,11,11,12,12,12,12,12,10,7,7,8,9,9,10,10,11,11,11,11,12,12,12,13,9,8,8,9,9,10,10,10,11,11,11,11,12,12,12,12,9,9,9,9,10,10,10,10,11,11,11,12,12,12,12,13,9,10,9,10,10,10,10,11,11,11,11,12,12,12,12,12,9,10,10,10,10,10,11,11,11,11,12,12,12,12,12,13,9,11,10,10,10,11,11,11,11,12,12,12,12,12,13,13,10,11,11,11,11,11,11,11,11,11,12,12,12,12,13,13,10,11,11,11,11,11,11,11,12,12,12,12,12,13,13,13,10,12,11,11,11,11,12,12,12,12,12,12,13,13,13,13,10,12,12,11,11,11,12,12,12,12,12,12,13,13,13,13,10,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,10,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,10,13,12,12,12,12,12,12,13,13,13,13,13,13,13,13,10,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,6,1,0,10,0,8,0,20,0,12,0,20,0,16,0,32,0,14,0,12,0,24,0,0,0,28,0,16,0,24,0,16,0,15,0,28,0,26,0,48,0,22,0,40,0,36,0,64,0,14,0,24,0,20,0,32,0,12,0,16,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,4,0,0,0,4,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,2,0,0,0,3,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,8,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,8,0,0,0,8,0,0,0,8,0,0,0,16,0,0,0,16,0,0,0,1,0,0,0,2,0,0,0,4,0,0,0,8,0,0,0,1,0,0,0,2,0,0,0,4,0,0,0,8,0,0,0,2,0,0,0,4,0,0,0,8,0,0,0,2,0,0,0,4,0,0,0,8,0,0,0,4,0,0,0,8,0,0,0,0,0,0,0,18,0,0,0,36,0,0,0,54,0,0,0,51,0,0,0,35,0,0,0,53,0,0,0,71,0,0,0,52,0,0,0,70,0,0,0,88,0,0,0,69,0,0,0,87,0,0,0,105,0,0,0,104,0,0,0,122,0,0,0,0,0,0,0,18,0,0,0,36,0,0,0,54,0,0,0,54,0,0,0,36,0,0,0,54,0,0,0,72,0,0,0,54,0,0,0,72,0,0,0,90,0,0,0,72,0,0,0,90,0,0,0,108,0,0,0,108,0,0,0,126,0,0,0,0,0,0,0,10,0,0,0,20,0,0,0,30,0,0,0,33,0,0,0,21,0,0,0,31,0,0,0,41,0,0,0,32,0,0,0,42,0,0,0,52,0,0,0,43,0,0,0,53,0,0,0,63,0,0,0,64,0,0,0,74,0,0,0,15,0,0,0,15,0,0,0,7,0,0,0,7,0,0,0,15,0,0,0,15,0,0,0,7,0,0,0,0,0,0,0,7,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,31,0,0,0,31,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,3,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,3,0,0,0,2,0,0,0,3,0,0,0,3,0,0,0,4,0,0,0,3,0,0,0,4,0,0,0,3,0,0,0,4,0,0,0,4,0,0,0,5,0,0,0,4,0,0,0,5,0,0,0,4,0,0,0,6,0,0,0,5,0,0,0,6,0,0,0,5,0,0,0,6,0,0,0,5,0,0,0,7,0,0,0,6,0,0,0,7,0,0,0,6,0,0,0,7,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,3,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,1,0,0,0,2,0,0,0,5,0,0,0,7,0,0,0,7,0,0,0,10,0,0,0,10,0,0,0,13,0,0,0,13,0,0,0,13,0,0,0,13,0,0,0,13,0,0,0,13,0,0,0,13,0,0,0,13,0,0,0,0,0,0,0,8,0,0,0,16,0,0,0,24,0,0,0,32,0,0,0,40,0,0,0,48,0,0,0,56,0,0,0,64,0,0,0,80,0,0,0,96,0,0,0,112,0,0,0,128,0,0,0,160,0,0,0,192,0,0,0,224,0,0,0,0,1,0,0,64,1], "i8", ALLOC_NONE, Runtime.GLOBAL_BASE+82224);
/* memory initializer */ allocate([51,46,57,57,46,53,0,0,93,61,127,102,158,160,230,63,0,0,0,0,0,136,57,61,68,23,117,250,82,176,230,63,0,0,0,0,0,0,216,60,254,217,11,117,18,192,230,63,0,0,0,0,0,120,40,189,191,118,212,221,220,207,230,63,0,0,0,0,0,192,30,61,41,26,101,60,178,223,230,63,0,0,0,0,0,0,216,188,227,58,89,152,146,239,230,63,0,0,0,0,0,0,188,188,134,147,81,249,125,255,230,63,0,0,0,0,0,216,47,189,163,45,244,102,116,15,231,63,0,0,0,0,0,136,44,189,195,95,236,232,117,31,231,63,0,0,0,0,0,192,19,61,5,207,234,134,130,47,231,63,0,0,0,0,0,48,56,189,82,129,165,72,154,63,231,63,0,0,0,0,0,192,0,189,252,204,215,53,189,79,231,63,0,0,0,0,0,136,47,61,241,103,66,86,235,95,231,63,0,0,0,0,0,224,3,61,72,109,171,177,36,112,231,63,0,0,0,0,0,208,39,189,56,93,222,79,105,128,231,63,0,0,0,0,0,0,221,188,0,29,172,56,185,144,231,63,0,0,0,0,0,0,227,60,120,1,235,115,20,161,231,63,0,0,0,0,0,0,237,188,96,208,118,9,123,177,231,63,0,0,0,0,0,64,32,61,51,193,48,1,237,193,231,63,0,0,0,0,0,0,160,60,54,134,255,98,106,210,231,63,0,0,0,0,0,144,38,189,59,78,207,54,243,226,231,63,0,0,0,0,0,224,2,189,232,195,145,132,135,243,231,63,0,0,0,0,0,88,36,189,78,27,62,84,39,4,232,63,0,0,0,0,0,0,51,61,26,7,209,173,210,20,232,63,0,0,0,0,0,0,15,61,126,205,76,153,137,37,232,63,0,0,0,0,0,192,33,189,208,66,185,30,76,54,232,63,0,0,0,0,0,208,41,61,181,202,35,70,26,71,232,63,0,0,0,0,0,16,71,61,188,91,159,23,244,87,232,63,0,0,0,0,0,96,34,61,175,145,68,155,217,104,232,63,0,0,0,0,0,196,50,189,149,163,49,217,202,121,232,63,0,0,0,0,0,0,35,189,184,101,138,217,199,138,232,63,0,0,0,0,0,128,42,189,0,88,120,164,208,155,232,63,0,0,0,0,0,0,237,188,35,162,42,66,229,172,232,63,0,0,0,0,0,40,51,61,250,25,214,186,5,190,232,63,0,0,0,0,0,180,66,61,131,67,181,22,50,207,232,63,0,0,0,0,0,208,46,189,76,102,8,94,106,224,232,63,0,0,0,0,0,80,32,189,7,120,21,153,174,241,232,63,0,0,0,0,0,40,40,61,14,44,40,208,254,2,233,63,0,0,0,0,0,176,28,189,150,255,145,11,91,20,233,63,0,0,0,0,0,224,5,189,249,47,170,83,195,37,233,63,0,0,0,0,0,64,245,60,74,198,205,176,55,55,233,63,0,0,0,0,0,32,23,61,174,152,95,43,184,72,233,63,0,0,0,0,0,0,9,189,203,82,200,203,68,90,233,63,0,0,0,0,0,104,37,61,33,111,118,154,221,107,233,63,0,0,0,0,0,208,54,189,42,78,222,159,130,125,233,63,0,0,0,0,0,0,1,189,163,35,122,228,51,143,233,63,0,0,0,0,0,0,45,61,4,6,202,112,241,160,233,63,0,0,0,0,0,164,56,189,137,255,83,77,187,178,233,63,0,0,0,0,0,92,53,61,91,241,163,130,145,196,233,63,0,0,0,0,0,184,38,61,197,184,75,25,116,214,233,63,0,0,0,0,0,0,236,188,142,35,227,25,99,232,233,63,0,0,0,0,0,208,23,61,2,243,7,141,94,250,233,63,0,0,0,0,0,64,22,61,77,229,93,123,102,12,234,63,0,0,0,0,0,0,245,188,246,184,142,237,122,30,234,63,0,0,0,0,0,224,9,61,39,46,74,236,155,48,234,63,0,0,0,0,0,216,42,61,93,10,70,128,201,66,234,63,0,0,0,0,0,240,26,189,155,37,62,178,3,85,234,63,0,0,0,0,0,96,11,61,19,98,244,138,74,103,234,63,0,0,0,0,0,136,56,61,167,179,48,19,158,121,234,63,0,0,0,0,0,32,17,61,141,46,193,83,254,139,234,63,0,0,0,0,0,192,6,61,210,252,121,85,107,158,234,63,0,0,0,0,0,184,41,189,184,111,53,33,229,176,234,63,0,0,0,0,0,112,43,61,129,243,211,191,107,195,234,63,0,0,0,0,0,0,217,60,128,39,60,58,255,213,234,63,0,0,0,0,0,0,228,60,163,210,90,153,159,232,234,63,0,0,0,0,0,144,44,189,103,243,34,230,76,251,234,63,0,0,0,0,0,80,22,61,144,183,141,41,7,14,235,63,0,0,0,0,0,212,47,61,169,137,154,108,206,32,235,63,0,0,0,0,0,112,18,61,75,26,79,184,162,51,235,63,0,0,0,0,0,71,77,61,231,71,183,21,132,70,235,63,0,0,0,0,0,56,56,189,58,89,229,141,114,89,235,63,0,0,0,0,0,0,152,60,106,197,241,41,110,108,235,63,0,0,0,0,0,208,10,61,80,94,251,242,118,127,235,63,0,0,0,0,0,128,222,60,178,73,39,242,140,146,235,63,0,0,0,0,0,192,4,189,3,6,161,48,176,165,235,63,0,0,0,0,0,112,13,189,102,111,154,183,224,184,235,63,0,0,0,0,0,144,13,61,255,193,75,144,30,204,235,63,0,0,0,0,0,160,2,61,111,161,243,195,105,223,235,63,0,0,0,0,0,120,31,189,184,29,215,91,194,242,235,63,0,0,0,0,0,160,16,189,233,178,65,97,40,6,236,63,0,0,0,0,0,64,17,189,224,82,133,221,155,25,236,63,0,0,0,0,0,224,11,61,238,100,250,217,28,45,236,63,0,0,0,0,0,64,9,189,47,208,255,95,171,64,236,63,0,0,0,0,0,208,14,189,21,253,250,120,71,84,236,63,0,0,0,0,0,102,57,61,203,208,87,46,241,103,236,63,0,0,0,0,0,16,26,189,182,193,136,137,168,123,236,63,0,0,0,0,128,69,88,189,51,231,6,148,109,143,236,63,0,0,0,0,0,72,26,189,223,196,81,87,64,163,236,63,0,0,0,0,0,0,203,60,148,144,239,220,32,183,236,63,0,0,0,0,0,64,1,61,137,22,109,46,15,203,236,63,0,0,0,0,0,32,240,60,18,196,93,85,11,223,236,63,0,0,0,0,0,96,243,60,59,171,91,91,21,243,236,63,0,0,0,0,0,144,6,189,188,137,7,74,45,7,237,63,0,0,0,0,0,160,9,61,250,200,8,43,83,27,237,63,0,0,0,0,0,224,21,189,133,138,13,8,135,47,237,63,0,0,0,0,0,40,29,61,3,162,202,234,200,67,237,63,0,0,0,0,0,160,1,61,145,164,251,220,24,88,237,63,0,0,0,0,0,0,223,60,161,230,98,232,118,108,237,63,0,0,0,0,0,160,3,189,78,131,201,22,227,128,237,63,0,0,0,0,0,216,12,189,144,96,255,113,93,149,237,63,0,0,0,0,0,192,244,60,174,50,219,3,230,169,237,63,0,0,0,0,0,144,255,60,37,131,58,214,124,190,237,63,0,0,0,0,0,128,233,60,69,180,1,243,33,211,237,63,0,0,0,0,0,32,245,188,191,5,28,100,213,231,237,63,0,0,0,0,0,112,29,189,236,154,123,51,151,252,237,63,0,0,0,0,0,20,22,189,94,125,25,107,103,17,238,63,0,0,0,0,0,72,11,61,231,163,245,20,70,38,238,63,0,0,0,0,0,206,64,61,92,238,22,59,51,59,238,63,0,0,0,0,0,104,12,61,180,63,139,231,46,80,238,63,0,0,0,0,0,48,9,189,104,109,103,36,57,101,238,63,0,0,0,0,0,0,229,188,68,76,199,251,81,122,238,63,0,0,0,0,0,248,7,189,38,183,205,119,121,143,238,63,0,0,0,0,0,112,243,188,232,144,164,162,175,164,238,63,0,0,0,0,0,208,229,60,228,202,124,134,244,185,238,63,0,0,0,0,0,26,22,61,13,104,142,45,72,207,238,63,0,0,0,0,0,80,245,60,20,133,24,162,170,228,238,63,0,0,0,0,0,64,198,60,19,90,97,238,27,250,238,63,0,0,0,0,0,128,238,188,6,65,182,28,156,15,239,63,0,0,0,0,0,136,250,188,99,185,107,55,43,37,239,63,0,0,0,0,0,144,44,189,117,114,221,72,201,58,239,63,0,0,0,0,0,0,170,60,36,69,110,91,118,80,239,63,0,0,0,0,0,240,244,188,253,68,136,121,50,102,239,63,0,0,0,0,0,128,202,60,56,190,156,173,253,123,239,63,0,0,0,0,0,188,250,60,130,60,36,2,216,145,239,63,0,0,0,0,0,96,212,188,142,144,158,129,193,167,239,63,0,0,0,0,0,12,11,189,17,213,146,54,186,189,239,63,0,0,0,0,0,224,192,188,148,113,143,43,194,211,239,63,0,0,0,0,128,222,16,189,238,35,42,107,217,233,239,63,0,0,0,0,0,67,238,60,0,0,0,0,0,0,240,63,0,0,0,0,0,0,0,0,190,188,90,250,26,11,240,63,0,0,0,0,0,64,179,188,3,51,251,169,61,22,240,63,0,0,0,0,0,23,18,189,130,2,59,20,104,33,240,63,0,0,0,0,0,64,186,60,108,128,119,62,154,44,240,63,0,0,0,0,0,152,239,60,202,187,17,46,212,55,240,63,0,0,0,0,0,64,199,188,137,127,110,232,21,67,240,63,0,0,0,0,0,48,216,60,103,84,246,114,95,78,240,63,0,0,0,0,0,63,26,189,90,133,21,211,176,89,240,63,0,0,0,0,0,132,2,189,149,31,60,14,10,101,240,63,0,0,0,0,0,96,241,60,26,247,221,41,107,112,240,63,0,0,0,0,0,36,21,61,45,168,114,43,212,123,240,63,0,0,0,0,0,160,233,188,208,155,117,24,69,135,240,63,0,0,0,0,0,64,230,60,200,7,102,246,189,146,240,63,0,0,0,0,0,120,0,189,131,243,198,202,62,158,240,63,0,0,0,0,0,0,152,188,48,57,31,155,199,169,240,63,0,0,0,0,0,160,255,60,252,136,249,108,88,181,240,63,0,0,0,0,0,200,250,188,138,108,228,69,241,192,240,63,0,0,0,0,0,192,217,60,22,72,114,43,146,204,240,63,0,0,0,0,0,32,5,61,216,93,57,35,59,216,240,63,0,0,0,0,0,208,250,188,243,209,211,50,236,227,240,63,0,0,0,0,0,172,27,61,166,169,223,95,165,239,240,63,0,0,0,0,0,232,4,189,240,210,254,175,102,251,240,63,0,0,0,0,0,48,13,189,75,35,215,40,48,7,241,63,0,0,0,0,0,80,241,60,91,91,18,208,1,19,241,63,0,0,0,0,0,0,236,60,249,42,94,171,219,30,241,63,0,0,0,0,0,188,22,61,213,49,108,192,189,42,241,63,0,0,0,0,0,64,232,60,125,4,242,20,168,54,241,63,0,0,0,0,0,208,14,189,233,45,169,174,154,66,241,63,0,0,0,0,0,224,232,60,56,49,79,147,149,78,241,63,0,0,0,0,0,64,235,60,113,142,165,200,152,90,241,63,0,0,0,0,0,48,5,61,223,195,113,84,164,102,241,63,0,0,0,0,0,56,3,61,17,82,125,60,184,114,241,63,0,0,0,0,0,212,40,61,159,187,149,134,212,126,241,63,0,0,0,0,0,208,5,189,147,141,140,56,249,138,241,63,0,0,0,0,0,136,28,189,102,93,55,88,38,151,241,63,0,0,0,0,0,240,17,61,167,203,111,235,91,163,241,63,0,0,0,0,0,72,16,61,227,135,19,248,153,175,241,63,0,0,0,0,0,57,71,189,84,93,4,132,224,187,241,63,0,0,0,0,0,228,36,61,67,28,40,149,47,200,241,63,0,0,0,0,0,32,10,189,178,185,104,49,135,212,241,63,0,0,0,0,0,128,227,60,49,64,180,94,231,224,241,63,0,0,0,0,0,192,234,60,56,217,252,34,80,237,241,63,0,0,0,0,0,144,1,61,247,205,56,132,193,249,241,63,0,0,0,0,0,120,27,189,143,141,98,136,59,6,242,63,0,0,0,0,0,148,45,61,30,168,120,53,190,18,242,63,0,0,0,0,0,0,216,60,65,221,125,145,73,31,242,63,0,0,0,0,0,52,43,61,35,19,121,162,221,43,242,63,0,0,0,0,0,248,25,61,231,97,117,110,122,56,242,63,0,0,0,0,0,200,25,189,39,20,130,251,31,69,242,63,0,0,0,0,0,48,2,61,2,166,178,79,206,81,242,63,0,0,0,0,0,72,19,189,176,206,30,113,133,94,242,63,0,0,0,0,0,112,18,61,22,125,226,101,69,107,242,63,0,0,0,0,0,208,17,61,15,224,29,52,14,120,242,63,0,0,0,0,0,238,49,61,62,99,245,225,223,132,242,63,0,0,0,0,0,192,20,189,48,187,145,117,186,145,242,63,0,0,0,0,0,216,19,189,9,223,31,245,157,158,242,63,0,0,0,0,0,176,8,61,155,14,209,102,138,171,242,63,0,0,0,0,0,124,34,189,58,218,218,208,127,184,242,63,0,0,0,0,0,52,42,61,249,26,119,57,126,197,242,63,0,0,0,0,0,128,16,189,217,2,228,166,133,210,242,63,0,0,0,0,0,208,14,189,121,21,100,31,150,223,242,63,0,0,0,0,0,32,244,188,207,46,62,169,175,236,242,63,0,0,0,0,0,152,36,189,34,136,189,74,210,249,242,63,0,0,0,0,0,48,22,189,37,182,49,10,254,6,243,63,0,0,0,0,0,54,50,189,11,165,238,237,50,20,243,63,0,0,0,0,128,223,112,189,184,215,76,252,112,33,243,63,0,0,0,0,0,72,34,189,162,233,168,59,184,46,243,63,0,0,0,0,0,152,37,189,102,23,100,178,8,60,243,63,0,0,0,0,0,208,30,61,39,250,227,102,98,73,243,63,0,0,0,0,0,0,220,188,15,159,146,95,197,86,243,63,0,0,0,0,0,216,48,189,185,136,222,162,49,100,243,63,0,0,0,0,0,200,34,61,57,170,58,55,167,113,243,63,0,0,0,0,0,96,32,61,254,116,30,35,38,127,243,63,0,0,0,0,0,96,22,189,56,216,5,109,174,140,243,63,0,0,0,0,0,224,10,189,195,62,113,27,64,154,243,63,0,0,0,0,0,114,68,189,32,160,229,52,219,167,243,63,0,0,0,0,0,32,8,61,149,110,236,191,127,181,243,63,0,0,0,0,0,128,62,61,242,168,19,195,45,195,243,63,0,0,0,0,0,128,239,60,34,225,237,68,229,208,243,63,0,0,0,0,0,160,23,189,187,52,18,76,166,222,243,63,0,0,0,0,0,48,38,61,204,78,28,223,112,236,243,63,0,0,0,0,0,166,72,189,140,126,172,4,69,250,243,63,0,0,0,0,0,220,60,189,187,160,103,195,34,8,244,63,0,0,0,0,0,184,37,61,149,46,247,33,10,22,244,63,0,0,0,0,0,192,30,61,70,70,9,39,251,35,244,63,0,0,0,0,0,96,19,189,32,169,80,217,245,49,244,63,0,0,0,0,0,152,35,61,235,185,132,63,250,63,244,63,0,0,0,0,0,0,250,60,25,137,97,96,8,78,244,63,0,0,0,0,0,192,246,188,1,210,167,66,32,92,244,63,0,0,0,0,0,192,11,189,22,0,29,237,65,106,244,63,0,0,0,0,0,128,18,189,38,51,139,102,109,120,244,63,0,0,0,0,0,224,48,61,0,60,193,181,162,134,244,63,0,0,0,0,0,64,45,189,4,175,146,225,225,148,244,63,0,0,0,0,0,32,12,61,114,211,215,240,42,163,244,63,0,0,0,0,0,80,30,189,1,184,109,234,125,177,244,63,0,0,0,0,0,128,7,61,225,41,54,213,218,191,244,63,0,0,0,0,0,128,19,189,50,193,23,184,65,206,244,63,0,0,0,0,0,128,0,61,219,221,253,153,178,220,244,63,0,0,0,0,0,112,44,61,150,171,216,129,45,235,244,63,0,0,0,0,0,224,28,189,2,45,157,118,178,249,244,63,0,0,0,0,0,32,25,61,193,49,69,127,65,8,245,63,0,0,0,0,0,192,8,189,42,102,207,162,218,22,245,63,0,0,0,0,0,0,250,188,234,81,63,232,125,37,245,63,0,0,0,0,0,8,74,61,218,78,157,86,43,52,245,63,0,0,0,0,0,216,38,189,26,172,246,244,226,66,245,63,0,0,0,0,0,68,50,189,219,148,93,202,164,81,245,63,0,0,0,0,0,60,72,61,107,17,233,221,112,96,245,63,0,0,0,0,0,176,36,61,222,41,181,54,71,111,245,63,0,0,0,0,0,90,65,61,14,196,226,219,39,126,245,63,0,0,0,0,0,224,41,189,111,199,151,212,18,141,245,63,0,0,0,0,0,8,35,189,76,11,255,39,8,156,245,63,0,0,0,0,0,236,77,61,39,84,72,221,7,171,245,63,0,0,0,0,0,0,196,188,244,122,168,251,17,186,245,63,0,0,0,0,0,8,48,61,11,70,89,138,38,201,245,63,0,0,0,0,0,200,38,189,63,142,153,144,69,216,245,63,0,0,0,0,0,154,70,61,225,32,173,21,111,231,245,63,0,0,0,0,0,64,27,189,202,235,220,32,163,246,245,63,0,0,0,0,0,112,23,61,184,220,118,185,225,5,246,63,0,0,0,0,0,248,38,61,21,247,205,230,42,21,246,63,0,0,0,0,0,0,1,61,49,85,58,176,126,36,246,63,0,0,0,0,0,208,21,189,181,41,25,29,221,51,246,63,0,0,0,0,0,208,18,189,19,195,204,52,70,67,246,63,0,0,0,0,0,128,234,188,250,142,188,254,185,82,246,63,0,0,0,0,0,96,40,189,151,51,85,130,56,98,246,63,0,0,0,0,0,254,113,61,142,50,8,199,193,113,246,63,0,0,0,0,0,32,55,189,126,169,76,212,85,129,246,63,0,0,0,0,0,128,230,60,113,148,158,177,244,144,246,63,0,0,0,0,0,120,41,189,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,10,0,17,17,17,0,0,0,0,5,0,0,0,0,0,0,9,0,0,0,0,11,0,0,0,0,0,0,0,0,17,0,15,10,17,17,17,3,10,7,0,1,19,9,11,11,0,0,9,6,11,0,0,11,0,6,17,0,0,0,17,17,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,17,0,10,10,17,17,17,0,10,0,0,2,0,9,11,0,0,0,9,0,11,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,9,12,0,0,0,0,0,12,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,4,13,0,0,0,0,9,14,0,0,0,0,0,14,0,0,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,0,9,16,0,0,0,0,0,16,0,0,16,0,0,18,0,0,0,18,18,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,18,18,18,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,10,0,0,0,0,9,11,0,0,0,0,0,11,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,9,12,0,0,0,0,0,12,0,0,12,0,0,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,45,43,32,32,32,48,88,48,120,0,0,0,0,0,0,0,40,110,117,108,108,41,0,0,45,48,88,43,48,88,32,48,88,45,48,120,43,48,120,32,48,120,0,0,0,0,0,0,105,110,102,0,0,0,0,0,73,78,70,0,0,0,0,0,110,97,110,0,0,0,0,0,78,65,78,0,0,0,0,0,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_NONE, Runtime.GLOBAL_BASE+91696);





/* no memory initializer */
var tempDoublePtr = Runtime.alignMemory(allocate(12, "i8", ALLOC_STATIC), 8);

assert(tempDoublePtr % 8 == 0);

function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

}

function copyTempDouble(ptr) {

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];

  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];

  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];

  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];

}

// {{PRE_LIBRARY}}


  function _InitGainAnalysis() {
  Module['printErr']('missing function: InitGainAnalysis'); abort(-1);
  }

  function _AnalyzeSamples() {
  Module['printErr']('missing function: AnalyzeSamples'); abort(-1);
  }

   
  Module["_i64Subtract"] = _i64Subtract;

  var _fabsf=Math_abs;

  var _floorf=Math_floor;

   
  Module["_memset"] = _memset;

  var _BDtoILow=true;

  
  
  var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};
  
  var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can't send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};
  
  
  var ___errno_state=0;function ___setErrNo(value) {
      // For convenient setting and returning of errno.
      HEAP32[((___errno_state)>>2)]=value;
      return value;
    }function _strerror_r(errnum, strerrbuf, buflen) {
      if (errnum in ERRNO_MESSAGES) {
        if (ERRNO_MESSAGES[errnum].length > buflen - 1) {
          return ___setErrNo(ERRNO_CODES.ERANGE);
        } else {
          var msg = ERRNO_MESSAGES[errnum];
          writeAsciiToMemory(msg, strerrbuf);
          return 0;
        }
      } else {
        return ___setErrNo(ERRNO_CODES.EINVAL);
      }
    }function _strerror(errnum) {
      if (!_strerror.buffer) _strerror.buffer = _malloc(256);
      _strerror_r(errnum, _strerror.buffer, 256);
      return _strerror.buffer;
    }

  function _VBR_encode_frame() {
  Module['printErr']('missing function: VBR_encode_frame'); abort(-1);
  }

  function _abort() {
      Module['abort']();
    }

  function _init_xrpow_core_sse() {
  Module['printErr']('missing function: init_xrpow_core_sse'); abort(-1);
  }

  
  
  var PATH={splitPath:function (filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function (parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up--; up) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function (path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function (path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function (path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function (path) {
        return PATH.splitPath(path)[3];
      },join:function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function (l, r) {
        return PATH.normalize(l + '/' + r);
      },resolve:function () {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function (from, to) {
        from = PATH.resolve(from).substr(1);
        to = PATH.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY={ttys:[],init:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function (dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function (stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function (stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function (stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function (stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          for (var i = 0; i < length; i++) {
            try {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function (tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              // we will read data by chunks of BUFSIZE
              var BUFSIZE = 256;
              var buf = new Buffer(BUFSIZE);
              var bytesRead = 0;
  
              var fd = process.stdin.fd;
              // Linux and Mac cannot use process.stdin.fd (which isn't set up as sync)
              var usingDevice = false;
              try {
                fd = fs.openSync('/dev/stdin', 'r');
                usingDevice = true;
              } catch (e) {}
  
              bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);
  
              if (usingDevice) { fs.closeSync(fd); }
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString('utf-8');
              } else {
                result = null;
              }
  
            } else if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['print'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function (tty) {
          if (tty.output && tty.output.length > 0) {
            Module['print'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['printErr'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function (tty) {
          if (tty.output && tty.output.length > 0) {
            Module['printErr'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  var MEMFS={ops_table:null,mount:function (mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function (parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.buffer.byteLength which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },getFileDataAsRegularArray:function (node) {
        if (node.contents && node.contents.subarray) {
          var arr = [];
          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
          return arr; // Returns a copy of the original data.
        }
        return node.contents; // No-op, the file contents are already in a JS array. Return as-is.
      },getFileDataAsTypedArray:function (node) {
        if (!node.contents) return new Uint8Array;
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function (node, newCapacity) {
        // If we are asked to expand the size of a file that already exists, revert to using a standard JS array to store the file
        // instead of a typed array. This makes resizing the array more flexible because we can just .push() elements at the back to
        // increase the size.
        if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {
          node.contents = MEMFS.getFileDataAsRegularArray(node);
          node.usedBytes = node.contents.length; // We might be writing to a lazy-loaded file which had overridden this property, so force-reset it.
        }
  
        if (!node.contents || node.contents.subarray) { // Keep using a typed array if creating a new storage, or if old one was a typed array as well.
          var prevCapacity = node.contents ? node.contents.buffer.byteLength : 0;
          if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
          // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
          // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
          // avoid overshooting the allocation cap by a very large margin.
          var CAPACITY_DOUBLING_MAX = 1024 * 1024;
          newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) | 0);
          if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
          var oldContents = node.contents;
          node.contents = new Uint8Array(newCapacity); // Allocate new storage.
          if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
          return;
        }
        // Not using a typed array to back the file storage. Use a standard JS array instead.
        if (!node.contents && newCapacity > 0) node.contents = [];
        while (node.contents.length < newCapacity) node.contents.push(0);
      },resizeFileStorage:function (node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
          return;
        }
        if (!node.contents || node.contents.subarray) { // Resize a typed array if that is being used as the backing store.
          var oldContents = node.contents;
          node.contents = new Uint8Array(new ArrayBuffer(newSize)); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
          return;
        }
        // Backing with a JS array.
        if (!node.contents) node.contents = [];
        if (node.contents.length > newSize) node.contents.length = newSize;
        else while (node.contents.length < newSize) node.contents.push(0);
        node.usedBytes = newSize;
      },node_ops:{getattr:function (node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function (parent, name) {
          throw FS.genericErrors[ERRNO_CODES.ENOENT];
        },mknod:function (parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function (old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },unlink:function (parent, name) {
          delete parent.contents[name];
        },rmdir:function (parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
          }
          delete parent.contents[name];
        },readdir:function (node) {
          var entries = ['.', '..']
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function (parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function (node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return node.link;
        }},stream_ops:{read:function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function (stream, buffer, offset, length, position, canOwn) {
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) { // Can we just reuse the buffer we are given?
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = new Uint8Array(buffer.subarray(offset, offset + length));
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.
          else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position+length);
          return length;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return position;
        },allocate:function (stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function (stream, buffer, offset, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if ( !(flags & 2) &&
                (contents.buffer === buffer || contents.buffer === buffer.buffer) ) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < stream.node.usedBytes) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = _malloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);
            }
            buffer.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function (stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};
  
  var IDBFS={dbs:{},indexedDB:function () {
        if (typeof indexedDB !== 'undefined') return indexedDB;
        var ret = null;
        if (typeof window === 'object') ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        assert(ret, 'IDBFS used, but indexedDB not supported');
        return ret;
      },DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:function (mount) {
        // reuse all of the core MEMFS functionality
        return MEMFS.mount.apply(null, arguments);
      },syncfs:function (mount, populate, callback) {
        IDBFS.getLocalSet(mount, function(err, local) {
          if (err) return callback(err);
  
          IDBFS.getRemoteSet(mount, function(err, remote) {
            if (err) return callback(err);
  
            var src = populate ? remote : local;
            var dst = populate ? local : remote;
  
            IDBFS.reconcile(src, dst, callback);
          });
        });
      },getDB:function (name, callback) {
        // check the cache first
        var db = IDBFS.dbs[name];
        if (db) {
          return callback(null, db);
        }
  
        var req;
        try {
          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
        } catch (e) {
          return callback(e);
        }
        req.onupgradeneeded = function(e) {
          var db = e.target.result;
          var transaction = e.target.transaction;
  
          var fileStore;
  
          if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
          } else {
            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);
          }
  
          if (!fileStore.indexNames.contains('timestamp')) {
            fileStore.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
        req.onsuccess = function() {
          db = req.result;
  
          // add to the cache
          IDBFS.dbs[name] = db;
          callback(null, db);
        };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },getLocalSet:function (mount, callback) {
        var entries = {};
  
        function isRealDir(p) {
          return p !== '.' && p !== '..';
        };
        function toAbsolute(root) {
          return function(p) {
            return PATH.join2(root, p);
          }
        };
  
        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));
  
        while (check.length) {
          var path = check.pop();
          var stat;
  
          try {
            stat = FS.stat(path);
          } catch (e) {
            return callback(e);
          }
  
          if (FS.isDir(stat.mode)) {
            check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));
          }
  
          entries[path] = { timestamp: stat.mtime };
        }
  
        return callback(null, { type: 'local', entries: entries });
      },getRemoteSet:function (mount, callback) {
        var entries = {};
  
        IDBFS.getDB(mount.mountpoint, function(err, db) {
          if (err) return callback(err);
  
          var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readonly');
          transaction.onerror = function(e) {
            callback(this.error);
            e.preventDefault();
          };
  
          var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
          var index = store.index('timestamp');
  
          index.openKeyCursor().onsuccess = function(event) {
            var cursor = event.target.result;
  
            if (!cursor) {
              return callback(null, { type: 'remote', db: db, entries: entries });
            }
  
            entries[cursor.primaryKey] = { timestamp: cursor.key };
  
            cursor.continue();
          };
        });
      },loadLocalEntry:function (path, callback) {
        var stat, node;
  
        try {
          var lookup = FS.lookupPath(path);
          node = lookup.node;
          stat = FS.stat(path);
        } catch (e) {
          return callback(e);
        }
  
        if (FS.isDir(stat.mode)) {
          return callback(null, { timestamp: stat.mtime, mode: stat.mode });
        } else if (FS.isFile(stat.mode)) {
          // Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array.
          // Therefore always convert the file contents to a typed array first before writing the data to IndexedDB.
          node.contents = MEMFS.getFileDataAsTypedArray(node);
          return callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents });
        } else {
          return callback(new Error('node type not supported'));
        }
      },storeLocalEntry:function (path, entry, callback) {
        try {
          if (FS.isDir(entry.mode)) {
            FS.mkdir(path, entry.mode);
          } else if (FS.isFile(entry.mode)) {
            FS.writeFile(path, entry.contents, { encoding: 'binary', canOwn: true });
          } else {
            return callback(new Error('node type not supported'));
          }
  
          FS.chmod(path, entry.mode);
          FS.utime(path, entry.timestamp, entry.timestamp);
        } catch (e) {
          return callback(e);
        }
  
        callback(null);
      },removeLocalEntry:function (path, callback) {
        try {
          var lookup = FS.lookupPath(path);
          var stat = FS.stat(path);
  
          if (FS.isDir(stat.mode)) {
            FS.rmdir(path);
          } else if (FS.isFile(stat.mode)) {
            FS.unlink(path);
          }
        } catch (e) {
          return callback(e);
        }
  
        callback(null);
      },loadRemoteEntry:function (store, path, callback) {
        var req = store.get(path);
        req.onsuccess = function(event) { callback(null, event.target.result); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },storeRemoteEntry:function (store, path, entry, callback) {
        var req = store.put(entry, path);
        req.onsuccess = function() { callback(null); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },removeRemoteEntry:function (store, path, callback) {
        var req = store.delete(path);
        req.onsuccess = function() { callback(null); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },reconcile:function (src, dst, callback) {
        var total = 0;
  
        var create = [];
        Object.keys(src.entries).forEach(function (key) {
          var e = src.entries[key];
          var e2 = dst.entries[key];
          if (!e2 || e.timestamp > e2.timestamp) {
            create.push(key);
            total++;
          }
        });
  
        var remove = [];
        Object.keys(dst.entries).forEach(function (key) {
          var e = dst.entries[key];
          var e2 = src.entries[key];
          if (!e2) {
            remove.push(key);
            total++;
          }
        });
  
        if (!total) {
          return callback(null);
        }
  
        var errored = false;
        var completed = 0;
        var db = src.type === 'remote' ? src.db : dst.db;
        var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readwrite');
        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
  
        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return callback(err);
            }
            return;
          }
          if (++completed >= total) {
            return callback(null);
          }
        };
  
        transaction.onerror = function(e) {
          done(this.error);
          e.preventDefault();
        };
  
        // sort paths in ascending order so directory entries are created
        // before the files inside them
        create.sort().forEach(function (path) {
          if (dst.type === 'local') {
            IDBFS.loadRemoteEntry(store, path, function (err, entry) {
              if (err) return done(err);
              IDBFS.storeLocalEntry(path, entry, done);
            });
          } else {
            IDBFS.loadLocalEntry(path, function (err, entry) {
              if (err) return done(err);
              IDBFS.storeRemoteEntry(store, path, entry, done);
            });
          }
        });
  
        // sort paths in descending order so files are deleted before their
        // parent directories
        remove.sort().reverse().forEach(function(path) {
          if (dst.type === 'local') {
            IDBFS.removeLocalEntry(path, done);
          } else {
            IDBFS.removeRemoteEntry(store, path, done);
          }
        });
      }};
  
  var NODEFS={isWindows:false,staticInit:function () {
        NODEFS.isWindows = !!process.platform.match(/^win/);
      },mount:function (mount) {
        assert(ENVIRONMENT_IS_NODE);
        return NODEFS.createNode(null, '/', NODEFS.getMode(mount.opts.root), 0);
      },createNode:function (parent, name, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node = FS.createNode(parent, name, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node;
      },getMode:function (path) {
        var stat;
        try {
          stat = fs.lstatSync(path);
          if (NODEFS.isWindows) {
            // On Windows, directories return permission bits 'rw-rw-rw-', even though they have 'rwxrwxrwx', so
            // propagate write bits to execute bits.
            stat.mode = stat.mode | ((stat.mode & 146) >> 1);
          }
        } catch (e) {
          if (!e.code) throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return stat.mode;
      },realPath:function (node) {
        var parts = [];
        while (node.parent !== node) {
          parts.push(node.name);
          node = node.parent;
        }
        parts.push(node.mount.opts.root);
        parts.reverse();
        return PATH.join.apply(null, parts);
      },flagsToPermissionStringMap:{0:"r",1:"r+",2:"r+",64:"r",65:"r+",66:"r+",129:"rx+",193:"rx+",514:"w+",577:"w",578:"w+",705:"wx",706:"wx+",1024:"a",1025:"a",1026:"a+",1089:"a",1090:"a+",1153:"ax",1154:"ax+",1217:"ax",1218:"ax+",4096:"rs",4098:"rs+"},flagsToPermissionString:function (flags) {
        if (flags in NODEFS.flagsToPermissionStringMap) {
          return NODEFS.flagsToPermissionStringMap[flags];
        } else {
          return flags;
        }
      },node_ops:{getattr:function (node) {
          var path = NODEFS.realPath(node);
          var stat;
          try {
            stat = fs.lstatSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake them with default blksize of 4096.
          // See http://support.microsoft.com/kb/140365
          if (NODEFS.isWindows && !stat.blksize) {
            stat.blksize = 4096;
          }
          if (NODEFS.isWindows && !stat.blocks) {
            stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;
          }
          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks
          };
        },setattr:function (node, attr) {
          var path = NODEFS.realPath(node);
          try {
            if (attr.mode !== undefined) {
              fs.chmodSync(path, attr.mode);
              // update the common node structure mode as well
              node.mode = attr.mode;
            }
            if (attr.timestamp !== undefined) {
              var date = new Date(attr.timestamp);
              fs.utimesSync(path, date, date);
            }
            if (attr.size !== undefined) {
              fs.truncateSync(path, attr.size);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },lookup:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          var mode = NODEFS.getMode(path);
          return NODEFS.createNode(parent, name, mode);
        },mknod:function (parent, name, mode, dev) {
          var node = NODEFS.createNode(parent, name, mode, dev);
          // create the backing node for this in the fs root as well
          var path = NODEFS.realPath(node);
          try {
            if (FS.isDir(node.mode)) {
              fs.mkdirSync(path, node.mode);
            } else {
              fs.writeFileSync(path, '', { mode: node.mode });
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          return node;
        },rename:function (oldNode, newDir, newName) {
          var oldPath = NODEFS.realPath(oldNode);
          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
          try {
            fs.renameSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },unlink:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.unlinkSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },rmdir:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.rmdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },readdir:function (node) {
          var path = NODEFS.realPath(node);
          try {
            return fs.readdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },symlink:function (parent, newName, oldPath) {
          var newPath = PATH.join2(NODEFS.realPath(parent), newName);
          try {
            fs.symlinkSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },readlink:function (node) {
          var path = NODEFS.realPath(node);
          try {
            path = fs.readlinkSync(path);
            path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);
            return path;
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        }},stream_ops:{open:function (stream) {
          var path = NODEFS.realPath(stream.node);
          try {
            if (FS.isFile(stream.node.mode)) {
              stream.nfd = fs.openSync(path, NODEFS.flagsToPermissionString(stream.flags));
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },close:function (stream) {
          try {
            if (FS.isFile(stream.node.mode) && stream.nfd) {
              fs.closeSync(stream.nfd);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },read:function (stream, buffer, offset, length, position) {
          if (length === 0) return 0; // node errors on 0 length reads
          // FIXME this is terrible.
          var nbuffer = new Buffer(length);
          var res;
          try {
            res = fs.readSync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          if (res > 0) {
            for (var i = 0; i < res; i++) {
              buffer[offset + i] = nbuffer[i];
            }
          }
          return res;
        },write:function (stream, buffer, offset, length, position) {
          // FIXME this is terrible.
          var nbuffer = new Buffer(buffer.subarray(offset, offset + length));
          var res;
          try {
            res = fs.writeSync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          return res;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              try {
                var stat = fs.fstatSync(stream.nfd);
                position += stat.size;
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES[e.code]);
              }
            }
          }
  
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
  
          return position;
        }}};
  
  var _stdin=allocate(1, "i32*", ALLOC_STATIC);
  
  var _stdout=allocate(1, "i32*", ALLOC_STATIC);
  
  var _stderr=allocate(1, "i32*", ALLOC_STATIC);var FS={root:null,mounts:[],devices:[null],streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},handleFSError:function (e) {
        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();
        return ___setErrNo(e.errno);
      },lookupPath:function (path, opts) {
        path = PATH.resolve(FS.cwd(), path);
        opts = opts || {};
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:function (node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:function (parentid, name) {
        var hash = 0;
  
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:function (parent, name) {
        var err = FS.mayLookup(parent);
        if (err) {
          throw new FS.ErrnoError(err, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:function (parent, name, mode, rdev) {
        if (!FS.FSNode) {
          FS.FSNode = function(parent, name, mode, rdev) {
            if (!parent) {
              parent = this;  // root node sets parent to itself
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };
  
          FS.FSNode.prototype = {};
  
          // compatibility
          var readMode = 292 | 73;
          var writeMode = 146;
  
          // NOTE we must use Object.defineProperties instead of individual calls to
          // Object.defineProperty in order to make closure compiler happy
          Object.defineProperties(FS.FSNode.prototype, {
            read: {
              get: function() { return (this.mode & readMode) === readMode; },
              set: function(val) { val ? this.mode |= readMode : this.mode &= ~readMode; }
            },
            write: {
              get: function() { return (this.mode & writeMode) === writeMode; },
              set: function(val) { val ? this.mode |= writeMode : this.mode &= ~writeMode; }
            },
            isFolder: {
              get: function() { return FS.isDir(this.mode); }
            },
            isDevice: {
              get: function() { return FS.isChrdev(this.mode); }
            }
          });
        }
  
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:function (node) {
        FS.hashRemoveNode(node);
      },isRoot:function (node) {
        return node === node.parent;
      },isMountpoint:function (node) {
        return !!node.mounted;
      },isFile:function (mode) {
        return (mode & 61440) === 32768;
      },isDir:function (mode) {
        return (mode & 61440) === 16384;
      },isLink:function (mode) {
        return (mode & 61440) === 40960;
      },isChrdev:function (mode) {
        return (mode & 61440) === 8192;
      },isBlkdev:function (mode) {
        return (mode & 61440) === 24576;
      },isFIFO:function (mode) {
        return (mode & 61440) === 4096;
      },isSocket:function (mode) {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function (str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:function (flag) {
        var accmode = flag & 2097155;
        var perms = ['r', 'w', 'rw'][accmode];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:function (node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {
          return ERRNO_CODES.EACCES;
        }
        return 0;
      },mayLookup:function (dir) {
        var err = FS.nodePermissions(dir, 'x');
        if (err) return err;
        if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES;
        return 0;
      },mayCreate:function (dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return ERRNO_CODES.EEXIST;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:function (dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var err = FS.nodePermissions(dir, 'wx');
        if (err) {
          return err;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return ERRNO_CODES.ENOTDIR;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return ERRNO_CODES.EBUSY;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return ERRNO_CODES.EISDIR;
          }
        }
        return 0;
      },mayOpen:function (node, flags) {
        if (!node) {
          return ERRNO_CODES.ENOENT;
        }
        if (FS.isLink(node.mode)) {
          return ERRNO_CODES.ELOOP;
        } else if (FS.isDir(node.mode)) {
          if ((flags & 2097155) !== 0 ||  // opening for write
              (flags & 512)) {
            return ERRNO_CODES.EISDIR;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:function (fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(ERRNO_CODES.EMFILE);
      },getStream:function (fd) {
        return FS.streams[fd];
      },createStream:function (stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = function(){};
          FS.FSStream.prototype = {};
          // compatibility
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          });
        }
        // clone it, so we can return an instance of FSStream
        var newStream = new FS.FSStream();
        for (var p in stream) {
          newStream[p] = stream[p];
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:function (fd) {
        FS.streams[fd] = null;
      },getStreamFromPtr:function (ptr) {
        return FS.streams[ptr - 1];
      },getPtrForStream:function (stream) {
        return stream ? stream.fd + 1 : 0;
      },chrdev_stream_ops:{open:function (stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function () {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }},major:function (dev) {
        return ((dev) >> 8);
      },minor:function (dev) {
        return ((dev) & 0xff);
      },makedev:function (ma, mi) {
        return ((ma) << 8 | (mi));
      },registerDevice:function (dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:function (dev) {
        return FS.devices[dev];
      },getMounts:function (mount) {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:function (populate, callback) {
        if (typeof(populate) === 'function') {
          callback = populate;
          populate = false;
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return callback(err);
            }
            return;
          }
          if (++completed >= mounts.length) {
            callback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:function (type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },lookup:function (parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function (path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var err = FS.mayCreate(parent, name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function (path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:function (path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdev:function (path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:function (oldpath, newpath) {
        if (!PATH.resolve(oldpath)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        var newname = PATH.basename(newpath);
        var err = FS.mayCreate(parent, newname);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function (old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
        try {
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(ERRNO_CODES.EXDEV);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        // new path should not be an ancestor of the old path
        relative = PATH.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var err = FS.mayDelete(old_dir, old_name, isdir);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        err = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          err = FS.nodePermissions(old_dir, 'w');
          if (err) {
            throw new FS.ErrnoError(err);
          }
        }
        try {
          if (FS.trackingDelegate['willMovePath']) {
            FS.trackingDelegate['willMovePath'](old_path, new_path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
        try {
          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);
        } catch(e) {
          console.log("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
      },rmdir:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, true);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        return node.node_ops.readdir(node);
      },unlink:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, false);
        if (err) {
          // POSIX says unlink should set EPERM, not EISDIR
          if (err === ERRNO_CODES.EISDIR) err = ERRNO_CODES.EPERM;
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readlink:function (path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return PATH.resolve(FS.getPath(lookup.node.parent), link.node_ops.readlink(link));
      },stat:function (path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return node.node_ops.getattr(node);
      },lstat:function (path) {
        return FS.stat(path, true);
      },chmod:function (path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function (path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function (fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chmod(stream.node, mode);
      },chown:function (path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function (path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function (fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function (path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var err = FS.nodePermissions(node, 'w');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function (fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        FS.truncate(stream.node, len);
      },utime:function (path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function (path, flags, mode, fd_start, fd_end) {
        if (path === "") {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(ERRNO_CODES.EEXIST);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var err = FS.mayOpen(node, flags);
          if (err) {
            throw new FS.ErrnoError(err);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            Module['printErr']('read file: ' + path);
          }
        }
        try {
          if (FS.trackingDelegate['onOpenFile']) {
            var trackingFlags = 0;
            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }
            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }
            FS.trackingDelegate['onOpenFile'](path, trackingFlags);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: " + e.message);
        }
        return stream;
      },close:function (stream) {
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
      },llseek:function (stream, offset, whence) {
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:function (stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function (stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if (stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        try {
          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);
        } catch(e) {
          console.log("FS.trackingDelegate['onWriteToFile']('"+path+"') threw an exception: " + e.message);
        }
        return bytesWritten;
      },allocate:function (stream, offset, length) {
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function (stream, buffer, offset, length, position, prot, flags) {
        // TODO if PROT is PROT_WRITE, make sure we have write access
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EACCES);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
      },msync:function (stream, buffer, offset, length, mmapFlags) {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:function (stream) {
        return 0;
      },ioctl:function (stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:function (path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'r';
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:function (path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'w';
        opts.encoding = opts.encoding || 'utf8';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var stream = FS.open(path, opts.flags, opts.mode);
        if (opts.encoding === 'utf8') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, 0, opts.canOwn);
        } else if (opts.encoding === 'binary') {
          FS.write(stream, data, 0, data.length, 0, opts.canOwn);
        }
        FS.close(stream);
      },cwd:function () {
        return FS.currentPath;
      },chdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        var err = FS.nodePermissions(lookup.node, 'x');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:function () {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:function () {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function(stream, buffer, offset, length, pos) { return length; }
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using Module['printErr']
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device;
        if (typeof crypto !== 'undefined') {
          // for modern web browsers
          var randomBuffer = new Uint8Array(1);
          random_device = function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
        } else if (ENVIRONMENT_IS_NODE) {
          // for nodejs
          random_device = function() { return require('crypto').randomBytes(1)[0]; };
        } else {
          // default for ES5 platforms
          random_device = function() { return (Math.random()*256)|0; };
        }
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createStandardStreams:function () {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 'r');
        HEAP32[((_stdin)>>2)]=FS.getPtrForStream(stdin);
        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');
  
        var stdout = FS.open('/dev/stdout', 'w');
        HEAP32[((_stdout)>>2)]=FS.getPtrForStream(stdout);
        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');
  
        var stderr = FS.open('/dev/stderr', 'w');
        HEAP32[((_stderr)>>2)]=FS.getPtrForStream(stderr);
        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
      },ensureErrnoError:function () {
        if (FS.ErrnoError) return;
        FS.ErrnoError = function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = function(errno) {
            this.errno = errno;
            for (var key in ERRNO_CODES) {
              if (ERRNO_CODES[key] === errno) {
                this.code = key;
                break;
              }
            }
          };
          this.setErrno(errno);
          this.message = ERRNO_MESSAGES[errno];
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [ERRNO_CODES.ENOENT].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:function () {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
      },init:function (input, output, error) {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:function () {
        FS.init.initialized = false;
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:function (canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },joinPath:function (parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == '/') path = path.substr(1);
        return path;
      },absolutePath:function (relative, base) {
        return PATH.resolve(base, relative);
      },standardizePath:function (path) {
        return PATH.normalize(path);
      },findObject:function (path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          ___setErrNo(ret.error);
          return null;
        }
      },analyzePath:function (path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createFolder:function (parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode);
      },createPath:function (parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function (parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function (parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 'w');
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:function (parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },createLink:function (parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path);
      },forceLoadFile:function (obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (Module['read']) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(Module['read'](obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) ___setErrNo(ERRNO_CODES.EIO);
        return success;
      },createLazyFile:function (parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        }
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        }
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (function(from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(xhr.response || []);
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          });
          var lazyArray = this;
          lazyArray.setDataGetter(function(chunkNum) {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperty(lazyArray, "length", {
              get: function() {
                  if(!this.lengthKnown) {
                      this.cacheLength();
                  }
                  return this._length;
              }
          });
          Object.defineProperty(lazyArray, "chunkSize", {
              get: function() {
                  if(!this.lengthKnown) {
                      this.cacheLength();
                  }
                  return this._chunkSize;
              }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperty(node, "usedBytes", {
            get: function() { return this.contents.length; }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EIO);
          }
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
        Browser.init();
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency(dep);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },indexedDB:function () {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:function () {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          console.log('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};function _fflush(stream) {
      // int fflush(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fflush.html
  
      /*
      // Disabled, see https://github.com/kripken/emscripten/issues/2770
      stream = FS.getStreamFromPtr(stream);
      if (stream.stream_ops.flush) {
        stream.stream_ops.flush(stream);
      }
      */
    }

   
  Module["_strlen"] = _strlen;

  function _GetTitleGain() {
  Module['printErr']('missing function: GetTitleGain'); abort(-1);
  }

   
  Module["_i64Add"] = _i64Add;

  var _fabs=Math_abs;

  var _floor=Math_floor;

  var _sqrt=Math_sqrt;

  function _hip_set_errorf() {
  Module['printErr']('missing function: hip_set_errorf'); abort(-1);
  }

  var _llvm_pow_f32=Math_pow;

  
  
  function _emscripten_set_main_loop_timing(mode, value) {
      Browser.mainLoop.timingMode = mode;
      Browser.mainLoop.timingValue = value;
  
      if (!Browser.mainLoop.func) {
        return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.
      }
  
      if (mode == 0 /*EM_TIMING_SETTIMEOUT*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler() {
          setTimeout(Browser.mainLoop.runner, value); // doing this each time means that on exception, we stop
        };
        Browser.mainLoop.method = 'timeout';
      } else if (mode == 1 /*EM_TIMING_RAF*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler() {
          Browser.requestAnimationFrame(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'rAF';
      }
      return 0;
    }function _emscripten_set_main_loop(func, fps, simulateInfiniteLoop, arg, noSetTiming) {
      Module['noExitRuntime'] = true;
  
      assert(!Browser.mainLoop.func, 'emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.');
  
      Browser.mainLoop.func = func;
      Browser.mainLoop.arg = arg;
  
      var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;
  
      Browser.mainLoop.runner = function Browser_mainLoop_runner() {
        if (ABORT) return;
        if (Browser.mainLoop.queue.length > 0) {
          var start = Date.now();
          var blocker = Browser.mainLoop.queue.shift();
          blocker.func(blocker.arg);
          if (Browser.mainLoop.remainingBlockers) {
            var remaining = Browser.mainLoop.remainingBlockers;
            var next = remaining%1 == 0 ? remaining-1 : Math.floor(remaining);
            if (blocker.counted) {
              Browser.mainLoop.remainingBlockers = next;
            } else {
              // not counted, but move the progress along a tiny bit
              next = next + 0.5; // do not steal all the next one's progress
              Browser.mainLoop.remainingBlockers = (8*remaining + next)/9;
            }
          }
          console.log('main loop blocker "' + blocker.name + '" took ' + (Date.now() - start) + ' ms'); //, left: ' + Browser.mainLoop.remainingBlockers);
          Browser.mainLoop.updateStatus();
          setTimeout(Browser.mainLoop.runner, 0);
          return;
        }
  
        // catch pauses from non-main loop sources
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
        // Implement very basic swap interval control
        Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
        if (Browser.mainLoop.timingMode == 1/*EM_TIMING_RAF*/ && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
          // Not the scheduled time to render this frame - skip.
          Browser.mainLoop.scheduler();
          return;
        }
  
        // Signal GL rendering layer that processing of a new frame is about to start. This helps it optimize
        // VBO double-buffering and reduce GPU stalls.
  
        if (Browser.mainLoop.method === 'timeout' && Module.ctx) {
          Module.printErr('Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!');
          Browser.mainLoop.method = ''; // just warn once per call to set main loop
        }
  
        Browser.mainLoop.runIter(function() {
          if (typeof arg !== 'undefined') {
            Runtime.dynCall('vi', func, [arg]);
          } else {
            Runtime.dynCall('v', func);
          }
        });
  
        // catch pauses from the main loop itself
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
        // Queue new audio data. This is important to be right after the main loop invocation, so that we will immediately be able
        // to queue the newest produced audio samples.
        // TODO: Consider adding pre- and post- rAF callbacks so that GL.newRenderingFrameStarted() and SDL.audio.queueNewAudioData()
        //       do not need to be hardcoded into this function, but can be more generic.
        if (typeof SDL === 'object' && SDL.audio && SDL.audio.queueNewAudioData) SDL.audio.queueNewAudioData();
  
        Browser.mainLoop.scheduler();
      }
  
      if (!noSetTiming) {
        if (fps && fps > 0) _emscripten_set_main_loop_timing(0/*EM_TIMING_SETTIMEOUT*/, 1000.0 / fps);
        else _emscripten_set_main_loop_timing(1/*EM_TIMING_RAF*/, 1); // Do rAF by rendering each frame (no decimating)
  
        Browser.mainLoop.scheduler();
      }
  
      if (simulateInfiniteLoop) {
        throw 'SimulateInfiniteLoop';
      }
    }var Browser={mainLoop:{scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:function () {
          Browser.mainLoop.scheduler = null;
          Browser.mainLoop.currentlyRunningMainloop++; // Incrementing this signals the previous main loop that it's now become old, and it must return.
        },resume:function () {
          Browser.mainLoop.currentlyRunningMainloop++;
          var timingMode = Browser.mainLoop.timingMode;
          var timingValue = Browser.mainLoop.timingValue;
          var func = Browser.mainLoop.func;
          Browser.mainLoop.func = null;
          _emscripten_set_main_loop(func, 0, false, Browser.mainLoop.arg, true /* do not set timing and call scheduler, we will do it on the next lines */);
          _emscripten_set_main_loop_timing(timingMode, timingValue);
          Browser.mainLoop.scheduler();
        },updateStatus:function () {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        },runIter:function (func) {
          if (ABORT) return;
          if (Module['preMainLoop']) {
            var preRet = Module['preMainLoop']();
            if (preRet === false) {
              return; // |return false| skips a frame
            }
          }
          try {
            func();
          } catch (e) {
            if (e instanceof ExitStatus) {
              return;
            } else {
              if (e && typeof e === 'object' && e.stack) Module.printErr('exception thrown: ' + [e, e.stack]);
              throw e;
            }
          }
          if (Module['postMainLoop']) Module['postMainLoop']();
        }},isFullScreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function () {
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = []; // needs to exist even in workers
  
        if (Browser.initted) return;
        Browser.initted = true;
  
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : undefined;
        if (!Module.noImageDecoding && typeof Browser.URLObject === 'undefined') {
          console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");
          Module.noImageDecoding = true;
        }
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: Browser.getMimetype(name) });
              if (b.size !== byteArray.length) { // Safari bug #118630
                // Safari's Blob can only take an ArrayBuffer
                b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
              }
            } catch(e) {
              Runtime.warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          var img = new Image();
          img.onload = function img_onload() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function img_onerror(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function audio_onerror(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            Browser.safeSetTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);
  
        // Canvas event setup
  
        var canvas = Module['canvas'];
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === canvas ||
                                document['mozPointerLockElement'] === canvas ||
                                document['webkitPointerLockElement'] === canvas ||
                                document['msPointerLockElement'] === canvas;
        }
        if (canvas) {
          // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
          // Module['forcedAspectRatio'] = 4 / 3;
          
          canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                      canvas['mozRequestPointerLock'] ||
                                      canvas['webkitRequestPointerLock'] ||
                                      canvas['msRequestPointerLock'] ||
                                      function(){};
          canvas.exitPointerLock = document['exitPointerLock'] ||
                                   document['mozExitPointerLock'] ||
                                   document['webkitExitPointerLock'] ||
                                   document['msExitPointerLock'] ||
                                   function(){}; // no-op if function does not exist
          canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
  
  
          document.addEventListener('pointerlockchange', pointerLockChange, false);
          document.addEventListener('mozpointerlockchange', pointerLockChange, false);
          document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
          document.addEventListener('mspointerlockchange', pointerLockChange, false);
  
          if (Module['elementPointerLock']) {
            canvas.addEventListener("click", function(ev) {
              if (!Browser.pointerLock && canvas.requestPointerLock) {
                canvas.requestPointerLock();
                ev.preventDefault();
              }
            }, false);
          }
        }
      },createContext:function (canvas, useWebGL, setInModule, webGLContextAttributes) {
        if (useWebGL && Module.ctx && canvas == Module.canvas) return Module.ctx; // no need to recreate GL context if it's already been created for this canvas.
  
        var ctx;
        var contextHandle;
        if (useWebGL) {
          // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
          var contextAttributes = {
            antialias: false,
            alpha: false
          };
  
          if (webGLContextAttributes) {
            for (var attribute in webGLContextAttributes) {
              contextAttributes[attribute] = webGLContextAttributes[attribute];
            }
          }
  
          contextHandle = GL.createContext(canvas, contextAttributes);
          if (contextHandle) {
            ctx = GL.getContext(contextHandle).GLctx;
          }
          // Set the background of the WebGL canvas to black
          canvas.style.backgroundColor = "black";
        } else {
          ctx = canvas.getContext('2d');
        }
  
        if (!ctx) return null;
  
        if (setInModule) {
          if (!useWebGL) assert(typeof GLctx === 'undefined', 'cannot set in module if GLctx is used, but we are a non-GL context that would replace it');
  
          Module.ctx = ctx;
          if (useWebGL) GL.makeContextCurrent(contextHandle);
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
          Browser.init();
        }
        return ctx;
      },destroyContext:function (canvas, useWebGL, setInModule) {},fullScreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullScreen:function (lockPointer, resizeCanvas, vrDevice) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        Browser.vrDevice = vrDevice;
        if (typeof Browser.lockPointer === 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas === 'undefined') Browser.resizeCanvas = false;
        if (typeof Browser.vrDevice === 'undefined') Browser.vrDevice = null;
  
        var canvas = Module['canvas'];
        function fullScreenChange() {
          Browser.isFullScreen = false;
          var canvasContainer = canvas.parentNode;
          if ((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
               document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
               document['fullScreenElement'] || document['fullscreenElement'] ||
               document['msFullScreenElement'] || document['msFullscreenElement'] ||
               document['webkitCurrentFullScreenElement']) === canvasContainer) {
            canvas.cancelFullScreen = document['cancelFullScreen'] ||
                                      document['mozCancelFullScreen'] ||
                                      document['webkitCancelFullScreen'] ||
                                      document['msExitFullscreen'] ||
                                      document['exitFullscreen'] ||
                                      function() {};
            canvas.cancelFullScreen = canvas.cancelFullScreen.bind(document);
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullScreen = true;
            if (Browser.resizeCanvas) Browser.setFullScreenCanvasSize();
          } else {
            
            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
            canvasContainer.parentNode.removeChild(canvasContainer);
            
            if (Browser.resizeCanvas) Browser.setWindowedCanvasSize();
          }
          if (Module['onFullScreen']) Module['onFullScreen'](Browser.isFullScreen);
          Browser.updateCanvasDimensions(canvas);
        }
  
        if (!Browser.fullScreenHandlersInstalled) {
          Browser.fullScreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullScreenChange, false);
          document.addEventListener('mozfullscreenchange', fullScreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullScreenChange, false);
          document.addEventListener('MSFullscreenChange', fullScreenChange, false);
        }
  
        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvasContainer = document.createElement("div");
        canvas.parentNode.insertBefore(canvasContainer, canvas);
        canvasContainer.appendChild(canvas);
  
        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
        canvasContainer.requestFullScreen = canvasContainer['requestFullScreen'] ||
                                            canvasContainer['mozRequestFullScreen'] ||
                                            canvasContainer['msRequestFullscreen'] ||
                                           (canvasContainer['webkitRequestFullScreen'] ? function() { canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
  
        if (vrDevice) {
          canvasContainer.requestFullScreen({ vrDisplay: vrDevice });
        } else {
          canvasContainer.requestFullScreen();
        }
      },nextRAF:0,fakeRequestAnimationFrame:function (func) {
        // try to keep 60fps between calls to here
        var now = Date.now();
        if (Browser.nextRAF === 0) {
          Browser.nextRAF = now + 1000/60;
        } else {
          while (now + 2 >= Browser.nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0
            Browser.nextRAF += 1000/60;
          }
        }
        var delay = Math.max(Browser.nextRAF - now, 0);
        setTimeout(func, delay);
      },requestAnimationFrame:function requestAnimationFrame(func) {
        if (typeof window === 'undefined') { // Provide fallback to setTimeout if window is undefined (e.g. in Node.js)
          Browser.fakeRequestAnimationFrame(func);
        } else {
          if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = window['requestAnimationFrame'] ||
                                           window['mozRequestAnimationFrame'] ||
                                           window['webkitRequestAnimationFrame'] ||
                                           window['msRequestAnimationFrame'] ||
                                           window['oRequestAnimationFrame'] ||
                                           Browser.fakeRequestAnimationFrame;
          }
          window.requestAnimationFrame(func);
        }
      },safeCallback:function (func) {
        return function() {
          if (!ABORT) return func.apply(null, arguments);
        };
      },allowAsyncCallbacks:true,queuedAsyncCallbacks:[],pauseAsyncCallbacks:function () {
        Browser.allowAsyncCallbacks = false;
      },resumeAsyncCallbacks:function () { // marks future callbacks as ok to execute, and synchronously runs any remaining ones right now
        Browser.allowAsyncCallbacks = true;
        if (Browser.queuedAsyncCallbacks.length > 0) {
          var callbacks = Browser.queuedAsyncCallbacks;
          Browser.queuedAsyncCallbacks = [];
          callbacks.forEach(function(func) {
            func();
          });
        }
      },safeRequestAnimationFrame:function (func) {
        return Browser.requestAnimationFrame(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } else {
            Browser.queuedAsyncCallbacks.push(func);
          }
        });
      },safeSetTimeout:function (func, timeout) {
        Module['noExitRuntime'] = true;
        return setTimeout(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } else {
            Browser.queuedAsyncCallbacks.push(func);
          }
        }, timeout);
      },safeSetInterval:function (func, timeout) {
        Module['noExitRuntime'] = true;
        return setInterval(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } // drop it on the floor otherwise, next interval will kick in
        }, timeout);
      },getMimetype:function (name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },getUserMedia:function (func) {
        if(!window.getUserMedia) {
          window.getUserMedia = navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        }
        window.getUserMedia(func);
      },getMovementX:function (event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function (event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },getMouseWheelDelta:function (event) {
        var delta = 0;
        switch (event.type) {
          case 'DOMMouseScroll': 
            delta = event.detail;
            break;
          case 'mousewheel': 
            delta = event.wheelDelta;
            break;
          case 'wheel': 
            delta = event['deltaY'];
            break;
          default:
            throw 'unrecognized mouse wheel event: ' + event.type;
        }
        return delta;
      },mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function (event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }
          
          // check if SDL is available
          if (typeof SDL != "undefined") {
          	Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
          	Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
          } else {
          	// just add the mouse delta to the current absolut mouse position
          	// FIXME: ideally this should be clamped against the canvas size and zero
          	Browser.mouseX += Browser.mouseMovementX;
          	Browser.mouseY += Browser.mouseMovementY;
          }        
        } else {
          // Otherwise, calculate the movement based on the changes
          // in the coordinates.
          var rect = Module["canvas"].getBoundingClientRect();
          var cw = Module["canvas"].width;
          var ch = Module["canvas"].height;
  
          // Neither .scrollX or .pageXOffset are defined in a spec, but
          // we prefer .scrollX because it is currently in a spec draft.
          // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
          var scrollX = ((typeof window.scrollX !== 'undefined') ? window.scrollX : window.pageXOffset);
          var scrollY = ((typeof window.scrollY !== 'undefined') ? window.scrollY : window.pageYOffset);
  
          if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
            var touch = event.touch;
            if (touch === undefined) {
              return; // the "touch" property is only defined in SDL
  
            }
            var adjustedX = touch.pageX - (scrollX + rect.left);
            var adjustedY = touch.pageY - (scrollY + rect.top);
  
            adjustedX = adjustedX * (cw / rect.width);
            adjustedY = adjustedY * (ch / rect.height);
  
            var coords = { x: adjustedX, y: adjustedY };
            
            if (event.type === 'touchstart') {
              Browser.lastTouches[touch.identifier] = coords;
              Browser.touches[touch.identifier] = coords;
            } else if (event.type === 'touchend' || event.type === 'touchmove') {
              var last = Browser.touches[touch.identifier];
              if (!last) last = coords;
              Browser.lastTouches[touch.identifier] = last;
              Browser.touches[touch.identifier] = coords;
            } 
            return;
          }
  
          var x = event.pageX - (scrollX + rect.left);
          var y = event.pageY - (scrollY + rect.top);
  
          // the canvas might be CSS-scaled compared to its backbuffer;
          // SDL-using content will want mouse coordinates in terms
          // of backbuffer units.
          x = x * (cw / rect.width);
          y = y * (ch / rect.height);
  
          Browser.mouseMovementX = x - Browser.mouseX;
          Browser.mouseMovementY = y - Browser.mouseY;
          Browser.mouseX = x;
          Browser.mouseY = y;
        }
      },xhrLoad:function (url, onload, onerror) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function xhr_onload() {
          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
            onload(xhr.response);
          } else {
            onerror();
          }
        };
        xhr.onerror = onerror;
        xhr.send(null);
      },asyncLoad:function (url, onload, onerror, noRunDep) {
        Browser.xhrLoad(url, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          if (!noRunDep) removeRunDependency('al ' + url);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        });
        if (!noRunDep) addRunDependency('al ' + url);
      },resizeListeners:[],updateResizeListeners:function () {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function (width, height, noUpdates) {
        var canvas = Module['canvas'];
        Browser.updateCanvasDimensions(canvas, width, height);
        if (!noUpdates) Browser.updateResizeListeners();
      },windowedWidth:0,windowedHeight:0,setFullScreenCanvasSize:function () {
        // check if SDL is available   
        if (typeof SDL != "undefined") {
        	var flags = HEAPU32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)];
        	flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
        	HEAP32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)]=flags
        }
        Browser.updateResizeListeners();
      },setWindowedCanvasSize:function () {
        // check if SDL is available       
        if (typeof SDL != "undefined") {
        	var flags = HEAPU32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)];
        	flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
        	HEAP32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)]=flags
        }
        Browser.updateResizeListeners();
      },updateCanvasDimensions:function (canvas, wNative, hNative) {
        if (wNative && hNative) {
          canvas.widthNative = wNative;
          canvas.heightNative = hNative;
        } else {
          wNative = canvas.widthNative;
          hNative = canvas.heightNative;
        }
        var w = wNative;
        var h = hNative;
        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
          if (w/h < Module['forcedAspectRatio']) {
            w = Math.round(h * Module['forcedAspectRatio']);
          } else {
            h = Math.round(w / Module['forcedAspectRatio']);
          }
        }
        if (((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
             document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
             document['fullScreenElement'] || document['fullscreenElement'] ||
             document['msFullScreenElement'] || document['msFullscreenElement'] ||
             document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
           var factor = Math.min(screen.width / w, screen.height / h);
           w = Math.round(w * factor);
           h = Math.round(h * factor);
        }
        if (Browser.resizeCanvas) {
          if (canvas.width  != w) canvas.width  = w;
          if (canvas.height != h) canvas.height = h;
          if (typeof canvas.style != 'undefined') {
            canvas.style.removeProperty( "width");
            canvas.style.removeProperty("height");
          }
        } else {
          if (canvas.width  != wNative) canvas.width  = wNative;
          if (canvas.height != hNative) canvas.height = hNative;
          if (typeof canvas.style != 'undefined') {
            if (w != wNative || h != hNative) {
              canvas.style.setProperty( "width", w + "px", "important");
              canvas.style.setProperty("height", h + "px", "important");
            } else {
              canvas.style.removeProperty( "width");
              canvas.style.removeProperty("height");
            }
          }
        }
      },wgetRequests:{},nextWgetRequestHandle:0,getNextWgetRequestHandle:function () {
        var handle = Browser.nextWgetRequestHandle;
        Browser.nextWgetRequestHandle++;
        return handle;
      }};

  var _llvm_sqrt_f64=Math_sqrt;

  
  function __exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      Module['exit'](status);
    }function _exit(status) {
      __exit(status);
    }

  function _hip_decode_init() {
  Module['printErr']('missing function: hip_decode_init'); abort(-1);
  }

  function _hip_set_msgf() {
  Module['printErr']('missing function: hip_set_msgf'); abort(-1);
  }

  var _sin=Math_sin;

  function _sysconf(name) {
      // long sysconf(int name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
      switch(name) {
        case 30: return PAGE_SIZE;
        case 85: return totalMemory / PAGE_SIZE;
        case 132:
        case 133:
        case 12:
        case 137:
        case 138:
        case 15:
        case 235:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 149:
        case 13:
        case 10:
        case 236:
        case 153:
        case 9:
        case 21:
        case 22:
        case 159:
        case 154:
        case 14:
        case 77:
        case 78:
        case 139:
        case 80:
        case 81:
        case 82:
        case 68:
        case 67:
        case 164:
        case 11:
        case 29:
        case 47:
        case 48:
        case 95:
        case 52:
        case 51:
        case 46:
          return 200809;
        case 79:
          return 0;
        case 27:
        case 246:
        case 127:
        case 128:
        case 23:
        case 24:
        case 160:
        case 161:
        case 181:
        case 182:
        case 242:
        case 183:
        case 184:
        case 243:
        case 244:
        case 245:
        case 165:
        case 178:
        case 179:
        case 49:
        case 50:
        case 168:
        case 169:
        case 175:
        case 170:
        case 171:
        case 172:
        case 97:
        case 76:
        case 32:
        case 173:
        case 35:
          return -1;
        case 176:
        case 177:
        case 7:
        case 155:
        case 8:
        case 157:
        case 125:
        case 126:
        case 92:
        case 93:
        case 129:
        case 130:
        case 131:
        case 94:
        case 91:
          return 1;
        case 74:
        case 60:
        case 69:
        case 70:
        case 4:
          return 1024;
        case 31:
        case 42:
        case 72:
          return 32;
        case 87:
        case 26:
        case 33:
          return 2147483647;
        case 34:
        case 1:
          return 47839;
        case 38:
        case 36:
          return 99;
        case 43:
        case 37:
          return 2048;
        case 0: return 2097152;
        case 3: return 65536;
        case 28: return 32768;
        case 44: return 32767;
        case 75: return 16384;
        case 39: return 1000;
        case 89: return 700;
        case 71: return 256;
        case 40: return 255;
        case 2: return 100;
        case 180: return 64;
        case 25: return 20;
        case 5: return 16;
        case 6: return 6;
        case 73: return 4;
        case 84: {
          if (typeof navigator === 'object') return navigator['hardwareConcurrency'] || 1;
          return 1;
        }
      }
      ___setErrNo(ERRNO_CODES.EINVAL);
      return -1;
    }

   
  Module["_bitshift64Lshr"] = _bitshift64Lshr;

  function _hip_decode_exit() {
  Module['printErr']('missing function: hip_decode_exit'); abort(-1);
  }

  var _atan=Math_atan;

  var _BDtoIHigh=true;

  var _ceil=Math_ceil;

  
  
  
  
  
  
  function _mkport() { throw 'TODO' }var SOCKFS={mount:function (mount) {
        // If Module['websocket'] has already been defined (e.g. for configuring
        // the subprotocol/url) use that, if not initialise it to a new object.
        Module['websocket'] = (Module['websocket'] && 
                               ('object' === typeof Module['websocket'])) ? Module['websocket'] : {};
  
        // Add the Event registration mechanism to the exported websocket configuration
        // object so we can register network callbacks from native JavaScript too.
        // For more documentation see system/include/emscripten/emscripten.h
        Module['websocket']._callbacks = {};
        Module['websocket']['on'] = function(event, callback) {
  	    if ('function' === typeof callback) {
  		  this._callbacks[event] = callback;
          }
  	    return this;
        };
  
        Module['websocket'].emit = function(event, param) {
  	    if ('function' === typeof this._callbacks[event]) {
  		  this._callbacks[event].call(this, param);
          }
        };
  
        // If debug is enabled register simple default logging callbacks for each Event.
  
        return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createSocket:function (family, type, protocol) {
        var streaming = type == 1;
        if (protocol) {
          assert(streaming == (protocol == 6)); // if SOCK_STREAM, must be tcp
        }
  
        // create our internal socket structure
        var sock = {
          family: family,
          type: type,
          protocol: protocol,
          server: null,
          error: null, // Used in getsockopt for SOL_SOCKET/SO_ERROR test
          peers: {},
          pending: [],
          recv_queue: [],
          sock_ops: SOCKFS.websocket_sock_ops
        };
  
        // create the filesystem node to store the socket structure
        var name = SOCKFS.nextname();
        var node = FS.createNode(SOCKFS.root, name, 49152, 0);
        node.sock = sock;
  
        // and the wrapping stream that enables library functions such
        // as read and write to indirectly interact with the socket
        var stream = FS.createStream({
          path: name,
          node: node,
          flags: FS.modeStringToFlags('r+'),
          seekable: false,
          stream_ops: SOCKFS.stream_ops
        });
  
        // map the new stream to the socket structure (sockets have a 1:1
        // relationship with a stream)
        sock.stream = stream;
  
        return sock;
      },getSocket:function (fd) {
        var stream = FS.getStream(fd);
        if (!stream || !FS.isSocket(stream.node.mode)) {
          return null;
        }
        return stream.node.sock;
      },stream_ops:{poll:function (stream) {
          var sock = stream.node.sock;
          return sock.sock_ops.poll(sock);
        },ioctl:function (stream, request, varargs) {
          var sock = stream.node.sock;
          return sock.sock_ops.ioctl(sock, request, varargs);
        },read:function (stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          var msg = sock.sock_ops.recvmsg(sock, length);
          if (!msg) {
            // socket is closed
            return 0;
          }
          buffer.set(msg.buffer, offset);
          return msg.buffer.length;
        },write:function (stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          return sock.sock_ops.sendmsg(sock, buffer, offset, length);
        },close:function (stream) {
          var sock = stream.node.sock;
          sock.sock_ops.close(sock);
        }},nextname:function () {
        if (!SOCKFS.nextname.current) {
          SOCKFS.nextname.current = 0;
        }
        return 'socket[' + (SOCKFS.nextname.current++) + ']';
      },websocket_sock_ops:{createPeer:function (sock, addr, port) {
          var ws;
  
          if (typeof addr === 'object') {
            ws = addr;
            addr = null;
            port = null;
          }
  
          if (ws) {
            // for sockets that've already connected (e.g. we're the server)
            // we can inspect the _socket property for the address
            if (ws._socket) {
              addr = ws._socket.remoteAddress;
              port = ws._socket.remotePort;
            }
            // if we're just now initializing a connection to the remote,
            // inspect the url property
            else {
              var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
              if (!result) {
                throw new Error('WebSocket URL must be in the format ws(s)://address:port');
              }
              addr = result[1];
              port = parseInt(result[2], 10);
            }
          } else {
            // create the actual websocket object and connect
            try {
              // runtimeConfig gets set to true if WebSocket runtime configuration is available.
              var runtimeConfig = (Module['websocket'] && ('object' === typeof Module['websocket']));
  
              // The default value is 'ws://' the replace is needed because the compiler replaces '//' comments with '#'
              // comments without checking context, so we'd end up with ws:#, the replace swaps the '#' for '//' again.
              var url = 'ws:#'.replace('#', '//');
  
              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['url']) {
                  url = Module['websocket']['url']; // Fetch runtime WebSocket URL config.
                }
              }
  
              if (url === 'ws://' || url === 'wss://') { // Is the supplied URL config just a prefix, if so complete it.
                var parts = addr.split('/');
                url = url + parts[0] + ":" + port + "/" + parts.slice(1).join('/');
              }
  
              // Make the WebSocket subprotocol (Sec-WebSocket-Protocol) default to binary if no configuration is set.
              var subProtocols = 'binary'; // The default value is 'binary'
  
              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['subprotocol']) {
                  subProtocols = Module['websocket']['subprotocol']; // Fetch runtime WebSocket subprotocol config.
                }
              }
  
              // The regex trims the string (removes spaces at the beginning and end, then splits the string by
              // <any space>,<any space> into an Array. Whitespace removal is important for Websockify and ws.
              subProtocols = subProtocols.replace(/^ +| +$/g,"").split(/ *, */);
  
              // The node ws library API for specifying optional subprotocol is slightly different than the browser's.
              var opts = ENVIRONMENT_IS_NODE ? {'protocol': subProtocols.toString()} : subProtocols;
  
              // If node we use the ws library.
              var WebSocket = ENVIRONMENT_IS_NODE ? require('ws') : window['WebSocket'];
              ws = new WebSocket(url, opts);
              ws.binaryType = 'arraybuffer';
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EHOSTUNREACH);
            }
          }
  
  
          var peer = {
            addr: addr,
            port: port,
            socket: ws,
            dgram_send_queue: []
          };
  
          SOCKFS.websocket_sock_ops.addPeer(sock, peer);
          SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
  
          // if this is a bound dgram socket, send the port number first to allow
          // us to override the ephemeral port reported to us by remotePort on the
          // remote end.
          if (sock.type === 2 && typeof sock.sport !== 'undefined') {
            peer.dgram_send_queue.push(new Uint8Array([
                255, 255, 255, 255,
                'p'.charCodeAt(0), 'o'.charCodeAt(0), 'r'.charCodeAt(0), 't'.charCodeAt(0),
                ((sock.sport & 0xff00) >> 8) , (sock.sport & 0xff)
            ]));
          }
  
          return peer;
        },getPeer:function (sock, addr, port) {
          return sock.peers[addr + ':' + port];
        },addPeer:function (sock, peer) {
          sock.peers[peer.addr + ':' + peer.port] = peer;
        },removePeer:function (sock, peer) {
          delete sock.peers[peer.addr + ':' + peer.port];
        },handlePeerEvents:function (sock, peer) {
          var first = true;
  
          var handleOpen = function () {
  
            Module['websocket'].emit('open', sock.stream.fd);
  
            try {
              var queued = peer.dgram_send_queue.shift();
              while (queued) {
                peer.socket.send(queued);
                queued = peer.dgram_send_queue.shift();
              }
            } catch (e) {
              // not much we can do here in the way of proper error handling as we've already
              // lied and said this data was sent. shut it down.
              peer.socket.close();
            }
          };
  
          function handleMessage(data) {
            assert(typeof data !== 'string' && data.byteLength !== undefined);  // must receive an ArrayBuffer
            data = new Uint8Array(data);  // make a typed array view on the array buffer
  
  
            // if this is the port message, override the peer's port with it
            var wasfirst = first;
            first = false;
            if (wasfirst &&
                data.length === 10 &&
                data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 &&
                data[4] === 'p'.charCodeAt(0) && data[5] === 'o'.charCodeAt(0) && data[6] === 'r'.charCodeAt(0) && data[7] === 't'.charCodeAt(0)) {
              // update the peer's port and it's key in the peer map
              var newport = ((data[8] << 8) | data[9]);
              SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              peer.port = newport;
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              return;
            }
  
            sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data });
            Module['websocket'].emit('message', sock.stream.fd);
          };
  
          if (ENVIRONMENT_IS_NODE) {
            peer.socket.on('open', handleOpen);
            peer.socket.on('message', function(data, flags) {
              if (!flags.binary) {
                return;
              }
              handleMessage((new Uint8Array(data)).buffer);  // copy from node Buffer -> ArrayBuffer
            });
            peer.socket.on('close', function() {
              Module['websocket'].emit('close', sock.stream.fd);
            });
            peer.socket.on('error', function(error) {
              // Although the ws library may pass errors that may be more descriptive than
              // ECONNREFUSED they are not necessarily the expected error code e.g. 
              // ENOTFOUND on getaddrinfo seems to be node.js specific, so using ECONNREFUSED
              // is still probably the most useful thing to do.
              sock.error = ERRNO_CODES.ECONNREFUSED; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
              // don't throw
            });
          } else {
            peer.socket.onopen = handleOpen;
            peer.socket.onclose = function() {
              Module['websocket'].emit('close', sock.stream.fd);
            };
            peer.socket.onmessage = function peer_socket_onmessage(event) {
              handleMessage(event.data);
            };
            peer.socket.onerror = function(error) {
              // The WebSocket spec only allows a 'simple event' to be thrown on error,
              // so we only really know as much as ECONNREFUSED.
              sock.error = ERRNO_CODES.ECONNREFUSED; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
            };
          }
        },poll:function (sock) {
          if (sock.type === 1 && sock.server) {
            // listen sockets should only say they're available for reading
            // if there are pending clients.
            return sock.pending.length ? (64 | 1) : 0;
          }
  
          var mask = 0;
          var dest = sock.type === 1 ?  // we only care about the socket state for connection-based sockets
            SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) :
            null;
  
          if (sock.recv_queue.length ||
              !dest ||  // connection-less sockets are always ready to read
              (dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {  // let recv return 0 once closed
            mask |= (64 | 1);
          }
  
          if (!dest ||  // connection-less sockets are always ready to write
              (dest && dest.socket.readyState === dest.socket.OPEN)) {
            mask |= 4;
          }
  
          if ((dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {
            mask |= 16;
          }
  
          return mask;
        },ioctl:function (sock, request, arg) {
          switch (request) {
            case 21531:
              var bytes = 0;
              if (sock.recv_queue.length) {
                bytes = sock.recv_queue[0].data.length;
              }
              HEAP32[((arg)>>2)]=bytes;
              return 0;
            default:
              return ERRNO_CODES.EINVAL;
          }
        },close:function (sock) {
          // if we've spawned a listen server, close it
          if (sock.server) {
            try {
              sock.server.close();
            } catch (e) {
            }
            sock.server = null;
          }
          // close any peer connections
          var peers = Object.keys(sock.peers);
          for (var i = 0; i < peers.length; i++) {
            var peer = sock.peers[peers[i]];
            try {
              peer.socket.close();
            } catch (e) {
            }
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
          }
          return 0;
        },bind:function (sock, addr, port) {
          if (typeof sock.saddr !== 'undefined' || typeof sock.sport !== 'undefined') {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already bound
          }
          sock.saddr = addr;
          sock.sport = port || _mkport();
          // in order to emulate dgram sockets, we need to launch a listen server when
          // binding on a connection-less socket
          // note: this is only required on the server side
          if (sock.type === 2) {
            // close the existing server if it exists
            if (sock.server) {
              sock.server.close();
              sock.server = null;
            }
            // swallow error operation not supported error that occurs when binding in the
            // browser where this isn't supported
            try {
              sock.sock_ops.listen(sock, 0);
            } catch (e) {
              if (!(e instanceof FS.ErrnoError)) throw e;
              if (e.errno !== ERRNO_CODES.EOPNOTSUPP) throw e;
            }
          }
        },connect:function (sock, addr, port) {
          if (sock.server) {
            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
          }
  
          // TODO autobind
          // if (!sock.addr && sock.type == 2) {
          // }
  
          // early out if we're already connected / in the middle of connecting
          if (typeof sock.daddr !== 'undefined' && typeof sock.dport !== 'undefined') {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (dest) {
              if (dest.socket.readyState === dest.socket.CONNECTING) {
                throw new FS.ErrnoError(ERRNO_CODES.EALREADY);
              } else {
                throw new FS.ErrnoError(ERRNO_CODES.EISCONN);
              }
            }
          }
  
          // add the socket to our peer list and set our
          // destination address / port to match
          var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
          sock.daddr = peer.addr;
          sock.dport = peer.port;
  
          // always "fail" in non-blocking mode
          throw new FS.ErrnoError(ERRNO_CODES.EINPROGRESS);
        },listen:function (sock, backlog) {
          if (!ENVIRONMENT_IS_NODE) {
            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
          }
          if (sock.server) {
             throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already listening
          }
          var WebSocketServer = require('ws').Server;
          var host = sock.saddr;
          sock.server = new WebSocketServer({
            host: host,
            port: sock.sport
            // TODO support backlog
          });
          Module['websocket'].emit('listen', sock.stream.fd); // Send Event with listen fd.
  
          sock.server.on('connection', function(ws) {
            if (sock.type === 1) {
              var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
  
              // create a peer on the new socket
              var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
              newsock.daddr = peer.addr;
              newsock.dport = peer.port;
  
              // push to queue for accept to pick up
              sock.pending.push(newsock);
              Module['websocket'].emit('connection', newsock.stream.fd);
            } else {
              // create a peer on the listen socket so calling sendto
              // with the listen socket and an address will resolve
              // to the correct client
              SOCKFS.websocket_sock_ops.createPeer(sock, ws);
              Module['websocket'].emit('connection', sock.stream.fd);
            }
          });
          sock.server.on('closed', function() {
            Module['websocket'].emit('close', sock.stream.fd);
            sock.server = null;
          });
          sock.server.on('error', function(error) {
            // Although the ws library may pass errors that may be more descriptive than
            // ECONNREFUSED they are not necessarily the expected error code e.g. 
            // ENOTFOUND on getaddrinfo seems to be node.js specific, so using EHOSTUNREACH
            // is still probably the most useful thing to do. This error shouldn't
            // occur in a well written app as errors should get trapped in the compiled
            // app's own getaddrinfo call.
            sock.error = ERRNO_CODES.EHOSTUNREACH; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
            Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'EHOSTUNREACH: Host is unreachable']);
            // don't throw
          });
        },accept:function (listensock) {
          if (!listensock.server) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          var newsock = listensock.pending.shift();
          newsock.stream.flags = listensock.stream.flags;
          return newsock;
        },getname:function (sock, peer) {
          var addr, port;
          if (peer) {
            if (sock.daddr === undefined || sock.dport === undefined) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
            }
            addr = sock.daddr;
            port = sock.dport;
          } else {
            // TODO saddr and sport will be set for bind()'d UDP sockets, but what
            // should we be returning for TCP sockets that've been connect()'d?
            addr = sock.saddr || 0;
            port = sock.sport || 0;
          }
          return { addr: addr, port: port };
        },sendmsg:function (sock, buffer, offset, length, addr, port) {
          if (sock.type === 2) {
            // connection-less sockets will honor the message address,
            // and otherwise fall back to the bound destination address
            if (addr === undefined || port === undefined) {
              addr = sock.daddr;
              port = sock.dport;
            }
            // if there was no address to fall back to, error out
            if (addr === undefined || port === undefined) {
              throw new FS.ErrnoError(ERRNO_CODES.EDESTADDRREQ);
            }
          } else {
            // connection-based sockets will only use the bound
            addr = sock.daddr;
            port = sock.dport;
          }
  
          // find the peer for the destination address
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
  
          // early out if not connected with a connection-based socket
          if (sock.type === 1) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
            } else if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
          }
  
          // create a copy of the incoming data to send, as the WebSocket API
          // doesn't work entirely with an ArrayBufferView, it'll just send
          // the entire underlying buffer
          var data;
          if (buffer instanceof Array || buffer instanceof ArrayBuffer) {
            data = buffer.slice(offset, offset + length);
          } else {  // ArrayBufferView
            data = buffer.buffer.slice(buffer.byteOffset + offset, buffer.byteOffset + offset + length);
          }
  
          // if we're emulating a connection-less dgram socket and don't have
          // a cached connection, queue the buffer to send upon connect and
          // lie, saying the data was sent now.
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
              // if we're not connected, open a new connection
              if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
              }
              dest.dgram_send_queue.push(data);
              return length;
            }
          }
  
          try {
            // send the actual data
            dest.socket.send(data);
            return length;
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
        },recvmsg:function (sock, length) {
          // http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
          if (sock.type === 1 && sock.server) {
            // tcp servers should not be recv()'ing on the listen socket
            throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
          }
  
          var queued = sock.recv_queue.shift();
          if (!queued) {
            if (sock.type === 1) {
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
  
              if (!dest) {
                // if we have a destination address but are not connected, error out
                throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
              }
              else if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                // return null if the socket has closed
                return null;
              }
              else {
                // else, our socket is in a valid state but truly has nothing available
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
            } else {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
          }
  
          // queued.data will be an ArrayBuffer if it's unadulterated, but if it's
          // requeued TCP data it'll be an ArrayBufferView
          var queuedLength = queued.data.byteLength || queued.data.length;
          var queuedOffset = queued.data.byteOffset || 0;
          var queuedBuffer = queued.data.buffer || queued.data;
          var bytesRead = Math.min(length, queuedLength);
          var res = {
            buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
            addr: queued.addr,
            port: queued.port
          };
  
  
          // push back any unread data for TCP connections
          if (sock.type === 1 && bytesRead < queuedLength) {
            var bytesRemaining = queuedLength - bytesRead;
            queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
            sock.recv_queue.unshift(queued);
          }
  
          return res;
        }}};function _send(fd, buf, len, flags) {
      var sock = SOCKFS.getSocket(fd);
      if (!sock) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      // TODO honor flags
      return _write(fd, buf, len);
    }
  
  function _pwrite(fildes, buf, nbyte, offset) {
      // ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        var slab = HEAP8;
        return FS.write(stream, slab, buf, nbyte, offset);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _write(fildes, buf, nbyte) {
      // ssize_t write(int fildes, const void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
  
  
      try {
        var slab = HEAP8;
        return FS.write(stream, slab, buf, nbyte);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }
  
  function _fileno(stream) {
      // int fileno(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fileno.html
      stream = FS.getStreamFromPtr(stream);
      if (!stream) return -1;
      return stream.fd;
    }function _fwrite(ptr, size, nitems, stream) {
      // size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fwrite.html
      var bytesToWrite = nitems * size;
      if (bytesToWrite == 0) return 0;
      var fd = _fileno(stream);
      var bytesWritten = _write(fd, ptr, bytesToWrite);
      if (bytesWritten == -1) {
        var streamObj = FS.getStreamFromPtr(stream);
        if (streamObj) streamObj.error = true;
        return 0;
      } else {
        return (bytesWritten / size)|0;
      }
    }
  
  
  function __reallyNegative(x) {
      return x < 0 || (x === 0 && (1/x) === -Infinity);
    }function __formatString(format, varargs) {
      assert((varargs & 3) === 0);
      var textIndex = format;
      var argIndex = 0;
      function getNextArg(type) {
        // NOTE: Explicitly ignoring type safety. Otherwise this fails:
        //       int x = 4; printf("%c\n", (char)x);
        var ret;
        argIndex = Runtime.prepVararg(argIndex, type);
        if (type === 'double') {
          ret = (HEAP32[((tempDoublePtr)>>2)]=HEAP32[(((varargs)+(argIndex))>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[(((varargs)+((argIndex)+(4)))>>2)],(+(HEAPF64[(tempDoublePtr)>>3])));
          argIndex += 8;
        } else if (type == 'i64') {
          ret = [HEAP32[(((varargs)+(argIndex))>>2)],
                 HEAP32[(((varargs)+(argIndex+4))>>2)]];
  
          argIndex += 8;
        } else {
          assert((argIndex & 3) === 0);
          type = 'i32'; // varargs are always i32, i64, or double
          ret = HEAP32[(((varargs)+(argIndex))>>2)];
          argIndex += 4;
        }
        return ret;
      }
  
      var ret = [];
      var curr, next, currArg;
      while(1) {
        var startTextIndex = textIndex;
        curr = HEAP8[((textIndex)>>0)];
        if (curr === 0) break;
        next = HEAP8[((textIndex+1)>>0)];
        if (curr == 37) {
          // Handle flags.
          var flagAlwaysSigned = false;
          var flagLeftAlign = false;
          var flagAlternative = false;
          var flagZeroPad = false;
          var flagPadSign = false;
          flagsLoop: while (1) {
            switch (next) {
              case 43:
                flagAlwaysSigned = true;
                break;
              case 45:
                flagLeftAlign = true;
                break;
              case 35:
                flagAlternative = true;
                break;
              case 48:
                if (flagZeroPad) {
                  break flagsLoop;
                } else {
                  flagZeroPad = true;
                  break;
                }
              case 32:
                flagPadSign = true;
                break;
              default:
                break flagsLoop;
            }
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
          }
  
          // Handle width.
          var width = 0;
          if (next == 42) {
            width = getNextArg('i32');
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
          } else {
            while (next >= 48 && next <= 57) {
              width = width * 10 + (next - 48);
              textIndex++;
              next = HEAP8[((textIndex+1)>>0)];
            }
          }
  
          // Handle precision.
          var precisionSet = false, precision = -1;
          if (next == 46) {
            precision = 0;
            precisionSet = true;
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
            if (next == 42) {
              precision = getNextArg('i32');
              textIndex++;
            } else {
              while(1) {
                var precisionChr = HEAP8[((textIndex+1)>>0)];
                if (precisionChr < 48 ||
                    precisionChr > 57) break;
                precision = precision * 10 + (precisionChr - 48);
                textIndex++;
              }
            }
            next = HEAP8[((textIndex+1)>>0)];
          }
          if (precision < 0) {
            precision = 6; // Standard default.
            precisionSet = false;
          }
  
          // Handle integer sizes. WARNING: These assume a 32-bit architecture!
          var argSize;
          switch (String.fromCharCode(next)) {
            case 'h':
              var nextNext = HEAP8[((textIndex+2)>>0)];
              if (nextNext == 104) {
                textIndex++;
                argSize = 1; // char (actually i32 in varargs)
              } else {
                argSize = 2; // short (actually i32 in varargs)
              }
              break;
            case 'l':
              var nextNext = HEAP8[((textIndex+2)>>0)];
              if (nextNext == 108) {
                textIndex++;
                argSize = 8; // long long
              } else {
                argSize = 4; // long
              }
              break;
            case 'L': // long long
            case 'q': // int64_t
            case 'j': // intmax_t
              argSize = 8;
              break;
            case 'z': // size_t
            case 't': // ptrdiff_t
            case 'I': // signed ptrdiff_t or unsigned size_t
              argSize = 4;
              break;
            default:
              argSize = null;
          }
          if (argSize) textIndex++;
          next = HEAP8[((textIndex+1)>>0)];
  
          // Handle type specifier.
          switch (String.fromCharCode(next)) {
            case 'd': case 'i': case 'u': case 'o': case 'x': case 'X': case 'p': {
              // Integer.
              var signed = next == 100 || next == 105;
              argSize = argSize || 4;
              var currArg = getNextArg('i' + (argSize * 8));
              var origArg = currArg;
              var argText;
              // Flatten i64-1 [low, high] into a (slightly rounded) double
              if (argSize == 8) {
                currArg = Runtime.makeBigInt(currArg[0], currArg[1], next == 117);
              }
              // Truncate to requested size.
              if (argSize <= 4) {
                var limit = Math.pow(256, argSize) - 1;
                currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
              }
              // Format the number.
              var currAbsArg = Math.abs(currArg);
              var prefix = '';
              if (next == 100 || next == 105) {
                if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], null); else
                argText = reSign(currArg, 8 * argSize, 1).toString(10);
              } else if (next == 117) {
                if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], true); else
                argText = unSign(currArg, 8 * argSize, 1).toString(10);
                currArg = Math.abs(currArg);
              } else if (next == 111) {
                argText = (flagAlternative ? '0' : '') + currAbsArg.toString(8);
              } else if (next == 120 || next == 88) {
                prefix = (flagAlternative && currArg != 0) ? '0x' : '';
                if (argSize == 8 && i64Math) {
                  if (origArg[1]) {
                    argText = (origArg[1]>>>0).toString(16);
                    var lower = (origArg[0]>>>0).toString(16);
                    while (lower.length < 8) lower = '0' + lower;
                    argText += lower;
                  } else {
                    argText = (origArg[0]>>>0).toString(16);
                  }
                } else
                if (currArg < 0) {
                  // Represent negative numbers in hex as 2's complement.
                  currArg = -currArg;
                  argText = (currAbsArg - 1).toString(16);
                  var buffer = [];
                  for (var i = 0; i < argText.length; i++) {
                    buffer.push((0xF - parseInt(argText[i], 16)).toString(16));
                  }
                  argText = buffer.join('');
                  while (argText.length < argSize * 2) argText = 'f' + argText;
                } else {
                  argText = currAbsArg.toString(16);
                }
                if (next == 88) {
                  prefix = prefix.toUpperCase();
                  argText = argText.toUpperCase();
                }
              } else if (next == 112) {
                if (currAbsArg === 0) {
                  argText = '(nil)';
                } else {
                  prefix = '0x';
                  argText = currAbsArg.toString(16);
                }
              }
              if (precisionSet) {
                while (argText.length < precision) {
                  argText = '0' + argText;
                }
              }
  
              // Add sign if needed
              if (currArg >= 0) {
                if (flagAlwaysSigned) {
                  prefix = '+' + prefix;
                } else if (flagPadSign) {
                  prefix = ' ' + prefix;
                }
              }
  
              // Move sign to prefix so we zero-pad after the sign
              if (argText.charAt(0) == '-') {
                prefix = '-' + prefix;
                argText = argText.substr(1);
              }
  
              // Add padding.
              while (prefix.length + argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad) {
                    argText = '0' + argText;
                  } else {
                    prefix = ' ' + prefix;
                  }
                }
              }
  
              // Insert the result into the buffer.
              argText = prefix + argText;
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 'f': case 'F': case 'e': case 'E': case 'g': case 'G': {
              // Float.
              var currArg = getNextArg('double');
              var argText;
              if (isNaN(currArg)) {
                argText = 'nan';
                flagZeroPad = false;
              } else if (!isFinite(currArg)) {
                argText = (currArg < 0 ? '-' : '') + 'inf';
                flagZeroPad = false;
              } else {
                var isGeneral = false;
                var effectivePrecision = Math.min(precision, 20);
  
                // Convert g/G to f/F or e/E, as per:
                // http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
                if (next == 103 || next == 71) {
                  isGeneral = true;
                  precision = precision || 1;
                  var exponent = parseInt(currArg.toExponential(effectivePrecision).split('e')[1], 10);
                  if (precision > exponent && exponent >= -4) {
                    next = ((next == 103) ? 'f' : 'F').charCodeAt(0);
                    precision -= exponent + 1;
                  } else {
                    next = ((next == 103) ? 'e' : 'E').charCodeAt(0);
                    precision--;
                  }
                  effectivePrecision = Math.min(precision, 20);
                }
  
                if (next == 101 || next == 69) {
                  argText = currArg.toExponential(effectivePrecision);
                  // Make sure the exponent has at least 2 digits.
                  if (/[eE][-+]\d$/.test(argText)) {
                    argText = argText.slice(0, -1) + '0' + argText.slice(-1);
                  }
                } else if (next == 102 || next == 70) {
                  argText = currArg.toFixed(effectivePrecision);
                  if (currArg === 0 && __reallyNegative(currArg)) {
                    argText = '-' + argText;
                  }
                }
  
                var parts = argText.split('e');
                if (isGeneral && !flagAlternative) {
                  // Discard trailing zeros and periods.
                  while (parts[0].length > 1 && parts[0].indexOf('.') != -1 &&
                         (parts[0].slice(-1) == '0' || parts[0].slice(-1) == '.')) {
                    parts[0] = parts[0].slice(0, -1);
                  }
                } else {
                  // Make sure we have a period in alternative mode.
                  if (flagAlternative && argText.indexOf('.') == -1) parts[0] += '.';
                  // Zero pad until required precision.
                  while (precision > effectivePrecision++) parts[0] += '0';
                }
                argText = parts[0] + (parts.length > 1 ? 'e' + parts[1] : '');
  
                // Capitalize 'E' if needed.
                if (next == 69) argText = argText.toUpperCase();
  
                // Add sign.
                if (currArg >= 0) {
                  if (flagAlwaysSigned) {
                    argText = '+' + argText;
                  } else if (flagPadSign) {
                    argText = ' ' + argText;
                  }
                }
              }
  
              // Add padding.
              while (argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad && (argText[0] == '-' || argText[0] == '+')) {
                    argText = argText[0] + '0' + argText.slice(1);
                  } else {
                    argText = (flagZeroPad ? '0' : ' ') + argText;
                  }
                }
              }
  
              // Adjust case.
              if (next < 97) argText = argText.toUpperCase();
  
              // Insert the result into the buffer.
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 's': {
              // String.
              var arg = getNextArg('i8*');
              var argLength = arg ? _strlen(arg) : '(null)'.length;
              if (precisionSet) argLength = Math.min(argLength, precision);
              if (!flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              if (arg) {
                for (var i = 0; i < argLength; i++) {
                  ret.push(HEAPU8[((arg++)>>0)]);
                }
              } else {
                ret = ret.concat(intArrayFromString('(null)'.substr(0, argLength), true));
              }
              if (flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              break;
            }
            case 'c': {
              // Character.
              if (flagLeftAlign) ret.push(getNextArg('i8'));
              while (--width > 0) {
                ret.push(32);
              }
              if (!flagLeftAlign) ret.push(getNextArg('i8'));
              break;
            }
            case 'n': {
              // Write the length written so far to the next parameter.
              var ptr = getNextArg('i32*');
              HEAP32[((ptr)>>2)]=ret.length;
              break;
            }
            case '%': {
              // Literal percent sign.
              ret.push(curr);
              break;
            }
            default: {
              // Unknown specifiers remain untouched.
              for (var i = startTextIndex; i < textIndex + 2; i++) {
                ret.push(HEAP8[((i)>>0)]);
              }
            }
          }
          textIndex += 2;
          // TODO: Support a/A (hex float) and m (last error) specifiers.
          // TODO: Support %1${specifier} for arg selection.
        } else {
          ret.push(curr);
          textIndex += 1;
        }
      }
      return ret;
    }function _fprintf(stream, format, varargs) {
      // int fprintf(FILE *restrict stream, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var result = __formatString(format, varargs);
      var stack = Runtime.stackSave();
      var ret = _fwrite(allocate(result, 'i8', ALLOC_STACK), 1, result.length, stream);
      Runtime.stackRestore(stack);
      return ret;
    }function _vfprintf(s, f, va_arg) {
      return _fprintf(s, f, HEAP32[((va_arg)>>2)]);
    }

  
  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);
      return dest;
    } 
  Module["_memcpy"] = _memcpy;

  var _log=Math_log;

  var _cos=Math_cos;

  var _llvm_pow_f64=Math_pow;

  function _sbrk(bytes) {
      // Implement a Linux-like 'memory area' for our 'process'.
      // Changes the size of the memory area by |bytes|; returns the
      // address of the previous top ('break') of the memory area
      // We control the "dynamic" memory - DYNAMIC_BASE to DYNAMICTOP
      var self = _sbrk;
      if (!self.called) {
        DYNAMICTOP = alignMemoryPage(DYNAMICTOP); // make sure we start out aligned
        self.called = true;
        assert(Runtime.dynamicAlloc);
        self.alloc = Runtime.dynamicAlloc;
        Runtime.dynamicAlloc = function() { abort('cannot dynamically allocate, sbrk now has control') };
      }
      var ret = DYNAMICTOP;
      if (bytes != 0) {
        var success = self.alloc(bytes);
        if (!success) return -1 >>> 0; // sbrk failure code
      }
      return ret;  // Previous break location.
    }

   
  Module["_bitshift64Shl"] = _bitshift64Shl;

  function ___errno_location() {
      return ___errno_state;
    }

  var _BItoD=true;

  function _hip_set_debugf() {
  Module['printErr']('missing function: hip_set_debugf'); abort(-1);
  }

  var _exp=Math_exp;

  function _time(ptr) {
      var ret = (Date.now()/1000)|0;
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret;
      }
      return ret;
    }

  function _hip_decode1_unclipped() {
  Module['printErr']('missing function: hip_decode1_unclipped'); abort(-1);
  }

___errno_state = Runtime.staticAlloc(4); HEAP32[((___errno_state)>>2)]=0;
FS.staticInit();__ATINIT__.unshift(function() { if (!Module["noFSInit"] && !FS.init.initialized) FS.init() });__ATMAIN__.push(function() { FS.ignorePermissions = false });__ATEXIT__.push(function() { FS.quit() });Module["FS_createFolder"] = FS.createFolder;Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createLink"] = FS.createLink;Module["FS_createDevice"] = FS.createDevice;
__ATINIT__.unshift(function() { TTY.init() });__ATEXIT__.push(function() { TTY.shutdown() });
if (ENVIRONMENT_IS_NODE) { var fs = require("fs"); var NODEJS_PATH = require("path"); NODEFS.staticInit(); }
Module["requestFullScreen"] = function Module_requestFullScreen(lockPointer, resizeCanvas, vrDevice) { Browser.requestFullScreen(lockPointer, resizeCanvas, vrDevice) };
  Module["requestAnimationFrame"] = function Module_requestAnimationFrame(func) { Browser.requestAnimationFrame(func) };
  Module["setCanvasSize"] = function Module_setCanvasSize(width, height, noUpdates) { Browser.setCanvasSize(width, height, noUpdates) };
  Module["pauseMainLoop"] = function Module_pauseMainLoop() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function Module_resumeMainLoop() { Browser.mainLoop.resume() };
  Module["getUserMedia"] = function Module_getUserMedia() { Browser.getUserMedia() }
  Module["createContext"] = function Module_createContext(canvas, useWebGL, setInModule, webGLContextAttributes) { return Browser.createContext(canvas, useWebGL, setInModule, webGLContextAttributes) }
__ATINIT__.push(function() { SOCKFS.root = FS.mount(SOCKFS, {}, null); });
STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);

staticSealed = true; // seal the static portion of memory

STACK_MAX = STACK_BASE + TOTAL_STACK;

DYNAMIC_BASE = DYNAMICTOP = Runtime.alignMemory(STACK_MAX);

assert(DYNAMIC_BASE < TOTAL_MEMORY, "TOTAL_MEMORY not big enough for stack");

 var cttz_i8 = allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0], "i8", ALLOC_DYNAMIC);


function invoke_iiii(index,a1,a2,a3) {
  try {
    return Module["dynCall_iiii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iiiii(index,a1,a2,a3,a4) {
  try {
    return Module["dynCall_iiiii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  try {
    Module["dynCall_vii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  try {
    return Module["dynCall_iii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_viiii(index,a1,a2,a3,a4) {
  try {
    Module["dynCall_viiii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

Module.asmGlobalArg = { "Math": Math, "Int8Array": Int8Array, "Int16Array": Int16Array, "Int32Array": Int32Array, "Uint8Array": Uint8Array, "Uint16Array": Uint16Array, "Uint32Array": Uint32Array, "Float32Array": Float32Array, "Float64Array": Float64Array, "NaN": NaN, "Infinity": Infinity };
Module.asmLibraryArg = { "abort": abort, "assert": assert, "invoke_iiii": invoke_iiii, "invoke_iiiii": invoke_iiiii, "invoke_vii": invoke_vii, "invoke_iii": invoke_iii, "invoke_viiii": invoke_viiii, "_fabs": _fabs, "_sin": _sin, "_exp": _exp, "_llvm_pow_f64": _llvm_pow_f64, "_send": _send, "_VBR_encode_frame": _VBR_encode_frame, "_abort": _abort, "___setErrNo": ___setErrNo, "_vfprintf": _vfprintf, "_hip_set_debugf": _hip_set_debugf, "_floor": _floor, "_fflush": _fflush, "_pwrite": _pwrite, "_strerror_r": _strerror_r, "__exit": __exit, "_GetTitleGain": _GetTitleGain, "_emscripten_set_main_loop_timing": _emscripten_set_main_loop_timing, "_fabsf": _fabsf, "_sbrk": _sbrk, "_atan": _atan, "_llvm_pow_f32": _llvm_pow_f32, "_InitGainAnalysis": _InitGainAnalysis, "_emscripten_memcpy_big": _emscripten_memcpy_big, "_fileno": _fileno, "_hip_decode_exit": _hip_decode_exit, "_sysconf": _sysconf, "_cos": _cos, "_mkport": _mkport, "_floorf": _floorf, "_hip_set_errorf": _hip_set_errorf, "__reallyNegative": __reallyNegative, "_write": _write, "_emscripten_set_main_loop": _emscripten_set_main_loop, "_AnalyzeSamples": _AnalyzeSamples, "___errno_location": ___errno_location, "_log": _log, "_init_xrpow_core_sse": _init_xrpow_core_sse, "_hip_decode1_unclipped": _hip_decode1_unclipped, "_fwrite": _fwrite, "_time": _time, "_fprintf": _fprintf, "_strerror": _strerror, "_ceil": _ceil, "__formatString": __formatString, "_sqrt": _sqrt, "_hip_set_msgf": _hip_set_msgf, "_exit": _exit, "_hip_decode_init": _hip_decode_init, "_llvm_sqrt_f64": _llvm_sqrt_f64, "STACKTOP": STACKTOP, "STACK_MAX": STACK_MAX, "tempDoublePtr": tempDoublePtr, "ABORT": ABORT, "cttz_i8": cttz_i8, "_stderr": _stderr };
// EMSCRIPTEN_START_ASM
var asm = (function(global, env, buffer) {
  'use asm';
  
  var HEAP8 = new global.Int8Array(buffer);
  var HEAP16 = new global.Int16Array(buffer);
  var HEAP32 = new global.Int32Array(buffer);
  var HEAPU8 = new global.Uint8Array(buffer);
  var HEAPU16 = new global.Uint16Array(buffer);
  var HEAPU32 = new global.Uint32Array(buffer);
  var HEAPF32 = new global.Float32Array(buffer);
  var HEAPF64 = new global.Float64Array(buffer);


  var STACKTOP=env.STACKTOP|0;
  var STACK_MAX=env.STACK_MAX|0;
  var tempDoublePtr=env.tempDoublePtr|0;
  var ABORT=env.ABORT|0;
  var cttz_i8=env.cttz_i8|0;
  var _stderr=env._stderr|0;

  var __THREW__ = 0;
  var threwValue = 0;
  var setjmpId = 0;
  var undef = 0;
  var nan = global.NaN, inf = global.Infinity;
  var tempInt = 0, tempBigInt = 0, tempBigIntP = 0, tempBigIntS = 0, tempBigIntR = 0.0, tempBigIntI = 0, tempBigIntD = 0, tempValue = 0, tempDouble = 0.0;

  var tempRet0 = 0;
  var tempRet1 = 0;
  var tempRet2 = 0;
  var tempRet3 = 0;
  var tempRet4 = 0;
  var tempRet5 = 0;
  var tempRet6 = 0;
  var tempRet7 = 0;
  var tempRet8 = 0;
  var tempRet9 = 0;
  var Math_floor=global.Math.floor;
  var Math_abs=global.Math.abs;
  var Math_sqrt=global.Math.sqrt;
  var Math_pow=global.Math.pow;
  var Math_cos=global.Math.cos;
  var Math_sin=global.Math.sin;
  var Math_tan=global.Math.tan;
  var Math_acos=global.Math.acos;
  var Math_asin=global.Math.asin;
  var Math_atan=global.Math.atan;
  var Math_atan2=global.Math.atan2;
  var Math_exp=global.Math.exp;
  var Math_log=global.Math.log;
  var Math_ceil=global.Math.ceil;
  var Math_imul=global.Math.imul;
  var Math_min=global.Math.min;
  var Math_clz32=global.Math.clz32;
  var abort=env.abort;
  var assert=env.assert;
  var invoke_iiii=env.invoke_iiii;
  var invoke_iiiii=env.invoke_iiiii;
  var invoke_vii=env.invoke_vii;
  var invoke_iii=env.invoke_iii;
  var invoke_viiii=env.invoke_viiii;
  var _fabs=env._fabs;
  var _sin=env._sin;
  var _exp=env._exp;
  var _llvm_pow_f64=env._llvm_pow_f64;
  var _send=env._send;
  var _VBR_encode_frame=env._VBR_encode_frame;
  var _abort=env._abort;
  var ___setErrNo=env.___setErrNo;
  var _vfprintf=env._vfprintf;
  var _hip_set_debugf=env._hip_set_debugf;
  var _floor=env._floor;
  var _fflush=env._fflush;
  var _pwrite=env._pwrite;
  var _strerror_r=env._strerror_r;
  var __exit=env.__exit;
  var _GetTitleGain=env._GetTitleGain;
  var _emscripten_set_main_loop_timing=env._emscripten_set_main_loop_timing;
  var _fabsf=env._fabsf;
  var _sbrk=env._sbrk;
  var _atan=env._atan;
  var _llvm_pow_f32=env._llvm_pow_f32;
  var _InitGainAnalysis=env._InitGainAnalysis;
  var _emscripten_memcpy_big=env._emscripten_memcpy_big;
  var _fileno=env._fileno;
  var _hip_decode_exit=env._hip_decode_exit;
  var _sysconf=env._sysconf;
  var _cos=env._cos;
  var _mkport=env._mkport;
  var _floorf=env._floorf;
  var _hip_set_errorf=env._hip_set_errorf;
  var __reallyNegative=env.__reallyNegative;
  var _write=env._write;
  var _emscripten_set_main_loop=env._emscripten_set_main_loop;
  var _AnalyzeSamples=env._AnalyzeSamples;
  var ___errno_location=env.___errno_location;
  var _log=env._log;
  var _init_xrpow_core_sse=env._init_xrpow_core_sse;
  var _hip_decode1_unclipped=env._hip_decode1_unclipped;
  var _fwrite=env._fwrite;
  var _time=env._time;
  var _fprintf=env._fprintf;
  var _strerror=env._strerror;
  var _ceil=env._ceil;
  var __formatString=env.__formatString;
  var _sqrt=env._sqrt;
  var _hip_set_msgf=env._hip_set_msgf;
  var _exit=env._exit;
  var _hip_decode_init=env._hip_decode_init;
  var _llvm_sqrt_f64=env._llvm_sqrt_f64;
  var tempFloat = 0.0;

// EMSCRIPTEN_START_FUNCS
function stackAlloc(size) {
  size = size|0;
  var ret = 0;
  ret = STACKTOP;
  STACKTOP = (STACKTOP + size)|0;
  STACKTOP = (STACKTOP + 15)&-16;

  return ret|0;
}
function stackSave() {
  return STACKTOP|0;
}
function stackRestore(top) {
  top = top|0;
  STACKTOP = top;
}
function establishStackSpace(stackBase, stackMax) {
  stackBase = stackBase|0;
  stackMax = stackMax|0;
  STACKTOP = stackBase;
  STACK_MAX = stackMax;
}

function setThrew(threw, value) {
  threw = threw|0;
  value = value|0;
  if ((__THREW__|0) == 0) {
    __THREW__ = threw;
    threwValue = value;
  }
}
function copyTempFloat(ptr) {
  ptr = ptr|0;
  HEAP8[tempDoublePtr>>0] = HEAP8[ptr>>0];
  HEAP8[tempDoublePtr+1>>0] = HEAP8[ptr+1>>0];
  HEAP8[tempDoublePtr+2>>0] = HEAP8[ptr+2>>0];
  HEAP8[tempDoublePtr+3>>0] = HEAP8[ptr+3>>0];
}
function copyTempDouble(ptr) {
  ptr = ptr|0;
  HEAP8[tempDoublePtr>>0] = HEAP8[ptr>>0];
  HEAP8[tempDoublePtr+1>>0] = HEAP8[ptr+1>>0];
  HEAP8[tempDoublePtr+2>>0] = HEAP8[ptr+2>>0];
  HEAP8[tempDoublePtr+3>>0] = HEAP8[ptr+3>>0];
  HEAP8[tempDoublePtr+4>>0] = HEAP8[ptr+4>>0];
  HEAP8[tempDoublePtr+5>>0] = HEAP8[ptr+5>>0];
  HEAP8[tempDoublePtr+6>>0] = HEAP8[ptr+6>>0];
  HEAP8[tempDoublePtr+7>>0] = HEAP8[ptr+7>>0];
}

function setTempRet0(value) {
  value = value|0;
  tempRet0 = value;
}
function getTempRet0() {
  return tempRet0|0;
}

function _AddVbrFrame($gfc) {
 $gfc = $gfc|0;
 var $$pre$i = 0, $$pre2$i = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0;
 var $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $i$01$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gfc)) + 84744|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ((($gfc)) + 16|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ((83944 + ($3<<6)|0) + ($1<<2)|0);
 $5 = HEAP32[$4>>2]|0;
 $6 = ((($gfc)) + 85784|0);
 $7 = HEAP32[$6>>2]|0;
 $8 = (($7) + 1)|0;
 HEAP32[$6>>2] = $8;
 $9 = ((($gfc)) + 85760|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = (($10) + ($5))|0;
 HEAP32[$9>>2] = $11;
 $12 = ((($gfc)) + 85764|0);
 $13 = HEAP32[$12>>2]|0;
 $14 = (($13) + 1)|0;
 HEAP32[$12>>2] = $14;
 $15 = ((($gfc)) + 85768|0);
 $16 = HEAP32[$15>>2]|0;
 $17 = ($14|0)<($16|0);
 if ($17) {
  return;
 }
 $18 = ((($gfc)) + 85772|0);
 $19 = HEAP32[$18>>2]|0;
 $20 = ((($gfc)) + 85776|0);
 $21 = HEAP32[$20>>2]|0;
 $22 = ($19|0)<($21|0);
 if ($22) {
  $23 = ((($gfc)) + 85780|0);
  $24 = HEAP32[$23>>2]|0;
  $25 = (($24) + ($19<<2)|0);
  HEAP32[$25>>2] = $11;
  $26 = HEAP32[$18>>2]|0;
  $27 = (($26) + 1)|0;
  HEAP32[$18>>2] = $27;
  HEAP32[$12>>2] = 0;
  $$pre$i = HEAP32[$20>>2]|0;
  $28 = $27;$30 = $$pre$i;
 } else {
  $28 = $19;$30 = $21;
 }
 $29 = ($28|0)==($30|0);
 if (!($29)) {
  return;
 }
 $31 = ($30|0)>(1);
 if ($31) {
  $32 = ((($gfc)) + 85780|0);
  $33 = HEAP32[$32>>2]|0;
  $i$01$i = 1;
  while(1) {
   $34 = (($33) + ($i$01$i<<2)|0);
   $35 = HEAP32[$34>>2]|0;
   $36 = (($i$01$i|0) / 2)&-1;
   $37 = (($33) + ($36<<2)|0);
   HEAP32[$37>>2] = $35;
   $38 = (($i$01$i) + 2)|0;
   $39 = HEAP32[$20>>2]|0;
   $40 = ($38|0)<($39|0);
   if ($40) {
    $i$01$i = $38;
   } else {
    break;
   }
  }
  $$pre2$i = HEAP32[$18>>2]|0;
  $44 = $$pre2$i;
 } else {
  $44 = $30;
 }
 $41 = HEAP32[$15>>2]|0;
 $42 = $41 << 1;
 HEAP32[$15>>2] = $42;
 $43 = (($44|0) / 2)&-1;
 HEAP32[$18>>2] = $43;
 return;
}
function _InitVbrTag($gfp) {
 $gfp = $gfp|0;
 var $$ = 0, $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0;
 var $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $buffer = 0, $exitcond = 0, $i$02 = 0, $kbps_header$0 = 0, $kbps_header$1 = 0, $or$cond = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 2896|0;
 $vararg_buffer = sp;
 $buffer = sp + 8|0;
 $0 = ((($gfp)) + 288|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ((($1)) + 16|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)==(1);
 if ($4) {
  $kbps_header$0 = 128;
 } else {
  $5 = ((($1)) + 64|0);
  $6 = HEAP32[$5>>2]|0;
  $7 = ($6|0)<(16000);
  $$ = $7 ? 32 : 64;
  $kbps_header$0 = $$;
 }
 $8 = ((($1)) + 104|0);
 $9 = HEAP32[$8>>2]|0;
 $10 = ($9|0)==(0);
 if ($10) {
  $11 = ((($1)) + 120|0);
  $12 = HEAP32[$11>>2]|0;
  $kbps_header$1 = $12;
 } else {
  $kbps_header$1 = $kbps_header$0;
 }
 $13 = ($3*72000)|0;
 $14 = (($13) + 72000)|0;
 $15 = Math_imul($14, $kbps_header$1)|0;
 $16 = ((($1)) + 64|0);
 $17 = HEAP32[$16>>2]|0;
 $18 = (($15|0) / ($17|0))&-1;
 $19 = ((($1)) + 24|0);
 $20 = HEAP32[$19>>2]|0;
 $21 = (($20) + 156)|0;
 $22 = ((($1)) + 85792|0);
 HEAP32[$22>>2] = $18;
 $23 = ($18|0)<($21|0);
 $24 = ($18|0)>(2880);
 $or$cond = $24 | $23;
 if ($or$cond) {
  $25 = ((($1)) + 156|0);
  HEAP32[$25>>2] = 0;
  $$0 = 0;
  STACKTOP = sp;return ($$0|0);
 }
 $26 = ((($1)) + 85784|0);
 HEAP32[$26>>2] = 0;
 $27 = ((($1)) + 85788|0);
 HEAP32[$27>>2] = 0;
 $28 = ((($1)) + 85760|0);
 HEAP32[$28>>2] = 0;
 $29 = ((($1)) + 85764|0);
 HEAP32[$29>>2] = 0;
 $30 = ((($1)) + 85768|0);
 HEAP32[$30>>2] = 1;
 $31 = ((($1)) + 85772|0);
 HEAP32[$31>>2] = 0;
 $32 = ((($1)) + 85780|0);
 $33 = HEAP32[$32>>2]|0;
 $34 = ($33|0)==(0|0);
 do {
  if ($34) {
   $35 = (_malloc(1600)|0);
   HEAP32[$32>>2] = $35;
   $36 = ($35|0)==(0|0);
   $37 = ((($1)) + 85776|0);
   if (!($36)) {
    HEAP32[$37>>2] = 400;
    break;
   }
   HEAP32[$37>>2] = 0;
   _lame_errorf($1,8,$vararg_buffer);
   $38 = ((($1)) + 156|0);
   HEAP32[$38>>2] = 0;
   $$0 = -1;
   STACKTOP = sp;return ($$0|0);
  }
 } while(0);
 _memset(($buffer|0),0,2880)|0;
 _setLameTagFrameHeader($1,$buffer);
 $39 = HEAP32[$22>>2]|0;
 $40 = ($39|0)==(0);
 if (!($40)) {
  $i$02 = 0;
  while(1) {
   $41 = (($buffer) + ($i$02)|0);
   $42 = HEAP8[$41>>0]|0;
   _add_dummy_byte($1,$42,1);
   $43 = (($i$02) + 1)|0;
   $exitcond = ($43|0)==($39|0);
   if ($exitcond) {
    break;
   } else {
    $i$02 = $43;
   }
  }
 }
 $$0 = 0;
 STACKTOP = sp;return ($$0|0);
}
function _UpdateMusicCRC($crc,$buffer,$size) {
 $crc = $crc|0;
 $buffer = $buffer|0;
 $size = $size|0;
 var $$pre = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $exitcond = 0, $i$01 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($size|0)>(0);
 if (!($0)) {
  return;
 }
 $$pre = HEAP16[$crc>>1]|0;
 $5 = $$pre;$i$01 = 0;
 while(1) {
  $1 = (($buffer) + ($i$01)|0);
  $2 = HEAP8[$1>>0]|0;
  $3 = $2&255;
  $4 = $5&65535;
  $6 = $5 ^ $3;
  $7 = $4 >>> 8;
  $8 = $6&65535;
  $9 = $8 & 255;
  $10 = (48 + ($9<<2)|0);
  $11 = HEAP32[$10>>2]|0;
  $12 = $7 ^ $11;
  $13 = $12&65535;
  HEAP16[$crc>>1] = $13;
  $14 = (($i$01) + 1)|0;
  $exitcond = ($14|0)==($size|0);
  if ($exitcond) {
   break;
  } else {
   $5 = $13;$i$01 = $14;
  }
 }
 return;
}
function _setLameTagFrameHeader($gfc,$buffer) {
 $gfc = $gfc|0;
 $buffer = $buffer|0;
 var $$ = 0, $$masked = 0, $$masked1 = 0, $$pre = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0;
 var $112 = 0, $113 = 0, $114 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0;
 var $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0;
 var $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0;
 var $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0;
 var $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $bbyte$0 = 0;
 var $bitrate$0 = 0, $bitrate$1 = 0, $not$ = 0, $sext = 0, $sext2 = 0, $storemerge = 0, $storemerge$in = 0, label = 0, sp = 0;
 sp = STACKTOP;
 HEAP8[$buffer>>0] = -1;
 $0 = ((($buffer)) + 1|0);
 $1 = HEAP8[$0>>0]|0;
 $2 = $1&255;
 $3 = $2 << 3;
 $4 = $3 | 7;
 $5 = $4&255;
 HEAP8[$0>>0] = $5;
 $6 = $4 << 1;
 $7 = ((($gfc)) + 64|0);
 $8 = HEAP32[$7>>2]|0;
 $not$ = ($8|0)>(15999);
 $9 = $not$&1;
 $10 = $6 | $9;
 $11 = $10&255;
 HEAP8[$0>>0] = $11;
 $12 = $10 << 1;
 $13 = ((($gfc)) + 16|0);
 $14 = HEAP32[$13>>2]|0;
 $15 = $14 & 1;
 $$masked = $12 & 62;
 $16 = $$masked | $15;
 $17 = $16 << 2;
 $18 = $17 | 1;
 $19 = $18&255;
 HEAP8[$0>>0] = $19;
 $20 = $18 << 1;
 $21 = ((($gfc)) + 160|0);
 $22 = HEAP32[$21>>2]|0;
 $23 = ($22|0)==(0);
 $24 = $23&1;
 $25 = $20 | $24;
 $26 = $25&255;
 HEAP8[$0>>0] = $26;
 $27 = ((($buffer)) + 2|0);
 $28 = HEAP8[$27>>0]|0;
 $29 = $28&255;
 $30 = $29 << 4;
 $31 = ((($gfc)) + 84744|0);
 $32 = HEAP32[$31>>2]|0;
 $33 = $32 & 15;
 $34 = $30 | $33;
 $35 = $34&255;
 HEAP8[$27>>0] = $35;
 $36 = $34 << 2;
 $37 = ((($gfc)) + 20|0);
 $38 = HEAP32[$37>>2]|0;
 $39 = $38 & 3;
 $$masked1 = $36 & 124;
 $40 = $$masked1 | $39;
 $41 = $40 << 1;
 $42 = $41&255;
 HEAP8[$27>>0] = $42;
 $43 = $40 << 2;
 $44 = ((($gfc)) + 172|0);
 $45 = HEAP32[$44>>2]|0;
 $46 = $45 & 1;
 $47 = $43 | $46;
 $48 = $47&255;
 HEAP8[$27>>0] = $48;
 $49 = ((($buffer)) + 3|0);
 $50 = HEAP8[$49>>0]|0;
 $51 = $50&255;
 $52 = $51 << 2;
 $53 = ((($gfc)) + 180|0);
 $54 = HEAP32[$53>>2]|0;
 $55 = $54 & 3;
 $56 = $52 | $55;
 $57 = $56&255;
 HEAP8[$49>>0] = $57;
 $58 = $56 << 2;
 $59 = ((($gfc)) + 84756|0);
 $60 = HEAP32[$59>>2]|0;
 $61 = $60 & 3;
 $62 = $58 | $61;
 $63 = $62&255;
 HEAP8[$49>>0] = $63;
 $64 = $62 << 1;
 $65 = ((($gfc)) + 164|0);
 $66 = HEAP32[$65>>2]|0;
 $67 = $66 & 1;
 $68 = $64 | $67;
 $69 = $68&255;
 HEAP8[$49>>0] = $69;
 $70 = $68 << 1;
 $71 = ((($gfc)) + 168|0);
 $72 = HEAP32[$71>>2]|0;
 $73 = $72 & 1;
 $74 = $70 | $73;
 $75 = $74&255;
 HEAP8[$49>>0] = $75;
 $76 = $74 << 2;
 $77 = ((($gfc)) + 176|0);
 $78 = HEAP32[$77>>2]|0;
 $79 = $78 & 3;
 $80 = $76 | $79;
 $81 = $80&255;
 HEAP8[$49>>0] = $81;
 HEAP8[$buffer>>0] = -1;
 $82 = HEAP32[$13>>2]|0;
 $83 = ($82|0)==(1);
 if ($83) {
  $bitrate$0 = 128;
 } else {
  $84 = HEAP32[$7>>2]|0;
  $85 = ($84|0)<(16000);
  $$ = $85 ? 32 : 64;
  $bitrate$0 = $$;
 }
 $86 = ((($gfc)) + 104|0);
 $87 = HEAP32[$86>>2]|0;
 $88 = ($87|0)==(0);
 if ($88) {
  $89 = ((($gfc)) + 120|0);
  $90 = HEAP32[$89>>2]|0;
  $bitrate$1 = $90;
 } else {
  $bitrate$1 = $bitrate$0;
 }
 $91 = ((($gfc)) + 152|0);
 $92 = HEAP32[$91>>2]|0;
 $93 = ($92|0)==(0);
 if ($93) {
  $94 = HEAP32[$7>>2]|0;
  $95 = (_BitrateIndex($bitrate$1,$82,$94)|0);
  $96 = $95 << 4;
  $97 = $96&255;
  $$pre = HEAP32[$13>>2]|0;
  $98 = $$pre;$bbyte$0 = $97;
 } else {
  $98 = $82;$bbyte$0 = 0;
 }
 $99 = ($98|0)==(1);
 $sext2 = $25 << 24;
 $sext = $sext2 >> 24;
 $100 = $sext & -15;
 if ($99) {
  $101 = $100 | 10;
  $102 = $101&255;
  HEAP8[$0>>0] = $102;
  $103 = HEAP8[$27>>0]|0;
  $104 = $103&255;
  $105 = $104 & 13;
  $106 = $bbyte$0 << 24 >> 24;
  $107 = $105 | $106;
  $storemerge$in = $107;
  $storemerge = $storemerge$in&255;
  HEAP8[$27>>0] = $storemerge;
  return;
 } else {
  $108 = $100 | 2;
  $109 = $108&255;
  HEAP8[$0>>0] = $109;
  $110 = HEAP8[$27>>0]|0;
  $111 = $110&255;
  $112 = $111 & 13;
  $113 = $bbyte$0&255;
  $114 = $112 | $113;
  $storemerge$in = $114;
  $storemerge = $storemerge$in&255;
  HEAP8[$27>>0] = $storemerge;
  return;
 }
}
function _getframebits($gfc) {
 $gfc = $gfc|0;
 var $$idx$val = 0, $$idx$val$pre = 0, $$idx1 = 0, $$idx1$val = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $bit_rate$0 = 0;
 var $bit_rate$0$in = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gfc)) + 16|0);
 $1 = ((($gfc)) + 84744|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = ($2|0)==(0);
 if ($3) {
  $6 = ((($gfc)) + 120|0);
  $$idx$val$pre = HEAP32[$0>>2]|0;
  $$idx$val = $$idx$val$pre;$bit_rate$0$in = $6;
 } else {
  $4 = HEAP32[$0>>2]|0;
  $5 = ((83944 + ($4<<6)|0) + ($2<<2)|0);
  $$idx$val = $4;$bit_rate$0$in = $5;
 }
 $bit_rate$0 = HEAP32[$bit_rate$0$in>>2]|0;
 $7 = ((($gfc)) + 84752|0);
 $8 = HEAP32[$7>>2]|0;
 $$idx1 = ((($gfc)) + 64|0);
 $$idx1$val = HEAP32[$$idx1>>2]|0;
 $9 = ($$idx$val*72000)|0;
 $10 = (($9) + 72000)|0;
 $11 = Math_imul($10, $bit_rate$0)|0;
 $12 = (($11|0) / ($$idx1$val|0))&-1;
 $13 = (($12) + ($8))|0;
 $14 = $13 << 3;
 return ($14|0);
}
function _get_max_frame_buffer_size_by_constraint($cfg,$constraint) {
 $cfg = $cfg|0;
 $constraint = $constraint|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0;
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cfg$idx2$val = 0, $cfg$idx3 = 0, $cfg$idx3$val = 0, $max_kbps$0 = 0, $max_kbps$0$in = 0, $maxmp3buf$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($cfg)) + 104|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($1|0)>(320);
 if ($2) {
  $3 = ($constraint|0)==(1);
  $cfg$idx2$val = HEAP32[$cfg>>2]|0;
  if ($3) {
   $cfg$idx3 = ((($cfg)) + 48|0);
   $cfg$idx3$val = HEAP32[$cfg$idx3>>2]|0;
   $4 = ($cfg$idx2$val*72000)|0;
   $5 = (($4) + 72000)|0;
   $6 = Math_imul($5, $1)|0;
   $7 = (($6|0) / ($cfg$idx3$val|0))&-1;
   $8 = $7 << 3;
   $maxmp3buf$0 = $8;
   return ($maxmp3buf$0|0);
  } else {
   $9 = ($cfg$idx2$val*7680)|0;
   $10 = (($9) + 7680)|0;
   $maxmp3buf$0 = $10;
   return ($maxmp3buf$0|0);
  }
 }
 $11 = HEAP32[$cfg>>2]|0;
 if ((($constraint|0) == 2)) {
  $22 = ($11*7680)|0;
  $23 = (($22) + 7680)|0;
  $maxmp3buf$0 = $23;
  return ($maxmp3buf$0|0);
 } else if ((($constraint|0) == 1)) {
  $12 = ((($cfg)) + 48|0);
  $13 = HEAP32[$12>>2]|0;
  $14 = ($13|0)<(16000);
  $15 = (((83944 + ($11<<6)|0)) + 32|0);
  $16 = (((83944 + ($11<<6)|0)) + 56|0);
  $max_kbps$0$in = $14 ? $15 : $16;
  $max_kbps$0 = HEAP32[$max_kbps$0$in>>2]|0;
  $17 = ($11*72000)|0;
  $18 = (($17) + 72000)|0;
  $19 = Math_imul($18, $max_kbps$0)|0;
  $20 = (($19|0) / ($13|0))&-1;
  $21 = $20 << 3;
  $maxmp3buf$0 = $21;
  return ($maxmp3buf$0|0);
 } else {
  $maxmp3buf$0 = 11520;
  return ($maxmp3buf$0|0);
 }
 return (0)|0;
}
function _CRC_writeheader($gfc,$header) {
 $gfc = $gfc|0;
 $header = $header|0;
 var $$$1$i = 0, $$$1$i10 = 0, $$$1$i2 = 0, $$$2$i = 0, $$$2$i11 = 0, $$$2$i3 = 0, $$$3$i = 0, $$$3$i12 = 0, $$$3$i4 = 0, $$$4$i = 0, $$$4$i13 = 0, $$$4$i5 = 0, $$$5$i = 0, $$$5$i14 = 0, $$$5$i6 = 0, $$$6$i = 0, $$$6$i15 = 0, $$$6$i7 = 0, $$$7$i = 0, $$$7$i16 = 0;
 var $$$7$i8 = 0, $$$i = 0, $$$i1 = 0, $$$i9 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0;
 var $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0;
 var $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0;
 var $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0;
 var $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0;
 var $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0;
 var $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0;
 var $98 = 0, $99 = 0, $crc$0$lcssa = 0, $crc$017 = 0, $i$018 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($header)) + 2|0);
 $1 = HEAP8[$0>>0]|0;
 $2 = $1&255;
 $3 = $2 & 128;
 $4 = ($3|0)!=(0);
 $$$i = $4 ? 262140 : 196598;
 $5 = $2 << 10;
 $6 = $$$i ^ $5;
 $7 = $6 & 65536;
 $8 = ($7|0)==(0);
 $9 = $$$i ^ 32773;
 $$$1$i = $8 ? $$$i : $9;
 $10 = $2 << 11;
 $11 = $$$1$i << 1;
 $12 = $11 ^ $10;
 $13 = $12 & 65536;
 $14 = ($13|0)==(0);
 $15 = $11 ^ 32773;
 $$$2$i = $14 ? $11 : $15;
 $16 = $2 << 12;
 $17 = $$$2$i << 1;
 $18 = $17 ^ $16;
 $19 = $18 & 65536;
 $20 = ($19|0)==(0);
 $21 = $17 ^ 32773;
 $$$3$i = $20 ? $17 : $21;
 $22 = $2 << 13;
 $23 = $$$3$i << 1;
 $24 = $23 ^ $22;
 $25 = $24 & 65536;
 $26 = ($25|0)==(0);
 $27 = $23 ^ 32773;
 $$$4$i = $26 ? $23 : $27;
 $28 = $2 << 14;
 $29 = $$$4$i << 1;
 $30 = $29 ^ $28;
 $31 = $30 & 65536;
 $32 = ($31|0)==(0);
 $33 = $29 ^ 32773;
 $$$5$i = $32 ? $29 : $33;
 $34 = $2 << 15;
 $35 = $$$5$i << 1;
 $36 = $35 ^ $34;
 $37 = $36 & 65536;
 $38 = ($37|0)==(0);
 $39 = $35 ^ 32773;
 $$$6$i = $38 ? $35 : $39;
 $40 = $2 << 16;
 $41 = $$$6$i << 1;
 $42 = $41 ^ $40;
 $43 = $42 & 65536;
 $44 = ($43|0)==(0);
 $45 = $41 ^ 32773;
 $$$7$i = $44 ? $41 : $45;
 $46 = ((($header)) + 3|0);
 $47 = HEAP8[$46>>0]|0;
 $48 = $47&255;
 $49 = $48 << 9;
 $50 = $$$7$i << 1;
 $51 = $50 ^ $49;
 $52 = $51 & 65536;
 $53 = ($52|0)==(0);
 $54 = $50 ^ 32773;
 $$$i9 = $53 ? $50 : $54;
 $55 = $48 << 10;
 $56 = $$$i9 << 1;
 $57 = $56 ^ $55;
 $58 = $57 & 65536;
 $59 = ($58|0)==(0);
 $60 = $56 ^ 32773;
 $$$1$i10 = $59 ? $56 : $60;
 $61 = $48 << 11;
 $62 = $$$1$i10 << 1;
 $63 = $62 ^ $61;
 $64 = $63 & 65536;
 $65 = ($64|0)==(0);
 $66 = $62 ^ 32773;
 $$$2$i11 = $65 ? $62 : $66;
 $67 = $48 << 12;
 $68 = $$$2$i11 << 1;
 $69 = $68 ^ $67;
 $70 = $69 & 65536;
 $71 = ($70|0)==(0);
 $72 = $68 ^ 32773;
 $$$3$i12 = $71 ? $68 : $72;
 $73 = $48 << 13;
 $74 = $$$3$i12 << 1;
 $75 = $74 ^ $73;
 $76 = $75 & 65536;
 $77 = ($76|0)==(0);
 $78 = $74 ^ 32773;
 $$$4$i13 = $77 ? $74 : $78;
 $79 = $48 << 14;
 $80 = $$$4$i13 << 1;
 $81 = $80 ^ $79;
 $82 = $81 & 65536;
 $83 = ($82|0)==(0);
 $84 = $80 ^ 32773;
 $$$5$i14 = $83 ? $80 : $84;
 $85 = $48 << 15;
 $86 = $$$5$i14 << 1;
 $87 = $86 ^ $85;
 $88 = $87 & 65536;
 $89 = ($88|0)==(0);
 $90 = $86 ^ 32773;
 $$$6$i15 = $89 ? $86 : $90;
 $91 = $48 << 16;
 $92 = $$$6$i15 << 1;
 $93 = $92 ^ $91;
 $94 = $93 & 65536;
 $95 = ($94|0)==(0);
 $96 = $92 ^ 32773;
 $$$7$i16 = $95 ? $92 : $96;
 $97 = ((($gfc)) + 24|0);
 $98 = HEAP32[$97>>2]|0;
 $99 = ($98|0)>(6);
 if ($99) {
  $crc$017 = $$$7$i16;$i$018 = 6;
 } else {
  $crc$0$lcssa = $$$7$i16;
  $153 = $crc$0$lcssa >>> 8;
  $154 = $153&255;
  $155 = ((($header)) + 4|0);
  HEAP8[$155>>0] = $154;
  $156 = $crc$0$lcssa&255;
  $157 = ((($header)) + 5|0);
  HEAP8[$157>>0] = $156;
  return;
 }
 while(1) {
  $100 = (($header) + ($i$018)|0);
  $101 = HEAP8[$100>>0]|0;
  $102 = $101&255;
  $103 = $102 << 9;
  $104 = $crc$017 << 1;
  $105 = $103 ^ $104;
  $106 = $105 & 65536;
  $107 = ($106|0)==(0);
  $108 = $104 ^ 32773;
  $$$i1 = $107 ? $104 : $108;
  $109 = $102 << 10;
  $110 = $$$i1 << 1;
  $111 = $110 ^ $109;
  $112 = $111 & 65536;
  $113 = ($112|0)==(0);
  $114 = $110 ^ 32773;
  $$$1$i2 = $113 ? $110 : $114;
  $115 = $102 << 11;
  $116 = $$$1$i2 << 1;
  $117 = $116 ^ $115;
  $118 = $117 & 65536;
  $119 = ($118|0)==(0);
  $120 = $116 ^ 32773;
  $$$2$i3 = $119 ? $116 : $120;
  $121 = $102 << 12;
  $122 = $$$2$i3 << 1;
  $123 = $122 ^ $121;
  $124 = $123 & 65536;
  $125 = ($124|0)==(0);
  $126 = $122 ^ 32773;
  $$$3$i4 = $125 ? $122 : $126;
  $127 = $102 << 13;
  $128 = $$$3$i4 << 1;
  $129 = $128 ^ $127;
  $130 = $129 & 65536;
  $131 = ($130|0)==(0);
  $132 = $128 ^ 32773;
  $$$4$i5 = $131 ? $128 : $132;
  $133 = $102 << 14;
  $134 = $$$4$i5 << 1;
  $135 = $134 ^ $133;
  $136 = $135 & 65536;
  $137 = ($136|0)==(0);
  $138 = $134 ^ 32773;
  $$$5$i6 = $137 ? $134 : $138;
  $139 = $102 << 15;
  $140 = $$$5$i6 << 1;
  $141 = $140 ^ $139;
  $142 = $141 & 65536;
  $143 = ($142|0)==(0);
  $144 = $140 ^ 32773;
  $$$6$i7 = $143 ? $140 : $144;
  $145 = $102 << 16;
  $146 = $$$6$i7 << 1;
  $147 = $146 ^ $145;
  $148 = $147 & 65536;
  $149 = ($148|0)==(0);
  $150 = $146 ^ 32773;
  $$$7$i8 = $149 ? $146 : $150;
  $151 = (($i$018) + 1)|0;
  $152 = ($151|0)<($98|0);
  if ($152) {
   $crc$017 = $$$7$i8;$i$018 = $151;
  } else {
   $crc$0$lcssa = $$$7$i8;
   break;
  }
 }
 $153 = $crc$0$lcssa >>> 8;
 $154 = $153&255;
 $155 = ((($header)) + 4|0);
 HEAP8[$155>>0] = $154;
 $156 = $crc$0$lcssa&255;
 $157 = ((($header)) + 5|0);
 HEAP8[$157>>0] = $156;
 return;
}
function _flush_bitstream($gfc) {
 $gfc = $gfc|0;
 var $$$i = 0, $$1$i = 0, $$idx$val$i$i = 0, $$idx$val$pre$i$i = 0, $$idx1$i$i = 0, $$idx1$val$i$i = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0;
 var $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0;
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $bit_rate$0$i$i = 0, $bit_rate$0$in$i$i = 0, $flushbits$0$i = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $vararg_buffer = sp;
 $0 = ((($gfc)) + 52132|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ((($gfc)) + 52128|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = (($3) + -1)|0;
 $5 = ($3|0)==(0);
 $$$i = $5 ? 255 : $4;
 $6 = (((($gfc)) + 39840|0) + (($$$i*48)|0)|0);
 $7 = HEAP32[$6>>2]|0;
 $8 = ((($gfc)) + 292|0);
 $9 = HEAP32[$8>>2]|0;
 $10 = (($7) - ($9))|0;
 $11 = ($10|0)>(-1);
 if ($11) {
  $12 = (1 - ($1))|0;
  $13 = (($$$i) + ($12))|0;
  $14 = ($$$i|0)<($1|0);
  $15 = (($13) + 256)|0;
  $$1$i = $14 ? $15 : $13;
  $16 = $$1$i << 3;
  $17 = ((($gfc)) + 24|0);
  $18 = HEAP32[$17>>2]|0;
  $19 = Math_imul($16, $18)|0;
  $20 = (($10) - ($19))|0;
  $flushbits$0$i = $20;
 } else {
  $flushbits$0$i = $10;
 }
 $21 = ((($gfc)) + 16|0);
 $22 = ((($gfc)) + 84744|0);
 $23 = HEAP32[$22>>2]|0;
 $24 = ($23|0)==(0);
 if ($24) {
  $27 = ((($gfc)) + 120|0);
  $$idx$val$pre$i$i = HEAP32[$21>>2]|0;
  $$idx$val$i$i = $$idx$val$pre$i$i;$bit_rate$0$in$i$i = $27;
 } else {
  $25 = HEAP32[$21>>2]|0;
  $26 = ((83944 + ($25<<6)|0) + ($23<<2)|0);
  $$idx$val$i$i = $25;$bit_rate$0$in$i$i = $26;
 }
 $bit_rate$0$i$i = HEAP32[$bit_rate$0$in$i$i>>2]|0;
 $28 = ((($gfc)) + 84752|0);
 $29 = HEAP32[$28>>2]|0;
 $$idx1$i$i = ((($gfc)) + 64|0);
 $$idx1$val$i$i = HEAP32[$$idx1$i$i>>2]|0;
 $30 = ($$idx$val$i$i*72000)|0;
 $31 = (($30) + 72000)|0;
 $32 = Math_imul($31, $bit_rate$0$i$i)|0;
 $33 = (($32|0) / ($$idx1$val$i$i|0))&-1;
 $34 = (($33) + ($29))|0;
 $35 = $34 << 3;
 $36 = (($35) + ($flushbits$0$i))|0;
 $37 = ($36|0)<(0);
 if ($37) {
  _lame_errorf($gfc,1072,$vararg_buffer);
  STACKTOP = sp;return;
 } else {
  _drain_into_ancillary($gfc,$36);
  $38 = ((($gfc)) + 52140|0);
  HEAP32[$38>>2] = 0;
  $39 = ((($gfc)) + 21312|0);
  HEAP32[$39>>2] = 0;
  STACKTOP = sp;return;
 }
}
function _add_dummy_byte($gfc,$val,$n) {
 $gfc = $gfc|0;
 $val = $val|0;
 $n = $n|0;
 var $$0$$i = 0, $$01$i = 0, $$in = 0, $$pre$i = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0;
 var $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $exitcond = 0, $i$01 = 0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($n|0)==(0);
 if ($0) {
  return;
 }
 $1 = $val&255;
 $2 = ((($gfc)) + 300|0);
 $3 = ((($gfc)) + 296|0);
 $4 = ((($gfc)) + 284|0);
 $5 = ((($gfc)) + 292|0);
 $$in = $n;
 while(1) {
  $$01$i = 8;
  while(1) {
   $8 = HEAP32[$2>>2]|0;
   $9 = ($8|0)==(0);
   if ($9) {
    HEAP32[$2>>2] = 8;
    $10 = HEAP32[$3>>2]|0;
    $11 = (($10) + 1)|0;
    HEAP32[$3>>2] = $11;
    $12 = HEAP32[$4>>2]|0;
    $13 = (($12) + ($11)|0);
    HEAP8[$13>>0] = 0;
    $$pre$i = HEAP32[$2>>2]|0;
    $15 = $$pre$i;
   } else {
    $15 = $8;
   }
   $14 = ($$01$i|0)<($15|0);
   $$0$$i = $14 ? $$01$i : $15;
   $16 = (($$01$i) - ($$0$$i))|0;
   $17 = (($15) - ($$0$$i))|0;
   HEAP32[$2>>2] = $17;
   $18 = $1 >>> $16;
   $19 = $18 << $17;
   $20 = HEAP32[$3>>2]|0;
   $21 = HEAP32[$4>>2]|0;
   $22 = (($21) + ($20)|0);
   $23 = HEAP8[$22>>0]|0;
   $24 = $23&255;
   $25 = $19 | $24;
   $26 = $25&255;
   HEAP8[$22>>0] = $26;
   $27 = HEAP32[$5>>2]|0;
   $28 = (($27) + ($$0$$i))|0;
   HEAP32[$5>>2] = $28;
   $29 = ($16|0)>(0);
   if ($29) {
    $$01$i = $16;
   } else {
    $i$01 = 0;
    break;
   }
  }
  while(1) {
   $30 = (((($gfc)) + 39840|0) + (($i$01*48)|0)|0);
   $31 = HEAP32[$30>>2]|0;
   $32 = (($31) + 8)|0;
   HEAP32[$30>>2] = $32;
   $33 = (($i$01) + 1)|0;
   $exitcond = ($33|0)==(256);
   if ($exitcond) {
    break;
   } else {
    $i$01 = $33;
   }
  }
  $6 = (($$in) + -1)|0;
  $7 = ($6|0)==(0);
  if ($7) {
   break;
  } else {
   $$in = $6;
  }
 }
 return;
}
function _format_bitstream($gfc) {
 $gfc = $gfc|0;
 var $$$i = 0, $$$i$i = 0, $$$i26$i = 0, $$$i7 = 0, $$$i8$i = 0, $$$i9$i = 0, $$0$$i$i = 0, $$0$$i$us$i = 0, $$0$$i107$i = 0, $$0$$i11$i = 0, $$0$$i115$i = 0, $$0$$i123$i = 0, $$0$$i131$i = 0, $$0$$i139$i = 0, $$0$$i14$i = 0, $$0$$i147$i = 0, $$0$$i155$i = 0, $$0$$i163$i = 0, $$0$$i171$i = 0, $$0$$i179$i = 0;
 var $$0$$i189$i = 0, $$0$$i19$i = 0, $$0$$i19$i9 = 0, $$0$$i199$i = 0, $$0$$i209$i = 0, $$0$$i219$i = 0, $$0$$i229$i = 0, $$0$$i239$i = 0, $$0$$i24$i = 0, $$0$$i249$i = 0, $$0$$i259$i = 0, $$0$$i269$i = 0, $$0$$i27$i = 0, $$0$$i279$i = 0, $$0$$i289$i = 0, $$0$$i299$i = 0, $$0$$i3$i = 0, $$0$$i30$us$i = 0, $$0$$i309$i = 0, $$0$$i319$i = 0;
 var $$0$$i329$i = 0, $$0$$i339$i = 0, $$0$$i349$i = 0, $$0$$i35$i = 0, $$0$$i359$i = 0, $$0$$i369$i = 0, $$0$$i379$i = 0, $$0$$i389$i = 0, $$0$$i399$1$i = 0, $$0$$i399$2$i = 0, $$0$$i399$3$i = 0, $$0$$i399$i = 0, $$0$$i409$i = 0, $$0$$i419$i = 0, $$0$$i429$i = 0, $$0$$i43$i = 0, $$0$$i439$i = 0, $$0$$i449$i = 0, $$0$$i459$i = 0, $$0$$i469$i = 0;
 var $$0$$i479$i = 0, $$0$$i489$i = 0, $$0$$i499$i = 0, $$0$$i509$i = 0, $$0$$i51$i = 0, $$0$$i519$i = 0, $$0$$i529$i = 0, $$0$$i539$i = 0, $$0$$i549$i = 0, $$0$$i559$i = 0, $$0$$i59$i = 0, $$0$$i6$i = 0, $$0$$i67$i = 0, $$0$$i75$i = 0, $$0$$i83$i = 0, $$0$$i91$i = 0, $$0$$i99$i = 0, $$01$i$us$i = 0, $$01$i12$i = 0, $$01$i17$i = 0;
 var $$01$i22$i = 0, $$01$i28$us$i = 0, $$01$i4$i = 0, $$02$i$i = 0, $$02$i1$i = 0, $$02$i105$i = 0, $$02$i113$i = 0, $$02$i121$i = 0, $$02$i129$i = 0, $$02$i137$i = 0, $$02$i145$i = 0, $$02$i153$i = 0, $$02$i161$i = 0, $$02$i169$i = 0, $$02$i17$i = 0, $$02$i177$i = 0, $$02$i187$i = 0, $$02$i197$i = 0, $$02$i207$i = 0, $$02$i217$i = 0;
 var $$02$i227$i = 0, $$02$i237$i = 0, $$02$i247$i = 0, $$02$i25$i = 0, $$02$i257$i = 0, $$02$i267$i = 0, $$02$i277$i = 0, $$02$i287$i = 0, $$02$i297$i = 0, $$02$i307$i = 0, $$02$i317$i = 0, $$02$i327$i = 0, $$02$i33$i = 0, $$02$i337$i = 0, $$02$i347$i = 0, $$02$i357$i = 0, $$02$i367$i = 0, $$02$i377$i = 0, $$02$i387$i = 0, $$02$i397$1$i = 0;
 var $$02$i397$2$i = 0, $$02$i397$3$i = 0, $$02$i397$i = 0, $$02$i407$i = 0, $$02$i41$i = 0, $$02$i417$i = 0, $$02$i427$i = 0, $$02$i437$i = 0, $$02$i447$i = 0, $$02$i457$i = 0, $$02$i467$i = 0, $$02$i477$i = 0, $$02$i487$i = 0, $$02$i49$i = 0, $$02$i497$i = 0, $$02$i507$i = 0, $$02$i517$i = 0, $$02$i527$i = 0, $$02$i537$i = 0, $$02$i547$i = 0;
 var $$02$i557$i = 0, $$02$i57$i = 0, $$02$i65$i = 0, $$02$i73$i = 0, $$02$i81$i = 0, $$02$i89$i = 0, $$02$i9$i = 0, $$02$i97$i = 0, $$1$i = 0, $$1$i10 = 0, $$2$us$i = 0, $$idx$val$i = 0, $$idx$val$i$i = 0, $$idx$val$pre$i = 0, $$idx$val$pre$i$i = 0, $$idx1$i = 0, $$idx1$val$i = 0, $$idx1$val$i$i = 0, $$lcssa401 = 0, $$lcssa402 = 0;
 var $$lcssa404 = 0, $$lcssa405 = 0, $$lcssa406 = 0, $$lcssa407 = 0, $$lcssa408 = 0, $$lcssa409 = 0, $$lcssa410 = 0, $$lcssa411 = 0, $$lcssa412 = 0, $$lcssa413 = 0, $$lcssa414 = 0, $$lcssa415 = 0, $$lcssa416 = 0, $$lcssa417 = 0, $$lcssa418 = 0, $$lcssa419 = 0, $$lcssa420 = 0, $$lcssa421 = 0, $$lcssa422 = 0, $$lcssa423 = 0;
 var $$lcssa424 = 0, $$lcssa427 = 0, $$lcssa428 = 0, $$lcssa429 = 0, $$lcssa430 = 0, $$lcssa432 = 0, $$lcssa433 = 0, $$lcssa434 = 0, $$lcssa435 = 0, $$lcssa436 = 0, $$lcssa437 = 0, $$lcssa438 = 0, $$lcssa439 = 0, $$lcssa440 = 0, $$lcssa441 = 0, $$lcssa442 = 0, $$lcssa443 = 0, $$lcssa444 = 0, $$lcssa445 = 0, $$lcssa446 = 0;
 var $$lcssa447 = 0, $$lcssa448 = 0, $$lcssa449 = 0, $$lcssa450 = 0, $$lcssa451 = 0, $$lcssa452 = 0, $$lcssa453 = 0, $$lcssa454 = 0, $$lcssa455 = 0, $$lcssa456 = 0, $$lcssa457 = 0, $$lcssa458 = 0, $$lcssa459 = 0, $$lcssa460 = 0, $$lcssa461 = 0, $$lcssa462 = 0, $$lcssa463 = 0, $$lcssa464 = 0, $$lcssa465 = 0, $$lcssa466 = 0;
 var $$lcssa467 = 0, $$lcssa468 = 0, $$lcssa469 = 0, $$lcssa470 = 0, $$lcssa471 = 0, $$phi$trans$insert705$i = 0, $$phi$trans$insert708$i = 0, $$phi$trans$insert711$i = 0, $$phi$trans$insert714$i = 0, $$phi$trans$insert717$i = 0, $$phi$trans$insert720$i = 0, $$phi$trans$insert723$i = 0, $$phi$trans$insert726$i = 0, $$phi$trans$insert729$i = 0, $$phi$trans$insert732$i = 0, $$phi$trans$insert736$i = 0, $$pn$i = 0, $$pn100$i = 0, $$pre = 0, $$pre$i = 0;
 var $$pre$i$i = 0, $$pre$i$i$lcssa = 0, $$pre$i$us$i = 0, $$pre$i1 = 0, $$pre$i101$i = 0, $$pre$i101$i$lcssa = 0, $$pre$i109$i = 0, $$pre$i109$i$lcssa = 0, $$pre$i117$i = 0, $$pre$i117$i$lcssa = 0, $$pre$i125$i = 0, $$pre$i125$i$lcssa = 0, $$pre$i13$i = 0, $$pre$i13$i$lcssa = 0, $$pre$i13$i8 = 0, $$pre$i133$i = 0, $$pre$i133$i$lcssa = 0, $$pre$i141$i = 0, $$pre$i141$i$lcssa = 0, $$pre$i149$i = 0;
 var $$pre$i149$i$lcssa = 0, $$pre$i157$i = 0, $$pre$i157$i$lcssa = 0, $$pre$i165$i = 0, $$pre$i165$i$lcssa = 0, $$pre$i173$i = 0, $$pre$i173$i$lcssa = 0, $$pre$i18$i = 0, $$pre$i181$i = 0, $$pre$i181$i$lcssa = 0, $$pre$i191$i = 0, $$pre$i191$i$lcssa = 0, $$pre$i201$i = 0, $$pre$i201$i$lcssa = 0, $$pre$i21$i = 0, $$pre$i21$i$lcssa = 0, $$pre$i211$i = 0, $$pre$i211$i$lcssa = 0, $$pre$i221$i = 0, $$pre$i221$i$lcssa = 0;
 var $$pre$i23$i = 0, $$pre$i231$i = 0, $$pre$i231$i$lcssa = 0, $$pre$i241$i = 0, $$pre$i241$i$lcssa = 0, $$pre$i251$i = 0, $$pre$i251$i$lcssa = 0, $$pre$i261$i = 0, $$pre$i261$i$lcssa = 0, $$pre$i281$i = 0, $$pre$i281$i$lcssa = 0, $$pre$i29$i = 0, $$pre$i29$i$lcssa = 0, $$pre$i29$us$i = 0, $$pre$i291$i = 0, $$pre$i291$i$lcssa = 0, $$pre$i301$i = 0, $$pre$i301$i$lcssa = 0, $$pre$i311$i = 0, $$pre$i311$i$lcssa = 0;
 var $$pre$i321$i = 0, $$pre$i321$i$lcssa = 0, $$pre$i331$i = 0, $$pre$i331$i$lcssa = 0, $$pre$i341$i = 0, $$pre$i341$i$lcssa = 0, $$pre$i351$i = 0, $$pre$i351$i$lcssa = 0, $$pre$i361$i = 0, $$pre$i361$i$lcssa = 0, $$pre$i37$i = 0, $$pre$i37$i$lcssa = 0, $$pre$i371$i = 0, $$pre$i371$i$lcssa = 0, $$pre$i381$i = 0, $$pre$i381$i$lcssa = 0, $$pre$i391$i = 0, $$pre$i391$i$lcssa = 0, $$pre$i401$1$i = 0, $$pre$i401$1$i$lcssa = 0;
 var $$pre$i401$2$i = 0, $$pre$i401$2$i$lcssa = 0, $$pre$i401$3$i = 0, $$pre$i401$3$i$lcssa = 0, $$pre$i401$i = 0, $$pre$i401$i$lcssa = 0, $$pre$i411$i = 0, $$pre$i411$i$lcssa = 0, $$pre$i421$i = 0, $$pre$i421$i$lcssa = 0, $$pre$i431$i = 0, $$pre$i431$i$lcssa = 0, $$pre$i45$i = 0, $$pre$i45$i$lcssa = 0, $$pre$i451$i = 0, $$pre$i451$i$lcssa = 0, $$pre$i461$i = 0, $$pre$i461$i$lcssa = 0, $$pre$i471$i = 0, $$pre$i471$i$lcssa = 0;
 var $$pre$i481$i = 0, $$pre$i481$i$lcssa = 0, $$pre$i491$i = 0, $$pre$i491$i$lcssa = 0, $$pre$i5$i = 0, $$pre$i5$i$lcssa = 0, $$pre$i5$i4 = 0, $$pre$i501$i = 0, $$pre$i501$i$lcssa = 0, $$pre$i511$i = 0, $$pre$i511$i$lcssa = 0, $$pre$i521$i = 0, $$pre$i521$i$lcssa = 0, $$pre$i53$i = 0, $$pre$i53$i$lcssa = 0, $$pre$i531$i = 0, $$pre$i531$i$lcssa = 0, $$pre$i541$i = 0, $$pre$i541$i$lcssa = 0, $$pre$i551$i = 0;
 var $$pre$i551$i$lcssa = 0, $$pre$i561$i = 0, $$pre$i561$i$lcssa = 0, $$pre$i61$i = 0, $$pre$i61$i$lcssa = 0, $$pre$i77$i = 0, $$pre$i77$i$lcssa = 0, $$pre$i85$i = 0, $$pre$i85$i$lcssa = 0, $$pre$i93$i = 0, $$pre$i93$i$lcssa = 0, $$pre$phiZ2D = 0, $$pre167 = 0, $$pre704$i = 0, $$pre706$i = 0, $$pre707$i = 0, $$pre709$i = 0, $$pre710$i = 0, $$pre712$i = 0, $$pre713$i = 0;
 var $$pre715$i = 0, $$pre716$i = 0, $$pre718$i = 0, $$pre719$i = 0, $$pre721$i = 0, $$pre722$i = 0, $$pre724$i = 0, $$pre725$i = 0, $$pre727$i = 0, $$pre728$i = 0, $$pre730$i = 0, $$pre731$i = 0, $$pre733$i = 0, $$pre734$i = 0, $$pre735$i = 0, $$pre737$i = 0, $$pre96$pre$i = 0, $$pre97$i = 0, $$pre97$pre$i = 0, $0 = 0;
 var $1 = 0, $10 = 0, $100 = 0, $1000 = 0, $1001 = 0, $1002 = 0, $1003 = 0, $1004 = 0, $1005 = 0, $1006 = 0, $1007 = 0, $1008 = 0, $1009 = 0, $101 = 0, $1010 = 0, $1011 = 0, $1012 = 0, $1013 = 0, $1014 = 0, $1015 = 0;
 var $1016 = 0, $1017 = 0, $1018 = 0, $1019 = 0, $102 = 0, $1020 = 0, $1021 = 0, $1022 = 0, $1023 = 0, $1024 = 0, $1025 = 0, $1026 = 0, $1027 = 0, $1028 = 0, $1029 = 0, $103 = 0, $1030 = 0, $1031 = 0, $1032 = 0, $1033 = 0;
 var $1034 = 0, $1035 = 0, $1036 = 0, $1037 = 0, $1038 = 0, $1039 = 0, $104 = 0, $1040 = 0, $1041 = 0, $1042 = 0, $1043 = 0, $1044 = 0, $1045 = 0, $1046 = 0, $1047 = 0, $1048 = 0, $1049 = 0, $105 = 0, $1050 = 0, $1051 = 0;
 var $1052 = 0, $1053 = 0, $1054 = 0, $1055 = 0, $1056 = 0, $1057 = 0, $1058 = 0, $1059 = 0, $106 = 0, $1060 = 0, $1061 = 0, $1062 = 0, $1063 = 0, $1064 = 0, $1065 = 0, $1066 = 0, $1067 = 0, $1068 = 0, $1069 = 0, $107 = 0;
 var $1070 = 0, $1071 = 0, $1072 = 0, $1073 = 0, $1074 = 0, $1075 = 0, $1076 = 0, $1077 = 0, $1078 = 0, $1079 = 0, $108 = 0, $1080 = 0, $1081 = 0, $1082 = 0, $1083 = 0, $1084 = 0, $1085 = 0, $1086 = 0, $1087 = 0, $1088 = 0;
 var $1089 = 0, $109 = 0, $1090 = 0, $1091 = 0, $1092 = 0, $1093 = 0, $1094 = 0, $1095 = 0, $1096 = 0, $1097 = 0, $1098 = 0, $1099 = 0, $11 = 0, $110 = 0, $1100 = 0, $1101 = 0, $1102 = 0, $1103 = 0, $1104 = 0, $1105 = 0;
 var $1106 = 0, $1107 = 0, $1108 = 0, $1109 = 0, $111 = 0, $1110 = 0, $1111 = 0, $1112 = 0, $1113 = 0, $1114 = 0, $1115 = 0, $1116 = 0, $1117 = 0, $1118 = 0, $1119 = 0, $112 = 0, $1120 = 0, $1121 = 0, $1122 = 0, $1123 = 0;
 var $1124 = 0, $1125 = 0, $1126 = 0, $1127 = 0, $1128 = 0, $1129 = 0, $113 = 0, $1130 = 0, $1131 = 0, $1132 = 0, $1133 = 0, $1134 = 0, $1135 = 0, $1136 = 0, $1137 = 0, $1138 = 0, $1139 = 0, $114 = 0, $1140 = 0, $1141 = 0;
 var $1142 = 0, $1143 = 0, $1144 = 0, $1145 = 0, $1146 = 0, $1147 = 0, $1148 = 0, $1149 = 0, $115 = 0, $1150 = 0, $1151 = 0, $1152 = 0, $1153 = 0, $1154 = 0, $1155 = 0, $1156 = 0, $1157 = 0, $1158 = 0, $1159 = 0, $116 = 0;
 var $1160 = 0, $1161 = 0, $1162 = 0, $1163 = 0, $1164 = 0, $1165 = 0, $1166 = 0, $1167 = 0, $1168 = 0, $1169 = 0, $117 = 0, $1170 = 0, $1171 = 0, $1172 = 0, $1173 = 0, $1174 = 0, $1175 = 0, $1176 = 0, $1177 = 0, $1178 = 0;
 var $1179 = 0, $118 = 0, $1180 = 0, $1181 = 0, $1182 = 0, $1183 = 0, $1184 = 0, $1185 = 0, $1186 = 0, $1187 = 0, $1188 = 0, $1189 = 0, $119 = 0, $1190 = 0, $1191 = 0, $1192 = 0, $1193 = 0, $1194 = 0, $1195 = 0, $1196 = 0;
 var $1197 = 0, $1198 = 0, $1199 = 0, $12 = 0, $120 = 0, $1200 = 0, $1201 = 0, $1202 = 0, $1203 = 0, $1204 = 0, $1205 = 0, $1206 = 0, $1207 = 0, $1208 = 0, $1209 = 0, $121 = 0, $1210 = 0, $1211 = 0, $1212 = 0, $1213 = 0;
 var $1214 = 0, $1215 = 0, $1216 = 0, $1217 = 0, $1218 = 0, $1219 = 0, $122 = 0, $1220 = 0, $1221 = 0, $1222 = 0, $1223 = 0, $1224 = 0, $1225 = 0, $1226 = 0, $1227 = 0, $1228 = 0, $1229 = 0, $123 = 0, $1230 = 0, $1231 = 0;
 var $1232 = 0, $1233 = 0, $1234 = 0, $1235 = 0, $1236 = 0, $1237 = 0, $1238 = 0, $1239 = 0, $124 = 0, $1240 = 0, $1241 = 0, $1242 = 0, $1243 = 0, $1244 = 0, $1245 = 0, $1246 = 0, $1247 = 0, $1248 = 0, $1249 = 0, $125 = 0;
 var $1250 = 0, $1251 = 0, $1252 = 0, $1253 = 0, $1254 = 0, $1255 = 0, $1256 = 0, $1257 = 0, $1258 = 0, $1259 = 0, $126 = 0, $1260 = 0, $1261 = 0, $1262 = 0, $1263 = 0, $1264 = 0, $1265 = 0, $1266 = 0, $1267 = 0, $1268 = 0;
 var $1269 = 0, $127 = 0, $1270 = 0, $1271 = 0, $1272 = 0, $1273 = 0, $1274 = 0, $1275 = 0, $1276 = 0, $1277 = 0, $1278 = 0, $1279 = 0, $128 = 0, $1280 = 0, $1281 = 0, $1282 = 0, $1283 = 0, $1284 = 0, $1285 = 0, $1286 = 0;
 var $1287 = 0, $1288 = 0, $1289 = 0, $129 = 0, $1290 = 0, $1291 = 0, $1292 = 0, $1293 = 0, $1294 = 0, $1295 = 0, $1296 = 0, $1297 = 0, $1298 = 0, $1299 = 0, $13 = 0, $130 = 0, $1300 = 0, $1301 = 0, $1302 = 0, $1303 = 0;
 var $1304 = 0, $1305 = 0, $1306 = 0, $1307 = 0, $1308 = 0, $1309 = 0, $131 = 0, $1310 = 0, $1311 = 0, $1312 = 0, $1313 = 0, $1314 = 0, $1315 = 0, $1316 = 0, $1317 = 0, $1318 = 0, $1319 = 0, $132 = 0, $1320 = 0, $1321 = 0;
 var $1322 = 0, $1323 = 0, $1324 = 0, $1325 = 0, $1326 = 0, $1327 = 0, $1328 = 0, $1329 = 0, $133 = 0, $1330 = 0, $1331 = 0, $1332 = 0, $1333 = 0, $1334 = 0, $1335 = 0, $1336 = 0, $1337 = 0, $1338 = 0, $1339 = 0, $134 = 0;
 var $1340 = 0, $1341 = 0, $1342 = 0, $1343 = 0, $1344 = 0, $1345 = 0, $1346 = 0, $1347 = 0, $1348 = 0, $1349 = 0, $135 = 0, $1350 = 0, $1351 = 0, $1352 = 0, $1353 = 0, $1354 = 0, $1355 = 0, $1356 = 0, $1357 = 0, $1358 = 0;
 var $1359 = 0, $136 = 0, $1360 = 0, $1361 = 0, $1362 = 0, $1363 = 0, $1364 = 0, $1365 = 0, $1366 = 0, $1367 = 0, $1368 = 0, $1369 = 0, $137 = 0, $1370 = 0, $1371 = 0, $1372 = 0, $1373 = 0, $1374 = 0, $1375 = 0, $1376 = 0;
 var $1377 = 0, $1378 = 0, $1379 = 0, $138 = 0, $1380 = 0, $1381 = 0, $1382 = 0, $1383 = 0, $1384 = 0, $1385 = 0, $1386 = 0, $1387 = 0, $1388 = 0, $1389 = 0, $139 = 0, $1390 = 0, $1391 = 0, $1392 = 0, $1393 = 0, $1394 = 0;
 var $1395 = 0, $1396 = 0, $1397 = 0, $1398 = 0, $1399 = 0, $14 = 0, $140 = 0, $1400 = 0, $1401 = 0, $1402 = 0, $1403 = 0, $1404 = 0, $1405 = 0, $1406 = 0, $1407 = 0, $1408 = 0, $1409 = 0, $141 = 0, $1410 = 0, $1411 = 0;
 var $1412 = 0, $1413 = 0, $1414 = 0, $1415 = 0, $1416 = 0, $1417 = 0, $1418 = 0, $1419 = 0, $142 = 0, $1420 = 0, $1421 = 0, $1422 = 0, $1423 = 0, $1424 = 0, $1425 = 0, $1426 = 0, $1427 = 0, $1428 = 0, $1429 = 0, $143 = 0;
 var $1430 = 0, $1431 = 0, $1432 = 0, $1433 = 0, $1434 = 0, $1435 = 0, $1436 = 0, $1437 = 0, $1438 = 0, $1439 = 0, $144 = 0, $1440 = 0, $1441 = 0, $1442 = 0, $1443 = 0, $1444 = 0, $1445 = 0, $1446 = 0, $1447 = 0, $1448 = 0;
 var $1449 = 0, $145 = 0, $1450 = 0, $1451 = 0, $1452 = 0, $1453 = 0, $1454 = 0, $1455 = 0, $1456 = 0, $1457 = 0, $1458 = 0, $1459 = 0, $146 = 0, $1460 = 0, $1461 = 0, $1462 = 0, $1463 = 0, $1464 = 0, $1465 = 0, $1466 = 0;
 var $1467 = 0, $1468 = 0, $1469 = 0, $147 = 0, $1470 = 0, $1471 = 0, $1472 = 0, $1473 = 0, $1474 = 0, $1475 = 0, $1476 = 0, $1477 = 0, $1478 = 0, $1479 = 0, $148 = 0, $1480 = 0, $1481 = 0, $1482 = 0, $1483 = 0, $1484 = 0;
 var $1485 = 0, $1486 = 0, $1487 = 0, $1488 = 0, $1489 = 0, $149 = 0, $1490 = 0, $1491 = 0, $1492 = 0, $1493 = 0, $1494 = 0, $1495 = 0, $1496 = 0, $1497 = 0, $1498 = 0, $1499 = 0, $15 = 0, $150 = 0, $1500 = 0, $1501 = 0;
 var $1502 = 0, $1503 = 0, $1504 = 0, $1505 = 0, $1506 = 0, $1507 = 0, $1508 = 0, $1509 = 0, $151 = 0, $1510 = 0, $1511 = 0, $1512 = 0, $1513 = 0, $1514 = 0, $1515 = 0, $1516 = 0, $1517 = 0, $1518 = 0, $1519 = 0, $152 = 0;
 var $1520 = 0, $1521 = 0, $1522 = 0, $1523 = 0, $1524 = 0, $1525 = 0, $1526 = 0, $1527 = 0, $1528 = 0, $1529 = 0, $153 = 0, $1530 = 0, $1531 = 0, $1532 = 0, $1533 = 0, $1534 = 0, $1535 = 0, $1536 = 0, $1537 = 0, $1538 = 0;
 var $1539 = 0, $154 = 0, $1540 = 0, $1541 = 0, $1542 = 0, $1543 = 0, $1544 = 0, $1545 = 0, $1546 = 0, $1547 = 0, $1548 = 0, $1549 = 0, $155 = 0, $1550 = 0, $1551 = 0, $1552 = 0, $1553 = 0, $1554 = 0, $1555 = 0, $1556 = 0;
 var $1557 = 0, $1558 = 0, $1559 = 0, $156 = 0, $1560 = 0, $1561 = 0, $1562 = 0, $1563 = 0, $1564 = 0, $1565 = 0, $1566 = 0, $1567 = 0, $1568 = 0, $1569 = 0, $157 = 0, $1570 = 0, $1571 = 0, $1572 = 0, $1573 = 0, $1574 = 0;
 var $1575 = 0, $1576 = 0, $1577 = 0, $1578 = 0, $1579 = 0, $158 = 0, $1580 = 0, $1581 = 0, $1582 = 0, $1583 = 0, $1584 = 0, $1585 = 0, $1586 = 0, $1587 = 0, $1588 = 0, $1589 = 0, $159 = 0, $1590 = 0, $1591 = 0, $1592 = 0;
 var $1593 = 0, $1594 = 0, $1595 = 0, $1596 = 0, $1597 = 0, $1598 = 0, $1599 = 0, $16 = 0, $160 = 0, $1600 = 0, $1601 = 0, $1602 = 0, $1603 = 0, $1604 = 0, $1605 = 0, $1606 = 0, $1607 = 0, $1608 = 0, $1609 = 0, $161 = 0;
 var $1610 = 0, $1611 = 0, $1612 = 0, $1613 = 0, $1614 = 0, $1615 = 0, $1616 = 0, $1617 = 0, $1618 = 0, $1619 = 0, $162 = 0, $1620 = 0, $1621 = 0, $1622 = 0, $1623 = 0, $1624 = 0, $1625 = 0, $1626 = 0, $1627 = 0, $1628 = 0;
 var $1629 = 0, $163 = 0, $1630 = 0, $1631 = 0, $1632 = 0, $1633 = 0, $1634 = 0, $1635 = 0, $1636 = 0, $1637 = 0, $1638 = 0, $1639 = 0, $164 = 0, $1640 = 0, $1641 = 0, $1642 = 0, $1643 = 0, $1644 = 0, $1645 = 0, $1646 = 0;
 var $1647 = 0, $1648 = 0, $1649 = 0, $165 = 0, $1650 = 0, $1651 = 0, $1652 = 0, $1653 = 0, $1654 = 0, $1655 = 0, $1656 = 0, $1657 = 0, $1658 = 0, $1659 = 0, $166 = 0, $1660 = 0, $1661 = 0, $1662 = 0, $1663 = 0, $1664 = 0;
 var $1665 = 0, $1666 = 0, $1667 = 0, $1668 = 0, $1669 = 0, $167 = 0, $1670 = 0, $1671 = 0, $1672 = 0, $1673 = 0, $1674 = 0, $1675 = 0, $1676 = 0, $1677 = 0, $1678 = 0, $1679 = 0, $168 = 0, $1680 = 0, $1681 = 0, $1682 = 0;
 var $1683 = 0, $1684 = 0, $1685 = 0, $1686 = 0, $1687 = 0, $1688 = 0, $1689 = 0, $169 = 0, $1690 = 0, $1691 = 0, $1692 = 0, $1693 = 0, $1694 = 0, $1695 = 0, $1696 = 0, $1697 = 0, $1698 = 0, $1699 = 0, $17 = 0, $170 = 0;
 var $1700 = 0, $1701 = 0, $1702 = 0, $1703 = 0, $1704 = 0, $1705 = 0, $1706 = 0, $1707 = 0, $1708 = 0, $1709 = 0, $171 = 0, $1710 = 0, $1711 = 0, $1712 = 0, $1713 = 0, $1714 = 0, $1715 = 0, $1716 = 0, $1717 = 0, $1718 = 0;
 var $1719 = 0, $172 = 0, $1720 = 0, $1721 = 0, $1722 = 0, $1723 = 0, $1724 = 0, $1725 = 0, $1726 = 0, $1727 = 0, $1728 = 0, $1729 = 0, $173 = 0, $1730 = 0, $1731 = 0, $1732 = 0, $1733 = 0, $1734 = 0, $1735 = 0, $1736 = 0;
 var $1737 = 0, $1738 = 0, $1739 = 0, $174 = 0, $1740 = 0, $1741 = 0, $1742 = 0, $1743 = 0, $1744 = 0, $1745 = 0, $1746 = 0, $1747 = 0, $1748 = 0, $1749 = 0, $175 = 0, $1750 = 0, $1751 = 0, $1752 = 0, $1753 = 0, $1754 = 0;
 var $1755 = 0, $1756 = 0, $1757 = 0, $1758 = 0, $1759 = 0, $176 = 0, $1760 = 0, $1761 = 0, $1762 = 0, $1763 = 0, $1764 = 0, $1765 = 0, $1766 = 0, $1767 = 0, $1768 = 0, $1769 = 0, $177 = 0, $1770 = 0, $1771 = 0, $1772 = 0;
 var $1773 = 0, $1774 = 0, $1775 = 0, $1776 = 0, $1777 = 0, $1778 = 0, $1779 = 0, $178 = 0, $1780 = 0, $1781 = 0, $1782 = 0, $1783 = 0, $1784 = 0, $1785 = 0, $1786 = 0, $1787 = 0, $1788 = 0, $1789 = 0, $179 = 0, $1790 = 0;
 var $1791 = 0, $1792 = 0, $1793 = 0, $1794 = 0, $1795 = 0, $1796 = 0, $1797 = 0, $1798 = 0, $1799 = 0, $18 = 0, $180 = 0, $1800 = 0, $1801 = 0, $1802 = 0, $1803 = 0, $1804 = 0, $1805 = 0, $1806 = 0, $1807 = 0, $1808 = 0;
 var $1809 = 0, $181 = 0, $1810 = 0, $1811 = 0, $1812 = 0, $1813 = 0, $1814 = 0, $1815 = 0, $1816 = 0, $1817 = 0, $1818 = 0, $1819 = 0, $182 = 0, $1820 = 0, $1821 = 0, $1822 = 0, $1823 = 0, $1824 = 0, $1825 = 0, $183 = 0;
 var $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0;
 var $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0;
 var $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0;
 var $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0;
 var $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0;
 var $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0;
 var $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0;
 var $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0;
 var $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0;
 var $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0;
 var $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0;
 var $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0;
 var $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0;
 var $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0, $432 = 0, $433 = 0, $434 = 0, $435 = 0;
 var $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0;
 var $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $469 = 0, $47 = 0, $470 = 0, $471 = 0;
 var $472 = 0, $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0, $486 = 0, $487 = 0, $488 = 0, $489 = 0, $49 = 0;
 var $490 = 0, $491 = 0, $492 = 0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $502 = 0, $503 = 0, $504 = 0, $505 = 0, $506 = 0, $507 = 0;
 var $508 = 0, $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $514 = 0, $515 = 0, $516 = 0, $517 = 0, $518 = 0, $519 = 0, $52 = 0, $520 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0, $525 = 0;
 var $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $534 = 0, $535 = 0, $536 = 0, $537 = 0, $538 = 0, $539 = 0, $54 = 0, $540 = 0, $541 = 0, $542 = 0, $543 = 0;
 var $544 = 0, $545 = 0, $546 = 0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0, $552 = 0, $553 = 0, $554 = 0, $555 = 0, $556 = 0, $557 = 0, $558 = 0, $559 = 0, $56 = 0, $560 = 0, $561 = 0;
 var $562 = 0, $563 = 0, $564 = 0, $565 = 0, $566 = 0, $567 = 0, $568 = 0, $569 = 0, $57 = 0, $570 = 0, $571 = 0, $572 = 0, $573 = 0, $574 = 0, $575 = 0, $576 = 0, $577 = 0, $578 = 0, $579 = 0, $58 = 0;
 var $580 = 0, $581 = 0, $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0, $587 = 0, $588 = 0, $589 = 0, $59 = 0, $590 = 0, $591 = 0, $592 = 0, $593 = 0, $594 = 0, $595 = 0, $596 = 0, $597 = 0, $598 = 0;
 var $599 = 0, $6 = 0, $60 = 0, $600 = 0, $601 = 0, $602 = 0, $603 = 0, $604 = 0, $605 = 0, $606 = 0, $607 = 0, $608 = 0, $609 = 0, $61 = 0, $610 = 0, $611 = 0, $612 = 0, $613 = 0, $614 = 0, $615 = 0;
 var $616 = 0, $617 = 0, $618 = 0, $619 = 0, $62 = 0, $620 = 0, $621 = 0, $622 = 0, $623 = 0, $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0, $629 = 0, $63 = 0, $630 = 0, $631 = 0, $632 = 0, $633 = 0;
 var $634 = 0, $635 = 0, $636 = 0, $637 = 0, $638 = 0, $639 = 0, $64 = 0, $640 = 0, $641 = 0, $642 = 0, $643 = 0, $644 = 0, $645 = 0, $646 = 0, $647 = 0, $648 = 0, $649 = 0, $65 = 0, $650 = 0, $651 = 0;
 var $652 = 0, $653 = 0, $654 = 0, $655 = 0, $656 = 0, $657 = 0, $658 = 0, $659 = 0, $66 = 0, $660 = 0, $661 = 0, $662 = 0, $663 = 0, $664 = 0, $665 = 0, $666 = 0, $667 = 0, $668 = 0, $669 = 0, $67 = 0;
 var $670 = 0, $671 = 0, $672 = 0, $673 = 0, $674 = 0, $675 = 0, $676 = 0, $677 = 0, $678 = 0, $679 = 0, $68 = 0, $680 = 0, $681 = 0, $682 = 0, $683 = 0, $684 = 0, $685 = 0, $686 = 0, $687 = 0, $688 = 0;
 var $689 = 0, $69 = 0, $690 = 0, $691 = 0, $692 = 0, $693 = 0, $694 = 0, $695 = 0, $696 = 0, $697 = 0, $698 = 0, $699 = 0, $7 = 0, $70 = 0, $700 = 0, $701 = 0, $702 = 0, $703 = 0, $704 = 0, $705 = 0;
 var $706 = 0, $707 = 0, $708 = 0, $709 = 0, $71 = 0, $710 = 0, $711 = 0, $712 = 0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $72 = 0, $720 = 0, $721 = 0, $722 = 0, $723 = 0;
 var $724 = 0, $725 = 0, $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0, $730 = 0, $731 = 0, $732 = 0, $733 = 0, $734 = 0, $735 = 0, $736 = 0, $737 = 0, $738 = 0, $739 = 0, $74 = 0, $740 = 0, $741 = 0;
 var $742 = 0, $743 = 0, $744 = 0, $745 = 0, $746 = 0, $747 = 0, $748 = 0, $749 = 0, $75 = 0, $750 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0, $755 = 0, $756 = 0, $757 = 0, $758 = 0, $759 = 0, $76 = 0;
 var $760 = 0, $761 = 0, $762 = 0, $763 = 0, $764 = 0, $765 = 0, $766 = 0, $767 = 0, $768 = 0, $769 = 0, $77 = 0, $770 = 0, $771 = 0, $772 = 0, $773 = 0, $774 = 0, $775 = 0, $776 = 0, $777 = 0, $778 = 0;
 var $779 = 0, $78 = 0, $780 = 0, $781 = 0, $782 = 0, $783 = 0, $784 = 0, $785 = 0, $786 = 0, $787 = 0, $788 = 0, $789 = 0, $79 = 0, $790 = 0, $791 = 0, $792 = 0, $793 = 0, $794 = 0, $795 = 0, $796 = 0;
 var $797 = 0, $798 = 0, $799 = 0, $8 = 0, $80 = 0, $800 = 0, $801 = 0, $802 = 0, $803 = 0, $804 = 0, $805 = 0, $806 = 0, $807 = 0, $808 = 0, $809 = 0, $81 = 0, $810 = 0, $811 = 0, $812 = 0, $813 = 0;
 var $814 = 0, $815 = 0, $816 = 0, $817 = 0, $818 = 0, $819 = 0, $82 = 0, $820 = 0, $821 = 0, $822 = 0, $823 = 0, $824 = 0, $825 = 0, $826 = 0, $827 = 0, $828 = 0, $829 = 0, $83 = 0, $830 = 0, $831 = 0;
 var $832 = 0, $833 = 0, $834 = 0, $835 = 0, $836 = 0, $837 = 0, $838 = 0, $839 = 0, $84 = 0, $840 = 0, $841 = 0, $842 = 0, $843 = 0, $844 = 0, $845 = 0, $846 = 0, $847 = 0, $848 = 0, $849 = 0, $85 = 0;
 var $850 = 0, $851 = 0, $852 = 0, $853 = 0, $854 = 0, $855 = 0, $856 = 0, $857 = 0, $858 = 0, $859 = 0, $86 = 0, $860 = 0, $861 = 0, $862 = 0, $863 = 0, $864 = 0, $865 = 0, $866 = 0, $867 = 0, $868 = 0;
 var $869 = 0, $87 = 0, $870 = 0, $871 = 0, $872 = 0, $873 = 0, $874 = 0, $875 = 0, $876 = 0, $877 = 0, $878 = 0, $879 = 0, $88 = 0, $880 = 0, $881 = 0, $882 = 0, $883 = 0, $884 = 0, $885 = 0, $886 = 0;
 var $887 = 0, $888 = 0, $889 = 0, $89 = 0, $890 = 0, $891 = 0, $892 = 0, $893 = 0, $894 = 0, $895 = 0, $896 = 0, $897 = 0, $898 = 0, $899 = 0, $9 = 0, $90 = 0, $900 = 0, $901 = 0, $902 = 0, $903 = 0;
 var $904 = 0, $905 = 0, $906 = 0, $907 = 0, $908 = 0, $909 = 0, $91 = 0, $910 = 0, $911 = 0, $912 = 0, $913 = 0, $914 = 0, $915 = 0, $916 = 0, $917 = 0, $918 = 0, $919 = 0, $92 = 0, $920 = 0, $921 = 0;
 var $922 = 0, $923 = 0, $924 = 0, $925 = 0, $926 = 0, $927 = 0, $928 = 0, $929 = 0, $93 = 0, $930 = 0, $931 = 0, $932 = 0, $933 = 0, $934 = 0, $935 = 0, $936 = 0, $937 = 0, $938 = 0, $939 = 0, $94 = 0;
 var $940 = 0, $941 = 0, $942 = 0, $943 = 0, $944 = 0, $945 = 0, $946 = 0, $947 = 0, $948 = 0, $949 = 0, $95 = 0, $950 = 0, $951 = 0, $952 = 0, $953 = 0, $954 = 0, $955 = 0, $956 = 0, $957 = 0, $958 = 0;
 var $959 = 0, $96 = 0, $960 = 0, $961 = 0, $962 = 0, $963 = 0, $964 = 0, $965 = 0, $966 = 0, $967 = 0, $968 = 0, $969 = 0, $97 = 0, $970 = 0, $971 = 0, $972 = 0, $973 = 0, $974 = 0, $975 = 0, $976 = 0;
 var $977 = 0, $978 = 0, $979 = 0, $98 = 0, $980 = 0, $981 = 0, $982 = 0, $983 = 0, $984 = 0, $985 = 0, $986 = 0, $987 = 0, $988 = 0, $989 = 0, $99 = 0, $990 = 0, $991 = 0, $992 = 0, $993 = 0, $994 = 0;
 var $995 = 0, $996 = 0, $997 = 0, $998 = 0, $999 = 0, $bit_rate$0$i = 0, $bit_rate$0$i$i = 0, $bit_rate$0$in$i = 0, $bit_rate$0$in$i$i = 0, $ch$047$i = 0, $ch$0637$i = 0, $ch$1632$i = 0, $ch$179$i = 0, $ch$2638$i = 0, $data_bits$0$lcssa$i = 0, $data_bits$039$$i = 0, $data_bits$039$i = 0, $data_bits$039$us$i = 0, $data_bits$1$us$i = 0, $data_bits$2$lcssa$i = 0;
 var $data_bits$242$i = 0, $data_bits$3$i = 0, $data_bits$4$i = 0, $data_bits$5$i = 0, $exitcond = 0, $exitcond$i = 0, $exitcond$i6 = 0, $exitcond166 = 0, $exitcond93$i = 0, $exitcond94$i = 0, $exitcond95$i = 0, $flushbits$0$i = 0, $gr$054$i = 0, $gr$0634$i = 0, $i$067$i = 0, $i$091 = 0, $i$156$us$i = 0, $ptr$01$i$i = 0, $ptr$01$i10$i = 0, $ptr$01$i106$i = 0;
 var $ptr$01$i114$i = 0, $ptr$01$i122$i = 0, $ptr$01$i130$i = 0, $ptr$01$i138$i = 0, $ptr$01$i146$i = 0, $ptr$01$i154$i = 0, $ptr$01$i162$i = 0, $ptr$01$i170$i = 0, $ptr$01$i178$i = 0, $ptr$01$i18$i = 0, $ptr$01$i188$i = 0, $ptr$01$i198$i = 0, $ptr$01$i2$i = 0, $ptr$01$i208$i = 0, $ptr$01$i218$i = 0, $ptr$01$i228$i = 0, $ptr$01$i238$i = 0, $ptr$01$i248$i = 0, $ptr$01$i258$i = 0, $ptr$01$i26$i = 0;
 var $ptr$01$i268$i = 0, $ptr$01$i278$i = 0, $ptr$01$i288$i = 0, $ptr$01$i298$i = 0, $ptr$01$i308$i = 0, $ptr$01$i318$i = 0, $ptr$01$i328$i = 0, $ptr$01$i338$i = 0, $ptr$01$i34$i = 0, $ptr$01$i348$i = 0, $ptr$01$i358$i = 0, $ptr$01$i368$i = 0, $ptr$01$i378$i = 0, $ptr$01$i388$i = 0, $ptr$01$i398$1$i = 0, $ptr$01$i398$2$i = 0, $ptr$01$i398$3$i = 0, $ptr$01$i398$i = 0, $ptr$01$i408$i = 0, $ptr$01$i418$i = 0;
 var $ptr$01$i42$i = 0, $ptr$01$i428$i = 0, $ptr$01$i438$i = 0, $ptr$01$i448$i = 0, $ptr$01$i458$i = 0, $ptr$01$i468$i = 0, $ptr$01$i478$i = 0, $ptr$01$i488$i = 0, $ptr$01$i498$i = 0, $ptr$01$i50$i = 0, $ptr$01$i508$i = 0, $ptr$01$i518$i = 0, $ptr$01$i528$i = 0, $ptr$01$i538$i = 0, $ptr$01$i548$i = 0, $ptr$01$i558$i = 0, $ptr$01$i58$i = 0, $ptr$01$i66$i = 0, $ptr$01$i74$i = 0, $ptr$01$i82$i = 0;
 var $ptr$01$i90$i = 0, $ptr$01$i98$i = 0, $region2Start$0$i$i = 0, $region2Start$0$i10$i = 0, $scale_bits$076$i = 0, $scale_bits$1$lcssa$i = 0, $scale_bits$1$lcssa$i$lcssa = 0, $scale_bits$265$i = 0, $scale_bits$3$lcssa$i = 0, $scale_bits$3$lcssa$i$lcssa = 0, $scale_bits$4$i = 0, $sfb$0$lcssa$i = 0, $sfb$040$i = 0, $sfb$040$us$i = 0, $sfb$143$i = 0, $sfb$277$i = 0, $sfb$3$lcssa$i = 0, $sfb$369$i = 0, $sfb$466$i = 0, $sfb$5$lcssa$i = 0;
 var $sfb$558$us$i = 0, $sfb_partition$075$i = 0, $sfb_partition$164$i = 0, $smax$i = 0, $split62$i = 0, $split63$i = 0, $tot_bits$053$i = 0, $tot_bits$1$lcssa$i = 0, $tot_bits$146$i = 0, $tot_bits$278$i = 0, $tot_bits$3$i = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer15 = 0, $vararg_buffer17 = 0, $vararg_buffer19 = 0, $vararg_buffer21 = 0, $vararg_buffer3 = 0, $vararg_buffer5 = 0, $vararg_ptr10 = 0;
 var $vararg_ptr11 = 0, $vararg_ptr12 = 0, $vararg_ptr13 = 0, $vararg_ptr14 = 0, $vararg_ptr7 = 0, $vararg_ptr8 = 0, $vararg_ptr9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96|0;
 $vararg_buffer21 = sp + 88|0;
 $vararg_buffer19 = sp + 80|0;
 $vararg_buffer17 = sp + 72|0;
 $vararg_buffer15 = sp + 64|0;
 $vararg_buffer5 = sp + 24|0;
 $vararg_buffer3 = sp + 16|0;
 $vararg_buffer1 = sp + 8|0;
 $vararg_buffer = sp;
 $0 = ((($gfc)) + 16|0);
 $1 = ((($gfc)) + 84744|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = ($2|0)==(0);
 if ($3) {
  $6 = ((($gfc)) + 120|0);
  $$idx$val$pre$i = HEAP32[$0>>2]|0;
  $$idx$val$i = $$idx$val$pre$i;$bit_rate$0$in$i = $6;
 } else {
  $4 = HEAP32[$0>>2]|0;
  $5 = ((83944 + ($4<<6)|0) + ($2<<2)|0);
  $$idx$val$i = $4;$bit_rate$0$in$i = $5;
 }
 $bit_rate$0$i = HEAP32[$bit_rate$0$in$i>>2]|0;
 $7 = ((($gfc)) + 84752|0);
 $8 = HEAP32[$7>>2]|0;
 $$idx1$i = ((($gfc)) + 64|0);
 $$idx1$val$i = HEAP32[$$idx1$i>>2]|0;
 $9 = ($$idx$val$i*72000)|0;
 $10 = (($9) + 72000)|0;
 $11 = Math_imul($10, $bit_rate$0$i)|0;
 $12 = (($11|0) / ($$idx1$val$i|0))&-1;
 $13 = (($12) + ($8))|0;
 $14 = $13 << 3;
 $15 = ((($gfc)) + 21320|0);
 $16 = HEAP32[$15>>2]|0;
 _drain_into_ancillary($gfc,$16);
 $17 = ((($gfc)) + 52128|0);
 $18 = HEAP32[$17>>2]|0;
 $19 = (((((($gfc)) + 39840|0) + (($18*48)|0)|0)) + 4|0);
 HEAP32[$19>>2] = 0;
 $20 = (((((($gfc)) + 39840|0) + (($18*48)|0)|0)) + 8|0);
 $21 = ((($gfc)) + 24|0);
 $22 = HEAP32[$21>>2]|0;
 _memset(($20|0),0,($22|0))|0;
 $23 = HEAP32[$$idx1$i>>2]|0;
 $24 = ($23|0)<(16000);
 $25 = HEAP32[$17>>2]|0;
 $26 = (((((($gfc)) + 39840|0) + (($25*48)|0)|0)) + 4|0);
 $27 = HEAP32[$26>>2]|0;
 if ($24) {
  $$02$i$i = 12;$37 = $25;$ptr$01$i$i = $27;
  while(1) {
   $28 = $ptr$01$i$i & 7;
   $29 = (8 - ($28))|0;
   $30 = ($$02$i$i|0)<($29|0);
   $$0$$i$i = $30 ? $$02$i$i : $29;
   $31 = (($$02$i$i) - ($$0$$i$i))|0;
   $32 = 4094 >>> $31;
   $33 = (($29) - ($$0$$i$i))|0;
   $34 = $32 << $33;
   $35 = $ptr$01$i$i >> 3;
   $36 = ((((((($gfc)) + 39840|0) + (($37*48)|0)|0)) + 8|0) + ($35)|0);
   $38 = HEAP8[$36>>0]|0;
   $39 = $38&255;
   $40 = $34 | $39;
   $41 = $40&255;
   HEAP8[$36>>0] = $41;
   $42 = (($$0$$i$i) + ($ptr$01$i$i))|0;
   $43 = ($31|0)>(0);
   $$pre$i$i = HEAP32[$17>>2]|0;
   if ($43) {
    $$02$i$i = $31;$37 = $$pre$i$i;$ptr$01$i$i = $42;
   } else {
    $$lcssa470 = $42;$$pre$i$i$lcssa = $$pre$i$i;
    break;
   }
  }
  $44 = (((((($gfc)) + 39840|0) + (($$pre$i$i$lcssa*48)|0)|0)) + 4|0);
  HEAP32[$44>>2] = $$lcssa470;
  $1787 = $$lcssa470;$1788 = $$pre$i$i$lcssa;
 } else {
  $$02$i1$i = 12;$54 = $25;$ptr$01$i2$i = $27;
  while(1) {
   $45 = $ptr$01$i2$i & 7;
   $46 = (8 - ($45))|0;
   $47 = ($$02$i1$i|0)<($46|0);
   $$0$$i3$i = $47 ? $$02$i1$i : $46;
   $48 = (($$02$i1$i) - ($$0$$i3$i))|0;
   $49 = 4095 >>> $48;
   $50 = (($46) - ($$0$$i3$i))|0;
   $51 = $49 << $50;
   $52 = $ptr$01$i2$i >> 3;
   $53 = ((((((($gfc)) + 39840|0) + (($54*48)|0)|0)) + 8|0) + ($52)|0);
   $55 = HEAP8[$53>>0]|0;
   $56 = $55&255;
   $57 = $51 | $56;
   $58 = $57&255;
   HEAP8[$53>>0] = $58;
   $59 = (($$0$$i3$i) + ($ptr$01$i2$i))|0;
   $60 = ($48|0)>(0);
   $$pre$i5$i = HEAP32[$17>>2]|0;
   if ($60) {
    $$02$i1$i = $48;$54 = $$pre$i5$i;$ptr$01$i2$i = $59;
   } else {
    $$lcssa471 = $59;$$pre$i5$i$lcssa = $$pre$i5$i;
    break;
   }
  }
  $61 = (((((($gfc)) + 39840|0) + (($$pre$i5$i$lcssa*48)|0)|0)) + 4|0);
  HEAP32[$61>>2] = $$lcssa471;
  $1787 = $$lcssa471;$1788 = $$pre$i5$i$lcssa;
 }
 $62 = ((($gfc)) + 16|0);
 $63 = HEAP32[$62>>2]|0;
 $$02$i557$i = 1;$73 = $1788;$ptr$01$i558$i = $1787;
 while(1) {
  $64 = $ptr$01$i558$i & 7;
  $65 = (8 - ($64))|0;
  $66 = ($$02$i557$i|0)<($65|0);
  $$0$$i559$i = $66 ? $$02$i557$i : $65;
  $67 = (($$02$i557$i) - ($$0$$i559$i))|0;
  $68 = $63 >> $67;
  $69 = (($65) - ($$0$$i559$i))|0;
  $70 = $68 << $69;
  $71 = $ptr$01$i558$i >> 3;
  $72 = ((((((($gfc)) + 39840|0) + (($73*48)|0)|0)) + 8|0) + ($71)|0);
  $74 = HEAP8[$72>>0]|0;
  $75 = $74&255;
  $76 = $70 | $75;
  $77 = $76&255;
  HEAP8[$72>>0] = $77;
  $78 = (($$0$$i559$i) + ($ptr$01$i558$i))|0;
  $79 = ($67|0)>(0);
  $$pre$i561$i = HEAP32[$17>>2]|0;
  if ($79) {
   $$02$i557$i = $67;$73 = $$pre$i561$i;$ptr$01$i558$i = $78;
  } else {
   $$lcssa469 = $78;$$pre$i561$i$lcssa = $$pre$i561$i;
   break;
  }
 }
 $80 = (((((($gfc)) + 39840|0) + (($$pre$i561$i$lcssa*48)|0)|0)) + 4|0);
 HEAP32[$80>>2] = $$lcssa469;
 $$02$i547$i = 2;$90 = $$pre$i561$i$lcssa;$ptr$01$i548$i = $$lcssa469;
 while(1) {
  $81 = $ptr$01$i548$i & 7;
  $82 = (8 - ($81))|0;
  $83 = ($$02$i547$i|0)<($82|0);
  $$0$$i549$i = $83 ? $$02$i547$i : $82;
  $84 = (($$02$i547$i) - ($$0$$i549$i))|0;
  $85 = 1 >>> $84;
  $86 = (($82) - ($$0$$i549$i))|0;
  $87 = $85 << $86;
  $88 = $ptr$01$i548$i >> 3;
  $89 = ((((((($gfc)) + 39840|0) + (($90*48)|0)|0)) + 8|0) + ($88)|0);
  $91 = HEAP8[$89>>0]|0;
  $92 = $91&255;
  $93 = $87 | $92;
  $94 = $93&255;
  HEAP8[$89>>0] = $94;
  $95 = (($$0$$i549$i) + ($ptr$01$i548$i))|0;
  $96 = ($84|0)>(0);
  $$pre$i551$i = HEAP32[$17>>2]|0;
  if ($96) {
   $$02$i547$i = $84;$90 = $$pre$i551$i;$ptr$01$i548$i = $95;
  } else {
   $$lcssa468 = $95;$$pre$i551$i$lcssa = $$pre$i551$i;
   break;
  }
 }
 $97 = (((((($gfc)) + 39840|0) + (($$pre$i551$i$lcssa*48)|0)|0)) + 4|0);
 HEAP32[$97>>2] = $$lcssa468;
 $98 = ((($gfc)) + 160|0);
 $99 = HEAP32[$98>>2]|0;
 $100 = ($99|0)==(0);
 $101 = $100&1;
 $$02$i537$i = 1;$111 = $$pre$i551$i$lcssa;$ptr$01$i538$i = $$lcssa468;
 while(1) {
  $102 = $ptr$01$i538$i & 7;
  $103 = (8 - ($102))|0;
  $104 = ($$02$i537$i|0)<($103|0);
  $$0$$i539$i = $104 ? $$02$i537$i : $103;
  $105 = (($$02$i537$i) - ($$0$$i539$i))|0;
  $106 = $101 >>> $105;
  $107 = (($103) - ($$0$$i539$i))|0;
  $108 = $106 << $107;
  $109 = $ptr$01$i538$i >> 3;
  $110 = ((((((($gfc)) + 39840|0) + (($111*48)|0)|0)) + 8|0) + ($109)|0);
  $112 = HEAP8[$110>>0]|0;
  $113 = $112&255;
  $114 = $108 | $113;
  $115 = $114&255;
  HEAP8[$110>>0] = $115;
  $116 = (($$0$$i539$i) + ($ptr$01$i538$i))|0;
  $117 = ($105|0)>(0);
  $$pre$i541$i = HEAP32[$17>>2]|0;
  if ($117) {
   $$02$i537$i = $105;$111 = $$pre$i541$i;$ptr$01$i538$i = $116;
  } else {
   $$lcssa467 = $116;$$pre$i541$i$lcssa = $$pre$i541$i;
   break;
  }
 }
 $118 = (((((($gfc)) + 39840|0) + (($$pre$i541$i$lcssa*48)|0)|0)) + 4|0);
 HEAP32[$118>>2] = $$lcssa467;
 $119 = HEAP32[$1>>2]|0;
 $$02$i527$i = 4;$129 = $$pre$i541$i$lcssa;$ptr$01$i528$i = $$lcssa467;
 while(1) {
  $120 = $ptr$01$i528$i & 7;
  $121 = (8 - ($120))|0;
  $122 = ($$02$i527$i|0)<($121|0);
  $$0$$i529$i = $122 ? $$02$i527$i : $121;
  $123 = (($$02$i527$i) - ($$0$$i529$i))|0;
  $124 = $119 >> $123;
  $125 = (($121) - ($$0$$i529$i))|0;
  $126 = $124 << $125;
  $127 = $ptr$01$i528$i >> 3;
  $128 = ((((((($gfc)) + 39840|0) + (($129*48)|0)|0)) + 8|0) + ($127)|0);
  $130 = HEAP8[$128>>0]|0;
  $131 = $130&255;
  $132 = $126 | $131;
  $133 = $132&255;
  HEAP8[$128>>0] = $133;
  $134 = (($$0$$i529$i) + ($ptr$01$i528$i))|0;
  $135 = ($123|0)>(0);
  $$pre$i531$i = HEAP32[$17>>2]|0;
  if ($135) {
   $$02$i527$i = $123;$129 = $$pre$i531$i;$ptr$01$i528$i = $134;
  } else {
   $$lcssa466 = $134;$$pre$i531$i$lcssa = $$pre$i531$i;
   break;
  }
 }
 $136 = (((((($gfc)) + 39840|0) + (($$pre$i531$i$lcssa*48)|0)|0)) + 4|0);
 HEAP32[$136>>2] = $$lcssa466;
 $137 = ((($gfc)) + 20|0);
 $138 = HEAP32[$137>>2]|0;
 $$02$i517$i = 2;$148 = $$pre$i531$i$lcssa;$ptr$01$i518$i = $$lcssa466;
 while(1) {
  $139 = $ptr$01$i518$i & 7;
  $140 = (8 - ($139))|0;
  $141 = ($$02$i517$i|0)<($140|0);
  $$0$$i519$i = $141 ? $$02$i517$i : $140;
  $142 = (($$02$i517$i) - ($$0$$i519$i))|0;
  $143 = $138 >> $142;
  $144 = (($140) - ($$0$$i519$i))|0;
  $145 = $143 << $144;
  $146 = $ptr$01$i518$i >> 3;
  $147 = ((((((($gfc)) + 39840|0) + (($148*48)|0)|0)) + 8|0) + ($146)|0);
  $149 = HEAP8[$147>>0]|0;
  $150 = $149&255;
  $151 = $145 | $150;
  $152 = $151&255;
  HEAP8[$147>>0] = $152;
  $153 = (($$0$$i519$i) + ($ptr$01$i518$i))|0;
  $154 = ($142|0)>(0);
  $$pre$i521$i = HEAP32[$17>>2]|0;
  if ($154) {
   $$02$i517$i = $142;$148 = $$pre$i521$i;$ptr$01$i518$i = $153;
  } else {
   $$lcssa465 = $153;$$pre$i521$i$lcssa = $$pre$i521$i;
   break;
  }
 }
 $155 = (((((($gfc)) + 39840|0) + (($$pre$i521$i$lcssa*48)|0)|0)) + 4|0);
 HEAP32[$155>>2] = $$lcssa465;
 $156 = HEAP32[$7>>2]|0;
 $$02$i507$i = 1;$166 = $$pre$i521$i$lcssa;$ptr$01$i508$i = $$lcssa465;
 while(1) {
  $157 = $ptr$01$i508$i & 7;
  $158 = (8 - ($157))|0;
  $159 = ($$02$i507$i|0)<($158|0);
  $$0$$i509$i = $159 ? $$02$i507$i : $158;
  $160 = (($$02$i507$i) - ($$0$$i509$i))|0;
  $161 = $156 >> $160;
  $162 = (($158) - ($$0$$i509$i))|0;
  $163 = $161 << $162;
  $164 = $ptr$01$i508$i >> 3;
  $165 = ((((((($gfc)) + 39840|0) + (($166*48)|0)|0)) + 8|0) + ($164)|0);
  $167 = HEAP8[$165>>0]|0;
  $168 = $167&255;
  $169 = $163 | $168;
  $170 = $169&255;
  HEAP8[$165>>0] = $170;
  $171 = (($$0$$i509$i) + ($ptr$01$i508$i))|0;
  $172 = ($160|0)>(0);
  $$pre$i511$i = HEAP32[$17>>2]|0;
  if ($172) {
   $$02$i507$i = $160;$166 = $$pre$i511$i;$ptr$01$i508$i = $171;
  } else {
   $$lcssa464 = $171;$$pre$i511$i$lcssa = $$pre$i511$i;
   break;
  }
 }
 $173 = (((((($gfc)) + 39840|0) + (($$pre$i511$i$lcssa*48)|0)|0)) + 4|0);
 HEAP32[$173>>2] = $$lcssa464;
 $174 = ((($gfc)) + 172|0);
 $175 = HEAP32[$174>>2]|0;
 $$02$i497$i = 1;$185 = $$pre$i511$i$lcssa;$ptr$01$i498$i = $$lcssa464;
 while(1) {
  $176 = $ptr$01$i498$i & 7;
  $177 = (8 - ($176))|0;
  $178 = ($$02$i497$i|0)<($177|0);
  $$0$$i499$i = $178 ? $$02$i497$i : $177;
  $179 = (($$02$i497$i) - ($$0$$i499$i))|0;
  $180 = $175 >> $179;
  $181 = (($177) - ($$0$$i499$i))|0;
  $182 = $180 << $181;
  $183 = $ptr$01$i498$i >> 3;
  $184 = ((((((($gfc)) + 39840|0) + (($185*48)|0)|0)) + 8|0) + ($183)|0);
  $186 = HEAP8[$184>>0]|0;
  $187 = $186&255;
  $188 = $182 | $187;
  $189 = $188&255;
  HEAP8[$184>>0] = $189;
  $190 = (($$0$$i499$i) + ($ptr$01$i498$i))|0;
  $191 = ($179|0)>(0);
  $$pre$i501$i = HEAP32[$17>>2]|0;
  if ($191) {
   $$02$i497$i = $179;$185 = $$pre$i501$i;$ptr$01$i498$i = $190;
  } else {
   $$lcssa463 = $190;$$pre$i501$i$lcssa = $$pre$i501$i;
   break;
  }
 }
 $192 = (((((($gfc)) + 39840|0) + (($$pre$i501$i$lcssa*48)|0)|0)) + 4|0);
 HEAP32[$192>>2] = $$lcssa463;
 $193 = ((($gfc)) + 180|0);
 $194 = HEAP32[$193>>2]|0;
 $$02$i487$i = 2;$204 = $$pre$i501$i$lcssa;$ptr$01$i488$i = $$lcssa463;
 while(1) {
  $195 = $ptr$01$i488$i & 7;
  $196 = (8 - ($195))|0;
  $197 = ($$02$i487$i|0)<($196|0);
  $$0$$i489$i = $197 ? $$02$i487$i : $196;
  $198 = (($$02$i487$i) - ($$0$$i489$i))|0;
  $199 = $194 >> $198;
  $200 = (($196) - ($$0$$i489$i))|0;
  $201 = $199 << $200;
  $202 = $ptr$01$i488$i >> 3;
  $203 = ((((((($gfc)) + 39840|0) + (($204*48)|0)|0)) + 8|0) + ($202)|0);
  $205 = HEAP8[$203>>0]|0;
  $206 = $205&255;
  $207 = $201 | $206;
  $208 = $207&255;
  HEAP8[$203>>0] = $208;
  $209 = (($$0$$i489$i) + ($ptr$01$i488$i))|0;
  $210 = ($198|0)>(0);
  $$pre$i491$i = HEAP32[$17>>2]|0;
  if ($210) {
   $$02$i487$i = $198;$204 = $$pre$i491$i;$ptr$01$i488$i = $209;
  } else {
   $$lcssa462 = $209;$$pre$i491$i$lcssa = $$pre$i491$i;
   break;
  }
 }
 $211 = (((((($gfc)) + 39840|0) + (($$pre$i491$i$lcssa*48)|0)|0)) + 4|0);
 HEAP32[$211>>2] = $$lcssa462;
 $212 = ((($gfc)) + 84756|0);
 $213 = HEAP32[$212>>2]|0;
 $$02$i477$i = 2;$223 = $$pre$i491$i$lcssa;$ptr$01$i478$i = $$lcssa462;
 while(1) {
  $214 = $ptr$01$i478$i & 7;
  $215 = (8 - ($214))|0;
  $216 = ($$02$i477$i|0)<($215|0);
  $$0$$i479$i = $216 ? $$02$i477$i : $215;
  $217 = (($$02$i477$i) - ($$0$$i479$i))|0;
  $218 = $213 >> $217;
  $219 = (($215) - ($$0$$i479$i))|0;
  $220 = $218 << $219;
  $221 = $ptr$01$i478$i >> 3;
  $222 = ((((((($gfc)) + 39840|0) + (($223*48)|0)|0)) + 8|0) + ($221)|0);
  $224 = HEAP8[$222>>0]|0;
  $225 = $224&255;
  $226 = $220 | $225;
  $227 = $226&255;
  HEAP8[$222>>0] = $227;
  $228 = (($$0$$i479$i) + ($ptr$01$i478$i))|0;
  $229 = ($217|0)>(0);
  $$pre$i481$i = HEAP32[$17>>2]|0;
  if ($229) {
   $$02$i477$i = $217;$223 = $$pre$i481$i;$ptr$01$i478$i = $228;
  } else {
   $$lcssa461 = $228;$$pre$i481$i$lcssa = $$pre$i481$i;
   break;
  }
 }
 $230 = (((((($gfc)) + 39840|0) + (($$pre$i481$i$lcssa*48)|0)|0)) + 4|0);
 HEAP32[$230>>2] = $$lcssa461;
 $231 = ((($gfc)) + 164|0);
 $232 = HEAP32[$231>>2]|0;
 $$02$i467$i = 1;$242 = $$pre$i481$i$lcssa;$ptr$01$i468$i = $$lcssa461;
 while(1) {
  $233 = $ptr$01$i468$i & 7;
  $234 = (8 - ($233))|0;
  $235 = ($$02$i467$i|0)<($234|0);
  $$0$$i469$i = $235 ? $$02$i467$i : $234;
  $236 = (($$02$i467$i) - ($$0$$i469$i))|0;
  $237 = $232 >> $236;
  $238 = (($234) - ($$0$$i469$i))|0;
  $239 = $237 << $238;
  $240 = $ptr$01$i468$i >> 3;
  $241 = ((((((($gfc)) + 39840|0) + (($242*48)|0)|0)) + 8|0) + ($240)|0);
  $243 = HEAP8[$241>>0]|0;
  $244 = $243&255;
  $245 = $239 | $244;
  $246 = $245&255;
  HEAP8[$241>>0] = $246;
  $247 = (($$0$$i469$i) + ($ptr$01$i468$i))|0;
  $248 = ($236|0)>(0);
  $$pre$i471$i = HEAP32[$17>>2]|0;
  if ($248) {
   $$02$i467$i = $236;$242 = $$pre$i471$i;$ptr$01$i468$i = $247;
  } else {
   $$lcssa460 = $247;$$pre$i471$i$lcssa = $$pre$i471$i;
   break;
  }
 }
 $249 = (((((($gfc)) + 39840|0) + (($$pre$i471$i$lcssa*48)|0)|0)) + 4|0);
 HEAP32[$249>>2] = $$lcssa460;
 $250 = ((($gfc)) + 168|0);
 $251 = HEAP32[$250>>2]|0;
 $$02$i457$i = 1;$261 = $$pre$i471$i$lcssa;$ptr$01$i458$i = $$lcssa460;
 while(1) {
  $252 = $ptr$01$i458$i & 7;
  $253 = (8 - ($252))|0;
  $254 = ($$02$i457$i|0)<($253|0);
  $$0$$i459$i = $254 ? $$02$i457$i : $253;
  $255 = (($$02$i457$i) - ($$0$$i459$i))|0;
  $256 = $251 >> $255;
  $257 = (($253) - ($$0$$i459$i))|0;
  $258 = $256 << $257;
  $259 = $ptr$01$i458$i >> 3;
  $260 = ((((((($gfc)) + 39840|0) + (($261*48)|0)|0)) + 8|0) + ($259)|0);
  $262 = HEAP8[$260>>0]|0;
  $263 = $262&255;
  $264 = $258 | $263;
  $265 = $264&255;
  HEAP8[$260>>0] = $265;
  $266 = (($$0$$i459$i) + ($ptr$01$i458$i))|0;
  $267 = ($255|0)>(0);
  $$pre$i461$i = HEAP32[$17>>2]|0;
  if ($267) {
   $$02$i457$i = $255;$261 = $$pre$i461$i;$ptr$01$i458$i = $266;
  } else {
   $$lcssa459 = $266;$$pre$i461$i$lcssa = $$pre$i461$i;
   break;
  }
 }
 $268 = (((((($gfc)) + 39840|0) + (($$pre$i461$i$lcssa*48)|0)|0)) + 4|0);
 HEAP32[$268>>2] = $$lcssa459;
 $269 = ((($gfc)) + 176|0);
 $270 = HEAP32[$269>>2]|0;
 $$02$i447$i = 2;$280 = $$pre$i461$i$lcssa;$ptr$01$i448$i = $$lcssa459;
 while(1) {
  $271 = $ptr$01$i448$i & 7;
  $272 = (8 - ($271))|0;
  $273 = ($$02$i447$i|0)<($272|0);
  $$0$$i449$i = $273 ? $$02$i447$i : $272;
  $274 = (($$02$i447$i) - ($$0$$i449$i))|0;
  $275 = $270 >> $274;
  $276 = (($272) - ($$0$$i449$i))|0;
  $277 = $275 << $276;
  $278 = $ptr$01$i448$i >> 3;
  $279 = ((((((($gfc)) + 39840|0) + (($280*48)|0)|0)) + 8|0) + ($278)|0);
  $281 = HEAP8[$279>>0]|0;
  $282 = $281&255;
  $283 = $277 | $282;
  $284 = $283&255;
  HEAP8[$279>>0] = $284;
  $285 = (($$0$$i449$i) + ($ptr$01$i448$i))|0;
  $286 = ($274|0)>(0);
  $$pre$i451$i = HEAP32[$17>>2]|0;
  if ($286) {
   $$02$i447$i = $274;$280 = $$pre$i451$i;$ptr$01$i448$i = $285;
  } else {
   $$lcssa458 = $285;$$pre$i451$i$lcssa = $$pre$i451$i;
   break;
  }
 }
 $287 = (((((($gfc)) + 39840|0) + (($$pre$i451$i$lcssa*48)|0)|0)) + 4|0);
 HEAP32[$287>>2] = $$lcssa458;
 $288 = HEAP32[$98>>2]|0;
 $289 = ($288|0)==(0);
 if ($289) {
  $1789 = $$lcssa458;
 } else {
  $$02$i437$i = 16;$ptr$01$i438$i = $$lcssa458;
  while(1) {
   $290 = $ptr$01$i438$i & 7;
   $291 = (8 - ($290))|0;
   $292 = ($$02$i437$i|0)<($291|0);
   $$0$$i439$i = $292 ? $$02$i437$i : $291;
   $293 = (($$02$i437$i) - ($$0$$i439$i))|0;
   $294 = (($$0$$i439$i) + ($ptr$01$i438$i))|0;
   $295 = ($293|0)>(0);
   if ($295) {
    $$02$i437$i = $293;$ptr$01$i438$i = $294;
   } else {
    $$lcssa457 = $294;
    break;
   }
  }
  HEAP32[$287>>2] = $$lcssa457;
  $1789 = $$lcssa457;
 }
 $296 = HEAP32[$62>>2]|0;
 $297 = ($296|0)==(1);
 $298 = ((($gfc)) + 21312|0);
 $299 = HEAP32[$298>>2]|0;
 do {
  if ($297) {
   $$02$i427$i = 9;$309 = $$pre$i451$i$lcssa;$ptr$01$i428$i = $1789;
   while(1) {
    $300 = $ptr$01$i428$i & 7;
    $301 = (8 - ($300))|0;
    $302 = ($$02$i427$i|0)<($301|0);
    $$0$$i429$i = $302 ? $$02$i427$i : $301;
    $303 = (($$02$i427$i) - ($$0$$i429$i))|0;
    $304 = $299 >> $303;
    $305 = (($301) - ($$0$$i429$i))|0;
    $306 = $304 << $305;
    $307 = $ptr$01$i428$i >> 3;
    $308 = ((((((($gfc)) + 39840|0) + (($309*48)|0)|0)) + 8|0) + ($307)|0);
    $310 = HEAP8[$308>>0]|0;
    $311 = $310&255;
    $312 = $306 | $311;
    $313 = $312&255;
    HEAP8[$308>>0] = $313;
    $314 = (($$0$$i429$i) + ($ptr$01$i428$i))|0;
    $315 = ($303|0)>(0);
    $$pre$i431$i = HEAP32[$17>>2]|0;
    if ($315) {
     $$02$i427$i = $303;$309 = $$pre$i431$i;$ptr$01$i428$i = $314;
    } else {
     $$lcssa434 = $314;$$pre$i431$i$lcssa = $$pre$i431$i;
     break;
    }
   }
   $316 = (((((($gfc)) + 39840|0) + (($$pre$i431$i$lcssa*48)|0)|0)) + 4|0);
   HEAP32[$316>>2] = $$lcssa434;
   $317 = ((($gfc)) + 72|0);
   $318 = HEAP32[$317>>2]|0;
   $319 = ($318|0)==(2);
   $320 = ((($gfc)) + 21316|0);
   $321 = HEAP32[$320>>2]|0;
   if ($319) {
    $$02$i417$i = 3;$331 = $$pre$i431$i$lcssa;$ptr$01$i418$i = $$lcssa434;
    while(1) {
     $322 = $ptr$01$i418$i & 7;
     $323 = (8 - ($322))|0;
     $324 = ($$02$i417$i|0)<($323|0);
     $$0$$i419$i = $324 ? $$02$i417$i : $323;
     $325 = (($$02$i417$i) - ($$0$$i419$i))|0;
     $326 = $321 >> $325;
     $327 = (($323) - ($$0$$i419$i))|0;
     $328 = $326 << $327;
     $329 = $ptr$01$i418$i >> 3;
     $330 = ((((((($gfc)) + 39840|0) + (($331*48)|0)|0)) + 8|0) + ($329)|0);
     $332 = HEAP8[$330>>0]|0;
     $333 = $332&255;
     $334 = $328 | $333;
     $335 = $334&255;
     HEAP8[$330>>0] = $335;
     $336 = (($$0$$i419$i) + ($ptr$01$i418$i))|0;
     $337 = ($325|0)>(0);
     $$pre$i421$i = HEAP32[$17>>2]|0;
     if ($337) {
      $$02$i417$i = $325;$331 = $$pre$i421$i;$ptr$01$i418$i = $336;
     } else {
      $$lcssa432 = $336;$$pre$i421$i$lcssa = $$pre$i421$i;
      break;
     }
    }
    $338 = (((((($gfc)) + 39840|0) + (($$pre$i421$i$lcssa*48)|0)|0)) + 4|0);
    HEAP32[$338>>2] = $$lcssa432;
    $$pre735$i = $$lcssa432;$1790 = $$pre$i421$i$lcssa;
   } else {
    $$02$i407$i = 5;$348 = $$pre$i431$i$lcssa;$ptr$01$i408$i = $$lcssa434;
    while(1) {
     $339 = $ptr$01$i408$i & 7;
     $340 = (8 - ($339))|0;
     $341 = ($$02$i407$i|0)<($340|0);
     $$0$$i409$i = $341 ? $$02$i407$i : $340;
     $342 = (($$02$i407$i) - ($$0$$i409$i))|0;
     $343 = $321 >> $342;
     $344 = (($340) - ($$0$$i409$i))|0;
     $345 = $343 << $344;
     $346 = $ptr$01$i408$i >> 3;
     $347 = ((((((($gfc)) + 39840|0) + (($348*48)|0)|0)) + 8|0) + ($346)|0);
     $349 = HEAP8[$347>>0]|0;
     $350 = $349&255;
     $351 = $345 | $350;
     $352 = $351&255;
     HEAP8[$347>>0] = $352;
     $353 = (($$0$$i409$i) + ($ptr$01$i408$i))|0;
     $354 = ($342|0)>(0);
     $$pre$i411$i = HEAP32[$17>>2]|0;
     if ($354) {
      $$02$i407$i = $342;$348 = $$pre$i411$i;$ptr$01$i408$i = $353;
     } else {
      $$lcssa433 = $353;$$pre$i411$i$lcssa = $$pre$i411$i;
      break;
     }
    }
    $355 = (((((($gfc)) + 39840|0) + (($$pre$i411$i$lcssa*48)|0)|0)) + 4|0);
    HEAP32[$355>>2] = $$lcssa433;
    $$pre735$i = $$lcssa433;$1790 = $$pre$i411$i$lcssa;
   }
   $356 = HEAP32[$317>>2]|0;
   $357 = ($356|0)>(0);
   if ($357) {
    $1791 = $$pre735$i;$1792 = $1790;$ch$0637$i = 0;
    while(1) {
     $358 = (((($gfc)) + 21328|0) + ($ch$0637$i<<4)|0);
     $359 = HEAP32[$358>>2]|0;
     $$02$i397$i = 1;$369 = $1792;$ptr$01$i398$i = $1791;
     while(1) {
      $360 = $ptr$01$i398$i & 7;
      $361 = (8 - ($360))|0;
      $362 = ($$02$i397$i|0)<($361|0);
      $$0$$i399$i = $362 ? $$02$i397$i : $361;
      $363 = (($$02$i397$i) - ($$0$$i399$i))|0;
      $364 = $359 >> $363;
      $365 = (($361) - ($$0$$i399$i))|0;
      $366 = $364 << $365;
      $367 = $ptr$01$i398$i >> 3;
      $368 = ((((((($gfc)) + 39840|0) + (($369*48)|0)|0)) + 8|0) + ($367)|0);
      $370 = HEAP8[$368>>0]|0;
      $371 = $370&255;
      $372 = $366 | $371;
      $373 = $372&255;
      HEAP8[$368>>0] = $373;
      $374 = (($$0$$i399$i) + ($ptr$01$i398$i))|0;
      $375 = ($363|0)>(0);
      $$pre$i401$i = HEAP32[$17>>2]|0;
      if ($375) {
       $$02$i397$i = $363;$369 = $$pre$i401$i;$ptr$01$i398$i = $374;
      } else {
       $$lcssa427 = $374;$$pre$i401$i$lcssa = $$pre$i401$i;
       break;
      }
     }
     $376 = (((((($gfc)) + 39840|0) + (($$pre$i401$i$lcssa*48)|0)|0)) + 4|0);
     HEAP32[$376>>2] = $$lcssa427;
     $377 = (((((($gfc)) + 21328|0) + ($ch$0637$i<<4)|0)) + 4|0);
     $378 = HEAP32[$377>>2]|0;
     $$02$i397$1$i = 1;$1234 = $$pre$i401$i$lcssa;$ptr$01$i398$1$i = $$lcssa427;
     while(1) {
      $1225 = $ptr$01$i398$1$i & 7;
      $1226 = (8 - ($1225))|0;
      $1227 = ($$02$i397$1$i|0)<($1226|0);
      $$0$$i399$1$i = $1227 ? $$02$i397$1$i : $1226;
      $1228 = (($$02$i397$1$i) - ($$0$$i399$1$i))|0;
      $1229 = $378 >> $1228;
      $1230 = (($1226) - ($$0$$i399$1$i))|0;
      $1231 = $1229 << $1230;
      $1232 = $ptr$01$i398$1$i >> 3;
      $1233 = ((((((($gfc)) + 39840|0) + (($1234*48)|0)|0)) + 8|0) + ($1232)|0);
      $1235 = HEAP8[$1233>>0]|0;
      $1236 = $1235&255;
      $1237 = $1231 | $1236;
      $1238 = $1237&255;
      HEAP8[$1233>>0] = $1238;
      $1239 = (($$0$$i399$1$i) + ($ptr$01$i398$1$i))|0;
      $1240 = ($1228|0)>(0);
      $$pre$i401$1$i = HEAP32[$17>>2]|0;
      if ($1240) {
       $$02$i397$1$i = $1228;$1234 = $$pre$i401$1$i;$ptr$01$i398$1$i = $1239;
      } else {
       $$lcssa428 = $1239;$$pre$i401$1$i$lcssa = $$pre$i401$1$i;
       break;
      }
     }
     $1241 = (((((($gfc)) + 39840|0) + (($$pre$i401$1$i$lcssa*48)|0)|0)) + 4|0);
     HEAP32[$1241>>2] = $$lcssa428;
     $1242 = (((((($gfc)) + 21328|0) + ($ch$0637$i<<4)|0)) + 8|0);
     $1243 = HEAP32[$1242>>2]|0;
     $$02$i397$2$i = 1;$1253 = $$pre$i401$1$i$lcssa;$ptr$01$i398$2$i = $$lcssa428;
     while(1) {
      $1244 = $ptr$01$i398$2$i & 7;
      $1245 = (8 - ($1244))|0;
      $1246 = ($$02$i397$2$i|0)<($1245|0);
      $$0$$i399$2$i = $1246 ? $$02$i397$2$i : $1245;
      $1247 = (($$02$i397$2$i) - ($$0$$i399$2$i))|0;
      $1248 = $1243 >> $1247;
      $1249 = (($1245) - ($$0$$i399$2$i))|0;
      $1250 = $1248 << $1249;
      $1251 = $ptr$01$i398$2$i >> 3;
      $1252 = ((((((($gfc)) + 39840|0) + (($1253*48)|0)|0)) + 8|0) + ($1251)|0);
      $1254 = HEAP8[$1252>>0]|0;
      $1255 = $1254&255;
      $1256 = $1250 | $1255;
      $1257 = $1256&255;
      HEAP8[$1252>>0] = $1257;
      $1258 = (($$0$$i399$2$i) + ($ptr$01$i398$2$i))|0;
      $1259 = ($1247|0)>(0);
      $$pre$i401$2$i = HEAP32[$17>>2]|0;
      if ($1259) {
       $$02$i397$2$i = $1247;$1253 = $$pre$i401$2$i;$ptr$01$i398$2$i = $1258;
      } else {
       $$lcssa429 = $1258;$$pre$i401$2$i$lcssa = $$pre$i401$2$i;
       break;
      }
     }
     $1260 = (((((($gfc)) + 39840|0) + (($$pre$i401$2$i$lcssa*48)|0)|0)) + 4|0);
     HEAP32[$1260>>2] = $$lcssa429;
     $1261 = (((((($gfc)) + 21328|0) + ($ch$0637$i<<4)|0)) + 12|0);
     $1262 = HEAP32[$1261>>2]|0;
     $$02$i397$3$i = 1;$1272 = $$pre$i401$2$i$lcssa;$ptr$01$i398$3$i = $$lcssa429;
     while(1) {
      $1263 = $ptr$01$i398$3$i & 7;
      $1264 = (8 - ($1263))|0;
      $1265 = ($$02$i397$3$i|0)<($1264|0);
      $$0$$i399$3$i = $1265 ? $$02$i397$3$i : $1264;
      $1266 = (($$02$i397$3$i) - ($$0$$i399$3$i))|0;
      $1267 = $1262 >> $1266;
      $1268 = (($1264) - ($$0$$i399$3$i))|0;
      $1269 = $1267 << $1268;
      $1270 = $ptr$01$i398$3$i >> 3;
      $1271 = ((((((($gfc)) + 39840|0) + (($1272*48)|0)|0)) + 8|0) + ($1270)|0);
      $1273 = HEAP8[$1271>>0]|0;
      $1274 = $1273&255;
      $1275 = $1269 | $1274;
      $1276 = $1275&255;
      HEAP8[$1271>>0] = $1276;
      $1277 = (($$0$$i399$3$i) + ($ptr$01$i398$3$i))|0;
      $1278 = ($1266|0)>(0);
      $$pre$i401$3$i = HEAP32[$17>>2]|0;
      if ($1278) {
       $$02$i397$3$i = $1266;$1272 = $$pre$i401$3$i;$ptr$01$i398$3$i = $1277;
      } else {
       $$lcssa430 = $1277;$$pre$i401$3$i$lcssa = $$pre$i401$3$i;
       break;
      }
     }
     $1279 = (((((($gfc)) + 39840|0) + (($$pre$i401$3$i$lcssa*48)|0)|0)) + 4|0);
     HEAP32[$1279>>2] = $$lcssa430;
     $1280 = (($ch$0637$i) + 1)|0;
     $1281 = HEAP32[$317>>2]|0;
     $1282 = ($1280|0)<($1281|0);
     if ($1282) {
      $1791 = $$lcssa430;$1792 = $$pre$i401$3$i$lcssa;$ch$0637$i = $1280;
     } else {
      $379 = $1281;$381 = $$pre$i401$3$i$lcssa;$gr$0634$i = 0;
      break;
     }
    }
   } else {
    $379 = $356;$381 = $1790;$gr$0634$i = 0;
   }
   while(1) {
    $380 = ($379|0)>(0);
    if ($380) {
     $$phi$trans$insert736$i = (((((($gfc)) + 39840|0) + (($381*48)|0)|0)) + 4|0);
     $$pre737$i = HEAP32[$$phi$trans$insert736$i>>2]|0;
     $1795 = $$pre737$i;$1796 = $381;$ch$1632$i = 0;
     while(1) {
      $382 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4768|0);
      $383 = HEAP32[$382>>2]|0;
      $384 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4844|0);
      $385 = HEAP32[$384>>2]|0;
      $386 = (($385) + ($383))|0;
      $$02$i387$i = 12;$396 = $1796;$ptr$01$i388$i = $1795;
      while(1) {
       $387 = $ptr$01$i388$i & 7;
       $388 = (8 - ($387))|0;
       $389 = ($$02$i387$i|0)<($388|0);
       $$0$$i389$i = $389 ? $$02$i387$i : $388;
       $390 = (($$02$i387$i) - ($$0$$i389$i))|0;
       $391 = $386 >> $390;
       $392 = (($388) - ($$0$$i389$i))|0;
       $393 = $391 << $392;
       $394 = $ptr$01$i388$i >> 3;
       $395 = ((((((($gfc)) + 39840|0) + (($396*48)|0)|0)) + 8|0) + ($394)|0);
       $397 = HEAP8[$395>>0]|0;
       $398 = $397&255;
       $399 = $393 | $398;
       $400 = $399&255;
       HEAP8[$395>>0] = $400;
       $401 = (($$0$$i389$i) + ($ptr$01$i388$i))|0;
       $402 = ($390|0)>(0);
       $$pre$i391$i = HEAP32[$17>>2]|0;
       if ($402) {
        $$02$i387$i = $390;$396 = $$pre$i391$i;$ptr$01$i388$i = $401;
       } else {
        $$lcssa404 = $401;$$pre$i391$i$lcssa = $$pre$i391$i;
        break;
       }
      }
      $403 = (((((($gfc)) + 39840|0) + (($$pre$i391$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$403>>2] = $$lcssa404;
      $404 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4772|0);
      $405 = HEAP32[$404>>2]|0;
      $406 = (($405|0) / 2)&-1;
      $$02$i377$i = 9;$416 = $$pre$i391$i$lcssa;$ptr$01$i378$i = $$lcssa404;
      while(1) {
       $407 = $ptr$01$i378$i & 7;
       $408 = (8 - ($407))|0;
       $409 = ($$02$i377$i|0)<($408|0);
       $$0$$i379$i = $409 ? $$02$i377$i : $408;
       $410 = (($$02$i377$i) - ($$0$$i379$i))|0;
       $411 = $406 >> $410;
       $412 = (($408) - ($$0$$i379$i))|0;
       $413 = $411 << $412;
       $414 = $ptr$01$i378$i >> 3;
       $415 = ((((((($gfc)) + 39840|0) + (($416*48)|0)|0)) + 8|0) + ($414)|0);
       $417 = HEAP8[$415>>0]|0;
       $418 = $417&255;
       $419 = $413 | $418;
       $420 = $419&255;
       HEAP8[$415>>0] = $420;
       $421 = (($$0$$i379$i) + ($ptr$01$i378$i))|0;
       $422 = ($410|0)>(0);
       $$pre$i381$i = HEAP32[$17>>2]|0;
       if ($422) {
        $$02$i377$i = $410;$416 = $$pre$i381$i;$ptr$01$i378$i = $421;
       } else {
        $$lcssa405 = $421;$$pre$i381$i$lcssa = $$pre$i381$i;
        break;
       }
      }
      $423 = (((((($gfc)) + 39840|0) + (($$pre$i381$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$423>>2] = $$lcssa405;
      $424 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4780|0);
      $425 = HEAP32[$424>>2]|0;
      $$02$i367$i = 8;$435 = $$pre$i381$i$lcssa;$ptr$01$i368$i = $$lcssa405;
      while(1) {
       $426 = $ptr$01$i368$i & 7;
       $427 = (8 - ($426))|0;
       $428 = ($$02$i367$i|0)<($427|0);
       $$0$$i369$i = $428 ? $$02$i367$i : $427;
       $429 = (($$02$i367$i) - ($$0$$i369$i))|0;
       $430 = $425 >> $429;
       $431 = (($427) - ($$0$$i369$i))|0;
       $432 = $430 << $431;
       $433 = $ptr$01$i368$i >> 3;
       $434 = ((((((($gfc)) + 39840|0) + (($435*48)|0)|0)) + 8|0) + ($433)|0);
       $436 = HEAP8[$434>>0]|0;
       $437 = $436&255;
       $438 = $432 | $437;
       $439 = $438&255;
       HEAP8[$434>>0] = $439;
       $440 = (($$0$$i369$i) + ($ptr$01$i368$i))|0;
       $441 = ($429|0)>(0);
       $$pre$i371$i = HEAP32[$17>>2]|0;
       if ($441) {
        $$02$i367$i = $429;$435 = $$pre$i371$i;$ptr$01$i368$i = $440;
       } else {
        $$lcssa406 = $440;$$pre$i371$i$lcssa = $$pre$i371$i;
        break;
       }
      }
      $442 = (((((($gfc)) + 39840|0) + (($$pre$i371$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$442>>2] = $$lcssa406;
      $443 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4784|0);
      $444 = HEAP32[$443>>2]|0;
      $$02$i357$i = 4;$454 = $$pre$i371$i$lcssa;$ptr$01$i358$i = $$lcssa406;
      while(1) {
       $445 = $ptr$01$i358$i & 7;
       $446 = (8 - ($445))|0;
       $447 = ($$02$i357$i|0)<($446|0);
       $$0$$i359$i = $447 ? $$02$i357$i : $446;
       $448 = (($$02$i357$i) - ($$0$$i359$i))|0;
       $449 = $444 >> $448;
       $450 = (($446) - ($$0$$i359$i))|0;
       $451 = $449 << $450;
       $452 = $ptr$01$i358$i >> 3;
       $453 = ((((((($gfc)) + 39840|0) + (($454*48)|0)|0)) + 8|0) + ($452)|0);
       $455 = HEAP8[$453>>0]|0;
       $456 = $455&255;
       $457 = $451 | $456;
       $458 = $457&255;
       HEAP8[$453>>0] = $458;
       $459 = (($$0$$i359$i) + ($ptr$01$i358$i))|0;
       $460 = ($448|0)>(0);
       $$pre$i361$i = HEAP32[$17>>2]|0;
       if ($460) {
        $$02$i357$i = $448;$454 = $$pre$i361$i;$ptr$01$i358$i = $459;
       } else {
        $$lcssa407 = $459;$$pre$i361$i$lcssa = $$pre$i361$i;
        break;
       }
      }
      $461 = (((((($gfc)) + 39840|0) + (($$pre$i361$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$461>>2] = $$lcssa407;
      $462 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4788|0);
      $463 = HEAP32[$462>>2]|0;
      $464 = ($463|0)==(0);
      if ($464) {
       $$02$i267$i = 1;$ptr$01$i268$i = $$lcssa407;
       while(1) {
        $618 = $ptr$01$i268$i & 7;
        $619 = (8 - ($618))|0;
        $620 = ($$02$i267$i|0)<($619|0);
        $$0$$i269$i = $620 ? $$02$i267$i : $619;
        $621 = (($$02$i267$i) - ($$0$$i269$i))|0;
        $622 = (($$0$$i269$i) + ($ptr$01$i268$i))|0;
        $623 = ($621|0)>(0);
        if ($623) {
         $$02$i267$i = $621;$ptr$01$i268$i = $622;
        } else {
         $$lcssa416 = $622;
         break;
        }
       }
       HEAP32[$461>>2] = $$lcssa416;
       $624 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4796|0);
       $625 = HEAP32[$624>>2]|0;
       $626 = ($625|0)==(14);
       if ($626) {
        HEAP32[$624>>2] = 16;
        $$pre725$i = HEAP32[$17>>2]|0;
        $$phi$trans$insert726$i = (((((($gfc)) + 39840|0) + (($$pre725$i*48)|0)|0)) + 4|0);
        $$pre727$i = HEAP32[$$phi$trans$insert726$i>>2]|0;
        $1803 = $$pre727$i;$1804 = $$pre725$i;$632 = 16;
       } else {
        $1803 = $$lcssa416;$1804 = $$pre$i361$i$lcssa;$632 = $625;
       }
       $$02$i257$i = 5;$637 = $1804;$ptr$01$i258$i = $1803;
       while(1) {
        $627 = $ptr$01$i258$i & 7;
        $628 = (8 - ($627))|0;
        $629 = ($$02$i257$i|0)<($628|0);
        $$0$$i259$i = $629 ? $$02$i257$i : $628;
        $630 = (($$02$i257$i) - ($$0$$i259$i))|0;
        $631 = $632 >> $630;
        $633 = (($628) - ($$0$$i259$i))|0;
        $634 = $631 << $633;
        $635 = $ptr$01$i258$i >> 3;
        $636 = ((((((($gfc)) + 39840|0) + (($637*48)|0)|0)) + 8|0) + ($635)|0);
        $638 = HEAP8[$636>>0]|0;
        $639 = $638&255;
        $640 = $634 | $639;
        $641 = $640&255;
        HEAP8[$636>>0] = $641;
        $642 = (($$0$$i259$i) + ($ptr$01$i258$i))|0;
        $643 = ($630|0)>(0);
        $$pre$i261$i = HEAP32[$17>>2]|0;
        if ($643) {
         $$02$i257$i = $630;$637 = $$pre$i261$i;$ptr$01$i258$i = $642;
        } else {
         $$lcssa417 = $642;$$pre$i261$i$lcssa = $$pre$i261$i;
         break;
        }
       }
       $644 = (((((($gfc)) + 39840|0) + (($$pre$i261$i$lcssa*48)|0)|0)) + 4|0);
       HEAP32[$644>>2] = $$lcssa417;
       $645 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4800|0);
       $646 = HEAP32[$645>>2]|0;
       $647 = ($646|0)==(14);
       if ($647) {
        HEAP32[$645>>2] = 16;
        $$pre728$i = HEAP32[$17>>2]|0;
        $$phi$trans$insert729$i = (((((($gfc)) + 39840|0) + (($$pre728$i*48)|0)|0)) + 4|0);
        $$pre730$i = HEAP32[$$phi$trans$insert729$i>>2]|0;
        $1805 = $$pre730$i;$1806 = $$pre728$i;$653 = 16;
       } else {
        $1805 = $$lcssa417;$1806 = $$pre$i261$i$lcssa;$653 = $646;
       }
       $$02$i247$i = 5;$658 = $1806;$ptr$01$i248$i = $1805;
       while(1) {
        $648 = $ptr$01$i248$i & 7;
        $649 = (8 - ($648))|0;
        $650 = ($$02$i247$i|0)<($649|0);
        $$0$$i249$i = $650 ? $$02$i247$i : $649;
        $651 = (($$02$i247$i) - ($$0$$i249$i))|0;
        $652 = $653 >> $651;
        $654 = (($649) - ($$0$$i249$i))|0;
        $655 = $652 << $654;
        $656 = $ptr$01$i248$i >> 3;
        $657 = ((((((($gfc)) + 39840|0) + (($658*48)|0)|0)) + 8|0) + ($656)|0);
        $659 = HEAP8[$657>>0]|0;
        $660 = $659&255;
        $661 = $655 | $660;
        $662 = $661&255;
        HEAP8[$657>>0] = $662;
        $663 = (($$0$$i249$i) + ($ptr$01$i248$i))|0;
        $664 = ($651|0)>(0);
        $$pre$i251$i = HEAP32[$17>>2]|0;
        if ($664) {
         $$02$i247$i = $651;$658 = $$pre$i251$i;$ptr$01$i248$i = $663;
        } else {
         $$lcssa418 = $663;$$pre$i251$i$lcssa = $$pre$i251$i;
         break;
        }
       }
       $665 = (((((($gfc)) + 39840|0) + (($$pre$i251$i$lcssa*48)|0)|0)) + 4|0);
       HEAP32[$665>>2] = $$lcssa418;
       $666 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4804|0);
       $667 = HEAP32[$666>>2]|0;
       $668 = ($667|0)==(14);
       if ($668) {
        HEAP32[$666>>2] = 16;
        $$pre731$i = HEAP32[$17>>2]|0;
        $$phi$trans$insert732$i = (((((($gfc)) + 39840|0) + (($$pre731$i*48)|0)|0)) + 4|0);
        $$pre733$i = HEAP32[$$phi$trans$insert732$i>>2]|0;
        $1807 = $$pre733$i;$1808 = $$pre731$i;$674 = 16;
       } else {
        $1807 = $$lcssa418;$1808 = $$pre$i251$i$lcssa;$674 = $667;
       }
       $$02$i237$i = 5;$679 = $1808;$ptr$01$i238$i = $1807;
       while(1) {
        $669 = $ptr$01$i238$i & 7;
        $670 = (8 - ($669))|0;
        $671 = ($$02$i237$i|0)<($670|0);
        $$0$$i239$i = $671 ? $$02$i237$i : $670;
        $672 = (($$02$i237$i) - ($$0$$i239$i))|0;
        $673 = $674 >> $672;
        $675 = (($670) - ($$0$$i239$i))|0;
        $676 = $673 << $675;
        $677 = $ptr$01$i238$i >> 3;
        $678 = ((((((($gfc)) + 39840|0) + (($679*48)|0)|0)) + 8|0) + ($677)|0);
        $680 = HEAP8[$678>>0]|0;
        $681 = $680&255;
        $682 = $676 | $681;
        $683 = $682&255;
        HEAP8[$678>>0] = $683;
        $684 = (($$0$$i239$i) + ($ptr$01$i238$i))|0;
        $685 = ($672|0)>(0);
        $$pre$i241$i = HEAP32[$17>>2]|0;
        if ($685) {
         $$02$i237$i = $672;$679 = $$pre$i241$i;$ptr$01$i238$i = $684;
        } else {
         $$lcssa419 = $684;$$pre$i241$i$lcssa = $$pre$i241$i;
         break;
        }
       }
       $686 = (((((($gfc)) + 39840|0) + (($$pre$i241$i$lcssa*48)|0)|0)) + 4|0);
       HEAP32[$686>>2] = $$lcssa419;
       $687 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4824|0);
       $688 = HEAP32[$687>>2]|0;
       $$02$i227$i = 4;$698 = $$pre$i241$i$lcssa;$ptr$01$i228$i = $$lcssa419;
       while(1) {
        $689 = $ptr$01$i228$i & 7;
        $690 = (8 - ($689))|0;
        $691 = ($$02$i227$i|0)<($690|0);
        $$0$$i229$i = $691 ? $$02$i227$i : $690;
        $692 = (($$02$i227$i) - ($$0$$i229$i))|0;
        $693 = $688 >> $692;
        $694 = (($690) - ($$0$$i229$i))|0;
        $695 = $693 << $694;
        $696 = $ptr$01$i228$i >> 3;
        $697 = ((((((($gfc)) + 39840|0) + (($698*48)|0)|0)) + 8|0) + ($696)|0);
        $699 = HEAP8[$697>>0]|0;
        $700 = $699&255;
        $701 = $695 | $700;
        $702 = $701&255;
        HEAP8[$697>>0] = $702;
        $703 = (($$0$$i229$i) + ($ptr$01$i228$i))|0;
        $704 = ($692|0)>(0);
        $$pre$i231$i = HEAP32[$17>>2]|0;
        if ($704) {
         $$02$i227$i = $692;$698 = $$pre$i231$i;$ptr$01$i228$i = $703;
        } else {
         $$lcssa420 = $703;$$pre$i231$i$lcssa = $$pre$i231$i;
         break;
        }
       }
       $705 = (((((($gfc)) + 39840|0) + (($$pre$i231$i$lcssa*48)|0)|0)) + 4|0);
       HEAP32[$705>>2] = $$lcssa420;
       $706 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4828|0);
       $707 = HEAP32[$706>>2]|0;
       $$02$i217$i = 3;$717 = $$pre$i231$i$lcssa;$ptr$01$i218$i = $$lcssa420;
       while(1) {
        $708 = $ptr$01$i218$i & 7;
        $709 = (8 - ($708))|0;
        $710 = ($$02$i217$i|0)<($709|0);
        $$0$$i219$i = $710 ? $$02$i217$i : $709;
        $711 = (($$02$i217$i) - ($$0$$i219$i))|0;
        $712 = $707 >> $711;
        $713 = (($709) - ($$0$$i219$i))|0;
        $714 = $712 << $713;
        $715 = $ptr$01$i218$i >> 3;
        $716 = ((((((($gfc)) + 39840|0) + (($717*48)|0)|0)) + 8|0) + ($715)|0);
        $718 = HEAP8[$716>>0]|0;
        $719 = $718&255;
        $720 = $714 | $719;
        $721 = $720&255;
        HEAP8[$716>>0] = $721;
        $722 = (($$0$$i219$i) + ($ptr$01$i218$i))|0;
        $723 = ($711|0)>(0);
        $$pre$i221$i = HEAP32[$17>>2]|0;
        if ($723) {
         $$02$i217$i = $711;$717 = $$pre$i221$i;$ptr$01$i218$i = $722;
        } else {
         $$lcssa421 = $722;$$pre$i221$i$lcssa = $$pre$i221$i;
         break;
        }
       }
       $724 = (((((($gfc)) + 39840|0) + (($$pre$i221$i$lcssa*48)|0)|0)) + 4|0);
       HEAP32[$724>>2] = $$lcssa421;
       $1801 = $$lcssa421;$1802 = $$pre$i221$i$lcssa;
      } else {
       $$02$i347$i = 1;$474 = $$pre$i361$i$lcssa;$ptr$01$i348$i = $$lcssa407;
       while(1) {
        $465 = $ptr$01$i348$i & 7;
        $466 = (8 - ($465))|0;
        $467 = ($$02$i347$i|0)<($466|0);
        $$0$$i349$i = $467 ? $$02$i347$i : $466;
        $468 = (($$02$i347$i) - ($$0$$i349$i))|0;
        $469 = 1 >>> $468;
        $470 = (($466) - ($$0$$i349$i))|0;
        $471 = $469 << $470;
        $472 = $ptr$01$i348$i >> 3;
        $473 = ((((((($gfc)) + 39840|0) + (($474*48)|0)|0)) + 8|0) + ($472)|0);
        $475 = HEAP8[$473>>0]|0;
        $476 = $475&255;
        $477 = $471 | $476;
        $478 = $477&255;
        HEAP8[$473>>0] = $478;
        $479 = (($$0$$i349$i) + ($ptr$01$i348$i))|0;
        $480 = ($468|0)>(0);
        $$pre$i351$i = HEAP32[$17>>2]|0;
        if ($480) {
         $$02$i347$i = $468;$474 = $$pre$i351$i;$ptr$01$i348$i = $479;
        } else {
         $$lcssa408 = $479;$$pre$i351$i$lcssa = $$pre$i351$i;
         break;
        }
       }
       $481 = (((((($gfc)) + 39840|0) + (($$pre$i351$i$lcssa*48)|0)|0)) + 4|0);
       HEAP32[$481>>2] = $$lcssa408;
       $482 = HEAP32[$462>>2]|0;
       $$02$i337$i = 2;$492 = $$pre$i351$i$lcssa;$ptr$01$i338$i = $$lcssa408;
       while(1) {
        $483 = $ptr$01$i338$i & 7;
        $484 = (8 - ($483))|0;
        $485 = ($$02$i337$i|0)<($484|0);
        $$0$$i339$i = $485 ? $$02$i337$i : $484;
        $486 = (($$02$i337$i) - ($$0$$i339$i))|0;
        $487 = $482 >> $486;
        $488 = (($484) - ($$0$$i339$i))|0;
        $489 = $487 << $488;
        $490 = $ptr$01$i338$i >> 3;
        $491 = ((((((($gfc)) + 39840|0) + (($492*48)|0)|0)) + 8|0) + ($490)|0);
        $493 = HEAP8[$491>>0]|0;
        $494 = $493&255;
        $495 = $489 | $494;
        $496 = $495&255;
        HEAP8[$491>>0] = $496;
        $497 = (($$0$$i339$i) + ($ptr$01$i338$i))|0;
        $498 = ($486|0)>(0);
        $$pre$i341$i = HEAP32[$17>>2]|0;
        if ($498) {
         $$02$i337$i = $486;$492 = $$pre$i341$i;$ptr$01$i338$i = $497;
        } else {
         $$lcssa409 = $497;$$pre$i341$i$lcssa = $$pre$i341$i;
         break;
        }
       }
       $499 = (((((($gfc)) + 39840|0) + (($$pre$i341$i$lcssa*48)|0)|0)) + 4|0);
       HEAP32[$499>>2] = $$lcssa409;
       $500 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4792|0);
       $501 = HEAP32[$500>>2]|0;
       $$02$i327$i = 1;$511 = $$pre$i341$i$lcssa;$ptr$01$i328$i = $$lcssa409;
       while(1) {
        $502 = $ptr$01$i328$i & 7;
        $503 = (8 - ($502))|0;
        $504 = ($$02$i327$i|0)<($503|0);
        $$0$$i329$i = $504 ? $$02$i327$i : $503;
        $505 = (($$02$i327$i) - ($$0$$i329$i))|0;
        $506 = $501 >> $505;
        $507 = (($503) - ($$0$$i329$i))|0;
        $508 = $506 << $507;
        $509 = $ptr$01$i328$i >> 3;
        $510 = ((((((($gfc)) + 39840|0) + (($511*48)|0)|0)) + 8|0) + ($509)|0);
        $512 = HEAP8[$510>>0]|0;
        $513 = $512&255;
        $514 = $508 | $513;
        $515 = $514&255;
        HEAP8[$510>>0] = $515;
        $516 = (($$0$$i329$i) + ($ptr$01$i328$i))|0;
        $517 = ($505|0)>(0);
        $$pre$i331$i = HEAP32[$17>>2]|0;
        if ($517) {
         $$02$i327$i = $505;$511 = $$pre$i331$i;$ptr$01$i328$i = $516;
        } else {
         $$lcssa410 = $516;$$pre$i331$i$lcssa = $$pre$i331$i;
         break;
        }
       }
       $518 = (((((($gfc)) + 39840|0) + (($$pre$i331$i$lcssa*48)|0)|0)) + 4|0);
       HEAP32[$518>>2] = $$lcssa410;
       $519 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4796|0);
       $520 = HEAP32[$519>>2]|0;
       $521 = ($520|0)==(14);
       if ($521) {
        HEAP32[$519>>2] = 16;
        $$pre719$i = HEAP32[$17>>2]|0;
        $$phi$trans$insert720$i = (((((($gfc)) + 39840|0) + (($$pre719$i*48)|0)|0)) + 4|0);
        $$pre721$i = HEAP32[$$phi$trans$insert720$i>>2]|0;
        $1797 = $$pre721$i;$1798 = $$pre719$i;$527 = 16;
       } else {
        $1797 = $$lcssa410;$1798 = $$pre$i331$i$lcssa;$527 = $520;
       }
       $$02$i317$i = 5;$532 = $1798;$ptr$01$i318$i = $1797;
       while(1) {
        $522 = $ptr$01$i318$i & 7;
        $523 = (8 - ($522))|0;
        $524 = ($$02$i317$i|0)<($523|0);
        $$0$$i319$i = $524 ? $$02$i317$i : $523;
        $525 = (($$02$i317$i) - ($$0$$i319$i))|0;
        $526 = $527 >> $525;
        $528 = (($523) - ($$0$$i319$i))|0;
        $529 = $526 << $528;
        $530 = $ptr$01$i318$i >> 3;
        $531 = ((((((($gfc)) + 39840|0) + (($532*48)|0)|0)) + 8|0) + ($530)|0);
        $533 = HEAP8[$531>>0]|0;
        $534 = $533&255;
        $535 = $529 | $534;
        $536 = $535&255;
        HEAP8[$531>>0] = $536;
        $537 = (($$0$$i319$i) + ($ptr$01$i318$i))|0;
        $538 = ($525|0)>(0);
        $$pre$i321$i = HEAP32[$17>>2]|0;
        if ($538) {
         $$02$i317$i = $525;$532 = $$pre$i321$i;$ptr$01$i318$i = $537;
        } else {
         $$lcssa411 = $537;$$pre$i321$i$lcssa = $$pre$i321$i;
         break;
        }
       }
       $539 = (((((($gfc)) + 39840|0) + (($$pre$i321$i$lcssa*48)|0)|0)) + 4|0);
       HEAP32[$539>>2] = $$lcssa411;
       $540 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4800|0);
       $541 = HEAP32[$540>>2]|0;
       $542 = ($541|0)==(14);
       if ($542) {
        HEAP32[$540>>2] = 16;
        $$pre722$i = HEAP32[$17>>2]|0;
        $$phi$trans$insert723$i = (((((($gfc)) + 39840|0) + (($$pre722$i*48)|0)|0)) + 4|0);
        $$pre724$i = HEAP32[$$phi$trans$insert723$i>>2]|0;
        $1799 = $$pre724$i;$1800 = $$pre722$i;$548 = 16;
       } else {
        $1799 = $$lcssa411;$1800 = $$pre$i321$i$lcssa;$548 = $541;
       }
       $$02$i307$i = 5;$553 = $1800;$ptr$01$i308$i = $1799;
       while(1) {
        $543 = $ptr$01$i308$i & 7;
        $544 = (8 - ($543))|0;
        $545 = ($$02$i307$i|0)<($544|0);
        $$0$$i309$i = $545 ? $$02$i307$i : $544;
        $546 = (($$02$i307$i) - ($$0$$i309$i))|0;
        $547 = $548 >> $546;
        $549 = (($544) - ($$0$$i309$i))|0;
        $550 = $547 << $549;
        $551 = $ptr$01$i308$i >> 3;
        $552 = ((((((($gfc)) + 39840|0) + (($553*48)|0)|0)) + 8|0) + ($551)|0);
        $554 = HEAP8[$552>>0]|0;
        $555 = $554&255;
        $556 = $550 | $555;
        $557 = $556&255;
        HEAP8[$552>>0] = $557;
        $558 = (($$0$$i309$i) + ($ptr$01$i308$i))|0;
        $559 = ($546|0)>(0);
        $$pre$i311$i = HEAP32[$17>>2]|0;
        if ($559) {
         $$02$i307$i = $546;$553 = $$pre$i311$i;$ptr$01$i308$i = $558;
        } else {
         $$lcssa412 = $558;$$pre$i311$i$lcssa = $$pre$i311$i;
         break;
        }
       }
       $560 = (((((($gfc)) + 39840|0) + (($$pre$i311$i$lcssa*48)|0)|0)) + 4|0);
       HEAP32[$560>>2] = $$lcssa412;
       $561 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4808|0);
       $562 = HEAP32[$561>>2]|0;
       $$02$i297$i = 3;$572 = $$pre$i311$i$lcssa;$ptr$01$i298$i = $$lcssa412;
       while(1) {
        $563 = $ptr$01$i298$i & 7;
        $564 = (8 - ($563))|0;
        $565 = ($$02$i297$i|0)<($564|0);
        $$0$$i299$i = $565 ? $$02$i297$i : $564;
        $566 = (($$02$i297$i) - ($$0$$i299$i))|0;
        $567 = $562 >> $566;
        $568 = (($564) - ($$0$$i299$i))|0;
        $569 = $567 << $568;
        $570 = $ptr$01$i298$i >> 3;
        $571 = ((((((($gfc)) + 39840|0) + (($572*48)|0)|0)) + 8|0) + ($570)|0);
        $573 = HEAP8[$571>>0]|0;
        $574 = $573&255;
        $575 = $569 | $574;
        $576 = $575&255;
        HEAP8[$571>>0] = $576;
        $577 = (($$0$$i299$i) + ($ptr$01$i298$i))|0;
        $578 = ($566|0)>(0);
        $$pre$i301$i = HEAP32[$17>>2]|0;
        if ($578) {
         $$02$i297$i = $566;$572 = $$pre$i301$i;$ptr$01$i298$i = $577;
        } else {
         $$lcssa413 = $577;$$pre$i301$i$lcssa = $$pre$i301$i;
         break;
        }
       }
       $579 = (((((($gfc)) + 39840|0) + (($$pre$i301$i$lcssa*48)|0)|0)) + 4|0);
       HEAP32[$579>>2] = $$lcssa413;
       $580 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4812|0);
       $581 = HEAP32[$580>>2]|0;
       $$02$i287$i = 3;$591 = $$pre$i301$i$lcssa;$ptr$01$i288$i = $$lcssa413;
       while(1) {
        $582 = $ptr$01$i288$i & 7;
        $583 = (8 - ($582))|0;
        $584 = ($$02$i287$i|0)<($583|0);
        $$0$$i289$i = $584 ? $$02$i287$i : $583;
        $585 = (($$02$i287$i) - ($$0$$i289$i))|0;
        $586 = $581 >> $585;
        $587 = (($583) - ($$0$$i289$i))|0;
        $588 = $586 << $587;
        $589 = $ptr$01$i288$i >> 3;
        $590 = ((((((($gfc)) + 39840|0) + (($591*48)|0)|0)) + 8|0) + ($589)|0);
        $592 = HEAP8[$590>>0]|0;
        $593 = $592&255;
        $594 = $588 | $593;
        $595 = $594&255;
        HEAP8[$590>>0] = $595;
        $596 = (($$0$$i289$i) + ($ptr$01$i288$i))|0;
        $597 = ($585|0)>(0);
        $$pre$i291$i = HEAP32[$17>>2]|0;
        if ($597) {
         $$02$i287$i = $585;$591 = $$pre$i291$i;$ptr$01$i288$i = $596;
        } else {
         $$lcssa414 = $596;$$pre$i291$i$lcssa = $$pre$i291$i;
         break;
        }
       }
       $598 = (((((($gfc)) + 39840|0) + (($$pre$i291$i$lcssa*48)|0)|0)) + 4|0);
       HEAP32[$598>>2] = $$lcssa414;
       $599 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4816|0);
       $600 = HEAP32[$599>>2]|0;
       $$02$i277$i = 3;$610 = $$pre$i291$i$lcssa;$ptr$01$i278$i = $$lcssa414;
       while(1) {
        $601 = $ptr$01$i278$i & 7;
        $602 = (8 - ($601))|0;
        $603 = ($$02$i277$i|0)<($602|0);
        $$0$$i279$i = $603 ? $$02$i277$i : $602;
        $604 = (($$02$i277$i) - ($$0$$i279$i))|0;
        $605 = $600 >> $604;
        $606 = (($602) - ($$0$$i279$i))|0;
        $607 = $605 << $606;
        $608 = $ptr$01$i278$i >> 3;
        $609 = ((((((($gfc)) + 39840|0) + (($610*48)|0)|0)) + 8|0) + ($608)|0);
        $611 = HEAP8[$609>>0]|0;
        $612 = $611&255;
        $613 = $607 | $612;
        $614 = $613&255;
        HEAP8[$609>>0] = $614;
        $615 = (($$0$$i279$i) + ($ptr$01$i278$i))|0;
        $616 = ($604|0)>(0);
        $$pre$i281$i = HEAP32[$17>>2]|0;
        if ($616) {
         $$02$i277$i = $604;$610 = $$pre$i281$i;$ptr$01$i278$i = $615;
        } else {
         $$lcssa415 = $615;$$pre$i281$i$lcssa = $$pre$i281$i;
         break;
        }
       }
       $617 = (((((($gfc)) + 39840|0) + (($$pre$i281$i$lcssa*48)|0)|0)) + 4|0);
       HEAP32[$617>>2] = $$lcssa415;
       $1801 = $$lcssa415;$1802 = $$pre$i281$i$lcssa;
      }
      $725 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4832|0);
      $726 = HEAP32[$725>>2]|0;
      $$02$i207$i = 1;$736 = $1802;$ptr$01$i208$i = $1801;
      while(1) {
       $727 = $ptr$01$i208$i & 7;
       $728 = (8 - ($727))|0;
       $729 = ($$02$i207$i|0)<($728|0);
       $$0$$i209$i = $729 ? $$02$i207$i : $728;
       $730 = (($$02$i207$i) - ($$0$$i209$i))|0;
       $731 = $726 >> $730;
       $732 = (($728) - ($$0$$i209$i))|0;
       $733 = $731 << $732;
       $734 = $ptr$01$i208$i >> 3;
       $735 = ((((((($gfc)) + 39840|0) + (($736*48)|0)|0)) + 8|0) + ($734)|0);
       $737 = HEAP8[$735>>0]|0;
       $738 = $737&255;
       $739 = $733 | $738;
       $740 = $739&255;
       HEAP8[$735>>0] = $740;
       $741 = (($$0$$i209$i) + ($ptr$01$i208$i))|0;
       $742 = ($730|0)>(0);
       $$pre$i211$i = HEAP32[$17>>2]|0;
       if ($742) {
        $$02$i207$i = $730;$736 = $$pre$i211$i;$ptr$01$i208$i = $741;
       } else {
        $$lcssa422 = $741;$$pre$i211$i$lcssa = $$pre$i211$i;
        break;
       }
      }
      $743 = (((((($gfc)) + 39840|0) + (($$pre$i211$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$743>>2] = $$lcssa422;
      $744 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4836|0);
      $745 = HEAP32[$744>>2]|0;
      $$02$i197$i = 1;$755 = $$pre$i211$i$lcssa;$ptr$01$i198$i = $$lcssa422;
      while(1) {
       $746 = $ptr$01$i198$i & 7;
       $747 = (8 - ($746))|0;
       $748 = ($$02$i197$i|0)<($747|0);
       $$0$$i199$i = $748 ? $$02$i197$i : $747;
       $749 = (($$02$i197$i) - ($$0$$i199$i))|0;
       $750 = $745 >> $749;
       $751 = (($747) - ($$0$$i199$i))|0;
       $752 = $750 << $751;
       $753 = $ptr$01$i198$i >> 3;
       $754 = ((((((($gfc)) + 39840|0) + (($755*48)|0)|0)) + 8|0) + ($753)|0);
       $756 = HEAP8[$754>>0]|0;
       $757 = $756&255;
       $758 = $752 | $757;
       $759 = $758&255;
       HEAP8[$754>>0] = $759;
       $760 = (($$0$$i199$i) + ($ptr$01$i198$i))|0;
       $761 = ($749|0)>(0);
       $$pre$i201$i = HEAP32[$17>>2]|0;
       if ($761) {
        $$02$i197$i = $749;$755 = $$pre$i201$i;$ptr$01$i198$i = $760;
       } else {
        $$lcssa423 = $760;$$pre$i201$i$lcssa = $$pre$i201$i;
        break;
       }
      }
      $762 = (((((($gfc)) + 39840|0) + (($$pre$i201$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$762>>2] = $$lcssa423;
      $763 = ((((((($gfc)) + 304|0) + (($gr$0634$i*10504)|0)|0) + (($ch$1632$i*5252)|0)|0)) + 4840|0);
      $764 = HEAP32[$763>>2]|0;
      $$02$i187$i = 1;$774 = $$pre$i201$i$lcssa;$ptr$01$i188$i = $$lcssa423;
      while(1) {
       $765 = $ptr$01$i188$i & 7;
       $766 = (8 - ($765))|0;
       $767 = ($$02$i187$i|0)<($766|0);
       $$0$$i189$i = $767 ? $$02$i187$i : $766;
       $768 = (($$02$i187$i) - ($$0$$i189$i))|0;
       $769 = $764 >> $768;
       $770 = (($766) - ($$0$$i189$i))|0;
       $771 = $769 << $770;
       $772 = $ptr$01$i188$i >> 3;
       $773 = ((((((($gfc)) + 39840|0) + (($774*48)|0)|0)) + 8|0) + ($772)|0);
       $775 = HEAP8[$773>>0]|0;
       $776 = $775&255;
       $777 = $771 | $776;
       $778 = $777&255;
       HEAP8[$773>>0] = $778;
       $779 = (($$0$$i189$i) + ($ptr$01$i188$i))|0;
       $780 = ($768|0)>(0);
       $$pre$i191$i = HEAP32[$17>>2]|0;
       if ($780) {
        $$02$i187$i = $768;$774 = $$pre$i191$i;$ptr$01$i188$i = $779;
       } else {
        $$lcssa424 = $779;$$pre$i191$i$lcssa = $$pre$i191$i;
        break;
       }
      }
      $781 = (((((($gfc)) + 39840|0) + (($$pre$i191$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$781>>2] = $$lcssa424;
      $782 = (($ch$1632$i) + 1)|0;
      $783 = HEAP32[$317>>2]|0;
      $784 = ($782|0)<($783|0);
      if ($784) {
       $1795 = $$lcssa424;$1796 = $$pre$i191$i$lcssa;$ch$1632$i = $782;
      } else {
       $1793 = $$pre$i191$i$lcssa;$1794 = $783;
       break;
      }
     }
    } else {
     $1793 = $381;$1794 = $379;
    }
    $785 = (($gr$0634$i) + 1)|0;
    $exitcond$i = ($785|0)==(2);
    if ($exitcond$i) {
     $1213 = $1793;
     break;
    } else {
     $379 = $1794;$381 = $1793;$gr$0634$i = $785;
    }
   }
  } else {
   $$02$i177$i = 8;$795 = $$pre$i451$i$lcssa;$ptr$01$i178$i = $1789;
   while(1) {
    $786 = $ptr$01$i178$i & 7;
    $787 = (8 - ($786))|0;
    $788 = ($$02$i177$i|0)<($787|0);
    $$0$$i179$i = $788 ? $$02$i177$i : $787;
    $789 = (($$02$i177$i) - ($$0$$i179$i))|0;
    $790 = $299 >> $789;
    $791 = (($787) - ($$0$$i179$i))|0;
    $792 = $790 << $791;
    $793 = $ptr$01$i178$i >> 3;
    $794 = ((((((($gfc)) + 39840|0) + (($795*48)|0)|0)) + 8|0) + ($793)|0);
    $796 = HEAP8[$794>>0]|0;
    $797 = $796&255;
    $798 = $792 | $797;
    $799 = $798&255;
    HEAP8[$794>>0] = $799;
    $800 = (($$0$$i179$i) + ($ptr$01$i178$i))|0;
    $801 = ($789|0)>(0);
    $$pre$i181$i = HEAP32[$17>>2]|0;
    if ($801) {
     $$02$i177$i = $789;$795 = $$pre$i181$i;$ptr$01$i178$i = $800;
    } else {
     $$lcssa456 = $800;$$pre$i181$i$lcssa = $$pre$i181$i;
     break;
    }
   }
   $802 = (((((($gfc)) + 39840|0) + (($$pre$i181$i$lcssa*48)|0)|0)) + 4|0);
   HEAP32[$802>>2] = $$lcssa456;
   $803 = ((($gfc)) + 21316|0);
   $804 = HEAP32[$803>>2]|0;
   $805 = ((($gfc)) + 72|0);
   $806 = HEAP32[$805>>2]|0;
   $807 = ($806|0)>(0);
   if ($807) {
    $$02$i169$i = $806;$817 = $$pre$i181$i$lcssa;$ptr$01$i170$i = $$lcssa456;
   } else {
    HEAP32[$802>>2] = $$lcssa456;
    $1213 = $$pre$i181$i$lcssa;
    break;
   }
   while(1) {
    $808 = $ptr$01$i170$i & 7;
    $809 = (8 - ($808))|0;
    $810 = ($$02$i169$i|0)<($809|0);
    $$0$$i171$i = $810 ? $$02$i169$i : $809;
    $811 = (($$02$i169$i) - ($$0$$i171$i))|0;
    $812 = $804 >> $811;
    $813 = (($809) - ($$0$$i171$i))|0;
    $814 = $812 << $813;
    $815 = $ptr$01$i170$i >> 3;
    $816 = ((((((($gfc)) + 39840|0) + (($817*48)|0)|0)) + 8|0) + ($815)|0);
    $818 = HEAP8[$816>>0]|0;
    $819 = $818&255;
    $820 = $814 | $819;
    $821 = $820&255;
    HEAP8[$816>>0] = $821;
    $822 = (($$0$$i171$i) + ($ptr$01$i170$i))|0;
    $823 = ($811|0)>(0);
    $$pre$i173$i = HEAP32[$17>>2]|0;
    if ($823) {
     $$02$i169$i = $811;$817 = $$pre$i173$i;$ptr$01$i170$i = $822;
    } else {
     $$lcssa455 = $822;$$pre$i173$i$lcssa = $$pre$i173$i;
     break;
    }
   }
   $$pre$i = HEAP32[$805>>2]|0;
   $824 = (((((($gfc)) + 39840|0) + (($$pre$i173$i$lcssa*48)|0)|0)) + 4|0);
   HEAP32[$824>>2] = $$lcssa455;
   $825 = ($$pre$i|0)>(0);
   if ($825) {
    $1809 = $$lcssa455;$1810 = $$pre$i173$i$lcssa;$ch$2638$i = 0;
    while(1) {
     $826 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4768|0);
     $827 = HEAP32[$826>>2]|0;
     $828 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4844|0);
     $829 = HEAP32[$828>>2]|0;
     $830 = (($829) + ($827))|0;
     $$02$i161$i = 12;$840 = $1810;$ptr$01$i162$i = $1809;
     while(1) {
      $831 = $ptr$01$i162$i & 7;
      $832 = (8 - ($831))|0;
      $833 = ($$02$i161$i|0)<($832|0);
      $$0$$i163$i = $833 ? $$02$i161$i : $832;
      $834 = (($$02$i161$i) - ($$0$$i163$i))|0;
      $835 = $830 >> $834;
      $836 = (($832) - ($$0$$i163$i))|0;
      $837 = $835 << $836;
      $838 = $ptr$01$i162$i >> 3;
      $839 = ((((((($gfc)) + 39840|0) + (($840*48)|0)|0)) + 8|0) + ($838)|0);
      $841 = HEAP8[$839>>0]|0;
      $842 = $841&255;
      $843 = $837 | $842;
      $844 = $843&255;
      HEAP8[$839>>0] = $844;
      $845 = (($$0$$i163$i) + ($ptr$01$i162$i))|0;
      $846 = ($834|0)>(0);
      $$pre$i165$i = HEAP32[$17>>2]|0;
      if ($846) {
       $$02$i161$i = $834;$840 = $$pre$i165$i;$ptr$01$i162$i = $845;
      } else {
       $$lcssa435 = $845;$$pre$i165$i$lcssa = $$pre$i165$i;
       break;
      }
     }
     $847 = (((((($gfc)) + 39840|0) + (($$pre$i165$i$lcssa*48)|0)|0)) + 4|0);
     HEAP32[$847>>2] = $$lcssa435;
     $848 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4772|0);
     $849 = HEAP32[$848>>2]|0;
     $850 = (($849|0) / 2)&-1;
     $$02$i153$i = 9;$860 = $$pre$i165$i$lcssa;$ptr$01$i154$i = $$lcssa435;
     while(1) {
      $851 = $ptr$01$i154$i & 7;
      $852 = (8 - ($851))|0;
      $853 = ($$02$i153$i|0)<($852|0);
      $$0$$i155$i = $853 ? $$02$i153$i : $852;
      $854 = (($$02$i153$i) - ($$0$$i155$i))|0;
      $855 = $850 >> $854;
      $856 = (($852) - ($$0$$i155$i))|0;
      $857 = $855 << $856;
      $858 = $ptr$01$i154$i >> 3;
      $859 = ((((((($gfc)) + 39840|0) + (($860*48)|0)|0)) + 8|0) + ($858)|0);
      $861 = HEAP8[$859>>0]|0;
      $862 = $861&255;
      $863 = $857 | $862;
      $864 = $863&255;
      HEAP8[$859>>0] = $864;
      $865 = (($$0$$i155$i) + ($ptr$01$i154$i))|0;
      $866 = ($854|0)>(0);
      $$pre$i157$i = HEAP32[$17>>2]|0;
      if ($866) {
       $$02$i153$i = $854;$860 = $$pre$i157$i;$ptr$01$i154$i = $865;
      } else {
       $$lcssa436 = $865;$$pre$i157$i$lcssa = $$pre$i157$i;
       break;
      }
     }
     $867 = (((((($gfc)) + 39840|0) + (($$pre$i157$i$lcssa*48)|0)|0)) + 4|0);
     HEAP32[$867>>2] = $$lcssa436;
     $868 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4780|0);
     $869 = HEAP32[$868>>2]|0;
     $$02$i145$i = 8;$879 = $$pre$i157$i$lcssa;$ptr$01$i146$i = $$lcssa436;
     while(1) {
      $870 = $ptr$01$i146$i & 7;
      $871 = (8 - ($870))|0;
      $872 = ($$02$i145$i|0)<($871|0);
      $$0$$i147$i = $872 ? $$02$i145$i : $871;
      $873 = (($$02$i145$i) - ($$0$$i147$i))|0;
      $874 = $869 >> $873;
      $875 = (($871) - ($$0$$i147$i))|0;
      $876 = $874 << $875;
      $877 = $ptr$01$i146$i >> 3;
      $878 = ((((((($gfc)) + 39840|0) + (($879*48)|0)|0)) + 8|0) + ($877)|0);
      $880 = HEAP8[$878>>0]|0;
      $881 = $880&255;
      $882 = $876 | $881;
      $883 = $882&255;
      HEAP8[$878>>0] = $883;
      $884 = (($$0$$i147$i) + ($ptr$01$i146$i))|0;
      $885 = ($873|0)>(0);
      $$pre$i149$i = HEAP32[$17>>2]|0;
      if ($885) {
       $$02$i145$i = $873;$879 = $$pre$i149$i;$ptr$01$i146$i = $884;
      } else {
       $$lcssa437 = $884;$$pre$i149$i$lcssa = $$pre$i149$i;
       break;
      }
     }
     $886 = (((((($gfc)) + 39840|0) + (($$pre$i149$i$lcssa*48)|0)|0)) + 4|0);
     HEAP32[$886>>2] = $$lcssa437;
     $887 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4784|0);
     $888 = HEAP32[$887>>2]|0;
     $$02$i137$i = 9;$898 = $$pre$i149$i$lcssa;$ptr$01$i138$i = $$lcssa437;
     while(1) {
      $889 = $ptr$01$i138$i & 7;
      $890 = (8 - ($889))|0;
      $891 = ($$02$i137$i|0)<($890|0);
      $$0$$i139$i = $891 ? $$02$i137$i : $890;
      $892 = (($$02$i137$i) - ($$0$$i139$i))|0;
      $893 = $888 >> $892;
      $894 = (($890) - ($$0$$i139$i))|0;
      $895 = $893 << $894;
      $896 = $ptr$01$i138$i >> 3;
      $897 = ((((((($gfc)) + 39840|0) + (($898*48)|0)|0)) + 8|0) + ($896)|0);
      $899 = HEAP8[$897>>0]|0;
      $900 = $899&255;
      $901 = $895 | $900;
      $902 = $901&255;
      HEAP8[$897>>0] = $902;
      $903 = (($$0$$i139$i) + ($ptr$01$i138$i))|0;
      $904 = ($892|0)>(0);
      $$pre$i141$i = HEAP32[$17>>2]|0;
      if ($904) {
       $$02$i137$i = $892;$898 = $$pre$i141$i;$ptr$01$i138$i = $903;
      } else {
       $$lcssa438 = $903;$$pre$i141$i$lcssa = $$pre$i141$i;
       break;
      }
     }
     $905 = (((((($gfc)) + 39840|0) + (($$pre$i141$i$lcssa*48)|0)|0)) + 4|0);
     HEAP32[$905>>2] = $$lcssa438;
     $906 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4788|0);
     $907 = HEAP32[$906>>2]|0;
     $908 = ($907|0)==(0);
     if ($908) {
      $$02$i65$i = 1;$ptr$01$i66$i = $$lcssa438;
      while(1) {
       $1062 = $ptr$01$i66$i & 7;
       $1063 = (8 - ($1062))|0;
       $1064 = ($$02$i65$i|0)<($1063|0);
       $$0$$i67$i = $1064 ? $$02$i65$i : $1063;
       $1065 = (($$02$i65$i) - ($$0$$i67$i))|0;
       $1066 = (($$0$$i67$i) + ($ptr$01$i66$i))|0;
       $1067 = ($1065|0)>(0);
       if ($1067) {
        $$02$i65$i = $1065;$ptr$01$i66$i = $1066;
       } else {
        $$lcssa447 = $1066;
        break;
       }
      }
      HEAP32[$905>>2] = $$lcssa447;
      $1068 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4796|0);
      $1069 = HEAP32[$1068>>2]|0;
      $1070 = ($1069|0)==(14);
      if ($1070) {
       HEAP32[$1068>>2] = 16;
       $$pre710$i = HEAP32[$17>>2]|0;
       $$phi$trans$insert711$i = (((((($gfc)) + 39840|0) + (($$pre710$i*48)|0)|0)) + 4|0);
       $$pre712$i = HEAP32[$$phi$trans$insert711$i>>2]|0;
       $1076 = 16;$1817 = $$pre712$i;$1818 = $$pre710$i;
      } else {
       $1076 = $1069;$1817 = $$lcssa447;$1818 = $$pre$i141$i$lcssa;
      }
      $$02$i57$i = 5;$1081 = $1818;$ptr$01$i58$i = $1817;
      while(1) {
       $1071 = $ptr$01$i58$i & 7;
       $1072 = (8 - ($1071))|0;
       $1073 = ($$02$i57$i|0)<($1072|0);
       $$0$$i59$i = $1073 ? $$02$i57$i : $1072;
       $1074 = (($$02$i57$i) - ($$0$$i59$i))|0;
       $1075 = $1076 >> $1074;
       $1077 = (($1072) - ($$0$$i59$i))|0;
       $1078 = $1075 << $1077;
       $1079 = $ptr$01$i58$i >> 3;
       $1080 = ((((((($gfc)) + 39840|0) + (($1081*48)|0)|0)) + 8|0) + ($1079)|0);
       $1082 = HEAP8[$1080>>0]|0;
       $1083 = $1082&255;
       $1084 = $1078 | $1083;
       $1085 = $1084&255;
       HEAP8[$1080>>0] = $1085;
       $1086 = (($$0$$i59$i) + ($ptr$01$i58$i))|0;
       $1087 = ($1074|0)>(0);
       $$pre$i61$i = HEAP32[$17>>2]|0;
       if ($1087) {
        $$02$i57$i = $1074;$1081 = $$pre$i61$i;$ptr$01$i58$i = $1086;
       } else {
        $$lcssa448 = $1086;$$pre$i61$i$lcssa = $$pre$i61$i;
        break;
       }
      }
      $1088 = (((((($gfc)) + 39840|0) + (($$pre$i61$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$1088>>2] = $$lcssa448;
      $1089 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4800|0);
      $1090 = HEAP32[$1089>>2]|0;
      $1091 = ($1090|0)==(14);
      if ($1091) {
       HEAP32[$1089>>2] = 16;
       $$pre713$i = HEAP32[$17>>2]|0;
       $$phi$trans$insert714$i = (((((($gfc)) + 39840|0) + (($$pre713$i*48)|0)|0)) + 4|0);
       $$pre715$i = HEAP32[$$phi$trans$insert714$i>>2]|0;
       $1097 = 16;$1819 = $$pre715$i;$1820 = $$pre713$i;
      } else {
       $1097 = $1090;$1819 = $$lcssa448;$1820 = $$pre$i61$i$lcssa;
      }
      $$02$i49$i = 5;$1102 = $1820;$ptr$01$i50$i = $1819;
      while(1) {
       $1092 = $ptr$01$i50$i & 7;
       $1093 = (8 - ($1092))|0;
       $1094 = ($$02$i49$i|0)<($1093|0);
       $$0$$i51$i = $1094 ? $$02$i49$i : $1093;
       $1095 = (($$02$i49$i) - ($$0$$i51$i))|0;
       $1096 = $1097 >> $1095;
       $1098 = (($1093) - ($$0$$i51$i))|0;
       $1099 = $1096 << $1098;
       $1100 = $ptr$01$i50$i >> 3;
       $1101 = ((((((($gfc)) + 39840|0) + (($1102*48)|0)|0)) + 8|0) + ($1100)|0);
       $1103 = HEAP8[$1101>>0]|0;
       $1104 = $1103&255;
       $1105 = $1099 | $1104;
       $1106 = $1105&255;
       HEAP8[$1101>>0] = $1106;
       $1107 = (($$0$$i51$i) + ($ptr$01$i50$i))|0;
       $1108 = ($1095|0)>(0);
       $$pre$i53$i = HEAP32[$17>>2]|0;
       if ($1108) {
        $$02$i49$i = $1095;$1102 = $$pre$i53$i;$ptr$01$i50$i = $1107;
       } else {
        $$lcssa449 = $1107;$$pre$i53$i$lcssa = $$pre$i53$i;
        break;
       }
      }
      $1109 = (((((($gfc)) + 39840|0) + (($$pre$i53$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$1109>>2] = $$lcssa449;
      $1110 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4804|0);
      $1111 = HEAP32[$1110>>2]|0;
      $1112 = ($1111|0)==(14);
      if ($1112) {
       HEAP32[$1110>>2] = 16;
       $$pre716$i = HEAP32[$17>>2]|0;
       $$phi$trans$insert717$i = (((((($gfc)) + 39840|0) + (($$pre716$i*48)|0)|0)) + 4|0);
       $$pre718$i = HEAP32[$$phi$trans$insert717$i>>2]|0;
       $1118 = 16;$1821 = $$pre718$i;$1822 = $$pre716$i;
      } else {
       $1118 = $1111;$1821 = $$lcssa449;$1822 = $$pre$i53$i$lcssa;
      }
      $$02$i41$i = 5;$1123 = $1822;$ptr$01$i42$i = $1821;
      while(1) {
       $1113 = $ptr$01$i42$i & 7;
       $1114 = (8 - ($1113))|0;
       $1115 = ($$02$i41$i|0)<($1114|0);
       $$0$$i43$i = $1115 ? $$02$i41$i : $1114;
       $1116 = (($$02$i41$i) - ($$0$$i43$i))|0;
       $1117 = $1118 >> $1116;
       $1119 = (($1114) - ($$0$$i43$i))|0;
       $1120 = $1117 << $1119;
       $1121 = $ptr$01$i42$i >> 3;
       $1122 = ((((((($gfc)) + 39840|0) + (($1123*48)|0)|0)) + 8|0) + ($1121)|0);
       $1124 = HEAP8[$1122>>0]|0;
       $1125 = $1124&255;
       $1126 = $1120 | $1125;
       $1127 = $1126&255;
       HEAP8[$1122>>0] = $1127;
       $1128 = (($$0$$i43$i) + ($ptr$01$i42$i))|0;
       $1129 = ($1116|0)>(0);
       $$pre$i45$i = HEAP32[$17>>2]|0;
       if ($1129) {
        $$02$i41$i = $1116;$1123 = $$pre$i45$i;$ptr$01$i42$i = $1128;
       } else {
        $$lcssa450 = $1128;$$pre$i45$i$lcssa = $$pre$i45$i;
        break;
       }
      }
      $1130 = (((((($gfc)) + 39840|0) + (($$pre$i45$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$1130>>2] = $$lcssa450;
      $1131 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4824|0);
      $1132 = HEAP32[$1131>>2]|0;
      $$02$i33$i = 4;$1142 = $$pre$i45$i$lcssa;$ptr$01$i34$i = $$lcssa450;
      while(1) {
       $1133 = $ptr$01$i34$i & 7;
       $1134 = (8 - ($1133))|0;
       $1135 = ($$02$i33$i|0)<($1134|0);
       $$0$$i35$i = $1135 ? $$02$i33$i : $1134;
       $1136 = (($$02$i33$i) - ($$0$$i35$i))|0;
       $1137 = $1132 >> $1136;
       $1138 = (($1134) - ($$0$$i35$i))|0;
       $1139 = $1137 << $1138;
       $1140 = $ptr$01$i34$i >> 3;
       $1141 = ((((((($gfc)) + 39840|0) + (($1142*48)|0)|0)) + 8|0) + ($1140)|0);
       $1143 = HEAP8[$1141>>0]|0;
       $1144 = $1143&255;
       $1145 = $1139 | $1144;
       $1146 = $1145&255;
       HEAP8[$1141>>0] = $1146;
       $1147 = (($$0$$i35$i) + ($ptr$01$i34$i))|0;
       $1148 = ($1136|0)>(0);
       $$pre$i37$i = HEAP32[$17>>2]|0;
       if ($1148) {
        $$02$i33$i = $1136;$1142 = $$pre$i37$i;$ptr$01$i34$i = $1147;
       } else {
        $$lcssa451 = $1147;$$pre$i37$i$lcssa = $$pre$i37$i;
        break;
       }
      }
      $1149 = (((((($gfc)) + 39840|0) + (($$pre$i37$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$1149>>2] = $$lcssa451;
      $1150 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4828|0);
      $1151 = HEAP32[$1150>>2]|0;
      $$02$i25$i = 3;$1161 = $$pre$i37$i$lcssa;$ptr$01$i26$i = $$lcssa451;
      while(1) {
       $1152 = $ptr$01$i26$i & 7;
       $1153 = (8 - ($1152))|0;
       $1154 = ($$02$i25$i|0)<($1153|0);
       $$0$$i27$i = $1154 ? $$02$i25$i : $1153;
       $1155 = (($$02$i25$i) - ($$0$$i27$i))|0;
       $1156 = $1151 >> $1155;
       $1157 = (($1153) - ($$0$$i27$i))|0;
       $1158 = $1156 << $1157;
       $1159 = $ptr$01$i26$i >> 3;
       $1160 = ((((((($gfc)) + 39840|0) + (($1161*48)|0)|0)) + 8|0) + ($1159)|0);
       $1162 = HEAP8[$1160>>0]|0;
       $1163 = $1162&255;
       $1164 = $1158 | $1163;
       $1165 = $1164&255;
       HEAP8[$1160>>0] = $1165;
       $1166 = (($$0$$i27$i) + ($ptr$01$i26$i))|0;
       $1167 = ($1155|0)>(0);
       $$pre$i29$i = HEAP32[$17>>2]|0;
       if ($1167) {
        $$02$i25$i = $1155;$1161 = $$pre$i29$i;$ptr$01$i26$i = $1166;
       } else {
        $$lcssa452 = $1166;$$pre$i29$i$lcssa = $$pre$i29$i;
        break;
       }
      }
      $1168 = (((((($gfc)) + 39840|0) + (($$pre$i29$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$1168>>2] = $$lcssa452;
      $1815 = $$lcssa452;$1816 = $$pre$i29$i$lcssa;
     } else {
      $$02$i129$i = 1;$918 = $$pre$i141$i$lcssa;$ptr$01$i130$i = $$lcssa438;
      while(1) {
       $909 = $ptr$01$i130$i & 7;
       $910 = (8 - ($909))|0;
       $911 = ($$02$i129$i|0)<($910|0);
       $$0$$i131$i = $911 ? $$02$i129$i : $910;
       $912 = (($$02$i129$i) - ($$0$$i131$i))|0;
       $913 = 1 >>> $912;
       $914 = (($910) - ($$0$$i131$i))|0;
       $915 = $913 << $914;
       $916 = $ptr$01$i130$i >> 3;
       $917 = ((((((($gfc)) + 39840|0) + (($918*48)|0)|0)) + 8|0) + ($916)|0);
       $919 = HEAP8[$917>>0]|0;
       $920 = $919&255;
       $921 = $915 | $920;
       $922 = $921&255;
       HEAP8[$917>>0] = $922;
       $923 = (($$0$$i131$i) + ($ptr$01$i130$i))|0;
       $924 = ($912|0)>(0);
       $$pre$i133$i = HEAP32[$17>>2]|0;
       if ($924) {
        $$02$i129$i = $912;$918 = $$pre$i133$i;$ptr$01$i130$i = $923;
       } else {
        $$lcssa439 = $923;$$pre$i133$i$lcssa = $$pre$i133$i;
        break;
       }
      }
      $925 = (((((($gfc)) + 39840|0) + (($$pre$i133$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$925>>2] = $$lcssa439;
      $926 = HEAP32[$906>>2]|0;
      $$02$i121$i = 2;$936 = $$pre$i133$i$lcssa;$ptr$01$i122$i = $$lcssa439;
      while(1) {
       $927 = $ptr$01$i122$i & 7;
       $928 = (8 - ($927))|0;
       $929 = ($$02$i121$i|0)<($928|0);
       $$0$$i123$i = $929 ? $$02$i121$i : $928;
       $930 = (($$02$i121$i) - ($$0$$i123$i))|0;
       $931 = $926 >> $930;
       $932 = (($928) - ($$0$$i123$i))|0;
       $933 = $931 << $932;
       $934 = $ptr$01$i122$i >> 3;
       $935 = ((((((($gfc)) + 39840|0) + (($936*48)|0)|0)) + 8|0) + ($934)|0);
       $937 = HEAP8[$935>>0]|0;
       $938 = $937&255;
       $939 = $933 | $938;
       $940 = $939&255;
       HEAP8[$935>>0] = $940;
       $941 = (($$0$$i123$i) + ($ptr$01$i122$i))|0;
       $942 = ($930|0)>(0);
       $$pre$i125$i = HEAP32[$17>>2]|0;
       if ($942) {
        $$02$i121$i = $930;$936 = $$pre$i125$i;$ptr$01$i122$i = $941;
       } else {
        $$lcssa440 = $941;$$pre$i125$i$lcssa = $$pre$i125$i;
        break;
       }
      }
      $943 = (((((($gfc)) + 39840|0) + (($$pre$i125$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$943>>2] = $$lcssa440;
      $944 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4792|0);
      $945 = HEAP32[$944>>2]|0;
      $$02$i113$i = 1;$955 = $$pre$i125$i$lcssa;$ptr$01$i114$i = $$lcssa440;
      while(1) {
       $946 = $ptr$01$i114$i & 7;
       $947 = (8 - ($946))|0;
       $948 = ($$02$i113$i|0)<($947|0);
       $$0$$i115$i = $948 ? $$02$i113$i : $947;
       $949 = (($$02$i113$i) - ($$0$$i115$i))|0;
       $950 = $945 >> $949;
       $951 = (($947) - ($$0$$i115$i))|0;
       $952 = $950 << $951;
       $953 = $ptr$01$i114$i >> 3;
       $954 = ((((((($gfc)) + 39840|0) + (($955*48)|0)|0)) + 8|0) + ($953)|0);
       $956 = HEAP8[$954>>0]|0;
       $957 = $956&255;
       $958 = $952 | $957;
       $959 = $958&255;
       HEAP8[$954>>0] = $959;
       $960 = (($$0$$i115$i) + ($ptr$01$i114$i))|0;
       $961 = ($949|0)>(0);
       $$pre$i117$i = HEAP32[$17>>2]|0;
       if ($961) {
        $$02$i113$i = $949;$955 = $$pre$i117$i;$ptr$01$i114$i = $960;
       } else {
        $$lcssa441 = $960;$$pre$i117$i$lcssa = $$pre$i117$i;
        break;
       }
      }
      $962 = (((((($gfc)) + 39840|0) + (($$pre$i117$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$962>>2] = $$lcssa441;
      $963 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4796|0);
      $964 = HEAP32[$963>>2]|0;
      $965 = ($964|0)==(14);
      if ($965) {
       HEAP32[$963>>2] = 16;
       $$pre704$i = HEAP32[$17>>2]|0;
       $$phi$trans$insert705$i = (((((($gfc)) + 39840|0) + (($$pre704$i*48)|0)|0)) + 4|0);
       $$pre706$i = HEAP32[$$phi$trans$insert705$i>>2]|0;
       $1811 = $$pre706$i;$1812 = $$pre704$i;$971 = 16;
      } else {
       $1811 = $$lcssa441;$1812 = $$pre$i117$i$lcssa;$971 = $964;
      }
      $$02$i105$i = 5;$976 = $1812;$ptr$01$i106$i = $1811;
      while(1) {
       $966 = $ptr$01$i106$i & 7;
       $967 = (8 - ($966))|0;
       $968 = ($$02$i105$i|0)<($967|0);
       $$0$$i107$i = $968 ? $$02$i105$i : $967;
       $969 = (($$02$i105$i) - ($$0$$i107$i))|0;
       $970 = $971 >> $969;
       $972 = (($967) - ($$0$$i107$i))|0;
       $973 = $970 << $972;
       $974 = $ptr$01$i106$i >> 3;
       $975 = ((((((($gfc)) + 39840|0) + (($976*48)|0)|0)) + 8|0) + ($974)|0);
       $977 = HEAP8[$975>>0]|0;
       $978 = $977&255;
       $979 = $973 | $978;
       $980 = $979&255;
       HEAP8[$975>>0] = $980;
       $981 = (($$0$$i107$i) + ($ptr$01$i106$i))|0;
       $982 = ($969|0)>(0);
       $$pre$i109$i = HEAP32[$17>>2]|0;
       if ($982) {
        $$02$i105$i = $969;$976 = $$pre$i109$i;$ptr$01$i106$i = $981;
       } else {
        $$lcssa442 = $981;$$pre$i109$i$lcssa = $$pre$i109$i;
        break;
       }
      }
      $983 = (((((($gfc)) + 39840|0) + (($$pre$i109$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$983>>2] = $$lcssa442;
      $984 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4800|0);
      $985 = HEAP32[$984>>2]|0;
      $986 = ($985|0)==(14);
      if ($986) {
       HEAP32[$984>>2] = 16;
       $$pre707$i = HEAP32[$17>>2]|0;
       $$phi$trans$insert708$i = (((((($gfc)) + 39840|0) + (($$pre707$i*48)|0)|0)) + 4|0);
       $$pre709$i = HEAP32[$$phi$trans$insert708$i>>2]|0;
       $1813 = $$pre709$i;$1814 = $$pre707$i;$992 = 16;
      } else {
       $1813 = $$lcssa442;$1814 = $$pre$i109$i$lcssa;$992 = $985;
      }
      $$02$i97$i = 5;$997 = $1814;$ptr$01$i98$i = $1813;
      while(1) {
       $987 = $ptr$01$i98$i & 7;
       $988 = (8 - ($987))|0;
       $989 = ($$02$i97$i|0)<($988|0);
       $$0$$i99$i = $989 ? $$02$i97$i : $988;
       $990 = (($$02$i97$i) - ($$0$$i99$i))|0;
       $991 = $992 >> $990;
       $993 = (($988) - ($$0$$i99$i))|0;
       $994 = $991 << $993;
       $995 = $ptr$01$i98$i >> 3;
       $996 = ((((((($gfc)) + 39840|0) + (($997*48)|0)|0)) + 8|0) + ($995)|0);
       $998 = HEAP8[$996>>0]|0;
       $999 = $998&255;
       $1000 = $994 | $999;
       $1001 = $1000&255;
       HEAP8[$996>>0] = $1001;
       $1002 = (($$0$$i99$i) + ($ptr$01$i98$i))|0;
       $1003 = ($990|0)>(0);
       $$pre$i101$i = HEAP32[$17>>2]|0;
       if ($1003) {
        $$02$i97$i = $990;$997 = $$pre$i101$i;$ptr$01$i98$i = $1002;
       } else {
        $$lcssa443 = $1002;$$pre$i101$i$lcssa = $$pre$i101$i;
        break;
       }
      }
      $1004 = (((((($gfc)) + 39840|0) + (($$pre$i101$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$1004>>2] = $$lcssa443;
      $1005 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4808|0);
      $1006 = HEAP32[$1005>>2]|0;
      $$02$i89$i = 3;$1016 = $$pre$i101$i$lcssa;$ptr$01$i90$i = $$lcssa443;
      while(1) {
       $1007 = $ptr$01$i90$i & 7;
       $1008 = (8 - ($1007))|0;
       $1009 = ($$02$i89$i|0)<($1008|0);
       $$0$$i91$i = $1009 ? $$02$i89$i : $1008;
       $1010 = (($$02$i89$i) - ($$0$$i91$i))|0;
       $1011 = $1006 >> $1010;
       $1012 = (($1008) - ($$0$$i91$i))|0;
       $1013 = $1011 << $1012;
       $1014 = $ptr$01$i90$i >> 3;
       $1015 = ((((((($gfc)) + 39840|0) + (($1016*48)|0)|0)) + 8|0) + ($1014)|0);
       $1017 = HEAP8[$1015>>0]|0;
       $1018 = $1017&255;
       $1019 = $1013 | $1018;
       $1020 = $1019&255;
       HEAP8[$1015>>0] = $1020;
       $1021 = (($$0$$i91$i) + ($ptr$01$i90$i))|0;
       $1022 = ($1010|0)>(0);
       $$pre$i93$i = HEAP32[$17>>2]|0;
       if ($1022) {
        $$02$i89$i = $1010;$1016 = $$pre$i93$i;$ptr$01$i90$i = $1021;
       } else {
        $$lcssa444 = $1021;$$pre$i93$i$lcssa = $$pre$i93$i;
        break;
       }
      }
      $1023 = (((((($gfc)) + 39840|0) + (($$pre$i93$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$1023>>2] = $$lcssa444;
      $1024 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4812|0);
      $1025 = HEAP32[$1024>>2]|0;
      $$02$i81$i = 3;$1035 = $$pre$i93$i$lcssa;$ptr$01$i82$i = $$lcssa444;
      while(1) {
       $1026 = $ptr$01$i82$i & 7;
       $1027 = (8 - ($1026))|0;
       $1028 = ($$02$i81$i|0)<($1027|0);
       $$0$$i83$i = $1028 ? $$02$i81$i : $1027;
       $1029 = (($$02$i81$i) - ($$0$$i83$i))|0;
       $1030 = $1025 >> $1029;
       $1031 = (($1027) - ($$0$$i83$i))|0;
       $1032 = $1030 << $1031;
       $1033 = $ptr$01$i82$i >> 3;
       $1034 = ((((((($gfc)) + 39840|0) + (($1035*48)|0)|0)) + 8|0) + ($1033)|0);
       $1036 = HEAP8[$1034>>0]|0;
       $1037 = $1036&255;
       $1038 = $1032 | $1037;
       $1039 = $1038&255;
       HEAP8[$1034>>0] = $1039;
       $1040 = (($$0$$i83$i) + ($ptr$01$i82$i))|0;
       $1041 = ($1029|0)>(0);
       $$pre$i85$i = HEAP32[$17>>2]|0;
       if ($1041) {
        $$02$i81$i = $1029;$1035 = $$pre$i85$i;$ptr$01$i82$i = $1040;
       } else {
        $$lcssa445 = $1040;$$pre$i85$i$lcssa = $$pre$i85$i;
        break;
       }
      }
      $1042 = (((((($gfc)) + 39840|0) + (($$pre$i85$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$1042>>2] = $$lcssa445;
      $1043 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4816|0);
      $1044 = HEAP32[$1043>>2]|0;
      $$02$i73$i = 3;$1054 = $$pre$i85$i$lcssa;$ptr$01$i74$i = $$lcssa445;
      while(1) {
       $1045 = $ptr$01$i74$i & 7;
       $1046 = (8 - ($1045))|0;
       $1047 = ($$02$i73$i|0)<($1046|0);
       $$0$$i75$i = $1047 ? $$02$i73$i : $1046;
       $1048 = (($$02$i73$i) - ($$0$$i75$i))|0;
       $1049 = $1044 >> $1048;
       $1050 = (($1046) - ($$0$$i75$i))|0;
       $1051 = $1049 << $1050;
       $1052 = $ptr$01$i74$i >> 3;
       $1053 = ((((((($gfc)) + 39840|0) + (($1054*48)|0)|0)) + 8|0) + ($1052)|0);
       $1055 = HEAP8[$1053>>0]|0;
       $1056 = $1055&255;
       $1057 = $1051 | $1056;
       $1058 = $1057&255;
       HEAP8[$1053>>0] = $1058;
       $1059 = (($$0$$i75$i) + ($ptr$01$i74$i))|0;
       $1060 = ($1048|0)>(0);
       $$pre$i77$i = HEAP32[$17>>2]|0;
       if ($1060) {
        $$02$i73$i = $1048;$1054 = $$pre$i77$i;$ptr$01$i74$i = $1059;
       } else {
        $$lcssa446 = $1059;$$pre$i77$i$lcssa = $$pre$i77$i;
        break;
       }
      }
      $1061 = (((((($gfc)) + 39840|0) + (($$pre$i77$i$lcssa*48)|0)|0)) + 4|0);
      HEAP32[$1061>>2] = $$lcssa446;
      $1815 = $$lcssa446;$1816 = $$pre$i77$i$lcssa;
     }
     $1169 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4836|0);
     $1170 = HEAP32[$1169>>2]|0;
     $$02$i17$i = 1;$1180 = $1816;$ptr$01$i18$i = $1815;
     while(1) {
      $1171 = $ptr$01$i18$i & 7;
      $1172 = (8 - ($1171))|0;
      $1173 = ($$02$i17$i|0)<($1172|0);
      $$0$$i19$i = $1173 ? $$02$i17$i : $1172;
      $1174 = (($$02$i17$i) - ($$0$$i19$i))|0;
      $1175 = $1170 >> $1174;
      $1176 = (($1172) - ($$0$$i19$i))|0;
      $1177 = $1175 << $1176;
      $1178 = $ptr$01$i18$i >> 3;
      $1179 = ((((((($gfc)) + 39840|0) + (($1180*48)|0)|0)) + 8|0) + ($1178)|0);
      $1181 = HEAP8[$1179>>0]|0;
      $1182 = $1181&255;
      $1183 = $1177 | $1182;
      $1184 = $1183&255;
      HEAP8[$1179>>0] = $1184;
      $1185 = (($$0$$i19$i) + ($ptr$01$i18$i))|0;
      $1186 = ($1174|0)>(0);
      $$pre$i21$i = HEAP32[$17>>2]|0;
      if ($1186) {
       $$02$i17$i = $1174;$1180 = $$pre$i21$i;$ptr$01$i18$i = $1185;
      } else {
       $$lcssa453 = $1185;$$pre$i21$i$lcssa = $$pre$i21$i;
       break;
      }
     }
     $1187 = (((((($gfc)) + 39840|0) + (($$pre$i21$i$lcssa*48)|0)|0)) + 4|0);
     HEAP32[$1187>>2] = $$lcssa453;
     $1188 = (((((($gfc)) + 304|0) + (($ch$2638$i*5252)|0)|0)) + 4840|0);
     $1189 = HEAP32[$1188>>2]|0;
     $$02$i9$i = 1;$1199 = $$pre$i21$i$lcssa;$ptr$01$i10$i = $$lcssa453;
     while(1) {
      $1190 = $ptr$01$i10$i & 7;
      $1191 = (8 - ($1190))|0;
      $1192 = ($$02$i9$i|0)<($1191|0);
      $$0$$i11$i = $1192 ? $$02$i9$i : $1191;
      $1193 = (($$02$i9$i) - ($$0$$i11$i))|0;
      $1194 = $1189 >> $1193;
      $1195 = (($1191) - ($$0$$i11$i))|0;
      $1196 = $1194 << $1195;
      $1197 = $ptr$01$i10$i >> 3;
      $1198 = ((((((($gfc)) + 39840|0) + (($1199*48)|0)|0)) + 8|0) + ($1197)|0);
      $1200 = HEAP8[$1198>>0]|0;
      $1201 = $1200&255;
      $1202 = $1196 | $1201;
      $1203 = $1202&255;
      HEAP8[$1198>>0] = $1203;
      $1204 = (($$0$$i11$i) + ($ptr$01$i10$i))|0;
      $1205 = ($1193|0)>(0);
      $$pre$i13$i = HEAP32[$17>>2]|0;
      if ($1205) {
       $$02$i9$i = $1193;$1199 = $$pre$i13$i;$ptr$01$i10$i = $1204;
      } else {
       $$lcssa454 = $1204;$$pre$i13$i$lcssa = $$pre$i13$i;
       break;
      }
     }
     $1206 = (((((($gfc)) + 39840|0) + (($$pre$i13$i$lcssa*48)|0)|0)) + 4|0);
     HEAP32[$1206>>2] = $$lcssa454;
     $1207 = (($ch$2638$i) + 1)|0;
     $1208 = HEAP32[$805>>2]|0;
     $1209 = ($1207|0)<($1208|0);
     if ($1209) {
      $1809 = $$lcssa454;$1810 = $$pre$i13$i$lcssa;$ch$2638$i = $1207;
     } else {
      $1213 = $$pre$i13$i$lcssa;
      break;
     }
    }
   } else {
    $1213 = $$pre$i173$i$lcssa;
   }
  }
 } while(0);
 $1210 = HEAP32[$98>>2]|0;
 $1211 = ($1210|0)==(0);
 if ($1211) {
  $1215 = $1213;
 } else {
  $1212 = (((((($gfc)) + 39840|0) + (($1213*48)|0)|0)) + 8|0);
  _CRC_writeheader($gfc,$1212);
  $$pre734$i = HEAP32[$17>>2]|0;
  $1215 = $$pre734$i;
 }
 $1214 = (($1215) + 1)|0;
 $1216 = $1214 & 255;
 HEAP32[$17>>2] = $1216;
 $1217 = (((($gfc)) + 39840|0) + (($1215*48)|0)|0);
 $1218 = HEAP32[$1217>>2]|0;
 $1219 = (($1218) + ($14))|0;
 $1220 = (((($gfc)) + 39840|0) + (($1216*48)|0)|0);
 HEAP32[$1220>>2] = $1219;
 $1221 = HEAP32[$17>>2]|0;
 $1222 = ((($gfc)) + 52132|0);
 $1223 = HEAP32[$1222>>2]|0;
 $1224 = ($1221|0)==($1223|0);
 if ($1224) {
  _lame_errorf($gfc,1112,$vararg_buffer);
 }
 $1283 = HEAP32[$21>>2]|0;
 $1284 = $1283 << 3;
 $1285 = HEAP32[$62>>2]|0;
 $1286 = ($1285|0)==(1);
 $1287 = ((($gfc)) + 72|0);
 do {
  if ($1286) {
   $1295 = ((($gfc)) + 300|0);
   $1296 = ((($gfc)) + 296|0);
   $1297 = ((($gfc)) + 292|0);
   $1298 = ((($gfc)) + 284|0);
   $1299 = ((($gfc)) + 21464|0);
   $$pre$i1 = HEAP32[$1287>>2]|0;
   $1300 = $$pre$i1;$gr$054$i = 0;$tot_bits$053$i = 0;
   while(1) {
    $1301 = ($1300|0)>(0);
    if ($1301) {
     $ch$047$i = 0;$tot_bits$146$i = $tot_bits$053$i;
     while(1) {
      $1302 = ((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0);
      $1303 = ((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4784|0);
      $1304 = HEAP32[$1303>>2]|0;
      $1305 = (88648 + ($1304<<2)|0);
      $1306 = HEAP32[$1305>>2]|0;
      $1307 = (88712 + ($1304<<2)|0);
      $1308 = HEAP32[$1307>>2]|0;
      $1309 = ((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4868|0);
      $1310 = HEAP32[$1309>>2]|0;
      $1311 = ($1310|0)>(0);
      L269: do {
       if ($1311) {
        $1312 = ($1306|0)>(0);
        if ($1312) {
         $1824 = $1310;$data_bits$039$us$i = 0;$sfb$040$us$i = 0;
        } else {
         $data_bits$039$i = 0;$sfb$040$i = 0;
         while(1) {
          $1365 = (((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4608|0) + ($sfb$040$i<<2)|0);
          $1366 = HEAP32[$1365>>2]|0;
          $1367 = ($1366|0)==(-1);
          $1368 = $1367 ? 0 : $1306;
          $data_bits$039$$i = (($1368) + ($data_bits$039$i))|0;
          $1369 = (($sfb$040$i) + 1)|0;
          $exitcond166 = ($1369|0)==($1310|0);
          if ($exitcond166) {
           $data_bits$0$lcssa$i = $data_bits$039$$i;$sfb$0$lcssa$i = $1310;
           break L269;
          } else {
           $data_bits$039$i = $data_bits$039$$i;$sfb$040$i = $1369;
          }
         }
        }
        while(1) {
         $1313 = (((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4608|0) + ($sfb$040$us$i<<2)|0);
         $1314 = HEAP32[$1313>>2]|0;
         $1315 = ($1314|0)==(-1);
         if ($1315) {
          $1360 = $1824;$data_bits$1$us$i = $data_bits$039$us$i;
         } else {
          $$01$i$us$i = $1306;
          while(1) {
           $1316 = HEAP32[$1295>>2]|0;
           $1317 = ($1316|0)==(0);
           if ($1317) {
            HEAP32[$1295>>2] = 8;
            $1318 = HEAP32[$1296>>2]|0;
            $1319 = (($1318) + 1)|0;
            HEAP32[$1296>>2] = $1319;
            $1320 = HEAP32[$1222>>2]|0;
            $1321 = (((($gfc)) + 39840|0) + (($1320*48)|0)|0);
            $1322 = HEAP32[$1321>>2]|0;
            $1323 = HEAP32[$1297>>2]|0;
            $1324 = ($1322|0)==($1323|0);
            if ($1324) {
             $1325 = HEAP32[$1298>>2]|0;
             $1326 = (($1325) + ($1319)|0);
             $1327 = (((((($gfc)) + 39840|0) + (($1320*48)|0)|0)) + 8|0);
             $1328 = HEAP32[$21>>2]|0;
             _memcpy(($1326|0),($1327|0),($1328|0))|0;
             $1329 = HEAP32[$21>>2]|0;
             $1330 = HEAP32[$1296>>2]|0;
             $1331 = (($1330) + ($1329))|0;
             HEAP32[$1296>>2] = $1331;
             $1332 = $1329 << 3;
             $1333 = HEAP32[$1297>>2]|0;
             $1334 = (($1333) + ($1332))|0;
             HEAP32[$1297>>2] = $1334;
             $1335 = HEAP32[$1222>>2]|0;
             $1336 = (($1335) + 1)|0;
             $1337 = $1336 & 255;
             HEAP32[$1222>>2] = $1337;
             $1340 = $1331;
            } else {
             $1340 = $1319;
            }
            $1338 = HEAP32[$1298>>2]|0;
            $1339 = (($1338) + ($1340)|0);
            HEAP8[$1339>>0] = 0;
            $$pre$i$us$i = HEAP32[$1295>>2]|0;
            $1342 = $$pre$i$us$i;
           } else {
            $1342 = $1316;
           }
           $1341 = ($$01$i$us$i|0)<($1342|0);
           $$0$$i$us$i = $1341 ? $$01$i$us$i : $1342;
           $1343 = (($$01$i$us$i) - ($$0$$i$us$i))|0;
           $1344 = (($1342) - ($$0$$i$us$i))|0;
           HEAP32[$1295>>2] = $1344;
           $1345 = $1314 >> $1343;
           $1346 = $1345 << $1344;
           $1347 = HEAP32[$1296>>2]|0;
           $1348 = HEAP32[$1298>>2]|0;
           $1349 = (($1348) + ($1347)|0);
           $1350 = HEAP8[$1349>>0]|0;
           $1351 = $1350&255;
           $1352 = $1346 | $1351;
           $1353 = $1352&255;
           HEAP8[$1349>>0] = $1353;
           $1354 = HEAP32[$1297>>2]|0;
           $1355 = (($1354) + ($$0$$i$us$i))|0;
           HEAP32[$1297>>2] = $1355;
           $1356 = ($1343|0)>(0);
           if ($1356) {
            $$01$i$us$i = $1343;
           } else {
            break;
           }
          }
          $$pre96$pre$i = HEAP32[$1309>>2]|0;
          $1357 = (($data_bits$039$us$i) + ($1306))|0;
          $1360 = $$pre96$pre$i;$data_bits$1$us$i = $1357;
         }
         $1358 = (($sfb$040$us$i) + 1)|0;
         $1359 = ($1358|0)<($1360|0);
         if ($1359) {
          $1824 = $1360;$data_bits$039$us$i = $data_bits$1$us$i;$sfb$040$us$i = $1358;
         } else {
          $data_bits$0$lcssa$i = $data_bits$1$us$i;$sfb$0$lcssa$i = $1358;
          break;
         }
        }
       } else {
        $data_bits$0$lcssa$i = 0;$sfb$0$lcssa$i = 0;
       }
      } while(0);
      $1361 = ((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4860|0);
      $1362 = HEAP32[$1361>>2]|0;
      $1363 = ($sfb$0$lcssa$i|0)<($1362|0);
      if ($1363) {
       $1364 = ($1308|0)>(0);
       $1825 = $1362;$data_bits$242$i = $data_bits$0$lcssa$i;$sfb$143$i = $sfb$0$lcssa$i;
       while(1) {
        $1370 = (((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4608|0) + ($sfb$143$i<<2)|0);
        $1371 = HEAP32[$1370>>2]|0;
        $1372 = ($1371|0)==(-1);
        if ($1372) {
         $1417 = $1825;$data_bits$3$i = $data_bits$242$i;
        } else {
         if ($1364) {
          $$01$i4$i = $1308;
          while(1) {
           $1373 = HEAP32[$1295>>2]|0;
           $1374 = ($1373|0)==(0);
           if ($1374) {
            HEAP32[$1295>>2] = 8;
            $1375 = HEAP32[$1296>>2]|0;
            $1376 = (($1375) + 1)|0;
            HEAP32[$1296>>2] = $1376;
            $1377 = HEAP32[$1222>>2]|0;
            $1378 = (((($gfc)) + 39840|0) + (($1377*48)|0)|0);
            $1379 = HEAP32[$1378>>2]|0;
            $1380 = HEAP32[$1297>>2]|0;
            $1381 = ($1379|0)==($1380|0);
            if ($1381) {
             $1382 = HEAP32[$1298>>2]|0;
             $1383 = (($1382) + ($1376)|0);
             $1384 = (((((($gfc)) + 39840|0) + (($1377*48)|0)|0)) + 8|0);
             $1385 = HEAP32[$21>>2]|0;
             _memcpy(($1383|0),($1384|0),($1385|0))|0;
             $1386 = HEAP32[$21>>2]|0;
             $1387 = HEAP32[$1296>>2]|0;
             $1388 = (($1387) + ($1386))|0;
             HEAP32[$1296>>2] = $1388;
             $1389 = $1386 << 3;
             $1390 = HEAP32[$1297>>2]|0;
             $1391 = (($1390) + ($1389))|0;
             HEAP32[$1297>>2] = $1391;
             $1392 = HEAP32[$1222>>2]|0;
             $1393 = (($1392) + 1)|0;
             $1394 = $1393 & 255;
             HEAP32[$1222>>2] = $1394;
             $1397 = $1388;
            } else {
             $1397 = $1376;
            }
            $1395 = HEAP32[$1298>>2]|0;
            $1396 = (($1395) + ($1397)|0);
            HEAP8[$1396>>0] = 0;
            $$pre$i5$i4 = HEAP32[$1295>>2]|0;
            $1399 = $$pre$i5$i4;
           } else {
            $1399 = $1373;
           }
           $1398 = ($$01$i4$i|0)<($1399|0);
           $$0$$i6$i = $1398 ? $$01$i4$i : $1399;
           $1400 = (($$01$i4$i) - ($$0$$i6$i))|0;
           $1401 = (($1399) - ($$0$$i6$i))|0;
           HEAP32[$1295>>2] = $1401;
           $1402 = $1371 >> $1400;
           $1403 = $1402 << $1401;
           $1404 = HEAP32[$1296>>2]|0;
           $1405 = HEAP32[$1298>>2]|0;
           $1406 = (($1405) + ($1404)|0);
           $1407 = HEAP8[$1406>>0]|0;
           $1408 = $1407&255;
           $1409 = $1403 | $1408;
           $1410 = $1409&255;
           HEAP8[$1406>>0] = $1410;
           $1411 = HEAP32[$1297>>2]|0;
           $1412 = (($1411) + ($$0$$i6$i))|0;
           HEAP32[$1297>>2] = $1412;
           $1413 = ($1400|0)>(0);
           if ($1413) {
            $$01$i4$i = $1400;
           } else {
            break;
           }
          }
          $$pre97$pre$i = HEAP32[$1361>>2]|0;
          $$pre97$i = $$pre97$pre$i;
         } else {
          $$pre97$i = $1825;
         }
         $1414 = (($data_bits$242$i) + ($1308))|0;
         $1417 = $$pre97$i;$data_bits$3$i = $1414;
        }
        $1415 = (($sfb$143$i) + 1)|0;
        $1416 = ($1415|0)<($1417|0);
        if ($1416) {
         $1825 = $1417;$data_bits$242$i = $data_bits$3$i;$sfb$143$i = $1415;
        } else {
         $data_bits$2$lcssa$i = $data_bits$3$i;
         break;
        }
       }
      } else {
       $data_bits$2$lcssa$i = $data_bits$0$lcssa$i;
      }
      $1418 = ((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4788|0);
      $1419 = HEAP32[$1418>>2]|0;
      $1420 = ($1419|0)==(2);
      if ($1420) {
       $1421 = HEAP32[$1299>>2]|0;
       $1422 = ($1421*3)|0;
       $1423 = ((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4772|0);
       $1424 = HEAP32[$1423>>2]|0;
       $1425 = ($1422|0)>($1424|0);
       $$$i8$i = $1425 ? $1424 : $1422;
       $1426 = ((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4796|0);
       $1427 = HEAP32[$1426>>2]|0;
       $1428 = (_Huffmancode($gfc,$1427,0,$$$i8$i,$1302)|0);
       $1429 = ((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4800|0);
       $1430 = HEAP32[$1429>>2]|0;
       $1431 = HEAP32[$1423>>2]|0;
       $1432 = (_Huffmancode($gfc,$1430,$$$i8$i,$1431,$1302)|0);
       $1433 = (($1432) + ($1428))|0;
       $$pn$i = $1433;
      } else {
       $1434 = ((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4772|0);
       $1435 = HEAP32[$1434>>2]|0;
       $1436 = ((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4824|0);
       $1437 = HEAP32[$1436>>2]|0;
       $1438 = (($1437) + 1)|0;
       $1439 = (((($gfc)) + 21360|0) + ($1438<<2)|0);
       $1440 = HEAP32[$1439>>2]|0;
       $1441 = ((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4828|0);
       $1442 = HEAP32[$1441>>2]|0;
       $1443 = (($1437) + 2)|0;
       $1444 = (($1443) + ($1442))|0;
       $1445 = (((($gfc)) + 21360|0) + ($1444<<2)|0);
       $1446 = HEAP32[$1445>>2]|0;
       $1447 = ($1440|0)>($1435|0);
       $$$i9$i = $1447 ? $1435 : $1440;
       $1448 = ($1446|0)>($1435|0);
       $region2Start$0$i10$i = $1448 ? $1435 : $1446;
       $1449 = ((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4796|0);
       $1450 = HEAP32[$1449>>2]|0;
       $1451 = (_Huffmancode($gfc,$1450,0,$$$i9$i,$1302)|0);
       $1452 = ((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4800|0);
       $1453 = HEAP32[$1452>>2]|0;
       $1454 = (_Huffmancode($gfc,$1453,$$$i9$i,$region2Start$0$i10$i,$1302)|0);
       $1455 = (($1454) + ($1451))|0;
       $1456 = ((((((($gfc)) + 304|0) + (($gr$054$i*10504)|0)|0) + (($ch$047$i*5252)|0)|0)) + 4804|0);
       $1457 = HEAP32[$1456>>2]|0;
       $1458 = (_Huffmancode($gfc,$1457,$region2Start$0$i10$i,$1435,$1302)|0);
       $1459 = (($1455) + ($1458))|0;
       $$pn$i = $1459;
      }
      $1460 = (_huffman_coder_count1($gfc,$1302)|0);
      $data_bits$4$i = (($data_bits$2$lcssa$i) + ($tot_bits$146$i))|0;
      $1461 = (($data_bits$4$i) + ($$pn$i))|0;
      $1462 = (($1461) + ($1460))|0;
      $1463 = (($ch$047$i) + 1)|0;
      $1464 = HEAP32[$1287>>2]|0;
      $1465 = ($1463|0)<($1464|0);
      if ($1465) {
       $ch$047$i = $1463;$tot_bits$146$i = $1462;
      } else {
       $1823 = $1464;$tot_bits$1$lcssa$i = $1462;
       break;
      }
     }
    } else {
     $1823 = $1300;$tot_bits$1$lcssa$i = $tot_bits$053$i;
    }
    $1466 = (($gr$054$i) + 1)|0;
    $exitcond$i6 = ($1466|0)==(2);
    if ($exitcond$i6) {
     $$pre$phiZ2D = $1297;$tot_bits$3$i = $tot_bits$1$lcssa$i;
     break;
    } else {
     $1300 = $1823;$gr$054$i = $1466;$tot_bits$053$i = $tot_bits$1$lcssa$i;
    }
   }
  } else {
   $1288 = HEAP32[$1287>>2]|0;
   $1289 = ($1288|0)>(0);
   if (!($1289)) {
    $$pre167 = ((($gfc)) + 292|0);
    $$pre$phiZ2D = $$pre167;$tot_bits$3$i = 0;
    break;
   }
   $1290 = ((($gfc)) + 300|0);
   $1291 = ((($gfc)) + 296|0);
   $1292 = ((($gfc)) + 292|0);
   $1293 = ((($gfc)) + 284|0);
   $1294 = ((($gfc)) + 21464|0);
   $ch$179$i = 0;$tot_bits$278$i = 0;
   while(1) {
    $1467 = (((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0);
    $1468 = (((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 4788|0);
    $1469 = HEAP32[$1468>>2]|0;
    $1470 = ($1469|0)==(2);
    $1471 = (((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 5188|0);
    if ($1470) {
     $scale_bits$076$i = 0;$sfb$277$i = 0;$sfb_partition$075$i = 0;
     while(1) {
      $1472 = HEAP32[$1471>>2]|0;
      $1473 = (($1472) + ($sfb_partition$075$i<<2)|0);
      $1474 = HEAP32[$1473>>2]|0;
      $1475 = (($1474|0) / 3)&-1;
      $1476 = ((((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 5192|0) + ($sfb_partition$075$i<<2)|0);
      $1477 = HEAP32[$1476>>2]|0;
      $1478 = ($1474|0)>(2);
      if ($1478) {
       $1479 = ($1477|0)>(0);
       $1480 = ($1475|0)>(1);
       $smax$i = $1480 ? $1475 : 1;
       $i$067$i = 0;$sfb$369$i = $sfb$277$i;
       while(1) {
        $1481 = ($sfb$369$i*3)|0;
        $1482 = ((((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 4608|0) + ($1481<<2)|0);
        $1483 = HEAP32[$1482>>2]|0;
        $1484 = ($1483|0)>(0);
        $$$i7 = $1484 ? $1483 : 0;
        if ($1479) {
         $$01$i12$i = $1477;
         while(1) {
          $1485 = HEAP32[$1290>>2]|0;
          $1486 = ($1485|0)==(0);
          if ($1486) {
           HEAP32[$1290>>2] = 8;
           $1487 = HEAP32[$1291>>2]|0;
           $1488 = (($1487) + 1)|0;
           HEAP32[$1291>>2] = $1488;
           $1489 = HEAP32[$1222>>2]|0;
           $1490 = (((($gfc)) + 39840|0) + (($1489*48)|0)|0);
           $1491 = HEAP32[$1490>>2]|0;
           $1492 = HEAP32[$1292>>2]|0;
           $1493 = ($1491|0)==($1492|0);
           if ($1493) {
            $1494 = HEAP32[$1293>>2]|0;
            $1495 = (($1494) + ($1488)|0);
            $1496 = (((((($gfc)) + 39840|0) + (($1489*48)|0)|0)) + 8|0);
            $1497 = HEAP32[$21>>2]|0;
            _memcpy(($1495|0),($1496|0),($1497|0))|0;
            $1498 = HEAP32[$21>>2]|0;
            $1499 = HEAP32[$1291>>2]|0;
            $1500 = (($1499) + ($1498))|0;
            HEAP32[$1291>>2] = $1500;
            $1501 = $1498 << 3;
            $1502 = HEAP32[$1292>>2]|0;
            $1503 = (($1502) + ($1501))|0;
            HEAP32[$1292>>2] = $1503;
            $1504 = HEAP32[$1222>>2]|0;
            $1505 = (($1504) + 1)|0;
            $1506 = $1505 & 255;
            HEAP32[$1222>>2] = $1506;
            $1509 = $1500;
           } else {
            $1509 = $1488;
           }
           $1507 = HEAP32[$1293>>2]|0;
           $1508 = (($1507) + ($1509)|0);
           HEAP8[$1508>>0] = 0;
           $$pre$i13$i8 = HEAP32[$1290>>2]|0;
           $1511 = $$pre$i13$i8;
          } else {
           $1511 = $1485;
          }
          $1510 = ($$01$i12$i|0)<($1511|0);
          $$0$$i14$i = $1510 ? $$01$i12$i : $1511;
          $1512 = (($$01$i12$i) - ($$0$$i14$i))|0;
          $1513 = (($1511) - ($$0$$i14$i))|0;
          HEAP32[$1290>>2] = $1513;
          $1514 = $$$i7 >> $1512;
          $1515 = $1514 << $1513;
          $1516 = HEAP32[$1291>>2]|0;
          $1517 = HEAP32[$1293>>2]|0;
          $1518 = (($1517) + ($1516)|0);
          $1519 = HEAP8[$1518>>0]|0;
          $1520 = $1519&255;
          $1521 = $1515 | $1520;
          $1522 = $1521&255;
          HEAP8[$1518>>0] = $1522;
          $1523 = HEAP32[$1292>>2]|0;
          $1524 = (($1523) + ($$0$$i14$i))|0;
          HEAP32[$1292>>2] = $1524;
          $1525 = ($1512|0)>(0);
          if ($1525) {
           $$01$i12$i = $1512;
          } else {
           $$lcssa401 = $1524;
           break;
          }
         }
         $1526 = (($1481) + 1)|0;
         $1527 = ((((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 4608|0) + ($1526<<2)|0);
         $1528 = HEAP32[$1527>>2]|0;
         $1529 = ($1528|0)>(0);
         $1530 = $1529 ? $1528 : 0;
         $$01$i17$i = $1477;$1539 = $$lcssa401;
         while(1) {
          $1531 = HEAP32[$1290>>2]|0;
          $1532 = ($1531|0)==(0);
          if ($1532) {
           HEAP32[$1290>>2] = 8;
           $1533 = HEAP32[$1291>>2]|0;
           $1534 = (($1533) + 1)|0;
           HEAP32[$1291>>2] = $1534;
           $1535 = HEAP32[$1222>>2]|0;
           $1536 = (((($gfc)) + 39840|0) + (($1535*48)|0)|0);
           $1537 = HEAP32[$1536>>2]|0;
           $1538 = ($1537|0)==($1539|0);
           if ($1538) {
            $1540 = HEAP32[$1293>>2]|0;
            $1541 = (($1540) + ($1534)|0);
            $1542 = (((((($gfc)) + 39840|0) + (($1535*48)|0)|0)) + 8|0);
            $1543 = HEAP32[$21>>2]|0;
            _memcpy(($1541|0),($1542|0),($1543|0))|0;
            $1544 = HEAP32[$21>>2]|0;
            $1545 = HEAP32[$1291>>2]|0;
            $1546 = (($1545) + ($1544))|0;
            HEAP32[$1291>>2] = $1546;
            $1547 = $1544 << 3;
            $1548 = HEAP32[$1292>>2]|0;
            $1549 = (($1548) + ($1547))|0;
            HEAP32[$1292>>2] = $1549;
            $1550 = HEAP32[$1222>>2]|0;
            $1551 = (($1550) + 1)|0;
            $1552 = $1551 & 255;
            HEAP32[$1222>>2] = $1552;
            $1555 = $1546;
           } else {
            $1555 = $1534;
           }
           $1553 = HEAP32[$1293>>2]|0;
           $1554 = (($1553) + ($1555)|0);
           HEAP8[$1554>>0] = 0;
           $$pre$i18$i = HEAP32[$1290>>2]|0;
           $1557 = $$pre$i18$i;
          } else {
           $1557 = $1531;
          }
          $1556 = ($$01$i17$i|0)<($1557|0);
          $$0$$i19$i9 = $1556 ? $$01$i17$i : $1557;
          $1558 = (($$01$i17$i) - ($$0$$i19$i9))|0;
          $1559 = (($1557) - ($$0$$i19$i9))|0;
          HEAP32[$1290>>2] = $1559;
          $1560 = $1530 >> $1558;
          $1561 = $1560 << $1559;
          $1562 = HEAP32[$1291>>2]|0;
          $1563 = HEAP32[$1293>>2]|0;
          $1564 = (($1563) + ($1562)|0);
          $1565 = HEAP8[$1564>>0]|0;
          $1566 = $1565&255;
          $1567 = $1561 | $1566;
          $1568 = $1567&255;
          HEAP8[$1564>>0] = $1568;
          $1569 = HEAP32[$1292>>2]|0;
          $1570 = (($1569) + ($$0$$i19$i9))|0;
          HEAP32[$1292>>2] = $1570;
          $1571 = ($1558|0)>(0);
          if ($1571) {
           $$01$i17$i = $1558;$1539 = $1570;
          } else {
           $$lcssa402 = $1570;
           break;
          }
         }
         $1572 = (($1481) + 2)|0;
         $1573 = ((((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 4608|0) + ($1572<<2)|0);
         $1574 = HEAP32[$1573>>2]|0;
         $1575 = ($1574|0)>(0);
         $$1$i10 = $1575 ? $1574 : 0;
         $$01$i22$i = $1477;$1584 = $$lcssa402;
         while(1) {
          $1576 = HEAP32[$1290>>2]|0;
          $1577 = ($1576|0)==(0);
          if ($1577) {
           HEAP32[$1290>>2] = 8;
           $1578 = HEAP32[$1291>>2]|0;
           $1579 = (($1578) + 1)|0;
           HEAP32[$1291>>2] = $1579;
           $1580 = HEAP32[$1222>>2]|0;
           $1581 = (((($gfc)) + 39840|0) + (($1580*48)|0)|0);
           $1582 = HEAP32[$1581>>2]|0;
           $1583 = ($1582|0)==($1584|0);
           if ($1583) {
            $1585 = HEAP32[$1293>>2]|0;
            $1586 = (($1585) + ($1579)|0);
            $1587 = (((((($gfc)) + 39840|0) + (($1580*48)|0)|0)) + 8|0);
            $1588 = HEAP32[$21>>2]|0;
            _memcpy(($1586|0),($1587|0),($1588|0))|0;
            $1589 = HEAP32[$21>>2]|0;
            $1590 = HEAP32[$1291>>2]|0;
            $1591 = (($1590) + ($1589))|0;
            HEAP32[$1291>>2] = $1591;
            $1592 = $1589 << 3;
            $1593 = HEAP32[$1292>>2]|0;
            $1594 = (($1593) + ($1592))|0;
            HEAP32[$1292>>2] = $1594;
            $1595 = HEAP32[$1222>>2]|0;
            $1596 = (($1595) + 1)|0;
            $1597 = $1596 & 255;
            HEAP32[$1222>>2] = $1597;
            $1600 = $1591;
           } else {
            $1600 = $1579;
           }
           $1598 = HEAP32[$1293>>2]|0;
           $1599 = (($1598) + ($1600)|0);
           HEAP8[$1599>>0] = 0;
           $$pre$i23$i = HEAP32[$1290>>2]|0;
           $1602 = $$pre$i23$i;
          } else {
           $1602 = $1576;
          }
          $1601 = ($$01$i22$i|0)<($1602|0);
          $$0$$i24$i = $1601 ? $$01$i22$i : $1602;
          $1603 = (($$01$i22$i) - ($$0$$i24$i))|0;
          $1604 = (($1602) - ($$0$$i24$i))|0;
          HEAP32[$1290>>2] = $1604;
          $1605 = $$1$i10 >> $1603;
          $1606 = $1605 << $1604;
          $1607 = HEAP32[$1291>>2]|0;
          $1608 = HEAP32[$1293>>2]|0;
          $1609 = (($1608) + ($1607)|0);
          $1610 = HEAP8[$1609>>0]|0;
          $1611 = $1610&255;
          $1612 = $1606 | $1611;
          $1613 = $1612&255;
          HEAP8[$1609>>0] = $1613;
          $1614 = HEAP32[$1292>>2]|0;
          $1615 = (($1614) + ($$0$$i24$i))|0;
          HEAP32[$1292>>2] = $1615;
          $1616 = ($1603|0)>(0);
          if ($1616) {
           $$01$i22$i = $1603;$1584 = $1615;
          } else {
           break;
          }
         }
        }
        $1617 = (($i$067$i) + 1)|0;
        $1618 = (($sfb$369$i) + 1)|0;
        $1619 = ($1617|0)<($1475|0);
        if ($1619) {
         $i$067$i = $1617;$sfb$369$i = $1618;
        } else {
         break;
        }
       }
       $1620 = ($1477*3)|0;
       $1621 = Math_imul($1620, $smax$i)|0;
       $1622 = (($smax$i) + ($sfb$277$i))|0;
       $1623 = (($1621) + ($scale_bits$076$i))|0;
       $scale_bits$1$lcssa$i = $1623;$sfb$3$lcssa$i = $1622;
      } else {
       $scale_bits$1$lcssa$i = $scale_bits$076$i;$sfb$3$lcssa$i = $sfb$277$i;
      }
      $1624 = (($sfb_partition$075$i) + 1)|0;
      $exitcond95$i = ($1624|0)==(4);
      if ($exitcond95$i) {
       $scale_bits$1$lcssa$i$lcssa = $scale_bits$1$lcssa$i;
       break;
      } else {
       $scale_bits$076$i = $scale_bits$1$lcssa$i;$sfb$277$i = $sfb$3$lcssa$i;$sfb_partition$075$i = $1624;
      }
     }
     $1625 = HEAP32[$1294>>2]|0;
     $1626 = ($1625*3)|0;
     $1627 = (((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 4772|0);
     $1628 = HEAP32[$1627>>2]|0;
     $1629 = ($1626|0)>($1628|0);
     $$$i26$i = $1629 ? $1628 : $1626;
     $1630 = (((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 4796|0);
     $1631 = HEAP32[$1630>>2]|0;
     $1632 = (_Huffmancode($gfc,$1631,0,$$$i26$i,$1467)|0);
     $1633 = (((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 4800|0);
     $1634 = HEAP32[$1633>>2]|0;
     $1635 = HEAP32[$1627>>2]|0;
     $1636 = (_Huffmancode($gfc,$1634,$$$i26$i,$1635,$1467)|0);
     $1637 = (($1636) + ($1632))|0;
     $data_bits$5$i = $1637;$scale_bits$4$i = $scale_bits$1$lcssa$i$lcssa;
    } else {
     $scale_bits$265$i = 0;$sfb$466$i = 0;$sfb_partition$164$i = 0;
     while(1) {
      $1638 = HEAP32[$1471>>2]|0;
      $1639 = (($1638) + ($sfb_partition$164$i<<2)|0);
      $1640 = HEAP32[$1639>>2]|0;
      $1641 = ((((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 5192|0) + ($sfb_partition$164$i<<2)|0);
      $1642 = HEAP32[$1641>>2]|0;
      $1643 = ($1640|0)>(0);
      if ($1643) {
       $1644 = ($1642|0)>(0);
       if ($1644) {
        $i$156$us$i = 0;$sfb$558$us$i = $sfb$466$i;
        while(1) {
         $1645 = ((((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 4608|0) + ($sfb$558$us$i<<2)|0);
         $1646 = HEAP32[$1645>>2]|0;
         $1647 = ($1646|0)>(0);
         $$2$us$i = $1647 ? $1646 : 0;
         $$01$i28$us$i = $1642;
         while(1) {
          $1648 = HEAP32[$1290>>2]|0;
          $1649 = ($1648|0)==(0);
          if ($1649) {
           HEAP32[$1290>>2] = 8;
           $1650 = HEAP32[$1291>>2]|0;
           $1651 = (($1650) + 1)|0;
           HEAP32[$1291>>2] = $1651;
           $1652 = HEAP32[$1222>>2]|0;
           $1653 = (((($gfc)) + 39840|0) + (($1652*48)|0)|0);
           $1654 = HEAP32[$1653>>2]|0;
           $1655 = HEAP32[$1292>>2]|0;
           $1656 = ($1654|0)==($1655|0);
           if ($1656) {
            $1657 = HEAP32[$1293>>2]|0;
            $1658 = (($1657) + ($1651)|0);
            $1659 = (((((($gfc)) + 39840|0) + (($1652*48)|0)|0)) + 8|0);
            $1660 = HEAP32[$21>>2]|0;
            _memcpy(($1658|0),($1659|0),($1660|0))|0;
            $1661 = HEAP32[$21>>2]|0;
            $1662 = HEAP32[$1291>>2]|0;
            $1663 = (($1662) + ($1661))|0;
            HEAP32[$1291>>2] = $1663;
            $1664 = $1661 << 3;
            $1665 = HEAP32[$1292>>2]|0;
            $1666 = (($1665) + ($1664))|0;
            HEAP32[$1292>>2] = $1666;
            $1667 = HEAP32[$1222>>2]|0;
            $1668 = (($1667) + 1)|0;
            $1669 = $1668 & 255;
            HEAP32[$1222>>2] = $1669;
            $1672 = $1663;
           } else {
            $1672 = $1651;
           }
           $1670 = HEAP32[$1293>>2]|0;
           $1671 = (($1670) + ($1672)|0);
           HEAP8[$1671>>0] = 0;
           $$pre$i29$us$i = HEAP32[$1290>>2]|0;
           $1674 = $$pre$i29$us$i;
          } else {
           $1674 = $1648;
          }
          $1673 = ($$01$i28$us$i|0)<($1674|0);
          $$0$$i30$us$i = $1673 ? $$01$i28$us$i : $1674;
          $1675 = (($$01$i28$us$i) - ($$0$$i30$us$i))|0;
          $1676 = (($1674) - ($$0$$i30$us$i))|0;
          HEAP32[$1290>>2] = $1676;
          $1677 = $$2$us$i >> $1675;
          $1678 = $1677 << $1676;
          $1679 = HEAP32[$1291>>2]|0;
          $1680 = HEAP32[$1293>>2]|0;
          $1681 = (($1680) + ($1679)|0);
          $1682 = HEAP8[$1681>>0]|0;
          $1683 = $1682&255;
          $1684 = $1678 | $1683;
          $1685 = $1684&255;
          HEAP8[$1681>>0] = $1685;
          $1686 = HEAP32[$1292>>2]|0;
          $1687 = (($1686) + ($$0$$i30$us$i))|0;
          HEAP32[$1292>>2] = $1687;
          $1688 = ($1675|0)>(0);
          if ($1688) {
           $$01$i28$us$i = $1675;
          } else {
           break;
          }
         }
         $1689 = (($i$156$us$i) + 1)|0;
         $1690 = (($sfb$558$us$i) + 1)|0;
         $exitcond93$i = ($1689|0)==($1640|0);
         if ($exitcond93$i) {
          break;
         } else {
          $i$156$us$i = $1689;$sfb$558$us$i = $1690;
         }
        }
       }
       $$pn100$i = Math_imul($1642, $1640)|0;
       $split63$i = (($$pn100$i) + ($scale_bits$265$i))|0;
       $split62$i = (($1640) + ($sfb$466$i))|0;
       $scale_bits$3$lcssa$i = $split63$i;$sfb$5$lcssa$i = $split62$i;
      } else {
       $scale_bits$3$lcssa$i = $scale_bits$265$i;$sfb$5$lcssa$i = $sfb$466$i;
      }
      $1691 = (($sfb_partition$164$i) + 1)|0;
      $exitcond94$i = ($1691|0)==(4);
      if ($exitcond94$i) {
       $scale_bits$3$lcssa$i$lcssa = $scale_bits$3$lcssa$i;
       break;
      } else {
       $scale_bits$265$i = $scale_bits$3$lcssa$i;$sfb$466$i = $sfb$5$lcssa$i;$sfb_partition$164$i = $1691;
      }
     }
     $1692 = (((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 4772|0);
     $1693 = HEAP32[$1692>>2]|0;
     $1694 = (((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 4824|0);
     $1695 = HEAP32[$1694>>2]|0;
     $1696 = (($1695) + 1)|0;
     $1697 = (((($gfc)) + 21360|0) + ($1696<<2)|0);
     $1698 = HEAP32[$1697>>2]|0;
     $1699 = (((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 4828|0);
     $1700 = HEAP32[$1699>>2]|0;
     $1701 = (($1695) + 2)|0;
     $1702 = (($1701) + ($1700))|0;
     $1703 = (((($gfc)) + 21360|0) + ($1702<<2)|0);
     $1704 = HEAP32[$1703>>2]|0;
     $1705 = ($1698|0)>($1693|0);
     $$$i$i = $1705 ? $1693 : $1698;
     $1706 = ($1704|0)>($1693|0);
     $region2Start$0$i$i = $1706 ? $1693 : $1704;
     $1707 = (((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 4796|0);
     $1708 = HEAP32[$1707>>2]|0;
     $1709 = (_Huffmancode($gfc,$1708,0,$$$i$i,$1467)|0);
     $1710 = (((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 4800|0);
     $1711 = HEAP32[$1710>>2]|0;
     $1712 = (_Huffmancode($gfc,$1711,$$$i$i,$region2Start$0$i$i,$1467)|0);
     $1713 = (($1712) + ($1709))|0;
     $1714 = (((((($gfc)) + 304|0) + (($ch$179$i*5252)|0)|0)) + 4804|0);
     $1715 = HEAP32[$1714>>2]|0;
     $1716 = (_Huffmancode($gfc,$1715,$region2Start$0$i$i,$1693,$1467)|0);
     $1717 = (($1713) + ($1716))|0;
     $data_bits$5$i = $1717;$scale_bits$4$i = $scale_bits$3$lcssa$i$lcssa;
    }
    $1718 = (_huffman_coder_count1($gfc,$1467)|0);
    $1719 = (($scale_bits$4$i) + ($tot_bits$278$i))|0;
    $1720 = (($1719) + ($data_bits$5$i))|0;
    $1721 = (($1720) + ($1718))|0;
    $1722 = (($ch$179$i) + 1)|0;
    $1723 = HEAP32[$1287>>2]|0;
    $1724 = ($1722|0)<($1723|0);
    if ($1724) {
     $ch$179$i = $1722;$tot_bits$278$i = $1721;
    } else {
     $$pre$phiZ2D = $1292;$tot_bits$3$i = $1721;
     break;
    }
   }
  }
 } while(0);
 $1725 = (($tot_bits$3$i) + ($1284))|0;
 $1726 = ((($gfc)) + 21324|0);
 $1727 = HEAP32[$1726>>2]|0;
 _drain_into_ancillary($gfc,$1727);
 $1728 = HEAP32[$1726>>2]|0;
 $1729 = (($1725) + ($1728))|0;
 $1730 = (($14) - ($1729))|0;
 $1731 = (($1730|0) / 8)&-1;
 $1732 = HEAP32[$298>>2]|0;
 $1733 = (($1732) + ($1731))|0;
 HEAP32[$298>>2] = $1733;
 $1734 = HEAP32[$1222>>2]|0;
 $1735 = HEAP32[$17>>2]|0;
 $1736 = (($1735) + -1)|0;
 $1737 = ($1735|0)==(0);
 $$$i = $1737 ? 255 : $1736;
 $1738 = (((($gfc)) + 39840|0) + (($$$i*48)|0)|0);
 $1739 = HEAP32[$1738>>2]|0;
 $1740 = HEAP32[$$pre$phiZ2D>>2]|0;
 $1741 = (($1739) - ($1740))|0;
 $1742 = ($1741|0)>(-1);
 if ($1742) {
  $1743 = (1 - ($1734))|0;
  $1744 = (($$$i) + ($1743))|0;
  $1745 = ($$$i|0)<($1734|0);
  $1746 = (($1744) + 256)|0;
  $$1$i = $1745 ? $1746 : $1744;
  $1747 = $$1$i << 3;
  $1748 = HEAP32[$21>>2]|0;
  $1749 = Math_imul($1747, $1748)|0;
  $1750 = (($1741) - ($1749))|0;
  $flushbits$0$i = $1750;
 } else {
  $flushbits$0$i = $1741;
 }
 $1751 = HEAP32[$1>>2]|0;
 $1752 = ($1751|0)==(0);
 if ($1752) {
  $1755 = ((($gfc)) + 120|0);
  $$idx$val$pre$i$i = HEAP32[$0>>2]|0;
  $$idx$val$i$i = $$idx$val$pre$i$i;$bit_rate$0$in$i$i = $1755;
 } else {
  $1753 = HEAP32[$0>>2]|0;
  $1754 = ((83944 + ($1753<<6)|0) + ($1751<<2)|0);
  $$idx$val$i$i = $1753;$bit_rate$0$in$i$i = $1754;
 }
 $bit_rate$0$i$i = HEAP32[$bit_rate$0$in$i$i>>2]|0;
 $1756 = HEAP32[$7>>2]|0;
 $$idx1$val$i$i = HEAP32[$$idx1$i>>2]|0;
 $1757 = ($$idx$val$i$i*72000)|0;
 $1758 = (($1757) + 72000)|0;
 $1759 = Math_imul($1758, $bit_rate$0$i$i)|0;
 $1760 = (($1759|0) / ($$idx1$val$i$i|0))&-1;
 $1761 = (($1760) + ($1756))|0;
 $1762 = $1761 << 3;
 $1763 = (($1762) + ($flushbits$0$i))|0;
 $1764 = ($1763|0)<(0);
 if ($1764) {
  _lame_errorf($gfc,1072,$vararg_buffer1);
 }
 $1765 = ((($gfc)) + 52140|0);
 $1766 = HEAP32[$1765>>2]|0;
 $1767 = ($1763|0)==($1766|0);
 if ($1767) {
  $1771 = $1763;
 } else {
  _lame_errorf($gfc,1168,$vararg_buffer3);
  $$pre = HEAP32[$1765>>2]|0;
  $1771 = $$pre;
 }
 $1768 = HEAP32[$298>>2]|0;
 $1769 = $1768 << 3;
 $1770 = ($1769|0)==($1771|0);
 if (!($1770)) {
  $1772 = HEAP32[$1726>>2]|0;
  $1773 = HEAP32[$15>>2]|0;
  $1774 = HEAP32[$21>>2]|0;
  $1775 = $1774 << 3;
  $1776 = (($1729) - ($1772))|0;
  $1777 = (($1776) - ($1775))|0;
  $1778 = (($1729|0) % 8)&-1;
  HEAP32[$vararg_buffer5>>2] = $1769;
  $vararg_ptr7 = ((($vararg_buffer5)) + 4|0);
  HEAP32[$vararg_ptr7>>2] = $1771;
  $vararg_ptr8 = ((($vararg_buffer5)) + 8|0);
  HEAP32[$vararg_ptr8>>2] = $1772;
  $vararg_ptr9 = ((($vararg_buffer5)) + 12|0);
  HEAP32[$vararg_ptr9>>2] = $1773;
  $vararg_ptr10 = ((($vararg_buffer5)) + 16|0);
  HEAP32[$vararg_ptr10>>2] = $1775;
  $vararg_ptr11 = ((($vararg_buffer5)) + 20|0);
  HEAP32[$vararg_ptr11>>2] = $1777;
  $vararg_ptr12 = ((($vararg_buffer5)) + 24|0);
  HEAP32[$vararg_ptr12>>2] = $1729;
  $vararg_ptr13 = ((($vararg_buffer5)) + 28|0);
  HEAP32[$vararg_ptr13>>2] = $1778;
  $vararg_ptr14 = ((($vararg_buffer5)) + 32|0);
  HEAP32[$vararg_ptr14>>2] = $14;
  _lame_errorf($gfc,1224,$vararg_buffer5);
  _lame_errorf($gfc,1504,$vararg_buffer15);
  _lame_errorf($gfc,1560,$vararg_buffer17);
  _lame_errorf($gfc,1640,$vararg_buffer19);
  _lame_errorf($gfc,1680,$vararg_buffer21);
  $1779 = HEAP32[$298>>2]|0;
  $1780 = $1779 << 3;
  HEAP32[$1765>>2] = $1780;
 }
 $1781 = HEAP32[$$pre$phiZ2D>>2]|0;
 $1782 = ($1781|0)>(1000000000);
 if ($1782) {
  $i$091 = 0;
 } else {
  STACKTOP = sp;return 0;
 }
 while(1) {
  $1783 = (((($gfc)) + 39840|0) + (($i$091*48)|0)|0);
  $1784 = HEAP32[$1783>>2]|0;
  $1785 = (($1784) - ($1781))|0;
  HEAP32[$1783>>2] = $1785;
  $1786 = (($i$091) + 1)|0;
  $exitcond = ($1786|0)==(256);
  if ($exitcond) {
   break;
  } else {
   $i$091 = $1786;
  }
 }
 HEAP32[$$pre$phiZ2D>>2] = 0;
 STACKTOP = sp;return 0;
}
function _copy_buffer($gfc,$buffer,$size,$mp3data) {
 $gfc = $gfc|0;
 $buffer = $buffer|0;
 $size = $size|0;
 $mp3data = $mp3data|0;
 var $$$i = 0, $$0 = 0, $$pre$i = 0.0, $$pre8$i = 0.0, $$pre8$i$lcssa = 0.0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0;
 var $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0.0, $32 = 0, $33 = 0.0, $34 = 0.0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0;
 var $40 = 0.0, $41 = 0, $42 = 0.0, $43 = 0.0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0.0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $exitcond$i = 0;
 var $exitcond7$i = 0, $i$03$i = 0, $i$14$i = 0, $mp3_in$06$i = 0, $or$cond$i = 0, $pcm_buf$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 9216|0;
 $pcm_buf$i = sp;
 $0 = ((($gfc)) + 296|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = (($1) + 1)|0;
 $3 = ($1|0)<(0);
 if ($3) {
  $$0 = 0;
  STACKTOP = sp;return ($$0|0);
 }
 $4 = ($size|0)==(0);
 $5 = ($1|0)<($size|0);
 $or$cond$i = $4 | $5;
 if (!($or$cond$i)) {
  $$0 = -1;
  STACKTOP = sp;return ($$0|0);
 }
 $6 = ((($gfc)) + 284|0);
 $7 = HEAP32[$6>>2]|0;
 _memcpy(($buffer|0),($7|0),($2|0))|0;
 HEAP32[$0>>2] = -1;
 $8 = ((($gfc)) + 300|0);
 HEAP32[$8>>2] = 0;
 $9 = ($mp3data|0)==(0);
 if ($9) {
  $$0 = $2;
  STACKTOP = sp;return ($$0|0);
 }
 $10 = ((($gfc)) + 85752|0);
 _UpdateMusicCRC($10,$buffer,$2);
 $11 = ((($gfc)) + 85788|0);
 $12 = HEAP32[$11>>2]|0;
 $13 = (($12) + ($2))|0;
 HEAP32[$11>>2] = $13;
 $14 = ((($gfc)) + 136|0);
 $15 = HEAP32[$14>>2]|0;
 $16 = ($15|0)==(0);
 if ($16) {
  $$0 = $2;
  STACKTOP = sp;return ($$0|0);
 }
 $17 = ((($gfc)) + 85808|0);
 $18 = ((($pcm_buf$i)) + 4608|0);
 $19 = ((($gfc)) + 132|0);
 $20 = ((($gfc)) + 128|0);
 $21 = ((($gfc)) + 85676|0);
 $22 = ((($gfc)) + 72|0);
 $23 = ((($gfc)) + 85684|0);
 $mp3_in$06$i = $2;
 while(1) {
  $24 = HEAP32[$17>>2]|0;
  $25 = (_hip_decode1_unclipped(($24|0),($buffer|0),($mp3_in$06$i|0),($pcm_buf$i|0),($18|0))|0);
  $26 = ($25|0)==(-1);
  $$$i = $26 ? 0 : $25;
  $27 = ($$$i|0)>(0);
  if ($27) {
   $28 = HEAP32[$19>>2]|0;
   $29 = ($28|0)==(0);
   if (!($29)) {
    $$pre$i = +HEAPF32[$23>>2];
    $33 = $$pre$i;$i$03$i = 0;
    while(1) {
     $30 = (($pcm_buf$i) + ($i$03$i<<2)|0);
     $31 = +HEAPF32[$30>>2];
     $32 = $31 > $33;
     if ($32) {
      HEAPF32[$23>>2] = $31;
      $$pre8$i = $31;
     } else {
      $34 = -$31;
      $35 = $33 < $34;
      if ($35) {
       HEAPF32[$23>>2] = $34;
       $$pre8$i = $34;
      } else {
       $$pre8$i = $33;
      }
     }
     $36 = (($i$03$i) + 1)|0;
     $exitcond$i = ($36|0)==($$$i|0);
     if ($exitcond$i) {
      $$pre8$i$lcssa = $$pre8$i;
      break;
     } else {
      $33 = $$pre8$i;$i$03$i = $36;
     }
    }
    $37 = HEAP32[$22>>2]|0;
    $38 = ($37|0)>(1);
    if ($38) {
     $42 = $$pre8$i$lcssa;$i$14$i = 0;
     while(1) {
      $39 = (((($pcm_buf$i)) + 4608|0) + ($i$14$i<<2)|0);
      $40 = +HEAPF32[$39>>2];
      $41 = $40 > $42;
      if ($41) {
       HEAPF32[$23>>2] = $40;
       $53 = $40;
      } else {
       $43 = -$40;
       $44 = $42 < $43;
       if ($44) {
        HEAPF32[$23>>2] = $43;
        $53 = $43;
       } else {
        $53 = $42;
       }
      }
      $45 = (($i$14$i) + 1)|0;
      $exitcond7$i = ($45|0)==($$$i|0);
      if ($exitcond7$i) {
       break;
      } else {
       $42 = $53;$i$14$i = $45;
      }
     }
    }
   }
   $46 = HEAP32[$20>>2]|0;
   $47 = ($46|0)==(0);
   if (!($47)) {
    $48 = HEAP32[$21>>2]|0;
    $49 = HEAP32[$22>>2]|0;
    $50 = (_AnalyzeSamples(($48|0),($pcm_buf$i|0),($18|0),($$$i|0),($49|0))|0);
    $51 = ($50|0)==(0);
    if ($51) {
     label = 24;
     break;
    }
   }
  }
  $52 = ($$$i|0)==(0);
  if ($52) {
   label = 23;
   break;
  } else {
   $mp3_in$06$i = 0;
  }
 }
 if ((label|0) == 23) {
  $$0 = $2;
  STACKTOP = sp;return ($$0|0);
 }
 else if ((label|0) == 24) {
  $$0 = -6;
  STACKTOP = sp;return ($$0|0);
 }
 return (0)|0;
}
function _init_bit_stream_w($gfc) {
 $gfc = $gfc|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gfc)) + 52132|0);
 HEAP32[$0>>2] = 0;
 $1 = ((($gfc)) + 52128|0);
 HEAP32[$1>>2] = 0;
 $2 = ((($gfc)) + 39840|0);
 HEAP32[$2>>2] = 0;
 $3 = (_malloc(147456)|0);
 $4 = ((($gfc)) + 284|0);
 HEAP32[$4>>2] = $3;
 $5 = ((($gfc)) + 288|0);
 HEAP32[$5>>2] = 147456;
 $6 = ((($gfc)) + 296|0);
 HEAP32[$6>>2] = -1;
 $7 = ((($gfc)) + 300|0);
 HEAP32[$7>>2] = 0;
 $8 = ((($gfc)) + 292|0);
 HEAP32[$8>>2] = 0;
 return;
}
function _drain_into_ancillary($gfc,$remainingBits) {
 $gfc = $gfc|0;
 $remainingBits = $remainingBits|0;
 var $$0$$i = 0, $$0$$i11 = 0, $$0$$i15 = 0, $$0$$i19 = 0, $$0$$i3 = 0, $$0$$i7 = 0, $$01$i = 0, $$01$i1 = 0, $$01$i13 = 0, $$01$i17 = 0, $$01$i5 = 0, $$01$i9 = 0, $$428 = 0, $$5$ph = 0, $$5$ph30 = 0, $$526 = 0, $$lcssa42 = 0, $$lcssa43 = 0, $$lcssa44 = 0, $$pre = 0;
 var $$pre$i = 0, $$pre$i10 = 0, $$pre$i14 = 0, $$pre$i18 = 0, $$pre$i2 = 0, $$pre$i6 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0;
 var $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0;
 var $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0;
 var $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0;
 var $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0;
 var $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0;
 var $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0;
 var $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0;
 var $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0;
 var $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0;
 var $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $3 = 0;
 var $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0;
 var $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0;
 var $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0;
 var $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $i$027 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($remainingBits|0)>(7);
 if ($0) {
  $10 = ((($gfc)) + 300|0);
  $11 = ((($gfc)) + 296|0);
  $12 = ((($gfc)) + 52132|0);
  $13 = ((($gfc)) + 292|0);
  $14 = ((($gfc)) + 284|0);
  $15 = ((($gfc)) + 24|0);
  $$01$i = 8;
  while(1) {
   $16 = HEAP32[$10>>2]|0;
   $17 = ($16|0)==(0);
   if ($17) {
    HEAP32[$10>>2] = 8;
    $18 = HEAP32[$11>>2]|0;
    $19 = (($18) + 1)|0;
    HEAP32[$11>>2] = $19;
    $20 = HEAP32[$12>>2]|0;
    $21 = (((($gfc)) + 39840|0) + (($20*48)|0)|0);
    $22 = HEAP32[$21>>2]|0;
    $23 = HEAP32[$13>>2]|0;
    $24 = ($22|0)==($23|0);
    if ($24) {
     $25 = HEAP32[$14>>2]|0;
     $26 = (($25) + ($19)|0);
     $27 = (((((($gfc)) + 39840|0) + (($20*48)|0)|0)) + 8|0);
     $28 = HEAP32[$15>>2]|0;
     _memcpy(($26|0),($27|0),($28|0))|0;
     $29 = HEAP32[$15>>2]|0;
     $30 = HEAP32[$11>>2]|0;
     $31 = (($30) + ($29))|0;
     HEAP32[$11>>2] = $31;
     $32 = $29 << 3;
     $33 = HEAP32[$13>>2]|0;
     $34 = (($33) + ($32))|0;
     HEAP32[$13>>2] = $34;
     $35 = HEAP32[$12>>2]|0;
     $36 = (($35) + 1)|0;
     $37 = $36 & 255;
     HEAP32[$12>>2] = $37;
     $40 = $31;
    } else {
     $40 = $19;
    }
    $38 = HEAP32[$14>>2]|0;
    $39 = (($38) + ($40)|0);
    HEAP8[$39>>0] = 0;
    $$pre$i = HEAP32[$10>>2]|0;
    $42 = $$pre$i;
   } else {
    $42 = $16;
   }
   $41 = ($$01$i|0)<($42|0);
   $$0$$i = $41 ? $$01$i : $42;
   $43 = (($$01$i) - ($$0$$i))|0;
   $44 = (($42) - ($$0$$i))|0;
   HEAP32[$10>>2] = $44;
   $45 = 76 >>> $43;
   $46 = $45 << $44;
   $47 = HEAP32[$11>>2]|0;
   $48 = HEAP32[$14>>2]|0;
   $49 = (($48) + ($47)|0);
   $50 = HEAP8[$49>>0]|0;
   $51 = $50&255;
   $52 = $46 | $51;
   $53 = $52&255;
   HEAP8[$49>>0] = $53;
   $54 = HEAP32[$13>>2]|0;
   $55 = (($54) + ($$0$$i))|0;
   HEAP32[$13>>2] = $55;
   $56 = ($43|0)>(0);
   if ($56) {
    $$01$i = $43;
   } else {
    $$lcssa44 = $55;
    break;
   }
  }
  $57 = (($remainingBits) + -8)|0;
  $58 = ($57|0)>(7);
  if ($58) {
   $$01$i17 = 8;$67 = $$lcssa44;
   while(1) {
    $59 = HEAP32[$10>>2]|0;
    $60 = ($59|0)==(0);
    if ($60) {
     HEAP32[$10>>2] = 8;
     $61 = HEAP32[$11>>2]|0;
     $62 = (($61) + 1)|0;
     HEAP32[$11>>2] = $62;
     $63 = HEAP32[$12>>2]|0;
     $64 = (((($gfc)) + 39840|0) + (($63*48)|0)|0);
     $65 = HEAP32[$64>>2]|0;
     $66 = ($65|0)==($67|0);
     if ($66) {
      $68 = HEAP32[$14>>2]|0;
      $69 = (($68) + ($62)|0);
      $70 = (((((($gfc)) + 39840|0) + (($63*48)|0)|0)) + 8|0);
      $71 = HEAP32[$15>>2]|0;
      _memcpy(($69|0),($70|0),($71|0))|0;
      $72 = HEAP32[$15>>2]|0;
      $73 = HEAP32[$11>>2]|0;
      $74 = (($73) + ($72))|0;
      HEAP32[$11>>2] = $74;
      $75 = $72 << 3;
      $76 = HEAP32[$13>>2]|0;
      $77 = (($76) + ($75))|0;
      HEAP32[$13>>2] = $77;
      $78 = HEAP32[$12>>2]|0;
      $79 = (($78) + 1)|0;
      $80 = $79 & 255;
      HEAP32[$12>>2] = $80;
      $83 = $74;
     } else {
      $83 = $62;
     }
     $81 = HEAP32[$14>>2]|0;
     $82 = (($81) + ($83)|0);
     HEAP8[$82>>0] = 0;
     $$pre$i18 = HEAP32[$10>>2]|0;
     $85 = $$pre$i18;
    } else {
     $85 = $59;
    }
    $84 = ($$01$i17|0)<($85|0);
    $$0$$i19 = $84 ? $$01$i17 : $85;
    $86 = (($$01$i17) - ($$0$$i19))|0;
    $87 = (($85) - ($$0$$i19))|0;
    HEAP32[$10>>2] = $87;
    $88 = 65 >>> $86;
    $89 = $88 << $87;
    $90 = HEAP32[$11>>2]|0;
    $91 = HEAP32[$14>>2]|0;
    $92 = (($91) + ($90)|0);
    $93 = HEAP8[$92>>0]|0;
    $94 = $93&255;
    $95 = $89 | $94;
    $96 = $95&255;
    HEAP8[$92>>0] = $96;
    $97 = HEAP32[$13>>2]|0;
    $98 = (($97) + ($$0$$i19))|0;
    HEAP32[$13>>2] = $98;
    $99 = ($86|0)>(0);
    if ($99) {
     $$01$i17 = $86;$67 = $98;
    } else {
     $$lcssa43 = $98;
     break;
    }
   }
   $100 = (($remainingBits) + -16)|0;
   $101 = ($100|0)>(7);
   if ($101) {
    $$01$i13 = 8;$110 = $$lcssa43;
    while(1) {
     $102 = HEAP32[$10>>2]|0;
     $103 = ($102|0)==(0);
     if ($103) {
      HEAP32[$10>>2] = 8;
      $104 = HEAP32[$11>>2]|0;
      $105 = (($104) + 1)|0;
      HEAP32[$11>>2] = $105;
      $106 = HEAP32[$12>>2]|0;
      $107 = (((($gfc)) + 39840|0) + (($106*48)|0)|0);
      $108 = HEAP32[$107>>2]|0;
      $109 = ($108|0)==($110|0);
      if ($109) {
       $111 = HEAP32[$14>>2]|0;
       $112 = (($111) + ($105)|0);
       $113 = (((((($gfc)) + 39840|0) + (($106*48)|0)|0)) + 8|0);
       $114 = HEAP32[$15>>2]|0;
       _memcpy(($112|0),($113|0),($114|0))|0;
       $115 = HEAP32[$15>>2]|0;
       $116 = HEAP32[$11>>2]|0;
       $117 = (($116) + ($115))|0;
       HEAP32[$11>>2] = $117;
       $118 = $115 << 3;
       $119 = HEAP32[$13>>2]|0;
       $120 = (($119) + ($118))|0;
       HEAP32[$13>>2] = $120;
       $121 = HEAP32[$12>>2]|0;
       $122 = (($121) + 1)|0;
       $123 = $122 & 255;
       HEAP32[$12>>2] = $123;
       $126 = $117;
      } else {
       $126 = $105;
      }
      $124 = HEAP32[$14>>2]|0;
      $125 = (($124) + ($126)|0);
      HEAP8[$125>>0] = 0;
      $$pre$i14 = HEAP32[$10>>2]|0;
      $128 = $$pre$i14;
     } else {
      $128 = $102;
     }
     $127 = ($$01$i13|0)<($128|0);
     $$0$$i15 = $127 ? $$01$i13 : $128;
     $129 = (($$01$i13) - ($$0$$i15))|0;
     $130 = (($128) - ($$0$$i15))|0;
     HEAP32[$10>>2] = $130;
     $131 = 77 >>> $129;
     $132 = $131 << $130;
     $133 = HEAP32[$11>>2]|0;
     $134 = HEAP32[$14>>2]|0;
     $135 = (($134) + ($133)|0);
     $136 = HEAP8[$135>>0]|0;
     $137 = $136&255;
     $138 = $132 | $137;
     $139 = $138&255;
     HEAP8[$135>>0] = $139;
     $140 = HEAP32[$13>>2]|0;
     $141 = (($140) + ($$0$$i15))|0;
     HEAP32[$13>>2] = $141;
     $142 = ($129|0)>(0);
     if ($142) {
      $$01$i13 = $129;$110 = $141;
     } else {
      $$lcssa42 = $141;
      break;
     }
    }
    $143 = (($remainingBits) + -24)|0;
    $144 = ($143|0)>(7);
    if ($144) {
     $$01$i9 = 8;$153 = $$lcssa42;
     while(1) {
      $145 = HEAP32[$10>>2]|0;
      $146 = ($145|0)==(0);
      if ($146) {
       HEAP32[$10>>2] = 8;
       $147 = HEAP32[$11>>2]|0;
       $148 = (($147) + 1)|0;
       HEAP32[$11>>2] = $148;
       $149 = HEAP32[$12>>2]|0;
       $150 = (((($gfc)) + 39840|0) + (($149*48)|0)|0);
       $151 = HEAP32[$150>>2]|0;
       $152 = ($151|0)==($153|0);
       if ($152) {
        $154 = HEAP32[$14>>2]|0;
        $155 = (($154) + ($148)|0);
        $156 = (((((($gfc)) + 39840|0) + (($149*48)|0)|0)) + 8|0);
        $157 = HEAP32[$15>>2]|0;
        _memcpy(($155|0),($156|0),($157|0))|0;
        $158 = HEAP32[$15>>2]|0;
        $159 = HEAP32[$11>>2]|0;
        $160 = (($159) + ($158))|0;
        HEAP32[$11>>2] = $160;
        $161 = $158 << 3;
        $162 = HEAP32[$13>>2]|0;
        $163 = (($162) + ($161))|0;
        HEAP32[$13>>2] = $163;
        $164 = HEAP32[$12>>2]|0;
        $165 = (($164) + 1)|0;
        $166 = $165 & 255;
        HEAP32[$12>>2] = $166;
        $169 = $160;
       } else {
        $169 = $148;
       }
       $167 = HEAP32[$14>>2]|0;
       $168 = (($167) + ($169)|0);
       HEAP8[$168>>0] = 0;
       $$pre$i10 = HEAP32[$10>>2]|0;
       $171 = $$pre$i10;
      } else {
       $171 = $145;
      }
      $170 = ($$01$i9|0)<($171|0);
      $$0$$i11 = $170 ? $$01$i9 : $171;
      $172 = (($$01$i9) - ($$0$$i11))|0;
      $173 = (($171) - ($$0$$i11))|0;
      HEAP32[$10>>2] = $173;
      $174 = 69 >>> $172;
      $175 = $174 << $173;
      $176 = HEAP32[$11>>2]|0;
      $177 = HEAP32[$14>>2]|0;
      $178 = (($177) + ($176)|0);
      $179 = HEAP8[$178>>0]|0;
      $180 = $179&255;
      $181 = $175 | $180;
      $182 = $181&255;
      HEAP8[$178>>0] = $182;
      $183 = HEAP32[$13>>2]|0;
      $184 = (($183) + ($$0$$i11))|0;
      HEAP32[$13>>2] = $184;
      $185 = ($172|0)>(0);
      if ($185) {
       $$01$i9 = $172;$153 = $184;
      } else {
       break;
      }
     }
     $186 = (($remainingBits) + -32)|0;
     $187 = ($186|0)>(31);
     if ($187) {
      $188 = (_get_lame_short_version()|0);
      $189 = (_strlen(($188|0))|0);
      $190 = ($189|0)>(0);
      if ($190) {
       $$428 = $186;$i$027 = 0;
       while(1) {
        $191 = (($188) + ($i$027)|0);
        $192 = HEAP8[$191>>0]|0;
        $193 = $192 << 24 >> 24;
        $$01$i5 = 8;
        while(1) {
         $194 = HEAP32[$10>>2]|0;
         $195 = ($194|0)==(0);
         if ($195) {
          HEAP32[$10>>2] = 8;
          $196 = HEAP32[$11>>2]|0;
          $197 = (($196) + 1)|0;
          HEAP32[$11>>2] = $197;
          $198 = HEAP32[$12>>2]|0;
          $199 = (((($gfc)) + 39840|0) + (($198*48)|0)|0);
          $200 = HEAP32[$199>>2]|0;
          $201 = HEAP32[$13>>2]|0;
          $202 = ($200|0)==($201|0);
          if ($202) {
           $203 = HEAP32[$14>>2]|0;
           $204 = (($203) + ($197)|0);
           $205 = (((((($gfc)) + 39840|0) + (($198*48)|0)|0)) + 8|0);
           $206 = HEAP32[$15>>2]|0;
           _memcpy(($204|0),($205|0),($206|0))|0;
           $207 = HEAP32[$15>>2]|0;
           $208 = HEAP32[$11>>2]|0;
           $209 = (($208) + ($207))|0;
           HEAP32[$11>>2] = $209;
           $210 = $207 << 3;
           $211 = HEAP32[$13>>2]|0;
           $212 = (($211) + ($210))|0;
           HEAP32[$13>>2] = $212;
           $213 = HEAP32[$12>>2]|0;
           $214 = (($213) + 1)|0;
           $215 = $214 & 255;
           HEAP32[$12>>2] = $215;
           $218 = $209;
          } else {
           $218 = $197;
          }
          $216 = HEAP32[$14>>2]|0;
          $217 = (($216) + ($218)|0);
          HEAP8[$217>>0] = 0;
          $$pre$i6 = HEAP32[$10>>2]|0;
          $220 = $$pre$i6;
         } else {
          $220 = $194;
         }
         $219 = ($$01$i5|0)<($220|0);
         $$0$$i7 = $219 ? $$01$i5 : $220;
         $221 = (($$01$i5) - ($$0$$i7))|0;
         $222 = (($220) - ($$0$$i7))|0;
         HEAP32[$10>>2] = $222;
         $223 = $193 >> $221;
         $224 = $223 << $222;
         $225 = HEAP32[$11>>2]|0;
         $226 = HEAP32[$14>>2]|0;
         $227 = (($226) + ($225)|0);
         $228 = HEAP8[$227>>0]|0;
         $229 = $228&255;
         $230 = $224 | $229;
         $231 = $230&255;
         HEAP8[$227>>0] = $231;
         $232 = HEAP32[$13>>2]|0;
         $233 = (($232) + ($$0$$i7))|0;
         HEAP32[$13>>2] = $233;
         $234 = ($221|0)>(0);
         if ($234) {
          $$01$i5 = $221;
         } else {
          break;
         }
        }
        $235 = (($$428) + -8)|0;
        $236 = (($i$027) + 1)|0;
        $237 = (_strlen(($188|0))|0);
        $238 = ($236|0)<($237|0);
        $239 = ($235|0)>(7);
        $240 = $239 & $238;
        if ($240) {
         $$428 = $235;$i$027 = $236;
        } else {
         $$5$ph = $235;
         label = 2;
         break;
        }
       }
      } else {
       $$5$ph30 = $186;
      }
     } else {
      $$5$ph = $186;
      label = 2;
     }
    } else {
     $$5$ph = $143;
     label = 2;
    }
   } else {
    $$5$ph = $100;
    label = 2;
   }
  } else {
   $$5$ph = $57;
   label = 2;
  }
 } else {
  $$5$ph = $remainingBits;
  label = 2;
 }
 if ((label|0) == 2) {
  $1 = ($$5$ph|0)>(0);
  if ($1) {
   $$5$ph30 = $$5$ph;
  } else {
   return;
  }
 }
 $2 = ((($gfc)) + 52136|0);
 $3 = ((($gfc)) + 300|0);
 $4 = ((($gfc)) + 296|0);
 $5 = ((($gfc)) + 52132|0);
 $6 = ((($gfc)) + 292|0);
 $7 = ((($gfc)) + 284|0);
 $8 = ((($gfc)) + 24|0);
 $9 = ((($gfc)) + 144|0);
 $$pre = HEAP32[$2>>2]|0;
 $$526 = $$5$ph30;$271 = $$pre;
 while(1) {
  $$01$i1 = 1;
  while(1) {
   $241 = HEAP32[$3>>2]|0;
   $242 = ($241|0)==(0);
   if ($242) {
    HEAP32[$3>>2] = 8;
    $243 = HEAP32[$4>>2]|0;
    $244 = (($243) + 1)|0;
    HEAP32[$4>>2] = $244;
    $245 = HEAP32[$5>>2]|0;
    $246 = (((($gfc)) + 39840|0) + (($245*48)|0)|0);
    $247 = HEAP32[$246>>2]|0;
    $248 = HEAP32[$6>>2]|0;
    $249 = ($247|0)==($248|0);
    if ($249) {
     $250 = HEAP32[$7>>2]|0;
     $251 = (($250) + ($244)|0);
     $252 = (((((($gfc)) + 39840|0) + (($245*48)|0)|0)) + 8|0);
     $253 = HEAP32[$8>>2]|0;
     _memcpy(($251|0),($252|0),($253|0))|0;
     $254 = HEAP32[$8>>2]|0;
     $255 = HEAP32[$4>>2]|0;
     $256 = (($255) + ($254))|0;
     HEAP32[$4>>2] = $256;
     $257 = $254 << 3;
     $258 = HEAP32[$6>>2]|0;
     $259 = (($258) + ($257))|0;
     HEAP32[$6>>2] = $259;
     $260 = HEAP32[$5>>2]|0;
     $261 = (($260) + 1)|0;
     $262 = $261 & 255;
     HEAP32[$5>>2] = $262;
     $265 = $256;
    } else {
     $265 = $244;
    }
    $263 = HEAP32[$7>>2]|0;
    $264 = (($263) + ($265)|0);
    HEAP8[$264>>0] = 0;
    $$pre$i2 = HEAP32[$3>>2]|0;
    $267 = $$pre$i2;
   } else {
    $267 = $241;
   }
   $266 = ($$01$i1|0)<($267|0);
   $$0$$i3 = $266 ? $$01$i1 : $267;
   $268 = (($$01$i1) - ($$0$$i3))|0;
   $269 = (($267) - ($$0$$i3))|0;
   HEAP32[$3>>2] = $269;
   $270 = $271 >> $268;
   $272 = $270 << $269;
   $273 = HEAP32[$4>>2]|0;
   $274 = HEAP32[$7>>2]|0;
   $275 = (($274) + ($273)|0);
   $276 = HEAP8[$275>>0]|0;
   $277 = $276&255;
   $278 = $272 | $277;
   $279 = $278&255;
   HEAP8[$275>>0] = $279;
   $280 = HEAP32[$6>>2]|0;
   $281 = (($280) + ($$0$$i3))|0;
   HEAP32[$6>>2] = $281;
   $282 = ($268|0)>(0);
   if ($282) {
    $$01$i1 = $268;
   } else {
    break;
   }
  }
  $283 = HEAP32[$9>>2]|0;
  $284 = ($283|0)==(0);
  $285 = $284&1;
  $286 = HEAP32[$2>>2]|0;
  $287 = $285 ^ $286;
  HEAP32[$2>>2] = $287;
  $288 = (($$526) + -1)|0;
  $289 = ($$526|0)>(1);
  if ($289) {
   $$526 = $288;$271 = $287;
  } else {
   break;
  }
 }
 return;
}
function _Huffmancode($gfc,$tableindex,$start,$end,$gi) {
 $gfc = $gfc|0;
 $tableindex = $tableindex|0;
 $start = $start|0;
 $end = $end|0;
 $gi = $gi|0;
 var $$0 = 0, $$0$$i = 0, $$0$$i4 = 0, $$01$i = 0, $$01$i2 = 0, $$pre$i = 0, $$pre$i3 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0;
 var $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0;
 var $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0;
 var $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0.0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0;
 var $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0.0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0;
 var $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0;
 var $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0;
 var $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $bits$015 = 0, $cbits$0 = 0, $cbits$1 = 0, $ext$0 = 0, $ext$1 = 0, $ext$2 = 0, $ext$4 = 0;
 var $ext$410 = 0, $ext$5 = 0, $ext$6 = 0, $i$016 = 0, $or$cond = 0, $x1$0 = 0, $x1$1 = 0, $x1$111 = 0, $x1$112 = 0, $x2$113 = 0, $x2$114 = 0, $xbits$0 = 0, $xbits$2 = 0, $xbits$26 = 0, $xbits$27 = 0, $xlen$0 = 0, $xlen$08 = 0, $xlen$09 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (82272 + ($tableindex<<4)|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($tableindex|0)!=(0);
 $3 = ($start|0)<($end|0);
 $or$cond = $2 & $3;
 if (!($or$cond)) {
  $$0 = 0;
  return ($$0|0);
 }
 $4 = ($tableindex>>>0)>(15);
 $5 = $1&65535;
 $6 = (((82272 + ($tableindex<<4)|0)) + 12|0);
 $7 = HEAP32[$6>>2]|0;
 $8 = (((82272 + ($tableindex<<4)|0)) + 8|0);
 $9 = HEAP32[$8>>2]|0;
 $10 = ((($gfc)) + 300|0);
 $11 = ((($gfc)) + 296|0);
 $12 = ((($gfc)) + 52132|0);
 $13 = ((($gfc)) + 292|0);
 $14 = ((($gfc)) + 284|0);
 $15 = ((($gfc)) + 24|0);
 $bits$015 = 0;$i$016 = $start;
 while(1) {
  $16 = (((($gi)) + 2304|0) + ($i$016<<2)|0);
  $17 = HEAP32[$16>>2]|0;
  $18 = (($i$016) + 1)|0;
  $19 = (((($gi)) + 2304|0) + ($18<<2)|0);
  $20 = HEAP32[$19>>2]|0;
  $21 = ($17|0)==(0);
  if ($21) {
   $cbits$0 = 0;$ext$1 = 0;
  } else {
   $22 = (($gi) + ($i$016<<2)|0);
   $23 = +HEAPF32[$22>>2];
   $24 = $23 < 0.0;
   $ext$0 = $24&1;
   $cbits$0 = -1;$ext$1 = $ext$0;
  }
  if ($4) {
   $25 = ($17>>>0)>(14);
   if ($25) {
    $26 = $17 << 1;
    $27 = (($26) + 131042)|0;
    $28 = $27 & 131070;
    $29 = $ext$1 | $28;
    $ext$2 = $29;$x1$0 = 15;$xbits$0 = $5;
   } else {
    $ext$2 = $ext$1;$x1$0 = $17;$xbits$0 = 0;
   }
   $30 = ($20>>>0)>(14);
   if ($30) {
    $31 = (($20) + 65521)|0;
    $32 = $ext$2 << $1;
    $33 = $31 & 65535;
    $34 = $32 | $33;
    $35 = $xbits$0&65535;
    $36 = (($35) + ($1))|0;
    $37 = $36&65535;
    $ext$410 = $34;$x1$111 = $x1$0;$x2$113 = 15;$xbits$26 = $37;$xlen$08 = 16;
    label = 11;
   } else {
    $ext$4 = $ext$2;$x1$1 = $x1$0;$xbits$2 = $xbits$0;$xlen$0 = 16;
    label = 10;
   }
  } else {
   $ext$4 = $ext$1;$x1$1 = $17;$xbits$2 = 0;$xlen$0 = $1;
   label = 10;
  }
  if ((label|0) == 10) {
   label = 0;
   $38 = ($20|0)==(0);
   if ($38) {
    $cbits$1 = $cbits$0;$ext$6 = $ext$4;$x1$112 = $x1$1;$x2$114 = 0;$xbits$27 = $xbits$2;$xlen$09 = $xlen$0;
   } else {
    $ext$410 = $ext$4;$x1$111 = $x1$1;$x2$113 = $20;$xbits$26 = $xbits$2;$xlen$08 = $xlen$0;
    label = 11;
   }
  }
  if ((label|0) == 11) {
   label = 0;
   $39 = $ext$410 << 1;
   $40 = (($gi) + ($18<<2)|0);
   $41 = +HEAPF32[$40>>2];
   $42 = $41 < 0.0;
   $43 = $42&1;
   $ext$5 = $43 | $39;
   $44 = (($cbits$0) + -1)<<16>>16;
   $cbits$1 = $44;$ext$6 = $ext$5;$x1$112 = $x1$111;$x2$114 = $x2$113;$xbits$27 = $xbits$26;$xlen$09 = $xlen$08;
  }
  $45 = Math_imul($xlen$09, $x1$112)|0;
  $46 = (($45) + ($x2$114))|0;
  $47 = $cbits$1 << 16 >> 16;
  $48 = $xbits$27&65535;
  $49 = (($48) - ($47))|0;
  $50 = (($7) + ($46)|0);
  $51 = HEAP8[$50>>0]|0;
  $52 = $51&255;
  $53 = (($52) + ($47))|0;
  $54 = (($9) + ($46<<1)|0);
  $55 = HEAP16[$54>>1]|0;
  $56 = $55&65535;
  $57 = ($53|0)>(0);
  if ($57) {
   $$01$i = $53;
   while(1) {
    $58 = HEAP32[$10>>2]|0;
    $59 = ($58|0)==(0);
    if ($59) {
     HEAP32[$10>>2] = 8;
     $60 = HEAP32[$11>>2]|0;
     $61 = (($60) + 1)|0;
     HEAP32[$11>>2] = $61;
     $62 = HEAP32[$12>>2]|0;
     $63 = (((($gfc)) + 39840|0) + (($62*48)|0)|0);
     $64 = HEAP32[$63>>2]|0;
     $65 = HEAP32[$13>>2]|0;
     $66 = ($64|0)==($65|0);
     if ($66) {
      $67 = HEAP32[$14>>2]|0;
      $68 = (($67) + ($61)|0);
      $69 = (((((($gfc)) + 39840|0) + (($62*48)|0)|0)) + 8|0);
      $70 = HEAP32[$15>>2]|0;
      _memcpy(($68|0),($69|0),($70|0))|0;
      $71 = HEAP32[$15>>2]|0;
      $72 = HEAP32[$11>>2]|0;
      $73 = (($72) + ($71))|0;
      HEAP32[$11>>2] = $73;
      $74 = $71 << 3;
      $75 = HEAP32[$13>>2]|0;
      $76 = (($75) + ($74))|0;
      HEAP32[$13>>2] = $76;
      $77 = HEAP32[$12>>2]|0;
      $78 = (($77) + 1)|0;
      $79 = $78 & 255;
      HEAP32[$12>>2] = $79;
      $82 = $73;
     } else {
      $82 = $61;
     }
     $80 = HEAP32[$14>>2]|0;
     $81 = (($80) + ($82)|0);
     HEAP8[$81>>0] = 0;
     $$pre$i = HEAP32[$10>>2]|0;
     $84 = $$pre$i;
    } else {
     $84 = $58;
    }
    $83 = ($$01$i|0)<($84|0);
    $$0$$i = $83 ? $$01$i : $84;
    $85 = (($$01$i) - ($$0$$i))|0;
    $86 = (($84) - ($$0$$i))|0;
    HEAP32[$10>>2] = $86;
    $87 = $56 >>> $85;
    $88 = $87 << $86;
    $89 = HEAP32[$11>>2]|0;
    $90 = HEAP32[$14>>2]|0;
    $91 = (($90) + ($89)|0);
    $92 = HEAP8[$91>>0]|0;
    $93 = $92&255;
    $94 = $88 | $93;
    $95 = $94&255;
    HEAP8[$91>>0] = $95;
    $96 = HEAP32[$13>>2]|0;
    $97 = (($96) + ($$0$$i))|0;
    HEAP32[$13>>2] = $97;
    $98 = ($85|0)>(0);
    if ($98) {
     $$01$i = $85;
    } else {
     break;
    }
   }
  }
  $99 = $49 & 65535;
  $100 = ($99|0)==(0);
  if (!($100)) {
   $$01$i2 = $99;
   while(1) {
    $101 = HEAP32[$10>>2]|0;
    $102 = ($101|0)==(0);
    if ($102) {
     HEAP32[$10>>2] = 8;
     $103 = HEAP32[$11>>2]|0;
     $104 = (($103) + 1)|0;
     HEAP32[$11>>2] = $104;
     $105 = HEAP32[$12>>2]|0;
     $106 = (((($gfc)) + 39840|0) + (($105*48)|0)|0);
     $107 = HEAP32[$106>>2]|0;
     $108 = HEAP32[$13>>2]|0;
     $109 = ($107|0)==($108|0);
     if ($109) {
      $110 = HEAP32[$14>>2]|0;
      $111 = (($110) + ($104)|0);
      $112 = (((((($gfc)) + 39840|0) + (($105*48)|0)|0)) + 8|0);
      $113 = HEAP32[$15>>2]|0;
      _memcpy(($111|0),($112|0),($113|0))|0;
      $114 = HEAP32[$15>>2]|0;
      $115 = HEAP32[$11>>2]|0;
      $116 = (($115) + ($114))|0;
      HEAP32[$11>>2] = $116;
      $117 = $114 << 3;
      $118 = HEAP32[$13>>2]|0;
      $119 = (($118) + ($117))|0;
      HEAP32[$13>>2] = $119;
      $120 = HEAP32[$12>>2]|0;
      $121 = (($120) + 1)|0;
      $122 = $121 & 255;
      HEAP32[$12>>2] = $122;
      $125 = $116;
     } else {
      $125 = $104;
     }
     $123 = HEAP32[$14>>2]|0;
     $124 = (($123) + ($125)|0);
     HEAP8[$124>>0] = 0;
     $$pre$i3 = HEAP32[$10>>2]|0;
     $127 = $$pre$i3;
    } else {
     $127 = $101;
    }
    $126 = ($$01$i2|0)<($127|0);
    $$0$$i4 = $126 ? $$01$i2 : $127;
    $128 = (($$01$i2) - ($$0$$i4))|0;
    $129 = (($127) - ($$0$$i4))|0;
    HEAP32[$10>>2] = $129;
    $130 = $ext$6 >> $128;
    $131 = $130 << $129;
    $132 = HEAP32[$11>>2]|0;
    $133 = HEAP32[$14>>2]|0;
    $134 = (($133) + ($132)|0);
    $135 = HEAP8[$134>>0]|0;
    $136 = $135&255;
    $137 = $131 | $136;
    $138 = $137&255;
    HEAP8[$134>>0] = $138;
    $139 = HEAP32[$13>>2]|0;
    $140 = (($139) + ($$0$$i4))|0;
    HEAP32[$13>>2] = $140;
    $141 = ($128|0)>(0);
    if ($141) {
     $$01$i2 = $128;
    } else {
     break;
    }
   }
  }
  $142 = (($99) + ($bits$015))|0;
  $143 = (($142) + ($53))|0;
  $144 = (($i$016) + 2)|0;
  $145 = ($144|0)<($end|0);
  if ($145) {
   $bits$015 = $143;$i$016 = $144;
  } else {
   $$0 = $143;
   break;
  }
 }
 return ($$0|0);
}
function _huffman_coder_count1($gfc,$gi) {
 $gfc = $gfc|0;
 $gi = $gi|0;
 var $$0$$i = 0, $$01$i = 0, $$pre = 0, $$pre$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 var $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0.0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0.0;
 var $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0.0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0.0;
 var $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0;
 var $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0;
 var $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $bits$0$lcssa = 0, $bits$02 = 0, $huffbits$0 = 0, $huffbits$1 = 0, $huffbits$2 = 0, $huffbits$3 = 0, $i$01 = 0;
 var $ix$03 = 0, $p$0 = 0, $p$1 = 0, $p$2 = 0, $p$3 = 0, $xr$04 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gi)) + 4840|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = (($1) + 32)|0;
 $3 = ((($gi)) + 4772|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ((($gi)) + 4776|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = (($6) - ($4))|0;
 $8 = ($7|0)>(3);
 if (!($8)) {
  $bits$0$lcssa = 0;
  return ($bits$0$lcssa|0);
 }
 $9 = (($7|0) / 4)&-1;
 $10 = (($gi) + ($4<<2)|0);
 $11 = (((($gi)) + 2304|0) + ($4<<2)|0);
 $12 = (((82272 + ($2<<4)|0)) + 8|0);
 $13 = HEAP32[$12>>2]|0;
 $14 = (((82272 + ($2<<4)|0)) + 12|0);
 $15 = HEAP32[$14>>2]|0;
 $16 = ((($gfc)) + 300|0);
 $17 = ((($gfc)) + 296|0);
 $18 = ((($gfc)) + 52132|0);
 $19 = ((($gfc)) + 292|0);
 $20 = ((($gfc)) + 284|0);
 $21 = ((($gfc)) + 24|0);
 $bits$02 = 0;$i$01 = $9;$ix$03 = $11;$xr$04 = $10;
 while(1) {
  $22 = HEAP32[$ix$03>>2]|0;
  $23 = ($22|0)==(0);
  if ($23) {
   $huffbits$0 = 0;$p$0 = 0;
  } else {
   $24 = +HEAPF32[$xr$04>>2];
   $25 = $24 < 0.0;
   if ($25) {
    $huffbits$0 = 1;$p$0 = 8;
   } else {
    $huffbits$0 = 0;$p$0 = 8;
   }
  }
  $26 = ((($ix$03)) + 4|0);
  $27 = HEAP32[$26>>2]|0;
  $28 = ($27|0)==(0);
  if ($28) {
   $huffbits$1 = $huffbits$0;$p$1 = $p$0;
  } else {
   $29 = $p$0 | 4;
   $30 = $huffbits$0 << 1;
   $31 = ((($xr$04)) + 4|0);
   $32 = +HEAPF32[$31>>2];
   $33 = $32 < 0.0;
   if ($33) {
    $34 = $30 | 1;
    $huffbits$1 = $34;$p$1 = $29;
   } else {
    $huffbits$1 = $30;$p$1 = $29;
   }
  }
  $35 = ((($ix$03)) + 8|0);
  $36 = HEAP32[$35>>2]|0;
  $37 = ($36|0)==(0);
  if ($37) {
   $huffbits$2 = $huffbits$1;$p$2 = $p$1;
  } else {
   $38 = (($p$1) + 2)|0;
   $39 = $huffbits$1 << 1;
   $40 = ((($xr$04)) + 8|0);
   $41 = +HEAPF32[$40>>2];
   $42 = $41 < 0.0;
   if ($42) {
    $43 = $39 | 1;
    $huffbits$2 = $43;$p$2 = $38;
   } else {
    $huffbits$2 = $39;$p$2 = $38;
   }
  }
  $44 = ((($ix$03)) + 12|0);
  $45 = HEAP32[$44>>2]|0;
  $46 = ($45|0)==(0);
  if ($46) {
   $huffbits$3 = $huffbits$2;$p$3 = $p$2;
  } else {
   $47 = (($p$2) + 1)|0;
   $48 = $huffbits$2 << 1;
   $49 = ((($xr$04)) + 12|0);
   $50 = +HEAPF32[$49>>2];
   $51 = $50 < 0.0;
   if ($51) {
    $52 = $48 | 1;
    $huffbits$3 = $52;$p$3 = $47;
   } else {
    $huffbits$3 = $48;$p$3 = $47;
   }
  }
  $53 = ((($ix$03)) + 16|0);
  $54 = ((($xr$04)) + 16|0);
  $55 = (($13) + ($p$3<<1)|0);
  $56 = HEAP16[$55>>1]|0;
  $57 = $56&65535;
  $58 = (($57) + ($huffbits$3))|0;
  $59 = (($15) + ($p$3)|0);
  $60 = HEAP8[$59>>0]|0;
  $61 = ($60<<24>>24)==(0);
  if ($61) {
   $105 = 0;
  } else {
   $62 = $60&255;
   $$01$i = $62;
   while(1) {
    $63 = HEAP32[$16>>2]|0;
    $64 = ($63|0)==(0);
    if ($64) {
     HEAP32[$16>>2] = 8;
     $65 = HEAP32[$17>>2]|0;
     $66 = (($65) + 1)|0;
     HEAP32[$17>>2] = $66;
     $67 = HEAP32[$18>>2]|0;
     $68 = (((($gfc)) + 39840|0) + (($67*48)|0)|0);
     $69 = HEAP32[$68>>2]|0;
     $70 = HEAP32[$19>>2]|0;
     $71 = ($69|0)==($70|0);
     if ($71) {
      $72 = HEAP32[$20>>2]|0;
      $73 = (($72) + ($66)|0);
      $74 = (((((($gfc)) + 39840|0) + (($67*48)|0)|0)) + 8|0);
      $75 = HEAP32[$21>>2]|0;
      _memcpy(($73|0),($74|0),($75|0))|0;
      $76 = HEAP32[$21>>2]|0;
      $77 = HEAP32[$17>>2]|0;
      $78 = (($77) + ($76))|0;
      HEAP32[$17>>2] = $78;
      $79 = $76 << 3;
      $80 = HEAP32[$19>>2]|0;
      $81 = (($80) + ($79))|0;
      HEAP32[$19>>2] = $81;
      $82 = HEAP32[$18>>2]|0;
      $83 = (($82) + 1)|0;
      $84 = $83 & 255;
      HEAP32[$18>>2] = $84;
      $87 = $78;
     } else {
      $87 = $66;
     }
     $85 = HEAP32[$20>>2]|0;
     $86 = (($85) + ($87)|0);
     HEAP8[$86>>0] = 0;
     $$pre$i = HEAP32[$16>>2]|0;
     $89 = $$pre$i;
    } else {
     $89 = $63;
    }
    $88 = ($$01$i|0)<($89|0);
    $$0$$i = $88 ? $$01$i : $89;
    $90 = (($$01$i) - ($$0$$i))|0;
    $91 = (($89) - ($$0$$i))|0;
    HEAP32[$16>>2] = $91;
    $92 = $58 >> $90;
    $93 = $92 << $91;
    $94 = HEAP32[$17>>2]|0;
    $95 = HEAP32[$20>>2]|0;
    $96 = (($95) + ($94)|0);
    $97 = HEAP8[$96>>0]|0;
    $98 = $97&255;
    $99 = $93 | $98;
    $100 = $99&255;
    HEAP8[$96>>0] = $100;
    $101 = HEAP32[$19>>2]|0;
    $102 = (($101) + ($$0$$i))|0;
    HEAP32[$19>>2] = $102;
    $103 = ($90|0)>(0);
    if ($103) {
     $$01$i = $90;
    } else {
     break;
    }
   }
   $$pre = HEAP8[$59>>0]|0;
   $105 = $$pre;
  }
  $104 = $105&255;
  $106 = (($104) + ($bits$02))|0;
  $107 = (($i$01) + -1)|0;
  $108 = ($i$01|0)>(1);
  if ($108) {
   $bits$02 = $106;$i$01 = $107;$ix$03 = $53;$xr$04 = $54;
  } else {
   $bits$0$lcssa = $106;
   break;
  }
 }
 return ($bits$0$lcssa|0);
}
function _lame_encode_mp3_frame($gfc,$inbuf_l,$inbuf_r,$mp3buf,$mp3buf_size) {
 $gfc = $gfc|0;
 $inbuf_l = $inbuf_l|0;
 $inbuf_r = $inbuf_r|0;
 $mp3buf = $mp3buf|0;
 $mp3buf_size = $mp3buf_size|0;
 var $$$i = 0, $$0 = 0, $$lcssa = 0, $$lcssa116 = 0.0, $$lcssa117 = 0, $$lcssa118 = 0.0, $$lcssa118$lcssa = 0.0, $$lcssa119 = 0.0, $$lcssa119$lcssa = 0.0, $$lcssa121 = 0, $$pn$i = 0.0, $$pn1$i = 0.0, $$pre = 0, $$pre$i = 0, $$pre$i2 = 0, $$pre$i4 = 0, $$pre$phi$iZ2D = 0, $$pre10$i = 0, $$pre6$i = 0, $$pre92 = 0;
 var $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0.0, $102 = 0, $103 = 0.0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0.0, $109 = 0, $11 = 0, $110 = 0.0, $111 = 0, $112 = 0, $113 = 0, $114 = 0.0, $115 = 0;
 var $116 = 0.0, $117 = 0.0, $118 = 0.0, $119 = 0, $12 = 0, $120 = 0, $121 = 0.0, $122 = 0, $123 = 0, $124 = 0.0, $125 = 0, $126 = 0.0, $127 = 0.0, $128 = 0.0, $129 = 0.0, $13 = 0, $130 = 0, $131 = 0.0, $132 = 0, $133 = 0.0;
 var $134 = 0.0, $135 = 0.0, $136 = 0.0, $137 = 0.0, $138 = 0.0, $139 = 0, $14 = 0, $140 = 0, $141 = 0.0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0;
 var $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0.0, $162 = 0.0, $163 = 0, $164 = 0.0, $165 = 0.0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0;
 var $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0;
 var $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0.0, $195 = 0.0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0.0, $204 = 0.0, $205 = 0;
 var $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0.0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0;
 var $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0;
 var $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0;
 var $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0.0, $265 = 0.0, $266 = 0.0, $267 = 0.0, $268 = 0.0, $269 = 0.0, $27 = 0, $270 = 0.0, $271 = 0.0, $272 = 0.0, $273 = 0.0, $274 = 0.0, $275 = 0.0, $276 = 0.0, $277 = 0.0, $278 = 0.0;
 var $279 = 0.0, $28 = 0, $280 = 0.0, $281 = 0.0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0.0, $289 = 0.0, $29 = 0, $290 = 0, $291 = 0, $292 = 0.0, $293 = 0.0, $294 = 0.0, $295 = 0.0, $296 = 0.0;
 var $297 = 0.0, $298 = 0.0, $299 = 0.0, $3 = 0, $30 = 0, $300 = 0.0, $301 = 0.0, $302 = 0.0, $303 = 0.0, $304 = 0.0, $305 = 0.0, $306 = 0.0, $307 = 0.0, $308 = 0.0, $309 = 0.0, $31 = 0, $310 = 0.0, $311 = 0.0, $312 = 0.0, $313 = 0.0;
 var $314 = 0.0, $315 = 0.0, $316 = 0.0, $317 = 0.0, $318 = 0.0, $319 = 0, $32 = 0, $320 = 0, $321 = 0.0, $322 = 0.0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0.0, $328 = 0.0, $329 = 0, $33 = 0, $330 = 0, $331 = 0;
 var $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0;
 var $350 = 0, $351 = 0.0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0.0, $357 = 0.0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0;
 var $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0;
 var $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0;
 var $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $43 = 0;
 var $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0;
 var $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0.0, $78 = 0, $79 = 0.0, $8 = 0;
 var $80 = 0.0, $81 = 0, $82 = 0, $83 = 0.0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0;
 var $99 = 0, $blocktype = 0, $bufp = 0, $ch$02$i = 0, $ch$02$i8 = 0, $ch$069 = 0, $ch$173 = 0, $ch$254$us = 0, $ch$349 = 0, $ch$439$us = 0, $ch$533$us = 0, $ch$632 = 0, $exitcond = 0, $exitcond86 = 0, $exitcond91 = 0, $f$0$lcssa = 0.0, $f$045$us = 0.0, $f$140$us = 0.0, $gr$03$i = 0, $gr$03$i6 = 0;
 var $gr$076 = 0, $gr$161$us = 0, $gr$252 = 0, $gr$343$us = 0, $gr$435$us = 0, $gr2_max$0$i = 0.0, $i$06$i = 0, $inbuf = 0, $j$030 = 0, $j$07$i = 0, $j$1$i = 0, $j$131 = 0, $masking_LR = 0, $masking_MS = 0, $masking_MS$sink = 0, $max_pow$0$i = 0.0, $max_pow$1$i = 0.0, $ms_ener_ratio = 0, $or$cond = 0, $or$cond101 = 0;
 var $pe = 0, $pe_MS = 0, $primebuff0$i = 0, $primebuff1$i = 0, $sum_pe_LR$064$us = 0.0, $sum_pe_LR$156$us = 0.0, $sum_pe_MS$063$us = 0.0, $sum_pe_MS$155$us = 0.0, $tot_ener = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 20112|0;
 $primebuff0$i = sp + 12056|0;
 $primebuff1$i = sp + 4000|0;
 $masking_LR = sp + 2048|0;
 $masking_MS = sp + 96|0;
 $inbuf = sp + 88|0;
 $tot_ener = sp + 56|0;
 $ms_ener_ratio = sp + 8|0;
 $pe = sp + 40|0;
 $pe_MS = sp + 24|0;
 $bufp = sp;
 $blocktype = sp + 16|0;
 $0 = $ms_ener_ratio;
 $1 = $0;
 HEAP32[$1>>2] = 1056964608;
 $2 = (($0) + 4)|0;
 $3 = $2;
 HEAP32[$3>>2] = 1056964608;
 ;HEAP32[$pe>>2]=0|0;HEAP32[$pe+4>>2]=0|0;HEAP32[$pe+8>>2]=0|0;HEAP32[$pe+12>>2]=0|0;
 ;HEAP32[$pe_MS>>2]=0|0;HEAP32[$pe_MS+4>>2]=0|0;HEAP32[$pe_MS+8>>2]=0|0;HEAP32[$pe_MS+12>>2]=0|0;
 HEAP32[$inbuf>>2] = $inbuf_l;
 $4 = ((($inbuf)) + 4|0);
 HEAP32[$4>>2] = $inbuf_r;
 $5 = ((($gfc)) + 4|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = ($6|0)==(0);
 if ($7) {
  $8 = ((($gfc)) + 76|0);
  $9 = HEAP32[$8>>2]|0;
  $10 = ($9*576)|0;
  HEAP32[$5>>2] = 1;
  _memset(($primebuff0$i|0),0,8056)|0;
  _memset(($primebuff1$i|0),0,8056)|0;
  $11 = (($10) + 862)|0;
  $12 = ($11|0)>(0);
  if ($12) {
   $13 = ((($gfc)) + 72|0);
   $i$06$i = 0;$j$07$i = 0;
   while(1) {
    $16 = ($i$06$i|0)<($10|0);
    if ($16) {
     $17 = (($primebuff0$i) + ($i$06$i<<2)|0);
     HEAPF32[$17>>2] = 0.0;
     $18 = HEAP32[$13>>2]|0;
     $19 = ($18|0)==(2);
     if ($19) {
      $20 = (($primebuff1$i) + ($i$06$i<<2)|0);
      HEAPF32[$20>>2] = 0.0;
      $j$1$i = $j$07$i;
     } else {
      $j$1$i = $j$07$i;
     }
    } else {
     $21 = (($inbuf_l) + ($j$07$i<<2)|0);
     $22 = HEAP32[$21>>2]|0;
     $23 = (($primebuff0$i) + ($i$06$i<<2)|0);
     HEAP32[$23>>2] = $22;
     $24 = HEAP32[$13>>2]|0;
     $25 = ($24|0)==(2);
     if ($25) {
      $26 = (($inbuf_r) + ($j$07$i<<2)|0);
      $27 = HEAP32[$26>>2]|0;
      $28 = (($primebuff1$i) + ($i$06$i<<2)|0);
      HEAP32[$28>>2] = $27;
     }
     $29 = (($j$07$i) + 1)|0;
     $j$1$i = $29;
    }
    $30 = (($i$06$i) + 1)|0;
    $exitcond91 = ($30|0)==($11|0);
    if ($exitcond91) {
     break;
    } else {
     $i$06$i = $30;$j$07$i = $j$1$i;
    }
   }
  }
  $14 = ($9|0)>(0);
  if ($14) {
   $15 = ((($gfc)) + 72|0);
   $$pre$i = HEAP32[$15>>2]|0;
   $31 = $$pre$i;$415 = $9;$gr$03$i = 0;
   while(1) {
    $32 = ($31|0)>(0);
    if ($32) {
     $ch$02$i = 0;
     while(1) {
      $33 = ((((((($gfc)) + 304|0) + (($gr$03$i*10504)|0)|0) + (($ch$02$i*5252)|0)|0)) + 4788|0);
      HEAP32[$33>>2] = 2;
      $34 = (($ch$02$i) + 1)|0;
      $35 = HEAP32[$15>>2]|0;
      $36 = ($34|0)<($35|0);
      if ($36) {
       $ch$02$i = $34;
      } else {
       $$lcssa121 = $35;
       break;
      }
     }
     $$pre10$i = HEAP32[$8>>2]|0;
     $39 = $$pre10$i;$416 = $$lcssa121;
    } else {
     $39 = $415;$416 = $31;
    }
    $37 = (($gr$03$i) + 1)|0;
    $38 = ($37|0)<($39|0);
    if ($38) {
     $31 = $416;$415 = $39;$gr$03$i = $37;
    } else {
     break;
    }
   }
  }
  _mdct_sub48($gfc,$primebuff0$i,$primebuff1$i);
 }
 $40 = ((($gfc)) + 84752|0);
 HEAP32[$40>>2] = 0;
 $41 = ((($gfc)) + 39832|0);
 $42 = HEAP32[$41>>2]|0;
 $43 = ((($gfc)) + 39836|0);
 $44 = HEAP32[$43>>2]|0;
 $45 = (($44) - ($42))|0;
 HEAP32[$43>>2] = $45;
 $46 = ($45|0)<(0);
 if ($46) {
  $47 = ((($gfc)) + 64|0);
  $48 = HEAP32[$47>>2]|0;
  $49 = (($48) + ($45))|0;
  HEAP32[$43>>2] = $49;
  HEAP32[$40>>2] = 1;
 }
 $50 = $bufp;
 $51 = $50;
 HEAP32[$51>>2] = 0;
 $52 = (($50) + 4)|0;
 $53 = $52;
 HEAP32[$53>>2] = 0;
 $54 = ((($gfc)) + 76|0);
 $55 = HEAP32[$54>>2]|0;
 $56 = ($55|0)>(0);
 L30: do {
  if ($56) {
   $57 = ((($gfc)) + 72|0);
   $58 = ((($gfc)) + 180|0);
   $gr$076 = 0;
   while(1) {
    $59 = HEAP32[$57>>2]|0;
    $60 = ($59|0)>(0);
    if ($60) {
     $61 = ($gr$076*576)|0;
     $62 = (($61) + 304)|0;
     $ch$069 = 0;
     while(1) {
      $63 = (($inbuf) + ($ch$069<<2)|0);
      $64 = HEAP32[$63>>2]|0;
      $65 = (($64) + ($62<<2)|0);
      $66 = (($bufp) + ($ch$069<<2)|0);
      HEAP32[$66>>2] = $65;
      $67 = (($ch$069) + 1)|0;
      $68 = ($67|0)<($59|0);
      if ($68) {
       $ch$069 = $67;
      } else {
       break;
      }
     }
    }
    $69 = (($pe) + ($gr$076<<3)|0);
    $70 = (($pe_MS) + ($gr$076<<3)|0);
    $71 = (($tot_ener) + ($gr$076<<4)|0);
    $72 = (_L3psycho_anal_vbr($gfc,$bufp,$gr$076,$masking_LR,$masking_MS,$69,$70,$71,$blocktype)|0);
    $73 = ($72|0)==(0);
    if (!($73)) {
     $$0 = -4;
     break;
    }
    $74 = HEAP32[$58>>2]|0;
    $75 = ($74|0)==(1);
    if ($75) {
     $76 = (((($tot_ener) + ($gr$076<<4)|0)) + 8|0);
     $77 = +HEAPF32[$76>>2];
     $78 = (((($tot_ener) + ($gr$076<<4)|0)) + 12|0);
     $79 = +HEAPF32[$78>>2];
     $80 = $79 + $77;
     $81 = (($ms_ener_ratio) + ($gr$076<<2)|0);
     HEAPF32[$81>>2] = $80;
     $82 = $80 > 0.0;
     if ($82) {
      $83 = $79 / $80;
      HEAPF32[$81>>2] = $83;
     }
    }
    $84 = HEAP32[$57>>2]|0;
    $85 = ($84|0)>(0);
    if ($85) {
     $ch$173 = 0;
     while(1) {
      $86 = (($blocktype) + ($ch$173<<2)|0);
      $87 = HEAP32[$86>>2]|0;
      $88 = ((((((($gfc)) + 304|0) + (($gr$076*10504)|0)|0) + (($ch$173*5252)|0)|0)) + 4788|0);
      HEAP32[$88>>2] = $87;
      $89 = ((((((($gfc)) + 304|0) + (($gr$076*10504)|0)|0) + (($ch$173*5252)|0)|0)) + 4792|0);
      HEAP32[$89>>2] = 0;
      $90 = (($ch$173) + 1)|0;
      $91 = ($90|0)<($84|0);
      if ($91) {
       $ch$173 = $90;
      } else {
       break;
      }
     }
    }
    $92 = (($gr$076) + 1)|0;
    $93 = HEAP32[$54>>2]|0;
    $94 = ($92|0)<($93|0);
    if ($94) {
     $gr$076 = $92;
    } else {
     $111 = $93;
     break L30;
    }
   }
   STACKTOP = sp;return ($$0|0);
  } else {
   $111 = $55;
  }
 } while(0);
 $95 = ((($gfc)) + 85796|0);
 $96 = HEAP32[$95>>2]|0;
 $97 = HEAP32[$96>>2]|0;
 $98 = ($97|0)==(0);
 do {
  if ($98) {
   $99 = ((($96)) + 8|0);
   HEAPF32[$99>>2] = 1.0;
  } else {
   $100 = ((($gfc)) + 27804|0);
   $101 = +HEAPF32[$100>>2];
   $102 = ((($gfc)) + 27812|0);
   $103 = +HEAPF32[$102>>2];
   $104 = ((($gfc)) + 72|0);
   $105 = HEAP32[$104>>2]|0;
   $106 = ($105|0)==(2);
   if ($106) {
    $107 = ((($gfc)) + 27808|0);
    $108 = +HEAPF32[$107>>2];
    $109 = ((($gfc)) + 27816|0);
    $110 = +HEAPF32[$109>>2];
    $$pn$i = $108;$$pn1$i = $110;
   } else {
    $$pn$i = $101;$$pn1$i = $103;
   }
   $gr2_max$0$i = $103 + $$pn1$i;
   $max_pow$0$i = $101 + $$pn$i;
   $112 = ($111|0)==(2);
   $113 = $max_pow$0$i > $gr2_max$0$i;
   $114 = $113 ? $max_pow$0$i : $gr2_max$0$i;
   $max_pow$1$i = $112 ? $114 : $max_pow$0$i;
   $115 = ((($96)) + 4|0);
   $116 = +HEAPF32[$115>>2];
   $117 = $116 * 0.5;
   $118 = $117 * $max_pow$1$i;
   $119 = $118 > 0.03125;
   if ($119) {
    $120 = ((($96)) + 8|0);
    $121 = +HEAPF32[$120>>2];
    $122 = !($121 >= 1.0);
    if ($122) {
     $123 = ((($96)) + 12|0);
     $124 = +HEAPF32[$123>>2];
     $125 = $121 < $124;
     if ($125) {
      HEAPF32[$120>>2] = $124;
      $$pre$phi$iZ2D = $123;
     } else {
      $$pre$phi$iZ2D = $123;
     }
    } else {
     HEAPF32[$120>>2] = 1.0;
     $$pre$i2 = ((($96)) + 12|0);
     $$pre$phi$iZ2D = $$pre$i2;
    }
    HEAPF32[$$pre$phi$iZ2D>>2] = 1.0;
    break;
   }
   $126 = $118;
   $127 = $126 * 31.98;
   $128 = $127 + 6.2500000000000001E-4;
   $129 = $128;
   $130 = ((($96)) + 8|0);
   $131 = +HEAPF32[$130>>2];
   $132 = !($131 >= $129);
   do {
    if ($132) {
     $140 = ((($96)) + 12|0);
     $141 = +HEAPF32[$140>>2];
     $142 = !($141 >= $129);
     if (!($142)) {
      HEAPF32[$130>>2] = $129;
      break;
     }
     $143 = $131 < $141;
     if ($143) {
      HEAPF32[$130>>2] = $141;
     }
    } else {
     $133 = $129;
     $134 = $133 * 0.074999999999999997;
     $135 = $134 + 0.92500000000000004;
     $136 = $131;
     $137 = $136 * $135;
     $138 = $137;
     HEAPF32[$130>>2] = $138;
     $139 = $138 < $129;
     if ($139) {
      HEAPF32[$130>>2] = $129;
     }
    }
   } while(0);
   $144 = ((($96)) + 12|0);
   HEAPF32[$144>>2] = $129;
  }
 } while(0);
 $145 = HEAP32[$inbuf>>2]|0;
 _mdct_sub48($gfc,$145,$inbuf_r);
 $146 = ((($gfc)) + 84756|0);
 HEAP32[$146>>2] = 0;
 $147 = ((($gfc)) + 80|0);
 $148 = HEAP32[$147>>2]|0;
 $149 = ($148|0)==(0);
 do {
  if ($149) {
   $150 = ((($gfc)) + 180|0);
   $151 = HEAP32[$150>>2]|0;
   $152 = ($151|0)==(1);
   if ($152) {
    $153 = HEAP32[$54>>2]|0;
    $154 = ($153|0)>(0);
    if ($154) {
     $155 = ((($gfc)) + 72|0);
     $156 = HEAP32[$155>>2]|0;
     $157 = ($156|0)>(0);
     if ($157) {
      $gr$161$us = 0;$sum_pe_LR$064$us = 0.0;$sum_pe_MS$063$us = 0.0;
      while(1) {
       $ch$254$us = 0;$sum_pe_LR$156$us = $sum_pe_LR$064$us;$sum_pe_MS$155$us = $sum_pe_MS$063$us;
       while(1) {
        $160 = ((($pe_MS) + ($gr$161$us<<3)|0) + ($ch$254$us<<2)|0);
        $161 = +HEAPF32[$160>>2];
        $162 = $161 + $sum_pe_MS$155$us;
        $163 = ((($pe) + ($gr$161$us<<3)|0) + ($ch$254$us<<2)|0);
        $164 = +HEAPF32[$163>>2];
        $165 = $164 + $sum_pe_LR$156$us;
        $166 = (($ch$254$us) + 1)|0;
        $167 = ($166|0)<($156|0);
        if ($167) {
         $ch$254$us = $166;$sum_pe_LR$156$us = $165;$sum_pe_MS$155$us = $162;
        } else {
         $$lcssa118 = $162;$$lcssa119 = $165;
         break;
        }
       }
       $158 = (($gr$161$us) + 1)|0;
       $159 = ($158|0)<($153|0);
       if ($159) {
        $gr$161$us = $158;$sum_pe_LR$064$us = $$lcssa119;$sum_pe_MS$063$us = $$lcssa118;
       } else {
        $$lcssa118$lcssa = $$lcssa118;$$lcssa119$lcssa = $$lcssa119;
        break;
       }
      }
      $168 = !($$lcssa118$lcssa <= $$lcssa119$lcssa);
      if ($168) {
       $180 = 0;
       break;
      }
     }
    }
    $169 = (($153) + -1)|0;
    $170 = ((($gfc)) + 5092|0);
    $171 = HEAP32[$170>>2]|0;
    $172 = ((($gfc)) + 10344|0);
    $173 = HEAP32[$172>>2]|0;
    $174 = ($171|0)==($173|0);
    if ($174) {
     $175 = (((((($gfc)) + 304|0) + (($169*10504)|0)|0)) + 4788|0);
     $176 = HEAP32[$175>>2]|0;
     $177 = (((((($gfc)) + 304|0) + (($169*10504)|0)|0)) + 10040|0);
     $178 = HEAP32[$177>>2]|0;
     $179 = ($176|0)==($178|0);
     if ($179) {
      HEAP32[$146>>2] = 2;
      $180 = 1;
     } else {
      $180 = 0;
     }
    } else {
     $180 = 0;
    }
   } else {
    $180 = 0;
   }
  } else {
   HEAP32[$146>>2] = 2;
   $180 = 1;
  }
 } while(0);
 $masking_MS$sink = $180 ? $masking_MS : $masking_LR;
 $181 = $180 ? $pe_MS : $pe;
 $182 = ((($gfc)) + 140|0);
 $183 = HEAP32[$182>>2]|0;
 $184 = ($183|0)==(0);
 if (!($184)) {
  $185 = ((($gfc)) + 85804|0);
  $186 = HEAP32[$185>>2]|0;
  $187 = ($186|0)==(0|0);
  if (!($187)) {
   $188 = HEAP32[$54>>2]|0;
   $189 = ($188|0)>(0);
   if ($189) {
    $190 = ((($gfc)) + 72|0);
    $$pre = HEAP32[$190>>2]|0;
    $191 = $$pre;$417 = $188;$gr$252 = 0;
    while(1) {
     $192 = ($191|0)>(0);
     if ($192) {
      $193 = (($ms_ener_ratio) + ($gr$252<<2)|0);
      $194 = +HEAPF32[$193>>2];
      $195 = $194;
      $ch$349 = 0;
      while(1) {
       $196 = HEAP32[$185>>2]|0;
       $197 = (((($196)) + 90904|0) + ($gr$252<<3)|0);
       HEAPF64[$197>>3] = 0.0;
       $198 = (((($196)) + 90920|0) + ($gr$252<<3)|0);
       HEAPF64[$198>>3] = $195;
       $199 = ((((((($gfc)) + 304|0) + (($gr$252*10504)|0)|0) + (($ch$349*5252)|0)|0)) + 4788|0);
       $200 = HEAP32[$199>>2]|0;
       $201 = ((((($196)) + 203288|0) + ($gr$252<<3)|0) + ($ch$349<<2)|0);
       HEAP32[$201>>2] = $200;
       $202 = ((($181) + ($gr$252<<3)|0) + ($ch$349<<2)|0);
       $203 = +HEAPF32[$202>>2];
       $204 = $203;
       $205 = ((((($196)) + 189240|0) + ($gr$252<<5)|0) + ($ch$349<<3)|0);
       HEAPF64[$205>>3] = $204;
       $206 = ((((($196)) + 54040|0) + (($gr$252*9216)|0)|0) + (($ch$349*4608)|0)|0);
       $207 = ((((($gfc)) + 304|0) + (($gr$252*10504)|0)|0) + (($ch$349*5252)|0)|0);
       _memcpy(($206|0),($207|0),2304)|0;
       $208 = HEAP32[$146>>2]|0;
       $209 = ($208|0)==(2);
       if ($209) {
        $210 = (($ch$349) + 2)|0;
        $211 = HEAP32[$185>>2]|0;
        $212 = ((((($211)) + 197144|0) + ($gr$252<<5)|0) + ($210<<3)|0);
        $213 = +HEAPF64[$212>>3];
        $214 = ((((($211)) + 197144|0) + ($gr$252<<5)|0) + ($ch$349<<3)|0);
        HEAPF64[$214>>3] = $213;
        $215 = ((((($211)) + 123704|0) + ($gr$252<<15)|0) + ($ch$349<<13)|0);
        $216 = ((((($211)) + 123704|0) + ($gr$252<<15)|0) + ($210<<13)|0);
        _memcpy(($215|0),($216|0),8192)|0;
       }
       $217 = (($ch$349) + 1)|0;
       $218 = HEAP32[$190>>2]|0;
       $219 = ($217|0)<($218|0);
       if ($219) {
        $ch$349 = $217;
       } else {
        $$lcssa117 = $218;
        break;
       }
      }
      $$pre92 = HEAP32[$54>>2]|0;
      $222 = $$pre92;$418 = $$lcssa117;
     } else {
      $222 = $417;$418 = $191;
     }
     $220 = (($gr$252) + 1)|0;
     $221 = ($220|0)<($222|0);
     if ($221) {
      $191 = $418;$417 = $222;$gr$252 = $220;
     } else {
      break;
     }
    }
   }
  }
 }
 $223 = ((($gfc)) + 104|0);
 $224 = HEAP32[$223>>2]|0;
 if ((($224|0) == 3) | (($224|0) == 0)) {
  $225 = ((($gfc)) + 39760|0);
  $226 = HEAP32[$225>>2]|0;
  $227 = ((($gfc)) + 39756|0);
  HEAP32[$227>>2] = $226;
  $228 = ((($gfc)) + 39764|0);
  $229 = HEAP32[$228>>2]|0;
  HEAP32[$225>>2] = $229;
  $230 = ((($gfc)) + 39768|0);
  $231 = HEAP32[$230>>2]|0;
  HEAP32[$228>>2] = $231;
  $232 = ((($gfc)) + 39772|0);
  $233 = HEAP32[$232>>2]|0;
  HEAP32[$230>>2] = $233;
  $234 = ((($gfc)) + 39776|0);
  $235 = HEAP32[$234>>2]|0;
  HEAP32[$232>>2] = $235;
  $236 = ((($gfc)) + 39780|0);
  $237 = HEAP32[$236>>2]|0;
  HEAP32[$234>>2] = $237;
  $238 = ((($gfc)) + 39784|0);
  $239 = HEAP32[$238>>2]|0;
  HEAP32[$236>>2] = $239;
  $240 = ((($gfc)) + 39788|0);
  $241 = HEAP32[$240>>2]|0;
  HEAP32[$238>>2] = $241;
  $242 = ((($gfc)) + 39792|0);
  $243 = HEAP32[$242>>2]|0;
  HEAP32[$240>>2] = $243;
  $244 = ((($gfc)) + 39796|0);
  $245 = HEAP32[$244>>2]|0;
  HEAP32[$242>>2] = $245;
  $246 = ((($gfc)) + 39800|0);
  $247 = HEAP32[$246>>2]|0;
  HEAP32[$244>>2] = $247;
  $248 = ((($gfc)) + 39804|0);
  $249 = HEAP32[$248>>2]|0;
  HEAP32[$246>>2] = $249;
  $250 = ((($gfc)) + 39808|0);
  $251 = HEAP32[$250>>2]|0;
  HEAP32[$248>>2] = $251;
  $252 = ((($gfc)) + 39812|0);
  $253 = HEAP32[$252>>2]|0;
  HEAP32[$250>>2] = $253;
  $254 = ((($gfc)) + 39816|0);
  $255 = HEAP32[$254>>2]|0;
  HEAP32[$252>>2] = $255;
  $256 = ((($gfc)) + 39820|0);
  $257 = HEAP32[$256>>2]|0;
  HEAP32[$254>>2] = $257;
  $258 = ((($gfc)) + 39824|0);
  $259 = HEAP32[$258>>2]|0;
  HEAP32[$256>>2] = $259;
  $260 = ((($gfc)) + 39828|0);
  $261 = HEAP32[$260>>2]|0;
  HEAP32[$258>>2] = $261;
  $262 = HEAP32[$54>>2]|0;
  $263 = ($262|0)>(0);
  $264 = (HEAP32[tempDoublePtr>>2]=$245,+HEAPF32[tempDoublePtr>>2]);
  $265 = (HEAP32[tempDoublePtr>>2]=$226,+HEAPF32[tempDoublePtr>>2]);
  $266 = (HEAP32[tempDoublePtr>>2]=$229,+HEAPF32[tempDoublePtr>>2]);
  $267 = (HEAP32[tempDoublePtr>>2]=$261,+HEAPF32[tempDoublePtr>>2]);
  $268 = (HEAP32[tempDoublePtr>>2]=$231,+HEAPF32[tempDoublePtr>>2]);
  $269 = (HEAP32[tempDoublePtr>>2]=$259,+HEAPF32[tempDoublePtr>>2]);
  $270 = (HEAP32[tempDoublePtr>>2]=$233,+HEAPF32[tempDoublePtr>>2]);
  $271 = (HEAP32[tempDoublePtr>>2]=$257,+HEAPF32[tempDoublePtr>>2]);
  $272 = (HEAP32[tempDoublePtr>>2]=$235,+HEAPF32[tempDoublePtr>>2]);
  $273 = (HEAP32[tempDoublePtr>>2]=$255,+HEAPF32[tempDoublePtr>>2]);
  $274 = (HEAP32[tempDoublePtr>>2]=$237,+HEAPF32[tempDoublePtr>>2]);
  $275 = (HEAP32[tempDoublePtr>>2]=$253,+HEAPF32[tempDoublePtr>>2]);
  $276 = (HEAP32[tempDoublePtr>>2]=$239,+HEAPF32[tempDoublePtr>>2]);
  $277 = (HEAP32[tempDoublePtr>>2]=$251,+HEAPF32[tempDoublePtr>>2]);
  $278 = (HEAP32[tempDoublePtr>>2]=$241,+HEAPF32[tempDoublePtr>>2]);
  $279 = (HEAP32[tempDoublePtr>>2]=$249,+HEAPF32[tempDoublePtr>>2]);
  $280 = (HEAP32[tempDoublePtr>>2]=$243,+HEAPF32[tempDoublePtr>>2]);
  $281 = (HEAP32[tempDoublePtr>>2]=$247,+HEAPF32[tempDoublePtr>>2]);
  $282 = ((($gfc)) + 72|0);
  $283 = HEAP32[$282>>2]|0;
  $284 = ($283|0)>(0);
  $or$cond = $263 & $284;
  if ($or$cond) {
   $f$045$us = 0.0;$gr$343$us = 0;
   while(1) {
    $ch$439$us = 0;$f$140$us = $f$045$us;
    while(1) {
     $287 = ((($181) + ($gr$343$us<<3)|0) + ($ch$439$us<<2)|0);
     $288 = +HEAPF32[$287>>2];
     $289 = $288 + $f$140$us;
     $290 = (($ch$439$us) + 1)|0;
     $291 = ($290|0)<($283|0);
     if ($291) {
      $ch$439$us = $290;$f$140$us = $289;
     } else {
      $$lcssa116 = $289;
      break;
     }
    }
    $285 = (($gr$343$us) + 1)|0;
    $286 = ($285|0)<($262|0);
    if ($286) {
     $f$045$us = $$lcssa116;$gr$343$us = $285;
    } else {
     $f$0$lcssa = $$lcssa116;
     break;
    }
   }
  } else {
   $f$0$lcssa = 0.0;
  }
  HEAPF32[$260>>2] = $f$0$lcssa;
  $292 = $f$0$lcssa + $265;
  $293 = $292 * -0.10394349694252014;
  $294 = $293 + $264;
  $295 = $267 + $266;
  $296 = $295 * -0.18920649588108063;
  $297 = $296 + $294;
  $298 = $269 + $268;
  $299 = $298 * -0.21623599529266357;
  $300 = $299 + $297;
  $301 = $271 + $270;
  $302 = $301 * -0.15591500699520111;
  $303 = $302 + $300;
  $304 = $273 + $272;
  $305 = $304 * 3.8980449615198001E-17;
  $306 = $305 + $303;
  $307 = $275 + $274;
  $308 = $307 * 0.23387250304222107;
  $309 = $308 + $306;
  $310 = $277 + $276;
  $311 = $310 * 0.50454998016357422;
  $312 = $311 + $309;
  $313 = $279 + $278;
  $314 = $313 * 0.75682497024536133;
  $315 = $314 + $312;
  $316 = $281 + $280;
  $317 = $316 * 0.93549001216888427;
  $318 = $317 + $315;
  $319 = ($262*3350)|0;
  $320 = Math_imul($319, $283)|0;
  $321 = (+($320|0));
  $322 = $321 / $318;
  $323 = ($283|0)>(0);
  $or$cond101 = $263 & $323;
  if ($or$cond101) {
   $gr$435$us = 0;
   while(1) {
    $ch$533$us = 0;
    while(1) {
     $326 = ((($181) + ($gr$435$us<<3)|0) + ($ch$533$us<<2)|0);
     $327 = +HEAPF32[$326>>2];
     $328 = $327 * $322;
     HEAPF32[$326>>2] = $328;
     $329 = (($ch$533$us) + 1)|0;
     $330 = ($329|0)<($283|0);
     if ($330) {
      $ch$533$us = $329;
     } else {
      break;
     }
    }
    $324 = (($gr$435$us) + 1)|0;
    $325 = ($324|0)<($262|0);
    if ($325) {
     $gr$435$us = $324;
    } else {
     break;
    }
   }
  }
 }
 $331 = ((($gfc)) + 85812|0);
 $332 = HEAP32[$331>>2]|0;
 FUNCTION_TABLE_viiii[$332 & 7]($gfc,$181,$ms_ener_ratio,$masking_MS$sink);
 (_format_bitstream($gfc)|0);
 $333 = (_copy_buffer($gfc,$mp3buf,$mp3buf_size,1)|0);
 $334 = ((($gfc)) + 156|0);
 $335 = HEAP32[$334>>2]|0;
 $336 = ($335|0)==(0);
 if (!($336)) {
  _AddVbrFrame($gfc);
 }
 $337 = HEAP32[$182>>2]|0;
 $338 = ($337|0)==(0);
 if (!($338)) {
  $339 = ((($gfc)) + 85804|0);
  $340 = HEAP32[$339>>2]|0;
  $341 = ($340|0)==(0|0);
  if (!($341)) {
   $342 = HEAP32[$54>>2]|0;
   $343 = ($342*576)|0;
   $344 = ((($gfc)) + 72|0);
   $345 = HEAP32[$344>>2]|0;
   $346 = ($345|0)>(0);
   if ($346) {
    $ch$632 = 0;
    while(1) {
     $j$030 = 0;
     while(1) {
      $349 = (($j$030) + ($343))|0;
      $350 = ((((($340)) + 24|0) + (($ch$632*12800)|0)|0) + ($349<<3)|0);
      $351 = +HEAPF64[$350>>3];
      $352 = ((((($340)) + 24|0) + (($ch$632*12800)|0)|0) + ($j$030<<3)|0);
      HEAPF64[$352>>3] = $351;
      $353 = (($j$030) + 1)|0;
      $exitcond = ($353|0)==(272);
      if ($exitcond) {
       break;
      } else {
       $j$030 = $353;
      }
     }
     $347 = (($inbuf) + ($ch$632<<2)|0);
     $348 = HEAP32[$347>>2]|0;
     $j$131 = 272;
     while(1) {
      $354 = (($j$131) + -272)|0;
      $355 = (($348) + ($354<<2)|0);
      $356 = +HEAPF32[$355>>2];
      $357 = $356;
      $358 = ((((($340)) + 24|0) + (($ch$632*12800)|0)|0) + ($j$131<<3)|0);
      HEAPF64[$358>>3] = $357;
      $359 = (($j$131) + 1)|0;
      $exitcond86 = ($359|0)==(1600);
      if ($exitcond86) {
       break;
      } else {
       $j$131 = $359;
      }
     }
     $360 = (($ch$632) + 1)|0;
     $361 = ($360|0)<($345|0);
     if ($361) {
      $ch$632 = $360;
     } else {
      break;
     }
    }
   }
   $362 = ((($gfc)) + 84908|0);
   HEAPF32[$362>>2] = 1.0;
   _set_frame_pinfo($gfc,$masking_MS$sink);
  }
 }
 $363 = ((($gfc)) + 84748|0);
 $364 = HEAP32[$363>>2]|0;
 $365 = (($364) + 1)|0;
 HEAP32[$363>>2] = $365;
 $366 = ((($gfc)) + 84744|0);
 $367 = HEAP32[$366>>2]|0;
 $368 = (((((($gfc)) + 84040|0) + (($367*20)|0)|0)) + 16|0);
 $369 = HEAP32[$368>>2]|0;
 $370 = (($369) + 1)|0;
 HEAP32[$368>>2] = $370;
 $371 = ((($gfc)) + 84356|0);
 $372 = HEAP32[$371>>2]|0;
 $373 = (($372) + 1)|0;
 HEAP32[$371>>2] = $373;
 $374 = ((($gfc)) + 72|0);
 $375 = HEAP32[$374>>2]|0;
 $376 = ($375|0)==(2);
 if ($376) {
  $377 = HEAP32[$146>>2]|0;
  $378 = HEAP32[$366>>2]|0;
  $379 = ((((($gfc)) + 84040|0) + (($378*20)|0)|0) + ($377<<2)|0);
  $380 = HEAP32[$379>>2]|0;
  $381 = (($380) + 1)|0;
  HEAP32[$379>>2] = $381;
  $382 = HEAP32[$146>>2]|0;
  $383 = (((($gfc)) + 84340|0) + ($382<<2)|0);
  $384 = HEAP32[$383>>2]|0;
  $385 = (($384) + 1)|0;
  HEAP32[$383>>2] = $385;
 }
 $386 = HEAP32[$54>>2]|0;
 $387 = ($386|0)>(0);
 if (!($387)) {
  $$0 = $333;
  STACKTOP = sp;return ($$0|0);
 }
 $388 = ((($gfc)) + 84740|0);
 $$pre$i4 = HEAP32[$374>>2]|0;
 $389 = $$pre$i4;$419 = $386;$gr$03$i6 = 0;
 while(1) {
  $390 = ($389|0)>(0);
  if ($390) {
   $ch$02$i8 = 0;
   while(1) {
    $391 = ((((((($gfc)) + 304|0) + (($gr$03$i6*10504)|0)|0) + (($ch$02$i8*5252)|0)|0)) + 4788|0);
    $392 = HEAP32[$391>>2]|0;
    $393 = ((((((($gfc)) + 304|0) + (($gr$03$i6*10504)|0)|0) + (($ch$02$i8*5252)|0)|0)) + 4792|0);
    $394 = HEAP32[$393>>2]|0;
    $395 = ($394|0)==(0);
    $$$i = $395 ? $392 : 4;
    $396 = HEAP32[$366>>2]|0;
    $397 = ((((($gfc)) + 84360|0) + (($396*24)|0)|0) + ($$$i<<2)|0);
    $398 = HEAP32[$397>>2]|0;
    $399 = (($398) + 1)|0;
    HEAP32[$397>>2] = $399;
    $400 = HEAP32[$366>>2]|0;
    $401 = (((((($gfc)) + 84360|0) + (($400*24)|0)|0)) + 20|0);
    $402 = HEAP32[$401>>2]|0;
    $403 = (($402) + 1)|0;
    HEAP32[$401>>2] = $403;
    $404 = (((($gfc)) + 84720|0) + ($$$i<<2)|0);
    $405 = HEAP32[$404>>2]|0;
    $406 = (($405) + 1)|0;
    HEAP32[$404>>2] = $406;
    $407 = HEAP32[$388>>2]|0;
    $408 = (($407) + 1)|0;
    HEAP32[$388>>2] = $408;
    $409 = (($ch$02$i8) + 1)|0;
    $410 = HEAP32[$374>>2]|0;
    $411 = ($409|0)<($410|0);
    if ($411) {
     $ch$02$i8 = $409;
    } else {
     $$lcssa = $410;
     break;
    }
   }
   $$pre6$i = HEAP32[$54>>2]|0;
   $414 = $$pre6$i;$420 = $$lcssa;
  } else {
   $414 = $419;$420 = $389;
  }
  $412 = (($gr$03$i6) + 1)|0;
  $413 = ($412|0)<($414|0);
  if ($413) {
   $389 = $420;$419 = $414;$gr$03$i6 = $412;
  } else {
   $$0 = $333;
   break;
  }
 }
 STACKTOP = sp;return ($$0|0);
}
function _fft_short($gfc,$x_real,$chn,$buffer) {
 $gfc = $gfc|0;
 $x_real = $x_real|0;
 $chn = $chn|0;
 $buffer = $buffer|0;
 var $$pre = 0, $0 = 0, $1 = 0, $10 = 0.0, $11 = 0, $12 = 0, $13 = 0.0, $14 = 0.0, $15 = 0, $16 = 0, $17 = 0.0, $18 = 0, $19 = 0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0, $25 = 0;
 var $26 = 0.0, $27 = 0, $28 = 0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0, $32 = 0, $33 = 0.0, $34 = 0, $35 = 0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0, $41 = 0.0, $42 = 0.0, $43 = 0;
 var $44 = 0.0, $45 = 0, $46 = 0.0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0.0, $51 = 0, $52 = 0, $53 = 0.0, $54 = 0.0, $55 = 0, $56 = 0, $57 = 0.0, $58 = 0, $59 = 0, $6 = 0, $60 = 0.0, $61 = 0.0;
 var $62 = 0.0, $63 = 0.0, $64 = 0, $65 = 0, $66 = 0.0, $67 = 0, $68 = 0, $69 = 0.0, $7 = 0, $70 = 0.0, $71 = 0, $72 = 0, $73 = 0.0, $74 = 0, $75 = 0, $76 = 0.0, $77 = 0.0, $78 = 0.0, $79 = 0.0, $8 = 0;
 var $80 = 0.0, $81 = 0, $82 = 0.0, $83 = 0, $84 = 0.0, $85 = 0, $86 = 0.0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $b$01 = 0, $exitcond = 0, $indvars$iv = 0, $j$0 = 0, $scevgep = 0, $sext = 0, $x$0 = 0, label = 0;
 var sp = 0;
 sp = STACKTOP;
 $0 = (($buffer) + ($chn<<2)|0);
 $1 = ((($gfc)) + 85820|0);
 $b$01 = 0;$indvars$iv = $x_real;
 while(1) {
  $2 = (((($x_real) + ($b$01<<10)|0)) + 512|0);
  $3 = (($b$01) + 1)|0;
  $sext = Math_imul($3, 12582912)|0;
  $4 = $sext >> 16;
  $$pre = HEAP32[$0>>2]|0;
  $j$0 = 31;$x$0 = $2;
  while(1) {
   $5 = $j$0 << 2;
   $6 = (1720 + ($5)|0);
   $7 = HEAP8[$6>>0]|0;
   $8 = $7&255;
   $9 = (1848 + ($8<<2)|0);
   $10 = +HEAPF32[$9>>2];
   $11 = (($8) + ($4))|0;
   $12 = (($$pre) + ($11<<2)|0);
   $13 = +HEAPF32[$12>>2];
   $14 = $13 * $10;
   $15 = (127 - ($8))|0;
   $16 = (1848 + ($15<<2)|0);
   $17 = +HEAPF32[$16>>2];
   $18 = (($11) + 128)|0;
   $19 = (($$pre) + ($18<<2)|0);
   $20 = +HEAPF32[$19>>2];
   $21 = $20 * $17;
   $22 = $14 - $21;
   $23 = $21 + $14;
   $24 = (($8) + 64)|0;
   $25 = (1848 + ($24<<2)|0);
   $26 = +HEAPF32[$25>>2];
   $27 = (($11) + 64)|0;
   $28 = (($$pre) + ($27<<2)|0);
   $29 = +HEAPF32[$28>>2];
   $30 = $29 * $26;
   $31 = (63 - ($8))|0;
   $32 = (1848 + ($31<<2)|0);
   $33 = +HEAPF32[$32>>2];
   $34 = (($11) + 192)|0;
   $35 = (($$pre) + ($34<<2)|0);
   $36 = +HEAPF32[$35>>2];
   $37 = $36 * $33;
   $38 = $30 - $37;
   $39 = $37 + $30;
   $40 = ((($x$0)) + -16|0);
   $41 = $39 + $23;
   HEAPF32[$40>>2] = $41;
   $42 = $23 - $39;
   $43 = ((($x$0)) + -8|0);
   HEAPF32[$43>>2] = $42;
   $44 = $38 + $22;
   $45 = ((($x$0)) + -12|0);
   HEAPF32[$45>>2] = $44;
   $46 = $22 - $38;
   $47 = ((($x$0)) + -4|0);
   HEAPF32[$47>>2] = $46;
   $48 = (($8) + 1)|0;
   $49 = (1848 + ($48<<2)|0);
   $50 = +HEAPF32[$49>>2];
   $51 = (($11) + 1)|0;
   $52 = (($$pre) + ($51<<2)|0);
   $53 = +HEAPF32[$52>>2];
   $54 = $53 * $50;
   $55 = (126 - ($8))|0;
   $56 = (1848 + ($55<<2)|0);
   $57 = +HEAPF32[$56>>2];
   $58 = (($11) + 129)|0;
   $59 = (($$pre) + ($58<<2)|0);
   $60 = +HEAPF32[$59>>2];
   $61 = $60 * $57;
   $62 = $54 - $61;
   $63 = $61 + $54;
   $64 = (($8) + 65)|0;
   $65 = (1848 + ($64<<2)|0);
   $66 = +HEAPF32[$65>>2];
   $67 = (($11) + 65)|0;
   $68 = (($$pre) + ($67<<2)|0);
   $69 = +HEAPF32[$68>>2];
   $70 = $69 * $66;
   $71 = (62 - ($8))|0;
   $72 = (1848 + ($71<<2)|0);
   $73 = +HEAPF32[$72>>2];
   $74 = (($11) + 193)|0;
   $75 = (($$pre) + ($74<<2)|0);
   $76 = +HEAPF32[$75>>2];
   $77 = $76 * $73;
   $78 = $70 - $77;
   $79 = $77 + $70;
   $80 = $79 + $63;
   $81 = ((($x$0)) + 496|0);
   HEAPF32[$81>>2] = $80;
   $82 = $63 - $79;
   $83 = ((($x$0)) + 504|0);
   HEAPF32[$83>>2] = $82;
   $84 = $78 + $62;
   $85 = ((($x$0)) + 500|0);
   HEAPF32[$85>>2] = $84;
   $86 = $62 - $78;
   $87 = ((($x$0)) + 508|0);
   HEAPF32[$87>>2] = $86;
   $88 = (($j$0) + -1)|0;
   $89 = ($j$0|0)>(0);
   if ($89) {
    $j$0 = $88;$x$0 = $40;
   } else {
    break;
   }
  }
  $90 = HEAP32[$1>>2]|0;
  FUNCTION_TABLE_vii[$90 & 3]($indvars$iv,128);
  $scevgep = ((($indvars$iv)) + 1024|0);
  $exitcond = ($3|0)==(3);
  if ($exitcond) {
   break;
  } else {
   $b$01 = $3;$indvars$iv = $scevgep;
  }
 }
 return;
}
function _fft_long($gfc,$x,$chn,$buffer) {
 $gfc = $gfc|0;
 $x = $x|0;
 $chn = $chn|0;
 $buffer = $buffer|0;
 var $$0 = 0, $$pre = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0.0, $13 = 0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0, $19 = 0, $2 = 0, $20 = 0.0, $21 = 0, $22 = 0.0, $23 = 0.0, $24 = 0;
 var $25 = 0, $26 = 0.0, $27 = 0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0, $33 = 0.0, $34 = 0.0, $35 = 0, $36 = 0.0, $37 = 0, $38 = 0.0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0.0;
 var $43 = 0, $44 = 0.0, $45 = 0.0, $46 = 0, $47 = 0, $48 = 0.0, $49 = 0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $54 = 0, $55 = 0, $56 = 0.0, $57 = 0, $58 = 0.0, $59 = 0.0, $6 = 0.0, $60 = 0;
 var $61 = 0, $62 = 0.0, $63 = 0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0, $7 = 0, $70 = 0.0, $71 = 0, $72 = 0.0, $73 = 0, $74 = 0.0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0;
 var $8 = 0.0, $9 = 0.0, $jj$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($x)) + 2048|0);
 $1 = (($buffer) + ($chn<<2)|0);
 $$pre = HEAP32[$1>>2]|0;
 $$0 = $0;$jj$0 = 127;
 while(1) {
  $2 = (1720 + ($jj$0)|0);
  $3 = HEAP8[$2>>0]|0;
  $4 = $3&255;
  $5 = (2360 + ($4<<2)|0);
  $6 = +HEAPF32[$5>>2];
  $7 = (($$pre) + ($4<<2)|0);
  $8 = +HEAPF32[$7>>2];
  $9 = $8 * $6;
  $10 = $4 | 512;
  $11 = (2360 + ($10<<2)|0);
  $12 = +HEAPF32[$11>>2];
  $13 = (($$pre) + ($10<<2)|0);
  $14 = +HEAPF32[$13>>2];
  $15 = $14 * $12;
  $16 = $9 - $15;
  $17 = $15 + $9;
  $18 = $4 | 256;
  $19 = (2360 + ($18<<2)|0);
  $20 = +HEAPF32[$19>>2];
  $21 = (($$pre) + ($18<<2)|0);
  $22 = +HEAPF32[$21>>2];
  $23 = $22 * $20;
  $24 = $4 | 768;
  $25 = (2360 + ($24<<2)|0);
  $26 = +HEAPF32[$25>>2];
  $27 = (($$pre) + ($24<<2)|0);
  $28 = +HEAPF32[$27>>2];
  $29 = $28 * $26;
  $30 = $23 - $29;
  $31 = $29 + $23;
  $32 = ((($$0)) + -16|0);
  $33 = $31 + $17;
  HEAPF32[$32>>2] = $33;
  $34 = $17 - $31;
  $35 = ((($$0)) + -8|0);
  HEAPF32[$35>>2] = $34;
  $36 = $30 + $16;
  $37 = ((($$0)) + -12|0);
  HEAPF32[$37>>2] = $36;
  $38 = $16 - $30;
  $39 = ((($$0)) + -4|0);
  HEAPF32[$39>>2] = $38;
  $40 = (($4) + 1)|0;
  $41 = (2360 + ($40<<2)|0);
  $42 = +HEAPF32[$41>>2];
  $43 = (($$pre) + ($40<<2)|0);
  $44 = +HEAPF32[$43>>2];
  $45 = $44 * $42;
  $46 = (($4) + 513)|0;
  $47 = (2360 + ($46<<2)|0);
  $48 = +HEAPF32[$47>>2];
  $49 = (($$pre) + ($46<<2)|0);
  $50 = +HEAPF32[$49>>2];
  $51 = $50 * $48;
  $52 = $45 - $51;
  $53 = $51 + $45;
  $54 = (($4) + 257)|0;
  $55 = (2360 + ($54<<2)|0);
  $56 = +HEAPF32[$55>>2];
  $57 = (($$pre) + ($54<<2)|0);
  $58 = +HEAPF32[$57>>2];
  $59 = $58 * $56;
  $60 = (($4) + 769)|0;
  $61 = (2360 + ($60<<2)|0);
  $62 = +HEAPF32[$61>>2];
  $63 = (($$pre) + ($60<<2)|0);
  $64 = +HEAPF32[$63>>2];
  $65 = $64 * $62;
  $66 = $59 - $65;
  $67 = $65 + $59;
  $68 = $67 + $53;
  $69 = ((($$0)) + 2032|0);
  HEAPF32[$69>>2] = $68;
  $70 = $53 - $67;
  $71 = ((($$0)) + 2040|0);
  HEAPF32[$71>>2] = $70;
  $72 = $66 + $52;
  $73 = ((($$0)) + 2036|0);
  HEAPF32[$73>>2] = $72;
  $74 = $52 - $66;
  $75 = ((($$0)) + 2044|0);
  HEAPF32[$75>>2] = $74;
  $76 = (($jj$0) + -1)|0;
  $77 = ($jj$0|0)>(0);
  if ($77) {
   $$0 = $32;$jj$0 = $76;
  } else {
   break;
  }
 }
 $78 = ((($gfc)) + 85820|0);
 $79 = HEAP32[$78>>2]|0;
 FUNCTION_TABLE_vii[$79 & 3]($x,512);
 return;
}
function _init_fft($gfc) {
 $gfc = $gfc|0;
 var $0 = 0.0, $1 = 0.0, $10 = 0.0, $11 = 0, $12 = 0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0.0, $20 = 0, $21 = 0, $22 = 0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0.0;
 var $7 = 0.0, $8 = 0.0, $9 = 0.0, $exitcond = 0, $exitcond3 = 0, $i$02 = 0, $i$11 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $i$02 = 0;
 while(1) {
  $0 = (+($i$02|0));
  $1 = $0 + 0.5;
  $2 = $1 * 0.0061359231515425647;
  $3 = (+Math_cos((+$2)));
  $4 = $3 * 0.5;
  $5 = 0.41999999999999998 - $4;
  $6 = $1 * 0.012271846303085129;
  $7 = (+Math_cos((+$6)));
  $8 = $7 * 0.080000000000000002;
  $9 = $5 + $8;
  $10 = $9;
  $11 = (2360 + ($i$02<<2)|0);
  HEAPF32[$11>>2] = $10;
  $12 = (($i$02) + 1)|0;
  $exitcond3 = ($12|0)==(1024);
  if ($exitcond3) {
   $i$11 = 0;
   break;
  } else {
   $i$02 = $12;
  }
 }
 while(1) {
  $13 = (+($i$11|0));
  $14 = $13 + 0.5;
  $15 = $14 * 0.024543692606170259;
  $16 = (+Math_cos((+$15)));
  $17 = 1.0 - $16;
  $18 = $17 * 0.5;
  $19 = $18;
  $20 = (1848 + ($i$11<<2)|0);
  HEAPF32[$20>>2] = $19;
  $21 = (($i$11) + 1)|0;
  $exitcond = ($21|0)==(128);
  if ($exitcond) {
   break;
  } else {
   $i$11 = $21;
  }
 }
 $22 = ((($gfc)) + 85820|0);
 HEAP32[$22>>2] = 1;
 return;
}
function _fht($fz,$n) {
 $fz = $fz|0;
 $n = $n|0;
 var $$sum = 0, $0 = 0, $1 = 0, $10 = 0.0, $100 = 0.0, $101 = 0.0, $102 = 0.0, $103 = 0.0, $104 = 0.0, $105 = 0.0, $106 = 0.0, $107 = 0.0, $108 = 0, $109 = 0, $11 = 0.0, $110 = 0, $111 = 0.0, $112 = 0.0, $113 = 0.0, $114 = 0.0;
 var $115 = 0.0, $116 = 0.0, $117 = 0.0, $118 = 0.0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $13 = 0.0, $14 = 0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0;
 var $23 = 0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0;
 var $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0, $53 = 0, $54 = 0, $55 = 0.0, $56 = 0.0, $57 = 0, $58 = 0.0, $59 = 0.0;
 var $6 = 0, $60 = 0.0, $61 = 0.0, $62 = 0.0, $63 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0.0, $70 = 0, $71 = 0.0, $72 = 0.0, $73 = 0, $74 = 0.0, $75 = 0.0, $76 = 0.0, $77 = 0.0;
 var $78 = 0.0, $79 = 0.0, $8 = 0, $80 = 0, $81 = 0.0, $82 = 0.0, $83 = 0.0, $84 = 0, $85 = 0.0, $86 = 0.0, $87 = 0.0, $88 = 0.0, $89 = 0.0, $9 = 0.0, $90 = 0.0, $91 = 0.0, $92 = 0.0, $93 = 0.0, $94 = 0.0, $95 = 0.0;
 var $96 = 0.0, $97 = 0.0, $98 = 0.0, $99 = 0.0, $c1$02 = 0.0, $fi$0 = 0, $fi$1 = 0, $gi$0 = 0, $gi$1 = 0, $i$01 = 0, $k4$0 = 0, $s1$03 = 0.0, $tri$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = $n << 1;
 $1 = (($fz) + ($0<<2)|0);
 $k4$0 = 4;$tri$0 = 6456;
 while(1) {
  $2 = $k4$0 >> 1;
  $3 = $k4$0 << 1;
  $4 = ($k4$0*3)|0;
  $5 = $k4$0 << 2;
  $6 = (($fz) + ($2<<2)|0);
  $fi$0 = $fz;$gi$0 = $6;
  while(1) {
   $7 = +HEAPF32[$fi$0>>2];
   $8 = (($fi$0) + ($k4$0<<2)|0);
   $9 = +HEAPF32[$8>>2];
   $10 = $7 - $9;
   $11 = $9 + $7;
   $12 = (($fi$0) + ($3<<2)|0);
   $13 = +HEAPF32[$12>>2];
   $14 = (($fi$0) + ($4<<2)|0);
   $15 = +HEAPF32[$14>>2];
   $16 = $13 - $15;
   $17 = $15 + $13;
   $18 = $11 - $17;
   HEAPF32[$12>>2] = $18;
   $19 = $17 + $11;
   HEAPF32[$fi$0>>2] = $19;
   $20 = $10 - $16;
   HEAPF32[$14>>2] = $20;
   $21 = $16 + $10;
   HEAPF32[$8>>2] = $21;
   $22 = +HEAPF32[$gi$0>>2];
   $23 = (($gi$0) + ($k4$0<<2)|0);
   $24 = +HEAPF32[$23>>2];
   $25 = $22 - $24;
   $26 = $24 + $22;
   $27 = (($gi$0) + ($4<<2)|0);
   $28 = +HEAPF32[$27>>2];
   $29 = $28;
   $30 = $29 * 1.4142135623730951;
   $31 = $30;
   $32 = (($gi$0) + ($3<<2)|0);
   $33 = +HEAPF32[$32>>2];
   $34 = $33;
   $35 = $34 * 1.4142135623730951;
   $36 = $35;
   $37 = $26 - $36;
   HEAPF32[$32>>2] = $37;
   $38 = $36 + $26;
   HEAPF32[$gi$0>>2] = $38;
   $39 = $25 - $31;
   HEAPF32[$27>>2] = $39;
   $40 = $31 + $25;
   HEAPF32[$23>>2] = $40;
   $41 = (($gi$0) + ($5<<2)|0);
   $42 = (($fi$0) + ($5<<2)|0);
   $43 = ($42>>>0)<($1>>>0);
   if ($43) {
    $fi$0 = $42;$gi$0 = $41;
   } else {
    break;
   }
  }
  $44 = ((($tri$0)) + 4|0);
  $45 = ($k4$0|0)>(2);
  if ($45) {
   $46 = +HEAPF32[$44>>2];
   $47 = +HEAPF32[$tri$0>>2];
   $c1$02 = $47;$i$01 = 1;$s1$03 = $46;
   while(1) {
    $48 = $s1$03 * 2.0;
    $49 = $48 * $s1$03;
    $50 = 1.0 - $49;
    $51 = $48 * $c1$02;
    $52 = (($fz) + ($i$01<<2)|0);
    $$sum = (($k4$0) - ($i$01))|0;
    $53 = (($fz) + ($$sum<<2)|0);
    $fi$1 = $52;$gi$1 = $53;
    while(1) {
     $54 = (($fi$1) + ($k4$0<<2)|0);
     $55 = +HEAPF32[$54>>2];
     $56 = $55 * $51;
     $57 = (($gi$1) + ($k4$0<<2)|0);
     $58 = +HEAPF32[$57>>2];
     $59 = $58 * $50;
     $60 = $56 - $59;
     $61 = $55 * $50;
     $62 = $58 * $51;
     $63 = $62 + $61;
     $64 = +HEAPF32[$fi$1>>2];
     $65 = $64 - $63;
     $66 = $63 + $64;
     $67 = +HEAPF32[$gi$1>>2];
     $68 = $67 - $60;
     $69 = $67 + $60;
     $70 = (($fi$1) + ($4<<2)|0);
     $71 = +HEAPF32[$70>>2];
     $72 = $71 * $51;
     $73 = (($gi$1) + ($4<<2)|0);
     $74 = +HEAPF32[$73>>2];
     $75 = $74 * $50;
     $76 = $72 - $75;
     $77 = $71 * $50;
     $78 = $74 * $51;
     $79 = $78 + $77;
     $80 = (($fi$1) + ($3<<2)|0);
     $81 = +HEAPF32[$80>>2];
     $82 = $81 - $79;
     $83 = $79 + $81;
     $84 = (($gi$1) + ($3<<2)|0);
     $85 = +HEAPF32[$84>>2];
     $86 = $85 - $76;
     $87 = $85 + $76;
     $88 = $83 * $s1$03;
     $89 = $86 * $c1$02;
     $90 = $88 - $89;
     $91 = $83 * $c1$02;
     $92 = $86 * $s1$03;
     $93 = $91 + $92;
     $94 = $66 - $93;
     HEAPF32[$80>>2] = $94;
     $95 = $93 + $66;
     HEAPF32[$fi$1>>2] = $95;
     $96 = $68 - $90;
     HEAPF32[$73>>2] = $96;
     $97 = $90 + $68;
     HEAPF32[$57>>2] = $97;
     $98 = $87 * $c1$02;
     $99 = $82 * $s1$03;
     $100 = $98 - $99;
     $101 = $87 * $s1$03;
     $102 = $82 * $c1$02;
     $103 = $101 + $102;
     $104 = $69 - $103;
     HEAPF32[$84>>2] = $104;
     $105 = $103 + $69;
     HEAPF32[$gi$1>>2] = $105;
     $106 = $65 - $100;
     HEAPF32[$70>>2] = $106;
     $107 = $100 + $65;
     HEAPF32[$54>>2] = $107;
     $108 = (($gi$1) + ($5<<2)|0);
     $109 = (($fi$1) + ($5<<2)|0);
     $110 = ($109>>>0)<($1>>>0);
     if ($110) {
      $fi$1 = $109;$gi$1 = $108;
     } else {
      break;
     }
    }
    $111 = +HEAPF32[$tri$0>>2];
    $112 = $111 * $c1$02;
    $113 = +HEAPF32[$44>>2];
    $114 = $113 * $s1$03;
    $115 = $112 - $114;
    $116 = $113 * $c1$02;
    $117 = $111 * $s1$03;
    $118 = $116 + $117;
    $119 = (($i$01) + 1)|0;
    $120 = ($119|0)<($2|0);
    if ($120) {
     $c1$02 = $115;$i$01 = $119;$s1$03 = $118;
    } else {
     break;
    }
   }
  }
  $121 = ((($tri$0)) + 8|0);
  $122 = ($5|0)<($0|0);
  if ($122) {
   $k4$0 = $5;$tri$0 = $121;
  } else {
   break;
  }
 }
 return;
}
function _lame_get_id3v2_tag($gfp,$buffer,$size) {
 $gfp = $gfp|0;
 $buffer = $buffer|0;
 $size = $size|0;
 var $$$i = 0, $$$i$i = 0, $$$i$i29 = 0, $$0 = 0, $$0$be$i$i = 0, $$0$i = 0, $$0$i$off0$i$i = 0, $$0$i$off0$i$i18 = 0, $$0$i$off0$i$i66 = 0, $$0$i$off0$i22$i = 0, $$0$i$off0$i30$i = 0, $$0$i$off0$i35$i = 0, $$0$i$off0$i8$i = 0, $$0$i$off0$i8$i47 = 0, $$0$i$off0$i836$i = 0, $$0$i$off0$i841$i = 0, $$0$i$off0$v$i$i = 0, $$0$i$off0$v$i$i17 = 0, $$0$i$off0$v$i$i65 = 0, $$0$i$off0$v$i21$i = 0;
 var $$0$i$off0$v$i29$i = 0, $$0$i$off0$v$i34$i = 0, $$0$i$off0$v$i7$i = 0, $$0$i$off0$v$i7$i46 = 0, $$0$i$off0$v$i735$i = 0, $$0$i$off0$v$i740$i = 0, $$0$i$off8$i$i = 0, $$0$i$off8$i$i20 = 0, $$0$i$off8$i$i68 = 0, $$0$i$off8$i10$i = 0, $$0$i$off8$i10$i49 = 0, $$0$i$off8$i1038$i = 0, $$0$i$off8$i1043$i = 0, $$0$i$off8$i24$i = 0, $$0$i$off8$i32$i = 0, $$0$i$off8$i37$i = 0, $$0$i$off8$v$i$i = 0, $$0$i$off8$v$i$i19 = 0, $$0$i$off8$v$i$i67 = 0, $$0$i$off8$v$i9$i = 0;
 var $$0$i$off8$v$i9$i48 = 0, $$0$i23 = 0, $$0$i3$i$i = 0, $$0$i3$off$i$i = 0, $$0$i53 = 0, $$0$sum$i = 0, $$0$sum30$i = 0, $$0$sum45$i = 0, $$01$ph8$i$i = 0, $$010$i25$i = 0, $$010$i33$i = 0, $$010$i339$i = 0, $$010$i344$i = 0, $$010$i38$i = 0, $$014$i$i = 0, $$014$i$i25 = 0, $$014$i$i56 = 0, $$014$i19$i = 0, $$014$i19$i36 = 0, $$014$i7$i = 0;
 var $$015$i$i = 0, $$02$lcssa$i12$i = 0, $$02$lcssa$i24$i = 0, $$02$ph7$i$i = 0, $$023$i$i = 0, $$023$i$i26 = 0, $$023$i$i57 = 0, $$023$i20$i = 0, $$023$i20$i37 = 0, $$023$i8$i = 0, $$048$i = 0, $$05$i$i = 0, $$05$i$i24 = 0, $$05$i$i55 = 0, $$05$i18$i = 0, $$05$i18$i35 = 0, $$05$i6$i = 0, $$0511$i = 0, $$06$i$i = 0, $$06$lcssa$i = 0;
 var $$0610$i = 0, $$09$i = 0, $$1$i16$i = 0, $$1$i5$i = 0, $$17$i = 0, $$idx$val = 0, $$idx9 = 0, $$idx9$val = 0, $$in$i$i = 0, $$lobit = 0, $$lobit85 = 0, $$pn = 0, $$pn$i = 0, $$pn$i14 = 0, $$pn$i62 = 0, $$pn40$i = 0, $$pn46$i = 0, $$pre$i$i = 0, $$pre$i$i15 = 0, $$pre$i$i63 = 0;
 var $$pre$i12$i = 0, $$pre$i12$i44 = 0, $$sink$i = 0, $$sum$i = 0, $$sum$i12 = 0, $$sum$i39 = 0, $$sum15$i = 0, $$sum26$i = 0, $$sum26$pn$i = 0, $$sum27$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0;
 var $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0;
 var $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0;
 var $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0;
 var $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0;
 var $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0;
 var $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0;
 var $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0;
 var $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0;
 var $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0;
 var $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0;
 var $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0;
 var $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0;
 var $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0;
 var $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0;
 var $36 = 0.0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0.0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0;
 var $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0;
 var $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0.0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0.0, $410 = 0, $411 = 0, $412 = 0;
 var $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0;
 var $431 = 0, $432 = 0, $433 = 0, $434 = 0, $435 = 0, $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0;
 var $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0, $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0;
 var $468 = 0, $469 = 0, $47 = 0, $470 = 0, $471 = 0, $472 = 0, $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0;
 var $486 = 0, $487 = 0, $488 = 0, $489 = 0, $49 = 0, $490 = 0, $491 = 0, $492 = 0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $502 = 0;
 var $503 = 0, $504 = 0, $505 = 0, $506 = 0, $507 = 0, $508 = 0, $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $514 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0;
 var $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0;
 var $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0;
 var $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $albumart_mime$0$ph = 0, $albumart_mime$1 = 0, $buffer$i = 0, $cond$i = 0, $cond$i$i = 0, $cond$i$i10 = 0, $cond$i$i32 = 0, $cond$i73 = 0, $cond$i75 = 0, $cond1$i = 0, $cond1$i$i = 0, $cond1$i$i34 = 0, $cond1$i77 = 0, $extract5$i$i = 0, $extract5$i$i16 = 0;
 var $extract5$i$i64 = 0, $extract5$i20$i = 0, $extract5$i28$i = 0, $extract5$i33$i = 0, $extract5$i6$i = 0, $extract5$i6$i45 = 0, $extract5$i634$i = 0, $extract5$i639$i = 0, $n$0$i = 0, $n$0$i$i = 0, $n$0$i$i33 = 0, $n$0$i76 = 0, $n$1$i = 0, $n$1$i$i = 0, $n$1$i$i11 = 0, $n$2$i$i = 0, $node$096 = 0, $node2$093 = 0, $notlhs = 0, $notrhs = 0;
 var $or$cond = 0, $or$cond3 = 0, $or$cond3$i = 0, $or$cond5 = 0, $or$cond7$not = 0, $or$cond82 = 0, $p$091 = 0, $p$1 = 0, $p$2 = 0, $p$3 = 0, $phitmp$i = 0, $phitmp$i41 = 0, $phitmp18$i = 0, $phitmp19$i = 0, $phitmp31$i = 0, $phitmp32$i = 0, $playlength_ms$0$i = 0, $scevgep$i = 0, $scevgep$i$i = 0, $scevgep$i$i30 = 0;
 var $scevgep$i$i70 = 0, $scevgep$i1$i = 0, $scevgep$i1$i59 = 0, $scevgep$i10$i = 0, $scevgep$i14$i = 0, $scevgep$i14$i51 = 0, $scevgep$i14$sum$i = 0, $scevgep$i14$sum27$i = 0, $scevgep$i2$i = 0, $scevgep$i22$i = 0, $scevgep$i22$i40 = 0, $scevgep$i22$sum$i = 0, $scevgep$i4$i = 0, $tag_size$0 = 0, $tag_size$195 = 0, $tag_size$2 = 0, $tag_size$3 = 0, $tag_size$4 = 0, $vararg_buffer = 0, label = 0;
 var sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 1040|0;
 $vararg_buffer = sp;
 $buffer$i = sp + 8|0;
 $0 = ($gfp|0)==(0|0);
 if ($0) {
  $$0 = 0;
  STACKTOP = sp;return ($$0|0);
 }
 $1 = ((($gfp)) + 288|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = ($2|0)==(0|0);
 if ($3) {
  $$0 = 0;
  STACKTOP = sp;return ($$0|0);
 }
 $$idx9 = ((($2)) + 85696|0);
 $$idx9$val = HEAP32[$$idx9>>2]|0;
 $$lobit = $$idx9$val & 4;
 $4 = ($$lobit|0)==(0);
 if (!($4)) {
  $$0 = 0;
  STACKTOP = sp;return ($$0|0);
 }
 $5 = $$idx9$val & 10;
 $6 = ((($2)) + 85704|0);
 $7 = HEAP32[$6>>2]|0;
 $8 = ($7|0)==(0|0);
 if ($8) {
  $22 = 0;
 } else {
  $9 = (_strlen(($7|0))|0);
  $22 = $9;
 }
 $10 = ((($2)) + 85708|0);
 $11 = HEAP32[$10>>2]|0;
 $12 = ($11|0)==(0|0);
 if ($12) {
  $24 = 0;
 } else {
  $13 = (_strlen(($11|0))|0);
  $24 = $13;
 }
 $14 = ((($2)) + 85712|0);
 $15 = HEAP32[$14>>2]|0;
 $16 = ($15|0)==(0|0);
 if ($16) {
  $26 = 0;
 } else {
  $17 = (_strlen(($15|0))|0);
  $26 = $17;
 }
 $18 = ((($2)) + 85716|0);
 $19 = HEAP32[$18>>2]|0;
 $20 = ($19|0)==(0|0);
 if ($20) {
  $28 = 0;
 } else {
  $21 = (_strlen(($19|0))|0);
  $28 = $21;
 }
 $23 = ($22>>>0)>(30);
 $25 = ($24>>>0)>(30);
 $or$cond = $23 | $25;
 $27 = ($26>>>0)>(30);
 $or$cond3 = $or$cond | $27;
 $29 = ($28>>>0)>(30);
 $or$cond5 = $or$cond3 | $29;
 if (!($or$cond5)) {
  $30 = ((($2)) + 85720|0);
  $31 = HEAP32[$30>>2]|0;
  $notlhs = ($31|0)==(0);
  $notrhs = ($28>>>0)<(29);
  $or$cond7$not = $notrhs | $notlhs;
  $32 = ($5|0)==(0);
  $or$cond82 = $32 & $or$cond7$not;
  if ($or$cond82) {
   $$0 = 0;
   STACKTOP = sp;return ($$0|0);
  }
 }
 $33 = ((($gfp)) + 4|0);
 $34 = HEAP32[$33>>2]|0;
 $35 = ($34|0)==(-1);
 if (!($35)) {
  $36 = (+($34>>>0));
  $37 = $36 * 1000.0;
  $38 = ((($2)) + 60|0);
  $39 = HEAP32[$38>>2]|0;
  $40 = (+($39|0));
  $41 = $37 / $40;
  $42 = $41 > 4294967295.0;
  if ($42) {
   $playlength_ms$0$i = -1;
  } else {
   $43 = $41 < 0.0;
   if ($43) {
    $playlength_ms$0$i = 0;
   } else {
    $44 = (~~(($41))>>>0);
    $playlength_ms$0$i = $44;
   }
  }
  HEAP32[$vararg_buffer>>2] = $playlength_ms$0$i;
  (_sprintf($buffer$i,6496,$vararg_buffer)|0);
  $45 = HEAP32[$1>>2]|0;
  $46 = ($45|0)==(0|0);
  if (!($46)) {
   $47 = ((($45)) + 85696|0);
   $48 = HEAP32[$47>>2]|0;
   (_id3v2_add_latin1($gfp,1414284622,6488,0,$buffer$i)|0);
   HEAP32[$47>>2] = $48;
  }
 }
 $49 = ((($2)) + 85728|0);
 $50 = HEAP32[$49>>2]|0;
 $51 = ($50|0)==(0|0);
 do {
  if ($51) {
   $albumart_mime$1 = 0;$tag_size$0 = 10;
  } else {
   $52 = ((($2)) + 85732|0);
   $53 = HEAP32[$52>>2]|0;
   $54 = ($53|0)==(0);
   if ($54) {
    $albumart_mime$1 = 0;$tag_size$0 = 10;
   } else {
    $55 = ((($2)) + 85740|0);
    $56 = HEAP32[$55>>2]|0;
    if ((($56|0) == 2)) {
     $albumart_mime$0$ph = 6504;
    } else if ((($56|0) == 3)) {
     $albumart_mime$0$ph = 6520;
    } else if ((($56|0) == 1)) {
     $albumart_mime$0$ph = 6536;
    } else {
     $albumart_mime$1 = 0;$tag_size$0 = 10;
     break;
    }
    $57 = (_strlen(($albumart_mime$0$ph|0))|0);
    $58 = (($57) + 24)|0;
    $59 = (($58) + ($53))|0;
    $albumart_mime$1 = $albumart_mime$0$ph;$tag_size$0 = $59;
   }
  }
 } while(0);
 $60 = ((($2)) + 85744|0);
 $61 = HEAP32[$60>>2]|0;
 $62 = ($61|0)==(0|0);
 if ($62) {
  $tag_size$3 = $tag_size$0;
 } else {
  $node$096 = $61;$tag_size$195 = $tag_size$0;
  while(1) {
   $63 = ((($node$096)) + 4|0);
   $64 = HEAP32[$63>>2]|0;
   do {
    if ((($64|0) == 1431520594) | (($64|0) == 1129270605)) {
     $65 = ((($node$096)) + 20|0);
     $66 = HEAP32[$65>>2]|0;
     $cond$i75 = ($66|0)==(1);
     $67 = ((($node$096)) + 16|0);
     $68 = HEAP32[$67>>2]|0;
     $69 = $68 << 1;
     $70 = (($69) + 16)|0;
     $71 = (($68) + 15)|0;
     $n$0$i76 = $cond$i75 ? $70 : $71;
     $72 = ((($node$096)) + 32|0);
     $73 = HEAP32[$72>>2]|0;
     $cond1$i77 = ($73|0)==(1);
     $74 = ((($node$096)) + 28|0);
     $75 = HEAP32[$74>>2]|0;
     if ($cond1$i77) {
      $77 = $75 << 1;
      $78 = (($n$0$i76) + ($77))|0;
      $$pn = $78;
      break;
     } else {
      $76 = (($n$0$i76) + ($75))|0;
      $$pn = $76;
      break;
     }
    } else {
     $79 = $64 & -16777216;
     if (!((($79|0) == 0) | (($79|0) == 1459617792))) {
      $96 = ((($node$096)) + 32|0);
      $97 = HEAP32[$96>>2]|0;
      $cond$i = ($97|0)==(1);
      $98 = ((($node$096)) + 16|0);
      $99 = HEAP32[$98>>2]|0;
      $100 = ($99|0)!=(0);
      $101 = ((($node$096)) + 28|0);
      $102 = HEAP32[$101>>2]|0;
      if ($cond$i) {
       $105 = $99 << 1;
       $106 = (($105) + 13)|0;
       $n$1$i = $100 ? $106 : 11;
       $107 = $102 << 1;
       $108 = (($n$1$i) + ($107))|0;
       $$pn = $108;
       break;
      } else {
       $103 = (($99) + 12)|0;
       $$$i = $100 ? $103 : 11;
       $104 = (($$$i) + ($102))|0;
       $$pn = $104;
       break;
      }
     }
     $80 = ((($node$096)) + 16|0);
     $81 = HEAP32[$80>>2]|0;
     $82 = ($81|0)==(0);
     do {
      if ($82) {
       $n$0$i = 10;
      } else {
       $83 = ((($node$096)) + 20|0);
       $84 = HEAP32[$83>>2]|0;
       $cond$i73 = ($84|0)==(1);
       if ($cond$i73) {
        $86 = $81 << 1;
        $87 = (($86) + 13)|0;
        $n$0$i = $87;
        break;
       } else {
        $85 = (($81) + 12)|0;
        $n$0$i = $85;
        break;
       }
      }
     } while(0);
     $88 = ((($node$096)) + 28|0);
     $89 = HEAP32[$88>>2]|0;
     $90 = ($89|0)==(0);
     if ($90) {
      $$pn = $n$0$i;
     } else {
      $91 = ((($node$096)) + 32|0);
      $92 = HEAP32[$91>>2]|0;
      $cond1$i = ($92|0)==(1);
      if ($cond1$i) {
       $94 = (($n$0$i) + -1)|0;
       $95 = (($94) + ($89))|0;
       $$pn = $95;
       break;
      } else {
       $93 = (($89) + ($n$0$i))|0;
       $$pn = $93;
       break;
      }
     }
    }
   } while(0);
   $tag_size$2 = (($$pn) + ($tag_size$195))|0;
   $109 = HEAP32[$node$096>>2]|0;
   $110 = ($109|0)==(0|0);
   if ($110) {
    $tag_size$3 = $tag_size$2;
    break;
   } else {
    $node$096 = $109;$tag_size$195 = $tag_size$2;
   }
  }
 }
 $$idx$val = HEAP32[$$idx9>>2]|0;
 $$lobit85 = $$idx$val & 32;
 $111 = ($$lobit85|0)==(0);
 if ($111) {
  $tag_size$4 = $tag_size$3;
 } else {
  $112 = ((($2)) + 85736|0);
  $113 = HEAP32[$112>>2]|0;
  $114 = (($113) + ($tag_size$3))|0;
  $tag_size$4 = $114;
 }
 $115 = ($tag_size$4>>>0)>($size>>>0);
 if ($115) {
  $$0 = $tag_size$4;
  STACKTOP = sp;return ($$0|0);
 }
 $116 = ($buffer|0)==(0|0);
 if ($116) {
  $$0 = 0;
  STACKTOP = sp;return ($$0|0);
 }
 $117 = ((($buffer)) + 1|0);
 HEAP8[$buffer>>0] = 73;
 $118 = ((($buffer)) + 2|0);
 HEAP8[$117>>0] = 68;
 $119 = ((($buffer)) + 3|0);
 HEAP8[$118>>0] = 51;
 $120 = ((($buffer)) + 4|0);
 HEAP8[$119>>0] = 3;
 $121 = ((($buffer)) + 5|0);
 HEAP8[$120>>0] = 0;
 $122 = ((($buffer)) + 6|0);
 HEAP8[$121>>0] = 0;
 $123 = (($tag_size$4) + -10)|0;
 $124 = $123 >>> 21;
 $125 = $124 & 127;
 $126 = $125&255;
 $127 = ((($buffer)) + 7|0);
 HEAP8[$122>>0] = $126;
 $128 = $123 >>> 14;
 $129 = $128 & 127;
 $130 = $129&255;
 $131 = ((($buffer)) + 8|0);
 HEAP8[$127>>0] = $130;
 $132 = $123 >>> 7;
 $133 = $132 & 127;
 $134 = $133&255;
 $135 = ((($buffer)) + 9|0);
 HEAP8[$131>>0] = $134;
 $136 = $123 & 127;
 $137 = $136&255;
 $138 = ((($buffer)) + 10|0);
 HEAP8[$135>>0] = $137;
 $139 = HEAP32[$60>>2]|0;
 $140 = ($139|0)==(0|0);
 if ($140) {
  $p$2 = $138;
 } else {
  $node2$093 = $139;$p$091 = $138;
  while(1) {
   $141 = ((($node2$093)) + 4|0);
   $142 = HEAP32[$141>>2]|0;
   do {
    if ((($142|0) == 1431520594) | (($142|0) == 1129270605)) {
     $143 = ((($node2$093)) + 20|0);
     $144 = HEAP32[$143>>2]|0;
     $cond$i$i32 = ($144|0)==(1);
     $145 = ((($node2$093)) + 16|0);
     $146 = HEAP32[$145>>2]|0;
     $147 = $146 << 1;
     $148 = (($147) + 16)|0;
     $149 = (($146) + 15)|0;
     $n$0$i$i33 = $cond$i$i32 ? $148 : $149;
     $150 = ((($node2$093)) + 32|0);
     $151 = HEAP32[$150>>2]|0;
     $cond1$i$i34 = ($151|0)==(1);
     $152 = ((($node2$093)) + 28|0);
     $153 = HEAP32[$152>>2]|0;
     $154 = $cond1$i$i34&1;
     $$sink$i = $153 << $154;
     $155 = (($$sink$i) + ($n$0$i$i33))|0;
     $156 = ($155>>>0)>(10);
     if ($156) {
      $157 = $142&255;
      $158 = ((($p$091)) + 3|0);
      HEAP8[$158>>0] = $157;
      $159 = $142 >>> 8;
      $160 = $159&255;
      $161 = ((($p$091)) + 2|0);
      HEAP8[$161>>0] = $160;
      $162 = $142 >>> 16;
      $163 = $162&255;
      $164 = ((($p$091)) + 1|0);
      HEAP8[$164>>0] = $163;
      $165 = $142 >>> 24;
      $166 = $165&255;
      HEAP8[$p$091>>0] = $166;
      $167 = ((($p$091)) + 4|0);
      $168 = (($155) + -10)|0;
      $169 = $168&255;
      $170 = ((($p$091)) + 7|0);
      HEAP8[$170>>0] = $169;
      $171 = $168 >>> 8;
      $172 = $171&255;
      $173 = ((($p$091)) + 6|0);
      HEAP8[$173>>0] = $172;
      $174 = $168 >>> 16;
      $175 = $174&255;
      $176 = ((($p$091)) + 5|0);
      HEAP8[$176>>0] = $175;
      $177 = $168 >>> 24;
      $178 = $177&255;
      HEAP8[$167>>0] = $178;
      $179 = ((($p$091)) + 8|0);
      $180 = ((($p$091)) + 9|0);
      HEAP8[$179>>0] = 0;
      $181 = ((($p$091)) + 10|0);
      HEAP8[$180>>0] = 0;
      $182 = ((($node2$093)) + 24|0);
      $183 = HEAP32[$150>>2]|0;
      $184 = ($183|0)==(1);
      $185 = $184&1;
      $186 = ((($p$091)) + 11|0);
      HEAP8[$181>>0] = $185;
      $187 = ((($node2$093)) + 8|0);
      $188 = HEAP8[$187>>0]|0;
      $189 = ((($p$091)) + 12|0);
      HEAP8[$186>>0] = $188;
      $190 = ((($node2$093)) + 9|0);
      $191 = HEAP8[$190>>0]|0;
      $192 = ((($p$091)) + 13|0);
      HEAP8[$189>>0] = $191;
      $193 = ((($node2$093)) + 10|0);
      $194 = HEAP8[$193>>0]|0;
      $195 = ((($p$091)) + 14|0);
      HEAP8[$192>>0] = $194;
      $196 = ((($node2$093)) + 12|0);
      $197 = HEAP32[$143>>2]|0;
      $198 = ($197|0)==(1);
      if ($198) {
       $207 = HEAP32[$196>>2]|0;
       $208 = HEAP32[$145>>2]|0;
       $209 = ($208|0)==(0);
       if ($209) {
        $$1$i16$i = $195;$224 = 15;$514 = 16;
       } else {
        $210 = HEAP16[$207>>1]|0;
        $211 = ($210<<16>>16)==(-2);
        $212 = $208 << 1;
        $213 = (($208) + -1)|0;
        $extract5$i639$i = ($210&65535) >>> 8;
        $$0$i$off0$v$i740$i = $211 ? $extract5$i639$i : $210;
        $$0$i$off0$i841$i = $$0$i$off0$v$i740$i&255;
        $214 = $extract5$i639$i&255;
        $$0$i$off8$i1043$i = $211 ? -2 : $214;
        $215 = ((($p$091)) + 15|0);
        HEAP8[$195>>0] = $$0$i$off0$i841$i;
        HEAP8[$215>>0] = $$0$i$off8$i1043$i;
        $216 = ($213|0)==(0);
        if (!($216)) {
         $$010$i344$i = $195;$$pn46$i = $207;$220 = $213;
         while(1) {
          $217 = ((($$pn46$i)) + 2|0);
          $218 = ((($$010$i344$i)) + 2|0);
          $$pre$i12$i44 = HEAP16[$217>>1]|0;
          $219 = (($220) + -1)|0;
          $extract5$i6$i45 = ($$pre$i12$i44&65535) >>> 8;
          $$0$i$off0$v$i7$i46 = $211 ? $extract5$i6$i45 : $$pre$i12$i44;
          $$0$i$off0$i8$i47 = $$0$i$off0$v$i7$i46&255;
          $$0$i$off8$v$i9$i48 = $211 ? $$pre$i12$i44 : $extract5$i6$i45;
          $$0$i$off8$i10$i49 = $$0$i$off8$v$i9$i48&255;
          $221 = ((($$010$i344$i)) + 3|0);
          HEAP8[$218>>0] = $$0$i$off0$i8$i47;
          HEAP8[$221>>0] = $$0$i$off8$i10$i49;
          $222 = ($219|0)==(0);
          if ($222) {
           break;
          } else {
           $$010$i344$i = $218;$$pn46$i = $217;$220 = $219;
          }
         }
        }
        $$sum27$i = (($212) + 14)|0;
        $scevgep$i14$i51 = (($p$091) + ($$sum27$i)|0);
        $phitmp31$i = (($212) + 15)|0;
        $phitmp32$i = (($212) + 16)|0;
        $$1$i16$i = $scevgep$i14$i51;$224 = $phitmp31$i;$514 = $phitmp32$i;
       }
       $223 = (($p$091) + ($224)|0);
       HEAP8[$$1$i16$i>>0] = 0;
       HEAP8[$223>>0] = 0;
       $$sum26$pn$i = $514;
      } else {
       $199 = HEAP32[$145>>2]|0;
       $200 = ($199|0)==(0);
       if ($200) {
        $$02$lcssa$i24$i = $195;$513 = 15;
       } else {
        $201 = HEAP32[$196>>2]|0;
        $$014$i19$i36 = $201;$$023$i20$i37 = $195;$$05$i18$i35 = $199;
        while(1) {
         $202 = (($$05$i18$i35) + -1)|0;
         $203 = ((($$014$i19$i36)) + 1|0);
         $204 = HEAP8[$$014$i19$i36>>0]|0;
         $205 = ((($$023$i20$i37)) + 1|0);
         HEAP8[$$023$i20$i37>>0] = $204;
         $206 = ($202|0)==(0);
         if ($206) {
          break;
         } else {
          $$014$i19$i36 = $203;$$023$i20$i37 = $205;$$05$i18$i35 = $202;
         }
        }
        $$sum$i39 = (($199) + 14)|0;
        $scevgep$i22$i40 = (($p$091) + ($$sum$i39)|0);
        $phitmp$i41 = (($199) + 15)|0;
        $$02$lcssa$i24$i = $scevgep$i22$i40;$513 = $phitmp$i41;
       }
       HEAP8[$$02$lcssa$i24$i>>0] = 0;
       $$sum26$pn$i = $513;
      }
      $$0$i53 = (($p$091) + ($$sum26$pn$i)|0);
      $225 = HEAP32[$150>>2]|0;
      $226 = ($225|0)==(1);
      if ($226) {
       $235 = HEAP32[$182>>2]|0;
       $236 = HEAP32[$152>>2]|0;
       $237 = ($236|0)==(0);
       if ($237) {
        $p$1 = $$0$i53;
        break;
       }
       $238 = HEAP16[$235>>1]|0;
       $239 = ($238<<16>>16)==(-2);
       $240 = $236 << 1;
       $241 = (($236) + -1)|0;
       $extract5$i33$i = ($238&65535) >>> 8;
       $$0$i$off0$v$i34$i = $239 ? $extract5$i33$i : $238;
       $$0$i$off0$i35$i = $$0$i$off0$v$i34$i&255;
       $242 = $extract5$i33$i&255;
       $$0$i$off8$i37$i = $239 ? -2 : $242;
       $$0$sum45$i = (($$sum26$pn$i) + 1)|0;
       $243 = (($p$091) + ($$0$sum45$i)|0);
       HEAP8[$$0$i53>>0] = $$0$i$off0$i35$i;
       HEAP8[$243>>0] = $$0$i$off8$i37$i;
       $244 = ($241|0)==(0);
       if (!($244)) {
        $$010$i38$i = $$0$i53;$$pn$i62 = $235;$248 = $241;
        while(1) {
         $245 = ((($$pn$i62)) + 2|0);
         $246 = ((($$010$i38$i)) + 2|0);
         $$pre$i$i63 = HEAP16[$245>>1]|0;
         $247 = (($248) + -1)|0;
         $extract5$i$i64 = ($$pre$i$i63&65535) >>> 8;
         $$0$i$off0$v$i$i65 = $239 ? $extract5$i$i64 : $$pre$i$i63;
         $$0$i$off0$i$i66 = $$0$i$off0$v$i$i65&255;
         $$0$i$off8$v$i$i67 = $239 ? $$pre$i$i63 : $extract5$i$i64;
         $$0$i$off8$i$i68 = $$0$i$off8$v$i$i67&255;
         $249 = ((($$010$i38$i)) + 3|0);
         HEAP8[$246>>0] = $$0$i$off0$i$i66;
         HEAP8[$249>>0] = $$0$i$off8$i$i68;
         $250 = ($247|0)==(0);
         if ($250) {
          break;
         } else {
          $$010$i38$i = $246;$$pn$i62 = $245;$248 = $247;
         }
        }
       }
       $$0$sum30$i = (($240) + ($$sum26$pn$i))|0;
       $scevgep$i$i70 = (($p$091) + ($$0$sum30$i)|0);
       $p$1 = $scevgep$i$i70;
       break;
      } else {
       $227 = HEAP32[$152>>2]|0;
       $228 = ($227|0)==(0);
       if ($228) {
        $p$1 = $$0$i53;
        break;
       }
       $229 = HEAP32[$182>>2]|0;
       $$014$i$i56 = $229;$$023$i$i57 = $$0$i53;$$05$i$i55 = $227;
       while(1) {
        $230 = (($$05$i$i55) + -1)|0;
        $231 = ((($$014$i$i56)) + 1|0);
        $232 = HEAP8[$$014$i$i56>>0]|0;
        $233 = ((($$023$i$i57)) + 1|0);
        HEAP8[$$023$i$i57>>0] = $232;
        $234 = ($230|0)==(0);
        if ($234) {
         break;
        } else {
         $$014$i$i56 = $231;$$023$i$i57 = $233;$$05$i$i55 = $230;
        }
       }
       $$0$sum$i = (($227) + ($$sum26$pn$i))|0;
       $scevgep$i1$i59 = (($p$091) + ($$0$sum$i)|0);
       $p$1 = $scevgep$i1$i59;
       break;
      }
     } else {
      $p$1 = $p$091;
     }
    } else {
     $251 = $142 & -16777216;
     if (!((($251|0) == 0) | (($251|0) == 1459617792))) {
      $365 = ((($node2$093)) + 32|0);
      $366 = HEAP32[$365>>2]|0;
      $cond$i$i = ($366|0)==(1);
      $367 = ((($node2$093)) + 16|0);
      $368 = HEAP32[$367>>2]|0;
      $369 = ($368|0)!=(0);
      $370 = ((($node2$093)) + 28|0);
      $371 = HEAP32[$370>>2]|0;
      if ($cond$i$i) {
       $374 = $368 << 1;
       $375 = (($374) + 13)|0;
       $n$1$i$i = $369 ? $375 : 11;
       $376 = $371 << 1;
       $377 = (($n$1$i$i) + ($376))|0;
       $n$2$i$i = $377;
      } else {
       $372 = (($368) + 12)|0;
       $$$i$i = $369 ? $372 : 11;
       $373 = (($$$i$i) + ($371))|0;
       $n$2$i$i = $373;
      }
      $378 = ($n$2$i$i>>>0)>(10);
      if (!($378)) {
       $p$1 = $p$091;
       break;
      }
      $379 = $142&255;
      $380 = ((($p$091)) + 3|0);
      HEAP8[$380>>0] = $379;
      $381 = $142 >>> 8;
      $382 = $381&255;
      $383 = ((($p$091)) + 2|0);
      HEAP8[$383>>0] = $382;
      $384 = $142 >>> 16;
      $385 = $384&255;
      $386 = ((($p$091)) + 1|0);
      HEAP8[$386>>0] = $385;
      $387 = $142 >>> 24;
      $388 = $387&255;
      HEAP8[$p$091>>0] = $388;
      $389 = ((($p$091)) + 4|0);
      $390 = (($n$2$i$i) + -10)|0;
      $391 = $390&255;
      $392 = ((($p$091)) + 7|0);
      HEAP8[$392>>0] = $391;
      $393 = $390 >>> 8;
      $394 = $393&255;
      $395 = ((($p$091)) + 6|0);
      HEAP8[$395>>0] = $394;
      $396 = $390 >>> 16;
      $397 = $396&255;
      $398 = ((($p$091)) + 5|0);
      HEAP8[$398>>0] = $397;
      $399 = $390 >>> 24;
      $400 = $399&255;
      HEAP8[$389>>0] = $400;
      $401 = ((($p$091)) + 8|0);
      $402 = ((($p$091)) + 9|0);
      HEAP8[$401>>0] = 0;
      $403 = ((($p$091)) + 10|0);
      HEAP8[$402>>0] = 0;
      $404 = ((($node2$093)) + 24|0);
      $405 = HEAP32[$365>>2]|0;
      $406 = ($405|0)==(1);
      $407 = $406&1;
      $408 = ((($p$091)) + 11|0);
      HEAP8[$403>>0] = $407;
      $409 = HEAP32[$367>>2]|0;
      $410 = ($409|0)==(0);
      do {
       if ($410) {
        $$0$i = $408;
       } else {
        $411 = ((($node2$093)) + 20|0);
        $412 = HEAP32[$411>>2]|0;
        $413 = ($412|0)==(1);
        $414 = ((($node2$093)) + 12|0);
        if ($413) {
         $422 = HEAP32[$414>>2]|0;
         $423 = HEAP16[$422>>1]|0;
         $424 = ($423<<16>>16)==(-2);
         $425 = $409 << 1;
         $426 = (($409) + -1)|0;
         $extract5$i634$i = ($423&65535) >>> 8;
         $$0$i$off0$v$i735$i = $424 ? $extract5$i634$i : $423;
         $$0$i$off0$i836$i = $$0$i$off0$v$i735$i&255;
         $427 = $extract5$i634$i&255;
         $$0$i$off8$i1038$i = $424 ? -2 : $427;
         $428 = ((($p$091)) + 12|0);
         HEAP8[$408>>0] = $$0$i$off0$i836$i;
         HEAP8[$428>>0] = $$0$i$off8$i1038$i;
         $429 = ($426|0)==(0);
         if (!($429)) {
          $$010$i339$i = $408;$$pn40$i = $422;$433 = $426;
          while(1) {
           $430 = ((($$pn40$i)) + 2|0);
           $431 = ((($$010$i339$i)) + 2|0);
           $$pre$i12$i = HEAP16[$430>>1]|0;
           $432 = (($433) + -1)|0;
           $extract5$i6$i = ($$pre$i12$i&65535) >>> 8;
           $$0$i$off0$v$i7$i = $424 ? $extract5$i6$i : $$pre$i12$i;
           $$0$i$off0$i8$i = $$0$i$off0$v$i7$i&255;
           $$0$i$off8$v$i9$i = $424 ? $$pre$i12$i : $extract5$i6$i;
           $$0$i$off8$i10$i = $$0$i$off8$v$i9$i&255;
           $434 = ((($$010$i339$i)) + 3|0);
           HEAP8[$431>>0] = $$0$i$off0$i8$i;
           HEAP8[$434>>0] = $$0$i$off8$i10$i;
           $435 = ($432|0)==(0);
           if ($435) {
            break;
           } else {
            $$010$i339$i = $431;$$pn40$i = $430;$433 = $432;
           }
          }
         }
         $$sum26$i = (($425) + 11)|0;
         $scevgep$i14$i = (($p$091) + ($$sum26$i)|0);
         $scevgep$i14$sum$i = (($425) + 12)|0;
         $436 = (($p$091) + ($scevgep$i14$sum$i)|0);
         HEAP8[$scevgep$i14$i>>0] = 0;
         $scevgep$i14$sum27$i = (($425) + 13)|0;
         $437 = (($p$091) + ($scevgep$i14$sum27$i)|0);
         HEAP8[$436>>0] = 0;
         $$0$i = $437;
         break;
        } else {
         $415 = HEAP32[$414>>2]|0;
         $$014$i19$i = $415;$$023$i20$i = $408;$$05$i18$i = $409;
         while(1) {
          $416 = (($$05$i18$i) + -1)|0;
          $417 = ((($$014$i19$i)) + 1|0);
          $418 = HEAP8[$$014$i19$i>>0]|0;
          $419 = ((($$023$i20$i)) + 1|0);
          HEAP8[$$023$i20$i>>0] = $418;
          $420 = ($416|0)==(0);
          if ($420) {
           break;
          } else {
           $$014$i19$i = $417;$$023$i20$i = $419;$$05$i18$i = $416;
          }
         }
         $$sum$i = (($409) + 11)|0;
         $scevgep$i22$i = (($p$091) + ($$sum$i)|0);
         $scevgep$i22$sum$i = (($409) + 12)|0;
         $421 = (($p$091) + ($scevgep$i22$sum$i)|0);
         HEAP8[$scevgep$i22$i>>0] = 0;
         $$0$i = $421;
         break;
        }
       }
      } while(0);
      $438 = HEAP32[$365>>2]|0;
      $439 = ($438|0)==(1);
      if ($439) {
       $448 = HEAP32[$404>>2]|0;
       $449 = HEAP32[$370>>2]|0;
       $450 = ($449|0)==(0);
       if ($450) {
        $p$1 = $$0$i;
        break;
       }
       $451 = HEAP16[$448>>1]|0;
       $452 = ($451<<16>>16)==(-2);
       $453 = $449 << 1;
       $454 = (($449) + -1)|0;
       $extract5$i28$i = ($451&65535) >>> 8;
       $$0$i$off0$v$i29$i = $452 ? $extract5$i28$i : $451;
       $$0$i$off0$i30$i = $$0$i$off0$v$i29$i&255;
       $455 = $extract5$i28$i&255;
       $$0$i$off8$i32$i = $452 ? -2 : $455;
       $456 = ((($$0$i)) + 1|0);
       HEAP8[$$0$i>>0] = $$0$i$off0$i30$i;
       HEAP8[$456>>0] = $$0$i$off8$i32$i;
       $457 = ($454|0)==(0);
       if (!($457)) {
        $$010$i33$i = $$0$i;$$pn$i = $448;$461 = $454;
        while(1) {
         $458 = ((($$pn$i)) + 2|0);
         $459 = ((($$010$i33$i)) + 2|0);
         $$pre$i$i = HEAP16[$458>>1]|0;
         $460 = (($461) + -1)|0;
         $extract5$i$i = ($$pre$i$i&65535) >>> 8;
         $$0$i$off0$v$i$i = $452 ? $extract5$i$i : $$pre$i$i;
         $$0$i$off0$i$i = $$0$i$off0$v$i$i&255;
         $$0$i$off8$v$i$i = $452 ? $$pre$i$i : $extract5$i$i;
         $$0$i$off8$i$i = $$0$i$off8$v$i$i&255;
         $462 = ((($$010$i33$i)) + 3|0);
         HEAP8[$459>>0] = $$0$i$off0$i$i;
         HEAP8[$462>>0] = $$0$i$off8$i$i;
         $463 = ($460|0)==(0);
         if ($463) {
          break;
         } else {
          $$010$i33$i = $459;$$pn$i = $458;$461 = $460;
         }
        }
       }
       $scevgep$i$i = (($$0$i) + ($453)|0);
       $p$1 = $scevgep$i$i;
       break;
      } else {
       $440 = HEAP32[$370>>2]|0;
       $441 = ($440|0)==(0);
       if ($441) {
        $p$1 = $$0$i;
        break;
       }
       $442 = HEAP32[$404>>2]|0;
       $$014$i$i = $442;$$023$i$i = $$0$i;$$05$i$i = $440;
       while(1) {
        $443 = (($$05$i$i) + -1)|0;
        $444 = ((($$014$i$i)) + 1|0);
        $445 = HEAP8[$$014$i$i>>0]|0;
        $446 = ((($$023$i$i)) + 1|0);
        HEAP8[$$023$i$i>>0] = $445;
        $447 = ($443|0)==(0);
        if ($447) {
         break;
        } else {
         $$014$i$i = $444;$$023$i$i = $446;$$05$i$i = $443;
        }
       }
       $scevgep$i1$i = (($$0$i) + ($440)|0);
       $p$1 = $scevgep$i1$i;
       break;
      }
     }
     $252 = ((($node2$093)) + 16|0);
     $253 = HEAP32[$252>>2]|0;
     $254 = ($253|0)==(0);
     do {
      if ($254) {
       $n$0$i$i = 10;
      } else {
       $255 = ((($node2$093)) + 20|0);
       $256 = HEAP32[$255>>2]|0;
       $cond$i$i10 = ($256|0)==(1);
       if ($cond$i$i10) {
        $258 = $253 << 1;
        $259 = (($258) + 13)|0;
        $n$0$i$i = $259;
        break;
       } else {
        $257 = (($253) + 12)|0;
        $n$0$i$i = $257;
        break;
       }
      }
     } while(0);
     $260 = ((($node2$093)) + 28|0);
     $261 = HEAP32[$260>>2]|0;
     $262 = ($261|0)==(0);
     do {
      if ($262) {
       $n$1$i$i11 = $n$0$i$i;
      } else {
       $263 = ((($node2$093)) + 32|0);
       $264 = HEAP32[$263>>2]|0;
       $cond1$i$i = ($264|0)==(1);
       if ($cond1$i$i) {
        $266 = (($n$0$i$i) + -1)|0;
        $267 = (($266) + ($261))|0;
        $n$1$i$i11 = $267;
        break;
       } else {
        $265 = (($261) + ($n$0$i$i))|0;
        $n$1$i$i11 = $265;
        break;
       }
      }
     } while(0);
     $268 = ($n$1$i$i11>>>0)>(10);
     if (!($268)) {
      $p$1 = $p$091;
      break;
     }
     $269 = $142&255;
     $270 = ((($p$091)) + 3|0);
     HEAP8[$270>>0] = $269;
     $271 = $142 >>> 8;
     $272 = $271&255;
     $273 = ((($p$091)) + 2|0);
     HEAP8[$273>>0] = $272;
     $274 = $142 >>> 16;
     $275 = $274&255;
     $276 = ((($p$091)) + 1|0);
     HEAP8[$276>>0] = $275;
     $277 = $142 >>> 24;
     $278 = $277&255;
     HEAP8[$p$091>>0] = $278;
     $279 = ((($p$091)) + 4|0);
     $280 = (($n$1$i$i11) + -10)|0;
     $281 = $280&255;
     $282 = ((($p$091)) + 7|0);
     HEAP8[$282>>0] = $281;
     $283 = $280 >>> 8;
     $284 = $283&255;
     $285 = ((($p$091)) + 6|0);
     HEAP8[$285>>0] = $284;
     $286 = $280 >>> 16;
     $287 = $286&255;
     $288 = ((($p$091)) + 5|0);
     HEAP8[$288>>0] = $287;
     $289 = $280 >>> 24;
     $290 = $289&255;
     HEAP8[$279>>0] = $290;
     $291 = ((($p$091)) + 8|0);
     $292 = ((($p$091)) + 9|0);
     HEAP8[$291>>0] = 0;
     $293 = ((($p$091)) + 10|0);
     HEAP8[$292>>0] = 0;
     $294 = HEAP32[$252>>2]|0;
     $295 = ($294|0)==(0);
     do {
      if ($295) {
       $$0$i23 = $293;
      } else {
       $296 = ((($node2$093)) + 20|0);
       $297 = HEAP32[$296>>2]|0;
       $298 = ($297|0)==(1);
       $299 = $298&1;
       $300 = ((($p$091)) + 11|0);
       HEAP8[$293>>0] = $299;
       $301 = HEAP32[$296>>2]|0;
       $302 = ($301|0)==(1);
       $303 = ((($node2$093)) + 12|0);
       if ($302) {
        $314 = HEAP32[$303>>2]|0;
        $315 = HEAP32[$252>>2]|0;
        $316 = ($315|0)==(0);
        if ($316) {
         $$1$i5$i = $300;$331 = 12;$333 = 13;
        } else {
         $317 = HEAP16[$314>>1]|0;
         $318 = ($317<<16>>16)==(-2);
         $319 = $315 << 1;
         $320 = (($315) + -1)|0;
         $extract5$i20$i = ($317&65535) >>> 8;
         $$0$i$off0$v$i21$i = $318 ? $extract5$i20$i : $317;
         $$0$i$off0$i22$i = $$0$i$off0$v$i21$i&255;
         $321 = $extract5$i20$i&255;
         $$0$i$off8$i24$i = $318 ? -2 : $321;
         $322 = ((($p$091)) + 12|0);
         HEAP8[$300>>0] = $$0$i$off0$i22$i;
         HEAP8[$322>>0] = $$0$i$off8$i24$i;
         $323 = ($320|0)==(0);
         if (!($323)) {
          $$010$i25$i = $300;$$pn$i14 = $314;$327 = $320;
          while(1) {
           $324 = ((($$pn$i14)) + 2|0);
           $325 = ((($$010$i25$i)) + 2|0);
           $$pre$i$i15 = HEAP16[$324>>1]|0;
           $326 = (($327) + -1)|0;
           $extract5$i$i16 = ($$pre$i$i15&65535) >>> 8;
           $$0$i$off0$v$i$i17 = $318 ? $extract5$i$i16 : $$pre$i$i15;
           $$0$i$off0$i$i18 = $$0$i$off0$v$i$i17&255;
           $$0$i$off8$v$i$i19 = $318 ? $$pre$i$i15 : $extract5$i$i16;
           $$0$i$off8$i$i20 = $$0$i$off8$v$i$i19&255;
           $328 = ((($$010$i25$i)) + 3|0);
           HEAP8[$325>>0] = $$0$i$off0$i$i18;
           HEAP8[$328>>0] = $$0$i$off8$i$i20;
           $329 = ($326|0)==(0);
           if ($329) {
            break;
           } else {
            $$010$i25$i = $325;$$pn$i14 = $324;$327 = $326;
           }
          }
         }
         $$sum15$i = (($319) + 11)|0;
         $scevgep$i4$i = (($p$091) + ($$sum15$i)|0);
         $phitmp18$i = (($319) + 12)|0;
         $phitmp19$i = (($319) + 13)|0;
         $$1$i5$i = $scevgep$i4$i;$331 = $phitmp18$i;$333 = $phitmp19$i;
        }
        $330 = (($p$091) + ($331)|0);
        HEAP8[$$1$i5$i>>0] = 0;
        $332 = (($p$091) + ($333)|0);
        HEAP8[$330>>0] = 0;
        $$0$i23 = $332;
        break;
       } else {
        $304 = HEAP32[$252>>2]|0;
        $305 = ($304|0)==(0);
        if ($305) {
         $$02$lcssa$i12$i = $300;$313 = 12;
        } else {
         $306 = HEAP32[$303>>2]|0;
         $$014$i7$i = $306;$$023$i8$i = $300;$$05$i6$i = $304;
         while(1) {
          $307 = (($$05$i6$i) + -1)|0;
          $308 = ((($$014$i7$i)) + 1|0);
          $309 = HEAP8[$$014$i7$i>>0]|0;
          $310 = ((($$023$i8$i)) + 1|0);
          HEAP8[$$023$i8$i>>0] = $309;
          $311 = ($307|0)==(0);
          if ($311) {
           break;
          } else {
           $$014$i7$i = $308;$$023$i8$i = $310;$$05$i6$i = $307;
          }
         }
         $$sum$i12 = (($304) + 11)|0;
         $scevgep$i10$i = (($p$091) + ($$sum$i12)|0);
         $phitmp$i = (($304) + 12)|0;
         $$02$lcssa$i12$i = $scevgep$i10$i;$313 = $phitmp$i;
        }
        $312 = (($p$091) + ($313)|0);
        HEAP8[$$02$lcssa$i12$i>>0] = 0;
        $$0$i23 = $312;
        break;
       }
      }
     } while(0);
     $334 = ((($node2$093)) + 24|0);
     $335 = ((($node2$093)) + 32|0);
     $336 = HEAP32[$335>>2]|0;
     $337 = ($336|0)==(1);
     if (!($337)) {
      $338 = HEAP32[$260>>2]|0;
      $339 = ($338|0)==(0);
      if ($339) {
       $p$1 = $$0$i23;
       break;
      }
      $340 = HEAP32[$334>>2]|0;
      $$014$i$i25 = $340;$$023$i$i26 = $$0$i23;$$05$i$i24 = $338;
      while(1) {
       $341 = (($$05$i$i24) + -1)|0;
       $342 = ((($$014$i$i25)) + 1|0);
       $343 = HEAP8[$$014$i$i25>>0]|0;
       $344 = ((($$023$i$i26)) + 1|0);
       HEAP8[$$023$i$i26>>0] = $343;
       $345 = ($341|0)==(0);
       if ($345) {
        break;
       } else {
        $$014$i$i25 = $342;$$023$i$i26 = $344;$$05$i$i24 = $341;
       }
      }
      $scevgep$i2$i = (($$0$i23) + ($338)|0);
      $p$1 = $scevgep$i2$i;
      break;
     }
     $346 = HEAP32[$334>>2]|0;
     $347 = HEAP32[$260>>2]|0;
     $348 = ($347|0)==(0);
     if ($348) {
      $p$1 = $$0$i23;
      break;
     }
     $349 = HEAP16[$346>>1]|0;
     if ((($349<<16>>16) == -257) | (($349<<16>>16) == -2)) {
      $350 = ((($346)) + 2|0);
      $351 = (($347) + -1)|0;
      $352 = ($351|0)==(0);
      if ($352) {
       $p$1 = $$0$i23;
       break;
      } else {
       $$01$ph8$i$i = $350;$$02$ph7$i$i = $351;
      }
     } else {
      $$01$ph8$i$i = $346;$$02$ph7$i$i = $347;
     }
     $353 = ($349<<16>>16)==(-2);
     $$015$i$i = $$01$ph8$i$i;$$06$i$i = $$0$i23;$$in$i$i = $$02$ph7$i$i;
     while(1) {
      $354 = (($$in$i$i) + -1)|0;
      $355 = ((($$015$i$i)) + 2|0);
      $356 = HEAP16[$$015$i$i>>1]|0;
      if ($353) {
       $357 = $356&65535;
       $358 = $357 << 8;
       $359 = $357 >>> 8;
       $360 = $358 | $359;
       $361 = $360&65535;
       $$0$i3$i$i = $361;
      } else {
       $$0$i3$i$i = $356;
      }
      $$0$i3$off$i$i = (($$0$i3$i$i) + -32)<<16>>16;
      $362 = ($$0$i3$off$i$i&65535)>(223);
      $363 = $$0$i3$i$i&255;
      $$$i$i29 = $362 ? 32 : $363;
      $$0$be$i$i = ((($$06$i$i)) + 1|0);
      HEAP8[$$06$i$i>>0] = $$$i$i29;
      $364 = ($354|0)==(0);
      if ($364) {
       break;
      } else {
       $$015$i$i = $355;$$06$i$i = $$0$be$i$i;$$in$i$i = $354;
      }
     }
     $scevgep$i$i30 = (($$0$i23) + ($$02$ph7$i$i)|0);
     $p$1 = $scevgep$i$i30;
    }
   } while(0);
   $464 = HEAP32[$node2$093>>2]|0;
   $465 = ($464|0)==(0|0);
   if ($465) {
    $p$2 = $p$1;
    break;
   } else {
    $node2$093 = $464;$p$091 = $p$1;
   }
  }
 }
 $466 = ($albumart_mime$1|0)==(0|0);
 if ($466) {
  $p$3 = $p$2;
 } else {
  $467 = HEAP32[$49>>2]|0;
  $468 = ((($2)) + 85732|0);
  $469 = HEAP32[$468>>2]|0;
  $470 = ($467|0)!=(0|0);
  $471 = ($469|0)!=(0);
  $or$cond3$i = $470 & $471;
  if ($or$cond3$i) {
   $472 = ((($p$2)) + 3|0);
   HEAP8[$472>>0] = 67;
   $473 = ((($p$2)) + 2|0);
   HEAP8[$473>>0] = 73;
   $474 = ((($p$2)) + 1|0);
   HEAP8[$474>>0] = 80;
   HEAP8[$p$2>>0] = 65;
   $475 = ((($p$2)) + 4|0);
   $476 = (_strlen(($albumart_mime$1|0))|0);
   $477 = (($469) + 4)|0;
   $478 = (($477) + ($476))|0;
   $479 = $478&255;
   $480 = ((($p$2)) + 7|0);
   HEAP8[$480>>0] = $479;
   $481 = $478 >>> 8;
   $482 = $481&255;
   $483 = ((($p$2)) + 6|0);
   HEAP8[$483>>0] = $482;
   $484 = $478 >>> 16;
   $485 = $484&255;
   $486 = ((($p$2)) + 5|0);
   HEAP8[$486>>0] = $485;
   $487 = $478 >>> 24;
   $488 = $487&255;
   HEAP8[$475>>0] = $488;
   $489 = ((($p$2)) + 8|0);
   $490 = ((($p$2)) + 9|0);
   HEAP8[$489>>0] = 0;
   $491 = ((($p$2)) + 10|0);
   HEAP8[$490>>0] = 0;
   $492 = ((($p$2)) + 11|0);
   HEAP8[$491>>0] = 0;
   $493 = HEAP8[$albumart_mime$1>>0]|0;
   $494 = ($493<<24>>24)==(0);
   if ($494) {
    $$06$lcssa$i = $492;
   } else {
    $$0511$i = $albumart_mime$1;$$0610$i = $492;$497 = $493;
    while(1) {
     $495 = ((($$0511$i)) + 1|0);
     $496 = ((($$0610$i)) + 1|0);
     HEAP8[$$0610$i>>0] = $497;
     $498 = HEAP8[$495>>0]|0;
     $499 = ($498<<24>>24)==(0);
     if ($499) {
      $$06$lcssa$i = $496;
      break;
     } else {
      $$0511$i = $495;$$0610$i = $496;$497 = $498;
     }
    }
   }
   $500 = ((($$06$lcssa$i)) + 1|0);
   HEAP8[$$06$lcssa$i>>0] = 0;
   $501 = ((($$06$lcssa$i)) + 2|0);
   HEAP8[$500>>0] = 0;
   HEAP8[$501>>0] = 0;
   $502 = ((($$06$lcssa$i)) + 3|0);
   $$048$i = $467;$$09$i = $469;$$17$i = $502;
   while(1) {
    $503 = (($$09$i) + -1)|0;
    $504 = ((($$048$i)) + 1|0);
    $505 = HEAP8[$$048$i>>0]|0;
    $506 = ((($$17$i)) + 1|0);
    HEAP8[$$17$i>>0] = $505;
    $507 = ($503|0)==(0);
    if ($507) {
     break;
    } else {
     $$048$i = $504;$$09$i = $503;$$17$i = $506;
    }
   }
   $508 = (($469) + 3)|0;
   $scevgep$i = (($$06$lcssa$i) + ($508)|0);
   $p$3 = $scevgep$i;
  } else {
   $p$3 = $p$2;
  }
 }
 $509 = $p$3;
 $510 = $buffer;
 $511 = (($tag_size$4) + ($510))|0;
 $512 = (($511) - ($509))|0;
 _memset(($p$3|0),0,($512|0))|0;
 $$0 = $tag_size$4;
 STACKTOP = sp;return ($$0|0);
}
function _id3tag_write_v2($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0, $$idx1 = 0, $$idx1$val = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $exitcond = 0, $i$03 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gfp)) + 288|0);
 $1 = HEAP32[$0>>2]|0;
 $$idx1 = ((($1)) + 85696|0);
 $$idx1$val = HEAP32[$$idx1>>2]|0;
 $2 = $$idx1$val & 5;
 $3 = ($2|0)==(1);
 if (!($3)) {
  $$0 = 0;
  return ($$0|0);
 }
 $4 = (_lame_get_id3v2_tag($gfp,0,0)|0);
 $5 = (_calloc($4,1)|0);
 $6 = ($5|0)==(0|0);
 if ($6) {
  $$0 = -1;
  return ($$0|0);
 }
 $7 = (_lame_get_id3v2_tag($gfp,$5,$4)|0);
 $8 = ($7>>>0)>($4>>>0);
 if ($8) {
  _free($5);
  $$0 = -1;
  return ($$0|0);
 }
 $9 = ($7|0)==(0);
 if (!($9)) {
  $i$03 = 0;
  while(1) {
   $10 = (($5) + ($i$03)|0);
   $11 = HEAP8[$10>>0]|0;
   _add_dummy_byte($1,$11,1);
   $12 = (($i$03) + 1)|0;
   $exitcond = ($12|0)==($7|0);
   if ($exitcond) {
    break;
   } else {
    $i$03 = $12;
   }
  }
 }
 _free($5);
 $$0 = $7;
 return ($$0|0);
}
function _lame_get_id3v1_tag($gfp,$buffer,$size) {
 $gfp = $gfp|0;
 $buffer = $buffer|0;
 $size = $size|0;
 var $$0 = 0, $$0$lcssa$i = 0, $$0$lcssa$i10 = 0, $$0$lcssa$i19 = 0, $$0$lcssa$i28 = 0, $$0$lcssa$i37 = 0, $$0$ph8$i = 0, $$0$ph8$i13 = 0, $$0$ph8$i22 = 0, $$0$ph8$i31 = 0, $$0$ph8$i4 = 0, $$02$ph7$i = 0, $$02$ph7$i14 = 0, $$02$ph7$i23 = 0, $$02$ph7$i32 = 0, $$02$ph7$i5 = 0, $$05$i = 0, $$05$i$lcssa = 0, $$05$i17 = 0, $$05$i17$lcssa = 0;
 var $$05$i212 = 0, $$05$i26 = 0, $$05$i26$lcssa = 0, $$05$i35 = 0, $$05$i35$lcssa = 0, $$05$i8 = 0, $$05$i8$lcssa = 0, $$idx2 = 0, $$idx2$val = 0, $$in$i = 0, $$in$i12 = 0, $$in$i21 = 0, $$in$i3 = 0, $$in$i30 = 0, $$in10$i = 0, $$in10$i16 = 0, $$in10$i25 = 0, $$in10$i34 = 0, $$in10$i7 = 0, $$lcssa = 0;
 var $$lcssa214 = 0, $$lcssa218 = 0, $$lcssa220 = 0, $$lcssa224 = 0, $$lcssa226 = 0, $$lcssa230 = 0, $$lcssa232 = 0, $$lcssa236 = 0, $$lcssa238 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 var $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0;
 var $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0;
 var $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0;
 var $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $9 = 0, $or$cond = 0, $p$0 = 0, $vararg_buffer = 0, $year = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $vararg_buffer = sp;
 $year = sp + 4|0;
 $0 = ($gfp|0)==(0|0);
 if ($0) {
  $$0 = 0;
  STACKTOP = sp;return ($$0|0);
 }
 $1 = ($size>>>0)<(128);
 if ($1) {
  $$0 = 128;
  STACKTOP = sp;return ($$0|0);
 }
 $2 = ((($gfp)) + 288|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)==(0|0);
 $5 = ($buffer|0)==(0|0);
 $or$cond = $5 | $4;
 if ($or$cond) {
  $$0 = 0;
  STACKTOP = sp;return ($$0|0);
 }
 $$idx2 = ((($3)) + 85696|0);
 $$idx2$val = HEAP32[$$idx2>>2]|0;
 $6 = $$idx2$val & 9;
 $7 = ($6|0)==(1);
 if (!($7)) {
  $$0 = 0;
  STACKTOP = sp;return ($$0|0);
 }
 $8 = $$idx2$val << 1;
 $9 = $8 & 32;
 $10 = ((($buffer)) + 1|0);
 HEAP8[$buffer>>0] = 84;
 $11 = ((($buffer)) + 2|0);
 HEAP8[$10>>0] = 65;
 $12 = ((($buffer)) + 3|0);
 HEAP8[$11>>0] = 71;
 $13 = ((($3)) + 85704|0);
 $14 = HEAP32[$13>>2]|0;
 $15 = $9&255;
 $$0$ph8$i31 = $12;$$02$ph7$i32 = $14;$$in$i30 = 30;
 L13: while(1) {
  $16 = ($$02$ph7$i32|0)==(0|0);
  $$05$i35 = $$0$ph8$i31;$$in10$i34 = $$in$i30;
  while(1) {
   $17 = (($$in10$i34) + -1)|0;
   if (!($16)) {
    $18 = HEAP8[$$02$ph7$i32>>0]|0;
    $19 = ($18<<24>>24)==(0);
    if (!($19)) {
     $$05$i35$lcssa = $$05$i35;$$lcssa236 = $17;$$lcssa238 = $18;
     break;
    }
   }
   $23 = ((($$05$i35)) + 1|0);
   HEAP8[$$05$i35>>0] = $15;
   $24 = ($17|0)==(0);
   if ($24) {
    $$0$lcssa$i37 = $23;
    break L13;
   } else {
    $$05$i35 = $23;$$in10$i34 = $17;
   }
  }
  $20 = ((($$02$ph7$i32)) + 1|0);
  $21 = ((($$05$i35$lcssa)) + 1|0);
  HEAP8[$$05$i35$lcssa>>0] = $$lcssa238;
  $22 = ($$lcssa236|0)==(0);
  if ($22) {
   $$0$lcssa$i37 = $21;
   break;
  } else {
   $$0$ph8$i31 = $21;$$02$ph7$i32 = $20;$$in$i30 = $$lcssa236;
  }
 }
 $25 = ((($3)) + 85708|0);
 $26 = HEAP32[$25>>2]|0;
 $$0$ph8$i22 = $$0$lcssa$i37;$$02$ph7$i23 = $26;$$in$i21 = 30;
 L22: while(1) {
  $27 = ($$02$ph7$i23|0)==(0|0);
  $$05$i26 = $$0$ph8$i22;$$in10$i25 = $$in$i21;
  while(1) {
   $28 = (($$in10$i25) + -1)|0;
   if (!($27)) {
    $29 = HEAP8[$$02$ph7$i23>>0]|0;
    $30 = ($29<<24>>24)==(0);
    if (!($30)) {
     $$05$i26$lcssa = $$05$i26;$$lcssa230 = $28;$$lcssa232 = $29;
     break;
    }
   }
   $34 = ((($$05$i26)) + 1|0);
   HEAP8[$$05$i26>>0] = $15;
   $35 = ($28|0)==(0);
   if ($35) {
    $$0$lcssa$i28 = $34;
    break L22;
   } else {
    $$05$i26 = $34;$$in10$i25 = $28;
   }
  }
  $31 = ((($$02$ph7$i23)) + 1|0);
  $32 = ((($$05$i26$lcssa)) + 1|0);
  HEAP8[$$05$i26$lcssa>>0] = $$lcssa232;
  $33 = ($$lcssa230|0)==(0);
  if ($33) {
   $$0$lcssa$i28 = $32;
   break;
  } else {
   $$0$ph8$i22 = $32;$$02$ph7$i23 = $31;$$in$i21 = $$lcssa230;
  }
 }
 $36 = ((($3)) + 85712|0);
 $37 = HEAP32[$36>>2]|0;
 $$0$ph8$i13 = $$0$lcssa$i28;$$02$ph7$i14 = $37;$$in$i12 = 30;
 L31: while(1) {
  $38 = ($$02$ph7$i14|0)==(0|0);
  $$05$i17 = $$0$ph8$i13;$$in10$i16 = $$in$i12;
  while(1) {
   $39 = (($$in10$i16) + -1)|0;
   if (!($38)) {
    $40 = HEAP8[$$02$ph7$i14>>0]|0;
    $41 = ($40<<24>>24)==(0);
    if (!($41)) {
     $$05$i17$lcssa = $$05$i17;$$lcssa224 = $39;$$lcssa226 = $40;
     break;
    }
   }
   $45 = ((($$05$i17)) + 1|0);
   HEAP8[$$05$i17>>0] = $15;
   $46 = ($39|0)==(0);
   if ($46) {
    $$0$lcssa$i19 = $45;
    break L31;
   } else {
    $$05$i17 = $45;$$in10$i16 = $39;
   }
  }
  $42 = ((($$02$ph7$i14)) + 1|0);
  $43 = ((($$05$i17$lcssa)) + 1|0);
  HEAP8[$$05$i17$lcssa>>0] = $$lcssa226;
  $44 = ($$lcssa224|0)==(0);
  if ($44) {
   $$0$lcssa$i19 = $43;
   break;
  } else {
   $$0$ph8$i13 = $43;$$02$ph7$i14 = $42;$$in$i12 = $$lcssa224;
  }
 }
 $47 = ((($3)) + 85700|0);
 $48 = HEAP32[$47>>2]|0;
 HEAP32[$vararg_buffer>>2] = $48;
 (_sprintf($year,6552,$vararg_buffer)|0);
 $49 = HEAP32[$47>>2]|0;
 $50 = ($49|0)!=(0);
 $51 = $50 ? $year : 0;
 $$0$ph8$i4 = $$0$lcssa$i19;$$02$ph7$i5 = $51;$$in$i3 = 4;
 L40: while(1) {
  $52 = ($$02$ph7$i5|0)==(0|0);
  $$05$i8 = $$0$ph8$i4;$$in10$i7 = $$in$i3;
  while(1) {
   $53 = (($$in10$i7) + -1)|0;
   if (!($52)) {
    $54 = HEAP8[$$02$ph7$i5>>0]|0;
    $55 = ($54<<24>>24)==(0);
    if (!($55)) {
     $$05$i8$lcssa = $$05$i8;$$lcssa218 = $53;$$lcssa220 = $54;
     break;
    }
   }
   $59 = ((($$05$i8)) + 1|0);
   HEAP8[$$05$i8>>0] = $15;
   $60 = ($53|0)==(0);
   if ($60) {
    $$0$lcssa$i10 = $59;
    break L40;
   } else {
    $$05$i8 = $59;$$in10$i7 = $53;
   }
  }
  $56 = ((($$02$ph7$i5)) + 1|0);
  $57 = ((($$05$i8$lcssa)) + 1|0);
  HEAP8[$$05$i8$lcssa>>0] = $$lcssa220;
  $58 = ($$lcssa218|0)==(0);
  if ($58) {
   $$0$lcssa$i10 = $57;
   break;
  } else {
   $$0$ph8$i4 = $57;$$02$ph7$i5 = $56;$$in$i3 = $$lcssa218;
  }
 }
 $61 = ((($3)) + 85716|0);
 $62 = HEAP32[$61>>2]|0;
 $63 = ((($3)) + 85720|0);
 $64 = HEAP32[$63>>2]|0;
 $65 = ($64|0)!=(0);
 $66 = $65 ? 28 : 30;
 $$0$ph8$i = $$0$lcssa$i10;$$02$ph7$i = $62;$$in$i = $66;
 L49: while(1) {
  $67 = ($$02$ph7$i|0)==(0|0);
  $$05$i = $$0$ph8$i;$$in10$i = $$in$i;
  while(1) {
   $68 = (($$in10$i) + -1)|0;
   if (!($67)) {
    $69 = HEAP8[$$02$ph7$i>>0]|0;
    $70 = ($69<<24>>24)==(0);
    if (!($70)) {
     $$05$i$lcssa = $$05$i;$$lcssa = $68;$$lcssa214 = $69;
     break;
    }
   }
   $74 = ((($$05$i)) + 1|0);
   HEAP8[$$05$i>>0] = $15;
   $75 = ($68|0)==(0);
   if ($75) {
    $$0$lcssa$i = $74;$$05$i212 = $$05$i;
    break L49;
   } else {
    $$05$i = $74;$$in10$i = $68;
   }
  }
  $71 = ((($$02$ph7$i)) + 1|0);
  $72 = ((($$05$i$lcssa)) + 1|0);
  HEAP8[$$05$i$lcssa>>0] = $$lcssa214;
  $73 = ($$lcssa|0)==(0);
  if ($73) {
   $$0$lcssa$i = $72;$$05$i212 = $$05$i$lcssa;
   break;
  } else {
   $$0$ph8$i = $72;$$02$ph7$i = $71;$$in$i = $$lcssa;
  }
 }
 $76 = HEAP32[$63>>2]|0;
 $77 = ($76|0)==(0);
 if ($77) {
  $p$0 = $$0$lcssa$i;
 } else {
  $78 = ((($$05$i212)) + 2|0);
  HEAP8[$$0$lcssa$i>>0] = 0;
  $79 = HEAP32[$63>>2]|0;
  $80 = $79&255;
  $81 = ((($$05$i212)) + 3|0);
  HEAP8[$78>>0] = $80;
  $p$0 = $81;
 }
 $82 = ((($3)) + 85724|0);
 $83 = HEAP32[$82>>2]|0;
 $84 = $83&255;
 HEAP8[$p$0>>0] = $84;
 $$0 = 128;
 STACKTOP = sp;return ($$0|0);
}
function _id3tag_write_v1($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $exitcond = 0, $i$01 = 0, $tag = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128|0;
 $tag = sp;
 $0 = ((($gfp)) + 288|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = (_lame_get_id3v1_tag($gfp,$tag,128)|0);
 $3 = (($2) + -1)|0;
 $4 = ($3>>>0)>(127);
 if ($4) {
  $$0 = 0;
  STACKTOP = sp;return ($$0|0);
 } else {
  $i$01 = 0;
 }
 while(1) {
  $5 = (($tag) + ($i$01)|0);
  $6 = HEAP8[$5>>0]|0;
  _add_dummy_byte($1,$6,1);
  $7 = (($i$01) + 1)|0;
  $exitcond = ($7|0)==($2|0);
  if ($exitcond) {
   $$0 = $2;
   break;
  } else {
   $i$01 = $7;
  }
 }
 STACKTOP = sp;return ($$0|0);
}
function _id3v2_add_latin1($gfp,$frame_id,$lang,$desc,$text) {
 $gfp = $gfp|0;
 $frame_id = $frame_id|0;
 $lang = $lang|0;
 $desc = $desc|0;
 $text = $text|0;
 var $$0 = 0, $$0$i = 0, $$0$i2 = 0, $$0$i9 = 0, $$in$i = 0, $$lcssa = 0, $$lcssa84 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 var $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0;
 var $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0;
 var $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0;
 var $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0;
 var $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $i$0$lcssa$ph$i = 0, $i$01$i = 0, $n$0$i = 0, $n$0$i$lcssa = 0, $n$0$i7 = 0, $n$0$i7$lcssa = 0, $node$0 = 0, $node$0$i = 0, $node$0$i14 = 0, $node$0$i14$us = 0, $node$0$us = 0;
 var $node$01$i = 0, $node$01$i11 = 0, $node$01$i11$us = 0, $node$02$i = 0, $node$02$i12 = 0, $node$02$i12$us = 0, $node$1 = 0, $node$2 = 0, $scevgep$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($gfp|0)==(0|0);
 if ($0) {
  $$0 = -255;
  return ($$0|0);
 }
 $1 = ((($gfp)) + 288|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = ($2|0)==(0|0);
 if ($3) {
  $$0 = -255;
  return ($$0|0);
 }
 $4 = ((($2)) + 85744|0);
 $node$01$i = HEAP32[$4>>2]|0;
 $5 = ($node$01$i|0)==(0|0);
 L7: do {
  if ($5) {
   $$0$i = 0;
  } else {
   $node$02$i = $node$01$i;
   while(1) {
    $6 = ((($node$02$i)) + 4|0);
    $7 = HEAP32[$6>>2]|0;
    $8 = ($7|0)==($frame_id|0);
    if ($8) {
     $$0$i = $node$02$i;
     break L7;
    }
    $node$0$i = HEAP32[$node$02$i>>2]|0;
    $9 = ($node$0$i|0)==(0|0);
    if ($9) {
     $$0$i = 0;
     break;
    } else {
     $node$02$i = $node$0$i;
    }
   }
  }
 } while(0);
 L12: do {
  if ((($frame_id|0) == 1347570006) | (($frame_id|0) == 1196575044) | (($frame_id|0) == 1162756946) | (($frame_id|0) == 1279872587) | (($frame_id|0) == 1095061059) | (($frame_id|0) == 1346588244) | (($frame_id|0) == 1195724610) | (($frame_id|0) == 1095780675) | (($frame_id|0) == 1398361172) | (($frame_id|0) == 1129270605) | (($frame_id|0) == 1465407576) | (($frame_id|0) == 1415075928)) {
   $10 = ($$0$i|0)==(0|0);
   if ($10) {
    label = 25;
   } else {
    $11 = ($desc|0)==(0|0);
    if ($11) {
     $node$0$us = $$0$i;
     L16: while(1) {
      $12 = ((($node$0$us)) + 8|0);
      $13 = (_isSameLang($12,$lang)|0);
      $14 = ($13|0)==(0);
      if (!($14)) {
       $15 = ((($node$0$us)) + 16|0);
       $16 = HEAP32[$15>>2]|0;
       $17 = ($16|0)==(0);
       if ($17) {
        $node$2 = $node$0$us;
        break L12;
       }
      }
      $node$01$i11$us = HEAP32[$node$0$us>>2]|0;
      $18 = ($node$01$i11$us|0)==(0|0);
      if ($18) {
       label = 25;
       break L12;
      } else {
       $node$02$i12$us = $node$01$i11$us;
      }
      while(1) {
       $19 = ((($node$02$i12$us)) + 4|0);
       $20 = HEAP32[$19>>2]|0;
       $21 = ($20|0)==($frame_id|0);
       if ($21) {
        $node$0$us = $node$02$i12$us;
        continue L16;
       }
       $node$0$i14$us = HEAP32[$node$02$i12$us>>2]|0;
       $22 = ($node$0$i14$us|0)==(0|0);
       if ($22) {
        label = 25;
        break L12;
       } else {
        $node$02$i12$us = $node$0$i14$us;
       }
      }
     }
    } else {
     $node$0 = $$0$i;
    }
    L24: while(1) {
     $23 = ((($node$0)) + 8|0);
     $24 = (_isSameLang($23,$lang)|0);
     $25 = ($24|0)==(0);
     L26: do {
      if (!($25)) {
       $26 = ((($node$0)) + 20|0);
       $27 = HEAP32[$26>>2]|0;
       $28 = ($27|0)==(1);
       $29 = ((($node$0)) + 16|0);
       $30 = HEAP32[$29>>2]|0;
       $31 = ($30|0)==(0);
       if ($28) {
        if ($31) {
         $node$2 = $node$0;
         break L12;
        } else {
         break;
        }
       }
       if ($31) {
        $node$2 = $node$0;
        break L12;
       }
       $32 = ((($node$0)) + 12|0);
       $33 = HEAP32[$32>>2]|0;
       $i$01$i = 0;
       while(1) {
        $36 = (($33) + ($i$01$i)|0);
        $37 = HEAP8[$36>>0]|0;
        $38 = (($desc) + ($i$01$i)|0);
        $39 = HEAP8[$38>>0]|0;
        $40 = ($37<<24>>24)==($39<<24>>24);
        $34 = (($i$01$i) + 1)|0;
        if (!($40)) {
         break L26;
        }
        $35 = ($34>>>0)<($30>>>0);
        if ($35) {
         $i$01$i = $34;
        } else {
         $node$1 = $node$0;
         label = 24;
         break L12;
        }
       }
      }
     } while(0);
     $41 = ($node$0|0)==(0|0);
     $$in$i = $41 ? $4 : $node$0;
     $node$01$i11 = HEAP32[$$in$i>>2]|0;
     $42 = ($node$01$i11|0)==(0|0);
     if ($42) {
      label = 25;
      break L12;
     } else {
      $node$02$i12 = $node$01$i11;
     }
     while(1) {
      $43 = ((($node$02$i12)) + 4|0);
      $44 = HEAP32[$43>>2]|0;
      $45 = ($44|0)==($frame_id|0);
      if ($45) {
       $node$0 = $node$02$i12;
       continue L24;
      }
      $node$0$i14 = HEAP32[$node$02$i12>>2]|0;
      $46 = ($node$0$i14|0)==(0|0);
      if ($46) {
       label = 25;
       break L12;
      } else {
       $node$02$i12 = $node$0$i14;
      }
     }
    }
   }
  } else {
   $node$1 = $$0$i;
   label = 24;
  }
 } while(0);
 if ((label|0) == 24) {
  $47 = ($node$1|0)==(0|0);
  if ($47) {
   label = 25;
  } else {
   $node$2 = $node$1;
  }
 }
 if ((label|0) == 25) {
  $48 = (_calloc(1,36)|0);
  $49 = ($48|0)==(0|0);
  if ($49) {
   $$0 = -254;
   return ($$0|0);
  }
  $50 = ((($2)) + 85748|0);
  $51 = HEAP32[$50>>2]|0;
  $52 = ($51|0)==(0|0);
  if ($52) {
   label = 28;
  } else {
   $53 = HEAP32[$4>>2]|0;
   $54 = ($53|0)==(0|0);
   if ($54) {
    label = 28;
   } else {
    HEAP32[$51>>2] = $48;
   }
  }
  if ((label|0) == 28) {
   HEAP32[$4>>2] = $48;
  }
  HEAP32[$50>>2] = $48;
  $node$2 = $48;
 }
 $55 = ((($node$2)) + 4|0);
 HEAP32[$55>>2] = $frame_id;
 $56 = ((($node$2)) + 8|0);
 $57 = ($lang|0)==(0|0);
 do {
  if ($57) {
   label = 33;
  } else {
   $58 = HEAP8[$lang>>0]|0;
   $59 = ($58<<24>>24)==(0);
   if ($59) {
    label = 33;
   } else {
    HEAP8[$56>>0] = $58;
    $66 = HEAP8[$lang>>0]|0;
    $67 = ($66<<24>>24)==(0);
    if ($67) {
     $i$0$lcssa$ph$i = 1;
    } else {
     $68 = ((($lang)) + 1|0);
     $69 = HEAP8[$68>>0]|0;
     $70 = ((($node$2)) + 9|0);
     HEAP8[$70>>0] = $69;
     $71 = HEAP8[$lang>>0]|0;
     $72 = ($71<<24>>24)==(0);
     if ($72) {
      $i$0$lcssa$ph$i = 2;
     } else {
      $62 = ((($lang)) + 2|0);
      $63 = HEAP8[$62>>0]|0;
      $64 = ((($node$2)) + 10|0);
      HEAP8[$64>>0] = $63;
      break;
     }
    }
    $scevgep$i = (((($node$2)) + 8|0) + ($i$0$lcssa$ph$i)|0);
    $65 = $i$0$lcssa$ph$i ^ 3;
    _memset(($scevgep$i|0),32,($65|0))|0;
   }
  }
 } while(0);
 if ((label|0) == 33) {
  HEAP8[$56>>0] = 88;
  $60 = ((($node$2)) + 9|0);
  HEAP8[$60>>0] = 88;
  $61 = ((($node$2)) + 10|0);
  HEAP8[$61>>0] = 88;
 }
 $73 = ((($node$2)) + 12|0);
 $74 = HEAP32[$73>>2]|0;
 _free($74);
 HEAP32[$73>>2] = 0;
 $75 = ($desc|0)==(0|0);
 if ($75) {
  $$0$i9 = 0;
 } else {
  $n$0$i7 = 0;
  while(1) {
   $76 = (($desc) + ($n$0$i7)|0);
   $77 = HEAP8[$76>>0]|0;
   $78 = ($77<<24>>24)==(0);
   $79 = (($n$0$i7) + 1)|0;
   if ($78) {
    $$lcssa84 = $79;$n$0$i7$lcssa = $n$0$i7;
    break;
   } else {
    $n$0$i7 = $79;
   }
  }
  $80 = ($n$0$i7$lcssa|0)==(0);
  if ($80) {
   $$0$i9 = 0;
  } else {
   $81 = (_calloc($$lcssa84,1)|0);
   HEAP32[$73>>2] = $81;
   $82 = ($81|0)==(0|0);
   if ($82) {
    $$0$i9 = 0;
   } else {
    _memcpy(($81|0),($desc|0),($n$0$i7$lcssa|0))|0;
    $83 = (($81) + ($n$0$i7$lcssa)|0);
    HEAP8[$83>>0] = 0;
    $$0$i9 = $n$0$i7$lcssa;
   }
  }
 }
 $84 = ((($node$2)) + 16|0);
 HEAP32[$84>>2] = $$0$i9;
 $85 = ((($node$2)) + 20|0);
 HEAP32[$85>>2] = 0;
 $86 = ((($node$2)) + 24|0);
 $87 = HEAP32[$86>>2]|0;
 _free($87);
 HEAP32[$86>>2] = 0;
 $88 = ($text|0)==(0|0);
 if ($88) {
  $$0$i2 = 0;
 } else {
  $n$0$i = 0;
  while(1) {
   $89 = (($text) + ($n$0$i)|0);
   $90 = HEAP8[$89>>0]|0;
   $91 = ($90<<24>>24)==(0);
   $92 = (($n$0$i) + 1)|0;
   if ($91) {
    $$lcssa = $92;$n$0$i$lcssa = $n$0$i;
    break;
   } else {
    $n$0$i = $92;
   }
  }
  $93 = ($n$0$i$lcssa|0)==(0);
  if ($93) {
   $$0$i2 = 0;
  } else {
   $94 = (_calloc($$lcssa,1)|0);
   HEAP32[$86>>2] = $94;
   $95 = ($94|0)==(0|0);
   if ($95) {
    $$0$i2 = 0;
   } else {
    _memcpy(($94|0),($text|0),($n$0$i$lcssa|0))|0;
    $96 = (($94) + ($n$0$i$lcssa)|0);
    HEAP8[$96>>0] = 0;
    $$0$i2 = $n$0$i$lcssa;
   }
  }
 }
 $97 = ((($node$2)) + 28|0);
 HEAP32[$97>>2] = $$0$i2;
 $98 = ((($node$2)) + 32|0);
 HEAP32[$98>>2] = 0;
 $99 = ((($2)) + 85696|0);
 $100 = HEAP32[$99>>2]|0;
 $101 = $100 | 3;
 HEAP32[$99>>2] = $101;
 $$0 = 0;
 return ($$0|0);
}
function _isSameLang($l1,$l2) {
 $l1 = $l1|0;
 $l2 = $l2|0;
 var $$ = 0, $$$1 = 0, $$$2 = 0, $$5 = 0, $$mask = 0, $$mask$1 = 0, $$mask$2 = 0, $$unshifted = 0, $$unshifted$1 = 0, $$unshifted$2 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 var $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0;
 var $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $b$0 = 0, $b$0$1 = 0, $b$0$2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($l2|0)==(0|0);
 if ($0) {
  $11 = 88;$23 = 88;$35 = 88;
 } else {
  $1 = HEAP8[$l2>>0]|0;
  $2 = ($1<<24>>24)==(0);
  if ($2) {
   $11 = 88;$23 = 88;$35 = 88;
  } else {
   $3 = ((($l2)) + 1|0);
   $4 = HEAP8[$3>>0]|0;
   $5 = ((($l2)) + 2|0);
   $6 = HEAP8[$5>>0]|0;
   $11 = $1;$23 = $4;$35 = $6;
  }
 }
 $7 = HEAP8[$l1>>0]|0;
 $8 = $7 << 24 >> 24;
 $9 = (_tolower($8)|0);
 $10 = $11 << 24 >> 24;
 $12 = (_tolower($10)|0);
 $13 = $9&255;
 $14 = ($13<<24>>24)<(32);
 $$ = $14 ? 32 : $9;
 $15 = $12&255;
 $16 = ($15<<24>>24)<(32);
 $b$0 = $16 ? 32 : $12;
 $$unshifted = $b$0 ^ $$;
 $$mask = $$unshifted & 255;
 $17 = ($$mask|0)==(0);
 if (!($17)) {
  return 0;
 }
 $18 = ((($l1)) + 1|0);
 $19 = HEAP8[$18>>0]|0;
 $20 = $19 << 24 >> 24;
 $21 = (_tolower($20)|0);
 $22 = $23 << 24 >> 24;
 $24 = (_tolower($22)|0);
 $25 = $21&255;
 $26 = ($25<<24>>24)<(32);
 $$$1 = $26 ? 32 : $21;
 $27 = $24&255;
 $28 = ($27<<24>>24)<(32);
 $b$0$1 = $28 ? 32 : $24;
 $$unshifted$1 = $b$0$1 ^ $$$1;
 $$mask$1 = $$unshifted$1 & 255;
 $29 = ($$mask$1|0)==(0);
 if ($29) {
  $30 = ((($l1)) + 2|0);
  $31 = HEAP8[$30>>0]|0;
  $32 = $31 << 24 >> 24;
  $33 = (_tolower($32)|0);
  $34 = $35 << 24 >> 24;
  $36 = (_tolower($34)|0);
  $37 = $33&255;
  $38 = ($37<<24>>24)<(32);
  $$$2 = $38 ? 32 : $33;
  $39 = $36&255;
  $40 = ($39<<24>>24)<(32);
  $b$0$2 = $40 ? 32 : $36;
  $$unshifted$2 = $b$0$2 ^ $$$2;
  $$mask$2 = $$unshifted$2 & 255;
  $41 = ($$mask$2|0)==(0);
  $$5 = $41&1;
  return ($$5|0);
 } else {
  return 0;
 }
 return (0)|0;
}
function _is_lame_global_flags_valid($gfp) {
 $gfp = $gfp|0;
 var $$ = 0, $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($gfp|0)==(0|0);
 if ($0) {
  $$0 = 0;
  return ($$0|0);
 }
 $1 = HEAP32[$gfp>>2]|0;
 $2 = ($1|0)==(-487877);
 $$ = $2&1;
 $$0 = $$;
 return ($$0|0);
}
function _lame_init_params($gfp) {
 $gfp = $gfp|0;
 var $$ = 0, $$$i = 0, $$0 = 0, $$0$i13 = 0, $$1$i = 0, $$10 = 0, $$11 = 0, $$12 = 0, $$30 = 0, $$5 = 0, $$6 = 0, $$9 = 0, $$lcssa = 0, $$lcssa113 = 0.0, $$lcssa114 = 0.0, $$phi$trans$insert56 = 0, $$phi$trans$insert64 = 0, $$phi$trans$insert77 = 0, $$pr$i = 0.0, $$pre = 0;
 var $$pre$i = 0.0, $$pre57 = 0, $$pre58 = 0, $$pre59 = 0.0, $$pre60 = 0, $$pre63 = 0, $$pre65 = 0, $$pre67 = 0, $$pre69 = 0, $$pre69$1 = 0, $$pre69$10 = 0, $$pre69$11 = 0, $$pre69$12 = 0, $$pre69$13 = 0, $$pre69$14 = 0, $$pre69$15 = 0, $$pre69$16 = 0, $$pre69$17 = 0, $$pre69$2 = 0, $$pre69$3 = 0;
 var $$pre69$4 = 0, $$pre69$5 = 0, $$pre69$6 = 0, $$pre69$7 = 0, $$pre69$8 = 0, $$pre69$9 = 0, $$pre70 = 0, $$pre70$1 = 0, $$pre70$10 = 0, $$pre70$11 = 0, $$pre70$12 = 0, $$pre70$13 = 0, $$pre70$14 = 0, $$pre70$15 = 0, $$pre70$16 = 0, $$pre70$17 = 0, $$pre70$2 = 0, $$pre70$3 = 0, $$pre70$4 = 0, $$pre70$5 = 0;
 var $$pre70$6 = 0, $$pre70$7 = 0, $$pre70$8 = 0, $$pre70$9 = 0, $$pre72 = 0, $$pre74 = 0, $$pre75 = 0, $$pre78 = 0, $$sink = 0.0, $$sink54 = 0, $$sink55 = 0, $$storemerge = 0, $$storemerge91 = 0, $$suggested_samplefreq$0$i = 0, $$suggested_samplefreq$2$i = 0, $$suggested_samplefreq$4$i = 0, $$suggested_samplefreq$6$i = 0, $0 = 0, $1 = 0, $10 = 0;
 var $100 = 0, $1000 = 0, $1001 = 0, $1002 = 0, $1003 = 0, $1004 = 0, $1005 = 0, $1006 = 0, $1007 = 0, $1008 = 0, $1009 = 0, $101 = 0, $1010 = 0, $1011 = 0, $1012 = 0, $1013 = 0, $1014 = 0, $1015 = 0, $1016 = 0, $1017 = 0;
 var $1018 = 0, $1019 = 0, $102 = 0, $1020 = 0, $1021 = 0, $1022 = 0, $1023 = 0, $1024 = 0, $1025 = 0, $1026 = 0, $1027 = 0, $1028 = 0, $1029 = 0, $103 = 0, $1030 = 0, $1031 = 0, $1032 = 0, $1033 = 0, $1034 = 0, $1035 = 0;
 var $1036 = 0, $1037 = 0, $1038 = 0, $1039 = 0, $104 = 0, $1040 = 0, $1041 = 0, $1042 = 0, $1043 = 0, $1044 = 0, $1045 = 0, $1046 = 0, $1047 = 0, $1048 = 0, $1049 = 0, $105 = 0, $1050 = 0, $1051 = 0, $1052 = 0, $1053 = 0;
 var $1054 = 0, $1055 = 0, $1056 = 0, $1057 = 0, $1058 = 0, $1059 = 0, $106 = 0, $1060 = 0, $1061 = 0.0, $1062 = 0.0, $1063 = 0.0, $1064 = 0.0, $1065 = 0.0, $1066 = 0, $1067 = 0, $1068 = 0, $1069 = 0, $107 = 0, $1070 = 0, $1071 = 0;
 var $1072 = 0, $1073 = 0, $1074 = 0, $1075 = 0, $1076 = 0.0, $1077 = 0, $1078 = 0, $1079 = 0, $108 = 0, $1080 = 0, $1081 = 0, $1082 = 0, $1083 = 0.0, $1084 = 0, $1085 = 0, $1086 = 0, $1087 = 0.0, $1088 = 0, $1089 = 0, $109 = 0;
 var $1090 = 0, $1091 = 0, $1092 = 0, $1093 = 0, $1094 = 0, $1095 = 0, $1096 = 0, $1097 = 0, $1098 = 0, $1099 = 0.0, $11 = 0, $110 = 0, $1100 = 0.0, $1101 = 0, $1102 = 0.0, $1103 = 0.0, $1104 = 0, $1105 = 0, $1106 = 0, $1107 = 0;
 var $1108 = 0, $1109 = 0, $111 = 0, $1110 = 0, $1111 = 0, $1112 = 0, $1113 = 0, $1114 = 0, $1115 = 0, $1116 = 0, $1117 = 0, $1118 = 0, $1119 = 0, $112 = 0, $1120 = 0, $1121 = 0, $1122 = 0, $1123 = 0, $1124 = 0, $1125 = 0;
 var $1126 = 0, $1127 = 0, $1128 = 0, $1129 = 0, $113 = 0, $1130 = 0, $1131 = 0, $1132 = 0.0, $1133 = 0, $1134 = 0, $1135 = 0.0, $1136 = 0.0, $1137 = 0, $1138 = 0, $1139 = 0.0, $114 = 0, $1140 = 0, $1141 = 0, $1142 = 0.0, $1143 = 0.0;
 var $1144 = 0, $1145 = 0, $1146 = 0.0, $1147 = 0, $1148 = 0, $1149 = 0.0, $115 = 0, $1150 = 0.0, $1151 = 0, $1152 = 0, $1153 = 0.0, $1154 = 0, $1155 = 0, $1156 = 0.0, $1157 = 0.0, $1158 = 0.0, $1159 = 0, $116 = 0, $1160 = 0.0, $1161 = 0;
 var $1162 = 0.0, $1163 = 0.0, $1164 = 0, $1165 = 0.0, $1166 = 0.0, $1167 = 0, $1168 = 0, $1169 = 0, $117 = 0, $1170 = 0, $1171 = 0.0, $1172 = 0.0, $1173 = 0, $1174 = 0, $1175 = 0, $1176 = 0, $1177 = 0, $1178 = 0, $1179 = 0, $118 = 0;
 var $1180 = 0, $1181 = 0, $1182 = 0, $1183 = 0, $1184 = 0, $1185 = 0, $1186 = 0, $1187 = 0, $1188 = 0, $1189 = 0, $119 = 0, $1190 = 0, $1191 = 0, $1192 = 0, $1193 = 0, $1194 = 0, $1195 = 0, $1196 = 0, $1197 = 0, $1198 = 0;
 var $1199 = 0, $12 = 0, $120 = 0, $1200 = 0, $1201 = 0, $1202 = 0, $1203 = 0, $1204 = 0, $1205 = 0, $1206 = 0, $1207 = 0, $1208 = 0, $1209 = 0, $121 = 0, $1210 = 0, $122 = 0, $123 = 0, $124 = 0.0, $125 = 0.0, $126 = 0;
 var $127 = 0.0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0.0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0.0, $139 = 0.0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0;
 var $145 = 0, $146 = 0, $147 = 0.0, $148 = 0.0, $149 = 0.0, $15 = 0, $150 = 0.0, $151 = 0.0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0;
 var $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0;
 var $181 = 0, $182 = 0.0, $183 = 0, $184 = 0.0, $185 = 0.0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0.0, $193 = 0, $194 = 0.0, $195 = 0.0, $196 = 0, $197 = 0.0, $198 = 0.0, $199 = 0.0;
 var $2 = 0, $20 = 0, $200 = 0, $201 = 0.0, $202 = 0.0, $203 = 0.0, $204 = 0, $205 = 0, $206 = 0.0, $207 = 0, $208 = 0, $209 = 0.0, $21 = 0, $210 = 0, $211 = 0.0, $212 = 0, $213 = 0.0, $214 = 0, $215 = 0.0, $216 = 0.0;
 var $217 = 0.0, $218 = 0.0, $219 = 0.0, $22 = 0, $220 = 0.0, $221 = 0.0, $222 = 0, $223 = 0.0, $224 = 0.0, $225 = 0.0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0;
 var $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0.0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0.0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0;
 var $253 = 0, $254 = 0.0, $255 = 0, $256 = 0, $257 = 0, $258 = 0.0, $259 = 0, $26 = 0, $260 = 0.0, $261 = 0.0, $262 = 0.0, $263 = 0.0, $264 = 0.0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0.0;
 var $271 = 0, $272 = 0, $273 = 0, $274 = 0.0, $275 = 0, $276 = 0.0, $277 = 0.0, $278 = 0.0, $279 = 0.0, $28 = 0, $280 = 0.0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0.0, $287 = 0, $288 = 0, $289 = 0;
 var $29 = 0, $290 = 0.0, $291 = 0, $292 = 0.0, $293 = 0.0, $294 = 0.0, $295 = 0.0, $296 = 0.0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0.0, $301 = 0.0, $302 = 0, $303 = 0.0, $304 = 0, $305 = 0, $306 = 0;
 var $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0;
 var $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0;
 var $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0.0, $354 = 0, $355 = 0, $356 = 0.0, $357 = 0.0, $358 = 0.0, $359 = 0.0, $36 = 0, $360 = 0;
 var $361 = 0, $362 = 0, $363 = 0, $364 = 0.0, $365 = 0, $366 = 0, $367 = 0.0, $368 = 0.0, $369 = 0.0, $37 = 0, $370 = 0.0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0;
 var $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0;
 var $398 = 0, $399 = 0, $4 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0;
 var $415 = 0, $416 = 0, $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0.0, $429 = 0, $43 = 0, $430 = 0, $431 = 0.0, $432 = 0.0;
 var $433 = 0.0, $434 = 0.0, $435 = 0, $436 = 0, $437 = 0, $438 = 0, $439 = 0.0, $44 = 0, $440 = 0, $441 = 0, $442 = 0.0, $443 = 0.0, $444 = 0.0, $445 = 0.0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0;
 var $451 = 0, $452 = 0.0, $453 = 0.0, $454 = 0.0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0.0, $461 = 0.0, $462 = 0.0, $463 = 0, $464 = 0.0, $465 = 0.0, $466 = 0.0, $467 = 0, $468 = 0, $469 = 0;
 var $47 = 0, $470 = 0, $471 = 0, $472 = 0, $473 = 0, $474 = 0.0, $475 = 0.0, $476 = 0.0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0.0, $482 = 0.0, $483 = 0.0, $484 = 0, $485 = 0.0, $486 = 0.0, $487 = 0.0;
 var $488 = 0.0, $489 = 0, $49 = 0, $490 = 0.0, $491 = 0.0, $492 = 0.0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $502 = 0.0, $503 = 0.0, $504 = 0.0;
 var $505 = 0, $506 = 0, $507 = 0.0, $508 = 0.0, $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0.0, $513 = 0.0, $514 = 0.0, $515 = 0.0, $516 = 0.0, $517 = 0, $518 = 0, $519 = 0, $52 = 0, $520 = 0, $521 = 0, $522 = 0;
 var $523 = 0, $524 = 0, $525 = 0.0, $526 = 0.0, $527 = 0.0, $528 = 0, $529 = 0.0, $53 = 0, $530 = 0.0, $531 = 0.0, $532 = 0.0, $533 = 0.0, $534 = 0.0, $535 = 0.0, $536 = 0.0, $537 = 0.0, $538 = 0.0, $539 = 0, $54 = 0, $540 = 0.0;
 var $541 = 0.0, $542 = 0.0, $543 = 0.0, $544 = 0.0, $545 = 0.0, $546 = 0.0, $547 = 0.0, $548 = 0.0, $549 = 0, $55 = 0, $550 = 0, $551 = 0.0, $552 = 0.0, $553 = 0.0, $554 = 0.0, $555 = 0.0, $556 = 0, $557 = 0.0, $558 = 0.0, $559 = 0.0;
 var $56 = 0, $560 = 0.0, $561 = 0.0, $562 = 0.0, $563 = 0.0, $564 = 0.0, $565 = 0, $566 = 0, $567 = 0.0, $568 = 0.0, $569 = 0.0, $57 = 0, $570 = 0.0, $571 = 0, $572 = 0, $573 = 0, $574 = 0, $575 = 0, $576 = 0, $577 = 0;
 var $578 = 0, $579 = 0, $58 = 0, $580 = 0, $581 = 0, $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0, $587 = 0, $588 = 0, $589 = 0, $59 = 0, $590 = 0, $591 = 0, $592 = 0, $593 = 0, $594 = 0, $595 = 0;
 var $596 = 0, $597 = 0, $598 = 0, $599 = 0, $6 = 0, $60 = 0, $600 = 0, $601 = 0, $602 = 0, $603 = 0, $604 = 0, $605 = 0, $606 = 0, $607 = 0, $608 = 0, $609 = 0, $61 = 0, $610 = 0, $611 = 0, $612 = 0;
 var $613 = 0, $614 = 0, $615 = 0, $616 = 0, $617 = 0, $618 = 0, $619 = 0, $62 = 0, $620 = 0, $621 = 0, $622 = 0, $623 = 0, $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0, $629 = 0, $63 = 0, $630 = 0;
 var $631 = 0, $632 = 0, $633 = 0, $634 = 0, $635 = 0, $636 = 0, $637 = 0, $638 = 0, $639 = 0, $64 = 0, $640 = 0, $641 = 0, $642 = 0, $643 = 0, $644 = 0, $645 = 0, $646 = 0, $647 = 0, $648 = 0, $649 = 0;
 var $65 = 0, $650 = 0, $651 = 0, $652 = 0, $653 = 0, $654 = 0, $655 = 0, $656 = 0, $657 = 0, $658 = 0, $659 = 0, $66 = 0, $660 = 0, $661 = 0, $662 = 0, $663 = 0, $664 = 0, $665 = 0, $666 = 0, $667 = 0;
 var $668 = 0, $669 = 0, $67 = 0, $670 = 0, $671 = 0, $672 = 0, $673 = 0, $674 = 0, $675 = 0, $676 = 0, $677 = 0, $678 = 0, $679 = 0, $68 = 0, $680 = 0, $681 = 0, $682 = 0, $683 = 0, $684 = 0, $685 = 0;
 var $686 = 0, $687 = 0, $688 = 0, $689 = 0, $69 = 0, $690 = 0, $691 = 0, $692 = 0, $693 = 0, $694 = 0, $695 = 0, $696 = 0, $697 = 0, $698 = 0, $699 = 0, $7 = 0, $70 = 0, $700 = 0, $701 = 0, $702 = 0;
 var $703 = 0, $704 = 0, $705 = 0, $706 = 0, $707 = 0, $708 = 0, $709 = 0, $71 = 0, $710 = 0, $711 = 0, $712 = 0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $72 = 0, $720 = 0;
 var $721 = 0, $722 = 0, $723 = 0, $724 = 0, $725 = 0, $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0, $730 = 0, $731 = 0, $732 = 0, $733 = 0, $734 = 0, $735 = 0, $736 = 0, $737 = 0, $738 = 0, $739 = 0;
 var $74 = 0, $740 = 0, $741 = 0, $742 = 0, $743 = 0, $744 = 0, $745 = 0, $746 = 0, $747 = 0, $748 = 0, $749 = 0, $75 = 0, $750 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0, $755 = 0, $756 = 0, $757 = 0;
 var $758 = 0, $759 = 0, $76 = 0, $760 = 0, $761 = 0, $762 = 0.0, $763 = 0, $764 = 0, $765 = 0, $766 = 0.0, $767 = 0, $768 = 0, $769 = 0, $77 = 0, $770 = 0.0, $771 = 0, $772 = 0, $773 = 0, $774 = 0.0, $775 = 0;
 var $776 = 0, $777 = 0, $778 = 0.0, $779 = 0, $78 = 0, $780 = 0, $781 = 0, $782 = 0.0, $783 = 0, $784 = 0, $785 = 0, $786 = 0.0, $787 = 0, $788 = 0, $789 = 0, $79 = 0, $790 = 0.0, $791 = 0, $792 = 0, $793 = 0;
 var $794 = 0.0, $795 = 0, $796 = 0, $797 = 0, $798 = 0.0, $799 = 0, $8 = 0, $80 = 0, $800 = 0, $801 = 0, $802 = 0.0, $803 = 0, $804 = 0, $805 = 0, $806 = 0.0, $807 = 0, $808 = 0, $809 = 0, $81 = 0, $810 = 0.0;
 var $811 = 0, $812 = 0, $813 = 0, $814 = 0.0, $815 = 0, $816 = 0, $817 = 0, $818 = 0.0, $819 = 0, $82 = 0, $820 = 0, $821 = 0, $822 = 0.0, $823 = 0, $824 = 0, $825 = 0, $826 = 0.0, $827 = 0, $828 = 0, $829 = 0;
 var $83 = 0, $830 = 0.0, $831 = 0, $832 = 0, $833 = 0, $834 = 0.0, $835 = 0, $836 = 0, $837 = 0, $838 = 0, $839 = 0, $84 = 0, $840 = 0, $841 = 0, $842 = 0, $843 = 0, $844 = 0, $845 = 0, $846 = 0, $847 = 0;
 var $848 = 0, $849 = 0, $85 = 0, $850 = 0, $851 = 0, $852 = 0, $853 = 0, $854 = 0, $855 = 0, $856 = 0, $857 = 0, $858 = 0, $859 = 0, $86 = 0, $860 = 0, $861 = 0, $862 = 0, $863 = 0, $864 = 0, $865 = 0;
 var $866 = 0, $867 = 0, $868 = 0, $869 = 0, $87 = 0, $870 = 0, $871 = 0, $872 = 0, $873 = 0, $874 = 0, $875 = 0, $876 = 0, $877 = 0, $878 = 0, $879 = 0, $88 = 0, $880 = 0, $881 = 0, $882 = 0, $883 = 0;
 var $884 = 0, $885 = 0, $886 = 0, $887 = 0, $888 = 0, $889 = 0, $89 = 0, $890 = 0, $891 = 0, $892 = 0, $893 = 0, $894 = 0, $895 = 0, $896 = 0, $897 = 0, $898 = 0.0, $899 = 0.0, $9 = 0, $90 = 0, $900 = 0;
 var $901 = 0.0, $902 = 0.0, $903 = 0.0, $904 = 0, $905 = 0, $906 = 0, $907 = 0, $908 = 0, $909 = 0, $91 = 0, $910 = 0, $911 = 0, $912 = 0, $913 = 0, $914 = 0, $915 = 0, $916 = 0, $917 = 0, $918 = 0, $919 = 0;
 var $92 = 0, $920 = 0, $921 = 0, $922 = 0, $923 = 0, $924 = 0, $925 = 0, $926 = 0, $927 = 0, $928 = 0, $929 = 0, $93 = 0, $930 = 0, $931 = 0, $932 = 0, $933 = 0, $934 = 0, $935 = 0, $936 = 0, $937 = 0;
 var $938 = 0, $939 = 0, $94 = 0, $940 = 0, $941 = 0, $942 = 0, $943 = 0, $944 = 0, $945 = 0, $946 = 0, $947 = 0, $948 = 0, $949 = 0, $95 = 0, $950 = 0, $951 = 0, $952 = 0, $953 = 0, $954 = 0, $955 = 0;
 var $956 = 0, $957 = 0, $958 = 0, $959 = 0, $96 = 0, $960 = 0, $961 = 0, $962 = 0, $963 = 0, $964 = 0, $965 = 0, $966 = 0, $967 = 0, $968 = 0, $969 = 0, $97 = 0, $970 = 0, $971 = 0, $972 = 0, $973 = 0;
 var $974 = 0, $975 = 0, $976 = 0, $977 = 0, $978 = 0, $979 = 0, $98 = 0, $980 = 0, $981 = 0, $982 = 0, $983 = 0, $984 = 0, $985 = 0, $986 = 0, $987 = 0, $988 = 0, $989 = 0, $99 = 0, $990 = 0, $991 = 0;
 var $992 = 0, $993 = 0, $994 = 0, $995 = 0, $996 = 0, $997 = 0, $998 = 0, $999 = 0, $band$011$i = 0, $band$18$i = 0, $band$27$i = 0, $exitcond$i = 0, $exitcond14$i = 0, $exitcond15$i = 0, $fabsf = 0.0, $fc1$0$i = 0.0, $fc2$0$i = 0.0, $highpass_band$010$i = 0, $highpass_band$1$i = 0, $highpass_band$1$i$lcssa = 0;
 var $i$040 = 0, $i$040$lcssa = 0, $lowpass_band$0$minband$0$i = 0, $lowpass_band$013$i = 0, $lowpass_band$1$i = 0, $lowpass_band$1$i$lcssa = 0, $m10$sroa$0$0 = 0.0, $m10$sroa$22$0 = 0.0, $m10$sroa$8$0 = 0.0, $maxband$09$i = 0, $maxband$1$i = 0, $maxband$1$i$lcssa = 0, $minband$012$i = 0, $minband$1$i = 0, $minband$1$i$lcssa = 0, $or$cond = 0, $or$cond$i = 0, $or$cond17$i = 0, $or$cond4$i = 0, $storemerge$i = 0.0;
 var $storemerge$in$i = 0.0, $storemerge$in$in$i = 0.0, $storemerge$in$in$in$i = 0.0, $storemerge1 = 0.0, $storemerge2 = 0.0, $storemerge3 = 0.0, $storemerge4 = 0.0, $suggested_samplefreq$0$i = 0, $suggested_samplefreq$2$i = 0, $suggested_samplefreq$4$i = 0, $suggested_samplefreq$6$i = 0, $suggested_samplefreq$8$i = 0, $switch = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $vararg_buffer = sp;
 $0 = ((($gfp)) + 288|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ((($1)) + 16|0);
 HEAP32[$1>>2] = 0;
 $3 = ((($gfp)) + 180|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ((($1)) + 124|0);
 HEAP32[$5>>2] = $4;
 $6 = ((($gfp)) + 32|0);
 $7 = HEAP32[$6>>2]|0;
 $8 = ((($1)) + 140|0);
 HEAP32[$8>>2] = $7;
 $9 = ($7|0)==(0);
 if (!($9)) {
  $10 = ((($gfp)) + 36|0);
  HEAP32[$10>>2] = 0;
 }
 $11 = ((($1)) + 85804|0);
 $12 = HEAP32[$11>>2]|0;
 $13 = ($12|0)==(0|0);
 if (!($13)) {
  $14 = ((($gfp)) + 36|0);
  HEAP32[$14>>2] = 0;
 }
 $15 = ((($gfp)) + 272|0);
 $16 = HEAP32[$15>>2]|0;
 $17 = ((($1)) + 85828|0);
 HEAP32[$17>>2] = $16;
 $18 = ((($gfp)) + 276|0);
 $19 = HEAP32[$18>>2]|0;
 $20 = ((($1)) + 85832|0);
 HEAP32[$20>>2] = $19;
 $21 = ((($gfp)) + 280|0);
 $22 = HEAP32[$21>>2]|0;
 $23 = ((($1)) + 85836|0);
 HEAP32[$23>>2] = $22;
 $24 = ((($gfp)) + 296|0);
 $25 = HEAP32[$24>>2]|0;
 $26 = ($25|0)==(0);
 if ($26) {
  $34 = ((($1)) + 85756|0);
  $35 = HEAP32[$34>>2]|0;
  $36 = $35 & -3;
  HEAP32[$34>>2] = $36;
  $48 = $36;
 } else {
  $27 = (_has_3DNow()|0);
  $28 = ((($1)) + 85756|0);
  $29 = HEAP32[$28>>2]|0;
  $30 = $27 << 1;
  $31 = $30 & 2;
  $32 = $29 & -3;
  $33 = $32 | $31;
  HEAP32[$28>>2] = $33;
  $48 = $33;
 }
 $37 = ((($gfp)) + 292|0);
 $38 = HEAP32[$37>>2]|0;
 $39 = ($38|0)==(0);
 if ($39) {
  $46 = ((($1)) + 85756|0);
  $47 = $48 & -2;
  HEAP32[$46>>2] = $47;
  $67 = $47;
 } else {
  $40 = (_has_MMX()|0);
  $41 = ((($1)) + 85756|0);
  $42 = HEAP32[$41>>2]|0;
  $43 = $40 & 1;
  $44 = $42 & -2;
  $45 = $44 | $43;
  HEAP32[$41>>2] = $45;
  $67 = $45;
 }
 $49 = ((($gfp)) + 300|0);
 $50 = HEAP32[$49>>2]|0;
 $51 = ($50|0)==(0);
 if ($51) {
  $65 = ((($1)) + 85756|0);
  $66 = $67 & -13;
  HEAP32[$65>>2] = $66;
 } else {
  $52 = (_has_SSE()|0);
  $53 = ((($1)) + 85756|0);
  $54 = HEAP32[$53>>2]|0;
  $55 = $52 << 2;
  $56 = $55 & 4;
  $57 = $54 & -5;
  $58 = $57 | $56;
  HEAP32[$53>>2] = $58;
  $59 = (_has_SSE2()|0);
  $60 = HEAP32[$53>>2]|0;
  $61 = $59 << 3;
  $62 = $61 & 8;
  $63 = $60 & -9;
  $64 = $63 | $62;
  HEAP32[$53>>2] = $64;
 }
 $68 = ((($1)) + 85796|0);
 $69 = HEAP32[$68>>2]|0;
 $70 = ($69|0)==(0|0);
 if ($70) {
  $71 = (_calloc(1,2772)|0);
  HEAP32[$68>>2] = $71;
  $72 = ($71|0)==(0|0);
  if ($72) {
   $$0 = -2;
   STACKTOP = sp;return ($$0|0);
  }
 }
 $73 = ((($1)) + 85676|0);
 $74 = HEAP32[$73>>2]|0;
 $75 = ($74|0)==(0|0);
 if ($75) {
  $76 = (_calloc(1,134792)|0);
  HEAP32[$73>>2] = $76;
  $77 = ($76|0)==(0|0);
  if ($77) {
   _freegfc($1);
   HEAP32[$0>>2] = 0;
   $$0 = -2;
   STACKTOP = sp;return ($$0|0);
  }
 }
 $78 = ((($gfp)) + 120|0);
 $79 = HEAP32[$78>>2]|0;
 $80 = ((($1)) + 160|0);
 HEAP32[$80>>2] = $79;
 $81 = ((($gfp)) + 104|0);
 $82 = HEAP32[$81>>2]|0;
 $83 = ((($1)) + 164|0);
 HEAP32[$83>>2] = $82;
 $84 = ((($gfp)) + 108|0);
 $85 = HEAP32[$84>>2]|0;
 $86 = ((($1)) + 168|0);
 HEAP32[$86>>2] = $85;
 $87 = ((($gfp)) + 112|0);
 $88 = HEAP32[$87>>2]|0;
 $89 = ((($1)) + 172|0);
 HEAP32[$89>>2] = $88;
 $90 = ((($gfp)) + 116|0);
 $91 = HEAP32[$90>>2]|0;
 $92 = ((($1)) + 176|0);
 HEAP32[$92>>2] = $91;
 $93 = ((($gfp)) + 8|0);
 $94 = HEAP32[$93>>2]|0;
 $95 = ((($1)) + 68|0);
 HEAP32[$95>>2] = $94;
 $96 = ($94|0)==(1);
 $97 = ((($gfp)) + 48|0);
 if ($96) {
  HEAP32[$97>>2] = 3;
  $98 = ((($1)) + 72|0);
  HEAP32[$98>>2] = 1;
  $1205 = $98;$1206 = 1;
  label = 23;
 } else {
  $$pre = HEAP32[$97>>2]|0;
  $99 = ($$pre|0)==(3);
  $100 = $99 ? 1 : 2;
  $101 = ((($1)) + 72|0);
  HEAP32[$101>>2] = $100;
  if ($99) {
   $1205 = $101;$1206 = $100;
   label = 23;
  } else {
   $$phi$trans$insert56 = ((($gfp)) + 52|0);
   $$pre57 = HEAP32[$$phi$trans$insert56>>2]|0;
   $104 = $$pre57;$1207 = $100;$142 = $101;
  }
 }
 if ((label|0) == 23) {
  $102 = ((($gfp)) + 52|0);
  HEAP32[$102>>2] = 0;
  $104 = 0;$1207 = $1206;$142 = $1205;
 }
 $103 = ((($1)) + 80|0);
 HEAP32[$103>>2] = $104;
 $105 = ((($gfp)) + 156|0);
 $106 = HEAP32[$105>>2]|0;
 if ((($106|0) == 4) | (($106|0) == 1)) {
  label = 29;
 } else if ((($106|0) == 0)) {
  $107 = ((($gfp)) + 168|0);
  $108 = HEAP32[$107>>2]|0;
  $109 = ($108|0)==(128);
  if (!($109)) {
   $110 = ((($gfp)) + 96|0);
   $111 = HEAP32[$110>>2]|0;
   $112 = ($111|0)==(0);
   if ($112) {
    HEAP32[$110>>2] = $108;
   }
  }
  $117 = ((($gfp)) + 56|0);
  $118 = HEAP32[$117>>2]|0;
  $119 = ((($1)) + 152|0);
  HEAP32[$119>>2] = $118;
  $120 = ((($gfp)) + 96|0);
  $121 = HEAP32[$120>>2]|0;
  $122 = ($121|0)==(0);
  do {
   if ($122) {
    $123 = ((($gfp)) + 100|0);
    $124 = +HEAPF32[$123>>2];
    $fabsf = (+Math_abs((+$124)));
    $125 = $fabsf;
    $126 = ($124 != $124) | (0.0 != 0.0) |($124 == 0.0);
    if ($126) {
     $129 = $124 == 0.0;
     if (!($129)) {
      break;
     }
    } else {
     $127 = $125 * 9.9999999747524271E-7;
     $128 = !($125 <= $127);
     if ($128) {
      break;
     }
    }
    HEAPF32[$123>>2] = 11.024999618530273;
   }
  } while(0);
  $130 = ((($gfp)) + 100|0);
  $131 = +HEAPF32[$130>>2];
  $132 = $131 > 0.0;
  if ($132) {
   $133 = ((($gfp)) + 16|0);
   $134 = HEAP32[$133>>2]|0;
   $135 = ($134|0)==(0);
   if ($135) {
    $136 = ((($gfp)) + 12|0);
    $137 = HEAP32[$136>>2]|0;
    $138 = (+($137|0));
    $139 = $138 * 0.96999999999999997;
    $140 = (~~(($139)));
    $141 = (_map2MP3Frequency($140)|0);
    HEAP32[$133>>2] = $141;
    $$pre58 = HEAP32[$142>>2]|0;
    $$pre59 = +HEAPF32[$130>>2];
    $144 = $141;$146 = $$pre58;$149 = $$pre59;
   } else {
    $144 = $134;$146 = $1207;$149 = $131;
   }
   $143 = $144 << 4;
   $145 = Math_imul($143, $146)|0;
   $147 = (+($145|0));
   $148 = $149;
   $150 = $148 * 1000.0;
   $151 = $147 / $150;
   $152 = (~~(($151)));
   HEAP32[$120>>2] = $152;
   $153 = (_SmpFrqIndex($144,$2)|0);
   $154 = ((($1)) + 20|0);
   HEAP32[$154>>2] = $153;
   $155 = HEAP32[$119>>2]|0;
   $156 = ($155|0)==(0);
   if ($156) {
    $157 = HEAP32[$120>>2]|0;
    $158 = HEAP32[$2>>2]|0;
    $159 = HEAP32[$133>>2]|0;
    $160 = (_FindNearestBitrate($157,$158,$159)|0);
    HEAP32[$120>>2] = $160;
    $580 = $119;
   } else {
    $580 = $119;
   }
  } else {
   $580 = $119;
  }
 } else {
  $113 = ((($gfp)) + 56|0);
  HEAP32[$113>>2] = 0;
  label = 29;
 }
 if ((label|0) == 29) {
  $114 = ((($gfp)) + 56|0);
  $115 = HEAP32[$114>>2]|0;
  $116 = ((($1)) + 152|0);
  HEAP32[$116>>2] = $115;
  $580 = $116;
 }
 $161 = ((($gfp)) + 16|0);
 $162 = HEAP32[$161>>2]|0;
 $163 = ($162|0)==(0);
 L57: do {
  if ($163) {
   $179 = HEAP32[$105>>2]|0;
   if ((($179|0) == 4) | (($179|0) == 1)) {
    $180 = ((($gfp)) + 164|0);
    $181 = HEAP32[$180>>2]|0;
    $182 = (+($181|0));
    $183 = ((($gfp)) + 160|0);
    $184 = +HEAPF32[$183>>2];
    $185 = $182 + $184;
    $186 = ((($gfp)) + 12|0);
    $187 = HEAP32[$186>>2]|0;
    $i$040 = 2;
    while(1) {
     $188 = (6560 + (($i$040*24)|0)|0);
     $189 = HEAP32[$188>>2]|0;
     $190 = ($187|0)==($189|0);
     if ($190) {
      $191 = (((6560 + (($i$040*24)|0)|0)) + 4|0);
      $192 = +HEAPF32[$191>>2];
      $193 = $185 < $192;
      if ($193) {
       $194 = $185 / $192;
       $195 = $194;
       $196 = (((6560 + (($i$040*24)|0)|0)) + 12|0);
       $197 = +HEAPF32[$196>>2];
       $198 = $197;
       $199 = $198 * $195;
       $200 = (~~(($199)));
       HEAP32[$180>>2] = $200;
       $201 = (+($200|0));
       $202 = $199 - $201;
       $203 = $202;
       HEAPF32[$183>>2] = $203;
      }
     }
     $204 = ($187|0)<($189|0);
     if (!($204)) {
      $205 = (((6560 + (($i$040*24)|0)|0)) + 4|0);
      $206 = +HEAPF32[$205>>2];
      $207 = !($206 <= $185);
      if (!($207)) {
       $208 = (((6560 + (($i$040*24)|0)|0)) + 8|0);
       $209 = +HEAPF32[$208>>2];
       $210 = $185 < $209;
       if ($210) {
        $$lcssa = $189;$$lcssa113 = $206;$$lcssa114 = $209;$i$040$lcssa = $i$040;
        break;
       }
      }
     }
     $229 = (($i$040) + 1)|0;
     $230 = ($229|0)<(9);
     if ($230) {
      $i$040 = $229;
     } else {
      $1208 = $162;
      break L57;
     }
    }
    $211 = $$lcssa114 - $$lcssa113;
    $212 = (((6560 + (($i$040$lcssa*24)|0)|0)) + 16|0);
    $213 = +HEAPF32[$212>>2];
    $214 = (((6560 + (($i$040$lcssa*24)|0)|0)) + 12|0);
    $215 = +HEAPF32[$214>>2];
    $216 = $213 - $215;
    $217 = $185 - $$lcssa113;
    $218 = $216 * $217;
    $219 = $218 / $211;
    $220 = $219 + $215;
    $221 = $220;
    $222 = (~~(($220)));
    HEAP32[$180>>2] = $222;
    $223 = (+($222|0));
    $224 = $221 - $223;
    $225 = $224;
    HEAPF32[$183>>2] = $225;
    HEAP32[$161>>2] = $$lcssa;
    $226 = ((($gfp)) + 184|0);
    $227 = HEAP32[$226>>2]|0;
    $228 = ($227|0)==(0);
    if ($228) {
     HEAP32[$226>>2] = -1;
     $1208 = $$lcssa;
    } else {
     $1208 = $$lcssa;
    }
   } else {
    $1208 = 0;
   }
  } else {
   $164 = ($162|0)<(16000);
   if ($164) {
    $165 = ((($gfp)) + 168|0);
    $166 = HEAP32[$165>>2]|0;
    $167 = ($166|0)>(8);
    $$ = $167 ? $166 : 8;
    $168 = ($$|0)<(64);
    $169 = $168 ? $$ : 64;
    HEAP32[$165>>2] = $169;
    $1208 = $162;
    break;
   }
   $170 = ($162|0)<(32000);
   $171 = ((($gfp)) + 168|0);
   $172 = HEAP32[$171>>2]|0;
   if ($170) {
    $173 = ($172|0)>(8);
    $$5 = $173 ? $172 : 8;
    $174 = ($$5|0)<(160);
    $175 = $174 ? $$5 : 160;
    HEAP32[$171>>2] = $175;
    $1208 = $162;
    break;
   } else {
    $176 = ($172|0)>(32);
    $$6 = $176 ? $172 : 32;
    $177 = ($$6|0)<(320);
    $178 = $177 ? $$6 : 320;
    HEAP32[$171>>2] = $178;
    $1208 = $162;
    break;
   }
  }
 } while(0);
 $231 = ((($gfp)) + 184|0);
 $232 = HEAP32[$231>>2]|0;
 $233 = ($232|0)==(0);
 if ($233) {
  $234 = HEAP32[$105>>2]|0;
  switch ($234|0) {
  case 0:  {
   $235 = ((($gfp)) + 96|0);
   $236 = HEAP32[$235>>2]|0;
   $237 = $236&65535;
   $238 = (_nearestBitrateFullIndex($237)|0);
   $239 = (((6776 + ($238<<3)|0)) + 4|0);
   $240 = HEAP32[$239>>2]|0;
   $241 = (+($240|0));
   $301 = $241;
   break;
  }
  case 3:  {
   $242 = ((($gfp)) + 168|0);
   $243 = HEAP32[$242>>2]|0;
   $244 = $243&65535;
   $245 = (_nearestBitrateFullIndex($244)|0);
   $246 = (((6776 + ($245<<3)|0)) + 4|0);
   $247 = HEAP32[$246>>2]|0;
   $248 = (+($247|0));
   $301 = $248;
   break;
  }
  case 2:  {
   $249 = ((($gfp)) + 164|0);
   $250 = HEAP32[$249>>2]|0;
   $251 = ($250>>>0)<(10);
   if ($251) {
    $252 = (6912 + ($250<<2)|0);
    $253 = HEAP32[$252>>2]|0;
    $254 = (+($253|0));
    $255 = (($250) + 1)|0;
    $256 = (6912 + ($255<<2)|0);
    $257 = HEAP32[$256>>2]|0;
    $258 = (+($257|0));
    $259 = ((($gfp)) + 160|0);
    $260 = +HEAPF32[$259>>2];
    $261 = $260;
    $262 = $258 - $254;
    $263 = $262 * $261;
    $264 = $263 + $254;
    $301 = $264;
   } else {
    $301 = 19500.0;
   }
   break;
  }
  case 1: case 4:  {
   $265 = ((($gfp)) + 164|0);
   $266 = HEAP32[$265>>2]|0;
   $267 = ($266>>>0)<(10);
   if ($267) {
    $268 = (6960 + ($266<<2)|0);
    $269 = HEAP32[$268>>2]|0;
    $270 = (+($269|0));
    $271 = (($266) + 1)|0;
    $272 = (6960 + ($271<<2)|0);
    $273 = HEAP32[$272>>2]|0;
    $274 = (+($273|0));
    $275 = ((($gfp)) + 160|0);
    $276 = +HEAPF32[$275>>2];
    $277 = $276;
    $278 = $274 - $270;
    $279 = $278 * $277;
    $280 = $279 + $270;
    $301 = $280;
   } else {
    $301 = 21500.0;
   }
   break;
  }
  default: {
   $281 = ((($gfp)) + 164|0);
   $282 = HEAP32[$281>>2]|0;
   $283 = ($282>>>0)<(10);
   if ($283) {
    $284 = (7008 + ($282<<2)|0);
    $285 = HEAP32[$284>>2]|0;
    $286 = (+($285|0));
    $287 = (($282) + 1)|0;
    $288 = (7008 + ($287<<2)|0);
    $289 = HEAP32[$288>>2]|0;
    $290 = (+($289|0));
    $291 = ((($gfp)) + 160|0);
    $292 = +HEAPF32[$291>>2];
    $293 = $292;
    $294 = $290 - $286;
    $295 = $294 * $293;
    $296 = $295 + $286;
    $301 = $296;
   } else {
    $301 = 19500.0;
   }
  }
  }
  $297 = HEAP32[$97>>2]|0;
  $298 = ($297|0)==(3);
  if ($298) {
   $299 = HEAP32[$105>>2]|0;
   if ((($299|0) == 3) | (($299|0) == 0)) {
    $300 = $301 * 1.5;
    $303 = $300;
   } else {
    $303 = $301;
   }
  } else {
   $303 = $301;
  }
  $302 = (~~(($303)));
  HEAP32[$231>>2] = $302;
  $$pre60 = HEAP32[$161>>2]|0;
  $304 = $$pre60;$307 = $302;
 } else {
  $304 = $1208;$307 = $232;
 }
 $305 = ($304|0)==(0);
 if ($305) {
  $306 = $307 << 1;
  $308 = ((($gfp)) + 12|0);
  $309 = HEAP32[$308>>2]|0;
  $310 = ($306|0)>($309|0);
  if ($310) {
   $311 = (($309|0) / 2)&-1;
   HEAP32[$231>>2] = $311;
   $321 = $311;
  } else {
   $321 = $307;
  }
  $312 = ($309|0)>(47999);
  do {
   if ($312) {
    $suggested_samplefreq$0$i = 48000;
   } else {
    $313 = ($309|0)>(44099);
    if ($313) {
     $suggested_samplefreq$0$i = 44100;
    } else {
     $314 = ($309|0)>(31999);
     if ($314) {
      $suggested_samplefreq$0$i = 32000;
     } else {
      $315 = ($309|0)>(23999);
      if ($315) {
       $suggested_samplefreq$0$i = 24000;
      } else {
       $316 = ($309|0)>(22049);
       if ($316) {
        $suggested_samplefreq$0$i = 22050;
       } else {
        $317 = ($309|0)>(15999);
        if ($317) {
         $suggested_samplefreq$0$i = 16000;
        } else {
         $318 = ($309|0)>(11999);
         if ($318) {
          $suggested_samplefreq$0$i = 12000;
          break;
         }
         $319 = ($309|0)>(11024);
         if ($319) {
          $suggested_samplefreq$0$i = 11025;
          break;
         }
         $320 = ($309|0)>(7999);
         $$$i = $320 ? 8000 : 44100;
         $suggested_samplefreq$0$i = $$$i;
        }
       }
      }
     }
    }
   }
  } while(0);
  $322 = ($321|0)==(-1);
  do {
   if ($322) {
    $$0$i13 = $suggested_samplefreq$0$i;
   } else {
    $323 = ($321|0)<(15961);
    $$suggested_samplefreq$0$i = $323 ? 44100 : $suggested_samplefreq$0$i;
    $324 = ($321|0)<(15251);
    $suggested_samplefreq$2$i = $324 ? 32000 : $$suggested_samplefreq$0$i;
    $325 = ($321|0)<(11221);
    $$suggested_samplefreq$2$i = $325 ? 24000 : $suggested_samplefreq$2$i;
    $326 = ($321|0)<(9971);
    $suggested_samplefreq$4$i = $326 ? 22050 : $$suggested_samplefreq$2$i;
    $327 = ($321|0)<(7231);
    $$suggested_samplefreq$4$i = $327 ? 16000 : $suggested_samplefreq$4$i;
    $328 = ($321|0)<(5421);
    $suggested_samplefreq$6$i = $328 ? 12000 : $$suggested_samplefreq$4$i;
    $329 = ($321|0)<(4511);
    $$suggested_samplefreq$6$i = $329 ? 11025 : $suggested_samplefreq$6$i;
    $330 = ($321|0)<(3971);
    $suggested_samplefreq$8$i = $330 ? 8000 : $$suggested_samplefreq$6$i;
    $331 = ($suggested_samplefreq$8$i|0)>($309|0);
    if ($331) {
     $332 = ($309|0)>(44100);
     if ($332) {
      $$0$i13 = 48000;
     } else {
      $333 = ($309|0)>(32000);
      if ($333) {
       $$0$i13 = 44100;
      } else {
       $334 = ($309|0)>(24000);
       if ($334) {
        $$0$i13 = 32000;
       } else {
        $335 = ($309|0)>(22050);
        if ($335) {
         $$0$i13 = 24000;
         break;
        }
        $336 = ($309|0)>(16000);
        if ($336) {
         $$0$i13 = 22050;
         break;
        }
        $337 = ($309|0)>(12000);
        if ($337) {
         $$0$i13 = 16000;
         break;
        }
        $338 = ($309|0)>(11025);
        if ($338) {
         $$0$i13 = 12000;
         break;
        }
        $339 = ($309|0)>(8000);
        $$1$i = $339 ? 11025 : 8000;
        $$0$i13 = $$1$i;
       }
      }
     }
    } else {
     $$0$i13 = $suggested_samplefreq$8$i;
    }
   }
  } while(0);
  HEAP32[$161>>2] = $$0$i13;
  $341 = $321;$344 = $$0$i13;
 } else {
  $341 = $307;$344 = $304;
 }
 $340 = HEAP32[$105>>2]|0;
 do {
  if ((($340|0) == 4) | (($340|0) == 1)) {
   $342 = ($341|0)>(24000);
   $$9 = $342 ? 24000 : $341;
   $343 = (($344|0) / 2)&-1;
   $345 = ($343|0)<($$9|0);
   $$storemerge91 = $345 ? $343 : $$9;
   HEAP32[$231>>2] = $$storemerge91;
   $346 = ($340|0)==(3);
   if ($346) {
    label = 98;
   }
  } else {
   $347 = ($341|0)>(20500);
   $$10 = $347 ? 20500 : $341;
   $348 = (($344|0) / 2)&-1;
   $349 = ($348|0)<($$10|0);
   $$storemerge = $349 ? $348 : $$10;
   HEAP32[$231>>2] = $$storemerge;
   if ((($340|0) == 3)) {
    label = 98;
    break;
   } else if (!((($340|0) == 0))) {
    break;
   }
   $350 = $344 << 4;
   $351 = HEAP32[$142>>2]|0;
   $352 = Math_imul($350, $351)|0;
   $353 = (+($352|0));
   $354 = ((($gfp)) + 96|0);
   $355 = HEAP32[$354>>2]|0;
   $356 = (+($355|0));
   $357 = $356 * 1000.0;
   $358 = $353 / $357;
   $359 = $358;
   $360 = ((($gfp)) + 100|0);
   HEAPF32[$360>>2] = $359;
  }
 } while(0);
 if ((label|0) == 98) {
  $361 = $344 << 4;
  $362 = HEAP32[$142>>2]|0;
  $363 = Math_imul($361, $362)|0;
  $364 = (+($363|0));
  $365 = ((($gfp)) + 168|0);
  $366 = HEAP32[$365>>2]|0;
  $367 = (+($366|0));
  $368 = $367 * 1000.0;
  $369 = $364 / $368;
  $370 = $369;
  $371 = ((($gfp)) + 100|0);
  HEAPF32[$371>>2] = $370;
 }
 $372 = ((($gfp)) + 36|0);
 $373 = HEAP32[$372>>2]|0;
 $374 = ($373|0)==(0);
 $375 = ((($gfp)) + 60|0);
 if ($374) {
  HEAP32[$375>>2] = 0;
  $376 = ((($gfp)) + 64|0);
  HEAP32[$376>>2] = 0;
  $377 = ((($1)) + 132|0);
  HEAP32[$377>>2] = 0;
  $378 = ((($1)) + 128|0);
  HEAP32[$378>>2] = 0;
  $379 = ((($1)) + 136|0);
  HEAP32[$379>>2] = 0;
 } else {
  $$pre63 = HEAP32[$375>>2]|0;
  $$phi$trans$insert64 = ((($gfp)) + 64|0);
  $$pre65 = HEAP32[$$phi$trans$insert64>>2]|0;
  $380 = ((($1)) + 128|0);
  HEAP32[$380>>2] = $$pre63;
  $381 = ((($1)) + 136|0);
  HEAP32[$381>>2] = $$pre65;
  $382 = ($$pre65|0)==(0);
  if ($382) {
   $1209 = 0;
  } else {
   $383 = ((($1)) + 132|0);
   HEAP32[$383>>2] = 1;
   $1209 = $$pre65;
  }
  $384 = ($$pre63|0)==(0);
  do {
   if ($384) {
    $388 = $1209;
   } else {
    $385 = HEAP32[$73>>2]|0;
    $386 = (_InitGainAnalysis(($385|0),($344|0))|0);
    $387 = ($386|0)==(0);
    if (!($387)) {
     $$pre67 = HEAP32[$381>>2]|0;
     $388 = $$pre67;
     break;
    }
    _freegfc($1);
    HEAP32[$0>>2] = 0;
    $$0 = -6;
    STACKTOP = sp;return ($$0|0);
   }
  } while(0);
  $389 = ($388|0)==(0);
  if (!($389)) {
   $390 = ((($gfp)) + 40|0);
   $391 = HEAP32[$390>>2]|0;
   $392 = ($391|0)==(0);
   if ($392) {
    $393 = ((($1)) + 85808|0);
    $394 = HEAP32[$393>>2]|0;
    $395 = ($394|0)==(0|0);
    if (!($395)) {
     (_hip_decode_exit(($394|0))|0);
    }
    $396 = (_hip_decode_init()|0);
    HEAP32[$393>>2] = $396;
    $397 = HEAP32[$21>>2]|0;
    _hip_set_errorf(($396|0),($397|0));
    $398 = HEAP32[$393>>2]|0;
    $399 = HEAP32[$18>>2]|0;
    _hip_set_debugf(($398|0),($399|0));
    $400 = HEAP32[$393>>2]|0;
    $401 = HEAP32[$15>>2]|0;
    _hip_set_msgf(($400|0),($401|0));
   }
  }
 }
 $402 = ((($gfp)) + 128|0);
 $403 = HEAP32[$402>>2]|0;
 $404 = ((($1)) + 144|0);
 HEAP32[$404>>2] = $403;
 $405 = HEAP32[$231>>2]|0;
 $406 = ((($1)) + 52|0);
 HEAP32[$406>>2] = $405;
 $407 = ((($gfp)) + 188|0);
 $408 = HEAP32[$407>>2]|0;
 $409 = ((($1)) + 56|0);
 HEAP32[$409>>2] = $408;
 $410 = ((($gfp)) + 12|0);
 $411 = HEAP32[$410>>2]|0;
 $412 = ((($1)) + 60|0);
 HEAP32[$412>>2] = $411;
 $413 = HEAP32[$161>>2]|0;
 $414 = ((($1)) + 64|0);
 HEAP32[$414>>2] = $413;
 $415 = ($413|0)<(24001);
 $416 = $415 ? 1 : 2;
 $417 = ((($1)) + 76|0);
 HEAP32[$417>>2] = $416;
 $418 = ((($1)) + 84760|0);
 HEAP32[$418>>2] = 576;
 $419 = HEAP32[$105>>2]|0;
 if ((($419|0) == 4) | (($419|0) == 2) | (($419|0) == 1)) {
  $420 = ((($gfp)) + 164|0);
  $421 = HEAP32[$420>>2]|0;
  $422 = (7056 + ($421<<2)|0);
  $423 = HEAP32[$422>>2]|0;
  $424 = ((($gfp)) + 100|0);
  HEAP32[$424>>2] = $423;
 } else if ((($419|0) == 3)) {
  $425 = $413 << 4;
  $426 = HEAP32[$142>>2]|0;
  $427 = Math_imul($425, $426)|0;
  $428 = (+($427|0));
  $429 = ((($gfp)) + 168|0);
  $430 = HEAP32[$429>>2]|0;
  $431 = (+($430|0));
  $432 = $431 * 1000.0;
  $433 = $428 / $432;
  $434 = $433;
  $435 = ((($gfp)) + 100|0);
  HEAPF32[$435>>2] = $434;
 } else {
  $436 = $413 << 4;
  $437 = HEAP32[$142>>2]|0;
  $438 = Math_imul($436, $437)|0;
  $439 = (+($438|0));
  $440 = ((($gfp)) + 96|0);
  $441 = HEAP32[$440>>2]|0;
  $442 = (+($441|0));
  $443 = $442 * 1000.0;
  $444 = $439 / $443;
  $445 = $444;
  $446 = ((($gfp)) + 100|0);
  HEAPF32[$446>>2] = $445;
 }
 $447 = HEAP32[$97>>2]|0;
 $448 = ($447|0)==(4);
 if ($448) {
  HEAP32[$97>>2] = 1;
  $450 = 1;
 } else {
  $450 = $447;
 }
 $449 = ((($1)) + 180|0);
 HEAP32[$449>>2] = $450;
 $451 = ($408|0)>(0);
 if ($451) {
  $452 = (+($408|0));
  $453 = $452 * 2.0;
  $454 = $453;
  $455 = ((($1)) + 256|0);
  HEAPF32[$455>>2] = $454;
  $456 = ((($gfp)) + 196|0);
  $457 = HEAP32[$456>>2]|0;
  $458 = ($457|0)>(-1);
  if ($458) {
   $459 = (($408) + ($457))|0;
   $460 = (+($459|0));
   $461 = $460 * 2.0;
   $462 = $461;
   $$sink = $462;
  } else {
   $$sink = $454;
  }
  $463 = ((($1)) + 260|0);
  $464 = (+($413|0));
  $465 = $454 / $464;
  HEAPF32[$455>>2] = $465;
  $466 = $$sink / $464;
  HEAPF32[$463>>2] = $466;
  $507 = $466;
 } else {
  $467 = ((($1)) + 256|0);
  HEAPF32[$467>>2] = 0.0;
  $468 = ((($1)) + 260|0);
  HEAPF32[$468>>2] = 0.0;
  $507 = 0.0;
 }
 $469 = ((($1)) + 248|0);
 HEAPF32[$469>>2] = 0.0;
 $470 = ((($1)) + 252|0);
 HEAPF32[$470>>2] = 0.0;
 $471 = ($405|0)>(0);
 $472 = (($413|0) / 2)&-1;
 $473 = ($405|0)<($472|0);
 $or$cond = $471 & $473;
 if ($or$cond) {
  $474 = (+($405|0));
  $475 = $474 * 2.0;
  $476 = $475;
  HEAPF32[$470>>2] = $476;
  $477 = ((($gfp)) + 192|0);
  $478 = HEAP32[$477>>2]|0;
  $479 = ($478|0)>(-1);
  if ($479) {
   $480 = (($405) - ($478))|0;
   $481 = (+($480|0));
   $482 = $481 * 2.0;
   $483 = $482;
   HEAPF32[$469>>2] = $483;
   $484 = $483 < 0.0;
   if ($484) {
    HEAPF32[$469>>2] = 0.0;
    $487 = 0.0;
   } else {
    $487 = $483;
   }
  } else {
   HEAPF32[$469>>2] = $476;
   $487 = $476;
  }
  $485 = (+($413|0));
  $486 = $487 / $485;
  HEAPF32[$469>>2] = $486;
  $488 = $476 / $485;
  HEAPF32[$470>>2] = $488;
  $489 = $486 > 0.0;
  if ($489) {
   $band$011$i = 0;$lowpass_band$013$i = 32;$minband$012$i = 999;
   while(1) {
    $490 = (+($band$011$i|0));
    $491 = $490 * 0.032258064516129031;
    $492 = $491;
    $493 = !($492 >= $488);
    $494 = ($lowpass_band$013$i|0)<($band$011$i|0);
    $495 = $494 | $493;
    $lowpass_band$1$i = $495 ? $lowpass_band$013$i : $band$011$i;
    $496 = $486 < $492;
    $497 = $492 < $488;
    $or$cond4$i = $497 & $496;
    $498 = ($minband$012$i|0)<($band$011$i|0);
    $499 = $498 ? $minband$012$i : $band$011$i;
    $minband$1$i = $or$cond4$i ? $499 : $minband$012$i;
    $500 = (($band$011$i) + 1)|0;
    $exitcond15$i = ($500|0)==(32);
    if ($exitcond15$i) {
     $lowpass_band$1$i$lcssa = $lowpass_band$1$i;$minband$1$i$lcssa = $minband$1$i;
     break;
    } else {
     $band$011$i = $500;$lowpass_band$013$i = $lowpass_band$1$i;$minband$012$i = $minband$1$i;
    }
   }
   $501 = ($minband$1$i$lcssa|0)==(999);
   $lowpass_band$0$minband$0$i = $501 ? $lowpass_band$1$i$lcssa : $minband$1$i$lcssa;
   $storemerge$in$in$in$i = (+($lowpass_band$0$minband$0$i|0));
   $storemerge$in$in$i = $storemerge$in$in$in$i + -0.75;
   $storemerge$in$i = $storemerge$in$in$i * 0.032258064516129031;
   $storemerge$i = $storemerge$in$i;
   HEAPF32[$469>>2] = $storemerge$i;
   $502 = (+($lowpass_band$1$i$lcssa|0));
   $503 = $502 * 0.032258064516129031;
   $504 = $503;
   HEAPF32[$470>>2] = $504;
  }
 }
 $505 = ((($1)) + 260|0);
 $506 = $507 > 0.0;
 $508 = $507;
 $509 = $508 < 0.021774193548387097;
 $or$cond$i = $506 & $509;
 $510 = ((($1)) + 256|0);
 if ($or$cond$i) {
  HEAPF32[$510>>2] = 0.0;
  HEAPF32[$505>>2] = 0.0;
  _lame_msgf($1,7096,$vararg_buffer);
  $$pr$i = +HEAPF32[$505>>2];
  $512 = $$pr$i;
 } else {
  $512 = $507;
 }
 $511 = $512 > 0.0;
 do {
  if ($511) {
   $513 = +HEAPF32[$510>>2];
   $band$18$i = 0;$highpass_band$010$i = -1;$maxband$09$i = -1;
   while(1) {
    $514 = (+($band$18$i|0));
    $515 = $514 * 0.032258064516129031;
    $516 = $515;
    $517 = !($516 <= $513);
    $518 = ($highpass_band$010$i|0)>($band$18$i|0);
    $519 = $518 | $517;
    $highpass_band$1$i = $519 ? $highpass_band$010$i : $band$18$i;
    $520 = $513 < $516;
    $521 = $516 < $512;
    $or$cond17$i = $520 & $521;
    $522 = ($maxband$09$i|0)>($band$18$i|0);
    $523 = $522 ? $maxband$09$i : $band$18$i;
    $maxband$1$i = $or$cond17$i ? $523 : $maxband$09$i;
    $524 = (($band$18$i) + 1)|0;
    $exitcond14$i = ($524|0)==(32);
    if ($exitcond14$i) {
     $highpass_band$1$i$lcssa = $highpass_band$1$i;$maxband$1$i$lcssa = $maxband$1$i;
     break;
    } else {
     $band$18$i = $524;$highpass_band$010$i = $highpass_band$1$i;$maxband$09$i = $maxband$1$i;
    }
   }
   $525 = (+($highpass_band$1$i$lcssa|0));
   $526 = $525 * 0.032258064516129031;
   $527 = $526;
   HEAPF32[$510>>2] = $527;
   $528 = ($maxband$1$i$lcssa|0)==(-1);
   if ($528) {
    $529 = $525 + 0.75;
    $530 = $529 * 0.032258064516129031;
    $531 = $530;
    HEAPF32[$505>>2] = $531;
    $540 = $531;$band$27$i = 0;
    break;
   } else {
    $532 = (+($maxband$1$i$lcssa|0));
    $533 = $532 + 0.75;
    $534 = $533 * 0.032258064516129031;
    $535 = $534;
    HEAPF32[$505>>2] = $535;
    $540 = $535;$band$27$i = 0;
    break;
   }
  } else {
   $540 = $512;$band$27$i = 0;
  }
 } while(0);
 while(1) {
  $536 = (+($band$27$i|0));
  $537 = $536 * 0.032258063554763794;
  $538 = +HEAPF32[$510>>2];
  $539 = $540 > $538;
  do {
   if ($539) {
    $541 = $540 - $537;
    $542 = $541;
    $543 = $540 - $538;
    $544 = $543;
    $545 = $544 + 9.9999999999999995E-21;
    $546 = $542 / $545;
    $547 = $546;
    $548 = $547;
    $549 = $547 > 1.0;
    if ($549) {
     $fc1$0$i = 0.0;
     break;
    }
    $550 = !($547 <= 0.0);
    if (!($550)) {
     $fc1$0$i = 1.0;
     break;
    }
    $551 = $548 * 1.5707963267948966;
    $552 = (+Math_cos((+$551)));
    $553 = $552;
    $fc1$0$i = $553;
   } else {
    $fc1$0$i = 1.0;
   }
  } while(0);
  $554 = +HEAPF32[$470>>2];
  $555 = +HEAPF32[$469>>2];
  $556 = $554 > $555;
  do {
   if ($556) {
    $557 = $537 - $555;
    $558 = $557;
    $559 = $554 - $555;
    $560 = $559;
    $561 = $560 + 9.9999999999999995E-21;
    $562 = $558 / $561;
    $563 = $562;
    $564 = $563;
    $565 = $563 > 1.0;
    if ($565) {
     $fc2$0$i = 0.0;
     break;
    }
    $566 = !($563 <= 0.0);
    if (!($566)) {
     $fc2$0$i = 1.0;
     break;
    }
    $567 = $564 * 1.5707963267948966;
    $568 = (+Math_cos((+$567)));
    $569 = $568;
    $fc2$0$i = $569;
   } else {
    $fc2$0$i = 1.0;
   }
  } while(0);
  $570 = $fc2$0$i * $fc1$0$i;
  $571 = (((($1)) + 37040|0) + ($band$27$i<<2)|0);
  HEAPF32[$571>>2] = $570;
  $572 = (($band$27$i) + 1)|0;
  $exitcond$i = ($572|0)==(32);
  if ($exitcond$i) {
   break;
  }
  $$pre$i = +HEAPF32[$505>>2];
  $540 = $$pre$i;$band$27$i = $572;
 }
 $573 = HEAP32[$414>>2]|0;
 $574 = (_SmpFrqIndex($573,$2)|0);
 $575 = ((($1)) + 20|0);
 HEAP32[$575>>2] = $574;
 $576 = ($574|0)<(0);
 if ($576) {
  _freegfc($1);
  HEAP32[$0>>2] = 0;
  $$0 = -1;
  STACKTOP = sp;return ($$0|0);
 }
 $577 = HEAP32[$105>>2]|0;
 $578 = ($577|0)==(0);
 do {
  if ($578) {
   $579 = HEAP32[$580>>2]|0;
   $581 = ($579|0)==(0);
   if (!($581)) {
    $582 = ((($1)) + 84744|0);
    HEAP32[$582>>2] = 0;
    break;
   }
   $583 = ((($gfp)) + 96|0);
   $584 = HEAP32[$583>>2]|0;
   $585 = HEAP32[$2>>2]|0;
   $586 = HEAP32[$414>>2]|0;
   $587 = (_FindNearestBitrate($584,$585,$586)|0);
   HEAP32[$583>>2] = $587;
   $588 = HEAP32[$2>>2]|0;
   $589 = HEAP32[$414>>2]|0;
   $590 = (_BitrateIndex($587,$588,$589)|0);
   $591 = ((($1)) + 84744|0);
   HEAP32[$591>>2] = $590;
   $592 = ($590|0)<(1);
   if (!($592)) {
    break;
   }
   _freegfc($1);
   HEAP32[$0>>2] = 0;
   $$0 = -1;
   STACKTOP = sp;return ($$0|0);
  } else {
   $593 = ((($1)) + 84744|0);
   HEAP32[$593>>2] = 1;
  }
 } while(0);
 _init_bit_stream_w($1);
 $594 = HEAP32[$575>>2]|0;
 $595 = HEAP32[$2>>2]|0;
 $596 = ($595*3)|0;
 $597 = (($596) + ($594))|0;
 $598 = HEAP32[$414>>2]|0;
 $599 = ($598|0)<(16000);
 $600 = $599 ? 6 : 0;
 $601 = (($597) + ($600))|0;
 $602 = (12200 + (($601*204)|0)|0);
 $603 = HEAP32[$602>>2]|0;
 $604 = ((($1)) + 21360|0);
 HEAP32[$604>>2] = $603;
 $605 = (((12200 + (($601*204)|0)|0)) + 4|0);
 $606 = HEAP32[$605>>2]|0;
 $607 = ((($1)) + 21364|0);
 HEAP32[$607>>2] = $606;
 $608 = (((12200 + (($601*204)|0)|0)) + 8|0);
 $609 = HEAP32[$608>>2]|0;
 $610 = ((($1)) + 21368|0);
 HEAP32[$610>>2] = $609;
 $611 = (((12200 + (($601*204)|0)|0)) + 12|0);
 $612 = HEAP32[$611>>2]|0;
 $613 = ((($1)) + 21372|0);
 HEAP32[$613>>2] = $612;
 $614 = (((12200 + (($601*204)|0)|0)) + 16|0);
 $615 = HEAP32[$614>>2]|0;
 $616 = ((($1)) + 21376|0);
 HEAP32[$616>>2] = $615;
 $617 = (((12200 + (($601*204)|0)|0)) + 20|0);
 $618 = HEAP32[$617>>2]|0;
 $619 = ((($1)) + 21380|0);
 HEAP32[$619>>2] = $618;
 $620 = (((12200 + (($601*204)|0)|0)) + 24|0);
 $621 = HEAP32[$620>>2]|0;
 $622 = ((($1)) + 21384|0);
 HEAP32[$622>>2] = $621;
 $623 = (((12200 + (($601*204)|0)|0)) + 28|0);
 $624 = HEAP32[$623>>2]|0;
 $625 = ((($1)) + 21388|0);
 HEAP32[$625>>2] = $624;
 $626 = (((12200 + (($601*204)|0)|0)) + 32|0);
 $627 = HEAP32[$626>>2]|0;
 $628 = ((($1)) + 21392|0);
 HEAP32[$628>>2] = $627;
 $629 = (((12200 + (($601*204)|0)|0)) + 36|0);
 $630 = HEAP32[$629>>2]|0;
 $631 = ((($1)) + 21396|0);
 HEAP32[$631>>2] = $630;
 $632 = (((12200 + (($601*204)|0)|0)) + 40|0);
 $633 = HEAP32[$632>>2]|0;
 $634 = ((($1)) + 21400|0);
 HEAP32[$634>>2] = $633;
 $635 = (((12200 + (($601*204)|0)|0)) + 44|0);
 $636 = HEAP32[$635>>2]|0;
 $637 = ((($1)) + 21404|0);
 HEAP32[$637>>2] = $636;
 $638 = (((12200 + (($601*204)|0)|0)) + 48|0);
 $639 = HEAP32[$638>>2]|0;
 $640 = ((($1)) + 21408|0);
 HEAP32[$640>>2] = $639;
 $641 = (((12200 + (($601*204)|0)|0)) + 52|0);
 $642 = HEAP32[$641>>2]|0;
 $643 = ((($1)) + 21412|0);
 HEAP32[$643>>2] = $642;
 $644 = (((12200 + (($601*204)|0)|0)) + 56|0);
 $645 = HEAP32[$644>>2]|0;
 $646 = ((($1)) + 21416|0);
 HEAP32[$646>>2] = $645;
 $647 = (((12200 + (($601*204)|0)|0)) + 60|0);
 $648 = HEAP32[$647>>2]|0;
 $649 = ((($1)) + 21420|0);
 HEAP32[$649>>2] = $648;
 $650 = (((12200 + (($601*204)|0)|0)) + 64|0);
 $651 = HEAP32[$650>>2]|0;
 $652 = ((($1)) + 21424|0);
 HEAP32[$652>>2] = $651;
 $653 = (((12200 + (($601*204)|0)|0)) + 68|0);
 $654 = HEAP32[$653>>2]|0;
 $655 = ((($1)) + 21428|0);
 HEAP32[$655>>2] = $654;
 $656 = (((12200 + (($601*204)|0)|0)) + 72|0);
 $657 = HEAP32[$656>>2]|0;
 $658 = ((($1)) + 21432|0);
 HEAP32[$658>>2] = $657;
 $659 = (((12200 + (($601*204)|0)|0)) + 76|0);
 $660 = HEAP32[$659>>2]|0;
 $661 = ((($1)) + 21436|0);
 HEAP32[$661>>2] = $660;
 $662 = (((12200 + (($601*204)|0)|0)) + 80|0);
 $663 = HEAP32[$662>>2]|0;
 $664 = ((($1)) + 21440|0);
 HEAP32[$664>>2] = $663;
 $665 = (((12200 + (($601*204)|0)|0)) + 84|0);
 $666 = HEAP32[$665>>2]|0;
 $667 = ((($1)) + 21444|0);
 HEAP32[$667>>2] = $666;
 $668 = (((12200 + (($601*204)|0)|0)) + 88|0);
 $669 = HEAP32[$668>>2]|0;
 $670 = ((($1)) + 21448|0);
 HEAP32[$670>>2] = $669;
 $671 = (($669) - ($666))|0;
 $672 = (($671|0) / 6)&-1;
 $673 = ((($1)) + 21508|0);
 HEAP32[$673>>2] = $666;
 $674 = (($672) + ($666))|0;
 $675 = ((($1)) + 21512|0);
 HEAP32[$675>>2] = $674;
 $676 = $672 << 1;
 $677 = (($676) + ($666))|0;
 $678 = ((($1)) + 21516|0);
 HEAP32[$678>>2] = $677;
 $679 = ($672*3)|0;
 $680 = (($679) + ($666))|0;
 $681 = ((($1)) + 21520|0);
 HEAP32[$681>>2] = $680;
 $682 = $672 << 2;
 $683 = (($682) + ($666))|0;
 $684 = ((($1)) + 21524|0);
 HEAP32[$684>>2] = $683;
 $685 = ($672*5)|0;
 $686 = (($685) + ($666))|0;
 $687 = ((($1)) + 21528|0);
 HEAP32[$687>>2] = $686;
 $688 = ((($1)) + 21532|0);
 HEAP32[$688>>2] = 576;
 $689 = (((12200 + (($601*204)|0)|0)) + 92|0);
 $690 = HEAP32[$689>>2]|0;
 $691 = ((($1)) + 21452|0);
 HEAP32[$691>>2] = $690;
 $692 = (((12200 + (($601*204)|0)|0)) + 96|0);
 $693 = HEAP32[$692>>2]|0;
 $694 = ((($1)) + 21456|0);
 HEAP32[$694>>2] = $693;
 $695 = (((12200 + (($601*204)|0)|0)) + 100|0);
 $696 = HEAP32[$695>>2]|0;
 $697 = ((($1)) + 21460|0);
 HEAP32[$697>>2] = $696;
 $698 = (((12200 + (($601*204)|0)|0)) + 104|0);
 $699 = HEAP32[$698>>2]|0;
 $700 = ((($1)) + 21464|0);
 HEAP32[$700>>2] = $699;
 $701 = (((12200 + (($601*204)|0)|0)) + 108|0);
 $702 = HEAP32[$701>>2]|0;
 $703 = ((($1)) + 21468|0);
 HEAP32[$703>>2] = $702;
 $704 = (((12200 + (($601*204)|0)|0)) + 112|0);
 $705 = HEAP32[$704>>2]|0;
 $706 = ((($1)) + 21472|0);
 HEAP32[$706>>2] = $705;
 $707 = (((12200 + (($601*204)|0)|0)) + 116|0);
 $708 = HEAP32[$707>>2]|0;
 $709 = ((($1)) + 21476|0);
 HEAP32[$709>>2] = $708;
 $710 = (((12200 + (($601*204)|0)|0)) + 120|0);
 $711 = HEAP32[$710>>2]|0;
 $712 = ((($1)) + 21480|0);
 HEAP32[$712>>2] = $711;
 $713 = (((12200 + (($601*204)|0)|0)) + 124|0);
 $714 = HEAP32[$713>>2]|0;
 $715 = ((($1)) + 21484|0);
 HEAP32[$715>>2] = $714;
 $716 = (((12200 + (($601*204)|0)|0)) + 128|0);
 $717 = HEAP32[$716>>2]|0;
 $718 = ((($1)) + 21488|0);
 HEAP32[$718>>2] = $717;
 $719 = (((12200 + (($601*204)|0)|0)) + 132|0);
 $720 = HEAP32[$719>>2]|0;
 $721 = ((($1)) + 21492|0);
 HEAP32[$721>>2] = $720;
 $722 = (((12200 + (($601*204)|0)|0)) + 136|0);
 $723 = HEAP32[$722>>2]|0;
 $724 = ((($1)) + 21496|0);
 HEAP32[$724>>2] = $723;
 $725 = (((12200 + (($601*204)|0)|0)) + 140|0);
 $726 = HEAP32[$725>>2]|0;
 $727 = ((($1)) + 21500|0);
 HEAP32[$727>>2] = $726;
 $728 = (((12200 + (($601*204)|0)|0)) + 144|0);
 $729 = HEAP32[$728>>2]|0;
 $730 = ((($1)) + 21504|0);
 HEAP32[$730>>2] = $729;
 $731 = (($729) - ($726))|0;
 $732 = (($731|0) / 6)&-1;
 $733 = ((($1)) + 21536|0);
 HEAP32[$733>>2] = $726;
 $734 = (($732) + ($726))|0;
 $735 = ((($1)) + 21540|0);
 HEAP32[$735>>2] = $734;
 $736 = $732 << 1;
 $737 = (($736) + ($726))|0;
 $738 = ((($1)) + 21544|0);
 HEAP32[$738>>2] = $737;
 $739 = ($732*3)|0;
 $740 = (($739) + ($726))|0;
 $741 = ((($1)) + 21548|0);
 HEAP32[$741>>2] = $740;
 $742 = $732 << 2;
 $743 = (($742) + ($726))|0;
 $744 = ((($1)) + 21552|0);
 HEAP32[$744>>2] = $743;
 $745 = ($732*5)|0;
 $746 = (($745) + ($726))|0;
 $747 = ((($1)) + 21556|0);
 HEAP32[$747>>2] = $746;
 $748 = ((($1)) + 21560|0);
 HEAP32[$748>>2] = 192;
 $749 = HEAP32[$417>>2]|0;
 $750 = ($749|0)==(2);
 $751 = HEAP32[$142>>2]|0;
 $752 = ($751|0)==(1);
 $753 = $752 ? 13 : 21;
 $754 = $752 ? 21 : 36;
 $755 = $750 ? $754 : $753;
 $756 = ((($1)) + 24|0);
 HEAP32[$756>>2] = $755;
 $757 = HEAP32[$80>>2]|0;
 $758 = ($757|0)==(0);
 if (!($758)) {
  $759 = $755 | 2;
  HEAP32[$756>>2] = $759;
 }
 HEAP32[$1>>2] = -487877;
 $760 = ($749*700)|0;
 $761 = Math_imul($760, $751)|0;
 $762 = (+($761|0));
 $763 = ((($1)) + 39756|0);
 HEAPF32[$763>>2] = $762;
 $$pre69 = HEAP32[$417>>2]|0;
 $$pre70 = HEAP32[$142>>2]|0;
 $764 = ($$pre69*700)|0;
 $765 = Math_imul($764, $$pre70)|0;
 $766 = (+($765|0));
 $767 = ((($1)) + 39760|0);
 HEAPF32[$767>>2] = $766;
 $$pre69$1 = HEAP32[$417>>2]|0;
 $$pre70$1 = HEAP32[$142>>2]|0;
 $768 = ($$pre69$1*700)|0;
 $769 = Math_imul($768, $$pre70$1)|0;
 $770 = (+($769|0));
 $771 = ((($1)) + 39764|0);
 HEAPF32[$771>>2] = $770;
 $$pre69$2 = HEAP32[$417>>2]|0;
 $$pre70$2 = HEAP32[$142>>2]|0;
 $772 = ($$pre69$2*700)|0;
 $773 = Math_imul($772, $$pre70$2)|0;
 $774 = (+($773|0));
 $775 = ((($1)) + 39768|0);
 HEAPF32[$775>>2] = $774;
 $$pre69$3 = HEAP32[$417>>2]|0;
 $$pre70$3 = HEAP32[$142>>2]|0;
 $776 = ($$pre69$3*700)|0;
 $777 = Math_imul($776, $$pre70$3)|0;
 $778 = (+($777|0));
 $779 = ((($1)) + 39772|0);
 HEAPF32[$779>>2] = $778;
 $$pre69$4 = HEAP32[$417>>2]|0;
 $$pre70$4 = HEAP32[$142>>2]|0;
 $780 = ($$pre69$4*700)|0;
 $781 = Math_imul($780, $$pre70$4)|0;
 $782 = (+($781|0));
 $783 = ((($1)) + 39776|0);
 HEAPF32[$783>>2] = $782;
 $$pre69$5 = HEAP32[$417>>2]|0;
 $$pre70$5 = HEAP32[$142>>2]|0;
 $784 = ($$pre69$5*700)|0;
 $785 = Math_imul($784, $$pre70$5)|0;
 $786 = (+($785|0));
 $787 = ((($1)) + 39780|0);
 HEAPF32[$787>>2] = $786;
 $$pre69$6 = HEAP32[$417>>2]|0;
 $$pre70$6 = HEAP32[$142>>2]|0;
 $788 = ($$pre69$6*700)|0;
 $789 = Math_imul($788, $$pre70$6)|0;
 $790 = (+($789|0));
 $791 = ((($1)) + 39784|0);
 HEAPF32[$791>>2] = $790;
 $$pre69$7 = HEAP32[$417>>2]|0;
 $$pre70$7 = HEAP32[$142>>2]|0;
 $792 = ($$pre69$7*700)|0;
 $793 = Math_imul($792, $$pre70$7)|0;
 $794 = (+($793|0));
 $795 = ((($1)) + 39788|0);
 HEAPF32[$795>>2] = $794;
 $$pre69$8 = HEAP32[$417>>2]|0;
 $$pre70$8 = HEAP32[$142>>2]|0;
 $796 = ($$pre69$8*700)|0;
 $797 = Math_imul($796, $$pre70$8)|0;
 $798 = (+($797|0));
 $799 = ((($1)) + 39792|0);
 HEAPF32[$799>>2] = $798;
 $$pre69$9 = HEAP32[$417>>2]|0;
 $$pre70$9 = HEAP32[$142>>2]|0;
 $800 = ($$pre69$9*700)|0;
 $801 = Math_imul($800, $$pre70$9)|0;
 $802 = (+($801|0));
 $803 = ((($1)) + 39796|0);
 HEAPF32[$803>>2] = $802;
 $$pre69$10 = HEAP32[$417>>2]|0;
 $$pre70$10 = HEAP32[$142>>2]|0;
 $804 = ($$pre69$10*700)|0;
 $805 = Math_imul($804, $$pre70$10)|0;
 $806 = (+($805|0));
 $807 = ((($1)) + 39800|0);
 HEAPF32[$807>>2] = $806;
 $$pre69$11 = HEAP32[$417>>2]|0;
 $$pre70$11 = HEAP32[$142>>2]|0;
 $808 = ($$pre69$11*700)|0;
 $809 = Math_imul($808, $$pre70$11)|0;
 $810 = (+($809|0));
 $811 = ((($1)) + 39804|0);
 HEAPF32[$811>>2] = $810;
 $$pre69$12 = HEAP32[$417>>2]|0;
 $$pre70$12 = HEAP32[$142>>2]|0;
 $812 = ($$pre69$12*700)|0;
 $813 = Math_imul($812, $$pre70$12)|0;
 $814 = (+($813|0));
 $815 = ((($1)) + 39808|0);
 HEAPF32[$815>>2] = $814;
 $$pre69$13 = HEAP32[$417>>2]|0;
 $$pre70$13 = HEAP32[$142>>2]|0;
 $816 = ($$pre69$13*700)|0;
 $817 = Math_imul($816, $$pre70$13)|0;
 $818 = (+($817|0));
 $819 = ((($1)) + 39812|0);
 HEAPF32[$819>>2] = $818;
 $$pre69$14 = HEAP32[$417>>2]|0;
 $$pre70$14 = HEAP32[$142>>2]|0;
 $820 = ($$pre69$14*700)|0;
 $821 = Math_imul($820, $$pre70$14)|0;
 $822 = (+($821|0));
 $823 = ((($1)) + 39816|0);
 HEAPF32[$823>>2] = $822;
 $$pre69$15 = HEAP32[$417>>2]|0;
 $$pre70$15 = HEAP32[$142>>2]|0;
 $824 = ($$pre69$15*700)|0;
 $825 = Math_imul($824, $$pre70$15)|0;
 $826 = (+($825|0));
 $827 = ((($1)) + 39820|0);
 HEAPF32[$827>>2] = $826;
 $$pre69$16 = HEAP32[$417>>2]|0;
 $$pre70$16 = HEAP32[$142>>2]|0;
 $828 = ($$pre69$16*700)|0;
 $829 = Math_imul($828, $$pre70$16)|0;
 $830 = (+($829|0));
 $831 = ((($1)) + 39824|0);
 HEAPF32[$831>>2] = $830;
 $$pre69$17 = HEAP32[$417>>2]|0;
 $$pre70$17 = HEAP32[$142>>2]|0;
 $832 = ($$pre69$17*700)|0;
 $833 = Math_imul($832, $$pre70$17)|0;
 $834 = (+($833|0));
 $835 = ((($1)) + 39828|0);
 HEAPF32[$835>>2] = $834;
 $836 = ((($gfp)) + 220|0);
 $837 = HEAP32[$836>>2]|0;
 $838 = ($837|0)==(-1);
 if ($838) {
  HEAP32[$836>>2] = 4;
 }
 $839 = HEAP32[$105>>2]|0;
 do {
  if ((($839|0) == 4) | (($839|0) == 1)) {
   $840 = ((($gfp)) + 124|0);
   $841 = HEAP32[$840>>2]|0;
   $842 = ($841|0)<(0);
   if ($842) {
    HEAP32[$840>>2] = 2;
   }
   $843 = ((($gfp)) + 244|0);
   $844 = HEAP32[$843>>2]|0;
   $845 = ($844|0)<(0);
   if ($845) {
    HEAP32[$843>>2] = 0;
   }
   $846 = ((($gfp)) + 164|0);
   $847 = HEAP32[$846>>2]|0;
   $848 = Math_imul($847, -10)|0;
   $849 = (($848) + 500)|0;
   (_apply_preset($gfp,$849,0)|0);
   $850 = ((($gfp)) + 44|0);
   $851 = HEAP32[$850>>2]|0;
   $852 = ($851|0)<(0);
   do {
    if ($852) {
     HEAP32[$850>>2] = 3;
     label = 169;
    } else {
     $853 = ($851|0)<(5);
     if ($853) {
      label = 169;
      break;
     }
     $854 = ($851|0)>(7);
     if (!($854)) {
      break;
     }
     HEAP32[$850>>2] = 7;
    }
   } while(0);
   if ((label|0) == 169) {
    HEAP32[$850>>2] = 0;
   }
   $855 = ((($gfp)) + 140|0);
   $856 = HEAP32[$855>>2]|0;
   $857 = ($856|0)==(0);
   if ($857) {
    $858 = HEAP32[$414>>2]|0;
    $859 = ($858|0)>(44000);
    $860 = $859&1;
    $$sink54 = $860;
   } else {
    $$sink54 = 0;
   }
   $861 = ((($1)) + 85092|0);
   HEAP32[$861>>2] = $$sink54;
   $862 = ((($1)) + 85812|0);
   HEAP32[$862>>2] = 1;
  } else if ((($839|0) == 2)) {
   $863 = ((($gfp)) + 164|0);
   $864 = HEAP32[$863>>2]|0;
   $865 = Math_imul($864, -10)|0;
   $866 = (($865) + 500)|0;
   (_apply_preset($gfp,$866,0)|0);
   $867 = ((($gfp)) + 140|0);
   $868 = HEAP32[$867>>2]|0;
   $869 = ($868|0)==(0);
   if ($869) {
    $870 = HEAP32[$414>>2]|0;
    $871 = ($870|0)>(44000);
    $872 = $871&1;
    $$sink55 = $872;
   } else {
    $$sink55 = 0;
   }
   $873 = ((($1)) + 85092|0);
   HEAP32[$873>>2] = $$sink55;
   $874 = ((($gfp)) + 44|0);
   $875 = HEAP32[$874>>2]|0;
   $876 = ($875|0)>(6);
   do {
    if ($876) {
     HEAP32[$874>>2] = 6;
    } else {
     $877 = ($875|0)<(0);
     if (!($877)) {
      break;
     }
     HEAP32[$874>>2] = 3;
    }
   } while(0);
   $878 = ((($1)) + 85812|0);
   HEAP32[$878>>2] = 2;
  } else {
   $879 = ((($1)) + 85092|0);
   HEAP32[$879>>2] = 0;
   $880 = ((($gfp)) + 44|0);
   $881 = HEAP32[$880>>2]|0;
   $882 = ($881|0)<(0);
   if ($882) {
    HEAP32[$880>>2] = 3;
   }
   $883 = ($839|0)==(0);
   if ($883) {
    $884 = ((($gfp)) + 96|0);
    $885 = HEAP32[$884>>2]|0;
    (_lame_set_VBR_mean_bitrate_kbps($gfp,$885)|0);
   }
   $886 = ((($gfp)) + 168|0);
   $887 = HEAP32[$886>>2]|0;
   (_apply_preset($gfp,$887,0)|0);
   HEAP32[$105>>2] = $839;
   $888 = ((($1)) + 85812|0);
   if ($883) {
    HEAP32[$888>>2] = 3;
    break;
   } else {
    HEAP32[$888>>2] = 4;
    break;
   }
  }
 } while(0);
 $889 = ((($gfp)) + 200|0);
 $890 = HEAP32[$889>>2]|0;
 $891 = ((($1)) + 84912|0);
 HEAP32[$891>>2] = $890;
 $892 = ((($gfp)) + 204|0);
 $893 = HEAP32[$892>>2]|0;
 $894 = ((($1)) + 84916|0);
 HEAP32[$894>>2] = $893;
 $895 = ((($gfp)) + 256|0);
 $896 = HEAP32[$895>>2]|0;
 $897 = ($896|0)==(0);
 if (!($897)) {
  $898 = (HEAP32[tempDoublePtr>>2]=$893,+HEAPF32[tempDoublePtr>>2]);
  $899 = (HEAP32[tempDoublePtr>>2]=$890,+HEAPF32[tempDoublePtr>>2]);
  $900 = ((($gfp)) + 260|0);
  $901 = +HEAPF32[$900>>2];
  $902 = $899 + $901;
  HEAPF32[$891>>2] = $902;
  $903 = $898 + $901;
  HEAPF32[$894>>2] = $903;
 }
 $904 = HEAP32[$105>>2]|0;
 $905 = ($904|0)==(0);
 if ($905) {
  $$phi$trans$insert77 = ((($gfp)) + 168|0);
  $$pre78 = HEAP32[$$phi$trans$insert77>>2]|0;
  $947 = 0;$964 = $$pre78;
 } else {
  $906 = ((($1)) + 112|0);
  HEAP32[$906>>2] = 1;
  $907 = ((($1)) + 116|0);
  $908 = HEAP32[$414>>2]|0;
  $909 = ($908|0)<(16000);
  $$11 = $909 ? 8 : 14;
  HEAP32[$907>>2] = $$11;
  $910 = ((($gfp)) + 172|0);
  $911 = HEAP32[$910>>2]|0;
  $912 = ($911|0)==(0);
  do {
   if ($912) {
    $1210 = 1;
   } else {
    $913 = HEAP32[$2>>2]|0;
    $914 = (_FindNearestBitrate($911,$913,$908)|0);
    HEAP32[$910>>2] = $914;
    $915 = HEAP32[$2>>2]|0;
    $916 = HEAP32[$414>>2]|0;
    $917 = (_BitrateIndex($914,$915,$916)|0);
    HEAP32[$906>>2] = $917;
    $918 = ($917|0)<(0);
    if ($918) {
     $$0 = -1;
    } else {
     $1210 = $917;
     break;
    }
    STACKTOP = sp;return ($$0|0);
   }
  } while(0);
  $919 = ((($gfp)) + 176|0);
  $920 = HEAP32[$919>>2]|0;
  $921 = ($920|0)==(0);
  do {
   if ($921) {
    $$pre74 = HEAP32[$907>>2]|0;
    $931 = $1210;$934 = $$pre74;
   } else {
    $922 = HEAP32[$2>>2]|0;
    $923 = HEAP32[$414>>2]|0;
    $924 = (_FindNearestBitrate($920,$922,$923)|0);
    HEAP32[$919>>2] = $924;
    $925 = HEAP32[$2>>2]|0;
    $926 = HEAP32[$414>>2]|0;
    $927 = (_BitrateIndex($924,$925,$926)|0);
    HEAP32[$907>>2] = $927;
    $928 = ($927|0)<(0);
    if ($928) {
     $$0 = -1;
     STACKTOP = sp;return ($$0|0);
    } else {
     $$pre72 = HEAP32[$906>>2]|0;
     $931 = $$pre72;$934 = $927;
     break;
    }
   }
  } while(0);
  $929 = HEAP32[$2>>2]|0;
  $930 = ((83944 + ($929<<6)|0) + ($931<<2)|0);
  $932 = HEAP32[$930>>2]|0;
  HEAP32[$910>>2] = $932;
  $933 = ((83944 + ($929<<6)|0) + ($934<<2)|0);
  $935 = HEAP32[$933>>2]|0;
  HEAP32[$919>>2] = $935;
  $936 = ((($gfp)) + 168|0);
  $937 = HEAP32[$936>>2]|0;
  $938 = ($935|0)<($937|0);
  $$12 = $938 ? $935 : $937;
  $939 = ($932|0)>($$12|0);
  $940 = $939 ? $932 : $$12;
  HEAP32[$936>>2] = $940;
  $$pre75 = HEAP32[$105>>2]|0;
  $947 = $$pre75;$964 = $940;
 }
 $941 = ((($gfp)) + 152|0);
 $942 = HEAP32[$941>>2]|0;
 $943 = ((($1)) + 100|0);
 HEAP32[$943>>2] = $942;
 $944 = HEAP32[$372>>2]|0;
 $945 = ((($1)) + 156|0);
 HEAP32[$945>>2] = $944;
 $946 = ((($1)) + 104|0);
 HEAP32[$946>>2] = $947;
 $948 = ((($gfp)) + 80|0);
 $949 = HEAP32[$948>>2]|0;
 $950 = ((($1)) + 85096|0);
 HEAP32[$950>>2] = $949;
 $951 = ((($gfp)) + 84|0);
 $952 = HEAP32[$951>>2]|0;
 $953 = ((($1)) + 28|0);
 HEAP32[$953>>2] = $952;
 $954 = ((($gfp)) + 88|0);
 $955 = HEAP32[$954>>2]|0;
 $956 = ((($1)) + 32|0);
 HEAP32[$956>>2] = $955;
 $957 = ((($gfp)) + 92|0);
 $958 = HEAP32[$957>>2]|0;
 $959 = ((($1)) + 36|0);
 HEAP32[$959>>2] = $958;
 $960 = ((($gfp)) + 96|0);
 $961 = HEAP32[$960>>2]|0;
 $962 = ((($1)) + 120|0);
 HEAP32[$962>>2] = $961;
 $963 = ((($1)) + 108|0);
 HEAP32[$963>>2] = $964;
 $965 = ((($gfp)) + 100|0);
 $966 = HEAP32[$965>>2]|0;
 $967 = ((($1)) + 244|0);
 HEAP32[$967>>2] = $966;
 $968 = HEAP32[$0>>2]|0;
 $969 = ((($gfp)) + 44|0);
 $970 = HEAP32[$969>>2]|0;
 switch ($970|0) {
 case 6:  {
  $977 = ((($968)) + 28|0);
  $978 = HEAP32[$977>>2]|0;
  $979 = ($978|0)==(0);
  if ($979) {
   HEAP32[$977>>2] = 1;
  }
  $980 = ((($968)) + 40|0);
  HEAP32[$980>>2] = 0;
  $981 = ((($968)) + 44|0);
  HEAP32[$981>>2] = 0;
  $982 = ((($968)) + 32|0);
  $983 = HEAP32[$982>>2]|0;
  $984 = ($983|0)==(-1);
  if ($984) {
   HEAP32[$982>>2] = 1;
  }
  $985 = ((($968)) + 36|0);
  HEAP32[$985>>2] = 0;
  $986 = ((($968)) + 48|0);
  HEAP32[$986>>2] = 0;
  break;
 }
 case 5:  {
  $987 = ((($968)) + 28|0);
  $988 = HEAP32[$987>>2]|0;
  $989 = ($988|0)==(0);
  if ($989) {
   HEAP32[$987>>2] = 1;
  }
  $990 = ((($968)) + 40|0);
  HEAP32[$990>>2] = 0;
  $991 = ((($968)) + 44|0);
  HEAP32[$991>>2] = 0;
  $992 = ((($968)) + 32|0);
  $993 = HEAP32[$992>>2]|0;
  $994 = ($993|0)==(-1);
  if ($994) {
   HEAP32[$992>>2] = 1;
  }
  $995 = ((($968)) + 36|0);
  HEAP32[$995>>2] = 0;
  $996 = ((($968)) + 48|0);
  HEAP32[$996>>2] = 0;
  break;
 }
 case 8:  {
  HEAP32[$969>>2] = 7;
  label = 203;
  break;
 }
 case 7:  {
  label = 203;
  break;
 }
 case 3:  {
  $1007 = ((($968)) + 28|0);
  $1008 = HEAP32[$1007>>2]|0;
  $1009 = ($1008|0)==(0);
  if ($1009) {
   HEAP32[$1007>>2] = 1;
  }
  $1010 = ((($968)) + 40|0);
  HEAP32[$1010>>2] = 1;
  $1011 = ((($968)) + 44|0);
  HEAP32[$1011>>2] = 1;
  $1012 = ((($968)) + 32|0);
  $1013 = HEAP32[$1012>>2]|0;
  $1014 = ($1013|0)==(-1);
  if ($1014) {
   HEAP32[$1012>>2] = 1;
  }
  $1015 = ((($968)) + 36|0);
  HEAP32[$1015>>2] = 1;
  $1016 = ((($968)) + 48|0);
  HEAP32[$1016>>2] = 0;
  break;
 }
 case 4:  {
  $997 = ((($968)) + 28|0);
  $998 = HEAP32[$997>>2]|0;
  $999 = ($998|0)==(0);
  if ($999) {
   HEAP32[$997>>2] = 1;
  }
  $1000 = ((($968)) + 40|0);
  HEAP32[$1000>>2] = 0;
  $1001 = ((($968)) + 44|0);
  HEAP32[$1001>>2] = 0;
  $1002 = ((($968)) + 32|0);
  $1003 = HEAP32[$1002>>2]|0;
  $1004 = ($1003|0)==(-1);
  if ($1004) {
   HEAP32[$1002>>2] = 1;
  }
  $1005 = ((($968)) + 36|0);
  HEAP32[$1005>>2] = 1;
  $1006 = ((($968)) + 48|0);
  HEAP32[$1006>>2] = 0;
  break;
 }
 case 1:  {
  $1030 = ((($968)) + 28|0);
  $1031 = HEAP32[$1030>>2]|0;
  $1032 = ($1031|0)==(0);
  if ($1032) {
   HEAP32[$1030>>2] = 1;
  }
  $1033 = ((($968)) + 85096|0);
  $1034 = HEAP32[$1033>>2]|0;
  $1035 = ($1034|0)==(0);
  if ($1035) {
   HEAP32[$1033>>2] = 2;
  }
  $1036 = ((($968)) + 40|0);
  HEAP32[$1036>>2] = 2;
  $1037 = ((($968)) + 44|0);
  HEAP32[$1037>>2] = 1;
  $1038 = ((($968)) + 32|0);
  $1039 = HEAP32[$1038>>2]|0;
  $1040 = ($1039|0)==(-1);
  if ($1040) {
   HEAP32[$1038>>2] = 1;
  }
  $1041 = ((($968)) + 36|0);
  HEAP32[$1041>>2] = 1;
  $1042 = ((($968)) + 48|0);
  HEAP32[$1042>>2] = 0;
  break;
 }
 case 2:  {
  $1017 = ((($968)) + 28|0);
  $1018 = HEAP32[$1017>>2]|0;
  $1019 = ($1018|0)==(0);
  if ($1019) {
   HEAP32[$1017>>2] = 1;
  }
  $1020 = ((($968)) + 85096|0);
  $1021 = HEAP32[$1020>>2]|0;
  $1022 = ($1021|0)==(0);
  if ($1022) {
   HEAP32[$1020>>2] = 2;
  }
  $1023 = ((($968)) + 40|0);
  HEAP32[$1023>>2] = 1;
  $1024 = ((($968)) + 44|0);
  HEAP32[$1024>>2] = 1;
  $1025 = ((($968)) + 32|0);
  $1026 = HEAP32[$1025>>2]|0;
  $1027 = ($1026|0)==(-1);
  if ($1027) {
   HEAP32[$1025>>2] = 1;
  }
  $1028 = ((($968)) + 36|0);
  HEAP32[$1028>>2] = 1;
  $1029 = ((($968)) + 48|0);
  HEAP32[$1029>>2] = 0;
  break;
 }
 case 0:  {
  $1043 = ((($968)) + 28|0);
  $1044 = HEAP32[$1043>>2]|0;
  $1045 = ($1044|0)==(0);
  if ($1045) {
   HEAP32[$1043>>2] = 1;
  }
  $1046 = ((($968)) + 85096|0);
  $1047 = HEAP32[$1046>>2]|0;
  $1048 = ($1047|0)==(0);
  if ($1048) {
   HEAP32[$1046>>2] = 2;
  }
  $1049 = ((($968)) + 40|0);
  HEAP32[$1049>>2] = 2;
  $1050 = ((($968)) + 44|0);
  HEAP32[$1050>>2] = 1;
  $1051 = ((($968)) + 32|0);
  $1052 = HEAP32[$1051>>2]|0;
  $1053 = ($1052|0)==(-1);
  if ($1053) {
   HEAP32[$1051>>2] = 1;
  }
  $1054 = ((($968)) + 36|0);
  HEAP32[$1054>>2] = 1;
  $1055 = ((($968)) + 48|0);
  HEAP32[$1055>>2] = 1;
  break;
 }
 default: {
  $971 = ((($968)) + 28|0);
  HEAP32[$971>>2] = 0;
  $972 = ((($968)) + 36|0);
  ;HEAP32[$972>>2]=0|0;HEAP32[$972+4>>2]=0|0;HEAP32[$972+8>>2]=0|0;HEAP32[$972+12>>2]=0|0;
 }
 }
 do {
  if ((label|0) == 203) {
   $973 = ((($968)) + 28|0);
   HEAP32[$973>>2] = 0;
   $974 = ((($968)) + 36|0);
   $975 = ((($968)) + 48|0);
   ;HEAP32[$974>>2]=0|0;HEAP32[$974+4>>2]=0|0;HEAP32[$974+8>>2]=0|0;HEAP32[$974+12>>2]=0|0;
   $976 = HEAP32[$105>>2]|0;
   if (!((($976|0) == 4) | (($976|0) == 1))) {
    break;
   }
   HEAP32[$975>>2] = -1;
  }
 } while(0);
 $1056 = ((($gfp)) + 232|0);
 $1057 = HEAP32[$1056>>2]|0;
 $1058 = ($1057|0)<(0);
 $1059 = HEAP32[$68>>2]|0;
 $$30 = $1058 ? 3 : $1057;
 HEAP32[$1059>>2] = $$30;
 $1060 = ((($gfp)) + 236|0);
 $1061 = +HEAPF32[$1060>>2];
 $1062 = $1061;
 $1063 = $1062 * -0.10000000000000001;
 $1064 = (+Math_pow(10.0,(+$1063)));
 $1065 = $1064;
 $1066 = ((($1059)) + 4|0);
 HEAPF32[$1066>>2] = $1065;
 $1067 = ((($gfp)) + 240|0);
 $1068 = HEAP32[$1067>>2]|0;
 if ((($1068|0) == -1)) {
  HEAP32[$1067>>2] = 0;
  label = 248;
 } else if ((($1068|0) == 0)) {
  label = 248;
 } else {
  $1071 = $1068;
 }
 do {
  if ((label|0) == 248) {
   $1069 = HEAP32[$449>>2]|0;
   $switch = ($1069>>>0)<(2);
   if (!($switch)) {
    $1071 = 0;
    break;
   }
   HEAP32[$1067>>2] = 1;
   $1071 = 1;
  }
 } while(0);
 $1070 = ((($1)) + 184|0);
 HEAP32[$1070>>2] = $1071;
 $1072 = (_lame_get_quant_comp($gfp)|0);
 $1073 = ($1072|0)<(0);
 if ($1073) {
  (_lame_set_quant_comp($gfp,1)|0);
 }
 $1074 = (_lame_get_quant_comp_short($gfp)|0);
 $1075 = ($1074|0)<(0);
 if ($1075) {
  (_lame_set_quant_comp_short($gfp,0)|0);
 }
 $1076 = (+_lame_get_msfix($gfp));
 $1077 = $1076 < 0.0;
 if ($1077) {
  _lame_set_msfix($gfp,0.0);
 }
 $1078 = (_lame_get_exp_nspsytune($gfp)|0);
 $1079 = $1078 | 1;
 (_lame_set_exp_nspsytune($gfp,$1079)|0);
 $1080 = HEAP32[$836>>2]|0;
 $1081 = ($1080|0)<(0);
 if ($1081) {
  HEAP32[$836>>2] = 4;
  $1108 = 4;
 } else {
  $1108 = $1080;
 }
 $1082 = ((($gfp)) + 224|0);
 $1083 = +HEAPF32[$1082>>2];
 $1084 = $1083 < 0.0;
 $1085 = (HEAPF32[tempDoublePtr>>2]=$1083,HEAP32[tempDoublePtr>>2]|0);
 if ($1084) {
  HEAPF32[$1082>>2] = 4.0;
  $1106 = 1082130432;
 } else {
  $1106 = $1085;
 }
 $1086 = ((($gfp)) + 248|0);
 $1087 = +HEAPF32[$1086>>2];
 $1088 = $1087 < 0.0;
 $1089 = (HEAPF32[tempDoublePtr>>2]=$1087,HEAP32[tempDoublePtr>>2]|0);
 if ($1088) {
  HEAPF32[$1086>>2] = 0.0;
  $1094 = 0;
 } else {
  $1094 = $1089;
 }
 $1090 = ((($gfp)) + 244|0);
 $1091 = HEAP32[$1090>>2]|0;
 $1092 = ($1091|0)<(0);
 if ($1092) {
  HEAP32[$1090>>2] = 1;
  $1125 = 1;
 } else {
  $1125 = $1091;
 }
 $1093 = ((($1)) + 188|0);
 HEAP32[$1093>>2] = $1094;
 $1095 = ((($gfp)) + 252|0);
 $1096 = HEAP32[$1095>>2]|0;
 $1097 = ((($1)) + 192|0);
 HEAP32[$1097>>2] = $1096;
 $1098 = ((($gfp)) + 228|0);
 $1099 = +HEAPF32[$1098>>2];
 $1100 = -$1099;
 $1101 = ((($1)) + 196|0);
 HEAPF32[$1101>>2] = $1100;
 $1102 = $1099 * -0.10000000149011612;
 $1103 = (+Math_pow(10.0,(+$1102)));
 $1104 = ((($1)) + 200|0);
 HEAPF32[$1104>>2] = $1103;
 $1105 = ((($1)) + 204|0);
 HEAP32[$1105>>2] = $1106;
 $1107 = ((($1)) + 208|0);
 HEAP32[$1107>>2] = $1108;
 $1109 = ((($gfp)) + 208|0);
 $1110 = HEAP32[$1109>>2]|0;
 $1111 = ((($1)) + 212|0);
 HEAP32[$1111>>2] = $1110;
 $1112 = ((($gfp)) + 212|0);
 $1113 = HEAP32[$1112>>2]|0;
 $1114 = ((($1)) + 216|0);
 HEAP32[$1114>>2] = $1113;
 $1115 = ((($gfp)) + 216|0);
 $1116 = HEAP32[$1115>>2]|0;
 $1117 = ((($1)) + 220|0);
 HEAP32[$1117>>2] = $1116;
 $1118 = ((($gfp)) + 132|0);
 $1119 = HEAP32[$1118>>2]|0;
 $1120 = ((($1)) + 84|0);
 HEAP32[$1120>>2] = $1119;
 $1121 = ((($gfp)) + 136|0);
 $1122 = HEAP32[$1121>>2]|0;
 $1123 = ((($1)) + 88|0);
 HEAP32[$1123>>2] = $1122;
 $1124 = ((($1)) + 92|0);
 HEAP32[$1124>>2] = $1125;
 $1126 = ((($gfp)) + 148|0);
 $1127 = HEAP32[$1126>>2]|0;
 $1128 = $1127 & 2;
 $1129 = ((($1)) + 96|0);
 HEAP32[$1129>>2] = $1128;
 $1130 = $1127 >>> 2;
 $1131 = $1130 & 63;
 $1132 = (+($1131|0));
 $1133 = ((($1)) + 232|0);
 $1134 = !($1132 >= 32.0);
 $1135 = $1132 + -64.0;
 $storemerge4 = $1134 ? $1132 : $1135;
 $1136 = $storemerge4 * 0.25;
 HEAPF32[$1133>>2] = $1136;
 $1137 = $1127 >>> 8;
 $1138 = $1137 & 63;
 $1139 = (+($1138|0));
 $1140 = ((($1)) + 228|0);
 $1141 = !($1139 >= 32.0);
 $1142 = $1139 + -64.0;
 $storemerge3 = $1141 ? $1139 : $1142;
 $1143 = $storemerge3 * 0.25;
 HEAPF32[$1140>>2] = $1143;
 $1144 = $1127 >>> 14;
 $1145 = $1144 & 63;
 $1146 = (+($1145|0));
 $1147 = ((($1)) + 236|0);
 $1148 = !($1146 >= 32.0);
 $1149 = $1146 + -64.0;
 $storemerge2 = $1148 ? $1146 : $1149;
 $1150 = $storemerge2 * 0.25;
 HEAPF32[$1147>>2] = $1150;
 $1151 = $1127 >>> 20;
 $1152 = $1151 & 63;
 $1153 = (+($1152|0));
 $1154 = ((($1)) + 240|0);
 $1155 = !($1153 >= 32.0);
 $1156 = $1153 + -64.0;
 $storemerge1 = $1155 ? $1153 : $1156;
 $1157 = $storemerge1 + $storemerge2;
 $1158 = $1157 * 0.25;
 HEAPF32[$1154>>2] = $1158;
 $1159 = ((($gfp)) + 20|0);
 $1160 = +HEAPF32[$1159>>2];
 $1161 = ((($gfp)) + 24|0);
 $1162 = +HEAPF32[$1161>>2];
 $1163 = $1162 * $1160;
 $1164 = ((($gfp)) + 28|0);
 $1165 = +HEAPF32[$1164>>2];
 $1166 = $1165 * $1160;
 $1167 = HEAP32[$95>>2]|0;
 $1168 = ($1167|0)==(2);
 do {
  if ($1168) {
   $1169 = HEAP32[$142>>2]|0;
   $1170 = ($1169|0)==(1);
   if (!($1170)) {
    $m10$sroa$0$0 = $1163;$m10$sroa$22$0 = $1166;$m10$sroa$8$0 = 0.0;
    break;
   }
   $1171 = $1163 * 0.5;
   $1172 = $1166 * 0.5;
   $m10$sroa$0$0 = $1171;$m10$sroa$22$0 = 0.0;$m10$sroa$8$0 = $1172;
  } else {
   $m10$sroa$0$0 = $1163;$m10$sroa$22$0 = $1166;$m10$sroa$8$0 = 0.0;
  }
 } while(0);
 $1173 = ((($1)) + 264|0);
 HEAPF32[$1173>>2] = $m10$sroa$0$0;
 $1174 = ((($1)) + 268|0);
 HEAPF32[$1174>>2] = $m10$sroa$8$0;
 $1175 = ((($1)) + 272|0);
 HEAPF32[$1175>>2] = 0.0;
 $1176 = ((($1)) + 276|0);
 HEAPF32[$1176>>2] = $m10$sroa$22$0;
 $1177 = ((($1)) + 39832|0);
 HEAP32[$1177>>2] = 0;
 $1178 = ((($1)) + 39836|0);
 HEAP32[$1178>>2] = 0;
 $1179 = HEAP32[$946>>2]|0;
 $1180 = ($1179|0)==(0);
 if ($1180) {
  $1181 = HEAP32[$2>>2]|0;
  $1182 = ($1181*72000)|0;
  $1183 = (($1182) + 72000)|0;
  $1184 = HEAP32[$962>>2]|0;
  $1185 = Math_imul($1183, $1184)|0;
  $1186 = HEAP32[$414>>2]|0;
  $1187 = (($1185|0) % ($1186|0))&-1;
  HEAP32[$1177>>2] = $1187;
  HEAP32[$1178>>2] = $1187;
 }
 $1188 = HEAP32[$gfp>>2]|0;
 $1189 = ($1188|0)==(-487877);
 do {
  if ($1189) {
   $1190 = HEAP32[$0>>2]|0;
   $1191 = ($1190|0)==(0|0);
   if ($1191) {
    break;
   }
   $1192 = ((($1190)) + 84040|0);
   $1193 = ((($1190)) + 84748|0);
   HEAP32[$1193>>2] = 0;
   $1194 = ((($gfp)) + 68|0);
   $1195 = HEAP32[$1194>>2]|0;
   $1196 = ($1195|0)==(0);
   if (!($1196)) {
    (_id3tag_write_v2($gfp)|0);
   }
   $1197 = ((($1190)) + 85684|0);
   HEAPF32[$1197>>2] = 0.0;
   $1198 = ((($1190)) + 156|0);
   _memset(($1192|0),0,704)|0;
   $1199 = HEAP32[$1198>>2]|0;
   $1200 = ($1199|0)==(0);
   if ($1200) {
    break;
   }
   (_InitVbrTag($gfp)|0);
  }
 } while(0);
 _iteration_init($1);
 (_psymodel_init($gfp)|0);
 $1201 = ((($gfp)) + 124|0);
 $1202 = HEAP32[$1201>>2]|0;
 $1203 = (_get_max_frame_buffer_size_by_constraint($2,$1202)|0);
 $1204 = ((($1)) + 148|0);
 HEAP32[$1204>>2] = $1203;
 $$0 = 0;
 STACKTOP = sp;return ($$0|0);
}
function _lame_encode_buffer_ieee_float($gfp,$pcm_l,$pcm_r,$nsamples,$mp3buf,$mp3buf_size) {
 $gfp = $gfp|0;
 $pcm_l = $pcm_l|0;
 $pcm_r = $pcm_r|0;
 $nsamples = $nsamples|0;
 $mp3buf = $mp3buf|0;
 $mp3buf_size = $mp3buf_size|0;
 var $0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_lame_encode_buffer_template($gfp,$pcm_l,$pcm_r,$nsamples,$mp3buf,$mp3buf_size,3,1,32767.0)|0);
 return ($0|0);
}
function _lame_encode_flush($gfp,$mp3buffer,$mp3buffer_size) {
 $gfp = $gfp|0;
 $mp3buffer = $mp3buffer|0;
 $mp3buffer_size = $mp3buffer_size|0;
 var $$ = 0, $$$ = 0, $$0 = 0, $$04$lcssa16 = 0, $$0411 = 0, $$1 = 0, $$2 = 0, $$3 = 0, $$5 = 0, $$6 = 0, $$lcssa = 0, $$lcssa24 = 0, $$lcssa25 = 0, $$pre = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 var $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0.0, $22 = 0, $23 = 0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0.0, $29 = 0, $3 = 0, $30 = 0, $31 = 0;
 var $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0.0, $45 = 0.0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0;
 var $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0;
 var $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $8 = 0, $9 = 0, $buffer = 0, $frames_left$09 = 0, $mp3count$0$lcssa17 = 0, $mp3count$010 = 0, $resample_ratio$0 = 0.0, $samples_to_encode$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 4608|0;
 $buffer = sp;
 $0 = ($gfp|0)==(0|0);
 if ($0) {
  $$0 = -3;
  STACKTOP = sp;return ($$0|0);
 }
 $1 = HEAP32[$gfp>>2]|0;
 $2 = ($1|0)==(-487877);
 if (!($2)) {
  $$0 = -3;
  STACKTOP = sp;return ($$0|0);
 }
 $3 = ((($gfp)) + 288|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ($4|0)==(0|0);
 if ($5) {
  $$0 = -3;
  STACKTOP = sp;return ($$0|0);
 }
 $6 = HEAP32[$4>>2]|0;
 $7 = ($6|0)==(-487877);
 if (!($7)) {
  $$0 = -3;
  STACKTOP = sp;return ($$0|0);
 }
 $8 = ((($4)) + 84032|0);
 $9 = HEAP32[$8>>2]|0;
 $10 = ($9|0)<(1);
 if ($10) {
  $$0 = 0;
  STACKTOP = sp;return ($$0|0);
 }
 $11 = ((($4)) + 16|0);
 $12 = ((($4)) + 76|0);
 $13 = HEAP32[$12>>2]|0;
 $14 = ($13*576)|0;
 $15 = (($14) + 752)|0;
 $16 = (($9) + -1152)|0;
 _memset(($buffer|0),0,4608)|0;
 $17 = (_isResamplingNecessary($11)|0);
 $18 = ($17|0)==(0);
 if ($18) {
  $resample_ratio$0 = 1.0;$samples_to_encode$0 = $16;
 } else {
  $19 = ((($4)) + 60|0);
  $20 = HEAP32[$19>>2]|0;
  $21 = (+($20|0));
  $22 = ((($4)) + 64|0);
  $23 = HEAP32[$22>>2]|0;
  $24 = (+($23|0));
  $25 = $21 / $24;
  $26 = 16.0 / $25;
  $27 = (+($16|0));
  $28 = $26 + $27;
  $29 = (~~(($28)));
  $resample_ratio$0 = $25;$samples_to_encode$0 = $29;
 }
 $30 = (($samples_to_encode$0|0) % ($14|0))&-1;
 $31 = (($14) - ($30))|0;
 $32 = ($31|0)<(576);
 $33 = $32 ? $14 : 0;
 $$5 = (($33) + ($31))|0;
 $34 = ((($4)) + 84764|0);
 HEAP32[$34>>2] = $$5;
 $35 = (($$5) + ($samples_to_encode$0))|0;
 $36 = (($35|0) / ($14|0))&-1;
 $37 = ($36|0)>(0);
 if ($37) {
  $38 = ((($4)) + 84748|0);
  $39 = ((($4)) + 84036|0);
  $40 = ($mp3buffer_size|0)==(0);
  $41 = ((($buffer)) + 2304|0);
  $$pre = HEAP32[$38>>2]|0;
  $$0411 = $mp3buffer;$54 = $$pre;$frames_left$09 = $36;$mp3count$010 = 0;
  while(1) {
   $42 = HEAP32[$39>>2]|0;
   $43 = (($15) - ($42))|0;
   $44 = (+($43|0));
   $45 = $44 * $resample_ratio$0;
   $46 = (~~(($45)));
   $47 = ($46|0)>(1152);
   $$ = $47 ? 1152 : $46;
   $48 = ($$|0)<(1);
   $$$ = $48 ? 1 : $$;
   $49 = (($mp3buffer_size) - ($mp3count$010))|0;
   $$1 = $40 ? 0 : $49;
   $50 = (_lame_encode_buffer_template($gfp,$buffer,$41,$$$,$$0411,$$1,0,1,1.0)|0);
   $51 = (($$0411) + ($50)|0);
   $52 = (($50) + ($mp3count$010))|0;
   $53 = HEAP32[$38>>2]|0;
   $55 = ($54|0)!=($53|0);
   $56 = $55&1;
   $57 = (($frames_left$09) - ($56))|0;
   $58 = ($57|0)>(0);
   $59 = ($50|0)>(-1);
   $60 = $58 & $59;
   if ($60) {
    $$0411 = $51;$54 = $53;$frames_left$09 = $57;$mp3count$010 = $52;
   } else {
    $$lcssa = $50;$$lcssa24 = $51;$$lcssa25 = $52;
    break;
   }
  }
  HEAP32[$8>>2] = 0;
  $61 = ($$lcssa|0)<(0);
  if ($61) {
   $$0 = $$lcssa;
   STACKTOP = sp;return ($$0|0);
  } else {
   $$04$lcssa16 = $$lcssa24;$mp3count$0$lcssa17 = $$lcssa25;
  }
 } else {
  HEAP32[$8>>2] = 0;
  $$04$lcssa16 = $mp3buffer;$mp3count$0$lcssa17 = 0;
 }
 $62 = (($mp3buffer_size) - ($mp3count$0$lcssa17))|0;
 $63 = ($mp3buffer_size|0)==(0);
 $$2 = $63 ? 0 : $62;
 _flush_bitstream($4);
 $64 = (_copy_buffer($4,$$04$lcssa16,$$2,1)|0);
 _save_gain_values($4);
 $65 = ($64|0)<(0);
 if ($65) {
  $$0 = $64;
  STACKTOP = sp;return ($$0|0);
 }
 $66 = (($64) + ($mp3count$0$lcssa17))|0;
 $67 = ((($gfp)) + 68|0);
 $68 = HEAP32[$67>>2]|0;
 $69 = ($68|0)==(0);
 if ($69) {
  $$0 = $66;
  STACKTOP = sp;return ($$0|0);
 }
 $70 = (($mp3buffer_size) - ($66))|0;
 $$3 = $63 ? 0 : $70;
 $71 = (($$04$lcssa16) + ($64)|0);
 (_id3tag_write_v1($gfp)|0);
 $72 = (_copy_buffer($4,$71,$$3,0)|0);
 $73 = ($72|0)<(0);
 $74 = $73 ? 0 : $66;
 $$6 = (($74) + ($72))|0;
 $$0 = $$6;
 STACKTOP = sp;return ($$0|0);
}
function _lame_close($gfp) {
 $gfp = $gfp|0;
 var $$ = 0, $0 = 0, $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $ret$02 = 0, $ret$1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($gfp|0)==(0|0);
 if ($0) {
  $ret$1 = 0;
  return ($ret$1|0);
 }
 $1 = HEAP32[$gfp>>2]|0;
 $2 = ($1|0)==(-487877);
 if (!($2)) {
  $ret$1 = 0;
  return ($ret$1|0);
 }
 $3 = ((($gfp)) + 288|0);
 $4 = HEAP32[$3>>2]|0;
 HEAP32[$gfp>>2] = 0;
 $5 = ($4|0)==(0|0);
 if ($5) {
  $ret$02 = -3;
 } else {
  $6 = HEAP32[$4>>2]|0;
  $7 = ($6|0)==(-487877);
  $$ = $7 ? 0 : -3;
  HEAP32[$4>>2] = 0;
  _freegfc($4);
  HEAP32[$3>>2] = 0;
  $ret$02 = $$;
 }
 $8 = ((($gfp)) + 284|0);
 $9 = HEAP32[$8>>2]|0;
 $10 = ($9|0)==(0);
 if ($10) {
  $ret$1 = $ret$02;
  return ($ret$1|0);
 }
 _free($gfp);
 $ret$1 = $ret$02;
 return ($ret$1|0);
}
function _lame_init() {
 var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0;
 var $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0;
 var $62 = 0, $63 = 0, $64 = 0, $65 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 _init_log_table();
 $0 = (_calloc(1,304)|0);
 $1 = ($0|0)==(0|0);
 if ($1) {
  $$0 = 0;
  return ($$0|0);
 }
 _memset(($0|0),0,304)|0;
 HEAP32[$0>>2] = -487877;
 $2 = (_calloc(1,85840)|0);
 $3 = ((($0)) + 288|0);
 HEAP32[$3>>2] = $2;
 $4 = ($2|0)==(0|0);
 if ($4) {
  _free($0);
  $$0 = 0;
  return ($$0|0);
 } else {
  $5 = ((($0)) + 124|0);
  HEAP32[$5>>2] = 2;
  $6 = ((($0)) + 48|0);
  HEAP32[$6>>2] = 4;
  $7 = ((($0)) + 108|0);
  HEAP32[$7>>2] = 1;
  $8 = ((($0)) + 12|0);
  HEAP32[$8>>2] = 44100;
  $9 = ((($0)) + 8|0);
  HEAP32[$9>>2] = 2;
  $10 = ((($0)) + 4|0);
  HEAP32[$10>>2] = -1;
  $11 = ((($0)) + 36|0);
  HEAP32[$11>>2] = 1;
  $12 = ((($0)) + 44|0);
  HEAP32[$12>>2] = -1;
  $13 = ((($0)) + 240|0);
  HEAP32[$13>>2] = -1;
  $14 = ((($0)) + 88|0);
  HEAP32[$14>>2] = -1;
  $15 = ((($0)) + 184|0);
  HEAP32[$15>>2] = 0;
  $16 = ((($0)) + 188|0);
  HEAP32[$16>>2] = 0;
  $17 = ((($0)) + 192|0);
  HEAP32[$17>>2] = -1;
  $18 = ((($0)) + 196|0);
  HEAP32[$18>>2] = -1;
  $19 = ((($0)) + 156|0);
  HEAP32[$19>>2] = 0;
  $20 = ((($0)) + 164|0);
  HEAP32[$20>>2] = 4;
  $21 = ((($0)) + 224|0);
  HEAPF32[$21>>2] = -1.0;
  $22 = ((($0)) + 168|0);
  HEAP32[$22>>2] = 128;
  $23 = ((($0)) + 172|0);
  HEAP32[$23>>2] = 0;
  $24 = ((($0)) + 176|0);
  HEAP32[$24>>2] = 0;
  $25 = ((($0)) + 180|0);
  HEAP32[$25>>2] = 0;
  $26 = ((($2)) + 112|0);
  HEAP32[$26>>2] = 1;
  $27 = ((($2)) + 116|0);
  HEAP32[$27>>2] = 13;
  $28 = ((($0)) + 132|0);
  HEAP32[$28>>2] = -1;
  $29 = ((($0)) + 136|0);
  HEAP32[$29>>2] = -1;
  $30 = ((($0)) + 252|0);
  HEAPF32[$30>>2] = -1.0;
  $31 = ((($2)) + 84920|0);
  HEAP32[$31>>2] = 180;
  $32 = ((($2)) + 84924|0);
  HEAP32[$32>>2] = 180;
  $33 = ((($2)) + 84928|0);
  HEAP32[$33>>2] = 4;
  $34 = ((($2)) + 84932|0);
  HEAP32[$34>>2] = 4;
  $35 = ((($2)) + 84908|0);
  HEAPF32[$35>>2] = 1.0;
  $36 = ((($0)) + 264|0);
  HEAPF32[$36>>2] = -1.0;
  $37 = ((($0)) + 268|0);
  HEAPF32[$37>>2] = -1.0;
  $38 = ((($0)) + 20|0);
  HEAPF32[$38>>2] = 1.0;
  $39 = ((($0)) + 24|0);
  HEAPF32[$39>>2] = 1.0;
  $40 = ((($0)) + 28|0);
  HEAPF32[$40>>2] = 1.0;
  $41 = ((($0)) + 232|0);
  HEAP32[$41>>2] = -1;
  $42 = ((($0)) + 220|0);
  HEAP32[$42>>2] = -1;
  $43 = ((($0)) + 236|0);
  HEAPF32[$43>>2] = 0.0;
  $44 = ((($0)) + 244|0);
  HEAP32[$44>>2] = -1;
  $45 = ((($0)) + 248|0);
  HEAPF32[$45>>2] = -1.0;
  $46 = ((($2)) + 84032|0);
  HEAP32[$46>>2] = 1728;
  $47 = ((($2)) + 84764|0);
  HEAP32[$47>>2] = 0;
  $48 = ((($2)) + 84036|0);
  HEAP32[$48>>2] = 528;
  $49 = ((($0)) + 60|0);
  HEAP32[$49>>2] = 0;
  $50 = ((($0)) + 64|0);
  HEAP32[$50>>2] = 0;
  $51 = ((($2)) + 136|0);
  HEAP32[$51>>2] = 0;
  $52 = ((($2)) + 128|0);
  HEAP32[$52>>2] = 0;
  $53 = ((($2)) + 132|0);
  HEAP32[$53>>2] = 0;
  $54 = ((($2)) + 85680|0);
  $55 = ((($2)) + 85688|0);
  HEAP32[$55>>2] = 0;
  $56 = ((($2)) + 85692|0);
  HEAP32[$56>>2] = 0;
  HEAPF32[$54>>2] = -1.0;
  $57 = ((($0)) + 292|0);
  HEAP32[$57>>2] = 1;
  $58 = ((($0)) + 296|0);
  HEAP32[$58>>2] = 1;
  $59 = ((($0)) + 300|0);
  HEAP32[$59>>2] = 1;
  $60 = ((($0)) + 152|0);
  HEAP32[$60>>2] = 0;
  $61 = ((($0)) + 68|0);
  HEAP32[$61>>2] = 1;
  $62 = ((($0)) + 276|0);
  HEAP32[$62>>2] = 2;
  $63 = ((($0)) + 280|0);
  HEAP32[$63>>2] = 2;
  $64 = ((($0)) + 272|0);
  HEAP32[$64>>2] = 2;
  $65 = ((($0)) + 284|0);
  HEAP32[$65>>2] = 1;
  $$0 = $0;
  return ($$0|0);
 }
 return (0)|0;
}
function _lame_encode_buffer_template($gfp,$buffer_l,$buffer_r,$nsamples,$mp3buf,$mp3buf_size,$pcm_type,$aa,$norm) {
 $gfp = $gfp|0;
 $buffer_l = $buffer_l|0;
 $buffer_r = $buffer_r|0;
 $nsamples = $nsamples|0;
 $mp3buf = $mp3buf|0;
 $mp3buf_size = $mp3buf_size|0;
 $pcm_type = $pcm_type|0;
 $aa = $aa|0;
 $norm = +$norm;
 var $$0 = 0, $$0$i3 = 0, $$01$i = 0, $$01$i$us = 0, $$01$ph$i = 0, $$01$ph$i$us = 0, $$02$ph$i = 0, $$02$ph$i$us = 0, $$idx$val$i = 0, $$in_buffer$sroa$4$0$i = 0, $$in_buffer$sroa$4$0$i$lcssa = 0, $$in_buffer$sroa$4$0$i$us = 0, $$in_buffer$sroa$4$0$i$us$lcssa = 0, $$lcssa = 0, $$lcssa46 = 0, $$lcssa48 = 0, $$lcssa49 = 0, $$phi$trans$insert = 0, $$pr15$i = 0, $$pre = 0;
 var $$pre$phi$iZ2D = 0, $$pre$phiZ2D = 0, $$pre18 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0;
 var $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0;
 var $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0;
 var $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0;
 var $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0;
 var $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0;
 var $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0;
 var $98 = 0, $99 = 0, $ch$011$us$i = 0, $ch$011$us$i$us = 0, $exitcond = 0, $exitcond15 = 0, $exitcond16 = 0, $exitcond17 = 0, $i$010$us$i = 0, $i$010$us$i$us = 0, $in_buffer$sroa$0$0$i = 0, $in_buffer$sroa$0$0$i$us = 0, $in_buffer$sroa$0$0$ph$i = 0, $in_buffer$sroa$0$0$ph$i$us = 0, $in_buffer$sroa$4$0$i = 0, $in_buffer$sroa$4$0$i$us = 0, $in_buffer$sroa$4$0$ph$i = 0, $in_buffer$sroa$4$0$ph$i$us = 0, $in_buffer_ptr$i = 0, $mfbuf$i = 0;
 var $mp3size$0$ph$i = 0, $mp3size$0$ph$i$us = 0, $n_in$i = 0, $n_out$i = 0, $or$cond = 0, $or$cond$i = 0, $or$cond$i$us = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0;
 $vararg_buffer = sp;
 $mfbuf$i = sp + 24|0;
 $in_buffer_ptr$i = sp + 16|0;
 $n_in$i = sp + 8|0;
 $n_out$i = sp + 4|0;
 $0 = ($gfp|0)==(0|0);
 if ($0) {
  $$0 = -3;
  STACKTOP = sp;return ($$0|0);
 }
 $1 = HEAP32[$gfp>>2]|0;
 $2 = ($1|0)==(-487877);
 if (!($2)) {
  $$0 = -3;
  STACKTOP = sp;return ($$0|0);
 }
 $3 = ((($gfp)) + 288|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ($4|0)==(0|0);
 if ($5) {
  $$0 = -3;
  STACKTOP = sp;return ($$0|0);
 }
 $6 = HEAP32[$4>>2]|0;
 $7 = ($6|0)==(-487877);
 if (!($7)) {
  $$0 = -3;
  STACKTOP = sp;return ($$0|0);
 }
 $8 = ($nsamples|0)==(0);
 if ($8) {
  $$0 = 0;
  STACKTOP = sp;return ($$0|0);
 }
 $9 = ((($4)) + 52152|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = ($10|0)==(0|0);
 do {
  if ($11) {
   label = 10;
  } else {
   $12 = ((($4)) + 52148|0);
   $13 = HEAP32[$12>>2]|0;
   $14 = ($13|0)<($nsamples|0);
   if ($14) {
    _free($10);
    label = 10;
    break;
   } else {
    $$phi$trans$insert = ((($4)) + 52156|0);
    $$pre = HEAP32[$$phi$trans$insert>>2]|0;
    $$pr15$i = $10;$$pre$phiZ2D = $$phi$trans$insert;$22 = $$pre;
    label = 13;
    break;
   }
  }
 } while(0);
 if ((label|0) == 10) {
  $15 = ((($4)) + 52156|0);
  $16 = HEAP32[$15>>2]|0;
  $17 = ($16|0)==(0|0);
  if (!($17)) {
   _free($16);
  }
  $18 = (_calloc($nsamples,4)|0);
  HEAP32[$9>>2] = $18;
  $19 = (_calloc($nsamples,4)|0);
  HEAP32[$15>>2] = $19;
  $20 = ((($4)) + 52148|0);
  HEAP32[$20>>2] = $nsamples;
  $21 = ($18|0)==(0|0);
  if ($21) {
   $$pre$phi$iZ2D = $15;$24 = $19;
  } else {
   $$pr15$i = $18;$$pre$phiZ2D = $15;$22 = $19;
   label = 13;
  }
 }
 do {
  if ((label|0) == 13) {
   $23 = ($22|0)==(0|0);
   if ($23) {
    _free($$pr15$i);
    $$pre18 = HEAP32[$$pre$phiZ2D>>2]|0;
    $$pre$phi$iZ2D = $$pre$phiZ2D;$24 = $$pre18;
    break;
   }
   $27 = ((($4)) + 68|0);
   $28 = HEAP32[$27>>2]|0;
   $29 = ($28|0)>(1);
   $30 = ($buffer_l|0)==(0|0);
   do {
    if ($29) {
     $31 = ($buffer_r|0)==(0|0);
     $or$cond = $30 | $31;
     if ($or$cond) {
      $$0 = 0;
      STACKTOP = sp;return ($$0|0);
     } else {
      _lame_copy_inbuffer($4,$buffer_l,$buffer_r,$nsamples,$pcm_type,$aa,$norm);
      break;
     }
    } else {
     if ($30) {
      $$0 = 0;
      STACKTOP = sp;return ($$0|0);
     } else {
      _lame_copy_inbuffer($4,$buffer_l,$buffer_l,$nsamples,$pcm_type,$aa,$norm);
      break;
     }
    }
   } while(0);
   $32 = ((($4)) + 76|0);
   $33 = HEAP32[$32>>2]|0;
   $34 = ($33*576)|0;
   $35 = HEAP32[$4>>2]|0;
   $36 = ($35|0)==(-487877);
   L41: do {
    if ($36) {
     $37 = (_copy_buffer($4,$mp3buf,$mp3buf_size,0)|0);
     $38 = ($37|0)<(0);
     if ($38) {
      $$0$i3 = $37;
     } else {
      $39 = (($mp3buf) + ($37)|0);
      $40 = HEAP32[$9>>2]|0;
      $41 = HEAP32[$$pre$phiZ2D>>2]|0;
      $$idx$val$i = HEAP32[$32>>2]|0;
      $42 = ($$idx$val$i*576)|0;
      $43 = (($42) + 752)|0;
      $44 = ((($4)) + 52160|0);
      HEAP32[$mfbuf$i>>2] = $44;
      $45 = ((($4)) + 68096|0);
      $46 = ((($mfbuf$i)) + 4|0);
      HEAP32[$46>>2] = $45;
      $47 = ((($in_buffer_ptr$i)) + 4|0);
      $48 = ((($4)) + 128|0);
      $49 = ((($4)) + 72|0);
      $50 = ((($4)) + 84036|0);
      $51 = ((($4)) + 84032|0);
      $52 = ((($4)) + 136|0);
      $53 = ((($4)) + 85676|0);
      $54 = ($mp3buf_size|0)==(0);
      $55 = Math_imul($33, -576)|0;
      if ($54) {
       $$01$ph$i$us = $nsamples;$$02$ph$i$us = $39;$in_buffer$sroa$0$0$ph$i$us = $40;$in_buffer$sroa$4$0$ph$i$us = $41;$mp3size$0$ph$i$us = $37;
       L65: while(1) {
        $$01$i$us = $$01$ph$i$us;$in_buffer$sroa$0$0$i$us = $in_buffer$sroa$0$0$ph$i$us;$in_buffer$sroa$4$0$i$us = $in_buffer$sroa$4$0$ph$i$us;
        while(1) {
         $56 = ($$01$i$us|0)>(0);
         if (!($56)) {
          $$0$i3 = $mp3size$0$ph$i$us;
          break L41;
         }
         HEAP32[$n_in$i>>2] = 0;
         HEAP32[$n_out$i>>2] = 0;
         HEAP32[$in_buffer_ptr$i>>2] = $in_buffer$sroa$0$0$i$us;
         HEAP32[$47>>2] = $in_buffer$sroa$4$0$i$us;
         _fill_buffer($4,$mfbuf$i,$in_buffer_ptr$i,$$01$i$us,$n_in$i,$n_out$i);
         $57 = HEAP32[$48>>2]|0;
         $58 = ($57|0)==(0);
         if (!($58)) {
          $59 = HEAP32[$52>>2]|0;
          $60 = ($59|0)==(0);
          if ($60) {
           $61 = HEAP32[$53>>2]|0;
           $62 = HEAP32[$50>>2]|0;
           $63 = HEAP32[$mfbuf$i>>2]|0;
           $64 = (($63) + ($62<<2)|0);
           $65 = HEAP32[$46>>2]|0;
           $66 = (($65) + ($62<<2)|0);
           $67 = HEAP32[$n_out$i>>2]|0;
           $68 = HEAP32[$49>>2]|0;
           $69 = (_AnalyzeSamples(($61|0),($64|0),($66|0),($67|0),($68|0))|0);
           $70 = ($69|0)==(0);
           if ($70) {
            $$0$i3 = -6;
            break L41;
           }
          }
         }
         $71 = HEAP32[$n_in$i>>2]|0;
         $72 = (($$01$i$us) - ($71))|0;
         $73 = (($in_buffer$sroa$0$0$i$us) + ($71<<2)|0);
         $74 = HEAP32[$49>>2]|0;
         $75 = ($74|0)==(2);
         $76 = (($in_buffer$sroa$4$0$i$us) + ($71<<2)|0);
         $$in_buffer$sroa$4$0$i$us = $75 ? $76 : $in_buffer$sroa$4$0$i$us;
         $77 = HEAP32[$n_out$i>>2]|0;
         $78 = HEAP32[$50>>2]|0;
         $79 = (($78) + ($77))|0;
         HEAP32[$50>>2] = $79;
         $80 = HEAP32[$51>>2]|0;
         $81 = ($80|0)<(1);
         if ($81) {
          HEAP32[$51>>2] = 1728;
          $83 = 1728;
         } else {
          $83 = $80;
         }
         $82 = (($83) + ($77))|0;
         HEAP32[$51>>2] = $82;
         $84 = ($79|0)<($43|0);
         if ($84) {
          $$01$i$us = $72;$in_buffer$sroa$0$0$i$us = $73;$in_buffer$sroa$4$0$i$us = $$in_buffer$sroa$4$0$i$us;
         } else {
          $$in_buffer$sroa$4$0$i$us$lcssa = $$in_buffer$sroa$4$0$i$us;$$lcssa = $72;$$lcssa46 = $73;
          break;
         }
        }
        $85 = HEAP32[$mfbuf$i>>2]|0;
        $86 = HEAP32[$46>>2]|0;
        $87 = (_lame_encode_mp3_frame($4,$85,$86,$$02$ph$i$us,0)|0);
        $88 = ($87|0)<(0);
        if ($88) {
         $$0$i3 = $87;
         break L41;
        }
        $89 = (($$02$ph$i$us) + ($87)|0);
        $90 = (($87) + ($mp3size$0$ph$i$us))|0;
        $91 = HEAP32[$50>>2]|0;
        $92 = (($91) - ($34))|0;
        HEAP32[$50>>2] = $92;
        $93 = HEAP32[$51>>2]|0;
        $94 = (($93) - ($34))|0;
        HEAP32[$51>>2] = $94;
        $95 = HEAP32[$49>>2]|0;
        $96 = ($95|0)>(0);
        $97 = ($92|0)>(0);
        $or$cond$i$us = $97 & $96;
        if (!($or$cond$i$us)) {
         $$01$ph$i$us = $$lcssa;$$02$ph$i$us = $89;$in_buffer$sroa$0$0$ph$i$us = $$lcssa46;$in_buffer$sroa$4$0$ph$i$us = $$in_buffer$sroa$4$0$i$us$lcssa;$mp3size$0$ph$i$us = $90;
         continue;
        }
        $105 = (($55) + ($91))|0;
        $ch$011$us$i$us = 0;
        while(1) {
         $98 = (($mfbuf$i) + ($ch$011$us$i$us<<2)|0);
         $99 = HEAP32[$98>>2]|0;
         $i$010$us$i$us = 0;
         while(1) {
          $100 = (($i$010$us$i$us) + ($34))|0;
          $101 = (($99) + ($100<<2)|0);
          $102 = HEAP32[$101>>2]|0;
          $103 = (($99) + ($i$010$us$i$us<<2)|0);
          HEAP32[$103>>2] = $102;
          $104 = (($i$010$us$i$us) + 1)|0;
          $exitcond16 = ($104|0)==($105|0);
          if ($exitcond16) {
           break;
          } else {
           $i$010$us$i$us = $104;
          }
         }
         $106 = (($ch$011$us$i$us) + 1)|0;
         $exitcond17 = ($106|0)==($95|0);
         if ($exitcond17) {
          $$01$ph$i$us = $$lcssa;$$02$ph$i$us = $89;$in_buffer$sroa$0$0$ph$i$us = $$lcssa46;$in_buffer$sroa$4$0$ph$i$us = $$in_buffer$sroa$4$0$i$us$lcssa;$mp3size$0$ph$i$us = $90;
          continue L65;
         } else {
          $ch$011$us$i$us = $106;
         }
        }
       }
      } else {
       $$01$ph$i = $nsamples;$$02$ph$i = $39;$in_buffer$sroa$0$0$ph$i = $40;$in_buffer$sroa$4$0$ph$i = $41;$mp3size$0$ph$i = $37;
       L45: while(1) {
        $$01$i = $$01$ph$i;$in_buffer$sroa$0$0$i = $in_buffer$sroa$0$0$ph$i;$in_buffer$sroa$4$0$i = $in_buffer$sroa$4$0$ph$i;
        while(1) {
         $107 = ($$01$i|0)>(0);
         if (!($107)) {
          $$0$i3 = $mp3size$0$ph$i;
          break L41;
         }
         HEAP32[$n_in$i>>2] = 0;
         HEAP32[$n_out$i>>2] = 0;
         HEAP32[$in_buffer_ptr$i>>2] = $in_buffer$sroa$0$0$i;
         HEAP32[$47>>2] = $in_buffer$sroa$4$0$i;
         _fill_buffer($4,$mfbuf$i,$in_buffer_ptr$i,$$01$i,$n_in$i,$n_out$i);
         $108 = HEAP32[$48>>2]|0;
         $109 = ($108|0)==(0);
         if (!($109)) {
          $110 = HEAP32[$52>>2]|0;
          $111 = ($110|0)==(0);
          if ($111) {
           $112 = HEAP32[$53>>2]|0;
           $113 = HEAP32[$50>>2]|0;
           $114 = HEAP32[$mfbuf$i>>2]|0;
           $115 = (($114) + ($113<<2)|0);
           $116 = HEAP32[$46>>2]|0;
           $117 = (($116) + ($113<<2)|0);
           $118 = HEAP32[$n_out$i>>2]|0;
           $119 = HEAP32[$49>>2]|0;
           $120 = (_AnalyzeSamples(($112|0),($115|0),($117|0),($118|0),($119|0))|0);
           $121 = ($120|0)==(0);
           if ($121) {
            $$0$i3 = -6;
            break L41;
           }
          }
         }
         $122 = HEAP32[$n_in$i>>2]|0;
         $123 = (($$01$i) - ($122))|0;
         $124 = (($in_buffer$sroa$0$0$i) + ($122<<2)|0);
         $125 = HEAP32[$49>>2]|0;
         $126 = ($125|0)==(2);
         $127 = (($in_buffer$sroa$4$0$i) + ($122<<2)|0);
         $$in_buffer$sroa$4$0$i = $126 ? $127 : $in_buffer$sroa$4$0$i;
         $128 = HEAP32[$n_out$i>>2]|0;
         $129 = HEAP32[$50>>2]|0;
         $130 = (($129) + ($128))|0;
         HEAP32[$50>>2] = $130;
         $131 = HEAP32[$51>>2]|0;
         $132 = ($131|0)<(1);
         if ($132) {
          HEAP32[$51>>2] = 1728;
          $134 = 1728;
         } else {
          $134 = $131;
         }
         $133 = (($134) + ($128))|0;
         HEAP32[$51>>2] = $133;
         $135 = ($130|0)<($43|0);
         if ($135) {
          $$01$i = $123;$in_buffer$sroa$0$0$i = $124;$in_buffer$sroa$4$0$i = $$in_buffer$sroa$4$0$i;
         } else {
          $$in_buffer$sroa$4$0$i$lcssa = $$in_buffer$sroa$4$0$i;$$lcssa48 = $123;$$lcssa49 = $124;
          break;
         }
        }
        $136 = (($mp3buf_size) - ($mp3size$0$ph$i))|0;
        $137 = HEAP32[$mfbuf$i>>2]|0;
        $138 = HEAP32[$46>>2]|0;
        $139 = (_lame_encode_mp3_frame($4,$137,$138,$$02$ph$i,$136)|0);
        $140 = ($139|0)<(0);
        if ($140) {
         $$0$i3 = $139;
         break L41;
        }
        $141 = (($$02$ph$i) + ($139)|0);
        $142 = (($139) + ($mp3size$0$ph$i))|0;
        $143 = HEAP32[$50>>2]|0;
        $144 = (($143) - ($34))|0;
        HEAP32[$50>>2] = $144;
        $145 = HEAP32[$51>>2]|0;
        $146 = (($145) - ($34))|0;
        HEAP32[$51>>2] = $146;
        $147 = HEAP32[$49>>2]|0;
        $148 = ($147|0)>(0);
        $149 = ($144|0)>(0);
        $or$cond$i = $149 & $148;
        if (!($or$cond$i)) {
         $$01$ph$i = $$lcssa48;$$02$ph$i = $141;$in_buffer$sroa$0$0$ph$i = $$lcssa49;$in_buffer$sroa$4$0$ph$i = $$in_buffer$sroa$4$0$i$lcssa;$mp3size$0$ph$i = $142;
         continue;
        }
        $150 = (($55) + ($143))|0;
        $ch$011$us$i = 0;
        while(1) {
         $158 = (($mfbuf$i) + ($ch$011$us$i<<2)|0);
         $154 = HEAP32[$158>>2]|0;
         $i$010$us$i = 0;
         while(1) {
          $152 = (($i$010$us$i) + ($34))|0;
          $153 = (($154) + ($152<<2)|0);
          $155 = HEAP32[$153>>2]|0;
          $156 = (($154) + ($i$010$us$i<<2)|0);
          HEAP32[$156>>2] = $155;
          $157 = (($i$010$us$i) + 1)|0;
          $exitcond = ($157|0)==($150|0);
          if ($exitcond) {
           break;
          } else {
           $i$010$us$i = $157;
          }
         }
         $151 = (($ch$011$us$i) + 1)|0;
         $exitcond15 = ($151|0)==($147|0);
         if ($exitcond15) {
          $$01$ph$i = $$lcssa48;$$02$ph$i = $141;$in_buffer$sroa$0$0$ph$i = $$lcssa49;$in_buffer$sroa$4$0$ph$i = $$in_buffer$sroa$4$0$i$lcssa;$mp3size$0$ph$i = $142;
          continue L45;
         } else {
          $ch$011$us$i = $151;
         }
        }
       }
      }
     }
    } else {
     $$0$i3 = -3;
    }
   } while(0);
   $$0 = $$0$i3;
   STACKTOP = sp;return ($$0|0);
  }
 } while(0);
 $25 = ($24|0)==(0|0);
 if (!($25)) {
  _free($24);
 }
 HEAP32[$9>>2] = 0;
 HEAP32[$$pre$phi$iZ2D>>2] = 0;
 $26 = ((($4)) + 52148|0);
 HEAP32[$26>>2] = 0;
 _lame_errorf($4,7168,$vararg_buffer);
 $$0 = -2;
 STACKTOP = sp;return ($$0|0);
}
function _save_gain_values($gfc) {
 $gfc = $gfc|0;
 var $0 = 0, $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0, $14 = 0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0.0, $26 = 0.0;
 var $27 = 0.0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0, $32 = 0, $33 = 0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0.0, $8 = 0, $9 = 0.0, $fabsf = 0.0, $fabsf1 = 0.0;
 var $floorf = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gfc)) + 85680|0);
 $1 = ((($gfc)) + 128|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = ($2|0)==(0);
 do {
  if (!($3)) {
   $4 = ((($gfc)) + 85676|0);
   $5 = HEAP32[$4>>2]|0;
   $6 = (+_GetTitleGain(($5|0)));
   $7 = $6;
   $fabsf = (+Math_abs((+$6)));
   $8 = $fabsf > 24601.0;
   $9 = $6 + 24601.0;
   $fabsf1 = (+Math_abs((+$9)));
   $10 = $fabsf1;
   if ($8) {
    $11 = $fabsf;
    $12 = $11 * 9.9999999747524271E-7;
    $13 = !($10 <= $12);
    if ($13) {
     label = 5;
    } else {
     label = 6;
    }
   } else {
    $14 = !($10 <= 0.024600999937888446);
    if ($14) {
     label = 5;
    } else {
     label = 6;
    }
   }
   if ((label|0) == 5) {
    $15 = $7 * 10.0;
    $16 = $15 + 0.5;
    $17 = (+Math_floor((+$16)));
    $18 = (~~(($17)));
    $19 = ((($gfc)) + 85688|0);
    HEAP32[$19>>2] = $18;
    break;
   }
   else if ((label|0) == 6) {
    $20 = ((($gfc)) + 85688|0);
    HEAP32[$20>>2] = 0;
    break;
   }
  }
 } while(0);
 $21 = ((($gfc)) + 132|0);
 $22 = HEAP32[$21>>2]|0;
 $23 = ($22|0)==(0);
 if ($23) {
  return;
 }
 $24 = ((($gfc)) + 85684|0);
 $25 = +HEAPF32[$24>>2];
 $26 = $25;
 $27 = $26 * 3.0518509475997192E-5;
 $28 = (+_log10($27));
 $29 = $28 * 200.0;
 $30 = (+Math_ceil((+$29)));
 $31 = (~~(($30)));
 $32 = ((($gfc)) + 85692|0);
 HEAP32[$32>>2] = $31;
 $33 = ($31|0)>(0);
 if ($33) {
  $34 = 3276700.0 / $25;
  $floorf = (+Math_floor((+$34)));
  $35 = $floorf;
  $36 = $35 * 0.01;
  $37 = $36;
  HEAPF32[$0>>2] = $37;
  return;
 } else {
  HEAPF32[$0>>2] = -1.0;
  return;
 }
}
function _lame_copy_inbuffer($gfc,$l,$r,$nsamples,$pcm_type,$jump,$s) {
 $gfc = $gfc|0;
 $l = $l|0;
 $r = $r|0;
 $nsamples = $nsamples|0;
 $pcm_type = $pcm_type|0;
 $jump = $jump|0;
 $s = +$s;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0.0, $12 = 0.0, $13 = 0, $14 = 0.0, $15 = 0.0, $16 = 0, $17 = 0, $18 = 0.0, $19 = 0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0.0, $35 = 0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0, $44 = 0;
 var $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0.0, $50 = 0.0, $51 = 0, $52 = 0.0, $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0, $6 = 0.0, $60 = 0, $61 = 0, $62 = 0;
 var $63 = 0, $64 = 0, $65 = 0.0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0.0, $71 = 0.0, $72 = 0.0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0.0, $8 = 0.0, $80 = 0.0;
 var $81 = 0.0, $82 = 0.0, $83 = 0.0, $84 = 0.0, $85 = 0.0, $86 = 0.0, $87 = 0.0, $88 = 0.0, $89 = 0, $9 = 0.0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $bl$07 = 0, $bl1$010 = 0, $bl15$016 = 0, $bl22$020 = 0, $bl8$014 = 0, $br$06 = 0;
 var $br16$017 = 0, $br2$09 = 0, $br23$021 = 0, $br9$013 = 0, $exitcond = 0, $exitcond24 = 0, $exitcond25 = 0, $exitcond26 = 0, $exitcond27 = 0, $i$05 = 0, $i10$012 = 0, $i17$018 = 0, $i24$022 = 0, $i3$08 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gfc)) + 52152|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ((($gfc)) + 52156|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ((($gfc)) + 264|0);
 $5 = +HEAPF32[$4>>2];
 $6 = $5 * $s;
 $7 = ((($gfc)) + 268|0);
 $8 = +HEAPF32[$7>>2];
 $9 = $8 * $s;
 $10 = ((($gfc)) + 272|0);
 $11 = +HEAPF32[$10>>2];
 $12 = $11 * $s;
 $13 = ((($gfc)) + 276|0);
 $14 = +HEAPF32[$13>>2];
 $15 = $14 * $s;
 switch ($pcm_type|0) {
 case 4:  {
  $78 = ($nsamples|0)>(0);
  if (!($78)) {
   return;
  }
  $bl22$020 = $l;$br23$021 = $r;$i24$022 = 0;
  while(1) {
   $79 = +HEAPF64[$bl22$020>>3];
   $80 = $79;
   $81 = +HEAPF64[$br23$021>>3];
   $82 = $81;
   $83 = $80 * $6;
   $84 = $82 * $9;
   $85 = $84 + $83;
   $86 = $80 * $12;
   $87 = $82 * $15;
   $88 = $87 + $86;
   $89 = (($1) + ($i24$022<<2)|0);
   HEAPF32[$89>>2] = $85;
   $90 = (($3) + ($i24$022<<2)|0);
   HEAPF32[$90>>2] = $88;
   $91 = (($bl22$020) + ($jump<<3)|0);
   $92 = (($br23$021) + ($jump<<3)|0);
   $93 = (($i24$022) + 1)|0;
   $exitcond27 = ($93|0)==($nsamples|0);
   if ($exitcond27) {
    break;
   } else {
    $bl22$020 = $91;$br23$021 = $92;$i24$022 = $93;
   }
  }
  return;
  break;
 }
 case 0:  {
  $16 = ($nsamples|0)>(0);
  if (!($16)) {
   return;
  }
  $bl$07 = $l;$br$06 = $r;$i$05 = 0;
  while(1) {
   $17 = HEAP16[$bl$07>>1]|0;
   $18 = (+($17<<16>>16));
   $19 = HEAP16[$br$06>>1]|0;
   $20 = (+($19<<16>>16));
   $21 = $18 * $6;
   $22 = $20 * $9;
   $23 = $22 + $21;
   $24 = $18 * $12;
   $25 = $20 * $15;
   $26 = $25 + $24;
   $27 = (($1) + ($i$05<<2)|0);
   HEAPF32[$27>>2] = $23;
   $28 = (($3) + ($i$05<<2)|0);
   HEAPF32[$28>>2] = $26;
   $29 = (($bl$07) + ($jump<<1)|0);
   $30 = (($br$06) + ($jump<<1)|0);
   $31 = (($i$05) + 1)|0;
   $exitcond = ($31|0)==($nsamples|0);
   if ($exitcond) {
    break;
   } else {
    $bl$07 = $29;$br$06 = $30;$i$05 = $31;
   }
  }
  return;
  break;
 }
 case 3:  {
  $64 = ($nsamples|0)>(0);
  if (!($64)) {
   return;
  }
  $bl15$016 = $l;$br16$017 = $r;$i17$018 = 0;
  while(1) {
   $65 = +HEAPF32[$bl15$016>>2];
   $66 = +HEAPF32[$br16$017>>2];
   $67 = $65 * $6;
   $68 = $66 * $9;
   $69 = $68 + $67;
   $70 = $65 * $12;
   $71 = $66 * $15;
   $72 = $71 + $70;
   $73 = (($1) + ($i17$018<<2)|0);
   HEAPF32[$73>>2] = $69;
   $74 = (($3) + ($i17$018<<2)|0);
   HEAPF32[$74>>2] = $72;
   $75 = (($bl15$016) + ($jump<<2)|0);
   $76 = (($br16$017) + ($jump<<2)|0);
   $77 = (($i17$018) + 1)|0;
   $exitcond26 = ($77|0)==($nsamples|0);
   if ($exitcond26) {
    break;
   } else {
    $bl15$016 = $75;$br16$017 = $76;$i17$018 = $77;
   }
  }
  return;
  break;
 }
 case 2:  {
  $48 = ($nsamples|0)>(0);
  if (!($48)) {
   return;
  }
  $bl8$014 = $l;$br9$013 = $r;$i10$012 = 0;
  while(1) {
   $49 = HEAP32[$bl8$014>>2]|0;
   $50 = (+($49|0));
   $51 = HEAP32[$br9$013>>2]|0;
   $52 = (+($51|0));
   $53 = $50 * $6;
   $54 = $52 * $9;
   $55 = $54 + $53;
   $56 = $50 * $12;
   $57 = $52 * $15;
   $58 = $57 + $56;
   $59 = (($1) + ($i10$012<<2)|0);
   HEAPF32[$59>>2] = $55;
   $60 = (($3) + ($i10$012<<2)|0);
   HEAPF32[$60>>2] = $58;
   $61 = (($bl8$014) + ($jump<<2)|0);
   $62 = (($br9$013) + ($jump<<2)|0);
   $63 = (($i10$012) + 1)|0;
   $exitcond25 = ($63|0)==($nsamples|0);
   if ($exitcond25) {
    break;
   } else {
    $bl8$014 = $61;$br9$013 = $62;$i10$012 = $63;
   }
  }
  return;
  break;
 }
 case 1:  {
  $32 = ($nsamples|0)>(0);
  if (!($32)) {
   return;
  }
  $bl1$010 = $l;$br2$09 = $r;$i3$08 = 0;
  while(1) {
   $33 = HEAP32[$bl1$010>>2]|0;
   $34 = (+($33|0));
   $35 = HEAP32[$br2$09>>2]|0;
   $36 = (+($35|0));
   $37 = $34 * $6;
   $38 = $36 * $9;
   $39 = $38 + $37;
   $40 = $34 * $12;
   $41 = $36 * $15;
   $42 = $41 + $40;
   $43 = (($1) + ($i3$08<<2)|0);
   HEAPF32[$43>>2] = $39;
   $44 = (($3) + ($i3$08<<2)|0);
   HEAPF32[$44>>2] = $42;
   $45 = (($bl1$010) + ($jump<<2)|0);
   $46 = (($br2$09) + ($jump<<2)|0);
   $47 = (($i3$08) + 1)|0;
   $exitcond24 = ($47|0)==($nsamples|0);
   if ($exitcond24) {
    break;
   } else {
    $bl1$010 = $45;$br2$09 = $46;$i3$08 = $47;
   }
  }
  return;
  break;
 }
 default: {
  return;
 }
 }
}
function _mdct_sub48($gfc,$w0,$w1) {
 $gfc = $gfc|0;
 $w0 = $w0|0;
 $w1 = $w1|0;
 var $$ = 0, $$02$i = 0, $$lcssa = 0, $$neg11$i = 0.0, $$neg13$i = 0.0, $$neg3$i = 0.0, $$sum = 0, $$sum10 = 0, $$sum11 = 0, $$sum12 = 0, $$sum13 = 0, $$sum14 = 0, $$sum15 = 0, $$sum18$1 = 0, $$sum18$10 = 0, $$sum18$11 = 0, $$sum18$12 = 0, $$sum18$13 = 0, $$sum18$14 = 0, $$sum18$15 = 0;
 var $$sum18$16 = 0, $$sum18$17 = 0, $$sum18$2 = 0, $$sum18$3 = 0, $$sum18$4 = 0, $$sum18$5 = 0, $$sum18$6 = 0, $$sum18$7 = 0, $$sum18$8 = 0, $$sum18$9 = 0, $$sum4 = 0, $$sum5 = 0, $$sum6 = 0, $$sum9 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0.0, $102 = 0.0;
 var $103 = 0.0, $104 = 0, $105 = 0.0, $106 = 0.0, $107 = 0.0, $108 = 0, $109 = 0.0, $11 = 0, $110 = 0.0, $111 = 0.0, $112 = 0, $113 = 0.0, $114 = 0.0, $115 = 0.0, $116 = 0, $117 = 0.0, $118 = 0.0, $119 = 0.0, $12 = 0, $120 = 0;
 var $121 = 0.0, $122 = 0.0, $123 = 0.0, $124 = 0, $125 = 0.0, $126 = 0.0, $127 = 0.0, $128 = 0, $129 = 0.0, $13 = 0, $130 = 0.0, $131 = 0.0, $132 = 0, $133 = 0.0, $134 = 0.0, $135 = 0.0, $136 = 0, $137 = 0.0, $138 = 0.0, $139 = 0.0;
 var $14 = 0, $140 = 0, $141 = 0.0, $142 = 0.0, $143 = 0.0, $144 = 0, $145 = 0.0, $146 = 0.0, $147 = 0.0, $148 = 0, $149 = 0.0, $15 = 0, $150 = 0.0, $151 = 0.0, $152 = 0, $153 = 0.0, $154 = 0.0, $155 = 0.0, $156 = 0, $157 = 0.0;
 var $158 = 0.0, $159 = 0.0, $16 = 0, $160 = 0, $161 = 0.0, $162 = 0.0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0.0, $169 = 0, $17 = 0, $170 = 0, $171 = 0.0, $172 = 0.0, $173 = 0, $174 = 0, $175 = 0;
 var $176 = 0.0, $177 = 0.0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0.0, $185 = 0.0, $186 = 0, $187 = 0.0, $188 = 0.0, $189 = 0, $19 = 0, $190 = 0, $191 = 0.0, $192 = 0.0, $193 = 0.0;
 var $194 = 0.0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0.0, $201 = 0.0, $202 = 0, $203 = 0, $204 = 0.0, $205 = 0.0, $206 = 0, $207 = 0, $208 = 0.0, $209 = 0.0, $21 = 0, $210 = 0.0;
 var $211 = 0.0, $212 = 0, $213 = 0, $214 = 0, $215 = 0.0, $216 = 0.0, $217 = 0, $218 = 0.0, $219 = 0.0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0.0, $225 = 0.0, $226 = 0, $227 = 0.0, $228 = 0.0, $229 = 0.0;
 var $23 = 0, $230 = 0.0, $231 = 0, $232 = 0.0, $233 = 0.0, $234 = 0.0, $235 = 0.0, $236 = 0.0, $237 = 0.0, $238 = 0.0, $239 = 0.0, $24 = 0, $240 = 0.0, $241 = 0.0, $242 = 0, $243 = 0.0, $244 = 0.0, $245 = 0, $246 = 0.0, $247 = 0.0;
 var $248 = 0.0, $249 = 0.0, $25 = 0, $250 = 0.0, $251 = 0.0, $252 = 0.0, $253 = 0.0, $254 = 0.0, $255 = 0.0, $256 = 0.0, $257 = 0.0, $258 = 0.0, $259 = 0.0, $26 = 0, $260 = 0.0, $261 = 0.0, $262 = 0.0, $263 = 0.0, $264 = 0.0, $265 = 0.0;
 var $266 = 0.0, $267 = 0.0, $268 = 0.0, $269 = 0.0, $27 = 0, $270 = 0.0, $271 = 0.0, $272 = 0.0, $273 = 0.0, $274 = 0.0, $275 = 0.0, $276 = 0.0, $277 = 0.0, $278 = 0.0, $279 = 0.0, $28 = 0, $280 = 0.0, $281 = 0.0, $282 = 0.0, $283 = 0.0;
 var $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0.0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0.0, $293 = 0.0, $294 = 0, $295 = 0, $296 = 0.0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0.0;
 var $301 = 0.0, $302 = 0.0, $303 = 0, $304 = 0.0, $305 = 0, $306 = 0.0, $307 = 0.0, $308 = 0, $309 = 0, $31 = 0, $310 = 0.0, $311 = 0, $312 = 0.0, $313 = 0.0, $314 = 0.0, $315 = 0, $316 = 0.0, $317 = 0.0, $318 = 0.0, $319 = 0;
 var $32 = 0.0, $320 = 0.0, $321 = 0.0, $322 = 0, $323 = 0, $324 = 0.0, $325 = 0.0, $326 = 0.0, $327 = 0.0, $328 = 0.0, $329 = 0.0, $33 = 0.0, $330 = 0.0, $331 = 0.0, $332 = 0.0, $333 = 0.0, $334 = 0.0, $335 = 0.0, $336 = 0.0, $337 = 0.0;
 var $338 = 0.0, $339 = 0.0, $34 = 0, $340 = 0.0, $341 = 0.0, $342 = 0.0, $343 = 0.0, $344 = 0.0, $345 = 0.0, $346 = 0.0, $347 = 0.0, $348 = 0.0, $349 = 0, $35 = 0.0, $350 = 0.0, $351 = 0.0, $352 = 0.0, $353 = 0.0, $354 = 0.0, $355 = 0.0;
 var $356 = 0.0, $357 = 0.0, $358 = 0, $359 = 0.0, $36 = 0.0, $360 = 0, $361 = 0.0, $362 = 0.0, $363 = 0.0, $364 = 0.0, $365 = 0.0, $366 = 0.0, $367 = 0.0, $368 = 0.0, $369 = 0.0, $37 = 0, $370 = 0.0, $371 = 0.0, $372 = 0.0, $373 = 0.0;
 var $374 = 0.0, $375 = 0.0, $376 = 0.0, $377 = 0.0, $378 = 0.0, $379 = 0.0, $38 = 0.0, $380 = 0.0, $381 = 0, $382 = 0.0, $383 = 0, $384 = 0.0, $385 = 0.0, $386 = 0.0, $387 = 0.0, $388 = 0.0, $389 = 0.0, $39 = 0.0, $390 = 0.0, $391 = 0.0;
 var $392 = 0.0, $393 = 0.0, $394 = 0.0, $395 = 0.0, $396 = 0.0, $397 = 0, $398 = 0.0, $399 = 0, $4 = 0, $40 = 0, $400 = 0.0, $401 = 0.0, $402 = 0.0, $403 = 0.0, $404 = 0.0, $405 = 0.0, $406 = 0.0, $407 = 0.0, $408 = 0.0, $409 = 0.0;
 var $41 = 0.0, $410 = 0.0, $411 = 0.0, $412 = 0.0, $413 = 0, $414 = 0.0, $415 = 0, $416 = 0.0, $417 = 0.0, $418 = 0.0, $419 = 0.0, $42 = 0.0, $420 = 0.0, $421 = 0.0, $422 = 0.0, $423 = 0.0, $424 = 0.0, $425 = 0.0, $426 = 0.0, $427 = 0.0;
 var $428 = 0.0, $429 = 0.0, $43 = 0, $430 = 0.0, $431 = 0.0, $432 = 0.0, $433 = 0.0, $434 = 0.0, $435 = 0.0, $436 = 0.0, $437 = 0.0, $438 = 0.0, $439 = 0.0, $44 = 0.0, $440 = 0.0, $441 = 0.0, $442 = 0.0, $443 = 0.0, $444 = 0.0, $445 = 0.0;
 var $446 = 0.0, $447 = 0.0, $448 = 0.0, $449 = 0, $45 = 0.0, $450 = 0.0, $451 = 0, $452 = 0.0, $453 = 0.0, $454 = 0.0, $455 = 0.0, $456 = 0.0, $457 = 0.0, $458 = 0.0, $459 = 0.0, $46 = 0, $460 = 0.0, $461 = 0.0, $462 = 0.0, $463 = 0.0;
 var $464 = 0.0, $465 = 0.0, $466 = 0.0, $467 = 0.0, $468 = 0.0, $469 = 0.0, $47 = 0.0, $470 = 0.0, $471 = 0.0, $472 = 0, $473 = 0.0, $474 = 0, $475 = 0.0, $476 = 0.0, $477 = 0.0, $478 = 0.0, $479 = 0.0, $48 = 0.0, $480 = 0.0, $481 = 0.0;
 var $482 = 0.0, $483 = 0.0, $484 = 0.0, $485 = 0.0, $486 = 0.0, $487 = 0.0, $488 = 0, $489 = 0.0, $49 = 0, $490 = 0, $491 = 0.0, $492 = 0.0, $493 = 0.0, $494 = 0.0, $495 = 0.0, $496 = 0.0, $497 = 0.0, $498 = 0.0, $499 = 0.0, $5 = 0;
 var $50 = 0.0, $500 = 0.0, $501 = 0.0, $502 = 0.0, $503 = 0.0, $504 = 0, $505 = 0.0, $506 = 0, $507 = 0, $508 = 0, $509 = 0, $51 = 0.0, $510 = 0.0, $511 = 0, $512 = 0.0, $513 = 0.0, $514 = 0, $515 = 0, $516 = 0.0, $517 = 0;
 var $518 = 0.0, $519 = 0.0, $52 = 0, $520 = 0.0, $521 = 0.0, $522 = 0.0, $523 = 0.0, $524 = 0, $525 = 0, $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0.0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $534 = 0, $535 = 0;
 var $536 = 0, $54 = 0.0, $55 = 0, $56 = 0.0, $57 = 0.0, $58 = 0, $59 = 0.0, $6 = 0, $60 = 0.0, $61 = 0, $62 = 0.0, $63 = 0.0, $64 = 0, $65 = 0.0, $66 = 0.0, $67 = 0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0;
 var $71 = 0.0, $72 = 0.0, $73 = 0, $74 = 0.0, $75 = 0.0, $76 = 0, $77 = 0.0, $78 = 0.0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0.0, $89 = 0.0;
 var $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0.0, $94 = 0.0, $95 = 0.0, $96 = 0, $97 = 0.0, $98 = 0.0, $99 = 0.0, $band$156 = 0, $ch$060 = 0, $exitcond = 0, $exitcond$i = 0, $exitcond69 = 0, $exitcond70 = 0, $exitcond71 = 0, $gr$058 = 0, $k$049 = 0;
 var $k$252 = 0, $k$351 = 0, $k$453 = 0, $l$01$i = 0, $mdct_enc$054 = 0, $or$cond = 0, $or$cond3 = 0, $samp$047 = 0, $scevgep = 0, $w0$pn59 = 0, $wk$0 = 0, $wk$157 = 0, $wk$248 = 0, $work = 0, dest = 0, label = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80|0;
 $work = sp;
 $0 = ((($gfc)) + 72|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($1|0)>(0);
 if (!($2)) {
  STACKTOP = sp;return;
 }
 $3 = ((($gfc)) + 76|0);
 $4 = ((($work)) + 68|0);
 $5 = ((($work)) + 36|0);
 $6 = ((($work)) + 60|0);
 $7 = ((($work)) + 44|0);
 $8 = ((($work)) + 56|0);
 $9 = ((($work)) + 48|0);
 $10 = ((($work)) + 32|0);
 $11 = ((($work)) + 4|0);
 $12 = ((($work)) + 28|0);
 $13 = ((($work)) + 8|0);
 $14 = ((($work)) + 24|0);
 $15 = ((($work)) + 12|0);
 $16 = ((($work)) + 20|0);
 $17 = ((($work)) + 16|0);
 $18 = ((($work)) + 64|0);
 $19 = ((($work)) + 40|0);
 $20 = ((($work)) + 52|0);
 $ch$060 = 0;$w0$pn59 = $w0;
 while(1) {
  $21 = HEAP32[$3>>2]|0;
  $22 = ($21|0)>(0);
  if ($22) {
   $wk$0 = ((($w0$pn59)) + 1144|0);
   $gr$058 = 0;$wk$157 = $wk$0;
   while(1) {
    $23 = (1 - ($gr$058))|0;
    $24 = ((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0);
    $k$049 = 0;$samp$047 = $24;$wk$248 = $wk$157;
    while(1) {
     _window_subband($wk$248,$samp$047);
     $28 = ((($wk$248)) + 128|0);
     $29 = ((($samp$047)) + 128|0);
     _window_subband($28,$29);
     $30 = ((($samp$047)) + 256|0);
     $31 = ((($samp$047)) + 132|0);
     $32 = +HEAPF32[$31>>2];
     $33 = -$32;
     HEAPF32[$31>>2] = $33;
     $34 = ((($samp$047)) + 140|0);
     $35 = +HEAPF32[$34>>2];
     $36 = -$35;
     HEAPF32[$34>>2] = $36;
     $37 = ((($samp$047)) + 148|0);
     $38 = +HEAPF32[$37>>2];
     $39 = -$38;
     HEAPF32[$37>>2] = $39;
     $40 = ((($samp$047)) + 156|0);
     $41 = +HEAPF32[$40>>2];
     $42 = -$41;
     HEAPF32[$40>>2] = $42;
     $43 = ((($samp$047)) + 164|0);
     $44 = +HEAPF32[$43>>2];
     $45 = -$44;
     HEAPF32[$43>>2] = $45;
     $46 = ((($samp$047)) + 172|0);
     $47 = +HEAPF32[$46>>2];
     $48 = -$47;
     HEAPF32[$46>>2] = $48;
     $49 = ((($samp$047)) + 180|0);
     $50 = +HEAPF32[$49>>2];
     $51 = -$50;
     HEAPF32[$49>>2] = $51;
     $52 = ((($samp$047)) + 188|0);
     $53 = +HEAPF32[$52>>2];
     $54 = -$53;
     HEAPF32[$52>>2] = $54;
     $55 = ((($samp$047)) + 196|0);
     $56 = +HEAPF32[$55>>2];
     $57 = -$56;
     HEAPF32[$55>>2] = $57;
     $58 = ((($samp$047)) + 204|0);
     $59 = +HEAPF32[$58>>2];
     $60 = -$59;
     HEAPF32[$58>>2] = $60;
     $61 = ((($samp$047)) + 212|0);
     $62 = +HEAPF32[$61>>2];
     $63 = -$62;
     HEAPF32[$61>>2] = $63;
     $64 = ((($samp$047)) + 220|0);
     $65 = +HEAPF32[$64>>2];
     $66 = -$65;
     HEAPF32[$64>>2] = $66;
     $67 = ((($samp$047)) + 228|0);
     $68 = +HEAPF32[$67>>2];
     $69 = -$68;
     HEAPF32[$67>>2] = $69;
     $70 = ((($samp$047)) + 236|0);
     $71 = +HEAPF32[$70>>2];
     $72 = -$71;
     HEAPF32[$70>>2] = $72;
     $73 = ((($samp$047)) + 244|0);
     $74 = +HEAPF32[$73>>2];
     $75 = -$74;
     HEAPF32[$73>>2] = $75;
     $76 = ((($samp$047)) + 252|0);
     $77 = +HEAPF32[$76>>2];
     $78 = -$77;
     HEAPF32[$76>>2] = $78;
     $79 = ((($wk$248)) + 256|0);
     $80 = (($k$049) + 1)|0;
     $exitcond = ($80|0)==(9);
     if ($exitcond) {
      break;
     } else {
      $k$049 = $80;$samp$047 = $30;$wk$248 = $79;
     }
    }
    $25 = ((((($gfc)) + 304|0) + (($gr$058*10504)|0)|0) + (($ch$060*5252)|0)|0);
    $26 = ((((((($gfc)) + 304|0) + (($gr$058*10504)|0)|0) + (($ch$060*5252)|0)|0)) + 4788|0);
    $27 = ((((((($gfc)) + 304|0) + (($gr$058*10504)|0)|0) + (($ch$060*5252)|0)|0)) + 4792|0);
    $band$156 = 0;$mdct_enc$054 = $25;
    while(1) {
     $81 = HEAP32[$26>>2]|0;
     $82 = (7208 + ($band$156<<2)|0);
     $83 = HEAP32[$82>>2]|0;
     $84 = HEAP32[$27>>2]|0;
     $85 = ($84|0)!=(0);
     $86 = ($band$156|0)<(2);
     $or$cond = $86 & $85;
     $$ = $or$cond ? 0 : $81;
     $87 = (((($gfc)) + 37040|0) + ($band$156<<2)|0);
     $88 = +HEAPF32[$87>>2];
     $89 = $88;
     $90 = $89 < 9.9999999999999998E-13;
     do {
      if ($90) {
       dest=$mdct_enc$054; stop=dest+72|0; do { HEAP32[dest>>2]=0|0; dest=dest+4|0; } while ((dest|0) < (stop|0));
      } else {
       $91 = $88 < 1.0;
       if ($91) {
        $92 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($83<<2)|0);
        $93 = +HEAPF32[$92>>2];
        $94 = $93 * $88;
        HEAPF32[$92>>2] = $94;
        $95 = +HEAPF32[$87>>2];
        $$sum18$1 = (($83) + 32)|0;
        $96 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$1<<2)|0);
        $97 = +HEAPF32[$96>>2];
        $98 = $97 * $95;
        HEAPF32[$96>>2] = $98;
        $99 = +HEAPF32[$87>>2];
        $$sum18$2 = (($83) + 64)|0;
        $100 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$2<<2)|0);
        $101 = +HEAPF32[$100>>2];
        $102 = $101 * $99;
        HEAPF32[$100>>2] = $102;
        $103 = +HEAPF32[$87>>2];
        $$sum18$3 = (($83) + 96)|0;
        $104 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$3<<2)|0);
        $105 = +HEAPF32[$104>>2];
        $106 = $105 * $103;
        HEAPF32[$104>>2] = $106;
        $107 = +HEAPF32[$87>>2];
        $$sum18$4 = (($83) + 128)|0;
        $108 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$4<<2)|0);
        $109 = +HEAPF32[$108>>2];
        $110 = $109 * $107;
        HEAPF32[$108>>2] = $110;
        $111 = +HEAPF32[$87>>2];
        $$sum18$5 = (($83) + 160)|0;
        $112 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$5<<2)|0);
        $113 = +HEAPF32[$112>>2];
        $114 = $113 * $111;
        HEAPF32[$112>>2] = $114;
        $115 = +HEAPF32[$87>>2];
        $$sum18$6 = (($83) + 192)|0;
        $116 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$6<<2)|0);
        $117 = +HEAPF32[$116>>2];
        $118 = $117 * $115;
        HEAPF32[$116>>2] = $118;
        $119 = +HEAPF32[$87>>2];
        $$sum18$7 = (($83) + 224)|0;
        $120 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$7<<2)|0);
        $121 = +HEAPF32[$120>>2];
        $122 = $121 * $119;
        HEAPF32[$120>>2] = $122;
        $123 = +HEAPF32[$87>>2];
        $$sum18$8 = (($83) + 256)|0;
        $124 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$8<<2)|0);
        $125 = +HEAPF32[$124>>2];
        $126 = $125 * $123;
        HEAPF32[$124>>2] = $126;
        $127 = +HEAPF32[$87>>2];
        $$sum18$9 = (($83) + 288)|0;
        $128 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$9<<2)|0);
        $129 = +HEAPF32[$128>>2];
        $130 = $129 * $127;
        HEAPF32[$128>>2] = $130;
        $131 = +HEAPF32[$87>>2];
        $$sum18$10 = (($83) + 320)|0;
        $132 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$10<<2)|0);
        $133 = +HEAPF32[$132>>2];
        $134 = $133 * $131;
        HEAPF32[$132>>2] = $134;
        $135 = +HEAPF32[$87>>2];
        $$sum18$11 = (($83) + 352)|0;
        $136 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$11<<2)|0);
        $137 = +HEAPF32[$136>>2];
        $138 = $137 * $135;
        HEAPF32[$136>>2] = $138;
        $139 = +HEAPF32[$87>>2];
        $$sum18$12 = (($83) + 384)|0;
        $140 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$12<<2)|0);
        $141 = +HEAPF32[$140>>2];
        $142 = $141 * $139;
        HEAPF32[$140>>2] = $142;
        $143 = +HEAPF32[$87>>2];
        $$sum18$13 = (($83) + 416)|0;
        $144 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$13<<2)|0);
        $145 = +HEAPF32[$144>>2];
        $146 = $145 * $143;
        HEAPF32[$144>>2] = $146;
        $147 = +HEAPF32[$87>>2];
        $$sum18$14 = (($83) + 448)|0;
        $148 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$14<<2)|0);
        $149 = +HEAPF32[$148>>2];
        $150 = $149 * $147;
        HEAPF32[$148>>2] = $150;
        $151 = +HEAPF32[$87>>2];
        $$sum18$15 = (($83) + 480)|0;
        $152 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$15<<2)|0);
        $153 = +HEAPF32[$152>>2];
        $154 = $153 * $151;
        HEAPF32[$152>>2] = $154;
        $155 = +HEAPF32[$87>>2];
        $$sum18$16 = (($83) + 512)|0;
        $156 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$16<<2)|0);
        $157 = +HEAPF32[$156>>2];
        $158 = $157 * $155;
        HEAPF32[$156>>2] = $158;
        $159 = +HEAPF32[$87>>2];
        $$sum18$17 = (($83) + 544)|0;
        $160 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum18$17<<2)|0);
        $161 = +HEAPF32[$160>>2];
        $162 = $161 * $159;
        HEAPF32[$160>>2] = $162;
       }
       $163 = ($$|0)==(2);
       if ($163) {
        $164 = (($83) + 288)|0;
        $165 = (($83) + 480)|0;
        $k$252 = -3;
        while(1) {
         $166 = (($k$252) + 3)|0;
         $167 = (7624 + ($166<<2)|0);
         $168 = +HEAPF32[$167>>2];
         $169 = $k$252 << 5;
         $$sum10 = (($164) + ($169))|0;
         $170 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($gr$058*2304)|0)|0) + ($$sum10<<2)|0);
         $171 = +HEAPF32[$170>>2];
         $172 = $171 * $168;
         $173 = (8 - ($k$252))|0;
         $174 = $173 << 5;
         $$sum11 = (($174) + ($83))|0;
         $175 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($gr$058*2304)|0)|0) + ($$sum11<<2)|0);
         $176 = +HEAPF32[$175>>2];
         $177 = $172 - $176;
         $178 = ($k$252*3)|0;
         $179 = (($178) + 9)|0;
         $180 = (($mdct_enc$054) + ($179<<2)|0);
         HEAPF32[$180>>2] = $177;
         $181 = (14 - ($k$252))|0;
         $182 = $181 << 5;
         $$sum12 = (($182) + ($83))|0;
         $183 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($gr$058*2304)|0)|0) + ($$sum12<<2)|0);
         $184 = +HEAPF32[$183>>2];
         $185 = $184 * $168;
         $$sum13 = (($165) + ($169))|0;
         $186 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($gr$058*2304)|0)|0) + ($$sum13<<2)|0);
         $187 = +HEAPF32[$186>>2];
         $188 = $185 + $187;
         $189 = (($178) + 18)|0;
         $190 = (($mdct_enc$054) + ($189<<2)|0);
         HEAPF32[$190>>2] = $188;
         $191 = +HEAPF32[$186>>2];
         $192 = $191 * $168;
         $193 = +HEAPF32[$183>>2];
         $194 = $192 - $193;
         $195 = (($178) + 10)|0;
         $196 = (($mdct_enc$054) + ($195<<2)|0);
         HEAPF32[$196>>2] = $194;
         $197 = (2 - ($k$252))|0;
         $198 = $197 << 5;
         $$sum14 = (($198) + ($83))|0;
         $199 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum14<<2)|0);
         $200 = +HEAPF32[$199>>2];
         $201 = $200 * $168;
         $202 = $166 << 5;
         $$sum15 = (($202) + ($83))|0;
         $203 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum15<<2)|0);
         $204 = +HEAPF32[$203>>2];
         $205 = $201 + $204;
         $206 = (($178) + 19)|0;
         $207 = (($mdct_enc$054) + ($206<<2)|0);
         HEAPF32[$207>>2] = $205;
         $208 = +HEAPF32[$203>>2];
         $209 = $208 * $168;
         $210 = +HEAPF32[$199>>2];
         $211 = $209 - $210;
         $212 = (($178) + 11)|0;
         $213 = (($mdct_enc$054) + ($212<<2)|0);
         HEAPF32[$213>>2] = $211;
         $214 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum11<<2)|0);
         $215 = +HEAPF32[$214>>2];
         $216 = $215 * $168;
         $217 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum10<<2)|0);
         $218 = +HEAPF32[$217>>2];
         $219 = $216 + $218;
         $220 = (($178) + 20)|0;
         $221 = (($mdct_enc$054) + ($220<<2)|0);
         HEAPF32[$221>>2] = $219;
         $222 = (($k$252) + 1)|0;
         $exitcond70 = ($222|0)==(0);
         if ($exitcond70) {
          $$02$i = $mdct_enc$054;$l$01$i = 0;
          break;
         } else {
          $k$252 = $222;
         }
        }
        while(1) {
         $223 = ((($$02$i)) + 24|0);
         $224 = +HEAPF32[$223>>2];
         $225 = $224 * 0.13165250420570374;
         $226 = ((($$02$i)) + 60|0);
         $227 = +HEAPF32[$226>>2];
         $228 = $225 - $227;
         $229 = +HEAPF32[$$02$i>>2];
         $230 = $229 * 0.76732701063156128;
         $231 = ((($$02$i)) + 36|0);
         $232 = +HEAPF32[$231>>2];
         $233 = $230 - $232;
         $234 = $233 + $228;
         $235 = $228 - $233;
         $236 = $227 * 0.13165250420570374;
         $237 = $236 + $224;
         $238 = $232 * 0.76732701063156128;
         $239 = $238 + $229;
         $240 = $239 + $237;
         $241 = $239 - $237;
         $242 = ((($$02$i)) + 12|0);
         $243 = +HEAPF32[$242>>2];
         $244 = $243 * 0.41421356797218323;
         $245 = ((($$02$i)) + 48|0);
         $246 = +HEAPF32[$245>>2];
         $247 = $244 - $246;
         $248 = $247;
         $249 = $248 * 2.0699781119530891E-11;
         $250 = $249;
         $251 = $246 * 0.41421356797218323;
         $252 = $251 + $243;
         $253 = $252;
         $254 = $253 * 2.0699781119530891E-11;
         $255 = $254;
         $256 = $234;
         $257 = $256 * 1.9075251917372799E-11;
         $258 = $250;
         $259 = $258 + $257;
         $260 = $259;
         HEAPF32[$$02$i>>2] = $260;
         $261 = -$240;
         $262 = $261;
         $263 = $262 * 1.9075251917372799E-11;
         $264 = $255;
         $265 = $264 + $263;
         $266 = $265;
         HEAPF32[$226>>2] = $266;
         $267 = $235;
         $268 = $267 * 1.6519652744032674E-11;
         $269 = $268;
         $270 = $240;
         $271 = $270 * 9.5376259586864042E-12;
         $272 = $264 + $271;
         $273 = $272;
         $274 = $269 - $273;
         HEAPF32[$242>>2] = $274;
         $275 = $273 + $269;
         HEAPF32[$223>>2] = $275;
         $276 = $256 * 9.5376259586864042E-12;
         $277 = $276 - $258;
         $278 = $277;
         $279 = $241;
         $280 = $279 * 1.6519652744032674E-11;
         $281 = $280;
         $282 = $278 + $281;
         HEAPF32[$231>>2] = $282;
         $283 = $278 - $281;
         HEAPF32[$245>>2] = $283;
         $284 = ((($$02$i)) + 4|0);
         $285 = (($l$01$i) + 1)|0;
         $exitcond$i = ($285|0)==(3);
         if ($exitcond$i) {
          break;
         } else {
          $$02$i = $284;$l$01$i = $285;
         }
        }
       } else {
        $k$351 = -9;
        while(1) {
         $286 = (($k$351) + 27)|0;
         $287 = ((7336 + (($$*144)|0)|0) + ($286<<2)|0);
         $288 = +HEAPF32[$287>>2];
         $289 = (($k$351) + 9)|0;
         $290 = $289 << 5;
         $$sum5 = (($290) + ($83))|0;
         $291 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum5<<2)|0);
         $292 = +HEAPF32[$291>>2];
         $293 = $292 * $288;
         $294 = (($k$351) + 36)|0;
         $295 = ((7336 + (($$*144)|0)|0) + ($294<<2)|0);
         $296 = +HEAPF32[$295>>2];
         $297 = (8 - ($k$351))|0;
         $298 = $297 << 5;
         $$sum6 = (($298) + ($83))|0;
         $299 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($23*2304)|0)|0) + ($$sum6<<2)|0);
         $300 = +HEAPF32[$299>>2];
         $301 = $300 * $296;
         $302 = $301 + $293;
         $303 = ((7336 + (($$*144)|0)|0) + ($289<<2)|0);
         $304 = +HEAPF32[$303>>2];
         $305 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($gr$058*2304)|0)|0) + ($$sum5<<2)|0);
         $306 = +HEAPF32[$305>>2];
         $307 = $306 * $304;
         $308 = (($k$351) + 18)|0;
         $309 = ((7336 + (($$*144)|0)|0) + ($308<<2)|0);
         $310 = +HEAPF32[$309>>2];
         $311 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0) + (($gr$058*2304)|0)|0) + ($$sum6<<2)|0);
         $312 = +HEAPF32[$311>>2];
         $313 = $312 * $310;
         $314 = $307 - $313;
         $$sum9 = (($k$351) + 12)|0;
         $315 = (7624 + ($$sum9<<2)|0);
         $316 = +HEAPF32[$315>>2];
         $317 = $314 * $316;
         $318 = $302 - $317;
         $319 = (($work) + ($289<<2)|0);
         HEAPF32[$319>>2] = $318;
         $320 = $316 * $302;
         $321 = $320 + $314;
         $322 = (($work) + ($308<<2)|0);
         HEAPF32[$322>>2] = $321;
         $323 = (($k$351) + 1)|0;
         $exitcond69 = ($323|0)==(0);
         if ($exitcond69) {
          break;
         } else {
          $k$351 = $323;
         }
        }
        $324 = +HEAPF32[$4>>2];
        $325 = +HEAPF32[$5>>2];
        $326 = $324 - $325;
        $327 = +HEAPF32[$6>>2];
        $328 = +HEAPF32[$7>>2];
        $329 = $327 - $328;
        $330 = +HEAPF32[$8>>2];
        $331 = +HEAPF32[$9>>2];
        $332 = $330 - $331;
        $333 = +HEAPF32[$work>>2];
        $334 = +HEAPF32[$10>>2];
        $335 = $334 + $333;
        $336 = +HEAPF32[$11>>2];
        $337 = +HEAPF32[$12>>2];
        $338 = $337 + $336;
        $339 = +HEAPF32[$13>>2];
        $340 = +HEAPF32[$14>>2];
        $341 = $340 + $339;
        $342 = +HEAPF32[$15>>2];
        $343 = +HEAPF32[$16>>2];
        $344 = $343 + $342;
        $345 = $341 + $335;
        $346 = $345 - $344;
        $347 = +HEAPF32[$17>>2];
        $$neg3$i = $347 - $338;
        $348 = $$neg3$i + $346;
        $349 = ((($mdct_enc$054)) + 68|0);
        HEAPF32[$349>>2] = $348;
        $350 = $346 * 0.5;
        $351 = +HEAPF32[$17>>2];
        $352 = $338 - $351;
        $353 = $350 + $352;
        $354 = $326 - $329;
        $355 = $354 - $332;
        $356 = $355 * 0.86602538824081421;
        $357 = $353 + $356;
        $358 = ((($mdct_enc$054)) + 20|0);
        HEAPF32[$358>>2] = $357;
        $359 = $356 - $353;
        $360 = ((($mdct_enc$054)) + 24|0);
        HEAPF32[$360>>2] = $359;
        $361 = +HEAPF32[$18>>2];
        $362 = +HEAPF32[$19>>2];
        $363 = $361 - $362;
        $364 = $363 * 0.86602538824081421;
        $365 = $338 * 0.5;
        $366 = +HEAPF32[$17>>2];
        $367 = $366 + $365;
        $368 = $326 * 0.98480772972106933;
        $369 = $329 * 0.6427876353263855;
        $370 = $332 * 0.34202015399932861;
        $371 = $369 + $368;
        $372 = $371 + $370;
        $373 = $372 + $364;
        $374 = $335 * 0.1736481785774231;
        $375 = $341 * 0.76604443788528442;
        $376 = $344 * 0.93969261646270751;
        $377 = $375 + $374;
        $378 = $377 + $376;
        $379 = $378 + $367;
        $380 = $373 + $379;
        $381 = ((($mdct_enc$054)) + 4|0);
        HEAPF32[$381>>2] = $380;
        $382 = $373 - $379;
        $383 = ((($mdct_enc$054)) + 8|0);
        HEAPF32[$383>>2] = $382;
        $384 = $326 * 0.6427876353263855;
        $385 = $329 * 0.34202015399932861;
        $386 = $332 * 0.98480772972106933;
        $387 = $384 - $385;
        $388 = $387 + $386;
        $389 = $388 - $364;
        $390 = $335 * 0.76604443788528442;
        $391 = $341 * 0.93969261646270751;
        $392 = $344 * 0.1736481785774231;
        $393 = $390 - $391;
        $394 = $393 - $392;
        $395 = $394 + $367;
        $396 = $389 + $395;
        $397 = ((($mdct_enc$054)) + 36|0);
        HEAPF32[$397>>2] = $396;
        $398 = $389 - $395;
        $399 = ((($mdct_enc$054)) + 40|0);
        HEAPF32[$399>>2] = $398;
        $400 = $326 * 0.34202015399932861;
        $401 = $329 * 0.98480772972106933;
        $402 = $332 * 0.6427876353263855;
        $403 = $401 + $400;
        $404 = $403 - $402;
        $405 = $404 - $364;
        $406 = $335 * 0.93969261646270751;
        $407 = $341 * 0.1736481785774231;
        $408 = $344 * 0.76604443788528442;
        $409 = $406 - $407;
        $410 = $409 + $408;
        $411 = $410 - $367;
        $412 = $411 + $405;
        $413 = ((($mdct_enc$054)) + 52|0);
        HEAPF32[$413>>2] = $412;
        $414 = $405 - $411;
        $415 = ((($mdct_enc$054)) + 56|0);
        HEAPF32[$415>>2] = $414;
        $416 = +HEAPF32[$10>>2];
        $417 = +HEAPF32[$work>>2];
        $418 = $416 - $417;
        $419 = +HEAPF32[$14>>2];
        $420 = +HEAPF32[$13>>2];
        $421 = $419 - $420;
        $422 = +HEAPF32[$16>>2];
        $423 = +HEAPF32[$15>>2];
        $424 = $422 - $423;
        $425 = +HEAPF32[$4>>2];
        $426 = +HEAPF32[$5>>2];
        $427 = $426 + $425;
        $428 = +HEAPF32[$18>>2];
        $429 = +HEAPF32[$19>>2];
        $430 = $429 + $428;
        $431 = +HEAPF32[$6>>2];
        $432 = +HEAPF32[$7>>2];
        $433 = $432 + $431;
        $434 = +HEAPF32[$8>>2];
        $435 = +HEAPF32[$9>>2];
        $436 = $435 + $434;
        $437 = $433 + $427;
        $438 = $437 + $436;
        $439 = +HEAPF32[$20>>2];
        $440 = $439 + $430;
        $441 = $440 + $438;
        HEAPF32[$mdct_enc$054>>2] = $441;
        $442 = $438 * 0.5;
        $443 = +HEAPF32[$20>>2];
        $$neg11$i = -$430;
        $$neg13$i = $$neg11$i - $443;
        $444 = $$neg13$i + $442;
        $445 = $418 - $421;
        $446 = $445 + $424;
        $447 = $446 * 0.86602538824081421;
        $448 = $444 + $447;
        $449 = ((($mdct_enc$054)) + 44|0);
        HEAPF32[$449>>2] = $448;
        $450 = $444 - $447;
        $451 = ((($mdct_enc$054)) + 48|0);
        HEAPF32[$451>>2] = $450;
        $452 = +HEAPF32[$12>>2];
        $453 = +HEAPF32[$11>>2];
        $454 = $452 - $453;
        $455 = $454 * 0.86602538824081421;
        $456 = +HEAPF32[$20>>2];
        $457 = $430 * 0.5;
        $458 = $456 - $457;
        $459 = $427 * 0.93969261646270751;
        $460 = $433 * 0.1736481785774231;
        $461 = $436 * 0.76604443788528442;
        $462 = $459 - $460;
        $463 = $462 - $461;
        $464 = $463 - $458;
        $465 = $418 * 0.34202015399932861;
        $466 = $421 * 0.98480772972106933;
        $467 = $424 * 0.6427876353263855;
        $468 = $466 + $465;
        $469 = $468 + $467;
        $470 = $469 + $455;
        $471 = $464 + $470;
        $472 = ((($mdct_enc$054)) + 12|0);
        HEAPF32[$472>>2] = $471;
        $473 = $464 - $470;
        $474 = ((($mdct_enc$054)) + 16|0);
        HEAPF32[$474>>2] = $473;
        $475 = $427 * 0.76604443788528442;
        $476 = $433 * 0.93969261646270751;
        $477 = $436 * 0.1736481785774231;
        $478 = $475 - $476;
        $479 = $478 + $477;
        $480 = $479 + $458;
        $481 = $418 * 0.6427876353263855;
        $482 = $421 * 0.34202015399932861;
        $483 = $424 * 0.98480772972106933;
        $484 = $481 - $482;
        $485 = $484 - $483;
        $486 = $485 + $455;
        $487 = $480 + $486;
        $488 = ((($mdct_enc$054)) + 28|0);
        HEAPF32[$488>>2] = $487;
        $489 = $480 - $486;
        $490 = ((($mdct_enc$054)) + 32|0);
        HEAPF32[$490>>2] = $489;
        $491 = $427 * 0.1736481785774231;
        $492 = $433 * 0.76604443788528442;
        $493 = $436 * 0.93969261646270751;
        $494 = $492 + $491;
        $495 = $494 - $493;
        $496 = $495 + $458;
        $497 = $418 * 0.98480772972106933;
        $498 = $421 * 0.6427876353263855;
        $499 = $424 * 0.34202015399932861;
        $500 = $498 + $497;
        $501 = $500 - $499;
        $502 = $501 - $455;
        $503 = $496 + $502;
        $504 = ((($mdct_enc$054)) + 60|0);
        HEAPF32[$504>>2] = $503;
        $505 = $496 - $502;
        $506 = ((($mdct_enc$054)) + 64|0);
        HEAPF32[$506>>2] = $505;
        break;
       }
      }
     } while(0);
     $507 = ($$|0)!=(2);
     $508 = ($band$156|0)!=(0);
     $or$cond3 = $508 & $507;
     if ($or$cond3) {
      $k$453 = 7;
      while(1) {
       $509 = (($mdct_enc$054) + ($k$453<<2)|0);
       $510 = +HEAPF32[$509>>2];
       $$sum = (($k$453) + 20)|0;
       $511 = (7624 + ($$sum<<2)|0);
       $512 = +HEAPF32[$511>>2];
       $513 = $512 * $510;
       $514 = $k$453 ^ -1;
       $515 = (($mdct_enc$054) + ($514<<2)|0);
       $516 = +HEAPF32[$515>>2];
       $$sum4 = (($k$453) + 28)|0;
       $517 = (7624 + ($$sum4<<2)|0);
       $518 = +HEAPF32[$517>>2];
       $519 = $518 * $516;
       $520 = $519 + $513;
       $521 = $518 * $510;
       $522 = $516 * $512;
       $523 = $521 - $522;
       HEAPF32[$515>>2] = $520;
       HEAPF32[$509>>2] = $523;
       $524 = (($k$453) + -1)|0;
       $525 = ($k$453|0)>(0);
       if ($525) {
        $k$453 = $524;
       } else {
        break;
       }
      }
     }
     $526 = (($band$156) + 1)|0;
     $527 = ((($mdct_enc$054)) + 72|0);
     $exitcond71 = ($526|0)==(32);
     if ($exitcond71) {
      break;
     } else {
      $band$156 = $526;$mdct_enc$054 = $527;
     }
    }
    $scevgep = ((($wk$157)) + 2304|0);
    $528 = (($gr$058) + 1)|0;
    $529 = HEAP32[$3>>2]|0;
    $530 = ($528|0)<($529|0);
    if ($530) {
     $gr$058 = $528;$wk$157 = $scevgep;
    } else {
     $$lcssa = $529;
     break;
    }
   }
   $531 = ($$lcssa|0)==(1);
   if ($531) {
    $532 = (((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0);
    $533 = (((((($gfc)) + 27824|0) + (($ch$060*4608)|0)|0)) + 2304|0);
    _memcpy(($532|0),($533|0),2304)|0;
   }
  }
  $534 = (($ch$060) + 1)|0;
  $535 = HEAP32[$0>>2]|0;
  $536 = ($534|0)<($535|0);
  if ($536) {
   $ch$060 = $534;$w0$pn59 = $w1;
  } else {
   break;
  }
 }
 STACKTOP = sp;return;
}
function _window_subband($x1,$a) {
 $x1 = $x1|0;
 $a = $a|0;
 var $$015 = 0, $0 = 0, $1 = 0, $10 = 0.0, $100 = 0, $101 = 0.0, $102 = 0.0, $103 = 0.0, $104 = 0, $105 = 0.0, $106 = 0.0, $107 = 0.0, $108 = 0, $109 = 0.0, $11 = 0, $110 = 0, $111 = 0.0, $112 = 0.0, $113 = 0.0, $114 = 0;
 var $115 = 0.0, $116 = 0.0, $117 = 0.0, $118 = 0, $119 = 0.0, $12 = 0.0, $120 = 0.0, $121 = 0.0, $122 = 0.0, $123 = 0.0, $124 = 0.0, $125 = 0.0, $126 = 0, $127 = 0.0, $128 = 0, $129 = 0.0, $13 = 0.0, $130 = 0.0, $131 = 0.0, $132 = 0;
 var $133 = 0.0, $134 = 0.0, $135 = 0.0, $136 = 0, $137 = 0.0, $138 = 0, $139 = 0.0, $14 = 0.0, $140 = 0.0, $141 = 0.0, $142 = 0, $143 = 0.0, $144 = 0.0, $145 = 0.0, $146 = 0, $147 = 0.0, $148 = 0, $149 = 0.0, $15 = 0, $150 = 0.0;
 var $151 = 0.0, $152 = 0, $153 = 0.0, $154 = 0.0, $155 = 0.0, $156 = 0, $157 = 0.0, $158 = 0.0, $159 = 0.0, $16 = 0.0, $160 = 0.0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0.0, $166 = 0.0, $167 = 0, $168 = 0, $169 = 0;
 var $17 = 0.0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0.0, $175 = 0.0, $176 = 0, $177 = 0.0, $178 = 0.0, $179 = 0, $18 = 0.0, $180 = 0.0, $181 = 0, $182 = 0.0, $183 = 0.0, $184 = 0.0, $185 = 0.0, $186 = 0, $187 = 0.0;
 var $188 = 0.0, $189 = 0.0, $19 = 0, $190 = 0, $191 = 0.0, $192 = 0, $193 = 0.0, $194 = 0.0, $195 = 0.0, $196 = 0.0, $197 = 0, $198 = 0.0, $199 = 0.0, $2 = 0.0, $20 = 0.0, $200 = 0.0, $201 = 0, $202 = 0.0, $203 = 0, $204 = 0.0;
 var $205 = 0.0, $206 = 0.0, $207 = 0.0, $208 = 0, $209 = 0.0, $21 = 0, $210 = 0.0, $211 = 0.0, $212 = 0, $213 = 0.0, $214 = 0, $215 = 0.0, $216 = 0.0, $217 = 0.0, $218 = 0.0, $219 = 0, $22 = 0.0, $220 = 0.0, $221 = 0.0, $222 = 0.0;
 var $223 = 0, $224 = 0.0, $225 = 0, $226 = 0.0, $227 = 0.0, $228 = 0.0, $229 = 0.0, $23 = 0.0, $230 = 0, $231 = 0.0, $232 = 0.0, $233 = 0.0, $234 = 0, $235 = 0.0, $236 = 0, $237 = 0.0, $238 = 0.0, $239 = 0.0, $24 = 0.0, $240 = 0.0;
 var $241 = 0, $242 = 0.0, $243 = 0.0, $244 = 0.0, $245 = 0, $246 = 0.0, $247 = 0, $248 = 0.0, $249 = 0.0, $25 = 0, $250 = 0.0, $251 = 0.0, $252 = 0, $253 = 0.0, $254 = 0.0, $255 = 0.0, $256 = 0.0, $257 = 0, $258 = 0.0, $259 = 0;
 var $26 = 0.0, $260 = 0.0, $261 = 0.0, $262 = 0.0, $263 = 0, $264 = 0.0, $265 = 0, $266 = 0.0, $267 = 0.0, $268 = 0, $269 = 0.0, $27 = 0.0, $270 = 0.0, $271 = 0.0, $272 = 0.0, $273 = 0.0, $274 = 0, $275 = 0.0, $276 = 0, $277 = 0.0;
 var $278 = 0.0, $279 = 0.0, $28 = 0.0, $280 = 0.0, $281 = 0, $282 = 0.0, $283 = 0, $284 = 0.0, $285 = 0.0, $286 = 0.0, $287 = 0.0, $288 = 0, $289 = 0.0, $29 = 0, $290 = 0, $291 = 0.0, $292 = 0.0, $293 = 0.0, $294 = 0.0, $295 = 0;
 var $296 = 0.0, $297 = 0, $298 = 0.0, $299 = 0.0, $3 = 0, $30 = 0.0, $300 = 0.0, $301 = 0.0, $302 = 0, $303 = 0.0, $304 = 0, $305 = 0.0, $306 = 0.0, $307 = 0.0, $308 = 0.0, $309 = 0, $31 = 0, $310 = 0.0, $311 = 0, $312 = 0.0;
 var $313 = 0.0, $314 = 0.0, $315 = 0.0, $316 = 0.0, $317 = 0.0, $318 = 0, $319 = 0.0, $32 = 0.0, $320 = 0, $321 = 0.0, $322 = 0.0, $323 = 0.0, $324 = 0.0, $325 = 0.0, $326 = 0.0, $327 = 0.0, $328 = 0.0, $329 = 0.0, $33 = 0.0, $330 = 0.0;
 var $331 = 0.0, $332 = 0.0, $333 = 0.0, $334 = 0.0, $335 = 0.0, $336 = 0.0, $337 = 0.0, $338 = 0.0, $339 = 0.0, $34 = 0.0, $340 = 0, $341 = 0.0, $342 = 0, $343 = 0.0, $344 = 0.0, $345 = 0.0, $346 = 0.0, $347 = 0, $348 = 0.0, $349 = 0;
 var $35 = 0, $350 = 0.0, $351 = 0.0, $352 = 0.0, $353 = 0.0, $354 = 0, $355 = 0.0, $356 = 0, $357 = 0.0, $358 = 0.0, $359 = 0.0, $36 = 0.0, $360 = 0.0, $361 = 0, $362 = 0.0, $363 = 0, $364 = 0.0, $365 = 0.0, $366 = 0.0, $367 = 0.0;
 var $368 = 0, $369 = 0.0, $37 = 0.0, $370 = 0, $371 = 0.0, $372 = 0.0, $373 = 0.0, $374 = 0.0, $375 = 0, $376 = 0.0, $377 = 0, $378 = 0.0, $379 = 0.0, $38 = 0.0, $380 = 0.0, $381 = 0.0, $382 = 0.0, $383 = 0.0, $384 = 0.0, $385 = 0.0;
 var $386 = 0.0, $387 = 0.0, $388 = 0.0, $389 = 0.0, $39 = 0, $390 = 0.0, $391 = 0.0, $392 = 0.0, $393 = 0.0, $394 = 0.0, $395 = 0.0, $396 = 0.0, $397 = 0.0, $398 = 0.0, $399 = 0.0, $4 = 0.0, $40 = 0.0, $400 = 0.0, $401 = 0.0, $402 = 0.0;
 var $403 = 0.0, $404 = 0.0, $405 = 0.0, $406 = 0.0, $407 = 0.0, $408 = 0.0, $409 = 0.0, $41 = 0, $410 = 0.0, $411 = 0.0, $412 = 0.0, $413 = 0.0, $414 = 0.0, $415 = 0.0, $416 = 0.0, $417 = 0.0, $418 = 0.0, $419 = 0.0, $42 = 0.0, $420 = 0.0;
 var $421 = 0.0, $422 = 0.0, $423 = 0.0, $424 = 0.0, $425 = 0.0, $426 = 0.0, $427 = 0.0, $428 = 0.0, $429 = 0.0, $43 = 0.0, $430 = 0.0, $431 = 0.0, $432 = 0.0, $433 = 0.0, $434 = 0.0, $435 = 0.0, $436 = 0.0, $437 = 0.0, $438 = 0.0, $439 = 0.0;
 var $44 = 0.0, $440 = 0.0, $441 = 0.0, $442 = 0.0, $443 = 0.0, $444 = 0.0, $445 = 0.0, $446 = 0.0, $447 = 0.0, $448 = 0.0, $449 = 0.0, $45 = 0, $450 = 0.0, $451 = 0.0, $452 = 0.0, $453 = 0.0, $454 = 0.0, $455 = 0.0, $456 = 0.0, $457 = 0.0;
 var $458 = 0.0, $459 = 0.0, $46 = 0.0, $460 = 0.0, $461 = 0.0, $462 = 0.0, $463 = 0.0, $464 = 0.0, $465 = 0.0, $466 = 0.0, $467 = 0.0, $468 = 0.0, $469 = 0.0, $47 = 0.0, $470 = 0.0, $471 = 0.0, $472 = 0.0, $473 = 0.0, $474 = 0.0, $475 = 0.0;
 var $476 = 0.0, $477 = 0.0, $478 = 0.0, $479 = 0.0, $48 = 0.0, $480 = 0.0, $481 = 0.0, $482 = 0.0, $483 = 0.0, $484 = 0.0, $485 = 0.0, $486 = 0.0, $487 = 0.0, $488 = 0.0, $489 = 0.0, $49 = 0, $490 = 0.0, $491 = 0.0, $492 = 0.0, $493 = 0.0;
 var $494 = 0.0, $495 = 0.0, $496 = 0.0, $497 = 0.0, $498 = 0.0, $499 = 0.0, $5 = 0.0, $50 = 0.0, $500 = 0.0, $501 = 0.0, $502 = 0.0, $503 = 0.0, $504 = 0.0, $505 = 0.0, $506 = 0.0, $507 = 0.0, $508 = 0.0, $509 = 0.0, $51 = 0, $510 = 0.0;
 var $511 = 0.0, $512 = 0.0, $513 = 0.0, $514 = 0.0, $515 = 0.0, $516 = 0.0, $517 = 0.0, $518 = 0.0, $519 = 0.0, $52 = 0.0, $520 = 0.0, $521 = 0.0, $522 = 0.0, $523 = 0.0, $524 = 0.0, $525 = 0.0, $526 = 0.0, $527 = 0.0, $528 = 0.0, $529 = 0.0;
 var $53 = 0.0, $530 = 0.0, $531 = 0.0, $532 = 0.0, $533 = 0.0, $534 = 0.0, $535 = 0.0, $536 = 0.0, $537 = 0.0, $538 = 0.0, $539 = 0.0, $54 = 0.0, $540 = 0.0, $541 = 0.0, $542 = 0.0, $543 = 0.0, $544 = 0.0, $545 = 0.0, $546 = 0.0, $547 = 0.0;
 var $548 = 0.0, $549 = 0.0, $55 = 0, $550 = 0.0, $551 = 0.0, $552 = 0.0, $553 = 0.0, $554 = 0.0, $555 = 0.0, $556 = 0.0, $557 = 0.0, $558 = 0.0, $559 = 0.0, $56 = 0.0, $560 = 0.0, $561 = 0.0, $562 = 0.0, $563 = 0.0, $564 = 0.0, $565 = 0.0;
 var $566 = 0.0, $567 = 0.0, $568 = 0.0, $569 = 0.0, $57 = 0.0, $570 = 0.0, $571 = 0.0, $572 = 0.0, $573 = 0.0, $574 = 0.0, $575 = 0.0, $576 = 0.0, $577 = 0.0, $578 = 0.0, $579 = 0.0, $58 = 0.0, $580 = 0.0, $581 = 0.0, $582 = 0.0, $583 = 0.0;
 var $584 = 0.0, $585 = 0.0, $586 = 0.0, $587 = 0.0, $588 = 0.0, $589 = 0.0, $59 = 0, $590 = 0.0, $591 = 0.0, $592 = 0.0, $593 = 0.0, $594 = 0.0, $595 = 0.0, $596 = 0.0, $597 = 0.0, $598 = 0.0, $599 = 0.0, $6 = 0, $60 = 0.0, $600 = 0.0;
 var $601 = 0.0, $602 = 0.0, $603 = 0.0, $604 = 0.0, $605 = 0.0, $606 = 0.0, $607 = 0.0, $608 = 0.0, $609 = 0.0, $61 = 0, $610 = 0.0, $611 = 0.0, $62 = 0.0, $63 = 0.0, $64 = 0.0, $65 = 0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0;
 var $7 = 0.0, $70 = 0.0, $71 = 0, $72 = 0.0, $73 = 0.0, $74 = 0.0, $75 = 0, $76 = 0.0, $77 = 0.0, $78 = 0.0, $79 = 0, $8 = 0.0, $80 = 0.0, $81 = 0, $82 = 0.0, $83 = 0.0, $84 = 0.0, $85 = 0, $86 = 0.0, $87 = 0.0;
 var $88 = 0.0, $89 = 0, $9 = 0, $90 = 0.0, $91 = 0, $92 = 0.0, $93 = 0.0, $94 = 0.0, $95 = 0, $96 = 0.0, $97 = 0.0, $98 = 0.0, $99 = 0.0, $exitcond = 0, $i$014 = 0, $wp$013 = 0, $x2$012 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($x1)) + -248|0);
 $$015 = $x1;$i$014 = -15;$wp$013 = (7952);$x2$012 = $0;
 while(1) {
  $1 = ((($wp$013)) + -40|0);
  $2 = +HEAPF32[$1>>2];
  $3 = ((($x2$012)) + -896|0);
  $4 = +HEAPF32[$3>>2];
  $5 = $4 * $2;
  $6 = ((($$015)) + 896|0);
  $7 = +HEAPF32[$6>>2];
  $8 = $7 * $2;
  $9 = ((($wp$013)) + -36|0);
  $10 = +HEAPF32[$9>>2];
  $11 = ((($x2$012)) + -640|0);
  $12 = +HEAPF32[$11>>2];
  $13 = $12 * $10;
  $14 = $13 + $5;
  $15 = ((($$015)) + 640|0);
  $16 = +HEAPF32[$15>>2];
  $17 = $16 * $10;
  $18 = $17 + $8;
  $19 = ((($wp$013)) + -32|0);
  $20 = +HEAPF32[$19>>2];
  $21 = ((($x2$012)) + -384|0);
  $22 = +HEAPF32[$21>>2];
  $23 = $22 * $20;
  $24 = $14 + $23;
  $25 = ((($$015)) + 384|0);
  $26 = +HEAPF32[$25>>2];
  $27 = $26 * $20;
  $28 = $18 + $27;
  $29 = ((($wp$013)) + -28|0);
  $30 = +HEAPF32[$29>>2];
  $31 = ((($x2$012)) + -128|0);
  $32 = +HEAPF32[$31>>2];
  $33 = $32 * $30;
  $34 = $24 + $33;
  $35 = ((($$015)) + 128|0);
  $36 = +HEAPF32[$35>>2];
  $37 = $36 * $30;
  $38 = $28 + $37;
  $39 = ((($wp$013)) + -24|0);
  $40 = +HEAPF32[$39>>2];
  $41 = ((($x2$012)) + 128|0);
  $42 = +HEAPF32[$41>>2];
  $43 = $42 * $40;
  $44 = $34 + $43;
  $45 = ((($$015)) + -128|0);
  $46 = +HEAPF32[$45>>2];
  $47 = $46 * $40;
  $48 = $38 + $47;
  $49 = ((($wp$013)) + -20|0);
  $50 = +HEAPF32[$49>>2];
  $51 = ((($x2$012)) + 384|0);
  $52 = +HEAPF32[$51>>2];
  $53 = $52 * $50;
  $54 = $44 + $53;
  $55 = ((($$015)) + -384|0);
  $56 = +HEAPF32[$55>>2];
  $57 = $56 * $50;
  $58 = $48 + $57;
  $59 = ((($wp$013)) + -16|0);
  $60 = +HEAPF32[$59>>2];
  $61 = ((($x2$012)) + 640|0);
  $62 = +HEAPF32[$61>>2];
  $63 = $62 * $60;
  $64 = $54 + $63;
  $65 = ((($$015)) + -640|0);
  $66 = +HEAPF32[$65>>2];
  $67 = $66 * $60;
  $68 = $58 + $67;
  $69 = ((($wp$013)) + -12|0);
  $70 = +HEAPF32[$69>>2];
  $71 = ((($x2$012)) + 896|0);
  $72 = +HEAPF32[$71>>2];
  $73 = $72 * $70;
  $74 = $64 + $73;
  $75 = ((($$015)) + -896|0);
  $76 = +HEAPF32[$75>>2];
  $77 = $76 * $70;
  $78 = $68 + $77;
  $79 = ((($wp$013)) + -8|0);
  $80 = +HEAPF32[$79>>2];
  $81 = ((($$015)) + -1024|0);
  $82 = +HEAPF32[$81>>2];
  $83 = $82 * $80;
  $84 = $74 + $83;
  $85 = ((($x2$012)) + 1024|0);
  $86 = +HEAPF32[$85>>2];
  $87 = $86 * $80;
  $88 = $78 - $87;
  $89 = ((($wp$013)) + -4|0);
  $90 = +HEAPF32[$89>>2];
  $91 = ((($$015)) + -768|0);
  $92 = +HEAPF32[$91>>2];
  $93 = $92 * $90;
  $94 = $84 + $93;
  $95 = ((($x2$012)) + 768|0);
  $96 = +HEAPF32[$95>>2];
  $97 = $96 * $90;
  $98 = $88 - $97;
  $99 = +HEAPF32[$wp$013>>2];
  $100 = ((($$015)) + -512|0);
  $101 = +HEAPF32[$100>>2];
  $102 = $101 * $99;
  $103 = $94 + $102;
  $104 = ((($x2$012)) + 512|0);
  $105 = +HEAPF32[$104>>2];
  $106 = $105 * $99;
  $107 = $98 - $106;
  $108 = ((($wp$013)) + 4|0);
  $109 = +HEAPF32[$108>>2];
  $110 = ((($$015)) + -256|0);
  $111 = +HEAPF32[$110>>2];
  $112 = $111 * $109;
  $113 = $103 + $112;
  $114 = ((($x2$012)) + 256|0);
  $115 = +HEAPF32[$114>>2];
  $116 = $115 * $109;
  $117 = $107 - $116;
  $118 = ((($wp$013)) + 8|0);
  $119 = +HEAPF32[$118>>2];
  $120 = +HEAPF32[$$015>>2];
  $121 = $120 * $119;
  $122 = $113 + $121;
  $123 = +HEAPF32[$x2$012>>2];
  $124 = $123 * $119;
  $125 = $117 - $124;
  $126 = ((($wp$013)) + 12|0);
  $127 = +HEAPF32[$126>>2];
  $128 = ((($$015)) + 256|0);
  $129 = +HEAPF32[$128>>2];
  $130 = $129 * $127;
  $131 = $122 + $130;
  $132 = ((($x2$012)) + -256|0);
  $133 = +HEAPF32[$132>>2];
  $134 = $133 * $127;
  $135 = $125 - $134;
  $136 = ((($wp$013)) + 16|0);
  $137 = +HEAPF32[$136>>2];
  $138 = ((($$015)) + 512|0);
  $139 = +HEAPF32[$138>>2];
  $140 = $139 * $137;
  $141 = $131 + $140;
  $142 = ((($x2$012)) + -512|0);
  $143 = +HEAPF32[$142>>2];
  $144 = $143 * $137;
  $145 = $135 - $144;
  $146 = ((($wp$013)) + 20|0);
  $147 = +HEAPF32[$146>>2];
  $148 = ((($$015)) + 768|0);
  $149 = +HEAPF32[$148>>2];
  $150 = $149 * $147;
  $151 = $141 + $150;
  $152 = ((($x2$012)) + -768|0);
  $153 = +HEAPF32[$152>>2];
  $154 = $153 * $147;
  $155 = $145 - $154;
  $156 = ((($wp$013)) + 24|0);
  $157 = +HEAPF32[$156>>2];
  $158 = $151 * $157;
  $159 = $155 - $158;
  $160 = $155 + $158;
  $161 = $i$014 << 1;
  $162 = (($161) + 30)|0;
  $163 = (($a) + ($162<<2)|0);
  HEAPF32[$163>>2] = $160;
  $164 = ((($wp$013)) + 28|0);
  $165 = +HEAPF32[$164>>2];
  $166 = $159 * $165;
  $167 = (($161) + 31)|0;
  $168 = (($a) + ($167<<2)|0);
  HEAPF32[$168>>2] = $166;
  $169 = ((($wp$013)) + 72|0);
  $170 = ((($$015)) + -4|0);
  $171 = ((($x2$012)) + 4|0);
  $172 = (($i$014) + 1)|0;
  $exitcond = ($172|0)==(0);
  if ($exitcond) {
   break;
  } else {
   $$015 = $170;$i$014 = $172;$wp$013 = $169;$x2$012 = $171;
  }
 }
 $173 = ((($x1)) + -124|0);
 $174 = +HEAPF32[$173>>2];
 $175 = $174 * 10612.802734375;
 $176 = ((($x1)) + -188|0);
 $177 = +HEAPF32[$176>>2];
 $178 = $177 * 12804.7978515625;
 $179 = ((($x1)) + -252|0);
 $180 = +HEAPF32[$179>>2];
 $181 = ((($x1)) + 4|0);
 $182 = +HEAPF32[$181>>2];
 $183 = $180 - $182;
 $184 = $183 * 5302.158203125;
 $185 = $184 + $175;
 $186 = ((($x1)) + -444|0);
 $187 = +HEAPF32[$186>>2];
 $188 = $187 * 1945.5516357421875;
 $189 = $188 + $178;
 $190 = ((($x1)) + -380|0);
 $191 = +HEAPF32[$190>>2];
 $192 = ((($x1)) + 132|0);
 $193 = +HEAPF32[$192>>2];
 $194 = $193 + $191;
 $195 = $194 * 929.77630615234375;
 $196 = $185 + $195;
 $197 = ((($x1)) + -700|0);
 $198 = +HEAPF32[$197>>2];
 $199 = $198 * 313.42449951171875;
 $200 = $189 + $199;
 $201 = ((($x1)) + -508|0);
 $202 = +HEAPF32[$201>>2];
 $203 = ((($x1)) + 260|0);
 $204 = +HEAPF32[$203>>2];
 $205 = $202 - $204;
 $206 = $205 * 728.80108642578125;
 $207 = $196 + $206;
 $208 = ((($x1)) + -956|0);
 $209 = +HEAPF32[$208>>2];
 $210 = $209 * 20.801593780517578;
 $211 = $200 + $210;
 $212 = ((($x1)) + -636|0);
 $213 = +HEAPF32[$212>>2];
 $214 = ((($x1)) + 388|0);
 $215 = +HEAPF32[$214>>2];
 $216 = $215 + $213;
 $217 = $216 * 288.09765625;
 $218 = $207 + $217;
 $219 = ((($x1)) + 68|0);
 $220 = +HEAPF32[$219>>2];
 $221 = $220 * 1995.1556396484375;
 $222 = $211 - $221;
 $223 = ((($x1)) + -764|0);
 $224 = +HEAPF32[$223>>2];
 $225 = ((($x1)) + 516|0);
 $226 = +HEAPF32[$225>>2];
 $227 = $224 - $226;
 $228 = $227 * 64.917388916015625;
 $229 = $218 + $228;
 $230 = ((($x1)) + 324|0);
 $231 = +HEAPF32[$230>>2];
 $232 = $231 * 9.0008392333984375;
 $233 = $222 - $232;
 $234 = ((($x1)) + -892|0);
 $235 = +HEAPF32[$234>>2];
 $236 = ((($x1)) + 644|0);
 $237 = +HEAPF32[$236>>2];
 $238 = $237 + $235;
 $239 = $238 * 30.125003814697266;
 $240 = $229 + $239;
 $241 = ((($x1)) + 580|0);
 $242 = +HEAPF32[$241>>2];
 $243 = $242 * -29.202180862426758;
 $244 = $233 - $243;
 $245 = ((($x1)) + -1020|0);
 $246 = +HEAPF32[$245>>2];
 $247 = ((($x1)) + 772|0);
 $248 = +HEAPF32[$247>>2];
 $249 = $246 - $248;
 $250 = $249 * 4.1014566421508789;
 $251 = $240 + $250;
 $252 = ((($x1)) + 836|0);
 $253 = +HEAPF32[$252>>2];
 $254 = $244 - $253;
 $255 = $254 - $251;
 $256 = $254 + $251;
 $257 = ((($a)) + 56|0);
 $258 = +HEAPF32[$257>>2];
 $259 = ((($a)) + 60|0);
 $260 = +HEAPF32[$259>>2];
 $261 = $260 - $258;
 $262 = $256 + $258;
 $263 = ((($a)) + 124|0);
 $264 = $261 + $255;
 $265 = ((($a)) + 120|0);
 $266 = $255 - $261;
 $267 = $256 - $258;
 $268 = ((($a)) + 112|0);
 $269 = +HEAPF32[$268>>2];
 $270 = +HEAPF32[$a>>2];
 $271 = $269 - $270;
 $272 = $270 + $269;
 HEAPF32[$a>>2] = $272;
 $273 = $271 * 1.9615705013275146;
 HEAPF32[$268>>2] = $273;
 $274 = ((($a)) + 116|0);
 $275 = +HEAPF32[$274>>2];
 $276 = ((($a)) + 4|0);
 $277 = +HEAPF32[$276>>2];
 $278 = $275 - $277;
 $279 = $277 + $275;
 HEAPF32[$276>>2] = $279;
 $280 = $278 * 1.9615705013275146;
 HEAPF32[$274>>2] = $280;
 $281 = ((($a)) + 104|0);
 $282 = +HEAPF32[$281>>2];
 $283 = ((($a)) + 8|0);
 $284 = +HEAPF32[$283>>2];
 $285 = $282 - $284;
 $286 = $284 + $282;
 HEAPF32[$283>>2] = $286;
 $287 = $285 * 1.8477590084075928;
 HEAPF32[$281>>2] = $287;
 $288 = ((($a)) + 108|0);
 $289 = +HEAPF32[$288>>2];
 $290 = ((($a)) + 12|0);
 $291 = +HEAPF32[$290>>2];
 $292 = $289 - $291;
 $293 = $291 + $289;
 HEAPF32[$290>>2] = $293;
 $294 = $292 * 1.8477590084075928;
 HEAPF32[$288>>2] = $294;
 $295 = ((($a)) + 96|0);
 $296 = +HEAPF32[$295>>2];
 $297 = ((($a)) + 16|0);
 $298 = +HEAPF32[$297>>2];
 $299 = $296 - $298;
 $300 = $298 + $296;
 HEAPF32[$297>>2] = $300;
 $301 = $299 * 1.662939190864563;
 HEAPF32[$295>>2] = $301;
 $302 = ((($a)) + 100|0);
 $303 = +HEAPF32[$302>>2];
 $304 = ((($a)) + 20|0);
 $305 = +HEAPF32[$304>>2];
 $306 = $303 - $305;
 $307 = $305 + $303;
 HEAPF32[$304>>2] = $307;
 $308 = $306 * 1.662939190864563;
 HEAPF32[$302>>2] = $308;
 $309 = ((($a)) + 88|0);
 $310 = +HEAPF32[$309>>2];
 $311 = ((($a)) + 24|0);
 $312 = +HEAPF32[$311>>2];
 $313 = $310 - $312;
 $314 = $312 + $310;
 $315 = $313;
 $316 = $315 * 1.4142135623730951;
 $317 = $316;
 $318 = ((($a)) + 92|0);
 $319 = +HEAPF32[$318>>2];
 $320 = ((($a)) + 28|0);
 $321 = +HEAPF32[$320>>2];
 $322 = $319 - $321;
 $323 = $321 + $319;
 $324 = $322;
 $325 = $324 * 1.4142135623730951;
 $326 = $323;
 $327 = $325 - $326;
 $328 = $327;
 $329 = $323 - $314;
 $330 = $317 - $329;
 $331 = $328 - $330;
 $332 = $262 - $314;
 HEAPF32[$311>>2] = $332;
 $333 = $262 + $314;
 HEAPF32[$263>>2] = $333;
 $334 = $264 - $329;
 HEAPF32[$320>>2] = $334;
 $335 = $264 + $329;
 HEAPF32[$265>>2] = $335;
 $336 = $266 - $330;
 HEAPF32[$309>>2] = $336;
 $337 = $266 + $330;
 HEAPF32[$259>>2] = $337;
 $338 = $267 - $331;
 HEAPF32[$318>>2] = $338;
 $339 = $267 + $331;
 HEAPF32[$257>>2] = $339;
 $340 = ((($a)) + 80|0);
 $341 = +HEAPF32[$340>>2];
 $342 = ((($a)) + 32|0);
 $343 = +HEAPF32[$342>>2];
 $344 = $341 - $343;
 $345 = $343 + $341;
 $346 = $344 * 1.1111404895782471;
 $347 = ((($a)) + 84|0);
 $348 = +HEAPF32[$347>>2];
 $349 = ((($a)) + 36|0);
 $350 = +HEAPF32[$349>>2];
 $351 = $348 - $350;
 $352 = $350 + $348;
 $353 = $351 * 1.1111404895782471;
 $354 = ((($a)) + 72|0);
 $355 = +HEAPF32[$354>>2];
 $356 = ((($a)) + 40|0);
 $357 = +HEAPF32[$356>>2];
 $358 = $355 - $357;
 $359 = $357 + $355;
 $360 = $358 * 0.76536685228347778;
 $361 = ((($a)) + 76|0);
 $362 = +HEAPF32[$361>>2];
 $363 = ((($a)) + 44|0);
 $364 = +HEAPF32[$363>>2];
 $365 = $362 - $364;
 $366 = $364 + $362;
 $367 = $365 * 0.76536685228347778;
 $368 = ((($a)) + 64|0);
 $369 = +HEAPF32[$368>>2];
 $370 = ((($a)) + 48|0);
 $371 = +HEAPF32[$370>>2];
 $372 = $369 - $371;
 $373 = $371 + $369;
 $374 = $372 * 0.39018064737319946;
 $375 = ((($a)) + 68|0);
 $376 = +HEAPF32[$375>>2];
 $377 = ((($a)) + 52|0);
 $378 = +HEAPF32[$377>>2];
 $379 = $376 - $378;
 $380 = $378 + $376;
 $381 = $379 * 0.39018064737319946;
 $382 = +HEAPF32[$295>>2];
 $383 = $382 - $346;
 $384 = $382 + $346;
 HEAPF32[$340>>2] = $384;
 $385 = $383 * 0.76536685228347778;
 HEAPF32[$295>>2] = $385;
 $386 = +HEAPF32[$302>>2];
 $387 = $386 - $353;
 $388 = $386 + $353;
 HEAPF32[$347>>2] = $388;
 $389 = $387 * 0.76536685228347778;
 HEAPF32[$302>>2] = $389;
 $390 = +HEAPF32[$297>>2];
 $391 = $390 - $345;
 $392 = $345 + $390;
 HEAPF32[$297>>2] = $392;
 $393 = $391 * 0.76536685228347778;
 HEAPF32[$342>>2] = $393;
 $394 = +HEAPF32[$304>>2];
 $395 = $394 - $352;
 $396 = $352 + $394;
 HEAPF32[$304>>2] = $396;
 $397 = $395 * 0.76536685228347778;
 HEAPF32[$349>>2] = $397;
 $398 = +HEAPF32[$a>>2];
 $399 = $398 - $373;
 $400 = $373 + $398;
 HEAPF32[$a>>2] = $400;
 $401 = $399 * 1.8477590084075928;
 HEAPF32[$370>>2] = $401;
 $402 = +HEAPF32[$276>>2];
 $403 = $402 - $380;
 $404 = $380 + $402;
 HEAPF32[$276>>2] = $404;
 $405 = $403 * 1.8477590084075928;
 HEAPF32[$377>>2] = $405;
 $406 = +HEAPF32[$268>>2];
 $407 = $374 - $406;
 $408 = $406 + $374;
 HEAPF32[$368>>2] = $408;
 $409 = $407 * 1.8477590084075928;
 HEAPF32[$268>>2] = $409;
 $410 = +HEAPF32[$274>>2];
 $411 = $410 - $381;
 $412 = $410 + $381;
 HEAPF32[$375>>2] = $412;
 $413 = $411 * 1.8477590084075928;
 HEAPF32[$274>>2] = $413;
 $414 = +HEAPF32[$283>>2];
 $415 = $414 - $359;
 $416 = $415;
 $417 = $416 * 1.4142135623730951;
 $418 = $417;
 $419 = $359 + $414;
 $420 = +HEAPF32[$290>>2];
 $421 = $420 - $366;
 $422 = $421;
 $423 = $422 * 1.4142135623730951;
 $424 = $423;
 $425 = $366 + $420;
 $426 = +HEAPF32[$281>>2];
 $427 = $426 - $360;
 $428 = $427;
 $429 = $428 * 1.4142135623730951;
 $430 = $429;
 $431 = $426 + $360;
 $432 = $430 - $431;
 $433 = +HEAPF32[$288>>2];
 $434 = $433 - $367;
 $435 = $434;
 $436 = $435 * 1.4142135623730951;
 $437 = $436;
 $438 = $433 + $367;
 $439 = $437 - $438;
 $440 = $438 - $425;
 $441 = $425 - $419;
 $442 = +HEAPF32[$263>>2];
 $443 = $442 - $419;
 HEAPF32[$283>>2] = $443;
 $444 = $442 + $419;
 HEAPF32[$263>>2] = $444;
 $445 = $424 - $440;
 $446 = $431 - $441;
 $447 = +HEAPF32[$265>>2];
 $448 = $447 - $441;
 HEAPF32[$290>>2] = $448;
 $449 = $447 + $441;
 HEAPF32[$265>>2] = $449;
 $450 = $439 - $445;
 $451 = $440 - $446;
 $452 = +HEAPF32[$259>>2];
 $453 = $452 - $446;
 HEAPF32[$354>>2] = $453;
 $454 = $452 + $446;
 HEAPF32[$259>>2] = $454;
 $455 = $418 - $451;
 $456 = +HEAPF32[$257>>2];
 $457 = $456 - $451;
 HEAPF32[$361>>2] = $457;
 $458 = $456 + $451;
 HEAPF32[$257>>2] = $458;
 $459 = $445 - $455;
 $460 = +HEAPF32[$318>>2];
 $461 = $460 - $455;
 HEAPF32[$356>>2] = $461;
 $462 = $460 + $455;
 HEAPF32[$318>>2] = $462;
 $463 = $432 - $459;
 $464 = +HEAPF32[$309>>2];
 $465 = $464 - $459;
 HEAPF32[$363>>2] = $465;
 $466 = $464 + $459;
 HEAPF32[$309>>2] = $466;
 $467 = $450 - $463;
 $468 = +HEAPF32[$320>>2];
 $469 = $468 - $463;
 HEAPF32[$281>>2] = $469;
 $470 = $468 + $463;
 HEAPF32[$320>>2] = $470;
 $471 = +HEAPF32[$311>>2];
 $472 = $471 - $467;
 HEAPF32[$288>>2] = $472;
 $473 = $471 + $467;
 HEAPF32[$311>>2] = $473;
 $474 = +HEAPF32[$a>>2];
 $475 = +HEAPF32[$297>>2];
 $476 = $474 - $475;
 $477 = $476;
 $478 = $477 * 1.4142135623730951;
 $479 = $478;
 $480 = $475 + $474;
 HEAPF32[$a>>2] = $480;
 HEAPF32[$297>>2] = $479;
 $481 = +HEAPF32[$276>>2];
 $482 = +HEAPF32[$304>>2];
 $483 = $481 - $482;
 $484 = $483;
 $485 = $484 * 1.4142135623730951;
 $486 = $485;
 $487 = $482 + $481;
 $488 = +HEAPF32[$368>>2];
 $489 = +HEAPF32[$340>>2];
 $490 = $488 - $489;
 $491 = $490;
 $492 = $491 * 1.4142135623730951;
 $493 = $492;
 $494 = $489 + $488;
 $495 = +HEAPF32[$375>>2];
 $496 = +HEAPF32[$347>>2];
 $497 = $495 - $496;
 $498 = $497;
 $499 = $498 * 1.4142135623730951;
 $500 = $499;
 $501 = $496 + $495;
 $502 = +HEAPF32[$342>>2];
 $503 = +HEAPF32[$370>>2];
 $504 = $502 - $503;
 $505 = $504;
 $506 = $505 * -1.4142135623730951;
 $507 = $506;
 $508 = $503 + $502;
 $509 = $507 - $508;
 $510 = +HEAPF32[$349>>2];
 $511 = +HEAPF32[$377>>2];
 $512 = $510 - $511;
 $513 = $512;
 $514 = $513 * -1.4142135623730951;
 $515 = $514;
 $516 = $511 + $510;
 $517 = $515 - $516;
 $518 = +HEAPF32[$302>>2];
 $519 = +HEAPF32[$274>>2];
 $520 = $518 - $519;
 $521 = $520;
 $522 = $521 * -1.4142135623730951;
 $523 = $522;
 $524 = $519 + $518;
 $525 = $523 - $524;
 $526 = +HEAPF32[$295>>2];
 $527 = +HEAPF32[$268>>2];
 $528 = $527 + $526;
 $529 = $528;
 $530 = $529 * -1.4142135623730951;
 $531 = $530;
 $532 = $526 - $527;
 $533 = $531 - $532;
 $534 = $532 - $494;
 $535 = $493 - $534;
 $536 = $533 - $535;
 $537 = $524 - $501;
 $538 = $500 - $537;
 $539 = $525 - $538;
 $540 = $501 - $487;
 $541 = $516 - $540;
 $542 = $537 - $541;
 $543 = $486 - $542;
 $544 = $538 - $543;
 $545 = $517 - $544;
 $546 = $539 - $545;
 $547 = $487 - $480;
 $548 = $494 - $547;
 $549 = $540 - $548;
 $550 = $508 - $549;
 $551 = $541 - $550;
 $552 = $534 - $551;
 $553 = $542 - $552;
 $554 = +HEAPF32[$297>>2];
 $555 = $554 - $553;
 $556 = $543 - $555;
 $557 = $535 - $556;
 $558 = $544 - $557;
 $559 = $509 - $558;
 $560 = $545 - $559;
 $561 = $536 - $560;
 $562 = $546 - $561;
 $563 = +HEAPF32[$a>>2];
 $564 = +HEAPF32[$263>>2];
 $565 = $564 + $563;
 HEAPF32[$a>>2] = $565;
 $566 = $564 - $563;
 HEAPF32[$263>>2] = $566;
 $567 = +HEAPF32[$265>>2];
 $568 = $567 + $547;
 HEAPF32[$276>>2] = $568;
 $569 = $567 - $547;
 HEAPF32[$265>>2] = $569;
 $570 = +HEAPF32[$259>>2];
 $571 = $570 + $548;
 HEAPF32[$368>>2] = $571;
 $572 = $570 - $548;
 HEAPF32[$259>>2] = $572;
 $573 = +HEAPF32[$257>>2];
 $574 = $573 + $549;
 HEAPF32[$375>>2] = $574;
 $575 = $573 - $549;
 HEAPF32[$257>>2] = $575;
 $576 = +HEAPF32[$318>>2];
 $577 = $576 + $550;
 HEAPF32[$342>>2] = $577;
 $578 = $576 - $550;
 HEAPF32[$318>>2] = $578;
 $579 = +HEAPF32[$309>>2];
 $580 = $579 + $551;
 HEAPF32[$349>>2] = $580;
 $581 = $579 - $551;
 HEAPF32[$309>>2] = $581;
 $582 = +HEAPF32[$320>>2];
 $583 = $582 + $552;
 HEAPF32[$295>>2] = $583;
 $584 = $582 - $552;
 HEAPF32[$320>>2] = $584;
 $585 = +HEAPF32[$311>>2];
 $586 = $585 + $553;
 HEAPF32[$302>>2] = $586;
 $587 = $585 - $553;
 HEAPF32[$311>>2] = $587;
 $588 = +HEAPF32[$288>>2];
 $589 = $588 + $555;
 HEAPF32[$297>>2] = $589;
 $590 = $588 - $555;
 HEAPF32[$288>>2] = $590;
 $591 = +HEAPF32[$281>>2];
 $592 = $591 + $556;
 HEAPF32[$304>>2] = $592;
 $593 = $591 - $556;
 HEAPF32[$281>>2] = $593;
 $594 = +HEAPF32[$363>>2];
 $595 = $594 + $557;
 HEAPF32[$340>>2] = $595;
 $596 = $594 - $557;
 HEAPF32[$363>>2] = $596;
 $597 = +HEAPF32[$356>>2];
 $598 = $597 + $558;
 HEAPF32[$347>>2] = $598;
 $599 = $597 - $558;
 HEAPF32[$356>>2] = $599;
 $600 = +HEAPF32[$361>>2];
 $601 = $600 + $559;
 HEAPF32[$370>>2] = $601;
 $602 = $600 - $559;
 HEAPF32[$361>>2] = $602;
 $603 = +HEAPF32[$354>>2];
 $604 = $603 + $560;
 HEAPF32[$377>>2] = $604;
 $605 = $603 - $560;
 HEAPF32[$354>>2] = $605;
 $606 = +HEAPF32[$290>>2];
 $607 = $606 + $561;
 HEAPF32[$268>>2] = $607;
 $608 = $606 - $561;
 HEAPF32[$290>>2] = $608;
 $609 = +HEAPF32[$283>>2];
 $610 = $609 + $562;
 HEAPF32[$274>>2] = $610;
 $611 = $609 - $562;
 HEAPF32[$283>>2] = $611;
 return;
}
function _apply_preset($gfp,$preset,$enforce) {
 $gfp = $gfp|0;
 $preset = $preset|0;
 $enforce = $enforce|0;
 var $$0 = 0, $$02$off = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 L1: do {
  switch ($preset|0) {
  case 1004: case 1001:  {
   (_lame_set_VBR($gfp,4)|0);
   $2 = ((($gfp)) + 152|0);
   HEAP32[$2>>2] = 480;
   label = 15;
   break;
  }
  case 1007: case 1006:  {
   (_lame_set_VBR($gfp,4)|0);
   $1 = ((($gfp)) + 152|0);
   HEAP32[$1>>2] = 460;
   label = 13;
   break;
  }
  case 1005: case 1002:  {
   (_lame_set_VBR($gfp,4)|0);
   $3 = ((($gfp)) + 152|0);
   HEAP32[$3>>2] = 500;
   label = 17;
   break;
  }
  case 1003:  {
   $4 = ((($gfp)) + 152|0);
   HEAP32[$4>>2] = 320;
   (_apply_abr_preset($gfp,320,$enforce)|0);
   (_lame_set_VBR($gfp,0)|0);
   $$0 = 320;
   return ($$0|0);
   break;
  }
  case 1000:  {
   (_lame_set_VBR($gfp,4)|0);
   $0 = ((($gfp)) + 152|0);
   HEAP32[$0>>2] = 470;
   label = 14;
   break;
  }
  default: {
   $5 = ((($gfp)) + 152|0);
   HEAP32[$5>>2] = $preset;
   switch ($preset|0) {
   case 490:  {
    _apply_vbr_preset($gfp,1,$enforce);
    $$0 = 490;
    return ($$0|0);
    break;
   }
   case 470:  {
    label = 14;
    break L1;
    break;
   }
   case 410:  {
    _apply_vbr_preset($gfp,9,$enforce);
    $$0 = 410;
    return ($$0|0);
    break;
   }
   case 450:  {
    _apply_vbr_preset($gfp,5,$enforce);
    $$0 = 450;
    return ($$0|0);
    break;
   }
   case 420:  {
    _apply_vbr_preset($gfp,8,$enforce);
    $$0 = 420;
    return ($$0|0);
    break;
   }
   case 500:  {
    label = 17;
    break L1;
    break;
   }
   case 440:  {
    _apply_vbr_preset($gfp,6,$enforce);
    $$0 = 440;
    return ($$0|0);
    break;
   }
   case 480:  {
    label = 15;
    break L1;
    break;
   }
   case 460:  {
    label = 13;
    break L1;
    break;
   }
   case 430:  {
    _apply_vbr_preset($gfp,7,$enforce);
    $$0 = 430;
    return ($$0|0);
    break;
   }
   default: {
    $$02$off = (($preset) + -8)|0;
    $6 = ($$02$off>>>0)<(313);
    if ($6) {
     $7 = (_apply_abr_preset($gfp,$preset,$enforce)|0);
     $$0 = $7;
     return ($$0|0);
    } else {
     HEAP32[$5>>2] = 0;
     $$0 = $preset;
     return ($$0|0);
    }
   }
   }
  }
  }
 } while(0);
 if ((label|0) == 13) {
  _apply_vbr_preset($gfp,4,$enforce);
  $$0 = 460;
  return ($$0|0);
 }
 else if ((label|0) == 14) {
  _apply_vbr_preset($gfp,3,$enforce);
  $$0 = 470;
  return ($$0|0);
 }
 else if ((label|0) == 15) {
  _apply_vbr_preset($gfp,2,$enforce);
  $$0 = 480;
  return ($$0|0);
 }
 else if ((label|0) == 17) {
  _apply_vbr_preset($gfp,0,$enforce);
  $$0 = 500;
  return ($$0|0);
 }
 return (0)|0;
}
function _apply_abr_preset($gfp,$preset,$enforce) {
 $gfp = $gfp|0;
 $preset = $preset|0;
 $enforce = $enforce|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0.0, $22 = 0.0, $23 = 0, $24 = 0, $25 = 0.0, $26 = 0.0;
 var $27 = 0.0, $28 = 0.0, $29 = 0, $3 = 0, $30 = 0, $31 = 0.0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0.0, $38 = 0.0, $39 = 0, $4 = 0, $40 = 0.0, $41 = 0, $42 = 0.0, $43 = 0.0, $44 = 0.0;
 var $45 = 0, $46 = 0, $47 = 0.0, $48 = 0.0, $49 = 0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0.0, $53 = 0, $54 = 0, $55 = 0.0, $56 = 0.0, $57 = 0, $58 = 0, $59 = 0.0, $6 = 0, $60 = 0.0, $61 = 0.0, $62 = 0.0;
 var $63 = 0.0, $64 = 0, $65 = 0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0, $7 = 0, $70 = 0, $71 = 0.0, $72 = 0, $73 = 0.0, $74 = 0.0, $75 = 0.0, $76 = 0.0, $77 = 0, $78 = 0.0, $79 = 0, $8 = 0, $80 = 0.0;
 var $81 = 0, $82 = 0.0, $83 = 0.0, $84 = 0.0, $85 = 0, $86 = 0, $87 = 0.0, $88 = 0, $89 = 0, $9 = 0, $90 = 0.0, $91 = 0.0, $92 = 0.0, $93 = 0, $94 = 0, $95 = 0, $a$$i = 0, $a$$i1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = $preset&65535;
 $1 = (_nearestBitrateFullIndex($0)|0);
 (_lame_set_VBR($gfp,3)|0);
 (_lame_set_VBR_mean_bitrate_kbps($gfp,$preset)|0);
 $2 = (_lame_get_VBR_mean_bitrate_kbps($gfp)|0);
 $3 = ($2|0)<(320);
 $a$$i = $3 ? $2 : 320;
 (_lame_set_VBR_mean_bitrate_kbps($gfp,$a$$i)|0);
 $4 = (_lame_get_VBR_mean_bitrate_kbps($gfp)|0);
 $5 = ($4|0)>(8);
 $a$$i1 = $5 ? $4 : 8;
 (_lame_set_VBR_mean_bitrate_kbps($gfp,$a$$i1)|0);
 $6 = (_lame_get_VBR_mean_bitrate_kbps($gfp)|0);
 (_lame_set_brate($gfp,$6)|0);
 $7 = (($1) + -12)|0;
 $8 = ($7>>>0)<(5);
 if ($8) {
  $9 = (_lame_get_exp_nspsytune($gfp)|0);
  $10 = $9 | 2;
  (_lame_set_exp_nspsytune($gfp,$10)|0);
 }
 $11 = ($1>>>0)<(13);
 if ($11) {
  (_lame_set_sfscale($gfp,1)|0);
 }
 $12 = ($enforce|0)!=(0);
 if ($12) {
  $32 = (((10560 + (($1*52)|0)|0)) + 4|0);
  $33 = HEAP32[$32>>2]|0;
  (_lame_set_quant_comp($gfp,$33)|0);
  $34 = (((10560 + (($1*52)|0)|0)) + 8|0);
  $35 = HEAP32[$34>>2]|0;
  (_lame_set_quant_comp_short($gfp,$35)|0);
  $36 = (((10560 + (($1*52)|0)|0)) + 16|0);
  $37 = +HEAPF32[$36>>2];
  $38 = $37;
  _lame_set_msfix($gfp,$38);
  $39 = (((10560 + (($1*52)|0)|0)) + 20|0);
  $40 = +HEAPF32[$39>>2];
  (_lame_set_short_threshold_lrm($gfp,$40)|0);
  $41 = (((10560 + (($1*52)|0)|0)) + 24|0);
  $42 = +HEAPF32[$41>>2];
  (_lame_set_short_threshold_s($gfp,$42)|0);
 } else {
  $13 = (_lame_get_quant_comp($gfp)|0);
  $14 = ($13|0)==(-1);
  if ($14) {
   $15 = (((10560 + (($1*52)|0)|0)) + 4|0);
   $16 = HEAP32[$15>>2]|0;
   (_lame_set_quant_comp($gfp,$16)|0);
  }
  $17 = (_lame_get_quant_comp_short($gfp)|0);
  $18 = ($17|0)==(-1);
  if ($18) {
   $19 = (((10560 + (($1*52)|0)|0)) + 8|0);
   $20 = HEAP32[$19>>2]|0;
   (_lame_set_quant_comp_short($gfp,$20)|0);
  }
  $21 = (+_lame_get_msfix($gfp));
  $22 = $21 + 1.0;
  $23 = ($22 != $22) | (0.0 != 0.0) |($22 == 0.0);
  if ($23) {
   $24 = (((10560 + (($1*52)|0)|0)) + 16|0);
   $25 = +HEAPF32[$24>>2];
   $26 = $25;
   _lame_set_msfix($gfp,$26);
  }
  $27 = (+_lame_get_short_threshold_lrm($gfp));
  $28 = $27 + 1.0;
  $29 = ($28 != $28) | (0.0 != 0.0) |($28 == 0.0);
  if ($29) {
   $30 = (((10560 + (($1*52)|0)|0)) + 20|0);
   $31 = +HEAPF32[$30>>2];
   (_lame_set_short_threshold_lrm($gfp,$31)|0);
  }
  $43 = (+_lame_get_short_threshold_s($gfp));
  $44 = $43 + 1.0;
  $45 = ($44 != $44) | (0.0 != 0.0) |($44 == 0.0);
  if ($45) {
   $46 = (((10560 + (($1*52)|0)|0)) + 24|0);
   $47 = +HEAPF32[$46>>2];
   (_lame_set_short_threshold_s($gfp,$47)|0);
  }
 }
 $48 = (+_lame_get_scale($gfp));
 $49 = (((10560 + (($1*52)|0)|0)) + 28|0);
 $50 = +HEAPF32[$49>>2];
 $51 = $50 * $48;
 (_lame_set_scale($gfp,$51)|0);
 if ($12) {
  $72 = (((10560 + (($1*52)|0)|0)) + 32|0);
  $73 = +HEAPF32[$72>>2];
  (_lame_set_maskingadjust($gfp,$73)|0);
  $74 = $73;
  $75 = $74 * 1.1000000000000001;
  $76 = $75;
  (_lame_set_maskingadjust_short($gfp,$76)|0);
  $77 = (((10560 + (($1*52)|0)|0)) + 36|0);
  $78 = +HEAPF32[$77>>2];
  (_lame_set_ATHlower($gfp,$78)|0);
  $79 = (((10560 + (($1*52)|0)|0)) + 40|0);
  $80 = +HEAPF32[$79>>2];
  (_lame_set_ATHcurve($gfp,$80)|0);
  $81 = (((10560 + (($1*52)|0)|0)) + 44|0);
  $82 = +HEAPF32[$81>>2];
  (_lame_set_interChRatio($gfp,$82)|0);
  $88 = (10560 + (($1*52)|0)|0);
  $89 = HEAP32[$88>>2]|0;
  $90 = (+($89|0));
  $91 = $90 * 0.015625;
  $92 = $91;
  $93 = ((($gfp)) + 288|0);
  $94 = HEAP32[$93>>2]|0;
  $95 = ((($94)) + 280|0);
  HEAPF32[$95>>2] = $92;
  return ($preset|0);
 }
 $52 = (+_lame_get_maskingadjust($gfp));
 $53 = ($52 != $52) | (0.0 != 0.0) |($52 == 0.0);
 if ($53) {
  $54 = (((10560 + (($1*52)|0)|0)) + 32|0);
  $55 = +HEAPF32[$54>>2];
  (_lame_set_maskingadjust($gfp,$55)|0);
 }
 $56 = (+_lame_get_maskingadjust_short($gfp));
 $57 = ($56 != $56) | (0.0 != 0.0) |($56 == 0.0);
 if ($57) {
  $58 = (((10560 + (($1*52)|0)|0)) + 32|0);
  $59 = +HEAPF32[$58>>2];
  $60 = $59;
  $61 = $60 * 1.1000000000000001;
  $62 = $61;
  (_lame_set_maskingadjust_short($gfp,$62)|0);
 }
 $63 = (+_lame_get_ATHlower($gfp));
 $64 = ($63 != $63) | (0.0 != 0.0) |($63 == 0.0);
 if ($64) {
  $65 = (((10560 + (($1*52)|0)|0)) + 36|0);
  $66 = +HEAPF32[$65>>2];
  (_lame_set_ATHlower($gfp,$66)|0);
 }
 $67 = (+_lame_get_ATHcurve($gfp));
 $68 = $67 + 1.0;
 $69 = ($68 != $68) | (0.0 != 0.0) |($68 == 0.0);
 if ($69) {
  $70 = (((10560 + (($1*52)|0)|0)) + 40|0);
  $71 = +HEAPF32[$70>>2];
  (_lame_set_ATHcurve($gfp,$71)|0);
 }
 $83 = (+_lame_get_interChRatio($gfp));
 $84 = $83 + 1.0;
 $85 = ($84 != $84) | (0.0 != 0.0) |($84 == 0.0);
 if (!($85)) {
  $88 = (10560 + (($1*52)|0)|0);
  $89 = HEAP32[$88>>2]|0;
  $90 = (+($89|0));
  $91 = $90 * 0.015625;
  $92 = $91;
  $93 = ((($gfp)) + 288|0);
  $94 = HEAP32[$93>>2]|0;
  $95 = ((($94)) + 280|0);
  HEAPF32[$95>>2] = $92;
  return ($preset|0);
 }
 $86 = (((10560 + (($1*52)|0)|0)) + 44|0);
 $87 = +HEAPF32[$86>>2];
 (_lame_set_interChRatio($gfp,$87)|0);
 $88 = (10560 + (($1*52)|0)|0);
 $89 = HEAP32[$88>>2]|0;
 $90 = (+($89|0));
 $91 = $90 * 0.015625;
 $92 = $91;
 $93 = ((($gfp)) + 288|0);
 $94 = HEAP32[$93>>2]|0;
 $95 = ((($94)) + 280|0);
 HEAPF32[$95>>2] = $92;
 return ($preset|0);
}
function _apply_vbr_preset($gfp,$a,$enforce) {
 $gfp = $gfp|0;
 $a = $a|0;
 $enforce = $enforce|0;
 var $$0$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0.0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0.0, $108 = 0.0, $109 = 0, $11 = 0, $110 = 0.0, $111 = 0.0, $112 = 0, $113 = 0.0, $114 = 0;
 var $115 = 0.0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0.0, $120 = 0, $121 = 0.0, $122 = 0, $123 = 0.0, $124 = 0.0, $125 = 0, $126 = 0.0, $127 = 0, $128 = 0, $129 = 0.0, $13 = 0, $130 = 0.0, $131 = 0, $132 = 0;
 var $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0.0, $140 = 0, $141 = 0.0, $142 = 0.0, $143 = 0, $144 = 0.0, $145 = 0.0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0;
 var $16 = 0.0, $17 = 0, $18 = 0.0, $19 = 0, $2 = 0.0, $20 = 0.0, $21 = 0, $22 = 0.0, $23 = 0, $24 = 0.0, $25 = 0, $26 = 0.0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0.0, $33 = 0;
 var $34 = 0.0, $35 = 0, $36 = 0.0, $37 = 0, $38 = 0, $39 = 0.0, $4 = 0, $40 = 0, $41 = 0.0, $42 = 0, $43 = 0.0, $44 = 0, $45 = 0.0, $46 = 0, $47 = 0.0, $48 = 0, $49 = 0.0, $5 = 0, $50 = 0, $51 = 0.0;
 var $52 = 0, $53 = 0.0, $54 = 0, $55 = 0, $56 = 0, $57 = 0.0, $58 = 0, $59 = 0.0, $6 = 0, $60 = 0, $61 = 0.0, $62 = 0.0, $63 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0;
 var $70 = 0.0, $71 = 0.0, $72 = 0.0, $73 = 0.0, $74 = 0.0, $75 = 0.0, $76 = 0.0, $77 = 0.0, $78 = 0.0, $79 = 0.0, $8 = 0, $80 = 0.0, $81 = 0.0, $82 = 0.0, $83 = 0.0, $84 = 0.0, $85 = 0.0, $86 = 0.0, $87 = 0, $88 = 0.0;
 var $89 = 0.0, $9 = 0, $90 = 0.0, $91 = 0, $92 = 0.0, $93 = 0.0, $94 = 0.0, $95 = 0.0, $96 = 0.0, $97 = 0.0, $98 = 0.0, $99 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_lame_get_VBR($gfp)|0);
 if ((($0|0) == 1) | (($0|0) == 4)) {
  $$0$i = 9808;
 } else {
  $$0$i = 9056;
 }
 $1 = ((($gfp)) + 160|0);
 $2 = +HEAPF32[$1>>2];
 $3 = (($$0$i) + (($a*68)|0)|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = (((($$0$i) + (($a*68)|0)|0)) + 4|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = (((($$0$i) + (($a*68)|0)|0)) + 8|0);
 $8 = HEAP32[$7>>2]|0;
 $9 = (((($$0$i) + (($a*68)|0)|0)) + 12|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = (((($$0$i) + (($a*68)|0)|0)) + 16|0);
 $12 = +HEAPF32[$11>>2];
 $13 = (((($$0$i) + (($a*68)|0)|0)) + 20|0);
 $14 = +HEAPF32[$13>>2];
 $15 = (((($$0$i) + (($a*68)|0)|0)) + 24|0);
 $16 = +HEAPF32[$15>>2];
 $17 = (((($$0$i) + (($a*68)|0)|0)) + 28|0);
 $18 = +HEAPF32[$17>>2];
 $19 = (((($$0$i) + (($a*68)|0)|0)) + 32|0);
 $20 = +HEAPF32[$19>>2];
 $21 = (((($$0$i) + (($a*68)|0)|0)) + 36|0);
 $22 = +HEAPF32[$21>>2];
 $23 = (((($$0$i) + (($a*68)|0)|0)) + 40|0);
 $24 = +HEAPF32[$23>>2];
 $25 = (((($$0$i) + (($a*68)|0)|0)) + 44|0);
 $26 = +HEAPF32[$25>>2];
 $27 = (((($$0$i) + (($a*68)|0)|0)) + 48|0);
 $28 = HEAP32[$27>>2]|0;
 $29 = (((($$0$i) + (($a*68)|0)|0)) + 52|0);
 $30 = HEAP32[$29>>2]|0;
 $31 = (((($$0$i) + (($a*68)|0)|0)) + 56|0);
 $32 = +HEAPF32[$31>>2];
 $33 = (((($$0$i) + (($a*68)|0)|0)) + 60|0);
 $34 = +HEAPF32[$33>>2];
 $35 = (((($$0$i) + (($a*68)|0)|0)) + 64|0);
 $36 = +HEAPF32[$35>>2];
 $37 = (($a) + 1)|0;
 $38 = (((($$0$i) + (($37*68)|0)|0)) + 16|0);
 $39 = +HEAPF32[$38>>2];
 $40 = (((($$0$i) + (($37*68)|0)|0)) + 20|0);
 $41 = +HEAPF32[$40>>2];
 $42 = (((($$0$i) + (($37*68)|0)|0)) + 24|0);
 $43 = +HEAPF32[$42>>2];
 $44 = (((($$0$i) + (($37*68)|0)|0)) + 28|0);
 $45 = +HEAPF32[$44>>2];
 $46 = (((($$0$i) + (($37*68)|0)|0)) + 32|0);
 $47 = +HEAPF32[$46>>2];
 $48 = (((($$0$i) + (($37*68)|0)|0)) + 36|0);
 $49 = +HEAPF32[$48>>2];
 $50 = (((($$0$i) + (($37*68)|0)|0)) + 40|0);
 $51 = +HEAPF32[$50>>2];
 $52 = (((($$0$i) + (($37*68)|0)|0)) + 44|0);
 $53 = +HEAPF32[$52>>2];
 $54 = (((($$0$i) + (($37*68)|0)|0)) + 52|0);
 $55 = HEAP32[$54>>2]|0;
 $56 = (((($$0$i) + (($37*68)|0)|0)) + 56|0);
 $57 = +HEAPF32[$56>>2];
 $58 = (((($$0$i) + (($37*68)|0)|0)) + 60|0);
 $59 = +HEAPF32[$58>>2];
 $60 = (((($$0$i) + (($37*68)|0)|0)) + 64|0);
 $61 = +HEAPF32[$60>>2];
 $62 = $39 - $12;
 $63 = $62 * $2;
 $64 = $63 + $12;
 $65 = $41 - $14;
 $66 = $65 * $2;
 $67 = $66 + $14;
 $68 = $43 - $16;
 $69 = $68 * $2;
 $70 = $69 + $16;
 $71 = $45 - $18;
 $72 = $71 * $2;
 $73 = $72 + $18;
 $74 = $47 - $20;
 $75 = $74 * $2;
 $76 = $75 + $20;
 $77 = $49 - $22;
 $78 = $77 * $2;
 $79 = $78 + $22;
 $80 = $51 - $24;
 $81 = $80 * $2;
 $82 = $81 + $24;
 $83 = $53 - $26;
 $84 = $83 * $2;
 $85 = $84 + $26;
 $86 = (+($30|0));
 $87 = (($55) - ($30))|0;
 $88 = (+($87|0));
 $89 = $88 * $2;
 $90 = $89 + $86;
 $91 = (~~(($90)));
 $92 = $57 - $32;
 $93 = $92 * $2;
 $94 = $93 + $32;
 $95 = $59 - $34;
 $96 = $95 * $2;
 $97 = $96 + $34;
 $98 = $61 - $36;
 $99 = $98 * $2;
 $100 = $99 + $36;
 (_lame_set_VBR_q($gfp,$4)|0);
 $101 = ($enforce|0)!=(0);
 if ($101) {
  (_lame_set_quant_comp($gfp,$6)|0);
  (_lame_set_quant_comp_short($gfp,$8)|0);
 } else {
  $102 = (_lame_get_quant_comp($gfp)|0);
  $103 = ($102|0)==(-1);
  if ($103) {
   (_lame_set_quant_comp($gfp,$6)|0);
  }
  $104 = (_lame_get_quant_comp_short($gfp)|0);
  $105 = ($104|0)==(-1);
  if ($105) {
   (_lame_set_quant_comp_short($gfp,$8)|0);
  }
 }
 $106 = ($10|0)==(0);
 if (!($106)) {
  (_lame_set_experimentalY($gfp,$10)|0);
 }
 if ($101) {
  (_lame_set_short_threshold_lrm($gfp,$64)|0);
  (_lame_set_short_threshold_s($gfp,$67)|0);
  (_lame_set_maskingadjust($gfp,$70)|0);
  (_lame_set_maskingadjust_short($gfp,$73)|0);
 } else {
  $107 = (+_lame_get_short_threshold_lrm($gfp));
  $108 = $107 + 1.0;
  $109 = ($108 != $108) | (0.0 != 0.0) |($108 == 0.0);
  if ($109) {
   (_lame_set_short_threshold_lrm($gfp,$64)|0);
  }
  $110 = (+_lame_get_short_threshold_s($gfp));
  $111 = $110 + 1.0;
  $112 = ($111 != $111) | (0.0 != 0.0) |($111 == 0.0);
  if ($112) {
   (_lame_set_short_threshold_s($gfp,$67)|0);
  }
  $113 = (+_lame_get_maskingadjust($gfp));
  $114 = ($113 != $113) | (0.0 != 0.0) |($113 == 0.0);
  if ($114) {
   (_lame_set_maskingadjust($gfp,$70)|0);
  }
  $115 = (+_lame_get_maskingadjust_short($gfp));
  $116 = ($115 != $115) | (0.0 != 0.0) |($115 == 0.0);
  if ($116) {
   (_lame_set_maskingadjust_short($gfp,$73)|0);
  }
 }
 $117 = (_lame_get_VBR($gfp)|0);
 $118 = ($117|0)==(1);
 if ($118) {
  label = 23;
 } else {
  $119 = (_lame_get_VBR($gfp)|0);
  $120 = ($119|0)==(4);
  if ($120) {
   label = 23;
  }
 }
 if ((label|0) == 23) {
  (_lame_set_ATHtype($gfp,5)|0);
 }
 if ($101) {
  (_lame_set_ATHlower($gfp,$76)|0);
  (_lame_set_ATHcurve($gfp,$79)|0);
  (_lame_set_athaa_sensitivity($gfp,$82)|0);
 } else {
  $121 = (+_lame_get_ATHlower($gfp));
  $122 = ($121 != $121) | (0.0 != 0.0) |($121 == 0.0);
  if ($122) {
   (_lame_set_ATHlower($gfp,$76)|0);
  }
  $123 = (+_lame_get_ATHcurve($gfp));
  $124 = $123 + 1.0;
  $125 = ($124 != $124) | (0.0 != 0.0) |($124 == 0.0);
  if ($125) {
   (_lame_set_ATHcurve($gfp,$79)|0);
  }
  $126 = (+_lame_get_athaa_sensitivity($gfp));
  $127 = ($126 != $126) | (0.0 != 0.0) |($126 == 0.0);
  if ($127) {
   (_lame_set_athaa_sensitivity($gfp,$82)|0);
  }
 }
 $128 = $85 > 0.0;
 do {
  if ($128) {
   if ($101) {
    (_lame_set_interChRatio($gfp,$85)|0);
    break;
   }
   $129 = (+_lame_get_interChRatio($gfp));
   $130 = $129 + 1.0;
   $131 = ($130 != $130) | (0.0 != 0.0) |($130 == 0.0);
   if ($131) {
    (_lame_set_interChRatio($gfp,$85)|0);
   }
  }
 } while(0);
 $132 = ($28|0)>(0);
 if ($132) {
  $133 = (_lame_get_exp_nspsytune($gfp)|0);
  $134 = $133 | 2;
  (_lame_set_exp_nspsytune($gfp,$134)|0);
 }
 $135 = ($91|0)>(0);
 if ($135) {
  $136 = (_lame_get_exp_nspsytune($gfp)|0);
  $137 = $136 & 66060288;
  $138 = ($137|0)==(0);
  if ($138) {
   $139 = $91 << 20;
   $140 = $136 | $139;
   (_lame_set_exp_nspsytune($gfp,$140)|0);
  }
 }
 if ($101) {
  $145 = $94;
  _lame_set_msfix($gfp,$145);
  $147 = ((($gfp)) + 288|0);
  $148 = HEAP32[$147>>2]|0;
  $149 = ((($148)) + 280|0);
  HEAPF32[$149>>2] = $97;
  $150 = ((($148)) + 224|0);
  HEAPF32[$150>>2] = $100;
  return;
 }
 $141 = (+_lame_get_msfix($gfp));
 $142 = $141 + 1.0;
 $143 = ($142 != $142) | (0.0 != 0.0) |($142 == 0.0);
 if ($143) {
  $144 = $94;
  _lame_set_msfix($gfp,$144);
 }
 $146 = ((($gfp)) + 164|0);
 HEAP32[$146>>2] = $a;
 HEAPF32[$1>>2] = $2;
 $147 = ((($gfp)) + 288|0);
 $148 = HEAP32[$147>>2]|0;
 $149 = ((($148)) + 280|0);
 HEAPF32[$149>>2] = $97;
 $150 = ((($148)) + 224|0);
 HEAPF32[$150>>2] = $100;
 return;
}
function _L3psycho_anal_vbr($gfc,$buffer,$gr_out,$masking_ratio,$masking_MS_ratio,$percep_entropy,$percep_MS_entropy,$energy,$blocktype_d) {
 $gfc = $gfc|0;
 $buffer = $buffer|0;
 $gr_out = $gr_out|0;
 $masking_ratio = $masking_ratio|0;
 $masking_MS_ratio = $masking_MS_ratio|0;
 $percep_entropy = $percep_entropy|0;
 $percep_MS_entropy = $percep_MS_entropy|0;
 $energy = $energy|0;
 $blocktype_d = $blocktype_d|0;
 var $$$i = 0.0, $$$i67 = 0, $$01$i$i = 0.0, $$01$i$i46 = 0.0, $$02$i$i = 0.0, $$02$i$i47 = 0.0, $$1$i$i = 0.0, $$1$i$i54 = 0.0, $$lcssa = 0.0, $$lcssa$i$i = 0, $$lcssa$i$i39 = 0, $$lcssa1$i$i = 0.0, $$lcssa1$i$i38 = 0.0, $$lcssa226 = 0.0, $$lcssa227 = 0, $$lcssa228 = 0, $$lcssa229 = 0.0, $$lcssa230 = 0.0, $$lcssa231 = 0.0, $$lcssa232 = 0.0;
 var $$lcssa233 = 0, $$lcssa234 = 0, $$not = 0, $$not203 = 0, $$phi$trans$insert$i = 0, $$pre$i = 0, $$pre$i12 = 0.0, $$pre$i27 = 0.0, $$pre$phi$iZ2D = 0, $$pre$phi36$iZ2D = 0, $$pre34$i = 0.0, $$pre35$i = 0, $$pre37$i = 0, $$pre48$i = 0.0, $$pre49$i = 0, $$pre52$i = 0, $$pre61$i = 0, $$pre63$i = 0, $$pre8$i = 0, $$sink$i$i = 0;
 var $$sink$i$i36 = 0, $$sink7$i$i = 0, $$sink7$i$i43 = 0, $$sum = 0, $$sum$i = 0, $$sum$us$i = 0, $$sum1$1$i = 0, $$sum1$2$i = 0, $$sum1$3$i = 0, $$sum1$4$i = 0, $$sum1$i = 0, $$sum1$us$1$i = 0, $$sum1$us$2$i = 0, $$sum1$us$3$i = 0, $$sum1$us$4$i = 0, $$sum1$us$i = 0, $$sum2$1$i = 0, $$sum2$2$i = 0, $$sum2$3$i = 0, $$sum2$4$i = 0;
 var $$sum2$i = 0, $$sum2$us$1$i = 0, $$sum2$us$2$i = 0, $$sum2$us$3$i = 0, $$sum2$us$4$i = 0, $$sum2$us$i = 0, $$sum3$1$i = 0, $$sum3$2$i = 0, $$sum3$3$i = 0, $$sum3$4$i = 0, $$sum3$i = 0, $$sum3$us$1$i = 0, $$sum3$us$2$i = 0, $$sum3$us$3$i = 0, $$sum3$us$4$i = 0, $$sum3$us$i = 0, $$sum4$1$i = 0, $$sum4$2$i = 0, $$sum4$3$i = 0, $$sum4$4$i = 0;
 var $$sum4$i = 0, $$sum4$us$1$i = 0, $$sum4$us$2$i = 0, $$sum4$us$3$i = 0, $$sum4$us$4$i = 0, $$sum4$us$i = 0, $$sum73 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $1000 = 0, $1001 = 0, $1002 = 0.0, $1003 = 0.0, $1004 = 0, $1005 = 0, $1006 = 0.0, $1007 = 0, $1008 = 0.0;
 var $1009 = 0.0, $101 = 0.0, $1010 = 0.0, $1011 = 0.0, $1012 = 0, $1013 = 0.0, $1014 = 0, $1015 = 0.0, $1016 = 0.0, $1017 = 0.0, $1018 = 0, $1019 = 0.0, $102 = 0.0, $1020 = 0, $1021 = 0, $1022 = 0, $1023 = 0, $1024 = 0, $1025 = 0, $1026 = 0;
 var $1027 = 0, $1028 = 0, $1029 = 0.0, $103 = 0.0, $1030 = 0.0, $1031 = 0.0, $1032 = 0, $1033 = 0, $1034 = 0, $1035 = 0, $1036 = 0, $1037 = 0.0, $1038 = 0, $1039 = 0.0, $104 = 0.0, $1040 = 0.0, $1041 = 0.0, $1042 = 0, $1043 = 0, $1044 = 0.0;
 var $1045 = 0.0, $1046 = 0, $1047 = 0.0, $1048 = 0, $1049 = 0.0, $105 = 0.0, $1050 = 0, $1051 = 0.0, $1052 = 0.0, $1053 = 0, $1054 = 0, $1055 = 0, $1056 = 0, $1057 = 0, $1058 = 0, $1059 = 0, $106 = 0.0, $1060 = 0.0, $1061 = 0, $1062 = 0;
 var $1063 = 0, $1064 = 0, $1065 = 0, $1066 = 0, $1067 = 0, $1068 = 0, $1069 = 0, $107 = 0.0, $1070 = 0, $1071 = 0, $1072 = 0, $1073 = 0, $1074 = 0, $1075 = 0, $1076 = 0, $1077 = 0, $1078 = 0, $1079 = 0, $108 = 0.0, $1080 = 0;
 var $1081 = 0, $1082 = 0, $1083 = 0, $1084 = 0, $1085 = 0, $1086 = 0, $1087 = 0, $1088 = 0, $1089 = 0, $109 = 0.0, $1090 = 0, $1091 = 0, $1092 = 0, $1093 = 0, $1094 = 0, $1095 = 0, $1096 = 0, $1097 = 0, $1098 = 0, $1099 = 0;
 var $11 = 0.0, $110 = 0.0, $1100 = 0, $1101 = 0, $1102 = 0, $1103 = 0, $1104 = 0, $1105 = 0, $1106 = 0, $1107 = 0, $1108 = 0, $1109 = 0, $111 = 0.0, $1110 = 0, $1111 = 0, $1112 = 0, $1113 = 0, $1114 = 0, $1115 = 0, $1116 = 0;
 var $1117 = 0, $1118 = 0, $1119 = 0, $112 = 0.0, $1120 = 0, $1121 = 0, $1122 = 0, $1123 = 0, $1124 = 0, $1125 = 0, $1126 = 0, $1127 = 0, $1128 = 0, $1129 = 0.0, $113 = 0.0, $1130 = 0.0, $1131 = 0.0, $1132 = 0.0, $1133 = 0, $1134 = 0;
 var $1135 = 0, $1136 = 0, $1137 = 0, $1138 = 0, $1139 = 0, $114 = 0, $1140 = 0, $1141 = 0, $1142 = 0, $1143 = 0, $1144 = 0.0, $1145 = 0.0, $1146 = 0.0, $1147 = 0, $1148 = 0.0, $1149 = 0, $115 = 0, $1150 = 0, $1151 = 0.0, $1152 = 0.0;
 var $1153 = 0.0, $1154 = 0, $1155 = 0, $1156 = 0, $1157 = 0, $1158 = 0, $1159 = 0, $116 = 0, $1160 = 0.0, $1161 = 0.0, $1162 = 0.0, $1163 = 0, $1164 = 0.0, $1165 = 0.0, $1166 = 0.0, $1167 = 0, $1168 = 0.0, $1169 = 0, $117 = 0, $1170 = 0.0;
 var $1171 = 0.0, $1172 = 0, $1173 = 0, $1174 = 0, $1175 = 0, $1176 = 0, $1177 = 0, $1178 = 0, $1179 = 0, $118 = 0, $1180 = 0, $1181 = 0, $1182 = 0, $1183 = 0, $1184 = 0, $1185 = 0, $1186 = 0, $1187 = 0, $1188 = 0, $1189 = 0;
 var $119 = 0, $1190 = 0, $1191 = 0, $1192 = 0, $1193 = 0, $1194 = 0, $1195 = 0, $1196 = 0, $1197 = 0, $1198 = 0, $1199 = 0, $12 = 0, $120 = 0, $1200 = 0, $1201 = 0, $1202 = 0, $1203 = 0, $1204 = 0, $1205 = 0.0, $1206 = 0;
 var $1207 = 0, $1208 = 0.0, $1209 = 0, $121 = 0, $1210 = 0.0, $1211 = 0, $1212 = 0.0, $1213 = 0, $1214 = 0.0, $1215 = 0, $1216 = 0.0, $1217 = 0.0, $1218 = 0.0, $1219 = 0.0, $122 = 0, $1220 = 0.0, $1221 = 0.0, $1222 = 0.0, $1223 = 0.0, $1224 = 0.0;
 var $1225 = 0.0, $1226 = 0.0, $1227 = 0.0, $1228 = 0.0, $1229 = 0.0, $123 = 0, $1230 = 0, $1231 = 0.0, $1232 = 0, $1233 = 0.0, $1234 = 0, $1235 = 0.0, $1236 = 0, $1237 = 0.0, $1238 = 0, $1239 = 0.0, $124 = 0, $1240 = 0.0, $1241 = 0.0, $1242 = 0.0;
 var $1243 = 0.0, $1244 = 0.0, $1245 = 0.0, $1246 = 0.0, $1247 = 0.0, $1248 = 0.0, $1249 = 0.0, $125 = 0, $1250 = 0.0, $1251 = 0.0, $1252 = 0.0, $1253 = 0, $1254 = 0.0, $1255 = 0, $1256 = 0.0, $1257 = 0, $1258 = 0.0, $1259 = 0, $126 = 0, $1260 = 0.0;
 var $1261 = 0, $1262 = 0.0, $1263 = 0.0, $1264 = 0.0, $1265 = 0.0, $1266 = 0.0, $1267 = 0.0, $1268 = 0.0, $1269 = 0.0, $127 = 0, $1270 = 0.0, $1271 = 0.0, $1272 = 0.0, $1273 = 0.0, $1274 = 0.0, $1275 = 0.0, $1276 = 0, $1277 = 0, $1278 = 0, $1279 = 0.0;
 var $128 = 0, $1280 = 0, $1281 = 0.0, $1282 = 0, $1283 = 0.0, $1284 = 0, $1285 = 0.0, $1286 = 0, $1287 = 0, $1288 = 0.0, $1289 = 0.0, $129 = 0, $1290 = 0.0, $1291 = 0.0, $1292 = 0.0, $1293 = 0.0, $1294 = 0.0, $1295 = 0.0, $1296 = 0.0, $1297 = 0.0;
 var $1298 = 0.0, $1299 = 0.0, $13 = 0, $130 = 0, $1300 = 0.0, $1301 = 0.0, $1302 = 0, $1303 = 0, $1304 = 0.0, $1305 = 0.0, $1306 = 0, $1307 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0;
 var $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0.0, $149 = 0, $15 = 0.0, $150 = 0.0, $151 = 0, $152 = 0.0, $153 = 0.0, $154 = 0.0, $155 = 0, $156 = 0.0;
 var $157 = 0, $158 = 0.0, $159 = 0.0, $16 = 0.0, $160 = 0.0, $161 = 0, $162 = 0.0, $163 = 0, $164 = 0.0, $165 = 0.0, $166 = 0.0, $167 = 0, $168 = 0.0, $169 = 0, $17 = 0, $170 = 0.0, $171 = 0.0, $172 = 0.0, $173 = 0, $174 = 0.0;
 var $175 = 0, $176 = 0.0, $177 = 0.0, $178 = 0.0, $179 = 0, $18 = 0, $180 = 0.0, $181 = 0, $182 = 0.0, $183 = 0.0, $184 = 0.0, $185 = 0, $186 = 0.0, $187 = 0, $188 = 0.0, $189 = 0.0, $19 = 0, $190 = 0.0, $191 = 0, $192 = 0.0;
 var $193 = 0, $194 = 0.0, $195 = 0.0, $196 = 0.0, $197 = 0, $198 = 0.0, $199 = 0, $2 = 0, $20 = 0, $200 = 0.0, $201 = 0.0, $202 = 0.0, $203 = 0, $204 = 0.0, $205 = 0, $206 = 0.0, $207 = 0.0, $208 = 0.0, $209 = 0.0, $21 = 0;
 var $210 = 0.0, $211 = 0.0, $212 = 0.0, $213 = 0.0, $214 = 0.0, $215 = 0.0, $216 = 0.0, $217 = 0.0, $218 = 0.0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0;
 var $229 = 0, $23 = 0, $230 = 0.0, $231 = 0, $232 = 0.0, $233 = 0.0, $234 = 0, $235 = 0.0, $236 = 0, $237 = 0.0, $238 = 0.0, $239 = 0.0, $24 = 0, $240 = 0, $241 = 0.0, $242 = 0.0, $243 = 0.0, $244 = 0, $245 = 0.0, $246 = 0;
 var $247 = 0.0, $248 = 0.0, $249 = 0.0, $25 = 0, $250 = 0, $251 = 0.0, $252 = 0.0, $253 = 0.0, $254 = 0.0, $255 = 0.0, $256 = 0.0, $257 = 0, $258 = 0, $259 = 0.0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0;
 var $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0.0, $27 = 0, $270 = 0.0, $271 = 0, $272 = 0, $273 = 0.0, $274 = 0, $275 = 0.0, $276 = 0.0, $277 = 0, $278 = 0.0, $279 = 0, $28 = 0, $280 = 0.0, $281 = 0, $282 = 0;
 var $283 = 0.0, $284 = 0.0, $285 = 0.0, $286 = 0.0, $287 = 0.0, $288 = 0.0, $289 = 0, $29 = 0, $290 = 0.0, $291 = 0.0, $292 = 0, $293 = 0.0, $294 = 0, $295 = 0.0, $296 = 0, $297 = 0.0, $298 = 0, $299 = 0.0, $3 = 0, $30 = 0;
 var $300 = 0, $301 = 0.0, $302 = 0, $303 = 0.0, $304 = 0, $305 = 0.0, $306 = 0, $307 = 0.0, $308 = 0, $309 = 0.0, $31 = 0, $310 = 0, $311 = 0.0, $312 = 0, $313 = 0, $314 = 0.0, $315 = 0, $316 = 0.0, $317 = 0, $318 = 0;
 var $319 = 0.0, $32 = 0, $320 = 0, $321 = 0.0, $322 = 0.0, $323 = 0, $324 = 0.0, $325 = 0, $326 = 0.0, $327 = 0, $328 = 0.0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0.0, $336 = 0;
 var $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0.0, $345 = 0, $346 = 0.0, $347 = 0, $348 = 0.0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0;
 var $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0;
 var $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0.0, $38 = 0, $380 = 0, $381 = 0, $382 = 0.0, $383 = 0.0, $384 = 0.0, $385 = 0.0, $386 = 0.0, $387 = 0.0, $388 = 0, $389 = 0.0, $39 = 0, $390 = 0;
 var $391 = 0, $392 = 0.0, $393 = 0, $394 = 0.0, $395 = 0, $396 = 0.0, $397 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0;
 var $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0;
 var $427 = 0, $428 = 0, $429 = 0, $43 = 0.0, $430 = 0, $431 = 0.0, $432 = 0, $433 = 0.0, $434 = 0.0, $435 = 0.0, $436 = 0.0, $437 = 0.0, $438 = 0, $439 = 0, $44 = 0, $440 = 0.0, $441 = 0.0, $442 = 0, $443 = 0, $444 = 0.0;
 var $445 = 0, $446 = 0, $447 = 0.0, $448 = 0.0, $449 = 0.0, $45 = 0.0, $450 = 0.0, $451 = 0.0, $452 = 0, $453 = 0, $454 = 0, $455 = 0, $456 = 0.0, $457 = 0.0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0;
 var $463 = 0.0, $464 = 0, $465 = 0, $466 = 0.0, $467 = 0.0, $468 = 0, $469 = 0, $47 = 0.0, $470 = 0, $471 = 0, $472 = 0, $473 = 0, $474 = 0.0, $475 = 0, $476 = 0.0, $477 = 0.0, $478 = 0.0, $479 = 0, $48 = 0.0, $480 = 0.0;
 var $481 = 0.0, $482 = 0.0, $483 = 0, $484 = 0, $485 = 0, $486 = 0, $487 = 0, $488 = 0, $489 = 0, $49 = 0.0, $490 = 0, $491 = 0.0, $492 = 0.0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0;
 var $5 = 0, $50 = 0, $500 = 0, $501 = 0.0, $502 = 0.0, $503 = 0, $504 = 0, $505 = 0.0, $506 = 0.0, $507 = 0.0, $508 = 0, $509 = 0.0, $51 = 0.0, $510 = 0.0, $511 = 0, $512 = 0.0, $513 = 0.0, $514 = 0.0, $515 = 0, $516 = 0;
 var $517 = 0, $518 = 0, $519 = 0, $52 = 0, $520 = 0, $521 = 0.0, $522 = 0.0, $523 = 0.0, $524 = 0, $525 = 0, $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0.0, $530 = 0.0, $531 = 0.0, $532 = 0, $533 = 0, $534 = 0;
 var $535 = 0.0, $536 = 0.0, $537 = 0.0, $538 = 0, $539 = 0, $54 = 0.0, $540 = 0, $540$phi = 0, $541 = 0.0, $542 = 0, $543 = 0.0, $544 = 0, $545 = 0, $546 = 0.0, $547 = 0, $548 = 0.0, $549 = 0.0, $55 = 0.0, $550 = 0.0, $551 = 0;
 var $552 = 0, $553 = 0, $554 = 0, $555 = 0, $556 = 0, $557 = 0, $558 = 0, $559 = 0, $56 = 0, $560 = 0.0, $561 = 0.0, $562 = 0.0, $563 = 0, $564 = 0, $565 = 0, $566 = 0, $567 = 0, $568 = 0.0, $569 = 0.0, $57 = 0.0;
 var $570 = 0, $571 = 0, $572 = 0, $573 = 0.0, $574 = 0, $575 = 0.0, $576 = 0, $577 = 0.0, $578 = 0.0, $579 = 0.0, $58 = 0, $580 = 0, $581 = 0, $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0.0, $587 = 0.0, $588 = 0.0;
 var $589 = 0, $59 = 0.0, $590 = 0, $591 = 0, $592 = 0, $593 = 0, $594 = 0, $595 = 0, $596 = 0, $597 = 0, $598 = 0, $599 = 0, $6 = 0, $60 = 0.0, $600 = 0.0, $601 = 0.0, $602 = 0.0, $603 = 0, $604 = 0, $605 = 0;
 var $606 = 0, $607 = 0, $608 = 0, $609 = 0, $61 = 0.0, $610 = 0, $611 = 0, $612 = 0, $613 = 0, $614 = 0, $615 = 0, $616 = 0, $617 = 0.0, $618 = 0, $619 = 0.0, $62 = 0, $620 = 0.0, $621 = 0, $622 = 0.0, $623 = 0.0;
 var $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0, $629 = 0, $63 = 0.0, $630 = 0, $631 = 0.0, $632 = 0, $633 = 0.0, $634 = 0.0, $635 = 0, $636 = 0.0, $637 = 0.0, $638 = 0, $639 = 0, $64 = 0, $640 = 0, $641 = 0;
 var $642 = 0, $643 = 0, $644 = 0.0, $645 = 0.0, $646 = 0, $647 = 0, $648 = 0.0, $649 = 0, $65 = 0.0, $650 = 0.0, $651 = 0.0, $652 = 0.0, $653 = 0.0, $654 = 0, $655 = 0.0, $656 = 0, $657 = 0.0, $658 = 0.0, $659 = 0.0, $66 = 0.0;
 var $660 = 0, $661 = 0.0, $662 = 0, $663 = 0, $664 = 0, $665 = 0, $666 = 0, $667 = 0, $668 = 0, $669 = 0, $67 = 0.0, $670 = 0, $671 = 0.0, $672 = 0.0, $673 = 0.0, $674 = 0, $675 = 0, $676 = 0, $677 = 0.0, $678 = 0.0;
 var $679 = 0, $68 = 0, $680 = 0, $681 = 0.0, $682 = 0, $683 = 0.0, $684 = 0, $685 = 0.0, $686 = 0.0, $687 = 0.0, $688 = 0, $689 = 0.0, $69 = 0.0, $690 = 0, $691 = 0, $692 = 0.0, $693 = 0.0, $694 = 0, $695 = 0.0, $696 = 0.0;
 var $697 = 0, $698 = 0, $699 = 0, $7 = 0, $70 = 0, $700 = 0, $701 = 0.0, $702 = 0, $703 = 0.0, $704 = 0, $705 = 0, $706 = 0, $707 = 0, $708 = 0.0, $709 = 0, $71 = 0.0, $710 = 0.0, $711 = 0.0, $712 = 0.0, $713 = 0;
 var $714 = 0.0, $715 = 0, $716 = 0.0, $717 = 0.0, $718 = 0, $719 = 0.0, $72 = 0.0, $720 = 0, $721 = 0.0, $722 = 0, $723 = 0.0, $724 = 0.0, $725 = 0, $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0.0, $730 = 0, $731 = 0;
 var $732 = 0, $733 = 0, $734 = 0, $735 = 0, $736 = 0, $737 = 0, $738 = 0, $739 = 0, $74 = 0, $740 = 0.0, $741 = 0, $742 = 0, $743 = 0.0, $744 = 0, $745 = 0, $746 = 0, $747 = 0, $748 = 0, $749 = 0, $75 = 0.0;
 var $750 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0.0, $755 = 0.0, $756 = 0, $757 = 0, $758 = 0, $759 = 0, $76 = 0, $760 = 0, $761 = 0, $762 = 0, $763 = 0, $764 = 0, $765 = 0, $766 = 0, $767 = 0, $768 = 0;
 var $769 = 0, $77 = 0.0, $770 = 0, $771 = 0, $772 = 0, $773 = 0, $774 = 0, $775 = 0, $776 = 0, $777 = 0, $778 = 0, $779 = 0, $78 = 0.0, $780 = 0, $781 = 0, $782 = 0, $783 = 0, $784 = 0, $785 = 0, $786 = 0;
 var $787 = 0, $788 = 0, $789 = 0, $79 = 0.0, $790 = 0, $791 = 0, $792 = 0, $793 = 0, $794 = 0, $795 = 0, $796 = 0, $797 = 0, $798 = 0, $799 = 0, $8 = 0.0, $80 = 0, $800 = 0, $801 = 0, $802 = 0, $803 = 0;
 var $804 = 0, $805 = 0, $806 = 0, $807 = 0, $808 = 0, $809 = 0, $81 = 0.0, $810 = 0, $811 = 0, $812 = 0, $813 = 0, $814 = 0, $815 = 0, $816 = 0, $817 = 0, $818 = 0, $819 = 0.0, $82 = 0, $820 = 0, $821 = 0.0;
 var $822 = 0.0, $823 = 0.0, $824 = 0.0, $825 = 0.0, $826 = 0, $827 = 0, $828 = 0, $829 = 0.0, $83 = 0.0, $830 = 0.0, $831 = 0, $832 = 0, $833 = 0.0, $834 = 0, $835 = 0, $836 = 0.0, $837 = 0.0, $838 = 0.0, $839 = 0.0, $84 = 0.0;
 var $840 = 0.0, $841 = 0, $842 = 0, $843 = 0, $844 = 0, $845 = 0, $846 = 0, $847 = 0, $848 = 0, $849 = 0, $85 = 0.0, $850 = 0, $851 = 0, $852 = 0.0, $853 = 0.0, $854 = 0, $855 = 0, $856 = 0, $857 = 0, $858 = 0;
 var $859 = 0, $86 = 0, $860 = 0, $861 = 0.0, $862 = 0.0, $863 = 0, $864 = 0, $865 = 0.0, $866 = 0.0, $867 = 0.0, $868 = 0, $869 = 0.0, $87 = 0.0, $870 = 0.0, $871 = 0, $872 = 0.0, $873 = 0.0, $874 = 0.0, $875 = 0, $876 = 0;
 var $877 = 0, $878 = 0, $879 = 0, $88 = 0, $880 = 0, $881 = 0.0, $882 = 0.0, $883 = 0.0, $884 = 0, $885 = 0, $886 = 0, $887 = 0, $888 = 0, $889 = 0, $89 = 0.0, $890 = 0.0, $891 = 0, $892 = 0, $893 = 0, $894 = 0.0;
 var $895 = 0.0, $896 = 0.0, $897 = 0, $898 = 0, $899 = 0, $899$phi = 0, $9 = 0, $90 = 0.0, $900 = 0.0, $901 = 0, $902 = 0.0, $903 = 0, $904 = 0, $905 = 0.0, $906 = 0, $907 = 0.0, $908 = 0.0, $909 = 0.0, $91 = 0.0, $910 = 0;
 var $911 = 0, $912 = 0, $913 = 0, $914 = 0, $915 = 0, $916 = 0, $917 = 0, $918 = 0, $919 = 0.0, $92 = 0, $920 = 0.0, $921 = 0.0, $922 = 0, $923 = 0, $924 = 0, $925 = 0, $926 = 0, $927 = 0.0, $928 = 0.0, $929 = 0;
 var $93 = 0.0, $930 = 0, $931 = 0, $932 = 0.0, $933 = 0, $934 = 0.0, $935 = 0, $936 = 0.0, $937 = 0.0, $938 = 0.0, $939 = 0, $94 = 0, $940 = 0, $941 = 0, $942 = 0, $943 = 0, $944 = 0, $945 = 0.0, $946 = 0.0, $947 = 0.0;
 var $948 = 0, $949 = 0, $95 = 0.0, $950 = 0, $951 = 0, $952 = 0, $953 = 0, $954 = 0, $955 = 0, $956 = 0, $957 = 0, $958 = 0, $959 = 0, $96 = 0.0, $960 = 0, $961 = 0, $962 = 0, $963 = 0, $964 = 0, $965 = 0;
 var $966 = 0, $967 = 0.0, $968 = 0.0, $969 = 0.0, $97 = 0.0, $970 = 0, $971 = 0, $972 = 0, $973 = 0, $974 = 0, $975 = 0.0, $976 = 0, $977 = 0.0, $978 = 0.0, $979 = 0, $98 = 0, $980 = 0.0, $981 = 0.0, $982 = 0, $983 = 0;
 var $984 = 0, $985 = 0, $986 = 0, $987 = 0, $988 = 0, $989 = 0.0, $99 = 0.0, $990 = 0, $991 = 0.0, $992 = 0.0, $993 = 0, $994 = 0.0, $995 = 0.0, $996 = 0, $997 = 0, $998 = 0, $999 = 0, $avg$i = 0, $b$0$lcssa$i$i = 0, $b$0$lcssa$i$i40 = 0;
 var $b$01$i = 0, $b$019$i = 0, $b$02$i$i = 0, $b$02$i$i32 = 0, $b$030$i = 0, $b$08$i$i = 0, $b$116$i = 0, $b$16$i$ph = 0, $b$23$i$ph = 0, $blocktype$0$i = 0, $brmerge = 0, $chn$01$i$us = 0, $chn$01$i65 = 0, $chn$01$us$i = 0, $chn$0136 = 0, $chn$031$i = 0, $chn$031$us$i = 0, $chn$1133 = 0, $chn$125$i = 0, $chn$2120 = 0;
 var $chn$3127 = 0, $chn$4119 = 0, $chn$5114 = 0, $chn$6112 = 0, $dd$0$lcssa$i = 0, $dd$0$lcssa$i58 = 0, $dd$010$i = 0, $dd$06$i = 0, $dd_n$0$lcssa$i = 0, $dd_n$0$lcssa$i57 = 0, $eb = 0, $ebb$0$lcssa$i = 0.0, $ebb$0$lcssa$i$i = 0.0, $ebb$02$i$i = 0.0, $ebb$021$i = 0.0, $ecb$0$be$i = 0.0, $ecb$0$be$i$lcssa = 0.0, $ecb$0$be$i48 = 0.0, $ecb$0$be$i48$lcssa = 0.0, $ecb$0$lcssa$i = 0.0;
 var $ecb$0$lcssa$i56 = 0.0, $ecb$08$i = 0.0, $ecb$09$i = 0.0, $ecb_limit1$0$i = 0.0, $ecb_limit_1$0$i = 0.0, $ecb_limit_2$0$i = 0.0, $en_short$i = 0, $exitcond = 0, $exitcond$i = 0, $exitcond$i$i = 0, $exitcond$i11 = 0, $exitcond$i17 = 0, $exitcond$i18 = 0, $exitcond$i68 = 0, $exitcond$i7 = 0, $exitcond$i8 = 0, $exitcond150 = 0, $exitcond151 = 0, $exitcond155 = 0, $exitcond156 = 0;
 var $exitcond159 = 0, $exitcond160 = 0, $exitcond167 = 0, $exitcond168 = 0, $exitcond169 = 0, $exitcond170 = 0, $exitcond173 = 0, $exitcond180 = 0, $exitcond31$i = 0, $exitcond32$i = 0, $exitcond33$i = 0, $exitcond41$i = 0, $exitcond44$i = 0, $exitcond45$i = 0, $exitcond46$i = 0, $exitcond46$i25 = 0, $exitcond48$i = 0, $exitcond49$i = 0, $exitcond50$i = 0, $exitcond51$i = 0;
 var $exitcond9$i = 0, $fabsf$i = 0.0, $factor$0$1$i = 0.0, $factor$0$2$i = 0.0, $factor$0$i = 0.0, $fftenergy = 0, $fftenergy_s = 0, $i$01$i$i = 0, $i$023$i = 0, $i$030$i = 0, $i$030$us$i = 0, $i$04$i$i = 0, $i$114$i = 0, $i$319$i = 0, $i$623$i = 0, $ispos$i$i = 0, $ispos$i$i52 = 0, $j$03$i = 0, $j$031$i = 0, $j$07$i$i = 0;
 var $j$08$i = 0, $j$1$lcssa$i = 0, $j$1$lcssa$i$i = 0, $j$11$i$i = 0, $j$12$i = 0, $j$122$i = 0, $j$17$i = 0, $j$217$i = 0, $j$25$i = 0, $j$3$i = 0, $j$3$lcssa$i = 0, $j$34$i = 0, $j$34$i45 = 0, $j$39$i = 0, $k$020$i = 0, $k$1$i = 0, $k$1$lcssa$i = 0, $k$112$i = 0, $k$17$i = 0, $kk$010$i = 0;
 var $kk$010$in$i = 0, $kk$013$i = 0, $kk$013$in$i = 0, $last_thm = 0, $loudness_power$02$i$i = 0.0, $m$0$i$i = 0.0, $m$0$i$i29 = 0.0, $m$0$lcssa$i = 0.0, $m$0$lcssa$i$i = 0.0, $m$020$i = 0.0, $m$03$i$i = 0.0, $m$1$i = 0.0, $m$1$i$i = 0.0, $m$1$i$i$lcssa = 0.0, $m$1$i$i34 = 0.0, $m$1$i$lcssa = 0.0, $m$1$i2$i = 0.0, $m$2$i$i = 0.0, $m$2$i$i35 = 0.0, $m$3$i$i = 0.0;
 var $m$3$i$i42 = 0.0, $mask_idx_s$i = 0, $mr$0 = 0, $neg$i$i = 0, $neg$i$i53 = 0, $new_thmm = 0, $ns_attacks = 0, $ns_uselongblock$0$i = 0, $or$cond = 0, $or$cond$1$i = 0, $or$cond$2$i = 0, $or$cond$i = 0, $or$cond$i20 = 0, $or$cond3 = 0, $or$cond7$1$i = 0, $or$cond7$2$i = 0, $or$cond7$i = 0, $or$cond75 = 0, $p$017$i = 0.0, $p$1$i = 0.0;
 var $p$1$i$lcssa = 0.0, $p$2$i = 0.0, $pe_l$02$i = 0.0, $pe_l$1$i = 0.0, $pe_l$1$i$lcssa = 0.0, $pe_s$04$i = 0.0, $pe_s$2$1$i = 0.0, $pe_s$2$2$i = 0.0, $pe_s$2$2$i$lcssa = 0.0, $pe_s$2$i = 0.0, $pf$018$i = 0, $pf$116$i = 0, $ppe$0 = 0, $prev_thm$0 = 0.0, $prev_thm$0$in = 0, $prev_thm$1 = 0.0, $ratio$0$i$i = 0.0, $ratio$0$i$i51 = 0.0, $sb$01$i = 0, $sb$0118 = 0;
 var $sb$02$i = 0, $sb$03$i = 0, $sblock$0130 = 0, $sblock$1116 = 0, $scevgep = 0, $scevgep162 = 0, $scevgep165 = 0, $scevgep175 = 0, $scevgep178 = 0, $smax$i = 0, $smax$i$i = 0, $smax$i31 = 0, $storemerge$i$i = 0, $storemerge$i$i30 = 0, $sub_short_factor = 0, $t1$0 = 0.0, $t2$0 = 0.0, $thm$i = 0, $thr = 0, $totalenergy$06$i = 0.0;
 var $type$0 = 0, $type$1 = 0, $uselongblock = 0, $wsamp_L = 0, $wsamp_S = 0, $x$1$1$i = 0.0, $x$1$10$i = 0.0, $x$1$2$i = 0.0, $x$1$3$i = 0.0, $x$1$4$i = 0.0, $x$1$5$i = 0.0, $x$1$6$i = 0.0, $x$1$7$i = 0.0, $x$1$8$i = 0.0, $x$1$9$i = 0.0, $x$1$i = 0.0, dest = 0, label = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 26240|0;
 $mask_idx_s$i = sp + 21624|0;
 $thm$i = sp + 21368|0;
 $avg$i = sp + 21112|0;
 $en_short$i = sp + 21096|0;
 $last_thm = sp + 20120|0;
 $fftenergy = sp + 18068|0;
 $fftenergy_s = sp + 16520|0;
 $wsamp_L = sp + 8328|0;
 $wsamp_S = sp + 2184|0;
 $eb = sp + 1160|0;
 $thr = sp + 136|0;
 $sub_short_factor = sp + 88|0;
 $ns_attacks = sp + 24|0;
 $uselongblock = sp + 16|0;
 $new_thmm = sp;
 $0 = ((($gfc)) + 85800|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ((($gfc)) + 140|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)==(0);
 if ($4) {
  $1192 = 0;
 } else {
  $5 = ((($gfc)) + 85804|0);
  $6 = HEAP32[$5>>2]|0;
  $1192 = $6;
 }
 $7 = ((($gfc)) + 192|0);
 $8 = +HEAPF32[$7>>2];
 $9 = $8 > 0.0;
 if ($9) {
  $10 = ((($gfc)) + 200|0);
  $11 = +HEAPF32[$10>>2];
  $12 = ((($gfc)) + 85796|0);
  $13 = HEAP32[$12>>2]|0;
  $14 = ((($13)) + 8|0);
  $15 = +HEAPF32[$14>>2];
  $16 = $15 * $11;
  $743 = $16;
 } else {
  $743 = 1.0;
 }
 dest=$ns_attacks; stop=dest+64|0; do { HEAP32[dest>>2]=0|0; dest=dest+4|0; } while ((dest|0) < (stop|0));
 $17 = ((($gfc)) + 180|0);
 $18 = HEAP32[$17>>2]|0;
 $19 = ($18|0)==(1);
 if ($19) {
  $417 = 4;
 } else {
  $20 = ((($gfc)) + 72|0);
  $21 = HEAP32[$20>>2]|0;
  $417 = $21;
 }
 $22 = ((($gfc)) + 25660|0);
 _memcpy(($last_thm|0),($22|0),976)|0;
 if ($4) {
  $117 = 0;
 } else {
  $23 = ((($gfc)) + 85804|0);
  $24 = HEAP32[$23>>2]|0;
  $117 = $24;
 }
 $25 = ((($gfc)) + 72|0);
 $26 = HEAP32[$25>>2]|0;
 $27 = $19 ? 4 : $26;
 _memset(($mask_idx_s$i|0),0,4608)|0;
 $28 = ($26|0)>(0);
 if ($28) {
  $29 = ($27|0)>(2);
  if ($29) {
   $chn$031$us$i = 0;
   while(1) {
    $30 = (($buffer) + ($chn$031$us$i<<2)|0);
    $31 = HEAP32[$30>>2]|0;
    $i$030$us$i = 0;
    while(1) {
     $$sum$us$i = (($i$030$us$i) + 407)|0;
     $42 = (($31) + ($$sum$us$i<<2)|0);
     $43 = +HEAPF32[$42>>2];
     $$sum1$us$i = (($i$030$us$i) + 397)|0;
     $44 = (($31) + ($$sum1$us$i<<2)|0);
     $45 = +HEAPF32[$44>>2];
     $$sum2$us$i = (($i$030$us$i) + 418)|0;
     $46 = (($31) + ($$sum2$us$i<<2)|0);
     $47 = +HEAPF32[$46>>2];
     $48 = $47 + $45;
     $49 = $48 * 1.7303260184043527E-17;
     $$sum3$us$i = (($i$030$us$i) + 398)|0;
     $50 = (($31) + ($$sum3$us$i<<2)|0);
     $51 = +HEAPF32[$50>>2];
     $$sum4$us$i = (($i$030$us$i) + 417)|0;
     $52 = (($31) + ($$sum4$us$i<<2)|0);
     $53 = +HEAPF32[$52>>2];
     $54 = $53 + $51;
     $55 = $54 * 0.017031719908118248;
     $$sum1$us$1$i = (($i$030$us$i) + 399)|0;
     $56 = (($31) + ($$sum1$us$1$i<<2)|0);
     $57 = +HEAPF32[$56>>2];
     $$sum2$us$1$i = (($i$030$us$i) + 416)|0;
     $58 = (($31) + ($$sum2$us$1$i<<2)|0);
     $59 = +HEAPF32[$58>>2];
     $60 = $59 + $57;
     $61 = $60 * 1.3495279640235235E-17;
     $$sum3$us$1$i = (($i$030$us$i) + 400)|0;
     $62 = (($31) + ($$sum3$us$1$i<<2)|0);
     $63 = +HEAPF32[$62>>2];
     $$sum4$us$1$i = (($i$030$us$i) + 415)|0;
     $64 = (($31) + ($$sum4$us$1$i<<2)|0);
     $65 = +HEAPF32[$64>>2];
     $66 = $65 + $63;
     $67 = $66 * 0.041807200759649277;
     $$sum1$us$2$i = (($i$030$us$i) + 401)|0;
     $68 = (($31) + ($$sum1$us$2$i<<2)|0);
     $69 = +HEAPF32[$68>>2];
     $$sum2$us$2$i = (($i$030$us$i) + 414)|0;
     $70 = (($31) + ($$sum2$us$2$i<<2)|0);
     $71 = +HEAPF32[$70>>2];
     $72 = $71 + $69;
     $73 = $72 * 6.7327796858492251E-17;
     $$sum3$us$2$i = (($i$030$us$i) + 402)|0;
     $74 = (($31) + ($$sum3$us$2$i<<2)|0);
     $75 = +HEAPF32[$74>>2];
     $$sum4$us$2$i = (($i$030$us$i) + 413)|0;
     $76 = (($31) + ($$sum4$us$2$i<<2)|0);
     $77 = +HEAPF32[$76>>2];
     $78 = $77 + $75;
     $79 = $78 * 0.087632402777671814;
     $$sum1$us$3$i = (($i$030$us$i) + 403)|0;
     $80 = (($31) + ($$sum1$us$3$i<<2)|0);
     $81 = +HEAPF32[$80>>2];
     $$sum2$us$3$i = (($i$030$us$i) + 412)|0;
     $82 = (($31) + ($$sum2$us$3$i<<2)|0);
     $83 = +HEAPF32[$82>>2];
     $84 = $83 + $81;
     $85 = $84 * 3.0835000291318875E-17;
     $$sum3$us$3$i = (($i$030$us$i) + 404)|0;
     $86 = (($31) + ($$sum3$us$3$i<<2)|0);
     $87 = +HEAPF32[$86>>2];
     $$sum4$us$3$i = (($i$030$us$i) + 411)|0;
     $88 = (($31) + ($$sum4$us$3$i<<2)|0);
     $89 = +HEAPF32[$88>>2];
     $90 = $89 + $87;
     $91 = $90 * 0.1863476037979126;
     $$sum1$us$4$i = (($i$030$us$i) + 405)|0;
     $92 = (($31) + ($$sum1$us$4$i<<2)|0);
     $93 = +HEAPF32[$92>>2];
     $$sum2$us$4$i = (($i$030$us$i) + 410)|0;
     $94 = (($31) + ($$sum2$us$4$i<<2)|0);
     $95 = +HEAPF32[$94>>2];
     $96 = $95 + $93;
     $97 = $96 * 1.1044240253100168E-16;
     $$sum3$us$4$i = (($i$030$us$i) + 406)|0;
     $98 = (($31) + ($$sum3$us$4$i<<2)|0);
     $99 = +HEAPF32[$98>>2];
     $$sum4$us$4$i = (($i$030$us$i) + 409)|0;
     $100 = (($31) + ($$sum4$us$4$i<<2)|0);
     $101 = +HEAPF32[$100>>2];
     $102 = $101 + $99;
     $103 = $102 * 0.62763798236846924;
     $104 = $43 - $49;
     $105 = $104 - $55;
     $106 = $105 - $61;
     $107 = $106 + $67;
     $108 = $107 - $73;
     $109 = $108 - $79;
     $110 = $109 - $85;
     $111 = $110 + $91;
     $112 = $111 - $97;
     $113 = $112 - $103;
     $114 = ((($mask_idx_s$i) + (($chn$031$us$i*2304)|0)|0) + ($i$030$us$i<<2)|0);
     HEAPF32[$114>>2] = $113;
     $115 = (($i$030$us$i) + 1)|0;
     $exitcond50$i = ($115|0)==(576);
     if ($exitcond50$i) {
      break;
     } else {
      $i$030$us$i = $115;
     }
    }
    $32 = ((((($masking_ratio) + (($gr_out*976)|0)|0) + (($chn$031$us$i*488)|0)|0)) + 244|0);
    $33 = (((($gfc)) + 26636|0) + (($chn$031$us$i*244)|0)|0);
    _memcpy(($32|0),($33|0),244)|0;
    $34 = ((($masking_ratio) + (($gr_out*976)|0)|0) + (($chn$031$us$i*488)|0)|0);
    $35 = (((($gfc)) + 25660|0) + (($chn$031$us$i*244)|0)|0);
    _memcpy(($34|0),($35|0),244)|0;
    $36 = ((((($masking_MS_ratio) + (($gr_out*976)|0)|0) + (($chn$031$us$i*488)|0)|0)) + 244|0);
    $37 = (($chn$031$us$i) + 2)|0;
    $38 = (((($gfc)) + 26636|0) + (($37*244)|0)|0);
    _memcpy(($36|0),($38|0),244)|0;
    $39 = ((($masking_MS_ratio) + (($gr_out*976)|0)|0) + (($chn$031$us$i*488)|0)|0);
    $40 = (((($gfc)) + 25660|0) + (($37*244)|0)|0);
    _memcpy(($39|0),($40|0),244)|0;
    $41 = (($chn$031$us$i) + 1)|0;
    $exitcond51$i = ($41|0)==($26|0);
    if ($exitcond51$i) {
     break;
    } else {
     $chn$031$us$i = $41;
    }
   }
  } else {
   $chn$031$i = 0;
   while(1) {
    $145 = (($buffer) + ($chn$031$i<<2)|0);
    $146 = HEAP32[$145>>2]|0;
    $i$030$i = 0;
    while(1) {
     $$sum$i = (($i$030$i) + 407)|0;
     $147 = (($146) + ($$sum$i<<2)|0);
     $148 = +HEAPF32[$147>>2];
     $$sum1$i = (($i$030$i) + 397)|0;
     $149 = (($146) + ($$sum1$i<<2)|0);
     $150 = +HEAPF32[$149>>2];
     $$sum2$i = (($i$030$i) + 418)|0;
     $151 = (($146) + ($$sum2$i<<2)|0);
     $152 = +HEAPF32[$151>>2];
     $153 = $152 + $150;
     $154 = $153 * 1.7303260184043527E-17;
     $$sum3$i = (($i$030$i) + 398)|0;
     $155 = (($146) + ($$sum3$i<<2)|0);
     $156 = +HEAPF32[$155>>2];
     $$sum4$i = (($i$030$i) + 417)|0;
     $157 = (($146) + ($$sum4$i<<2)|0);
     $158 = +HEAPF32[$157>>2];
     $159 = $158 + $156;
     $160 = $159 * 0.017031719908118248;
     $$sum1$1$i = (($i$030$i) + 399)|0;
     $161 = (($146) + ($$sum1$1$i<<2)|0);
     $162 = +HEAPF32[$161>>2];
     $$sum2$1$i = (($i$030$i) + 416)|0;
     $163 = (($146) + ($$sum2$1$i<<2)|0);
     $164 = +HEAPF32[$163>>2];
     $165 = $164 + $162;
     $166 = $165 * 1.3495279640235235E-17;
     $$sum3$1$i = (($i$030$i) + 400)|0;
     $167 = (($146) + ($$sum3$1$i<<2)|0);
     $168 = +HEAPF32[$167>>2];
     $$sum4$1$i = (($i$030$i) + 415)|0;
     $169 = (($146) + ($$sum4$1$i<<2)|0);
     $170 = +HEAPF32[$169>>2];
     $171 = $170 + $168;
     $172 = $171 * 0.041807200759649277;
     $$sum1$2$i = (($i$030$i) + 401)|0;
     $173 = (($146) + ($$sum1$2$i<<2)|0);
     $174 = +HEAPF32[$173>>2];
     $$sum2$2$i = (($i$030$i) + 414)|0;
     $175 = (($146) + ($$sum2$2$i<<2)|0);
     $176 = +HEAPF32[$175>>2];
     $177 = $176 + $174;
     $178 = $177 * 6.7327796858492251E-17;
     $$sum3$2$i = (($i$030$i) + 402)|0;
     $179 = (($146) + ($$sum3$2$i<<2)|0);
     $180 = +HEAPF32[$179>>2];
     $$sum4$2$i = (($i$030$i) + 413)|0;
     $181 = (($146) + ($$sum4$2$i<<2)|0);
     $182 = +HEAPF32[$181>>2];
     $183 = $182 + $180;
     $184 = $183 * 0.087632402777671814;
     $$sum1$3$i = (($i$030$i) + 403)|0;
     $185 = (($146) + ($$sum1$3$i<<2)|0);
     $186 = +HEAPF32[$185>>2];
     $$sum2$3$i = (($i$030$i) + 412)|0;
     $187 = (($146) + ($$sum2$3$i<<2)|0);
     $188 = +HEAPF32[$187>>2];
     $189 = $188 + $186;
     $190 = $189 * 3.0835000291318875E-17;
     $$sum3$3$i = (($i$030$i) + 404)|0;
     $191 = (($146) + ($$sum3$3$i<<2)|0);
     $192 = +HEAPF32[$191>>2];
     $$sum4$3$i = (($i$030$i) + 411)|0;
     $193 = (($146) + ($$sum4$3$i<<2)|0);
     $194 = +HEAPF32[$193>>2];
     $195 = $194 + $192;
     $196 = $195 * 0.1863476037979126;
     $$sum1$4$i = (($i$030$i) + 405)|0;
     $197 = (($146) + ($$sum1$4$i<<2)|0);
     $198 = +HEAPF32[$197>>2];
     $$sum2$4$i = (($i$030$i) + 410)|0;
     $199 = (($146) + ($$sum2$4$i<<2)|0);
     $200 = +HEAPF32[$199>>2];
     $201 = $200 + $198;
     $202 = $201 * 1.1044240253100168E-16;
     $$sum3$4$i = (($i$030$i) + 406)|0;
     $203 = (($146) + ($$sum3$4$i<<2)|0);
     $204 = +HEAPF32[$203>>2];
     $$sum4$4$i = (($i$030$i) + 409)|0;
     $205 = (($146) + ($$sum4$4$i<<2)|0);
     $206 = +HEAPF32[$205>>2];
     $207 = $206 + $204;
     $208 = $207 * 0.62763798236846924;
     $209 = $148 - $154;
     $210 = $209 - $160;
     $211 = $210 - $166;
     $212 = $211 + $172;
     $213 = $212 - $178;
     $214 = $213 - $184;
     $215 = $214 - $190;
     $216 = $215 + $196;
     $217 = $216 - $202;
     $218 = $217 - $208;
     $219 = ((($mask_idx_s$i) + (($chn$031$i*2304)|0)|0) + ($i$030$i<<2)|0);
     HEAPF32[$219>>2] = $218;
     $220 = (($i$030$i) + 1)|0;
     $exitcond48$i = ($220|0)==(576);
     if ($exitcond48$i) {
      break;
     } else {
      $i$030$i = $220;
     }
    }
    $221 = ((((($masking_ratio) + (($gr_out*976)|0)|0) + (($chn$031$i*488)|0)|0)) + 244|0);
    $222 = (((($gfc)) + 26636|0) + (($chn$031$i*244)|0)|0);
    _memcpy(($221|0),($222|0),244)|0;
    $223 = ((($masking_ratio) + (($gr_out*976)|0)|0) + (($chn$031$i*488)|0)|0);
    $224 = (((($gfc)) + 25660|0) + (($chn$031$i*244)|0)|0);
    _memcpy(($223|0),($224|0),244)|0;
    $225 = (($chn$031$i) + 1)|0;
    $exitcond49$i = ($225|0)==($26|0);
    if ($exitcond49$i) {
     break;
    } else {
     $chn$031$i = $225;
    }
   }
  }
 }
 $116 = ($27|0)>(0);
 if ($116) {
  $118 = ($117|0)==(0|0);
  $119 = ((($uselongblock)) + 4|0);
  $120 = ((($avg$i)) + 4|0);
  $121 = ((($thm$i)) + 4|0);
  $122 = ((($avg$i)) + 8|0);
  $123 = ((($thm$i)) + 8|0);
  $124 = ((($avg$i)) + 12|0);
  $125 = ((($avg$i)) + 16|0);
  $126 = ((($avg$i)) + 20|0);
  $127 = ((($avg$i)) + 24|0);
  $128 = ((($avg$i)) + 28|0);
  $129 = ((($avg$i)) + 32|0);
  $130 = ((($avg$i)) + 36|0);
  $131 = ((($avg$i)) + 40|0);
  $132 = ((($avg$i)) + 44|0);
  $133 = ((($en_short$i)) + 4|0);
  $134 = ((($en_short$i)) + 8|0);
  $135 = ((($en_short$i)) + 12|0);
  $136 = ((($thm$i)) + 12|0);
  $137 = ((($thm$i)) + 16|0);
  $138 = ((($thm$i)) + 20|0);
  $139 = ((($thm$i)) + 24|0);
  $140 = ((($thm$i)) + 28|0);
  $141 = ((($thm$i)) + 32|0);
  $142 = ((($thm$i)) + 36|0);
  $143 = ((($thm$i)) + 40|0);
  $144 = ((($thm$i)) + 44|0);
  $chn$125$i = 0;
  while(1) {
   ;HEAP32[$en_short$i>>2]=0|0;HEAP32[$en_short$i+4>>2]=0|0;HEAP32[$en_short$i+8>>2]=0|0;HEAP32[$en_short$i+12>>2]=0|0;
   $226 = $chn$125$i & 1;
   $227 = (($mask_idx_s$i) + (($226*2304)|0)|0);
   $228 = ($chn$125$i|0)==(2);
   if ($228) {
    $i$114$i = 0;
    while(1) {
     $244 = (($mask_idx_s$i) + ($i$114$i<<2)|0);
     $245 = +HEAPF32[$244>>2];
     $246 = (((($mask_idx_s$i)) + 2304|0) + ($i$114$i<<2)|0);
     $247 = +HEAPF32[$246>>2];
     $248 = $247 + $245;
     HEAPF32[$244>>2] = $248;
     $249 = $245 - $247;
     HEAPF32[$246>>2] = $249;
     $250 = (($i$114$i) + 1)|0;
     $exitcond$i = ($250|0)==(576);
     if ($exitcond$i) {
      break;
     } else {
      $i$114$i = $250;
     }
    }
   }
   $229 = (((((($gfc)) + 27636|0) + (($chn$125$i*36)|0)|0)) + 24|0);
   $230 = +HEAPF32[$229>>2];
   HEAPF32[$avg$i>>2] = $230;
   $231 = (((((($gfc)) + 27636|0) + (($chn$125$i*36)|0)|0)) + 16|0);
   $232 = +HEAPF32[$231>>2];
   $233 = $230 / $232;
   HEAPF32[$thm$i>>2] = $233;
   $234 = (((((($gfc)) + 27636|0) + (($chn$125$i*36)|0)|0)) + 28|0);
   $235 = +HEAPF32[$234>>2];
   HEAPF32[$120>>2] = $235;
   $236 = (((((($gfc)) + 27636|0) + (($chn$125$i*36)|0)|0)) + 20|0);
   $237 = +HEAPF32[$236>>2];
   $238 = $235 / $237;
   HEAPF32[$121>>2] = $238;
   $239 = $235 + $230;
   $240 = (((((($gfc)) + 27636|0) + (($chn$125$i*36)|0)|0)) + 32|0);
   $241 = +HEAPF32[$240>>2];
   HEAPF32[$122>>2] = $241;
   $242 = $241 / $230;
   HEAPF32[$123>>2] = $242;
   $243 = $239 + $241;
   HEAPF32[$en_short$i>>2] = $243;
   $i$319$i = 0;$pf$018$i = $227;
   while(1) {
    $258 = ((($pf$018$i)) + 256|0);
    $p$017$i = 1.0;$pf$116$i = $pf$018$i;
    while(1) {
     $259 = +HEAPF32[$pf$116$i>>2];
     $fabsf$i = (+Math_abs((+$259)));
     $260 = $p$017$i < $fabsf$i;
     $p$1$i = $260 ? $fabsf$i : $p$017$i;
     $261 = ((($pf$116$i)) + 4|0);
     $262 = ($261>>>0)<($258>>>0);
     if ($262) {
      $p$017$i = $p$1$i;$pf$116$i = $261;
     } else {
      $p$1$i$lcssa = $p$1$i;
      break;
     }
    }
    $263 = (($i$319$i) + 3)|0;
    $264 = (($avg$i) + ($263<<2)|0);
    HEAPF32[$264>>2] = $p$1$i$lcssa;
    $265 = ((((($gfc)) + 27636|0) + (($chn$125$i*36)|0)|0) + ($i$319$i<<2)|0);
    HEAPF32[$265>>2] = $p$1$i$lcssa;
    $266 = (($i$319$i|0) / 3)&-1;
    $267 = (($266) + 1)|0;
    $268 = (($en_short$i) + ($267<<2)|0);
    $269 = +HEAPF32[$268>>2];
    $270 = $269 + $p$1$i$lcssa;
    HEAPF32[$268>>2] = $270;
    $271 = (($i$319$i) + 1)|0;
    $272 = (($avg$i) + ($271<<2)|0);
    $273 = +HEAPF32[$272>>2];
    $274 = $p$1$i$lcssa > $273;
    if ($274) {
     $275 = $p$1$i$lcssa / $273;
     $p$2$i = $275;
    } else {
     $276 = $p$1$i$lcssa * 10.0;
     $277 = $273 > $276;
     if ($277) {
      $278 = $273 / $276;
      $p$2$i = $278;
     } else {
      $p$2$i = 0.0;
     }
    }
    $279 = (($thm$i) + ($263<<2)|0);
    HEAPF32[$279>>2] = $p$2$i;
    $exitcond41$i = ($271|0)==(9);
    if ($exitcond41$i) {
     break;
    } else {
     $i$319$i = $271;$pf$018$i = $258;
    }
   }
   $251 = +HEAPF32[$124>>2];
   $252 = +HEAPF32[$125>>2];
   $253 = $252 + $251;
   $254 = +HEAPF32[$126>>2];
   $255 = $253 + $254;
   $256 = $254 * 6.0;
   $257 = $256 < $255;
   if ($257) {
    $280 = $252 * 6.0;
    $281 = $280 < $255;
    if ($281) {
     $factor$0$i = 0.25;
    } else {
     $factor$0$i = 0.5;
    }
   } else {
    $factor$0$i = 1.0;
   }
   $282 = (($sub_short_factor) + (($chn$125$i*12)|0)|0);
   HEAPF32[$282>>2] = $factor$0$i;
   $283 = +HEAPF32[$127>>2];
   $284 = +HEAPF32[$128>>2];
   $285 = $284 + $283;
   $286 = +HEAPF32[$129>>2];
   $287 = $285 + $286;
   $288 = $286 * 6.0;
   $289 = $288 < $287;
   if ($289) {
    $379 = $284 * 6.0;
    $380 = $379 < $287;
    if ($380) {
     $factor$0$1$i = 0.25;
    } else {
     $factor$0$1$i = 0.5;
    }
   } else {
    $factor$0$1$i = 1.0;
   }
   $381 = (((($sub_short_factor) + (($chn$125$i*12)|0)|0)) + 4|0);
   HEAPF32[$381>>2] = $factor$0$1$i;
   $382 = +HEAPF32[$130>>2];
   $383 = +HEAPF32[$131>>2];
   $384 = $383 + $382;
   $385 = +HEAPF32[$132>>2];
   $386 = $384 + $385;
   $387 = $385 * 6.0;
   $388 = $387 < $386;
   if ($388) {
    $389 = $383 * 6.0;
    $390 = $389 < $386;
    if ($390) {
     $factor$0$2$i = 0.25;
    } else {
     $factor$0$2$i = 0.5;
    }
   } else {
    $factor$0$2$i = 1.0;
   }
   $391 = (((($sub_short_factor) + (($chn$125$i*12)|0)|0)) + 8|0);
   HEAPF32[$391>>2] = $factor$0$2$i;
   if (!($118)) {
    $290 = +HEAPF32[$thm$i>>2];
    $291 = +HEAPF32[$121>>2];
    $292 = $290 < $291;
    $x$1$i = $292 ? $291 : $290;
    $293 = +HEAPF32[$123>>2];
    $294 = $x$1$i < $293;
    $x$1$1$i = $294 ? $293 : $x$1$i;
    $295 = +HEAPF32[$136>>2];
    $296 = $x$1$1$i < $295;
    $x$1$2$i = $296 ? $295 : $x$1$1$i;
    $297 = +HEAPF32[$137>>2];
    $298 = $x$1$2$i < $297;
    $x$1$3$i = $298 ? $297 : $x$1$2$i;
    $299 = +HEAPF32[$138>>2];
    $300 = $x$1$3$i < $299;
    $x$1$4$i = $300 ? $299 : $x$1$3$i;
    $301 = +HEAPF32[$139>>2];
    $302 = $x$1$4$i < $301;
    $x$1$5$i = $302 ? $301 : $x$1$4$i;
    $303 = +HEAPF32[$140>>2];
    $304 = $x$1$5$i < $303;
    $x$1$6$i = $304 ? $303 : $x$1$5$i;
    $305 = +HEAPF32[$141>>2];
    $306 = $x$1$6$i < $305;
    $x$1$7$i = $306 ? $305 : $x$1$6$i;
    $307 = +HEAPF32[$142>>2];
    $308 = $x$1$7$i < $307;
    $x$1$8$i = $308 ? $307 : $x$1$7$i;
    $309 = +HEAPF32[$143>>2];
    $310 = $x$1$8$i < $309;
    $x$1$9$i = $310 ? $309 : $x$1$8$i;
    $311 = +HEAPF32[$144>>2];
    $312 = $x$1$9$i < $311;
    $x$1$10$i = $312 ? $311 : $x$1$9$i;
    $313 = (((($117)) + 197112|0) + ($chn$125$i<<3)|0);
    $314 = +HEAPF64[$313>>3];
    $315 = ((((($117)) + 197144|0) + ($gr_out<<5)|0) + ($chn$125$i<<3)|0);
    HEAPF64[$315>>3] = $314;
    $316 = $x$1$10$i;
    HEAPF64[$313>>3] = $316;
   }
   $317 = HEAP32[$0>>2]|0;
   $318 = (((($317)) + 6480|0) + ($chn$125$i<<2)|0);
   $319 = +HEAPF32[$318>>2];
   $i$623$i = 0;
   while(1) {
    $330 = (($i$623$i|0) / 3)&-1;
    $331 = ((($ns_attacks) + ($chn$125$i<<4)|0) + ($330<<2)|0);
    $332 = HEAP32[$331>>2]|0;
    $333 = ($332|0)==(0);
    if ($333) {
     $334 = (($thm$i) + ($i$623$i<<2)|0);
     $335 = +HEAPF32[$334>>2];
     $336 = $335 > $319;
     if ($336) {
      $337 = (($i$623$i|0) % 3)&-1;
      $338 = (($337) + 1)|0;
      HEAP32[$331>>2] = $338;
     }
    }
    $339 = (($i$623$i) + 1)|0;
    $exitcond44$i = ($339|0)==(12);
    if ($exitcond44$i) {
     break;
    } else {
     $i$623$i = $339;
    }
   }
   $320 = (($ns_attacks) + ($chn$125$i<<4)|0);
   $321 = +HEAPF32[$en_short$i>>2];
   $322 = +HEAPF32[$133>>2];
   $323 = $321 > $322;
   $324 = $323 ? $321 : $322;
   $325 = $324 < 4.0E+4;
   $326 = $322 * 1.7000000476837158;
   $327 = $321 < $326;
   $or$cond$i = $327 & $325;
   $328 = $321 * 1.7000000476837158;
   $329 = $322 < $328;
   $or$cond7$i = $329 & $or$cond$i;
   if ($or$cond7$i) {
    $340 = HEAP32[$320>>2]|0;
    $341 = (((($ns_attacks) + ($chn$125$i<<4)|0)) + 4|0);
    $342 = HEAP32[$341>>2]|0;
    $343 = ($340|0)>($342|0);
    if (!($343)) {
     HEAP32[$320>>2] = 0;
    }
    HEAP32[$341>>2] = 0;
   }
   $344 = +HEAPF32[$134>>2];
   $345 = $322 > $344;
   $346 = $345 ? $322 : $344;
   $347 = $346 < 4.0E+4;
   $348 = $344 * 1.7000000476837158;
   $349 = $322 < $348;
   $or$cond$1$i = $349 & $347;
   $350 = $344 < $326;
   $or$cond7$1$i = $350 & $or$cond$1$i;
   if ($or$cond7$1$i) {
    $$pre61$i = (((($ns_attacks) + ($chn$125$i<<4)|0)) + 8|0);
    HEAP32[$$pre61$i>>2] = 0;
   }
   $392 = +HEAPF32[$135>>2];
   $393 = $344 > $392;
   $394 = $393 ? $344 : $392;
   $395 = $394 < 4.0E+4;
   $396 = $392 * 1.7000000476837158;
   $397 = $344 < $396;
   $or$cond$2$i = $397 & $395;
   $398 = $392 < $348;
   $or$cond7$2$i = $398 & $or$cond$2$i;
   if ($or$cond7$2$i) {
    $$pre63$i = (((($ns_attacks) + ($chn$125$i<<4)|0)) + 12|0);
    HEAP32[$$pre63$i>>2] = 0;
   }
   $399 = HEAP32[$320>>2]|0;
   $400 = (((($gfc)) + 27780|0) + ($chn$125$i<<2)|0);
   $351 = HEAP32[$400>>2]|0;
   $401 = ($399|0)>($351|0);
   if ($401) {
    $354 = $399;
   } else {
    HEAP32[$320>>2] = 0;
    $354 = 0;
   }
   $352 = ($351|0)==(3);
   $$phi$trans$insert$i = (((($ns_attacks) + ($chn$125$i<<4)|0)) + 4|0);
   $$pre$i = HEAP32[$$phi$trans$insert$i>>2]|0;
   if ($352) {
    label = 47;
   } else {
    $353 = (($$pre$i) + ($354))|0;
    $355 = (((($ns_attacks) + ($chn$125$i<<4)|0)) + 8|0);
    $356 = HEAP32[$355>>2]|0;
    $357 = (($353) + ($356))|0;
    $358 = (((($ns_attacks) + ($chn$125$i<<4)|0)) + 12|0);
    $359 = HEAP32[$358>>2]|0;
    $360 = (0 - ($359))|0;
    $361 = ($357|0)==($360|0);
    if ($361) {
     $ns_uselongblock$0$i = 1;
    } else {
     label = 47;
    }
   }
   do {
    if ((label|0) == 47) {
     label = 0;
     $362 = ($$pre$i|0)==(0);
     do {
      if ($362) {
       $367 = 0;
      } else {
       $363 = ($354|0)==(0);
       if ($363) {
        $367 = $$pre$i;
        break;
       }
       HEAP32[$$phi$trans$insert$i>>2] = 0;
       $367 = 0;
      }
     } while(0);
     $364 = (((($ns_attacks) + ($chn$125$i<<4)|0)) + 8|0);
     $365 = HEAP32[$364>>2]|0;
     $366 = ($365|0)==(0);
     if ($366) {
      $ns_uselongblock$0$i = 0;
      break;
     }
     $368 = ($367|0)==(0);
     if (!($368)) {
      HEAP32[$364>>2] = 0;
      $ns_uselongblock$0$i = 0;
      break;
     }
     $369 = (((($ns_attacks) + ($chn$125$i<<4)|0)) + 12|0);
     $370 = HEAP32[$369>>2]|0;
     $371 = ($370|0)==(0);
     if ($371) {
      $ns_uselongblock$0$i = 0;
      break;
     }
     HEAP32[$369>>2] = 0;
     $ns_uselongblock$0$i = 0;
    }
   } while(0);
   $372 = ($chn$125$i|0)<(2);
   do {
    if ($372) {
     $373 = (($uselongblock) + ($chn$125$i<<2)|0);
     HEAP32[$373>>2] = $ns_uselongblock$0$i;
    } else {
     $374 = ($ns_uselongblock$0$i|0)==(0);
     if (!($374)) {
      break;
     }
     HEAP32[$119>>2] = 0;
     HEAP32[$uselongblock>>2] = 0;
    }
   } while(0);
   $375 = (((($gfc)) + 27620|0) + ($chn$125$i<<2)|0);
   $376 = HEAP32[$375>>2]|0;
   $377 = (($energy) + ($chn$125$i<<2)|0);
   HEAP32[$377>>2] = $376;
   $378 = (($chn$125$i) + 1)|0;
   $exitcond46$i = ($378|0)==($27|0);
   if ($exitcond46$i) {
    break;
   } else {
    $chn$125$i = $378;
   }
  }
 }
 $402 = ((($gfc)) + 184|0);
 $403 = HEAP32[$402>>2]|0;
 $404 = ($403|0)==(1);
 if ($404) {
  $405 = HEAP32[$uselongblock>>2]|0;
  $406 = ($405|0)==(0);
  $$pre8$i = ((($uselongblock)) + 4|0);
  $407 = HEAP32[$$pre8$i>>2]|0;
  $408 = ($407|0)==(0);
  $or$cond75 = $406 | $408;
  if ($or$cond75) {
   HEAP32[$$pre8$i>>2] = 0;
   HEAP32[$uselongblock>>2] = 0;
  }
 }
 $409 = HEAP32[$25>>2]|0;
 $410 = ($409|0)>(0);
 do {
  if ($410) {
   if ((($403|0) == 3)) {
    $chn$01$i$us = 0;
    while(1) {
     $411 = (($uselongblock) + ($chn$01$i$us<<2)|0);
     HEAP32[$411>>2] = 0;
     $412 = (($chn$01$i$us) + 1)|0;
     $413 = ($412|0)<($409|0);
     if ($413) {
      $chn$01$i$us = $412;
     } else {
      break;
     }
    }
   } else if ((($403|0) == 2)) {
    $chn$01$us$i = 0;
    while(1) {
     $414 = (($uselongblock) + ($chn$01$us$i<<2)|0);
     HEAP32[$414>>2] = 1;
     $415 = (($chn$01$us$i) + 1)|0;
     $416 = ($415|0)<($409|0);
     if ($416) {
      $chn$01$us$i = $415;
     } else {
      break;
     }
    }
   } else {
    break;
   }
  }
 } while(0);
 $418 = ($417|0)>(0);
 if ($418) {
  $419 = ((($gfc)) + 85796|0);
  $420 = ((($thm$i)) + 4|0);
  $421 = ((($gfc)) + 84908|0);
  $$pre37$i = ((($avg$i)) + 4|0);
  $422 = ((($gfc)) + 85804|0);
  $chn$0136 = 0;
  while(1) {
   $423 = $chn$0136 & 1;
   $424 = (($wsamp_L) + ($423<<12)|0);
   $425 = HEAP32[$2>>2]|0;
   $426 = ($425|0)==(0);
   if ($426) {
    $460 = 0;
   } else {
    $427 = HEAP32[$422>>2]|0;
    $460 = $427;
   }
   $428 = ($chn$0136|0)<(2);
   if ($428) {
    _fft_long($gfc,$424,$chn$0136,$buffer);
   } else {
    $429 = ($chn$0136|0)==(2);
    if ($429) {
     $$sum73 = (($423) + 1)|0;
     $j$08$i = 1023;
     while(1) {
      $430 = ((($wsamp_L) + ($423<<12)|0) + ($j$08$i<<2)|0);
      $431 = +HEAPF32[$430>>2];
      $432 = ((($wsamp_L) + ($$sum73<<12)|0) + ($j$08$i<<2)|0);
      $433 = +HEAPF32[$432>>2];
      $434 = $433 + $431;
      $435 = $434 * 0.70710676908493042;
      HEAPF32[$430>>2] = $435;
      $436 = $431 - $433;
      $437 = $436 * 0.70710676908493042;
      HEAPF32[$432>>2] = $437;
      $438 = (($j$08$i) + -1)|0;
      $439 = ($j$08$i|0)>(0);
      if ($439) {
       $j$08$i = $438;
      } else {
       break;
      }
     }
    }
   }
   $440 = +HEAPF32[$424>>2];
   $441 = $440 * $440;
   HEAPF32[$fftenergy>>2] = $441;
   $j$17$i = 511;
   while(1) {
    $442 = (512 - ($j$17$i))|0;
    $443 = ((($wsamp_L) + ($423<<12)|0) + ($442<<2)|0);
    $444 = +HEAPF32[$443>>2];
    $445 = (($j$17$i) + 512)|0;
    $446 = ((($wsamp_L) + ($423<<12)|0) + ($445<<2)|0);
    $447 = +HEAPF32[$446>>2];
    $448 = $444 * $444;
    $449 = $447 * $447;
    $450 = $449 + $448;
    $451 = $450 * 0.5;
    $452 = (($fftenergy) + ($442<<2)|0);
    HEAPF32[$452>>2] = $451;
    $453 = (($j$17$i) + -1)|0;
    $454 = ($j$17$i|0)>(0);
    if ($454) {
     $j$17$i = $453;
    } else {
     $j$25$i = 11;$totalenergy$06$i = 0.0;
     break;
    }
   }
   while(1) {
    $455 = (($fftenergy) + ($j$25$i<<2)|0);
    $456 = +HEAPF32[$455>>2];
    $457 = $456 + $totalenergy$06$i;
    $458 = (($j$25$i) + 1)|0;
    $exitcond9$i = ($458|0)==(513);
    if ($exitcond9$i) {
     $$lcssa229 = $457;
     break;
    } else {
     $j$25$i = $458;$totalenergy$06$i = $457;
    }
   }
   $459 = (((($gfc)) + 27620|0) + ($chn$0136<<2)|0);
   HEAPF32[$459>>2] = $$lcssa229;
   $461 = ($460|0)==(0|0);
   if (!($461)) {
    $j$34$i = 0;
    while(1) {
     $462 = ((((($460)) + 90936|0) + ($chn$0136<<13)|0) + ($j$34$i<<3)|0);
     $463 = +HEAPF64[$462>>3];
     $464 = (((((($460)) + 123704|0) + ($gr_out<<15)|0) + ($chn$0136<<13)|0) + ($j$34$i<<3)|0);
     HEAPF64[$464>>3] = $463;
     $465 = (($fftenergy) + ($j$34$i<<2)|0);
     $466 = +HEAPF32[$465>>2];
     $467 = $466;
     HEAPF64[$462>>3] = $467;
     $468 = (($j$34$i) + 1)|0;
     $exitcond$i8 = ($468|0)==(513);
     if ($exitcond$i8) {
      break;
     } else {
      $j$34$i = $468;
     }
    }
   }
   if ($428) {
    $469 = (((($gfc)) + 27612|0) + ($chn$0136<<2)|0);
    $470 = HEAP32[$469>>2]|0;
    $471 = ((((($gfc)) + 27804|0) + ($gr_out<<3)|0) + ($chn$0136<<2)|0);
    HEAP32[$471>>2] = $470;
    $472 = HEAP32[$419>>2]|0;
    $i$01$i$i = 0;$loudness_power$02$i$i = 0.0;
    while(1) {
     $473 = (($fftenergy) + ($i$01$i$i<<2)|0);
     $474 = +HEAPF32[$473>>2];
     $475 = (((($472)) + 724|0) + ($i$01$i$i<<2)|0);
     $476 = +HEAPF32[$475>>2];
     $477 = $476 * $474;
     $478 = $477 + $loudness_power$02$i$i;
     $479 = (($i$01$i$i) + 1)|0;
     $exitcond$i$i = ($479|0)==(512);
     if ($exitcond$i$i) {
      $$lcssa230 = $478;
      break;
     } else {
      $i$01$i$i = $479;$loudness_power$02$i$i = $478;
     }
    }
    $480 = $$lcssa230;
    $481 = $480 * 8.9748713435966334E-12;
    $482 = $481;
    HEAPF32[$469>>2] = $482;
   }
   $483 = HEAP32[$0>>2]|0;
   $484 = ((($483)) + 2148|0);
   $485 = HEAP32[$484>>2]|0;
   $486 = ($485|0)>(0);
   if ($486) {
    $b$08$i$i = 0;$j$07$i$i = 0;
    while(1) {
     $487 = (((($483)) + 1716|0) + ($b$08$i$i<<2)|0);
     $488 = HEAP32[$487>>2]|0;
     $489 = ($488|0)>(0);
     if ($489) {
      $ebb$02$i$i = 0.0;$i$04$i$i = 0;$j$11$i$i = $j$07$i$i;$m$03$i$i = 0.0;
      while(1) {
       $490 = (($fftenergy) + ($j$11$i$i<<2)|0);
       $491 = +HEAPF32[$490>>2];
       $492 = $491 + $ebb$02$i$i;
       $493 = $m$03$i$i < $491;
       $m$1$i$i = $493 ? $491 : $m$03$i$i;
       $494 = (($i$04$i$i) + 1)|0;
       $495 = (($j$11$i$i) + 1)|0;
       $exitcond32$i = ($494|0)==($488|0);
       if ($exitcond32$i) {
        $$lcssa231 = $492;$m$1$i$i$lcssa = $m$1$i$i;
        break;
       } else {
        $ebb$02$i$i = $492;$i$04$i$i = $494;$j$11$i$i = $495;$m$03$i$i = $m$1$i$i;
       }
      }
      $496 = ($488|0)>(1);
      $smax$i$i = $496 ? $488 : 1;
      $497 = (($smax$i$i) + ($j$07$i$i))|0;
      $ebb$0$lcssa$i$i = $$lcssa231;$j$1$lcssa$i$i = $497;$m$0$lcssa$i$i = $m$1$i$i$lcssa;
     } else {
      $ebb$0$lcssa$i$i = 0.0;$j$1$lcssa$i$i = $j$07$i$i;$m$0$lcssa$i$i = 0.0;
     }
     $498 = ((($eb) + ($chn$0136<<8)|0) + ($b$08$i$i<<2)|0);
     HEAPF32[$498>>2] = $ebb$0$lcssa$i$i;
     $499 = (($thm$i) + ($b$08$i$i<<2)|0);
     HEAPF32[$499>>2] = $m$0$lcssa$i$i;
     $500 = (((($483)) + 512|0) + ($b$08$i$i<<2)|0);
     $501 = +HEAPF32[$500>>2];
     $502 = $501 * $ebb$0$lcssa$i$i;
     $503 = (($avg$i) + ($b$08$i$i<<2)|0);
     HEAPF32[$503>>2] = $502;
     $504 = (($b$08$i$i) + 1)|0;
     $exitcond33$i = ($504|0)==($485|0);
     if ($exitcond33$i) {
      break;
     } else {
      $b$08$i$i = $504;$j$07$i$i = $j$1$lcssa$i$i;
     }
    }
    $$pre$i12 = +HEAPF32[$avg$i>>2];
    $$pre34$i = +HEAPF32[$$pre37$i>>2];
    $506 = $$pre34$i;$507 = $$pre$i12;
   } else {
    $506 = 0.0;$507 = 0.0;
   }
   $505 = $507 + $506;
   $508 = $505 > 0.0;
   if ($508) {
    $509 = +HEAPF32[$thm$i>>2];
    $510 = +HEAPF32[$420>>2];
    $511 = $509 < $510;
    $m$0$i$i = $511 ? $510 : $509;
    $512 = $m$0$i$i * 2.0;
    $513 = $512 - $505;
    $514 = $513 * 20.0;
    $515 = ((($483)) + 1716|0);
    $516 = HEAP32[$515>>2]|0;
    $517 = ((($483)) + 1720|0);
    $518 = HEAP32[$517>>2]|0;
    $519 = (($516) + -1)|0;
    $520 = (($519) + ($518))|0;
    $521 = (+($520|0));
    $522 = $521 * $505;
    $523 = $514 / $522;
    $524 = (~~(($523)));
    $525 = ($524|0)>(8);
    $526 = $524&255;
    $527 = $525 ? 8 : $526;
    $storemerge$i$i = $527;
   } else {
    $storemerge$i$i = 0;
   }
   HEAP8[$mask_idx_s$i>>0] = $storemerge$i$i;
   $528 = (($485) + -1)|0;
   $529 = ($528|0)>(1);
   $530 = +HEAPF32[$$pre37$i>>2];
   $531 = $530 + $507;
   if ($529) {
    $532 = ($528|0)>(2);
    $537 = $531;$540 = 0;$569 = $530;$b$02$i$i = 1;
    while(1) {
     $533 = (($b$02$i$i) + 1)|0;
     $534 = (($avg$i) + ($533<<2)|0);
     $535 = +HEAPF32[$534>>2];
     $536 = $535 + $537;
     $538 = $536 > 0.0;
     if ($538) {
      $539 = (($thm$i) + ($540<<2)|0);
      $541 = +HEAPF32[$539>>2];
      $542 = (($thm$i) + ($b$02$i$i<<2)|0);
      $543 = +HEAPF32[$542>>2];
      $544 = $541 < $543;
      $m$1$i2$i = $544 ? $543 : $541;
      $545 = (($thm$i) + ($533<<2)|0);
      $546 = +HEAPF32[$545>>2];
      $547 = $m$1$i2$i < $546;
      $m$2$i$i = $547 ? $546 : $m$1$i2$i;
      $548 = $m$2$i$i * 3.0;
      $549 = $548 - $536;
      $550 = $549 * 20.0;
      $551 = (((($483)) + 1716|0) + ($540<<2)|0);
      $552 = HEAP32[$551>>2]|0;
      $553 = (((($483)) + 1716|0) + ($b$02$i$i<<2)|0);
      $554 = HEAP32[$553>>2]|0;
      $555 = (((($483)) + 1716|0) + ($533<<2)|0);
      $556 = HEAP32[$555>>2]|0;
      $557 = (($552) + -1)|0;
      $558 = (($557) + ($554))|0;
      $559 = (($558) + ($556))|0;
      $560 = (+($559|0));
      $561 = $560 * $536;
      $562 = $550 / $561;
      $563 = (~~(($562)));
      $564 = ($563|0)>(8);
      $565 = $563&255;
      $566 = $564 ? 8 : $565;
      $$sink$i$i = $566;
     } else {
      $$sink$i$i = 0;
     }
     $567 = (($mask_idx_s$i) + ($b$02$i$i)|0);
     HEAP8[$567>>0] = $$sink$i$i;
     $568 = $535 + $569;
     $exitcond173 = ($533|0)==($528|0);
     if ($exitcond173) {
      $$lcssa232 = $568;
      break;
     } else {
      $540$phi = $b$02$i$i;$537 = $568;$569 = $535;$b$02$i$i = $533;$540 = $540$phi;
     }
    }
    $smax$i = $532 ? $528 : 2;
    $570 = (($smax$i) + -1)|0;
    $$lcssa$i$i = $570;$$lcssa1$i$i = $$lcssa232;$b$0$lcssa$i$i = $smax$i;
   } else {
    $$lcssa$i$i = 0;$$lcssa1$i$i = $531;$b$0$lcssa$i$i = 1;
   }
   $571 = $$lcssa1$i$i > 0.0;
   if ($571) {
    $572 = (($thm$i) + ($$lcssa$i$i<<2)|0);
    $573 = +HEAPF32[$572>>2];
    $574 = (($thm$i) + ($b$0$lcssa$i$i<<2)|0);
    $575 = +HEAPF32[$574>>2];
    $576 = $573 < $575;
    $m$3$i$i = $576 ? $575 : $573;
    $577 = $m$3$i$i * 2.0;
    $578 = $577 - $$lcssa1$i$i;
    $579 = $578 * 20.0;
    $580 = (((($483)) + 1716|0) + ($$lcssa$i$i<<2)|0);
    $581 = HEAP32[$580>>2]|0;
    $582 = (((($483)) + 1716|0) + ($b$0$lcssa$i$i<<2)|0);
    $583 = HEAP32[$582>>2]|0;
    $584 = (($581) + -1)|0;
    $585 = (($584) + ($583))|0;
    $586 = (+($585|0));
    $587 = $586 * $$lcssa1$i$i;
    $588 = $579 / $587;
    $589 = (~~(($588)));
    $590 = ($589|0)>(8);
    $591 = $589&255;
    $592 = $590 ? 8 : $591;
    $$sink7$i$i = $592;
   } else {
    $$sink7$i$i = 0;
   }
   $593 = (($mask_idx_s$i) + ($b$0$lcssa$i$i)|0);
   HEAP8[$593>>0] = $$sink7$i$i;
   if ($486) {
    $594 = ((($483)) + 2156|0);
    $595 = (((($gfc)) + 27796|0) + ($423<<2)|0);
    $b$019$i = 0;$k$020$i = 0;
    while(1) {
     $599 = (($483) + ($b$019$i<<2)|0);
     $600 = +HEAPF32[$599>>2];
     $601 = +HEAPF32[$421>>2];
     $602 = $601 * $600;
     $603 = (((($483)) + 1204|0) + ($b$019$i<<3)|0);
     $604 = HEAP32[$603>>2]|0;
     $605 = (((((($483)) + 1204|0) + ($b$019$i<<3)|0)) + 4|0);
     $606 = HEAP32[$605>>2]|0;
     $607 = (($mask_idx_s$i) + ($b$019$i)|0);
     $608 = HEAP8[$607>>0]|0;
     $609 = $608&255;
     $610 = (11448 + ($609<<2)|0);
     $611 = HEAP32[$610>>2]|0;
     $612 = (($mask_idx_s$i) + ($604)|0);
     $613 = HEAP8[$612>>0]|0;
     $614 = $613&255;
     $615 = HEAP32[$594>>2]|0;
     $616 = (($615) + ($k$020$i<<2)|0);
     $617 = +HEAPF32[$616>>2];
     $618 = ((($eb) + ($chn$0136<<8)|0) + ($604<<2)|0);
     $619 = +HEAPF32[$618>>2];
     $620 = $619 * $617;
     $621 = (11488 + ($614<<2)|0);
     $622 = +HEAPF32[$621>>2];
     $623 = $620 * $622;
     $k$17$i = (($k$020$i) + 1)|0;
     $624 = ($604|0)<($606|0);
     if ($624) {
      $630 = $615;$dd$010$i = $614;$ecb$09$i = $623;$k$112$i = $k$17$i;$kk$013$in$i = $604;
      while(1) {
       $kk$013$i = (($kk$013$in$i) + 1)|0;
       $625 = (($mask_idx_s$i) + ($kk$013$i)|0);
       $626 = HEAP8[$625>>0]|0;
       $627 = $626&255;
       $628 = (($627) + ($dd$010$i))|0;
       $629 = (($630) + ($k$112$i<<2)|0);
       $631 = +HEAPF32[$629>>2];
       $632 = ((($eb) + ($chn$0136<<8)|0) + ($kk$013$i<<2)|0);
       $633 = +HEAPF32[$632>>2];
       $634 = $633 * $631;
       $635 = (11488 + ($627<<2)|0);
       $636 = +HEAPF32[$635>>2];
       $637 = $634 * $636;
       $638 = (($kk$013$i) - ($b$019$i))|0;
       $639 = $ecb$09$i < 0.0;
       $$01$i$i = $639 ? 0.0 : $ecb$09$i;
       $640 = $637 < 0.0;
       $$02$i$i = $640 ? 0.0 : $637;
       $641 = !($$01$i$i <= 0.0);
       do {
        if ($641) {
         $642 = !($$02$i$i <= 0.0);
         if (!($642)) {
          $ecb$0$be$i = $$01$i$i;
          break;
         }
         $643 = $$02$i$i > $$01$i$i;
         $644 = $$02$i$i / $$01$i$i;
         $645 = $$01$i$i / $$02$i$i;
         $ratio$0$i$i = $643 ? $644 : $645;
         $ispos$i$i = ($638|0)>(-1);
         $neg$i$i = (0 - ($638))|0;
         $646 = $ispos$i$i ? $638 : $neg$i$i;
         $647 = ($646|0)>($611|0);
         if ($647) {
          $659 = +HEAPF32[11576>>2];
          $660 = $ratio$0$i$i < $659;
          if ($660) {
           $661 = $$02$i$i + $$01$i$i;
           $ecb$0$be$i = $661;
           break;
          } else {
           $$1$i$i = $643 ? $$02$i$i : $$01$i$i;
           $ecb$0$be$i = $$1$i$i;
           break;
          }
         } else {
          $648 = +HEAPF32[11528>>2];
          $649 = !($ratio$0$i$i >= $648);
          if ($649) {
           $651 = (+_fast_log2($ratio$0$i$i));
           $652 = $651;
           $653 = $652 * 4.8164799306236983;
           $654 = (~~(($653)));
           $655 = $$02$i$i + $$01$i$i;
           $656 = (11536 + ($654<<2)|0);
           $657 = +HEAPF32[$656>>2];
           $658 = $657 * $655;
           $ecb$0$be$i = $658;
           break;
          } else {
           $650 = $$02$i$i + $$01$i$i;
           $ecb$0$be$i = $650;
           break;
          }
         }
        } else {
         $ecb$0$be$i = $$02$i$i;
        }
       } while(0);
       $exitcond31$i = ($kk$013$i|0)==($606|0);
       if ($exitcond31$i) {
        $$lcssa233 = $628;$ecb$0$be$i$lcssa = $ecb$0$be$i;
        break;
       }
       $k$1$i = (($k$112$i) + 1)|0;
       $$pre35$i = HEAP32[$594>>2]|0;
       $630 = $$pre35$i;$dd$010$i = $628;$ecb$09$i = $ecb$0$be$i;$k$112$i = $k$1$i;$kk$013$in$i = $kk$013$i;
      }
      $662 = (($k$17$i) - ($604))|0;
      $663 = (($662) + ($606))|0;
      $664 = (1 - ($604))|0;
      $665 = (($664) + ($606))|0;
      $dd$0$lcssa$i = $$lcssa233;$dd_n$0$lcssa$i = $665;$ecb$0$lcssa$i = $ecb$0$be$i$lcssa;$k$1$lcssa$i = $663;
     } else {
      $dd$0$lcssa$i = $614;$dd_n$0$lcssa$i = 1;$ecb$0$lcssa$i = $623;$k$1$lcssa$i = $k$17$i;
     }
     $666 = $dd$0$lcssa$i << 1;
     $667 = $666 | 1;
     $668 = $dd_n$0$lcssa$i << 1;
     $669 = (($667|0) / ($668|0))&-1;
     $670 = (11488 + ($669<<2)|0);
     $671 = +HEAPF32[$670>>2];
     $672 = $671 * 0.5;
     $673 = $672 * $ecb$0$lcssa$i;
     $674 = HEAP32[$595>>2]|0;
     $675 = ($674|0)==(2);
     do {
      if ($675) {
       $676 = ((((($gfc)) + 21564|0) + ($chn$0136<<8)|0) + ($b$019$i<<2)|0);
       $677 = +HEAPF32[$676>>2];
       $678 = $677 * 2.0;
       $679 = $678 > 0.0;
       if ($679) {
        $680 = $673 < $678;
        $681 = $680 ? $673 : $678;
        $682 = ((($thr) + ($chn$0136<<8)|0) + ($b$019$i<<2)|0);
        HEAPF32[$682>>2] = $681;
        $$pre$phi$iZ2D = $676;$$pre$phi36$iZ2D = $682;$714 = $681;
        break;
       } else {
        $683 = $673;
        $684 = ((($eb) + ($chn$0136<<8)|0) + ($b$019$i<<2)|0);
        $685 = +HEAPF32[$684>>2];
        $686 = $685;
        $687 = $686 * 0.29999999999999999;
        $688 = $683 < $687;
        $$$i = $688 ? $683 : $687;
        $689 = $$$i;
        $690 = ((($thr) + ($chn$0136<<8)|0) + ($b$019$i<<2)|0);
        HEAPF32[$690>>2] = $689;
        $$pre$phi$iZ2D = $676;$$pre$phi36$iZ2D = $690;$714 = $689;
        break;
       }
      } else {
       $691 = ((((($gfc)) + 22588|0) + ($chn$0136<<8)|0) + ($b$019$i<<2)|0);
       $692 = +HEAPF32[$691>>2];
       $693 = $692 * 16.0;
       $694 = ((((($gfc)) + 21564|0) + ($chn$0136<<8)|0) + ($b$019$i<<2)|0);
       $695 = +HEAPF32[$694>>2];
       $696 = $695 * 2.0;
       $697 = !($693 <= 0.0);
       $ecb_limit_2$0$i = $697 ? $693 : $673;
       $698 = !($696 <= 0.0);
       $ecb_limit_1$0$i = $698 ? $696 : $673;
       $699 = ($674|0)==(0);
       $700 = $ecb_limit_1$0$i < $ecb_limit_2$0$i;
       $701 = $700 ? $ecb_limit_1$0$i : $ecb_limit_2$0$i;
       $ecb_limit1$0$i = $699 ? $701 : $ecb_limit_1$0$i;
       $702 = $673 < $ecb_limit1$0$i;
       $703 = $702 ? $673 : $ecb_limit1$0$i;
       $704 = ((($thr) + ($chn$0136<<8)|0) + ($b$019$i<<2)|0);
       HEAPF32[$704>>2] = $703;
       $$pre$phi$iZ2D = $694;$$pre$phi36$iZ2D = $704;$714 = $703;
      }
     } while(0);
     $705 = HEAP32[$$pre$phi$iZ2D>>2]|0;
     $706 = ((((($gfc)) + 22588|0) + ($chn$0136<<8)|0) + ($b$019$i<<2)|0);
     HEAP32[$706>>2] = $705;
     HEAPF32[$$pre$phi$iZ2D>>2] = $673;
     $707 = (($thm$i) + ($b$019$i<<2)|0);
     $708 = +HEAPF32[$707>>2];
     $709 = (((($483)) + 256|0) + ($b$019$i<<2)|0);
     $710 = +HEAPF32[$709>>2];
     $711 = $708 * $672;
     $712 = $711 * $710;
     $713 = $714 > $712;
     if ($713) {
      HEAPF32[$$pre$phi36$iZ2D>>2] = $712;
      $717 = $712;
     } else {
      $717 = $714;
     }
     $715 = $602 > 1.0;
     if ($715) {
      $716 = $717 * $602;
      HEAPF32[$$pre$phi36$iZ2D>>2] = $716;
      $721 = $716;
     } else {
      $721 = $717;
     }
     $718 = ((($eb) + ($chn$0136<<8)|0) + ($b$019$i<<2)|0);
     $719 = +HEAPF32[$718>>2];
     $720 = $721 > $719;
     if ($720) {
      HEAPF32[$$pre$phi36$iZ2D>>2] = $719;
      $724 = $719;
     } else {
      $724 = $721;
     }
     $722 = $602 < 1.0;
     if ($722) {
      $723 = $724 * $602;
      HEAPF32[$$pre$phi36$iZ2D>>2] = $723;
     }
     $725 = (($b$019$i) + 1)|0;
     $726 = HEAP32[$484>>2]|0;
     $727 = ($725|0)<($726|0);
     if ($727) {
      $b$019$i = $725;$k$020$i = $k$1$lcssa$i;
     } else {
      $$lcssa234 = $725;
      break;
     }
    }
    $596 = ($$lcssa234|0)<(64);
    if ($596) {
     $b$16$i$ph = $$lcssa234;
     label = 114;
    }
   } else {
    $b$16$i$ph = 0;
    label = 114;
   }
   if ((label|0) == 114) {
    label = 0;
    $scevgep175 = ((($eb) + ($chn$0136<<8)|0) + ($b$16$i$ph<<2)|0);
    $597 = $b$16$i$ph << 2;
    $598 = (256 - ($597))|0;
    _memset(($scevgep175|0),0,($598|0))|0;
    $scevgep178 = ((($thr) + ($chn$0136<<8)|0) + ($b$16$i$ph<<2)|0);
    _memset(($scevgep178|0),0,($598|0))|0;
   }
   $728 = (($chn$0136) + 1)|0;
   $exitcond180 = ($728|0)==($417|0);
   if ($exitcond180) {
    break;
   } else {
    $chn$0136 = $728;
   }
  }
 }
 $729 = HEAP32[$17>>2]|0;
 $730 = ($729|0)==(1);
 if ($730) {
  $731 = HEAP32[$uselongblock>>2]|0;
  $732 = ((($uselongblock)) + 4|0);
  $733 = HEAP32[$732>>2]|0;
  $734 = (($733) + ($731))|0;
  $735 = ($734|0)==(2);
  if ($735) {
   $736 = ((($1)) + 768|0);
   $737 = ((($gfc)) + 85796|0);
   $738 = HEAP32[$737>>2]|0;
   $739 = ((($738)) + 212|0);
   $740 = +HEAPF32[$7>>2];
   $741 = ((($1)) + 2148|0);
   $742 = HEAP32[$741>>2]|0;
   _vbrpsy_compute_MS_thresholds($eb,$thr,$736,$739,$743,$740,$742);
  }
 }
 if ($418) {
  $chn$1133 = 0;
  while(1) {
   $744 = (($eb) + ($chn$1133<<8)|0);
   $745 = (($thr) + ($chn$1133<<8)|0);
   $746 = HEAP32[$0>>2]|0;
   $747 = (((($gfc)) + 26636|0) + (($chn$1133*244)|0)|0);
   $748 = (((($gfc)) + 25660|0) + (($chn$1133*244)|0)|0);
   _convert_partition2scalefac($746,$744,$745,$747,$748);
   $749 = HEAP32[$0>>2]|0;
   $750 = ((($749)) + 4320|0);
   _convert_partition2scalefac($750,$744,$745,$mask_idx_s$i,$thm$i);
   $sb$02$i = 0;
   while(1) {
    $751 = (($mask_idx_s$i) + ($sb$02$i<<2)|0);
    $752 = HEAP32[$751>>2]|0;
    $753 = (($thm$i) + ($sb$02$i<<2)|0);
    $754 = +HEAPF32[$753>>2];
    $755 = $754 * 0.015625;
    $756 = ((((((($gfc)) + 26636|0) + (($chn$1133*244)|0)|0)) + 88|0) + (($sb$02$i*12)|0)|0);
    HEAP32[$756>>2] = $752;
    $757 = ((((((($gfc)) + 25660|0) + (($chn$1133*244)|0)|0)) + 88|0) + (($sb$02$i*12)|0)|0);
    HEAPF32[$757>>2] = $755;
    $758 = ((((((((($gfc)) + 26636|0) + (($chn$1133*244)|0)|0)) + 88|0) + (($sb$02$i*12)|0)|0)) + 4|0);
    HEAP32[$758>>2] = $752;
    $759 = ((((((((($gfc)) + 25660|0) + (($chn$1133*244)|0)|0)) + 88|0) + (($sb$02$i*12)|0)|0)) + 4|0);
    HEAPF32[$759>>2] = $755;
    $760 = ((((((((($gfc)) + 26636|0) + (($chn$1133*244)|0)|0)) + 88|0) + (($sb$02$i*12)|0)|0)) + 8|0);
    HEAP32[$760>>2] = $752;
    $761 = ((((((((($gfc)) + 25660|0) + (($chn$1133*244)|0)|0)) + 88|0) + (($sb$02$i*12)|0)|0)) + 8|0);
    HEAPF32[$761>>2] = $755;
    $762 = (($sb$02$i) + 1)|0;
    $exitcond$i17 = ($762|0)==(13);
    if ($exitcond$i17) {
     break;
    } else {
     $sb$02$i = $762;
    }
   }
   $763 = (($chn$1133) + 1)|0;
   $exitcond170 = ($763|0)==($417|0);
   if ($exitcond170) {
    break;
   } else {
    $chn$1133 = $763;
   }
  }
 }
 $764 = HEAP32[$0>>2]|0;
 $765 = ((($764)) + 6500|0);
 $766 = HEAP32[$765>>2]|0;
 $767 = HEAP32[$uselongblock>>2]|0;
 $768 = ((($uselongblock)) + 4|0);
 $769 = HEAP32[$768>>2]|0;
 $770 = (0 - ($769))|0;
 $771 = ((($1)) + 2928|0);
 $772 = ((($gfc)) + 85796|0);
 $773 = ((($1)) + 4308|0);
 $774 = ($766|0)!=(0);
 $775 = ((($mask_idx_s$i)) + 4|0);
 $776 = ((($thm$i)) + 4|0);
 $777 = ((($mask_idx_s$i)) + 8|0);
 $778 = ((($thm$i)) + 8|0);
 $779 = ((($mask_idx_s$i)) + 12|0);
 $780 = ((($thm$i)) + 12|0);
 $781 = ((($mask_idx_s$i)) + 16|0);
 $782 = ((($thm$i)) + 16|0);
 $783 = ((($mask_idx_s$i)) + 20|0);
 $784 = ((($thm$i)) + 20|0);
 $785 = ((($mask_idx_s$i)) + 24|0);
 $786 = ((($thm$i)) + 24|0);
 $787 = ((($mask_idx_s$i)) + 28|0);
 $788 = ((($thm$i)) + 28|0);
 $789 = ((($mask_idx_s$i)) + 32|0);
 $790 = ((($thm$i)) + 32|0);
 $791 = ((($mask_idx_s$i)) + 36|0);
 $792 = ((($thm$i)) + 36|0);
 $793 = ((($mask_idx_s$i)) + 40|0);
 $794 = ((($thm$i)) + 40|0);
 $795 = ((($mask_idx_s$i)) + 44|0);
 $796 = ((($thm$i)) + 44|0);
 $797 = ((($mask_idx_s$i)) + 48|0);
 $798 = ((($thm$i)) + 48|0);
 $799 = ((($thm$i)) + 4|0);
 $800 = ((($gfc)) + 84908|0);
 $$pre52$i = ((($avg$i)) + 4|0);
 $$not203 = ($767|0)!=($770|0);
 $sblock$0130 = 0;
 while(1) {
  if ($418) {
   $801 = ($sblock$0130|0)==(0);
   $802 = (($fftenergy_s) + (($sblock$0130*516)|0)|0);
   $chn$2120 = 0;
   while(1) {
    $803 = $chn$2120 & 1;
    $804 = (($uselongblock) + ($803<<2)|0);
    $805 = HEAP32[$804>>2]|0;
    $806 = ($805|0)==(0);
    $or$cond = $774 | $806;
    if ($or$cond) {
     $815 = ($chn$2120|0)<(2);
     $or$cond$i20 = $801 & $815;
     if ($or$cond$i20) {
      $816 = (($wsamp_S) + (($803*3072)|0)|0);
      _fft_short($gfc,$816,$chn$2120,$buffer);
     }
     $817 = ($chn$2120|0)==(2);
     if ($817) {
      $$sum = (($803) + 1)|0;
      $j$03$i = 255;
      while(1) {
       $818 = (((($wsamp_S) + (($803*3072)|0)|0) + ($sblock$0130<<10)|0) + ($j$03$i<<2)|0);
       $819 = +HEAPF32[$818>>2];
       $820 = (((($wsamp_S) + (($$sum*3072)|0)|0) + ($sblock$0130<<10)|0) + ($j$03$i<<2)|0);
       $821 = +HEAPF32[$820>>2];
       $822 = $821 + $819;
       $823 = $822 * 0.70710676908493042;
       HEAPF32[$818>>2] = $823;
       $824 = $819 - $821;
       $825 = $824 * 0.70710676908493042;
       HEAPF32[$820>>2] = $825;
       $826 = (($j$03$i) + -1)|0;
       $827 = ($j$03$i|0)>(0);
       if ($827) {
        $j$03$i = $826;
       } else {
        break;
       }
      }
     }
     $828 = ((($wsamp_S) + (($803*3072)|0)|0) + ($sblock$0130<<10)|0);
     $829 = +HEAPF32[$828>>2];
     $830 = $829 * $829;
     HEAPF32[$802>>2] = $830;
     $j$12$i = 127;
     while(1) {
      $831 = (128 - ($j$12$i))|0;
      $832 = (((($wsamp_S) + (($803*3072)|0)|0) + ($sblock$0130<<10)|0) + ($831<<2)|0);
      $833 = +HEAPF32[$832>>2];
      $834 = (($j$12$i) + 128)|0;
      $835 = (((($wsamp_S) + (($803*3072)|0)|0) + ($sblock$0130<<10)|0) + ($834<<2)|0);
      $836 = +HEAPF32[$835>>2];
      $837 = $833 * $833;
      $838 = $836 * $836;
      $839 = $838 + $837;
      $840 = $839 * 0.5;
      $841 = ((($fftenergy_s) + (($sblock$0130*516)|0)|0) + ($831<<2)|0);
      HEAPF32[$841>>2] = $840;
      $842 = (($j$12$i) + -1)|0;
      $843 = ($j$12$i|0)>(0);
      if ($843) {
       $j$12$i = $842;
      } else {
       break;
      }
     }
     $844 = HEAP32[$0>>2]|0;
     _memset(($thm$i|0),0,256)|0;
     _memset(($avg$i|0),0,256)|0;
     $845 = ((($844)) + 4308|0);
     $846 = HEAP32[$845>>2]|0;
     $847 = ($846|0)>(0);
     if ($847) {
      $b$030$i = 0;$j$031$i = 0;
      while(1) {
       $848 = (((($844)) + 3876|0) + ($b$030$i<<2)|0);
       $849 = HEAP32[$848>>2]|0;
       $850 = ($849|0)>(0);
       if ($850) {
        $ebb$021$i = 0.0;$i$023$i = 0;$j$122$i = $j$031$i;$m$020$i = 0.0;
        while(1) {
         $851 = ((($fftenergy_s) + (($sblock$0130*516)|0)|0) + ($j$122$i<<2)|0);
         $852 = +HEAPF32[$851>>2];
         $853 = $852 + $ebb$021$i;
         $854 = $m$020$i < $852;
         $m$1$i = $854 ? $852 : $m$020$i;
         $855 = (($i$023$i) + 1)|0;
         $856 = (($j$122$i) + 1)|0;
         $exitcond46$i25 = ($855|0)==($849|0);
         if ($exitcond46$i25) {
          $$lcssa = $853;$m$1$i$lcssa = $m$1$i;
          break;
         } else {
          $ebb$021$i = $853;$i$023$i = $855;$j$122$i = $856;$m$020$i = $m$1$i;
         }
        }
        $857 = (($849) + ($j$031$i))|0;
        $ebb$0$lcssa$i = $$lcssa;$j$1$lcssa$i = $857;$m$0$lcssa$i = $m$1$i$lcssa;
       } else {
        $ebb$0$lcssa$i = 0.0;$j$1$lcssa$i = $j$031$i;$m$0$lcssa$i = 0.0;
       }
       $858 = ((($eb) + ($chn$2120<<8)|0) + ($b$030$i<<2)|0);
       HEAPF32[$858>>2] = $ebb$0$lcssa$i;
       $859 = (($thm$i) + ($b$030$i<<2)|0);
       HEAPF32[$859>>2] = $m$0$lcssa$i;
       $860 = (((($844)) + 2672|0) + ($b$030$i<<2)|0);
       $861 = +HEAPF32[$860>>2];
       $862 = $861 * $ebb$0$lcssa$i;
       $863 = (($avg$i) + ($b$030$i<<2)|0);
       HEAPF32[$863>>2] = $862;
       $864 = (($b$030$i) + 1)|0;
       $exitcond159 = ($864|0)==($846|0);
       if ($exitcond159) {
        break;
       } else {
        $b$030$i = $864;$j$031$i = $j$1$lcssa$i;
       }
      }
      $$pre$i27 = +HEAPF32[$avg$i>>2];
      $$pre48$i = +HEAPF32[$$pre52$i>>2];
      $866 = $$pre48$i;$867 = $$pre$i27;
     } else {
      $866 = 0.0;$867 = 0.0;
     }
     $865 = $867 + $866;
     $868 = $865 > 0.0;
     if ($868) {
      $869 = +HEAPF32[$thm$i>>2];
      $870 = +HEAPF32[$799>>2];
      $871 = $869 < $870;
      $m$0$i$i29 = $871 ? $870 : $869;
      $872 = $m$0$i$i29 * 2.0;
      $873 = $872 - $865;
      $874 = $873 * 20.0;
      $875 = ((($844)) + 3876|0);
      $876 = HEAP32[$875>>2]|0;
      $877 = ((($844)) + 3880|0);
      $878 = HEAP32[$877>>2]|0;
      $879 = (($876) + -1)|0;
      $880 = (($879) + ($878))|0;
      $881 = (+($880|0));
      $882 = $881 * $865;
      $883 = $874 / $882;
      $884 = (~~(($883)));
      $885 = ($884|0)>(8);
      $886 = $884&255;
      $887 = $885 ? 8 : $886;
      $storemerge$i$i30 = $887;
     } else {
      $storemerge$i$i30 = 0;
     }
     HEAP8[$mask_idx_s$i>>0] = $storemerge$i$i30;
     $888 = (($846) + -1)|0;
     $889 = ($888|0)>(1);
     $890 = $866 + $867;
     if ($889) {
      $891 = ($888|0)>(2);
      $896 = $890;$899 = 0;$928 = $866;$b$02$i$i32 = 1;
      while(1) {
       $892 = (($b$02$i$i32) + 1)|0;
       $893 = (($avg$i) + ($892<<2)|0);
       $894 = +HEAPF32[$893>>2];
       $895 = $894 + $896;
       $897 = $895 > 0.0;
       if ($897) {
        $898 = (($thm$i) + ($899<<2)|0);
        $900 = +HEAPF32[$898>>2];
        $901 = (($thm$i) + ($b$02$i$i32<<2)|0);
        $902 = +HEAPF32[$901>>2];
        $903 = $900 < $902;
        $m$1$i$i34 = $903 ? $902 : $900;
        $904 = (($thm$i) + ($892<<2)|0);
        $905 = +HEAPF32[$904>>2];
        $906 = $m$1$i$i34 < $905;
        $m$2$i$i35 = $906 ? $905 : $m$1$i$i34;
        $907 = $m$2$i$i35 * 3.0;
        $908 = $907 - $895;
        $909 = $908 * 20.0;
        $910 = (((($844)) + 3876|0) + ($899<<2)|0);
        $911 = HEAP32[$910>>2]|0;
        $912 = (((($844)) + 3876|0) + ($b$02$i$i32<<2)|0);
        $913 = HEAP32[$912>>2]|0;
        $914 = (((($844)) + 3876|0) + ($892<<2)|0);
        $915 = HEAP32[$914>>2]|0;
        $916 = (($911) + -1)|0;
        $917 = (($916) + ($913))|0;
        $918 = (($917) + ($915))|0;
        $919 = (+($918|0));
        $920 = $919 * $895;
        $921 = $909 / $920;
        $922 = (~~(($921)));
        $923 = ($922|0)>(8);
        $924 = $922&255;
        $925 = $923 ? 8 : $924;
        $$sink$i$i36 = $925;
       } else {
        $$sink$i$i36 = 0;
       }
       $926 = (($mask_idx_s$i) + ($b$02$i$i32)|0);
       HEAP8[$926>>0] = $$sink$i$i36;
       $927 = $894 + $928;
       $exitcond160 = ($892|0)==($888|0);
       if ($exitcond160) {
        $$lcssa226 = $927;
        break;
       } else {
        $899$phi = $b$02$i$i32;$896 = $927;$928 = $894;$b$02$i$i32 = $892;$899 = $899$phi;
       }
      }
      $smax$i31 = $891 ? $888 : 2;
      $929 = (($smax$i31) + -1)|0;
      $$lcssa$i$i39 = $929;$$lcssa1$i$i38 = $$lcssa226;$b$0$lcssa$i$i40 = $smax$i31;
     } else {
      $$lcssa$i$i39 = 0;$$lcssa1$i$i38 = $890;$b$0$lcssa$i$i40 = 1;
     }
     $930 = $$lcssa1$i$i38 > 0.0;
     if ($930) {
      $931 = (($thm$i) + ($$lcssa$i$i39<<2)|0);
      $932 = +HEAPF32[$931>>2];
      $933 = (($thm$i) + ($b$0$lcssa$i$i40<<2)|0);
      $934 = +HEAPF32[$933>>2];
      $935 = $932 < $934;
      $m$3$i$i42 = $935 ? $934 : $932;
      $936 = $m$3$i$i42 * 2.0;
      $937 = $936 - $$lcssa1$i$i38;
      $938 = $937 * 20.0;
      $939 = (((($844)) + 3876|0) + ($$lcssa$i$i39<<2)|0);
      $940 = HEAP32[$939>>2]|0;
      $941 = (((($844)) + 3876|0) + ($b$0$lcssa$i$i40<<2)|0);
      $942 = HEAP32[$941>>2]|0;
      $943 = (($940) + -1)|0;
      $944 = (($943) + ($942))|0;
      $945 = (+($944|0));
      $946 = $945 * $$lcssa1$i$i38;
      $947 = $938 / $946;
      $948 = (~~(($947)));
      $949 = ($948|0)>(8);
      $950 = $948&255;
      $951 = $949 ? 8 : $950;
      $$sink7$i$i43 = $951;
     } else {
      $$sink7$i$i43 = 0;
     }
     $952 = (($mask_idx_s$i) + ($b$0$lcssa$i$i40)|0);
     HEAP8[$952>>0] = $$sink7$i$i43;
     if ($847) {
      $953 = ((($844)) + 4316|0);
      $b$116$i = 0;$j$217$i = 0;
      while(1) {
       $957 = (((($844)) + 3364|0) + ($b$116$i<<3)|0);
       $958 = HEAP32[$957>>2]|0;
       $959 = (((((($844)) + 3364|0) + ($b$116$i<<3)|0)) + 4|0);
       $960 = HEAP32[$959>>2]|0;
       $961 = (($mask_idx_s$i) + ($b$116$i)|0);
       $962 = HEAP8[$961>>0]|0;
       $963 = $962&255;
       $964 = (11448 + ($963<<2)|0);
       $965 = HEAP32[$964>>2]|0;
       $966 = (((($844)) + 2160|0) + ($b$116$i<<2)|0);
       $967 = +HEAPF32[$966>>2];
       $968 = +HEAPF32[$800>>2];
       $969 = $968 * $967;
       $970 = (($mask_idx_s$i) + ($958)|0);
       $971 = HEAP8[$970>>0]|0;
       $972 = $971&255;
       $973 = HEAP32[$953>>2]|0;
       $974 = (($973) + ($j$217$i<<2)|0);
       $975 = +HEAPF32[$974>>2];
       $976 = ((($eb) + ($chn$2120<<8)|0) + ($958<<2)|0);
       $977 = +HEAPF32[$976>>2];
       $978 = $977 * $975;
       $979 = (11488 + ($972<<2)|0);
       $980 = +HEAPF32[$979>>2];
       $981 = $978 * $980;
       $j$34$i45 = (($j$217$i) + 1)|0;
       $982 = ($958|0)<($960|0);
       if ($982) {
        $988 = $973;$dd$06$i = $972;$ecb$08$i = $981;$j$39$i = $j$34$i45;$kk$010$in$i = $958;
        while(1) {
         $kk$010$i = (($kk$010$in$i) + 1)|0;
         $983 = (($mask_idx_s$i) + ($kk$010$i)|0);
         $984 = HEAP8[$983>>0]|0;
         $985 = $984&255;
         $986 = (($985) + ($dd$06$i))|0;
         $987 = (($988) + ($j$39$i<<2)|0);
         $989 = +HEAPF32[$987>>2];
         $990 = ((($eb) + ($chn$2120<<8)|0) + ($kk$010$i<<2)|0);
         $991 = +HEAPF32[$990>>2];
         $992 = $991 * $989;
         $993 = (11488 + ($985<<2)|0);
         $994 = +HEAPF32[$993>>2];
         $995 = $992 * $994;
         $996 = (($kk$010$i) - ($b$116$i))|0;
         $997 = $ecb$08$i < 0.0;
         $$01$i$i46 = $997 ? 0.0 : $ecb$08$i;
         $998 = $995 < 0.0;
         $$02$i$i47 = $998 ? 0.0 : $995;
         $999 = !($$01$i$i46 <= 0.0);
         do {
          if ($999) {
           $1000 = !($$02$i$i47 <= 0.0);
           if (!($1000)) {
            $ecb$0$be$i48 = $$01$i$i46;
            break;
           }
           $1001 = $$02$i$i47 > $$01$i$i46;
           $1002 = $$02$i$i47 / $$01$i$i46;
           $1003 = $$01$i$i46 / $$02$i$i47;
           $ratio$0$i$i51 = $1001 ? $1002 : $1003;
           $ispos$i$i52 = ($996|0)>(-1);
           $neg$i$i53 = (0 - ($996))|0;
           $1004 = $ispos$i$i52 ? $996 : $neg$i$i53;
           $1005 = ($1004|0)>($965|0);
           if ($1005) {
            $1017 = +HEAPF32[11576>>2];
            $1018 = $ratio$0$i$i51 < $1017;
            if ($1018) {
             $1019 = $$02$i$i47 + $$01$i$i46;
             $ecb$0$be$i48 = $1019;
             break;
            } else {
             $$1$i$i54 = $1001 ? $$02$i$i47 : $$01$i$i46;
             $ecb$0$be$i48 = $$1$i$i54;
             break;
            }
           } else {
            $1006 = +HEAPF32[11528>>2];
            $1007 = !($ratio$0$i$i51 >= $1006);
            if ($1007) {
             $1009 = (+_fast_log2($ratio$0$i$i51));
             $1010 = $1009;
             $1011 = $1010 * 4.8164799306236983;
             $1012 = (~~(($1011)));
             $1013 = $$02$i$i47 + $$01$i$i46;
             $1014 = (11536 + ($1012<<2)|0);
             $1015 = +HEAPF32[$1014>>2];
             $1016 = $1015 * $1013;
             $ecb$0$be$i48 = $1016;
             break;
            } else {
             $1008 = $$02$i$i47 + $$01$i$i46;
             $ecb$0$be$i48 = $1008;
             break;
            }
           }
          } else {
           $ecb$0$be$i48 = $$02$i$i47;
          }
         } while(0);
         $exitcond45$i = ($kk$010$i|0)==($960|0);
         if ($exitcond45$i) {
          $$lcssa227 = $986;$ecb$0$be$i48$lcssa = $ecb$0$be$i48;
          break;
         }
         $j$3$i = (($j$39$i) + 1)|0;
         $$pre49$i = HEAP32[$953>>2]|0;
         $988 = $$pre49$i;$dd$06$i = $986;$ecb$08$i = $ecb$0$be$i48;$j$39$i = $j$3$i;$kk$010$in$i = $kk$010$i;
        }
        $1020 = (($j$34$i45) - ($958))|0;
        $1021 = (($1020) + ($960))|0;
        $1022 = (1 - ($958))|0;
        $1023 = (($1022) + ($960))|0;
        $dd$0$lcssa$i58 = $$lcssa227;$dd_n$0$lcssa$i57 = $1023;$ecb$0$lcssa$i56 = $ecb$0$be$i48$lcssa;$j$3$lcssa$i = $1021;
       } else {
        $dd$0$lcssa$i58 = $972;$dd_n$0$lcssa$i57 = 1;$ecb$0$lcssa$i56 = $981;$j$3$lcssa$i = $j$34$i45;
       }
       $1024 = $dd$0$lcssa$i58 << 1;
       $1025 = $1024 | 1;
       $1026 = $dd_n$0$lcssa$i57 << 1;
       $1027 = (($1025|0) / ($1026|0))&-1;
       $1028 = (11488 + ($1027<<2)|0);
       $1029 = +HEAPF32[$1028>>2];
       $1030 = $1029 * 0.5;
       $1031 = $1030 * $ecb$0$lcssa$i56;
       $1032 = ((($thr) + ($chn$2120<<8)|0) + ($b$116$i<<2)|0);
       HEAPF32[$1032>>2] = $1031;
       $1033 = ((((($gfc)) + 23612|0) + ($chn$2120<<8)|0) + ($b$116$i<<2)|0);
       $1034 = HEAP32[$1033>>2]|0;
       $1035 = ((((($gfc)) + 24636|0) + ($chn$2120<<8)|0) + ($b$116$i<<2)|0);
       HEAP32[$1035>>2] = $1034;
       HEAPF32[$1033>>2] = $1031;
       $1036 = (($thm$i) + ($b$116$i<<2)|0);
       $1037 = +HEAPF32[$1036>>2];
       $1038 = (((($844)) + 2416|0) + ($b$116$i<<2)|0);
       $1039 = +HEAPF32[$1038>>2];
       $1040 = $1037 * $1030;
       $1041 = $1040 * $1039;
       $1042 = $1031 > $1041;
       if ($1042) {
        HEAPF32[$1032>>2] = $1041;
        $1045 = $1041;
       } else {
        $1045 = $1031;
       }
       $1043 = $969 > 1.0;
       if ($1043) {
        $1044 = $1045 * $969;
        HEAPF32[$1032>>2] = $1044;
        $1049 = $1044;
       } else {
        $1049 = $1045;
       }
       $1046 = ((($eb) + ($chn$2120<<8)|0) + ($b$116$i<<2)|0);
       $1047 = +HEAPF32[$1046>>2];
       $1048 = $1049 > $1047;
       if ($1048) {
        HEAPF32[$1032>>2] = $1047;
        $1052 = $1047;
       } else {
        $1052 = $1049;
       }
       $1050 = $969 < 1.0;
       if ($1050) {
        $1051 = $1052 * $969;
        HEAPF32[$1032>>2] = $1051;
       }
       $1053 = (($b$116$i) + 1)|0;
       $1054 = HEAP32[$845>>2]|0;
       $1055 = ($1053|0)<($1054|0);
       if ($1055) {
        $b$116$i = $1053;$j$217$i = $j$3$lcssa$i;
       } else {
        $$lcssa228 = $1053;
        break;
       }
      }
      $954 = ($$lcssa228|0)<(64);
      if ($954) {
       $b$23$i$ph = $$lcssa228;
       label = 185;
      }
     } else {
      $b$23$i$ph = 0;
      label = 185;
     }
     if ((label|0) == 185) {
      label = 0;
      $scevgep162 = ((($eb) + ($chn$2120<<8)|0) + ($b$23$i$ph<<2)|0);
      $955 = $b$23$i$ph << 2;
      $956 = (256 - ($955))|0;
      _memset(($scevgep162|0),0,($956|0))|0;
      $scevgep165 = ((($thr) + ($chn$2120<<8)|0) + ($b$23$i$ph<<2)|0);
      _memset(($scevgep165|0),0,($956|0))|0;
     }
    } else {
     if ($801) {
      $807 = HEAP32[$0>>2]|0;
      $808 = ((($807)) + 4308|0);
      $809 = HEAP32[$808>>2]|0;
      $810 = ($809|0)>(0);
      if ($810) {
       $b$01$i = 0;
       while(1) {
        $811 = ((((($gfc)) + 23612|0) + ($chn$2120<<8)|0) + ($b$01$i<<2)|0);
        $812 = HEAP32[$811>>2]|0;
        $813 = ((((($gfc)) + 24636|0) + ($chn$2120<<8)|0) + ($b$01$i<<2)|0);
        HEAP32[$813>>2] = $812;
        $814 = (($b$01$i) + 1)|0;
        $exitcond$i18 = ($814|0)==($809|0);
        if ($exitcond$i18) {
         break;
        } else {
         $b$01$i = $814;
        }
       }
      }
     }
    }
    $1056 = (($chn$2120) + 1)|0;
    $exitcond167 = ($1056|0)==($417|0);
    if ($exitcond167) {
     break;
    } else {
     $chn$2120 = $1056;
    }
   }
  }
  $1057 = HEAP32[$17>>2]|0;
  $$not = ($1057|0)!=(1);
  $brmerge = $$not | $$not203;
  if (!($brmerge)) {
   $1058 = HEAP32[$772>>2]|0;
   $1059 = ((($1058)) + 468|0);
   $1060 = +HEAPF32[$7>>2];
   $1061 = HEAP32[$773>>2]|0;
   _vbrpsy_compute_MS_thresholds($eb,$thr,$771,$1059,$743,$1060,$1061);
  }
  if ($418) {
   $chn$3127 = 0;
   while(1) {
    $1062 = $chn$3127 & 1;
    $1063 = (($uselongblock) + ($1062<<2)|0);
    $1064 = HEAP32[$1063>>2]|0;
    $1065 = ($1064|0)==(0);
    $or$cond3 = $774 | $1065;
    if ($or$cond3) {
     $1066 = (($eb) + ($chn$3127<<8)|0);
     $1067 = (($thr) + ($chn$3127<<8)|0);
     $1068 = HEAP32[$0>>2]|0;
     $1069 = ((($1068)) + 2160|0);
     _convert_partition2scalefac($1069,$1066,$1067,$mask_idx_s$i,$thm$i);
     $1070 = HEAP32[$mask_idx_s$i>>2]|0;
     $1071 = ((((((($gfc)) + 26636|0) + (($chn$3127*244)|0)|0)) + 88|0) + ($sblock$0130<<2)|0);
     HEAP32[$1071>>2] = $1070;
     $1072 = HEAP32[$thm$i>>2]|0;
     $1073 = ((((((($gfc)) + 25660|0) + (($chn$3127*244)|0)|0)) + 88|0) + ($sblock$0130<<2)|0);
     HEAP32[$1073>>2] = $1072;
     $1074 = HEAP32[$775>>2]|0;
     $1075 = ((((((($gfc)) + 26636|0) + (($chn$3127*244)|0)|0)) + 100|0) + ($sblock$0130<<2)|0);
     HEAP32[$1075>>2] = $1074;
     $1076 = HEAP32[$776>>2]|0;
     $1077 = ((((((($gfc)) + 25660|0) + (($chn$3127*244)|0)|0)) + 100|0) + ($sblock$0130<<2)|0);
     HEAP32[$1077>>2] = $1076;
     $1078 = HEAP32[$777>>2]|0;
     $1079 = ((((((($gfc)) + 26636|0) + (($chn$3127*244)|0)|0)) + 112|0) + ($sblock$0130<<2)|0);
     HEAP32[$1079>>2] = $1078;
     $1080 = HEAP32[$778>>2]|0;
     $1081 = ((((((($gfc)) + 25660|0) + (($chn$3127*244)|0)|0)) + 112|0) + ($sblock$0130<<2)|0);
     HEAP32[$1081>>2] = $1080;
     $1082 = HEAP32[$779>>2]|0;
     $1083 = ((((((($gfc)) + 26636|0) + (($chn$3127*244)|0)|0)) + 124|0) + ($sblock$0130<<2)|0);
     HEAP32[$1083>>2] = $1082;
     $1084 = HEAP32[$780>>2]|0;
     $1085 = ((((((($gfc)) + 25660|0) + (($chn$3127*244)|0)|0)) + 124|0) + ($sblock$0130<<2)|0);
     HEAP32[$1085>>2] = $1084;
     $1086 = HEAP32[$781>>2]|0;
     $1087 = ((((((($gfc)) + 26636|0) + (($chn$3127*244)|0)|0)) + 136|0) + ($sblock$0130<<2)|0);
     HEAP32[$1087>>2] = $1086;
     $1088 = HEAP32[$782>>2]|0;
     $1089 = ((((((($gfc)) + 25660|0) + (($chn$3127*244)|0)|0)) + 136|0) + ($sblock$0130<<2)|0);
     HEAP32[$1089>>2] = $1088;
     $1090 = HEAP32[$783>>2]|0;
     $1091 = ((((((($gfc)) + 26636|0) + (($chn$3127*244)|0)|0)) + 148|0) + ($sblock$0130<<2)|0);
     HEAP32[$1091>>2] = $1090;
     $1092 = HEAP32[$784>>2]|0;
     $1093 = ((((((($gfc)) + 25660|0) + (($chn$3127*244)|0)|0)) + 148|0) + ($sblock$0130<<2)|0);
     HEAP32[$1093>>2] = $1092;
     $1094 = HEAP32[$785>>2]|0;
     $1095 = ((((((($gfc)) + 26636|0) + (($chn$3127*244)|0)|0)) + 160|0) + ($sblock$0130<<2)|0);
     HEAP32[$1095>>2] = $1094;
     $1096 = HEAP32[$786>>2]|0;
     $1097 = ((((((($gfc)) + 25660|0) + (($chn$3127*244)|0)|0)) + 160|0) + ($sblock$0130<<2)|0);
     HEAP32[$1097>>2] = $1096;
     $1098 = HEAP32[$787>>2]|0;
     $1099 = ((((((($gfc)) + 26636|0) + (($chn$3127*244)|0)|0)) + 172|0) + ($sblock$0130<<2)|0);
     HEAP32[$1099>>2] = $1098;
     $1100 = HEAP32[$788>>2]|0;
     $1101 = ((((((($gfc)) + 25660|0) + (($chn$3127*244)|0)|0)) + 172|0) + ($sblock$0130<<2)|0);
     HEAP32[$1101>>2] = $1100;
     $1102 = HEAP32[$789>>2]|0;
     $1103 = ((((((($gfc)) + 26636|0) + (($chn$3127*244)|0)|0)) + 184|0) + ($sblock$0130<<2)|0);
     HEAP32[$1103>>2] = $1102;
     $1104 = HEAP32[$790>>2]|0;
     $1105 = ((((((($gfc)) + 25660|0) + (($chn$3127*244)|0)|0)) + 184|0) + ($sblock$0130<<2)|0);
     HEAP32[$1105>>2] = $1104;
     $1106 = HEAP32[$791>>2]|0;
     $1107 = ((((((($gfc)) + 26636|0) + (($chn$3127*244)|0)|0)) + 196|0) + ($sblock$0130<<2)|0);
     HEAP32[$1107>>2] = $1106;
     $1108 = HEAP32[$792>>2]|0;
     $1109 = ((((((($gfc)) + 25660|0) + (($chn$3127*244)|0)|0)) + 196|0) + ($sblock$0130<<2)|0);
     HEAP32[$1109>>2] = $1108;
     $1110 = HEAP32[$793>>2]|0;
     $1111 = ((((((($gfc)) + 26636|0) + (($chn$3127*244)|0)|0)) + 208|0) + ($sblock$0130<<2)|0);
     HEAP32[$1111>>2] = $1110;
     $1112 = HEAP32[$794>>2]|0;
     $1113 = ((((((($gfc)) + 25660|0) + (($chn$3127*244)|0)|0)) + 208|0) + ($sblock$0130<<2)|0);
     HEAP32[$1113>>2] = $1112;
     $1114 = HEAP32[$795>>2]|0;
     $1115 = ((((((($gfc)) + 26636|0) + (($chn$3127*244)|0)|0)) + 220|0) + ($sblock$0130<<2)|0);
     HEAP32[$1115>>2] = $1114;
     $1116 = HEAP32[$796>>2]|0;
     $1117 = ((((((($gfc)) + 25660|0) + (($chn$3127*244)|0)|0)) + 220|0) + ($sblock$0130<<2)|0);
     HEAP32[$1117>>2] = $1116;
     $1118 = HEAP32[$797>>2]|0;
     $1119 = ((((((($gfc)) + 26636|0) + (($chn$3127*244)|0)|0)) + 232|0) + ($sblock$0130<<2)|0);
     HEAP32[$1119>>2] = $1118;
     $1120 = HEAP32[$798>>2]|0;
     $1121 = ((((((($gfc)) + 25660|0) + (($chn$3127*244)|0)|0)) + 232|0) + ($sblock$0130<<2)|0);
     HEAP32[$1121>>2] = $1120;
    }
    $1122 = (($chn$3127) + 1)|0;
    $exitcond168 = ($1122|0)==($417|0);
    if ($exitcond168) {
     break;
    } else {
     $chn$3127 = $1122;
    }
   }
  }
  $1123 = (($sblock$0130) + 1)|0;
  $exitcond169 = ($1123|0)==(3);
  if ($exitcond169) {
   break;
  } else {
   $sblock$0130 = $1123;
  }
 }
 if ($418) {
  $chn$4119 = 0;
  while(1) {
   $1124 = (((($gfc)) + 27780|0) + ($chn$4119<<2)|0);
   $sb$0118 = 0;
   while(1) {
    $scevgep = ((((((($gfc)) + 25660|0) + (($chn$4119*244)|0)|0)) + 88|0) + (($sb$0118*12)|0)|0);
    $1125 = ((((((($last_thm) + (($chn$4119*244)|0)|0)) + 88|0) + (($sb$0118*12)|0)|0)) + 8|0);
    $1126 = ((((((($last_thm) + (($chn$4119*244)|0)|0)) + 88|0) + (($sb$0118*12)|0)|0)) + 4|0);
    $sblock$1116 = 0;
    while(1) {
     $1128 = (((((((($gfc)) + 25660|0) + (($chn$4119*244)|0)|0)) + 88|0) + (($sb$0118*12)|0)|0) + ($sblock$1116<<2)|0);
     $1129 = +HEAPF32[$1128>>2];
     $1130 = $1129;
     $1131 = $1130 * 0.80000000000000004;
     $1132 = $1131;
     $1133 = ($sblock$1116|0)>(0);
     $1134 = (($sblock$1116) + -1)|0;
     $1135 = (($new_thmm) + ($1134<<2)|0);
     $prev_thm$0$in = $1133 ? $1135 : $1125;
     $prev_thm$0 = +HEAPF32[$prev_thm$0$in>>2];
     $1136 = ((($ns_attacks) + ($chn$4119<<4)|0) + ($sblock$1116<<2)|0);
     $1137 = HEAP32[$1136>>2]|0;
     $1138 = ($1137|0)>(1);
     if ($1138) {
      label = 223;
     } else {
      $1139 = (($sblock$1116) + 1)|0;
      $1140 = ((($ns_attacks) + ($chn$4119<<4)|0) + ($1139<<2)|0);
      $1141 = HEAP32[$1140>>2]|0;
      $1142 = ($1141|0)==(1);
      if ($1142) {
       label = 223;
      } else {
       $t1$0 = $1132;
      }
     }
     if ((label|0) == 223) {
      label = 0;
      $1143 = $1132 > 0.0;
      if ($1143) {
       $1144 = $prev_thm$0 / $1132;
       $1145 = (+Math_pow((+$1144),0.36000001430511475));
       $1146 = $1145 * $1132;
       $t1$0 = $1146;
      } else {
       $t1$0 = 0.0;
      }
     }
     $1147 = $t1$0 < $1132;
     $1148 = $1147 ? $t1$0 : $1132;
     $1149 = ($1137|0)==(1);
     L341: do {
      if ($1149) {
       $1150 = $1148 > 0.0;
       if ($1150) {
        $1151 = $prev_thm$0 / $1148;
        $1152 = (+Math_pow((+$1151),0.18000000715255737));
        $1153 = $1152 * $1148;
        $t2$0 = $1153;
       } else {
        $t2$0 = 0.0;
       }
      } else {
       $1154 = ($sblock$1116|0)==(0);
       if ($1154) {
        $1155 = HEAP32[$1124>>2]|0;
        $1156 = ($1155|0)==(3);
        if ($1156) {
         label = 233;
        } else {
         label = 230;
        }
       } else {
        label = 230;
       }
       do {
        if ((label|0) == 230) {
         label = 0;
         if (!($1133)) {
          $t2$0 = $1132;
          break L341;
         }
         $1157 = ((($ns_attacks) + ($chn$4119<<4)|0) + ($1134<<2)|0);
         $1158 = HEAP32[$1157>>2]|0;
         $1159 = ($1158|0)==(3);
         if (!($1159)) {
          $t2$0 = $1132;
          break L341;
         }
         if ((($sblock$1116|0) == 0)) {
          label = 233;
          break;
         } else if ((($sblock$1116|0) == 1)) {
          $1161 = +HEAPF32[$1125>>2];
          $prev_thm$1 = $1161;
          break;
         } else if ((($sblock$1116|0) == 2)) {
          $1162 = +HEAPF32[$new_thmm>>2];
          $prev_thm$1 = $1162;
          break;
         } else {
          $prev_thm$1 = $prev_thm$0;
          break;
         }
        }
       } while(0);
       if ((label|0) == 233) {
        label = 0;
        $1160 = +HEAPF32[$1126>>2];
        $prev_thm$1 = $1160;
       }
       $1163 = $1148 > 0.0;
       if (!($1163)) {
        $t2$0 = 0.0;
        break;
       }
       $1164 = $prev_thm$1 / $1148;
       $1165 = (+Math_pow((+$1164),0.18000000715255737));
       $1166 = $1165 * $1148;
       $t2$0 = $1166;
      }
     } while(0);
     $1167 = $t2$0 < $1148;
     $1168 = $1167 ? $t2$0 : $1148;
     $1169 = ((($sub_short_factor) + (($chn$4119*12)|0)|0) + ($sblock$1116<<2)|0);
     $1170 = +HEAPF32[$1169>>2];
     $1171 = $1168 * $1170;
     $1172 = (($new_thmm) + ($sblock$1116<<2)|0);
     HEAPF32[$1172>>2] = $1171;
     $1173 = (($sblock$1116) + 1)|0;
     $exitcond151 = ($1173|0)==(3);
     if ($exitcond151) {
      break;
     } else {
      $sblock$1116 = $1173;
     }
    }
    ;HEAP32[$scevgep>>2]=HEAP32[$new_thmm>>2]|0;HEAP32[$scevgep+4>>2]=HEAP32[$new_thmm+4>>2]|0;HEAP32[$scevgep+8>>2]=HEAP32[$new_thmm+8>>2]|0;
    $1127 = (($sb$0118) + 1)|0;
    $exitcond155 = ($1127|0)==(13);
    if ($exitcond155) {
     break;
    } else {
     $sb$0118 = $1127;
    }
   }
   $1174 = (($chn$4119) + 1)|0;
   $exitcond156 = ($1174|0)==($417|0);
   if ($exitcond156) {
    break;
   } else {
    $chn$4119 = $1174;
   }
  }
  if ($418) {
   $chn$5114 = 0;
   while(1) {
    $1175 = (((($ns_attacks) + ($chn$5114<<4)|0)) + 8|0);
    $1176 = HEAP32[$1175>>2]|0;
    $1177 = (((($gfc)) + 27780|0) + ($chn$5114<<2)|0);
    HEAP32[$1177>>2] = $1176;
    $1178 = (($chn$5114) + 1)|0;
    $exitcond150 = ($1178|0)==($417|0);
    if ($exitcond150) {
     break;
    } else {
     $chn$5114 = $1178;
    }
   }
  }
 }
 $1179 = HEAP32[$25>>2]|0;
 $1180 = ($1179|0)>(0);
 if ($1180) {
  $chn$01$i65 = 0;
  while(1) {
   $1181 = (($uselongblock) + ($chn$01$i65<<2)|0);
   $1182 = HEAP32[$1181>>2]|0;
   $1183 = ($1182|0)==(0);
   $1184 = (((($gfc)) + 27796|0) + ($chn$01$i65<<2)|0);
   $1185 = HEAP32[$1184>>2]|0;
   do {
    if ($1183) {
     if ((($1185|0) == 0)) {
      HEAP32[$1184>>2] = 1;
      $1188 = 1;$blocktype$0$i = 2;
      break;
     } else if ((($1185|0) == 3)) {
      HEAP32[$1184>>2] = 2;
      $1188 = 2;$blocktype$0$i = 2;
      break;
     } else {
      $1188 = $1185;$blocktype$0$i = 2;
      break;
     }
    } else {
     $1186 = ($1185|0)==(2);
     $$$i67 = $1186 ? 3 : 0;
     $1188 = $1185;$blocktype$0$i = $$$i67;
    }
   } while(0);
   $1187 = (($blocktype_d) + ($chn$01$i65<<2)|0);
   HEAP32[$1187>>2] = $1188;
   HEAP32[$1184>>2] = $blocktype$0$i;
   $1189 = (($chn$01$i65) + 1)|0;
   $exitcond$i68 = ($1189|0)==($1179|0);
   if ($exitcond$i68) {
    break;
   } else {
    $chn$01$i65 = $1189;
   }
  }
 }
 if (!($418)) {
  STACKTOP = sp;return 0;
 }
 $1190 = ((($percep_MS_entropy)) + -8|0);
 $1191 = ((($blocktype_d)) + 4|0);
 $1193 = ($1192|0)==(0|0);
 $chn$6112 = 0;
 while(1) {
  $1194 = ($chn$6112|0)>(1);
  if ($1194) {
   $1195 = HEAP32[$blocktype_d>>2]|0;
   $1196 = ($1195|0)==(2);
   if ($1196) {
    label = 253;
   } else {
    $1197 = HEAP32[$1191>>2]|0;
    $1198 = ($1197|0)==(2);
    if ($1198) {
     label = 253;
    } else {
     $type$0 = 0;
    }
   }
   if ((label|0) == 253) {
    label = 0;
    $type$0 = 2;
   }
   $1199 = (($chn$6112) + -2)|0;
   $1200 = ((($masking_MS_ratio) + (($gr_out*976)|0)|0) + (($1199*488)|0)|0);
   $mr$0 = $1200;$ppe$0 = $1190;$type$1 = $type$0;
  } else {
   $1201 = (($blocktype_d) + ($chn$6112<<2)|0);
   $1202 = HEAP32[$1201>>2]|0;
   $1203 = ((($masking_ratio) + (($gr_out*976)|0)|0) + (($chn$6112*488)|0)|0);
   $mr$0 = $1203;$ppe$0 = $percep_entropy;$type$1 = $1202;
  }
  $1204 = ($type$1|0)==(2);
  $1205 = +HEAPF32[$800>>2];
  if ($1204) {
   $pe_s$04$i = 309.07000732421875;$sb$03$i = 0;
   while(1) {
    $1206 = (11584 + ($sb$03$i<<2)|0);
    $1207 = (((($mr$0)) + 88|0) + (($sb$03$i*12)|0)|0);
    $1208 = +HEAPF32[$1207>>2];
    $1209 = $1208 > 0.0;
    do {
     if ($1209) {
      $1210 = $1208 * $1205;
      $1211 = (((($mr$0)) + 332|0) + (($sb$03$i*12)|0)|0);
      $1212 = +HEAPF32[$1211>>2];
      $1213 = $1212 > $1210;
      if (!($1213)) {
       $pe_s$2$i = $pe_s$04$i;
       break;
      }
      $1214 = $1210 * 1.0E+10;
      $1215 = $1212 > $1214;
      $1216 = +HEAPF32[$1206>>2];
      $1217 = $1216;
      if ($1215) {
       $1218 = $1217 * 23.025850929940461;
       $1219 = $pe_s$04$i;
       $1220 = $1218 + $1219;
       $1221 = $1220;
       $pe_s$2$i = $1221;
       break;
      } else {
       $1222 = $1212 / $1210;
       $1223 = (+_fast_log2($1222));
       $1224 = $1223;
       $1225 = $1217 * 0.30102999566398114;
       $1226 = $1225 * $1224;
       $1227 = $pe_s$04$i;
       $1228 = $1226 + $1227;
       $1229 = $1228;
       $pe_s$2$i = $1229;
       break;
      }
     } else {
      $pe_s$2$i = $pe_s$04$i;
     }
    } while(0);
    $1230 = (((((($mr$0)) + 88|0) + (($sb$03$i*12)|0)|0)) + 4|0);
    $1231 = +HEAPF32[$1230>>2];
    $1232 = $1231 > 0.0;
    do {
     if ($1232) {
      $1233 = $1231 * $1205;
      $1234 = (((((($mr$0)) + 332|0) + (($sb$03$i*12)|0)|0)) + 4|0);
      $1235 = +HEAPF32[$1234>>2];
      $1236 = $1235 > $1233;
      if (!($1236)) {
       $pe_s$2$1$i = $pe_s$2$i;
       break;
      }
      $1237 = $1233 * 1.0E+10;
      $1238 = $1235 > $1237;
      $1239 = +HEAPF32[$1206>>2];
      $1240 = $1239;
      if ($1238) {
       $1249 = $1240 * 23.025850929940461;
       $1250 = $pe_s$2$i;
       $1251 = $1249 + $1250;
       $1252 = $1251;
       $pe_s$2$1$i = $1252;
       break;
      } else {
       $1241 = $1235 / $1233;
       $1242 = (+_fast_log2($1241));
       $1243 = $1242;
       $1244 = $1240 * 0.30102999566398114;
       $1245 = $1244 * $1243;
       $1246 = $pe_s$2$i;
       $1247 = $1245 + $1246;
       $1248 = $1247;
       $pe_s$2$1$i = $1248;
       break;
      }
     } else {
      $pe_s$2$1$i = $pe_s$2$i;
     }
    } while(0);
    $1253 = (((((($mr$0)) + 88|0) + (($sb$03$i*12)|0)|0)) + 8|0);
    $1254 = +HEAPF32[$1253>>2];
    $1255 = $1254 > 0.0;
    do {
     if ($1255) {
      $1256 = $1254 * $1205;
      $1257 = (((((($mr$0)) + 332|0) + (($sb$03$i*12)|0)|0)) + 8|0);
      $1258 = +HEAPF32[$1257>>2];
      $1259 = $1258 > $1256;
      if (!($1259)) {
       $pe_s$2$2$i = $pe_s$2$1$i;
       break;
      }
      $1260 = $1256 * 1.0E+10;
      $1261 = $1258 > $1260;
      $1262 = +HEAPF32[$1206>>2];
      $1263 = $1262;
      if ($1261) {
       $1272 = $1263 * 23.025850929940461;
       $1273 = $pe_s$2$1$i;
       $1274 = $1272 + $1273;
       $1275 = $1274;
       $pe_s$2$2$i = $1275;
       break;
      } else {
       $1264 = $1258 / $1256;
       $1265 = (+_fast_log2($1264));
       $1266 = $1265;
       $1267 = $1263 * 0.30102999566398114;
       $1268 = $1267 * $1266;
       $1269 = $pe_s$2$1$i;
       $1270 = $1268 + $1269;
       $1271 = $1270;
       $pe_s$2$2$i = $1271;
       break;
      }
     } else {
      $pe_s$2$2$i = $pe_s$2$1$i;
     }
    } while(0);
    $1276 = (($sb$03$i) + 1)|0;
    $exitcond$i11 = ($1276|0)==(12);
    if ($exitcond$i11) {
     $pe_s$2$2$i$lcssa = $pe_s$2$2$i;
     break;
    } else {
     $pe_s$04$i = $pe_s$2$2$i;$sb$03$i = $1276;
    }
   }
   $1277 = (($ppe$0) + ($chn$6112<<2)|0);
   HEAPF32[$1277>>2] = $pe_s$2$2$i$lcssa;
   $1305 = $pe_s$2$2$i$lcssa;
  } else {
   $pe_l$02$i = 281.0574951171875;$sb$01$i = 0;
   while(1) {
    $1278 = (($mr$0) + ($sb$01$i<<2)|0);
    $1279 = +HEAPF32[$1278>>2];
    $1280 = $1279 > 0.0;
    do {
     if ($1280) {
      $1281 = $1279 * $1205;
      $1282 = (((($mr$0)) + 244|0) + ($sb$01$i<<2)|0);
      $1283 = +HEAPF32[$1282>>2];
      $1284 = $1283 > $1281;
      if (!($1284)) {
       $pe_l$1$i = $pe_l$02$i;
       break;
      }
      $1285 = $1281 * 1.0E+10;
      $1286 = $1283 > $1285;
      $1287 = (11632 + ($sb$01$i<<2)|0);
      $1288 = +HEAPF32[$1287>>2];
      $1289 = $1288;
      if ($1286) {
       $1290 = $1289 * 23.025850929940461;
       $1291 = $pe_l$02$i;
       $1292 = $1290 + $1291;
       $1293 = $1292;
       $pe_l$1$i = $1293;
       break;
      } else {
       $1294 = $1283 / $1281;
       $1295 = (+_fast_log2($1294));
       $1296 = $1295;
       $1297 = $1289 * 0.30102999566398114;
       $1298 = $1297 * $1296;
       $1299 = $pe_l$02$i;
       $1300 = $1298 + $1299;
       $1301 = $1300;
       $pe_l$1$i = $1301;
       break;
      }
     } else {
      $pe_l$1$i = $pe_l$02$i;
     }
    } while(0);
    $1302 = (($sb$01$i) + 1)|0;
    $exitcond$i7 = ($1302|0)==(21);
    if ($exitcond$i7) {
     $pe_l$1$i$lcssa = $pe_l$1$i;
     break;
    } else {
     $pe_l$02$i = $pe_l$1$i;$sb$01$i = $1302;
    }
   }
   $1303 = (($ppe$0) + ($chn$6112<<2)|0);
   HEAPF32[$1303>>2] = $pe_l$1$i$lcssa;
   $1305 = $pe_l$1$i$lcssa;
  }
  if (!($1193)) {
   $1304 = $1305;
   $1306 = ((((($1192)) + 189240|0) + ($gr_out<<5)|0) + ($chn$6112<<3)|0);
   HEAPF64[$1306>>3] = $1304;
  }
  $1307 = (($chn$6112) + 1)|0;
  $exitcond = ($1307|0)==($417|0);
  if ($exitcond) {
   break;
  } else {
   $chn$6112 = $1307;
  }
 }
 STACKTOP = sp;return 0;
}
function _psymodel_init($gfp) {
 $gfp = $gfp|0;
 var $$ = 0.0, $$0 = 0, $$lcssa = 0, $$lcssa133 = 0.0, $$lcssa20 = 0, $$pre = 0, $$pre109 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0;
 var $11 = 0, $110 = 0.0, $111 = 0, $112 = 0.0, $113 = 0, $114 = 0, $115 = 0.0, $116 = 0.0, $117 = 0.0, $118 = 0, $119 = 0, $12 = 0, $120 = 0.0, $121 = 0.0, $122 = 0.0, $123 = 0.0, $124 = 0.0, $125 = 0, $126 = 0.0, $127 = 0.0;
 var $128 = 0.0, $129 = 0.0, $13 = 0, $130 = 0.0, $131 = 0.0, $132 = 0.0, $133 = 0.0, $134 = 0.0, $135 = 0.0, $136 = 0.0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0;
 var $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0.0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0.0, $158 = 0.0, $159 = 0.0, $16 = 0, $160 = 0.0, $161 = 0.0, $162 = 0.0, $163 = 0.0;
 var $164 = 0.0, $165 = 0.0, $166 = 0.0, $167 = 0.0, $168 = 0.0, $169 = 0, $17 = 0, $170 = 0.0, $171 = 0.0, $172 = 0.0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0.0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0.0;
 var $182 = 0.0, $183 = 0.0, $184 = 0.0, $185 = 0.0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0.0, $191 = 0.0, $192 = 0.0, $193 = 0, $194 = 0.0, $195 = 0.0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0;
 var $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0.0, $205 = 0, $206 = 0.0, $207 = 0, $208 = 0, $209 = 0.0, $21 = 0, $210 = 0.0, $211 = 0.0, $212 = 0, $213 = 0, $214 = 0.0, $215 = 0.0, $216 = 0.0, $217 = 0.0;
 var $218 = 0.0, $219 = 0, $22 = 0, $220 = 0.0, $221 = 0.0, $222 = 0.0, $223 = 0.0, $224 = 0.0, $225 = 0.0, $226 = 0.0, $227 = 0.0, $228 = 0.0, $229 = 0.0, $23 = 0, $230 = 0.0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0;
 var $236 = 0.0, $237 = 0, $238 = 0, $239 = 0.0, $24 = 0, $240 = 0, $241 = 0.0, $242 = 0.0, $243 = 0.0, $244 = 0.0, $245 = 0.0, $246 = 0.0, $247 = 0.0, $248 = 0.0, $249 = 0.0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0;
 var $254 = 0.0, $255 = 0.0, $256 = 0.0, $257 = 0.0, $258 = 0.0, $259 = 0.0, $26 = 0, $260 = 0.0, $261 = 0.0, $262 = 0.0, $263 = 0.0, $264 = 0.0, $265 = 0.0, $266 = 0, $267 = 0.0, $268 = 0.0, $269 = 0.0, $27 = 0, $270 = 0, $271 = 0;
 var $272 = 0, $273 = 0, $274 = 0.0, $275 = 0, $276 = 0, $277 = 0.0, $278 = 0.0, $279 = 0.0, $28 = 0, $280 = 0.0, $281 = 0, $282 = 0.0, $283 = 0.0, $284 = 0.0, $285 = 0.0, $286 = 0.0, $287 = 0, $288 = 0.0, $289 = 0.0, $29 = 0;
 var $290 = 0.0, $291 = 0.0, $292 = 0.0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0.0, $298 = 0.0, $299 = 0.0, $3 = 0, $30 = 0, $300 = 0, $301 = 0.0, $302 = 0.0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0;
 var $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0.0, $312 = 0.0, $313 = 0.0, $314 = 0.0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0.0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0;
 var $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0.0, $333 = 0.0, $334 = 0.0, $335 = 0.0, $336 = 0.0, $337 = 0.0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0;
 var $344 = 0, $345 = 0, $346 = 0, $347 = 0.0, $348 = 0.0, $349 = 0.0, $35 = 0, $350 = 0.0, $351 = 0.0, $352 = 0.0, $353 = 0.0, $354 = 0.0, $355 = 0.0, $356 = 0, $357 = 0, $358 = 0.0, $359 = 0, $36 = 0, $360 = 0.0, $361 = 0;
 var $362 = 0, $363 = 0, $364 = 0.0, $365 = 0, $366 = 0.0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0.0, $379 = 0.0, $38 = 0;
 var $380 = 0, $381 = 0, $382 = 0, $383 = 0.0, $384 = 0, $385 = 0.0, $386 = 0, $387 = 0, $388 = 0.0, $389 = 0.0, $39 = 0, $390 = 0.0, $391 = 0.0, $392 = 0, $393 = 0.0, $394 = 0, $395 = 0, $396 = 0.0, $397 = 0.0, $398 = 0.0;
 var $399 = 0.0, $4 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0.0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0.0, $412 = 0.0, $413 = 0.0, $414 = 0.0, $415 = 0;
 var $416 = 0, $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0.0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0;
 var $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0.0, $70 = 0, $71 = 0, $72 = 0, $73 = 0;
 var $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0.0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0;
 var $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $b$051 = 0, $b$3$lcssa110 = 0, $b$329 = 0, $b$427 = 0, $b$5$lcssa111 = 0, $b$525 = 0, $b$624 = 0, $bval = 0, $bval_width = 0, $eql_balance$049 = 0.0, $exitcond = 0, $exitcond$i = 0;
 var $exitcond$i4 = 0, $exitcond101 = 0, $exitcond102 = 0, $exitcond106 = 0, $exitcond108 = 0, $exitcond97 = 0, $freq5$048 = 0.0, $i$089 = 0, $i$180 = 0, $i$278 = 0, $i$365 = 0, $i$450 = 0, $j$01$i = 0, $j$01$i3 = 0, $j$084 = 0, $j$187 = 0, $j$377 = 0, $j$4$lcssa = 0, $j$471 = 0, $j$564 = 0;
 var $j$6$lcssa = 0, $j$657 = 0, $k$02$i = 0, $k$02$i2 = 0, $k$069 = 0, $k$155 = 0, $msfix$0 = 0.0, $norm = 0, $phitmp = 0.0, $sk_s$0 = 0.0, $snr2$0 = 0.0, $x$0$lcssa = 0.0, $x$070 = 0.0, $x$1 = 0.0, $x$2 = 0.0, $x$3 = 0.0, $x$3$op = 0.0, $x$3$op$op = 0.0, $x1$0$lcssa = 0.0, $x1$056 = 0.0;
 var $x1$1 = 0.0, $x1$2 = 0.0, $x1$3 = 0.0, $x1$4 = 0.0, $x1$5 = 0.0, $x1$5$op = 0.0, $x1$5$op$op = 0.0, $x6$0 = 0.0, $y$0 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 768|0;
 $bval = sp + 512|0;
 $bval_width = sp + 256|0;
 $norm = sp;
 $0 = ((($gfp)) + 288|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ((($1)) + 16|0);
 $3 = ((($1)) + 64|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = (+($4|0));
 $6 = ((($1)) + 280|0);
 $7 = +HEAPF32[$6>>2];
 $8 = -$7;
 $9 = ((($1)) + 85800|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = ($10|0)==(0|0);
 if (!($11)) {
  $$0 = 0;
  STACKTOP = sp;return ($$0|0);
 }
 _memset(($norm|0),0,256)|0;
 $12 = (_calloc(1,6504)|0);
 HEAP32[$9>>2] = $12;
 $13 = ((($gfp)) + 144|0);
 $14 = HEAP32[$13>>2]|0;
 $15 = ((($12)) + 6500|0);
 HEAP32[$15>>2] = $14;
 $16 = ((($1)) + 27800|0);
 HEAP32[$16>>2] = 0;
 $17 = ((($1)) + 27796|0);
 HEAP32[$17>>2] = 0;
 $i$089 = 0;
 while(1) {
  $j$084 = 0;
  while(1) {
   $63 = ((((($1)) + 21564|0) + ($i$089<<8)|0) + ($j$084<<2)|0);
   HEAPF32[$63>>2] = 1.0000000200408773E+20;
   $64 = ((((($1)) + 22588|0) + ($i$089<<8)|0) + ($j$084<<2)|0);
   HEAPF32[$64>>2] = 1.0000000200408773E+20;
   $65 = ((((($1)) + 24636|0) + ($i$089<<8)|0) + ($j$084<<2)|0);
   HEAPF32[$65>>2] = 1.0;
   $66 = ((((($1)) + 23612|0) + ($i$089<<8)|0) + ($j$084<<2)|0);
   HEAPF32[$66>>2] = 1.0;
   $67 = (($j$084) + 1)|0;
   $exitcond102 = ($67|0)==(64);
   if ($exitcond102) {
    break;
   } else {
    $j$084 = $67;
   }
  }
  $18 = (((($1)) + 26636|0) + (($i$089*244)|0)|0);
  HEAPF32[$18>>2] = 1.0000000200408773E+20;
  $19 = (((($1)) + 25660|0) + (($i$089*244)|0)|0);
  HEAPF32[$19>>2] = 1.0000000200408773E+20;
  $20 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 4|0);
  HEAPF32[$20>>2] = 1.0000000200408773E+20;
  $21 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 4|0);
  HEAPF32[$21>>2] = 1.0000000200408773E+20;
  $22 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 8|0);
  HEAPF32[$22>>2] = 1.0000000200408773E+20;
  $23 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 8|0);
  HEAPF32[$23>>2] = 1.0000000200408773E+20;
  $24 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 12|0);
  HEAPF32[$24>>2] = 1.0000000200408773E+20;
  $25 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 12|0);
  HEAPF32[$25>>2] = 1.0000000200408773E+20;
  $26 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 16|0);
  HEAPF32[$26>>2] = 1.0000000200408773E+20;
  $27 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 16|0);
  HEAPF32[$27>>2] = 1.0000000200408773E+20;
  $28 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 20|0);
  HEAPF32[$28>>2] = 1.0000000200408773E+20;
  $29 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 20|0);
  HEAPF32[$29>>2] = 1.0000000200408773E+20;
  $30 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 24|0);
  HEAPF32[$30>>2] = 1.0000000200408773E+20;
  $31 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 24|0);
  HEAPF32[$31>>2] = 1.0000000200408773E+20;
  $32 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 28|0);
  HEAPF32[$32>>2] = 1.0000000200408773E+20;
  $33 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 28|0);
  HEAPF32[$33>>2] = 1.0000000200408773E+20;
  $34 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 32|0);
  HEAPF32[$34>>2] = 1.0000000200408773E+20;
  $35 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 32|0);
  HEAPF32[$35>>2] = 1.0000000200408773E+20;
  $36 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 36|0);
  HEAPF32[$36>>2] = 1.0000000200408773E+20;
  $37 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 36|0);
  HEAPF32[$37>>2] = 1.0000000200408773E+20;
  $38 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 40|0);
  HEAPF32[$38>>2] = 1.0000000200408773E+20;
  $39 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 40|0);
  HEAPF32[$39>>2] = 1.0000000200408773E+20;
  $40 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 44|0);
  HEAPF32[$40>>2] = 1.0000000200408773E+20;
  $41 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 44|0);
  HEAPF32[$41>>2] = 1.0000000200408773E+20;
  $42 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 48|0);
  HEAPF32[$42>>2] = 1.0000000200408773E+20;
  $43 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 48|0);
  HEAPF32[$43>>2] = 1.0000000200408773E+20;
  $44 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 52|0);
  HEAPF32[$44>>2] = 1.0000000200408773E+20;
  $45 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 52|0);
  HEAPF32[$45>>2] = 1.0000000200408773E+20;
  $46 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 56|0);
  HEAPF32[$46>>2] = 1.0000000200408773E+20;
  $47 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 56|0);
  HEAPF32[$47>>2] = 1.0000000200408773E+20;
  $48 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 60|0);
  HEAPF32[$48>>2] = 1.0000000200408773E+20;
  $49 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 60|0);
  HEAPF32[$49>>2] = 1.0000000200408773E+20;
  $50 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 64|0);
  HEAPF32[$50>>2] = 1.0000000200408773E+20;
  $51 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 64|0);
  HEAPF32[$51>>2] = 1.0000000200408773E+20;
  $52 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 68|0);
  HEAPF32[$52>>2] = 1.0000000200408773E+20;
  $53 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 68|0);
  HEAPF32[$53>>2] = 1.0000000200408773E+20;
  $54 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 72|0);
  HEAPF32[$54>>2] = 1.0000000200408773E+20;
  $55 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 72|0);
  HEAPF32[$55>>2] = 1.0000000200408773E+20;
  $56 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 76|0);
  HEAPF32[$56>>2] = 1.0000000200408773E+20;
  $57 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 76|0);
  HEAPF32[$57>>2] = 1.0000000200408773E+20;
  $58 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 80|0);
  HEAPF32[$58>>2] = 1.0000000200408773E+20;
  $59 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 80|0);
  HEAPF32[$59>>2] = 1.0000000200408773E+20;
  $60 = (((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 84|0);
  HEAPF32[$60>>2] = 1.0000000200408773E+20;
  $61 = (((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 84|0);
  HEAPF32[$61>>2] = 1.0000000200408773E+20;
  $62 = (((($1)) + 27780|0) + ($i$089<<2)|0);
  $j$187 = 0;
  while(1) {
   $78 = ((((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 88|0) + ($j$187<<2)|0);
   HEAPF32[$78>>2] = 1.0000000200408773E+20;
   $79 = ((((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 88|0) + ($j$187<<2)|0);
   HEAPF32[$79>>2] = 1.0000000200408773E+20;
   $80 = ((((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 100|0) + ($j$187<<2)|0);
   HEAPF32[$80>>2] = 1.0000000200408773E+20;
   $81 = ((((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 100|0) + ($j$187<<2)|0);
   HEAPF32[$81>>2] = 1.0000000200408773E+20;
   $82 = ((((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 112|0) + ($j$187<<2)|0);
   HEAPF32[$82>>2] = 1.0000000200408773E+20;
   $83 = ((((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 112|0) + ($j$187<<2)|0);
   HEAPF32[$83>>2] = 1.0000000200408773E+20;
   $84 = ((((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 124|0) + ($j$187<<2)|0);
   HEAPF32[$84>>2] = 1.0000000200408773E+20;
   $85 = ((((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 124|0) + ($j$187<<2)|0);
   HEAPF32[$85>>2] = 1.0000000200408773E+20;
   $86 = ((((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 136|0) + ($j$187<<2)|0);
   HEAPF32[$86>>2] = 1.0000000200408773E+20;
   $87 = ((((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 136|0) + ($j$187<<2)|0);
   HEAPF32[$87>>2] = 1.0000000200408773E+20;
   $88 = ((((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 148|0) + ($j$187<<2)|0);
   HEAPF32[$88>>2] = 1.0000000200408773E+20;
   $89 = ((((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 148|0) + ($j$187<<2)|0);
   HEAPF32[$89>>2] = 1.0000000200408773E+20;
   $90 = ((((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 160|0) + ($j$187<<2)|0);
   HEAPF32[$90>>2] = 1.0000000200408773E+20;
   $91 = ((((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 160|0) + ($j$187<<2)|0);
   HEAPF32[$91>>2] = 1.0000000200408773E+20;
   $92 = ((((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 172|0) + ($j$187<<2)|0);
   HEAPF32[$92>>2] = 1.0000000200408773E+20;
   $93 = ((((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 172|0) + ($j$187<<2)|0);
   HEAPF32[$93>>2] = 1.0000000200408773E+20;
   $94 = ((((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 184|0) + ($j$187<<2)|0);
   HEAPF32[$94>>2] = 1.0000000200408773E+20;
   $95 = ((((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 184|0) + ($j$187<<2)|0);
   HEAPF32[$95>>2] = 1.0000000200408773E+20;
   $96 = ((((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 196|0) + ($j$187<<2)|0);
   HEAPF32[$96>>2] = 1.0000000200408773E+20;
   $97 = ((((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 196|0) + ($j$187<<2)|0);
   HEAPF32[$97>>2] = 1.0000000200408773E+20;
   $98 = ((((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 208|0) + ($j$187<<2)|0);
   HEAPF32[$98>>2] = 1.0000000200408773E+20;
   $99 = ((((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 208|0) + ($j$187<<2)|0);
   HEAPF32[$99>>2] = 1.0000000200408773E+20;
   $100 = ((((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 220|0) + ($j$187<<2)|0);
   HEAPF32[$100>>2] = 1.0000000200408773E+20;
   $101 = ((((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 220|0) + ($j$187<<2)|0);
   HEAPF32[$101>>2] = 1.0000000200408773E+20;
   $102 = ((((((($1)) + 26636|0) + (($i$089*244)|0)|0)) + 232|0) + ($j$187<<2)|0);
   HEAPF32[$102>>2] = 1.0000000200408773E+20;
   $103 = ((((((($1)) + 25660|0) + (($i$089*244)|0)|0)) + 232|0) + ($j$187<<2)|0);
   HEAPF32[$103>>2] = 1.0000000200408773E+20;
   HEAP32[$62>>2] = 0;
   $104 = (($j$187) + 1)|0;
   $exitcond106 = ($104|0)==(3);
   if ($exitcond106) {
    break;
   } else {
    $j$187 = $104;
   }
  }
  $68 = (((($1)) + 27636|0) + (($i$089*36)|0)|0);
  HEAPF32[$68>>2] = 10.0;
  $69 = (((((($1)) + 27636|0) + (($i$089*36)|0)|0)) + 4|0);
  HEAPF32[$69>>2] = 10.0;
  $70 = (((((($1)) + 27636|0) + (($i$089*36)|0)|0)) + 8|0);
  HEAPF32[$70>>2] = 10.0;
  $71 = (((((($1)) + 27636|0) + (($i$089*36)|0)|0)) + 12|0);
  HEAPF32[$71>>2] = 10.0;
  $72 = (((((($1)) + 27636|0) + (($i$089*36)|0)|0)) + 16|0);
  HEAPF32[$72>>2] = 10.0;
  $73 = (((((($1)) + 27636|0) + (($i$089*36)|0)|0)) + 20|0);
  HEAPF32[$73>>2] = 10.0;
  $74 = (((((($1)) + 27636|0) + (($i$089*36)|0)|0)) + 24|0);
  HEAPF32[$74>>2] = 10.0;
  $75 = (((((($1)) + 27636|0) + (($i$089*36)|0)|0)) + 28|0);
  HEAPF32[$75>>2] = 10.0;
  $76 = (((((($1)) + 27636|0) + (($i$089*36)|0)|0)) + 32|0);
  HEAPF32[$76>>2] = 10.0;
  $77 = (($i$089) + 1)|0;
  $exitcond108 = ($77|0)==(4);
  if ($exitcond108) {
   break;
  } else {
   $i$089 = $77;
  }
 }
 $105 = ((($1)) + 27616|0);
 HEAPF32[$105>>2] = 0.0;
 $106 = ((($1)) + 27612|0);
 HEAPF32[$106>>2] = 0.0;
 $107 = ((($1)) + 21360|0);
 _init_numline($12,$5,1024,576,22,$107);
 $108 = ((($12)) + 2148|0);
 $109 = HEAP32[$108>>2]|0;
 $110 = $5 * 9.765625E-4;
 $111 = ($109|0)>(0);
 if ($111) {
  $112 = $110;
  $j$01$i = 0;$k$02$i = 0;
  while(1) {
   $113 = (((($12)) + 1716|0) + ($k$02$i<<2)|0);
   $114 = HEAP32[$113>>2]|0;
   $115 = (+($j$01$i|0));
   $116 = $115 * $110;
   $117 = (+_freq2bark($116));
   $118 = (($114) + ($j$01$i))|0;
   $119 = (($118) + -1)|0;
   $120 = (+($119|0));
   $121 = $120 * $110;
   $122 = (+_freq2bark($121));
   $123 = $122 + $117;
   $124 = $123 * 0.5;
   $125 = (($bval) + ($k$02$i<<2)|0);
   HEAPF32[$125>>2] = $124;
   $126 = (+($j$01$i|0));
   $127 = $126 + -0.5;
   $128 = $127 * $112;
   $129 = $128;
   $130 = (+_freq2bark($129));
   $131 = (+($118|0));
   $132 = $131 + -0.5;
   $133 = $132 * $112;
   $134 = $133;
   $135 = (+_freq2bark($134));
   $136 = $135 - $130;
   $137 = (($bval_width) + ($k$02$i<<2)|0);
   HEAPF32[$137>>2] = $136;
   $138 = (($k$02$i) + 1)|0;
   $exitcond$i = ($138|0)==($109|0);
   if ($exitcond$i) {
    break;
   } else {
    $j$01$i = $118;$k$02$i = $138;
   }
  }
  $$pre = HEAP32[$108>>2]|0;
  $139 = ($$pre|0)>(0);
  if ($139) {
   $i$180 = 0;
   while(1) {
    $140 = (($norm) + ($i$180<<2)|0);
    HEAPF32[$140>>2] = 1.0;
    $141 = (($i$180) + 1)|0;
    $142 = ($141|0)<($$pre|0);
    if ($142) {
     $i$180 = $141;
    } else {
     $145 = $$pre;
     break;
    }
   }
  } else {
   $145 = $$pre;
  }
 } else {
  $145 = $109;
 }
 $143 = ((($12)) + 2156|0);
 $144 = ((($12)) + 1204|0);
 $146 = (_init_s3_values($143,$144,$145,$bval,$bval_width,$norm)|0);
 $147 = ($146|0)==(0);
 if (!($147)) {
  $$0 = $146;
  STACKTOP = sp;return ($$0|0);
 }
 $148 = HEAP32[$108>>2]|0;
 $149 = ($148|0)>(0);
 if ($149) {
  $150 = ((($12)) + 1716|0);
  $151 = ((($1)) + 85796|0);
  $152 = $8;
  $153 = ((($12)) + 256|0);
  $i$278 = 0;$j$377 = 0;
  while(1) {
   $154 = (($150) + ($i$278<<2)|0);
   $155 = HEAP32[$154>>2]|0;
   $156 = ($155|0)>(0);
   if ($156) {
    $j$471 = $j$377;$k$069 = 0;$x$070 = 9.9999999999999995E+36;
    while(1) {
     $157 = (+($j$471|0));
     $158 = $157 * $5;
     $159 = $158;
     $160 = $159 * 9.7656250000000002E-7;
     $161 = $160;
     $162 = $161 * 1000.0;
     $163 = (+_ATHformula($2,$162));
     $164 = $163 + -20.0;
     $165 = $164;
     $166 = $165 * 0.10000000000000001;
     $167 = (+Math_pow(10.0,(+$166)));
     $168 = $167;
     $169 = HEAP32[$154>>2]|0;
     $170 = (+($169|0));
     $171 = $170 * $168;
     $172 = $171;
     $173 = $x$070 > $172;
     $x$1 = $173 ? $172 : $x$070;
     $174 = (($k$069) + 1)|0;
     $175 = (($j$471) + 1)|0;
     $176 = ($174|0)<($169|0);
     if ($176) {
      $j$471 = $175;$k$069 = $174;$x$070 = $x$1;
     } else {
      $193 = $169;$j$4$lcssa = $175;$x$0$lcssa = $x$1;
      break;
     }
    }
   } else {
    $193 = $155;$j$4$lcssa = $j$377;$x$0$lcssa = 9.9999999999999995E+36;
   }
   $177 = $x$0$lcssa;
   $178 = HEAP32[$151>>2]|0;
   $179 = (((($178)) + 212|0) + ($i$278<<2)|0);
   HEAPF32[$179>>2] = $177;
   $180 = (($bval) + ($i$278<<2)|0);
   $181 = +HEAPF32[$180>>2];
   $182 = $181 * 0.10000000149011612;
   $183 = $182;
   $184 = $183 + -1.0;
   $185 = $184 * 20.0;
   $186 = $185 > 6.0;
   $x$2 = $186 ? 30.0 : $185;
   $187 = $x$2 < $152;
   $x$3 = $187 ? $152 : $x$2;
   $188 = HEAP32[$3>>2]|0;
   $189 = ($188|0)<(44000);
   $x$3$op = $x$3 + -8.0;
   $x$3$op$op = $x$3$op * 0.10000000000000001;
   $190 = $189 ? 2.2000000000000002 : $x$3$op$op;
   $191 = (+Math_pow(10.0,(+$190)));
   $192 = (+($193|0));
   $194 = $192 * $191;
   $195 = $194;
   $196 = (($153) + ($i$278<<2)|0);
   HEAPF32[$196>>2] = $195;
   $197 = (($i$278) + 1)|0;
   $198 = HEAP32[$108>>2]|0;
   $199 = ($197|0)<($198|0);
   if ($199) {
    $i$278 = $197;$j$377 = $j$4$lcssa;
   } else {
    break;
   }
  }
 }
 $200 = ((($12)) + 2160|0);
 $201 = ((($1)) + 21452|0);
 _init_numline($200,$5,256,192,13,$201);
 $202 = ((($12)) + 4308|0);
 $203 = HEAP32[$202>>2]|0;
 $204 = $5 * 0.00390625;
 $205 = ($203|0)>(0);
 if ($205) {
  $206 = $204;
  $j$01$i3 = 0;$k$02$i2 = 0;
  while(1) {
   $207 = (((($200)) + 1716|0) + ($k$02$i2<<2)|0);
   $208 = HEAP32[$207>>2]|0;
   $209 = (+($j$01$i3|0));
   $210 = $209 * $204;
   $211 = (+_freq2bark($210));
   $212 = (($208) + ($j$01$i3))|0;
   $213 = (($212) + -1)|0;
   $214 = (+($213|0));
   $215 = $214 * $204;
   $216 = (+_freq2bark($215));
   $217 = $216 + $211;
   $218 = $217 * 0.5;
   $219 = (($bval) + ($k$02$i2<<2)|0);
   HEAPF32[$219>>2] = $218;
   $220 = (+($j$01$i3|0));
   $221 = $220 + -0.5;
   $222 = $221 * $206;
   $223 = $222;
   $224 = (+_freq2bark($223));
   $225 = (+($212|0));
   $226 = $225 + -0.5;
   $227 = $226 * $206;
   $228 = $227;
   $229 = (+_freq2bark($228));
   $230 = $229 - $224;
   $231 = (($bval_width) + ($k$02$i2<<2)|0);
   HEAPF32[$231>>2] = $230;
   $232 = (($k$02$i2) + 1)|0;
   $exitcond$i4 = ($232|0)==($203|0);
   if ($exitcond$i4) {
    break;
   } else {
    $j$01$i3 = $212;$k$02$i2 = $232;
   }
  }
  $$pre109 = HEAP32[$202>>2]|0;
  $233 = ($$pre109|0)>(0);
  if ($233) {
   $234 = ((($12)) + 3876|0);
   $235 = ((($1)) + 85796|0);
   $236 = $8;
   $237 = ((($12)) + 2416|0);
   $i$365 = 0;$j$564 = 0;
   while(1) {
    $238 = (($bval) + ($i$365<<2)|0);
    $239 = +HEAPF32[$238>>2];
    $240 = !($239 >= 13.0);
    if ($240) {
     $snr2$0 = -8.25;
    } else {
     $241 = $239 + -13.0;
     $242 = $241 * 0.40909090638160706;
     $243 = 24.0 - $239;
     $244 = $243 * -0.75;
     $245 = $244 - $242;
     $246 = $245;
     $snr2$0 = $246;
    }
    $247 = $snr2$0 * 0.10000000000000001;
    $248 = (+Math_pow(10.0,(+$247)));
    $249 = $248;
    $250 = (($norm) + ($i$365<<2)|0);
    HEAPF32[$250>>2] = $249;
    $251 = (($234) + ($i$365<<2)|0);
    $252 = HEAP32[$251>>2]|0;
    $253 = ($252|0)>(0);
    if ($253) {
     $j$657 = $j$564;$k$155 = 0;$x1$056 = 9.9999999999999995E+36;
     while(1) {
      $254 = (+($j$657|0));
      $255 = $254 * $5;
      $256 = $255;
      $257 = $256 * 3.9062500000000001E-6;
      $258 = $257;
      $259 = $258 * 1000.0;
      $260 = (+_ATHformula($2,$259));
      $261 = $260 + -20.0;
      $262 = $261;
      $263 = $262 * 0.10000000000000001;
      $264 = (+Math_pow(10.0,(+$263)));
      $265 = $264;
      $266 = HEAP32[$251>>2]|0;
      $267 = (+($266|0));
      $268 = $267 * $265;
      $269 = $268;
      $270 = $x1$056 > $269;
      $x1$1 = $270 ? $269 : $x1$056;
      $271 = (($k$155) + 1)|0;
      $272 = (($j$657) + 1)|0;
      $273 = ($271|0)<($266|0);
      if ($273) {
       $j$657 = $272;$k$155 = $271;$x1$056 = $x1$1;
      } else {
       $300 = $266;$j$6$lcssa = $272;$x1$0$lcssa = $x1$1;
       break;
      }
     }
    } else {
     $300 = $252;$j$6$lcssa = $j$564;$x1$0$lcssa = 9.9999999999999995E+36;
    }
    $274 = $x1$0$lcssa;
    $275 = HEAP32[$235>>2]|0;
    $276 = (((($275)) + 468|0) + ($i$365<<2)|0);
    HEAPF32[$276>>2] = $274;
    $277 = $239 * 0.083333335816860198;
    $278 = $277;
    $279 = $278 + -1.0;
    $280 = $279 * 7.0;
    $281 = $239 > 12.0;
    if ($281) {
     $282 = $280 + 1.0;
     $283 = (+Math_log((+$282)));
     $284 = $283 * 3.1000000000000001;
     $285 = $284 + 1.0;
     $286 = $285 * $280;
     $x1$2 = $286;
    } else {
     $x1$2 = $280;
    }
    $287 = $239 < 12.0;
    if ($287) {
     $288 = 1.0 - $x1$2;
     $289 = (+Math_log((+$288)));
     $290 = $289 * 2.2999999999999998;
     $291 = $290 + 1.0;
     $292 = $291 * $x1$2;
     $x1$3 = $292;
    } else {
     $x1$3 = $x1$2;
    }
    $293 = $x1$3 > 6.0;
    $x1$4 = $293 ? 30.0 : $x1$3;
    $294 = $x1$4 < $236;
    $x1$5 = $294 ? $236 : $x1$4;
    $295 = HEAP32[$3>>2]|0;
    $296 = ($295|0)<(44000);
    $x1$5$op = $x1$5 + -8.0;
    $x1$5$op$op = $x1$5$op * 0.10000000000000001;
    $297 = $296 ? 2.2000000000000002 : $x1$5$op$op;
    $298 = (+Math_pow(10.0,(+$297)));
    $299 = (+($300|0));
    $301 = $299 * $298;
    $302 = $301;
    $303 = (($237) + ($i$365<<2)|0);
    HEAPF32[$303>>2] = $302;
    $304 = (($i$365) + 1)|0;
    $305 = HEAP32[$202>>2]|0;
    $306 = ($304|0)<($305|0);
    if ($306) {
     $i$365 = $304;$j$564 = $j$6$lcssa;
    } else {
     $$lcssa20 = $305;
     break;
    }
   }
  } else {
   $$lcssa20 = $$pre109;
  }
 } else {
  $$lcssa20 = $203;
 }
 $307 = ((($12)) + 4316|0);
 $308 = ((($12)) + 3364|0);
 $309 = (_init_s3_values($307,$308,$$lcssa20,$bval,$bval_width,$norm)|0);
 $310 = ($309|0)==(0);
 if (!($310)) {
  $$0 = $309;
  STACKTOP = sp;return ($$0|0);
 }
 HEAPF32[11528>>2] = 3.6517412662506104;
 HEAPF32[11576>>2] = 31.622776031494141;
 _init_fft($1);
 $311 = $5;
 $312 = -44209.633785485676 / $311;
 $313 = (+Math_exp((+$312)));
 $314 = $313;
 $315 = ((($12)) + 6496|0);
 HEAPF32[$315>>2] = $314;
 $316 = ((($1)) + 96|0);
 $317 = HEAP32[$316>>2]|0;
 $318 = ($317|0)!=(0);
 $$ = $318 ? 1.0 : 3.5;
 $319 = ((($1)) + 192|0);
 $320 = +HEAPF32[$319>>2];
 $321 = ($320 != $320) | (0.0 != 0.0) |($320 == 0.0);
 $msfix$0 = $321 ? $$ : $320;
 HEAPF32[$319>>2] = $msfix$0;
 $322 = HEAP32[$108>>2]|0;
 $323 = ($322|0)>(0);
 if ($323) {
  $324 = (($322) + -1)|0;
  $b$051 = 0;
  while(1) {
   $325 = (((($144) + ($b$051<<3)|0)) + 4|0);
   $326 = HEAP32[$325>>2]|0;
   $327 = ($326|0)>($324|0);
   if ($327) {
    HEAP32[$325>>2] = $324;
   }
   $328 = (($b$051) + 1)|0;
   $329 = ($328|0)<($322|0);
   if ($329) {
    $b$051 = $328;
   } else {
    break;
   }
  }
 }
 $330 = ((($1)) + 76|0);
 $331 = HEAP32[$330>>2]|0;
 $332 = (+($331|0));
 $333 = $332 * 576.0;
 $334 = $333 / $311;
 $335 = $334 * -1.2;
 $336 = (+Math_pow(10.0,(+$335)));
 $337 = $336;
 $338 = ((($1)) + 85796|0);
 $339 = HEAP32[$338>>2]|0;
 $340 = ((($339)) + 16|0);
 HEAPF32[$340>>2] = $337;
 $341 = ((($339)) + 8|0);
 HEAPF32[$341>>2] = 0.0099999997764825821;
 $342 = ((($339)) + 12|0);
 HEAPF32[$342>>2] = 1.0;
 $343 = ((($1)) + 208|0);
 $344 = HEAP32[$343>>2]|0;
 $345 = ($344|0)==(-1);
 if (!($345)) {
  $346 = HEAP32[$3>>2]|0;
  $347 = (+($346|0));
  $348 = $347 * 9.765625E-4;
  $eql_balance$049 = 0.0;$freq5$048 = 0.0;$i$450 = 0;
  while(1) {
   $349 = $freq5$048 + $348;
   $350 = (+_ATHformula($2,$349));
   $351 = $350 * 0.10000000149011612;
   $352 = $351;
   $353 = (+Math_pow(10.0,(+$352)));
   $354 = 1.0 / $353;
   $355 = $354;
   $356 = HEAP32[$338>>2]|0;
   $357 = (((($356)) + 724|0) + ($i$450<<2)|0);
   HEAPF32[$357>>2] = $355;
   $358 = $355 + $eql_balance$049;
   $359 = (($i$450) + 1)|0;
   $exitcond101 = ($359|0)==(512);
   if ($exitcond101) {
    $$lcssa = $356;$$lcssa133 = $358;
    break;
   } else {
    $eql_balance$049 = $358;$freq5$048 = $349;$i$450 = $359;
   }
  }
  $360 = 1.0 / $$lcssa133;
  $377 = 511;
  while(1) {
   $376 = (((($$lcssa)) + 724|0) + ($377<<2)|0);
   $378 = +HEAPF32[$376>>2];
   $379 = $378 * $360;
   HEAPF32[$376>>2] = $379;
   $380 = (($377) + -1)|0;
   $381 = ($377|0)>(0);
   if ($381) {
    $377 = $380;
   } else {
    break;
   }
  }
 }
 $361 = HEAP32[$202>>2]|0;
 $362 = ($361|0)>(0);
 $363 = ((($gfp)) + 264|0);
 $364 = +HEAPF32[$363>>2];
 $365 = ((($gfp)) + 268|0);
 $366 = +HEAPF32[$365>>2];
 $367 = $364 < 0.0;
 $x6$0 = $367 ? 4.4000000953674316 : $364;
 $368 = $366 < 0.0;
 $y$0 = $368 ? 25.0 : $366;
 $369 = ((($12)) + 6480|0);
 $370 = ((($12)) + 6488|0);
 HEAPF32[$370>>2] = $x6$0;
 $371 = ((($12)) + 6484|0);
 HEAPF32[$371>>2] = $x6$0;
 HEAPF32[$369>>2] = $x6$0;
 $372 = ((($12)) + 6492|0);
 HEAPF32[$372>>2] = $y$0;
 $373 = ((($gfp)) + 164|0);
 $374 = HEAP32[$373>>2]|0;
 $375 = ($374|0)<(4);
 if ($375) {
  $sk_s$0 = -0.74000000953674316;
 } else {
  $382 = (11720 + ($374<<2)|0);
  $383 = +HEAPF32[$382>>2];
  $384 = ((($gfp)) + 160|0);
  $385 = +HEAPF32[$384>>2];
  $386 = (($374) + 1)|0;
  $387 = (11720 + ($386<<2)|0);
  $388 = +HEAPF32[$387>>2];
  $389 = $383 - $388;
  $390 = $389 * $385;
  $391 = $390 + $383;
  $phitmp = $391 * 0.10000000149011612;
  $sk_s$0 = $phitmp;
 }
 if ($362) {
  $392 = ($361|0)>(1);
  $393 = (+($361|0));
  $b$329 = 0;
  while(1) {
   $395 = (($361) - ($b$329))|0;
   $396 = (+($395|0));
   $397 = $396 / $393;
   $398 = $sk_s$0 * $397;
   $399 = (+Math_pow(10.0,(+$398)));
   $400 = (($200) + ($b$329<<2)|0);
   HEAPF32[$400>>2] = $399;
   $401 = (($b$329) + 1)|0;
   $402 = ($361|0)>($401|0);
   if ($402) {
    $b$329 = $401;
   } else {
    break;
   }
  }
  if ($392) {
   $394 = ($361|0)<(64);
   if ($394) {
    $b$3$lcssa110 = $361;
    label = 50;
   }
  } else {
   $b$3$lcssa110 = 1;
   label = 50;
  }
 } else {
  $b$3$lcssa110 = 0;
  label = 50;
 }
 if ((label|0) == 50) {
  $b$427 = $b$3$lcssa110;
  while(1) {
   $407 = (($200) + ($b$427<<2)|0);
   HEAPF32[$407>>2] = 1.0;
   $408 = (($b$427) + 1)|0;
   $exitcond97 = ($408|0)==(64);
   if ($exitcond97) {
    break;
   } else {
    $b$427 = $408;
   }
  }
 }
 $403 = HEAP32[$108>>2]|0;
 $404 = ($403|0)>(0);
 if ($404) {
  $405 = ($403|0)>(1);
  $406 = (+($403|0));
  $b$525 = 0;
  while(1) {
   $410 = (($403) - ($b$525))|0;
   $411 = (+($410|0));
   $412 = $411 / $406;
   $413 = $sk_s$0 * $412;
   $414 = (+Math_pow(10.0,(+$413)));
   $415 = (($12) + ($b$525<<2)|0);
   HEAPF32[$415>>2] = $414;
   $416 = (($b$525) + 1)|0;
   $417 = ($403|0)>($416|0);
   if ($417) {
    $b$525 = $416;
   } else {
    break;
   }
  }
  if ($405) {
   $409 = ($403|0)<(64);
   if ($409) {
    $b$5$lcssa111 = $403;
    label = 57;
   }
  } else {
   $b$5$lcssa111 = 1;
   label = 57;
  }
 } else {
  $b$5$lcssa111 = 0;
  label = 57;
 }
 if ((label|0) == 57) {
  $b$624 = $b$5$lcssa111;
  while(1) {
   $418 = (($12) + ($b$624<<2)|0);
   HEAPF32[$418>>2] = 1.0;
   $419 = (($b$624) + 1)|0;
   $exitcond = ($419|0)==(64);
   if ($exitcond) {
    break;
   } else {
    $b$624 = $419;
   }
  }
 }
 $420 = ((($12)) + 4320|0);
 _memcpy(($420|0),($12|0),2160)|0;
 _init_numline($420,$5,1024,192,13,$201);
 $$0 = 0;
 STACKTOP = sp;return ($$0|0);
}
function _vbrpsy_compute_MS_thresholds($eb,$thr,$cb_mld,$ath_cb,$athlower,$msfix,$n) {
 $eb = $eb|0;
 $thr = $thr|0;
 $cb_mld = $cb_mld|0;
 $ath_cb = $ath_cb|0;
 $athlower = +$athlower;
 $msfix = +$msfix;
 $n = $n|0;
 var $0 = 0.0, $1 = 0, $10 = 0.0, $11 = 0, $12 = 0.0, $13 = 0, $14 = 0.0, $15 = 0.0, $16 = 0, $17 = 0.0, $18 = 0, $19 = 0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0, $24 = 0.0, $25 = 0, $26 = 0.0;
 var $27 = 0, $28 = 0.0, $29 = 0, $3 = 0, $30 = 0.0, $31 = 0, $32 = 0.0, $33 = 0.0, $34 = 0, $35 = 0.0, $36 = 0, $37 = 0.0, $38 = 0, $39 = 0.0, $4 = 0.0, $40 = 0, $41 = 0.0, $42 = 0.0, $43 = 0, $44 = 0;
 var $45 = 0.0, $46 = 0.0, $47 = 0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0, $52 = 0.0, $53 = 0, $54 = 0.0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0.0, $6 = 0.0, $60 = 0, $61 = 0.0, $62 = 0;
 var $63 = 0.0, $64 = 0, $65 = 0.0, $66 = 0, $67 = 0.0, $68 = 0, $69 = 0.0, $7 = 0, $70 = 0.0, $71 = 0, $72 = 0.0, $73 = 0, $74 = 0, $75 = 0.0, $76 = 0.0, $77 = 0.0, $78 = 0, $79 = 0.0, $8 = 0.0, $80 = 0;
 var $81 = 0.0, $82 = 0, $83 = 0.0, $84 = 0, $85 = 0.0, $86 = 0, $87 = 0, $88 = 0, $9 = 0, $b$02 = 0, $b$02$us = 0, $exitcond = 0, $exitcond3 = 0, $or$cond = 0, $or$cond$us = 0, $rmid$0 = 0.0, $rmid$0$us = 0.0, $rmid$2 = 0.0, $rmid$2$us = 0.0, $rside$0 = 0.0;
 var $rside$0$us = 0.0, $rside$2 = 0.0, $rside$2$us = 0.0, $thmM$0$us = 0.0, $thmS$0$us = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = $msfix * 2.0;
 $1 = ($n|0)>(0);
 if (!($1)) {
  return;
 }
 $2 = $msfix > 0.0;
 if ($2) {
  $b$02$us = 0;
 } else {
  $b$02 = 0;
  while(1) {
   $58 = (((($eb)) + 512|0) + ($b$02<<2)|0);
   $59 = +HEAPF32[$58>>2];
   $60 = (((($eb)) + 768|0) + ($b$02<<2)|0);
   $61 = +HEAPF32[$60>>2];
   $62 = (($thr) + ($b$02<<2)|0);
   $63 = +HEAPF32[$62>>2];
   $64 = (((($thr)) + 256|0) + ($b$02<<2)|0);
   $65 = +HEAPF32[$64>>2];
   $66 = (((($thr)) + 512|0) + ($b$02<<2)|0);
   $67 = +HEAPF32[$66>>2];
   $68 = (((($thr)) + 768|0) + ($b$02<<2)|0);
   $69 = +HEAPF32[$68>>2];
   $70 = $65 * 1.5800000429153442;
   $71 = !($63 <= $70);
   $72 = $63 * 1.5800000429153442;
   $73 = !($65 <= $72);
   $or$cond = $73 | $71;
   if ($or$cond) {
    $rmid$0 = $67;$rside$0 = $69;
   } else {
    $74 = (($cb_mld) + ($b$02<<2)|0);
    $75 = +HEAPF32[$74>>2];
    $76 = $75 * $61;
    $77 = $75 * $59;
    $78 = $69 < $76;
    $79 = $78 ? $69 : $76;
    $80 = $67 < $77;
    $81 = $80 ? $67 : $77;
    $82 = $67 > $79;
    $83 = $82 ? $67 : $79;
    $84 = $69 > $81;
    $85 = $84 ? $69 : $81;
    $rmid$0 = $83;$rside$0 = $85;
   }
   $86 = $rmid$0 > $59;
   $rmid$2 = $86 ? $59 : $rmid$0;
   $87 = $rside$0 > $61;
   $rside$2 = $87 ? $61 : $rside$0;
   HEAPF32[$66>>2] = $rmid$2;
   HEAPF32[$68>>2] = $rside$2;
   $88 = (($b$02) + 1)|0;
   $exitcond = ($88|0)==($n|0);
   if ($exitcond) {
    break;
   } else {
    $b$02 = $88;
   }
  }
  return;
 }
 while(1) {
  $3 = (((($eb)) + 512|0) + ($b$02$us<<2)|0);
  $4 = +HEAPF32[$3>>2];
  $5 = (((($eb)) + 768|0) + ($b$02$us<<2)|0);
  $6 = +HEAPF32[$5>>2];
  $7 = (($thr) + ($b$02$us<<2)|0);
  $8 = +HEAPF32[$7>>2];
  $9 = (((($thr)) + 256|0) + ($b$02$us<<2)|0);
  $10 = +HEAPF32[$9>>2];
  $11 = (((($thr)) + 512|0) + ($b$02$us<<2)|0);
  $12 = +HEAPF32[$11>>2];
  $13 = (((($thr)) + 768|0) + ($b$02$us<<2)|0);
  $14 = +HEAPF32[$13>>2];
  $15 = $10 * 1.5800000429153442;
  $16 = !($8 <= $15);
  $17 = $8 * 1.5800000429153442;
  $18 = !($10 <= $17);
  $or$cond$us = $18 | $16;
  if ($or$cond$us) {
   $rmid$0$us = $12;$rside$0$us = $14;
  } else {
   $19 = (($cb_mld) + ($b$02$us<<2)|0);
   $20 = +HEAPF32[$19>>2];
   $21 = $20 * $6;
   $22 = $20 * $4;
   $23 = $14 < $21;
   $24 = $23 ? $14 : $21;
   $25 = $12 < $22;
   $26 = $25 ? $12 : $22;
   $27 = $12 > $24;
   $28 = $27 ? $12 : $24;
   $29 = $14 > $26;
   $30 = $29 ? $14 : $26;
   $rmid$0$us = $28;$rside$0$us = $30;
  }
  $31 = (($ath_cb) + ($b$02$us<<2)|0);
  $32 = +HEAPF32[$31>>2];
  $33 = $32 * $athlower;
  $34 = $8 > $33;
  $35 = $34 ? $8 : $33;
  $36 = $10 > $33;
  $37 = $36 ? $10 : $33;
  $38 = $rmid$0$us > $33;
  $39 = $38 ? $rmid$0$us : $33;
  $40 = $rside$0$us > $33;
  $41 = $40 ? $rside$0$us : $33;
  $42 = $39 + $41;
  $43 = $42 > 0.0;
  if ($43) {
   $44 = $35 < $37;
   $45 = $44 ? $35 : $37;
   $46 = $0 * $45;
   $47 = $46 < $42;
   if ($47) {
    $48 = $46 / $42;
    $49 = $48 * $39;
    $50 = $48 * $41;
    $thmM$0$us = $49;$thmS$0$us = $50;
   } else {
    $thmM$0$us = $39;$thmS$0$us = $41;
   }
  } else {
   $thmM$0$us = $39;$thmS$0$us = $41;
  }
  $51 = $thmM$0$us < $rmid$0$us;
  $52 = $51 ? $thmM$0$us : $rmid$0$us;
  $53 = $thmS$0$us < $rside$0$us;
  $54 = $53 ? $thmS$0$us : $rside$0$us;
  $55 = $52 > $4;
  $rmid$2$us = $55 ? $4 : $52;
  $56 = $54 > $6;
  $rside$2$us = $56 ? $6 : $54;
  HEAPF32[$11>>2] = $rmid$2$us;
  HEAPF32[$13>>2] = $rside$2$us;
  $57 = (($b$02$us) + 1)|0;
  $exitcond3 = ($57|0)==($n|0);
  if ($exitcond3) {
   break;
  } else {
   $b$02$us = $57;
  }
 }
 return;
}
function _convert_partition2scalefac($gd,$eb,$thr,$enn_out,$thm_out) {
 $gd = $gd|0;
 $eb = $eb|0;
 $thr = $thr|0;
 $enn_out = $enn_out|0;
 $thm_out = $thm_out|0;
 var $$pre = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0.0, $14 = 0.0, $15 = 0, $16 = 0.0, $17 = 0.0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0.0, $25 = 0.0;
 var $26 = 0, $27 = 0.0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0, $35 = 0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0;
 var $44 = 0, $45 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $b$011 = 0, $b$1$lcssa = 0, $b$13 = 0, $enn$014 = 0.0, $enn$1$lcssa = 0.0, $enn$1$lcssa$lcssa = 0.0, $enn$15 = 0.0, $exitcond = 0, $exitcond26 = 0, $sb$012 = 0, $sb$012$lcssa = 0, $sb$1$ph = 0, $sb$12 = 0;
 var $thmm$013 = 0.0, $thmm$1$lcssa = 0.0, $thmm$1$lcssa$lcssa = 0.0, $thmm$14 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gd)) + 2152|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($1|0)>(0);
 L1: do {
  if ($2) {
   $3 = ((($gd)) + 2148|0);
   $$pre = HEAP32[$3>>2]|0;
   $b$011 = 0;$enn$014 = 0.0;$sb$012 = 0;$thmm$013 = 0.0;
   while(1) {
    $5 = (((($gd)) + 2060|0) + ($sb$012<<2)|0);
    $6 = HEAP32[$5>>2]|0;
    $7 = ($6|0)<($$pre|0);
    $8 = $7 ? $6 : $$pre;
    $9 = ($b$011|0)<($8|0);
    if ($9) {
     $10 = ($$pre|0)>($6|0);
     $11 = $10 ? $6 : $$pre;
     $b$13 = $b$011;$enn$15 = $enn$014;$thmm$14 = $thmm$013;
     while(1) {
      $12 = (($eb) + ($b$13<<2)|0);
      $13 = +HEAPF32[$12>>2];
      $14 = $13 + $enn$15;
      $15 = (($thr) + ($b$13<<2)|0);
      $16 = +HEAPF32[$15>>2];
      $17 = $16 + $thmm$14;
      $18 = (($b$13) + 1)|0;
      $exitcond26 = ($18|0)==($11|0);
      if ($exitcond26) {
       $b$1$lcssa = $11;$enn$1$lcssa = $14;$thmm$1$lcssa = $17;
       break;
      } else {
       $b$13 = $18;$enn$15 = $14;$thmm$14 = $17;
      }
     }
    } else {
     $b$1$lcssa = $b$011;$enn$1$lcssa = $enn$014;$thmm$1$lcssa = $thmm$013;
    }
    $19 = ($b$1$lcssa|0)<($$pre|0);
    if (!($19)) {
     $enn$1$lcssa$lcssa = $enn$1$lcssa;$sb$012$lcssa = $sb$012;$thmm$1$lcssa$lcssa = $thmm$1$lcssa;
     break;
    }
    $23 = (((($gd)) + 1112|0) + ($sb$012<<2)|0);
    $24 = +HEAPF32[$23>>2];
    $25 = 1.0 - $24;
    $26 = (($eb) + ($b$1$lcssa<<2)|0);
    $27 = +HEAPF32[$26>>2];
    $28 = $27 * $24;
    $29 = $28 + $enn$1$lcssa;
    $30 = (($thr) + ($b$1$lcssa<<2)|0);
    $31 = +HEAPF32[$30>>2];
    $32 = $31 * $24;
    $33 = $32 + $thmm$1$lcssa;
    $34 = (($enn_out) + ($sb$012<<2)|0);
    HEAPF32[$34>>2] = $29;
    $35 = (($thm_out) + ($sb$012<<2)|0);
    HEAPF32[$35>>2] = $33;
    $36 = +HEAPF32[$26>>2];
    $37 = $36 * $25;
    $38 = +HEAPF32[$30>>2];
    $39 = $38 * $25;
    $40 = (($b$1$lcssa) + 1)|0;
    $41 = (($sb$012) + 1)|0;
    $42 = ($41|0)<($1|0);
    if ($42) {
     $b$011 = $40;$enn$014 = $37;$sb$012 = $41;$thmm$013 = $39;
    } else {
     $sb$1$ph = $41;
     break L1;
    }
   }
   $20 = (($enn_out) + ($sb$012$lcssa<<2)|0);
   HEAPF32[$20>>2] = $enn$1$lcssa$lcssa;
   $21 = (($thm_out) + ($sb$012$lcssa<<2)|0);
   HEAPF32[$21>>2] = $thmm$1$lcssa$lcssa;
   $22 = (($sb$012$lcssa) + 1)|0;
   $sb$1$ph = $22;
  } else {
   $sb$1$ph = 0;
  }
 } while(0);
 $4 = ($sb$1$ph|0)<($1|0);
 if ($4) {
  $sb$12 = $sb$1$ph;
 } else {
  return;
 }
 while(1) {
  $43 = (($enn_out) + ($sb$12<<2)|0);
  HEAPF32[$43>>2] = 0.0;
  $44 = (($thm_out) + ($sb$12<<2)|0);
  HEAPF32[$44>>2] = 0.0;
  $45 = (($sb$12) + 1)|0;
  $exitcond = ($45|0)==($1|0);
  if ($exitcond) {
   break;
  } else {
   $sb$12 = $45;
  }
 }
 return;
}
function _init_numline($gd,$sfreq,$fft_size,$mdct_size,$sbmax,$scalepos) {
 $gd = $gd|0;
 $sfreq = +$sfreq;
 $fft_size = $fft_size|0;
 $mdct_size = $mdct_size|0;
 $sbmax = $sbmax|0;
 $scalepos = $scalepos|0;
 var $$ = 0, $$2 = 0, $$lcssa = 0, $$op$op$i = 0.0, $$op$op$i3 = 0.0, $0 = 0.0, $1 = 0.0, $10 = 0.0, $100 = 0.0, $101 = 0, $102 = 0, $103 = 0, $104 = 0.0, $105 = 0.0, $106 = 0.0, $107 = 0.0, $108 = 0, $109 = 0.0, $11 = 0, $110 = 0.0;
 var $111 = 0.0, $112 = 0.0, $113 = 0.0, $114 = 0.0, $115 = 0.0, $116 = 0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0, $18 = 0, $19 = 0, $2 = 0.0, $20 = 0, $21 = 0, $22 = 0, $23 = 0.0, $24 = 0.0;
 var $25 = 0.0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0.0, $30 = 0, $31 = 0, $32 = 0.0, $33 = 0.0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0.0, $40 = 0, $41 = 0, $42 = 0;
 var $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0, $48 = 0.0, $49 = 0.0, $5 = 0.0, $50 = 0.0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $54 = 0.0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0;
 var $61 = 0.0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0.0, $7 = 0, $70 = 0.0, $71 = 0.0, $72 = 0.0, $73 = 0.0, $74 = 0, $75 = 0, $76 = 0.0, $77 = 0.0, $78 = 0.0, $79 = 0.0;
 var $8 = 0.0, $80 = 0.0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0.0, $90 = 0, $91 = 0.0, $92 = 0.0, $93 = 0, $94 = 0.0, $95 = 0.0, $96 = 0, $97 = 0;
 var $98 = 0.0, $99 = 0.0, $b_frq = 0, $bo_w$0 = 0.0, $exitcond = 0, $exitcond17 = 0, $exitcond18 = 0, $i$29 = 0, $i$36 = 0, $j$0 = 0, $j$1$lcssa = 0, $j$112 = 0, $j$2 = 0, $j$38 = 0, $j2$0 = 0, $j2$0$lcssa = 0, $ni$0 = 0, $ni$1 = 0, $or$cond = 0, $partition = 0;
 var $sfb$05 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 2320|0;
 $b_frq = sp + 2052|0;
 $partition = sp;
 $0 = (+($mdct_size|0));
 $1 = $0 * 2.0;
 $2 = $sfreq / $1;
 $3 = (+($fft_size|0));
 $4 = $3 / $1;
 _memset(($partition|0),0,2052)|0;
 $5 = $sfreq / $3;
 $6 = (($fft_size|0) / 2)&-1;
 $j$0 = 0;$ni$0 = 0;
 while(1) {
  $7 = ($ni$0|0)<(64);
  if (!($7)) {
   $j$2 = $j$0;$ni$1 = $ni$0;
   break;
  }
  $8 = (+($j$0|0));
  $9 = $8 * $5;
  $10 = (+_freq2bark($9));
  $11 = (($b_frq) + ($ni$0<<2)|0);
  HEAPF32[$11>>2] = $9;
  $j2$0 = $j$0;
  while(1) {
   $12 = (+($j2$0|0));
   $13 = $12 * $5;
   $14 = (+_freq2bark($13));
   $15 = $14 - $10;
   $16 = $15;
   $17 = !($16 < 0.34000000000000002);
   $18 = ($j2$0|0)>($6|0);
   $or$cond = $18 | $17;
   $19 = (($j2$0) + 1)|0;
   if ($or$cond) {
    $j2$0$lcssa = $j2$0;
    break;
   } else {
    $j2$0 = $19;
   }
  }
  $20 = (($j2$0$lcssa) - ($j$0))|0;
  $21 = (((($gd)) + 1716|0) + ($ni$0<<2)|0);
  HEAP32[$21>>2] = $20;
  $22 = ($20|0)>(0);
  $23 = (+($20|0));
  $24 = 1.0 / $23;
  $25 = $22 ? $24 : 0.0;
  $26 = (((($gd)) + 512|0) + ($ni$0<<2)|0);
  HEAPF32[$26>>2] = $25;
  $27 = (($ni$0) + 1)|0;
  $28 = ($j2$0$lcssa|0)>($j$0|0);
  if ($28) {
   $j$112 = $j$0;
   while(1) {
    $29 = (($j$112) + 1)|0;
    $30 = (($partition) + ($j$112<<2)|0);
    HEAP32[$30>>2] = $ni$0;
    $exitcond18 = ($29|0)==($j2$0$lcssa|0);
    if ($exitcond18) {
     $j$1$lcssa = $j2$0$lcssa;
     break;
    } else {
     $j$112 = $29;
    }
   }
  } else {
   $j$1$lcssa = $j$0;
  }
  $31 = ($j$1$lcssa|0)>($6|0);
  if ($31) {
   $j$2 = $6;$ni$1 = $27;
   break;
  } else {
   $j$0 = $j$1$lcssa;$ni$0 = $27;
  }
 }
 $32 = (+($j$2|0));
 $33 = $32 * $5;
 $34 = (($b_frq) + ($ni$1<<2)|0);
 HEAPF32[$34>>2] = $33;
 $35 = ((($gd)) + 2152|0);
 HEAP32[$35>>2] = $sbmax;
 $36 = ((($gd)) + 2148|0);
 HEAP32[$36>>2] = $ni$1;
 $37 = ($ni$1|0)>(0);
 if ($37) {
  $i$29 = 0;$j$38 = 0;
  while(1) {
   $39 = (((($gd)) + 1716|0) + ($i$29<<2)|0);
   $40 = HEAP32[$39>>2]|0;
   $41 = (($40|0) / 2)&-1;
   $42 = (($41) + ($j$38))|0;
   $43 = (+($42|0));
   $44 = $43 * $5;
   $45 = (+_freq2bark($44));
   $46 = $45;
   $47 = $45 < 15.5;
   $$op$op$i = $46 * 0.2026833970057931;
   $48 = $47 ? $$op$op$i : 3.1415926535897931;
   $49 = (+Math_cos((+$48)));
   $50 = 1.0 - $49;
   $51 = $50 * 1.25;
   $52 = $51 + -2.5;
   $53 = (+Math_pow(10.0,(+$52)));
   $54 = $53;
   $55 = (((($gd)) + 768|0) + ($i$29<<2)|0);
   HEAPF32[$55>>2] = $54;
   $56 = (($40) + ($j$38))|0;
   $57 = (($i$29) + 1)|0;
   $58 = HEAP32[$36>>2]|0;
   $59 = ($57|0)<($58|0);
   if ($59) {
    $i$29 = $57;$j$38 = $56;
   } else {
    $$lcssa = $57;
    break;
   }
  }
  $38 = ($$lcssa|0)<(64);
  if ($38) {
   $i$36 = $$lcssa;
   label = 13;
  }
 } else {
  $i$36 = 0;
  label = 13;
 }
 if ((label|0) == 13) {
  while(1) {
   label = 0;
   $62 = (((($gd)) + 768|0) + ($i$36<<2)|0);
   HEAPF32[$62>>2] = 1.0;
   $63 = (($i$36) + 1)|0;
   $exitcond17 = ($63|0)==(64);
   if ($exitcond17) {
    break;
   } else {
    $i$36 = $63;
    label = 13;
   }
  }
 }
 $60 = ($sbmax|0)>(0);
 if (!($60)) {
  STACKTOP = sp;return;
 }
 $61 = $4;
 $sfb$05 = 0;
 while(1) {
  $64 = (($scalepos) + ($sfb$05<<2)|0);
  $65 = HEAP32[$64>>2]|0;
  $66 = (($sfb$05) + 1)|0;
  $67 = (($scalepos) + ($66<<2)|0);
  $68 = HEAP32[$67>>2]|0;
  $69 = (+($65|0));
  $70 = $69 + -0.5;
  $71 = $70 * $61;
  $72 = $71 + 0.5;
  $73 = (+Math_floor((+$72)));
  $74 = (~~(($73)));
  $75 = ($74|0)<(0);
  $$ = $75 ? 0 : $74;
  $76 = (+($68|0));
  $77 = $76 + -0.5;
  $78 = $77 * $61;
  $79 = $78 + 0.5;
  $80 = (+Math_floor((+$79)));
  $81 = (~~(($80)));
  $82 = ($81|0)>($6|0);
  $$2 = $82 ? $6 : $81;
  $83 = (($partition) + ($$2<<2)|0);
  $84 = HEAP32[$83>>2]|0;
  $85 = (($partition) + ($$<<2)|0);
  $86 = HEAP32[$85>>2]|0;
  $87 = (($86) + ($84))|0;
  $88 = (($87|0) / 2)&-1;
  $89 = (((($gd)) + 1972|0) + ($sfb$05<<2)|0);
  HEAP32[$89>>2] = $88;
  $90 = (((($gd)) + 2060|0) + ($sfb$05<<2)|0);
  HEAP32[$90>>2] = $84;
  $91 = (+($68|0));
  $92 = $91 * $2;
  $93 = (($b_frq) + ($84<<2)|0);
  $94 = +HEAPF32[$93>>2];
  $95 = $92 - $94;
  $96 = (($84) + 1)|0;
  $97 = (($b_frq) + ($96<<2)|0);
  $98 = +HEAPF32[$97>>2];
  $99 = $98 - $94;
  $100 = $95 / $99;
  $101 = $100 < 0.0;
  if ($101) {
   $bo_w$0 = 0.0;
  } else {
   $102 = $100 > 1.0;
   if ($102) {
    $bo_w$0 = 1.0;
   } else {
    $bo_w$0 = $100;
   }
  }
  $103 = (((($gd)) + 1112|0) + ($sfb$05<<2)|0);
  HEAPF32[$103>>2] = $bo_w$0;
  $104 = (+($65|0));
  $105 = $104 * $2;
  $106 = (+_freq2bark($105));
  $107 = $106;
  $108 = $106 < 15.5;
  $$op$op$i3 = $107 * 0.2026833970057931;
  $109 = $108 ? $$op$op$i3 : 3.1415926535897931;
  $110 = (+Math_cos((+$109)));
  $111 = 1.0 - $110;
  $112 = $111 * 1.25;
  $113 = $112 + -2.5;
  $114 = (+Math_pow(10.0,(+$113)));
  $115 = $114;
  $116 = (((($gd)) + 1024|0) + ($sfb$05<<2)|0);
  HEAPF32[$116>>2] = $115;
  $exitcond = ($66|0)==($sbmax|0);
  if ($exitcond) {
   break;
  } else {
   $sfb$05 = $66;
  }
 }
 STACKTOP = sp;return;
}
function _init_s3_values($p,$s3ind,$npart,$bval,$bval_width,$norm) {
 $p = $p|0;
 $s3ind = $s3ind|0;
 $npart = $npart|0;
 $bval = $bval|0;
 $bval_width = $bval_width|0;
 $norm = $norm|0;
 var $$0 = 0, $$0$i = 0.0, $$lcssa = 0, $$mux = 0, $$not = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0.0, $20 = 0.0, $21 = 0.0;
 var $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0.0;
 var $40 = 0.0, $41 = 0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0.0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0.0, $58 = 0;
 var $59 = 0, $6 = 0.0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0.0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0;
 var $77 = 0, $8 = 0, $9 = 0.0, $brmerge = 0, $exitcond = 0, $exitcond34 = 0, $exitcond35 = 0, $exitcond36 = 0, $i$024 = 0, $i$117 = 0, $i$27 = 0, $j$021 = 0, $j$111 = 0, $j$2 = 0, $j$2$in = 0, $j$2$in$lcssa = 0, $j$2$lcssa = 0, $k$09 = 0, $k$1$lcssa = 0, $numberOfNoneZero$0$lcssa = 0;
 var $numberOfNoneZero$018 = 0, $or$cond$i = 0, $phitmp = 0, $s3 = 0, $scevgep = 0, $scevgep31 = 0, $tempx$0$i = 0.0, $tempx$0$v$i = 0.0, $x$0$i = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16384|0;
 $s3 = sp;
 _memset(($s3|0),0,16384)|0;
 $0 = ($npart|0)>(0);
 if ($0) {
  $i$024 = 0;
  while(1) {
   $1 = (($bval) + ($i$024<<2)|0);
   $2 = +HEAPF32[$1>>2];
   $3 = (($norm) + ($i$024<<2)|0);
   $4 = +HEAPF32[$3>>2];
   $j$021 = 0;
   while(1) {
    $5 = (($bval) + ($j$021<<2)|0);
    $6 = +HEAPF32[$5>>2];
    $7 = $2 - $6;
    $8 = !($7 >= 0.0);
    $tempx$0$v$i = $8 ? 1.5 : 3.0;
    $tempx$0$i = $7 * $tempx$0$v$i;
    $9 = $tempx$0$i;
    $10 = !($tempx$0$i >= 0.5);
    $11 = !($tempx$0$i <= 2.5);
    $or$cond$i = $10 | $11;
    if ($or$cond$i) {
     $x$0$i = 0.0;
    } else {
     $12 = $tempx$0$i + -0.5;
     $13 = $12 * $12;
     $14 = $13;
     $15 = $12;
     $16 = $15 * 2.0;
     $17 = $14 - $16;
     $18 = $17 * 8.0;
     $19 = $18;
     $x$0$i = $19;
    }
    $20 = $9 + 0.47399999999999998;
    $21 = $20;
    $22 = $21;
    $23 = $22 * 7.5;
    $24 = $23 + 15.811389;
    $25 = $21 * $21;
    $26 = $25;
    $27 = $26 + 1.0;
    $28 = (+Math_sqrt((+$27)));
    $29 = $28 * 17.5;
    $30 = $24 - $29;
    $31 = $30;
    $32 = !($31 <= -60.0);
    if ($32) {
     $33 = $31 + $x$0$i;
     $34 = $33;
     $35 = $34 * 0.23025850929940458;
     $36 = (+Math_exp((+$35)));
     $37 = $36;
     $38 = $37;
     $39 = $38 * 1.5130440282194817;
     $40 = $39;
     $$0$i = $40;
    } else {
     $$0$i = 0.0;
    }
    $41 = (($bval_width) + ($j$021<<2)|0);
    $42 = +HEAPF32[$41>>2];
    $43 = $42 * $$0$i;
    $44 = $43 * $4;
    $45 = ((($s3) + ($i$024<<8)|0) + ($j$021<<2)|0);
    HEAPF32[$45>>2] = $44;
    $46 = (($j$021) + 1)|0;
    $exitcond35 = ($46|0)==($npart|0);
    if ($exitcond35) {
     break;
    } else {
     $j$021 = $46;
    }
   }
   $47 = (($i$024) + 1)|0;
   $exitcond36 = ($47|0)==($npart|0);
   if ($exitcond36) {
    break;
   } else {
    $i$024 = $47;
   }
  }
  if ($0) {
   $i$117 = 0;$numberOfNoneZero$018 = 0;
   while(1) {
    $j$111 = 0;
    while(1) {
     $48 = ((($s3) + ($i$117<<8)|0) + ($j$111<<2)|0);
     $49 = +HEAPF32[$48>>2];
     $50 = $49 > 0.0;
     if ($50) {
      $54 = $j$111;
      break;
     }
     $51 = (($j$111) + 1)|0;
     $52 = ($51|0)<($npart|0);
     if ($52) {
      $j$111 = $51;
     } else {
      $54 = $51;
      break;
     }
    }
    $53 = (($s3ind) + ($i$117<<3)|0);
    HEAP32[$53>>2] = $54;
    $j$2$in = $npart;
    while(1) {
     $j$2 = (($j$2$in) + -1)|0;
     $55 = ($j$2$in|0)>(1);
     if (!($55)) {
      $j$2$in$lcssa = $j$2$in;$j$2$lcssa = $j$2;
      break;
     }
     $56 = ((($s3) + ($i$117<<8)|0) + ($j$2<<2)|0);
     $57 = +HEAPF32[$56>>2];
     $58 = $57 > 0.0;
     if ($58) {
      $j$2$in$lcssa = $j$2$in;$j$2$lcssa = $j$2;
      break;
     } else {
      $j$2$in = $j$2;
     }
    }
    $59 = (((($s3ind) + ($i$117<<3)|0)) + 4|0);
    HEAP32[$59>>2] = $j$2$lcssa;
    $60 = (($numberOfNoneZero$018) + ($j$2$in$lcssa))|0;
    $61 = (($60) - ($54))|0;
    $62 = (($i$117) + 1)|0;
    $exitcond34 = ($62|0)==($npart|0);
    if ($exitcond34) {
     $$lcssa = $61;
     break;
    } else {
     $i$117 = $62;$numberOfNoneZero$018 = $61;
    }
   }
   $phitmp = $$lcssa << 2;
   $numberOfNoneZero$0$lcssa = $phitmp;
  } else {
   $numberOfNoneZero$0$lcssa = 0;
  }
 } else {
  $numberOfNoneZero$0$lcssa = 0;
 }
 $63 = (_malloc($numberOfNoneZero$0$lcssa)|0);
 HEAP32[$p>>2] = $63;
 $64 = ($63|0)==(0|0);
 $$not = $0 ^ 1;
 $brmerge = $64 | $$not;
 $$mux = $64 << 31 >> 31;
 if ($brmerge) {
  $$0 = $$mux;
  STACKTOP = sp;return ($$0|0);
 } else {
  $i$27 = 0;$k$09 = 0;
 }
 while(1) {
  $65 = (($s3ind) + ($i$27<<3)|0);
  $66 = HEAP32[$65>>2]|0;
  $67 = (((($s3ind) + ($i$27<<3)|0)) + 4|0);
  $68 = HEAP32[$67>>2]|0;
  $69 = ($66|0)>($68|0);
  if ($69) {
   $k$1$lcssa = $k$09;
  } else {
   $70 = HEAP32[$p>>2]|0;
   $71 = (($k$09) + 1)|0;
   $72 = (($71) + ($68))|0;
   $scevgep = (($70) + ($k$09<<2)|0);
   $scevgep31 = ((($s3) + ($i$27<<8)|0) + ($66<<2)|0);
   $73 = (($68) + 1)|0;
   $74 = (($73) - ($66))|0;
   $75 = $74 << 2;
   _memcpy(($scevgep|0),($scevgep31|0),($75|0))|0;
   $76 = (($72) - ($66))|0;
   $k$1$lcssa = $76;
  }
  $77 = (($i$27) + 1)|0;
  $exitcond = ($77|0)==($npart|0);
  if ($exitcond) {
   $$0 = 0;
   break;
  } else {
   $i$27 = $77;$k$09 = $k$1$lcssa;
  }
 }
 STACKTOP = sp;return ($$0|0);
}
function _init_xrpow_core_init($gfc) {
 $gfc = $gfc|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $init_xrpow_core_c$init_xrpow_core_sse = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gfc)) + 85824|0);
 $1 = ((($gfc)) + 85756|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = $2 & 4;
 $4 = ($3|0)==(0);
 $init_xrpow_core_c$init_xrpow_core_sse = $4 ? 6 : 5;
 HEAP32[$0>>2] = $init_xrpow_core_c$init_xrpow_core_sse;
 return;
}
function _VBR_old_iteration_loop($gfc,$pe,$ms_ener_ratio,$ratio) {
 $gfc = $gfc|0;
 $pe = $pe|0;
 $ms_ener_ratio = $ms_ener_ratio|0;
 $ratio = $ratio|0;
 var $$$i = 0, $$$i6 = 0.0, $$0$i1 = 0, $$01$i = 0, $$1$i = 0, $$12$i = 0, $$lcssa = 0, $$lcssa63 = 0, $$lobit$i = 0, $$pre$i = 0, $$pre$phiZ2D = 0, $$pre$pre = 0, $$pre$pre$pre = 0, $$pre29$i = 0, $$pre29$i$lcssa = 0, $$pre34 = 0, $$pre35 = 0, $$pre38 = 0, $0 = 0, $1 = 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0;
 var $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0.0, $132 = 0, $133 = 0, $134 = 0, $135 = 0;
 var $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0;
 var $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0;
 var $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0;
 var $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0.0, $206 = 0.0, $207 = 0.0;
 var $208 = 0.0, $209 = 0, $21 = 0, $210 = 0.0, $211 = 0.0, $212 = 0.0, $213 = 0.0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0.0, $222 = 0.0, $223 = 0.0, $224 = 0.0, $225 = 0;
 var $226 = 0.0, $227 = 0.0, $228 = 0.0, $229 = 0.0, $23 = 0, $230 = 0, $231 = 0.0, $232 = 0.0, $233 = 0.0, $234 = 0.0, $235 = 0, $236 = 0.0, $237 = 0.0, $238 = 0.0, $239 = 0.0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0.0;
 var $244 = 0, $245 = 0, $246 = 0.0, $247 = 0.0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0;
 var $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0;
 var $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0.0, $5 = 0, $50 = 0, $51 = 0.0, $52 = 0.0;
 var $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0, $57 = 0, $58 = 0.0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0.0;
 var $71 = 0.0, $72 = 0.0, $73 = 0.0, $74 = 0.0, $75 = 0.0, $76 = 0.0, $77 = 0.0, $78 = 0.0, $79 = 0.0, $8 = 0, $80 = 0.0, $81 = 0.0, $82 = 0.0, $83 = 0.0, $84 = 0.0, $85 = 0.0, $86 = 0.0, $87 = 0, $88 = 0, $89 = 0;
 var $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $analog_silence$0$lcssa34$i = 0, $analog_silence$023$i = 0, $analog_silence$1$$i = 0, $analog_silence$1$lcssa$i = 0, $analog_silence$1$lcssa$i$lcssa = 0, $analog_silence$115$i = 0, $bits$024$i = 0, $bits$1$lcssa$i = 0, $bits$1$lcssa$i$lcssa = 0;
 var $bits$116$i = 0, $bst_cod_info$i = 0, $bst_xrpow$i = 0, $ch$014$i = 0, $ch$022 = 0, $ch$07$i = 0, $ch$115 = 0, $ch$16$i = 0, $ch$16$us$us$i = 0, $dbits$0$i = 0, $exitcond = 0, $exitcond$i = 0, $exitcond$i$i = 0, $found$0$i = 0, $found$1$i = 0, $found$1$i$lcssa = 0, $frameBits = 0, $gr$0 = 0, $gr$010$i = 0, $gr$020$i = 0;
 var $gr$116 = 0, $gr$17$i = 0, $gr$17$us$i = 0, $i$01$i = 0, $i$01$i$i = 0, $i$01$i2$i = 0, $indvars$iv$i = 0, $indvars$iv13$i = 0, $l3_xmin = 0, $masking_lower_db$0$i = 0.0, $max_bits = 0, $mean_bits = 0, $min_bits = 0, $pxmin$0$lcssa$i = 0, $pxmin$02$i = 0, $pxmin$14$i = 0, $scevgep$i = 0, $scevgep14$i = 0, $scevgep15$i = 0, $sfb$01$i = 0;
 var $sfb$13$i = 0, $smax$i = 0, $storemerge = 0, $this_bits$0$i = 0, $this_bits$1$i = 0, $used_bits$0 = 0, $used_bits$1$lcssa = 0, $used_bits$124 = 0, $used_bits$2 = 0, $used_bits$2$lcssa = 0, $xrpow = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 10592|0;
 $bst_cod_info$i = sp + 5336|0;
 $bst_xrpow$i = sp + 3032|0;
 $l3_xmin = sp + 2408|0;
 $xrpow = sp + 104|0;
 $frameBits = sp + 40|0;
 $min_bits = sp + 24|0;
 $max_bits = sp + 8|0;
 $mean_bits = sp;
 $0 = ((($gfc)) + 116|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ((($gfc)) + 84744|0);
 HEAP32[$2>>2] = $1;
 $3 = (_ResvFrameBegin($gfc,$bst_xrpow$i)|0);
 $4 = ((($gfc)) + 76|0);
 $5 = HEAP32[$4>>2]|0;
 $6 = (($3|0) / ($5|0))&-1;
 HEAP32[$bst_xrpow$i>>2] = $6;
 $7 = ((($gfc)) + 112|0);
 $8 = HEAP32[$7>>2]|0;
 HEAP32[$2>>2] = $8;
 HEAP32[$2>>2] = 1;
 $9 = (_getframebits($gfc)|0);
 HEAP32[$bst_cod_info$i>>2] = $9;
 $10 = HEAP32[$0>>2]|0;
 $11 = ($10|0)<(1);
 if (!($11)) {
  $i$01$i$i = 1;
  while(1) {
   HEAP32[$2>>2] = $i$01$i$i;
   $12 = (_ResvFrameBegin($gfc,$bst_cod_info$i)|0);
   $13 = (($frameBits) + ($i$01$i$i<<2)|0);
   HEAP32[$13>>2] = $12;
   $14 = (($i$01$i$i) + 1)|0;
   $15 = HEAP32[$0>>2]|0;
   $16 = ($i$01$i$i|0)<($15|0);
   if ($16) {
    $i$01$i$i = $14;
   } else {
    break;
   }
  }
 }
 $17 = HEAP32[$4>>2]|0;
 $18 = ($17|0)>(0);
 L5: do {
  if ($18) {
   $19 = ((($gfc)) + 84756|0);
   $20 = ((($gfc)) + 72|0);
   $21 = ((($gfc)) + 84916|0);
   $22 = ((($gfc)) + 84908|0);
   $23 = ((($gfc)) + 84912|0);
   $analog_silence$023$i = 1;$bits$024$i = 0;$gr$020$i = 0;
   while(1) {
    $43 = (($max_bits) + ($gr$020$i<<3)|0);
    $44 = HEAP32[$bst_xrpow$i>>2]|0;
    $45 = (_on_pe($gfc,$pe,$43,$44,$gr$020$i,0)|0);
    $46 = HEAP32[$19>>2]|0;
    $47 = ($46|0)==(2);
    if ($47) {
     $i$01$i2$i = 0;
     while(1) {
      $48 = ((((($gfc)) + 304|0) + (($gr$020$i*10504)|0)|0) + ($i$01$i2$i<<2)|0);
      $49 = +HEAPF32[$48>>2];
      $50 = ((((((($gfc)) + 304|0) + (($gr$020$i*10504)|0)|0)) + 5252|0) + ($i$01$i2$i<<2)|0);
      $51 = +HEAPF32[$50>>2];
      $52 = $51 + $49;
      $53 = $52 * 0.70710676908493042;
      HEAPF32[$48>>2] = $53;
      $54 = $49 - $51;
      $55 = $54 * 0.70710676908493042;
      HEAPF32[$50>>2] = $55;
      $56 = (($i$01$i2$i) + 1)|0;
      $exitcond$i$i = ($56|0)==(576);
      if ($exitcond$i$i) {
       break;
      } else {
       $i$01$i2$i = $56;
      }
     }
     $57 = (($ms_ener_ratio) + ($gr$020$i<<2)|0);
     $58 = +HEAPF32[$57>>2];
     $59 = HEAP32[$bst_xrpow$i>>2]|0;
     _reduce_side($43,$58,$59,$45);
    }
    $60 = HEAP32[$20>>2]|0;
    $61 = ($60|0)>(0);
    if ($61) {
     $analog_silence$115$i = $analog_silence$023$i;$bits$116$i = $bits$024$i;$ch$014$i = 0;
     while(1) {
      $62 = ((((($gfc)) + 304|0) + (($gr$020$i*10504)|0)|0) + (($ch$014$i*5252)|0)|0);
      $63 = ((((((($gfc)) + 304|0) + (($gr$020$i*10504)|0)|0) + (($ch$014$i*5252)|0)|0)) + 4788|0);
      $64 = HEAP32[$63>>2]|0;
      $65 = ($64|0)==(2);
      $66 = ((($pe) + ($gr$020$i<<3)|0) + ($ch$014$i<<2)|0);
      $67 = +HEAPF32[$66>>2];
      $68 = $67;
      $69 = $68 * 0.0033333333333333335;
      $70 = 3.5 - $69;
      $71 = (+Math_exp((+$70)));
      $72 = $71 + 1.0;
      if ($65) {
       $78 = 2.5600000000000001 / $72;
       $79 = $78 + -0.14000000000000001;
       $80 = $79;
       $81 = +HEAPF32[$21>>2];
       $82 = $81 - $80;
       $masking_lower_db$0$i = $82;
      } else {
       $73 = 1.28 / $72;
       $74 = $73 + -0.050000000000000003;
       $75 = $74;
       $76 = +HEAPF32[$23>>2];
       $77 = $76 - $75;
       $masking_lower_db$0$i = $77;
      }
      $83 = $masking_lower_db$0$i;
      $84 = $83 * 0.10000000000000001;
      $85 = (+Math_pow(10.0,(+$84)));
      $86 = $85;
      HEAPF32[$22>>2] = $86;
      _init_outer_loop($gfc,$62);
      $87 = ((($ratio) + (($gr$020$i*976)|0)|0) + (($ch$014$i*488)|0)|0);
      $88 = ((($l3_xmin) + (($gr$020$i*312)|0)|0) + (($ch$014$i*156)|0)|0);
      $89 = (_calc_xmin($gfc,$87,$62,$88)|0);
      $90 = ($89|0)==(0);
      $analog_silence$1$$i = $90 ? $analog_silence$115$i : 0;
      $91 = ((($min_bits) + ($gr$020$i<<3)|0) + ($ch$014$i<<2)|0);
      HEAP32[$91>>2] = 126;
      $92 = ((($max_bits) + ($gr$020$i<<3)|0) + ($ch$014$i<<2)|0);
      $93 = HEAP32[$92>>2]|0;
      $94 = (($93) + ($bits$116$i))|0;
      $95 = (($ch$014$i) + 1)|0;
      $96 = HEAP32[$20>>2]|0;
      $97 = ($95|0)<($96|0);
      if ($97) {
       $analog_silence$115$i = $analog_silence$1$$i;$bits$116$i = $94;$ch$014$i = $95;
      } else {
       $$pre29$i = $96;$analog_silence$1$lcssa$i = $analog_silence$1$$i;$bits$1$lcssa$i = $94;
       break;
      }
     }
    } else {
     $$pre29$i = $60;$analog_silence$1$lcssa$i = $analog_silence$023$i;$bits$1$lcssa$i = $bits$024$i;
    }
    $98 = (($gr$020$i) + 1)|0;
    $99 = HEAP32[$4>>2]|0;
    $100 = ($98|0)<($99|0);
    if ($100) {
     $analog_silence$023$i = $analog_silence$1$lcssa$i;$bits$024$i = $bits$1$lcssa$i;$gr$020$i = $98;
    } else {
     $$lcssa63 = $99;$$pre29$i$lcssa = $$pre29$i;$analog_silence$1$lcssa$i$lcssa = $analog_silence$1$lcssa$i;$bits$1$lcssa$i$lcssa = $bits$1$lcssa$i;
     break;
    }
   }
   $24 = ($$lcssa63|0)>(0);
   if ($24) {
    $25 = ($bits$1$lcssa$i$lcssa|0)>(0);
    if (!($25)) {
     $101 = $$pre29$i$lcssa;$267 = $$pre29$i$lcssa;$gr$17$i = 0;
     while(1) {
      $102 = ($101|0)>(0);
      if ($102) {
       $268 = $267;$ch$16$i = 0;
       while(1) {
        $103 = ((($min_bits) + ($gr$17$i<<3)|0) + ($ch$16$i<<2)|0);
        $104 = HEAP32[$103>>2]|0;
        $105 = ((($max_bits) + ($gr$17$i<<3)|0) + ($ch$16$i<<2)|0);
        $106 = HEAP32[$105>>2]|0;
        $107 = ($104|0)>($106|0);
        if ($107) {
         HEAP32[$103>>2] = $106;
         $110 = $$pre29$i$lcssa;
        } else {
         $110 = $268;
        }
        $108 = (($ch$16$i) + 1)|0;
        $109 = ($108|0)<($110|0);
        if ($109) {
         $268 = $110;$ch$16$i = $108;
        } else {
         $269 = $110;$270 = $110;
         break;
        }
       }
      } else {
       $269 = $267;$270 = $101;
      }
      $111 = (($gr$17$i) + 1)|0;
      $112 = ($111|0)<($$lcssa63|0);
      if ($112) {
       $101 = $270;$267 = $269;$gr$17$i = $111;
      } else {
       $$pre$phiZ2D = $20;$266 = $$lcssa63;$analog_silence$0$lcssa34$i = $analog_silence$1$lcssa$i$lcssa;
       break L5;
      }
     }
    }
    $26 = ($$pre29$i$lcssa|0)>(0);
    $gr$17$us$i = 0;
    while(1) {
     if ($26) {
      $27 = HEAP32[$0>>2]|0;
      $28 = (($frameBits) + ($27<<2)|0);
      $29 = HEAP32[$28>>2]|0;
      $30 = ($bits$1$lcssa$i$lcssa|0)>($29|0);
      $ch$16$us$us$i = 0;
      while(1) {
       $33 = ((($max_bits) + ($gr$17$us$i<<3)|0) + ($ch$16$us$us$i<<2)|0);
       $34 = HEAP32[$33>>2]|0;
       if ($30) {
        $35 = Math_imul($34, $29)|0;
        $36 = (($35|0) / ($bits$1$lcssa$i$lcssa|0))&-1;
        HEAP32[$33>>2] = $36;
        $40 = $36;
       } else {
        $40 = $34;
       }
       $37 = ((($min_bits) + ($gr$17$us$i<<3)|0) + ($ch$16$us$us$i<<2)|0);
       $38 = HEAP32[$37>>2]|0;
       $39 = ($38|0)>($40|0);
       if ($39) {
        HEAP32[$37>>2] = $40;
       }
       $41 = (($ch$16$us$us$i) + 1)|0;
       $42 = ($41|0)<($$pre29$i$lcssa|0);
       if ($42) {
        $ch$16$us$us$i = $41;
       } else {
        break;
       }
      }
     }
     $31 = (($gr$17$us$i) + 1)|0;
     $32 = ($31|0)<($$lcssa63|0);
     if ($32) {
      $gr$17$us$i = $31;
     } else {
      $$pre$phiZ2D = $20;$266 = $$lcssa63;$analog_silence$0$lcssa34$i = $analog_silence$1$lcssa$i$lcssa;
      break;
     }
    }
   } else {
    $$pre$phiZ2D = $20;$266 = $$lcssa63;$analog_silence$0$lcssa34$i = $analog_silence$1$lcssa$i$lcssa;
   }
  } else {
   $$pre38 = ((($gfc)) + 72|0);
   $$pre$phiZ2D = $$pre38;$266 = $17;$analog_silence$0$lcssa34$i = 1;
  }
 } while(0);
 $113 = ($analog_silence$0$lcssa34$i|0)==(0);
 $114 = ((($gfc)) + 124|0);
 $115 = ((($gfc)) + 85824|0);
 $116 = ((($gfc)) + 85096|0);
 $117 = ((($gfc)) + 85092|0);
 $118 = ((($bst_cod_info$i)) + 2304|0);
 $120 = $266;$gr$0 = 0;$used_bits$0 = 0;
 L50: while(1) {
  $119 = ($gr$0|0)<($120|0);
  if (!($119)) {
   if ($113) {
    label = 55;
   } else {
    $182 = HEAP32[$114>>2]|0;
    $183 = ($182|0)==(0);
    if ($183) {
     $storemerge = 1;
    } else {
     label = 55;
    }
   }
   if ((label|0) == 55) {
    label = 0;
    $184 = HEAP32[$7>>2]|0;
    $storemerge = $184;
   }
   HEAP32[$2>>2] = $storemerge;
   $185 = HEAP32[$0>>2]|0;
   $186 = ($storemerge|0)<($185|0);
   L59: do {
    if ($186) {
     $188 = $storemerge;
     while(1) {
      $187 = (($frameBits) + ($188<<2)|0);
      $189 = HEAP32[$187>>2]|0;
      $190 = ($used_bits$0|0)>($189|0);
      if (!($190)) {
       break L59;
      }
      $191 = (($188) + 1)|0;
      HEAP32[$2>>2] = $191;
      $192 = ($191|0)<($185|0);
      if ($192) {
       $188 = $191;
      } else {
       break;
      }
     }
    }
   } while(0);
   $193 = (_ResvFrameBegin($gfc,$mean_bits)|0);
   $194 = ($used_bits$0|0)>($193|0);
   $195 = HEAP32[$4>>2]|0;
   $196 = ($195|0)>(0);
   if (!($194)) {
    break;
   }
   if (!($196)) {
    $120 = $195;$gr$0 = 0;$used_bits$0 = 0;
    continue;
   }
   $$pre$i = HEAP32[$$pre$phiZ2D>>2]|0;
   $199 = ($$pre$i|0)>(0);
   $gr$010$i = 0;$indvars$iv$i = $l3_xmin;
   while(1) {
    if ($199) {
     $ch$07$i = 0;$indvars$iv13$i = $indvars$iv$i;
     while(1) {
      $200 = ((($l3_xmin) + (($gr$010$i*312)|0)|0) + (($ch$07$i*156)|0)|0);
      $201 = ((((((($gfc)) + 304|0) + (($gr$010$i*10504)|0)|0) + (($ch$07$i*5252)|0)|0)) + 4856|0);
      $202 = HEAP32[$201>>2]|0;
      $203 = ($202|0)>(0);
      if ($203) {
       $204 = ($202|0)>(1);
       $pxmin$02$i = $200;$sfb$01$i = 0;
       while(1) {
        $205 = (+($sfb$01$i|0));
        $206 = $205 * $205;
        $207 = $206 * 5.9917355371900827E-5;
        $208 = $207 + 1.0;
        $209 = ((($pxmin$02$i)) + 4|0);
        $210 = +HEAPF32[$pxmin$02$i>>2];
        $211 = $210;
        $212 = $208 * $211;
        $213 = $212;
        HEAPF32[$pxmin$02$i>>2] = $213;
        $214 = (($sfb$01$i) + 1)|0;
        $exitcond = ($214|0)==($202|0);
        if ($exitcond) {
         break;
        } else {
         $pxmin$02$i = $209;$sfb$01$i = $214;
        }
       }
       $smax$i = $204 ? $202 : 1;
       $scevgep15$i = (($indvars$iv13$i) + ($smax$i<<2)|0);
       $pxmin$0$lcssa$i = $scevgep15$i;
      } else {
       $pxmin$0$lcssa$i = $200;
      }
      $215 = ((((((($gfc)) + 304|0) + (($gr$010$i*10504)|0)|0) + (($ch$07$i*5252)|0)|0)) + 4788|0);
      $216 = HEAP32[$215>>2]|0;
      $217 = ($216|0)==(2);
      if ($217) {
       $218 = ((((((($gfc)) + 304|0) + (($gr$010$i*10504)|0)|0) + (($ch$07$i*5252)|0)|0)) + 4852|0);
       $219 = HEAP32[$218>>2]|0;
       $220 = ($219|0)<(13);
       if ($220) {
        $pxmin$14$i = $pxmin$0$lcssa$i;$sfb$13$i = $219;
        while(1) {
         $221 = (+($sfb$13$i|0));
         $222 = $221 * $221;
         $223 = $222 * 1.7159763313609469E-4;
         $224 = $223 + 1.0;
         $225 = ((($pxmin$14$i)) + 4|0);
         $226 = +HEAPF32[$pxmin$14$i>>2];
         $227 = $226;
         $228 = $224 * $227;
         $229 = $228;
         HEAPF32[$pxmin$14$i>>2] = $229;
         $230 = ((($pxmin$14$i)) + 8|0);
         $231 = +HEAPF32[$225>>2];
         $232 = $231;
         $233 = $224 * $232;
         $234 = $233;
         HEAPF32[$225>>2] = $234;
         $235 = ((($pxmin$14$i)) + 12|0);
         $236 = +HEAPF32[$230>>2];
         $237 = $236;
         $238 = $237 * $224;
         $239 = $238;
         HEAPF32[$230>>2] = $239;
         $240 = (($sfb$13$i) + 1)|0;
         $exitcond$i = ($240|0)==(13);
         if ($exitcond$i) {
          break;
         } else {
          $pxmin$14$i = $235;$sfb$13$i = $240;
         }
        }
       }
      }
      $241 = ((($min_bits) + ($gr$010$i<<3)|0) + ($ch$07$i<<2)|0);
      $242 = HEAP32[$241>>2]|0;
      $243 = (+($242|0));
      $244 = ((($max_bits) + ($gr$010$i<<3)|0) + ($ch$07$i<<2)|0);
      $245 = HEAP32[$244>>2]|0;
      $246 = (+($245|0));
      $247 = $246 * 0.90000000000000002;
      $248 = $243 > $247;
      $$$i6 = $248 ? $243 : $247;
      $249 = (~~(($$$i6)));
      HEAP32[$244>>2] = $249;
      $250 = (($ch$07$i) + 1)|0;
      $251 = ($250|0)<($$pre$i|0);
      $scevgep14$i = ((($indvars$iv13$i)) + 156|0);
      if ($251) {
       $ch$07$i = $250;$indvars$iv13$i = $scevgep14$i;
      } else {
       break;
      }
     }
    }
    $252 = (($gr$010$i) + 1)|0;
    $253 = ($252|0)<($195|0);
    $scevgep$i = ((($indvars$iv$i)) + 312|0);
    if ($253) {
     $gr$010$i = $252;$indvars$iv$i = $scevgep$i;
    } else {
     $120 = $195;$gr$0 = 0;$used_bits$0 = 0;
     continue L50;
    }
   }
  }
  $121 = HEAP32[$$pre$phiZ2D>>2]|0;
  $122 = ($121|0)>(0);
  if ($122) {
   $ch$022 = 0;$used_bits$124 = $used_bits$0;
   while(1) {
    $123 = ((((($gfc)) + 304|0) + (($gr$0*10504)|0)|0) + (($ch$022*5252)|0)|0);
    HEAPF32[$bst_cod_info$i>>2] = 0.0;
    $124 = ((((((($gfc)) + 304|0) + (($gr$0*10504)|0)|0) + (($ch$022*5252)|0)|0)) + 5208|0);
    $125 = HEAP32[$124>>2]|0;
    $126 = ((((((($gfc)) + 304|0) + (($gr$0*10504)|0)|0) + (($ch$022*5252)|0)|0)) + 4764|0);
    HEAPF32[$126>>2] = 0.0;
    $127 = (($xrpow) + ($125<<2)|0);
    $128 = (576 - ($125))|0;
    $129 = $128 << 2;
    _memset(($127|0),0,($129|0))|0;
    $130 = HEAP32[$115>>2]|0;
    FUNCTION_TABLE_viiii[$130 & 7]($123,$xrpow,$125,$bst_cod_info$i);
    $131 = +HEAPF32[$bst_cod_info$i>>2];
    $132 = $131 > 9.9999996826552254E-21;
    if ($132) {
     $133 = HEAP32[$116>>2]|0;
     $134 = $133 >>> 1;
     $$lobit$i = $134 & 1;
     $135 = ((((((($gfc)) + 304|0) + (($gr$0*10504)|0)|0) + (($ch$022*5252)|0)|0)) + 4864|0);
     $136 = HEAP32[$135>>2]|0;
     $137 = ($136|0)>(0);
     if ($137) {
      $i$01$i = 0;
      while(1) {
       $138 = (((($gfc)) + 84936|0) + ($i$01$i<<2)|0);
       HEAP32[$138>>2] = $$lobit$i;
       $139 = (($i$01$i) + 1)|0;
       $140 = HEAP32[$135>>2]|0;
       $141 = ($139|0)<($140|0);
       if ($141) {
        $i$01$i = $139;
       } else {
        break;
       }
      }
     }
     $143 = ((($max_bits) + ($gr$0<<3)|0) + ($ch$022<<2)|0);
     $144 = HEAP32[$143>>2]|0;
     $145 = ($144|0)==(0);
     if ($145) {
      $used_bits$2 = $used_bits$124;
     } else {
      $146 = ((($l3_xmin) + (($gr$0*312)|0)|0) + (($ch$022*156)|0)|0);
      $147 = ((($min_bits) + ($gr$0<<3)|0) + ($ch$022<<2)|0);
      $148 = HEAP32[$147>>2]|0;
      $149 = (($148) + ($144))|0;
      $150 = (($149|0) / 2)&-1;
      $151 = HEAP32[$117>>2]|0;
      _memset(($118|0),0,2304)|0;
      $152 = (($144) + -42)|0;
      $153 = ((((((($gfc)) + 304|0) + (($gr$0*10504)|0)|0) + (($ch$022*5252)|0)|0)) + 4768|0);
      $$0$i1 = $148;$$01$i = $144;$found$0$i = 0;$this_bits$0$i = $150;
      while(1) {
       $154 = ($this_bits$0$i|0)>($152|0);
       $$$i = $154 ? 0 : $151;
       HEAP32[$117>>2] = $$$i;
       $155 = (_outer_loop($gfc,$123,$146,$xrpow,$ch$022,$this_bits$0$i)|0);
       $156 = ($155|0)<(1);
       if ($156) {
        $157 = HEAP32[$153>>2]|0;
        _memcpy(($bst_cod_info$i|0),($123|0),5252)|0;
        _memcpy(($bst_xrpow$i|0),($xrpow|0),2304)|0;
        $158 = (($157) + -32)|0;
        $159 = (($158) - ($$0$i1))|0;
        $160 = (($158) + ($$0$i1))|0;
        $161 = (($160|0) / 2)&-1;
        $$1$i = $$0$i1;$$12$i = $158;$dbits$0$i = $159;$found$1$i = 1;$this_bits$1$i = $161;
       } else {
        $162 = (($this_bits$0$i) + 32)|0;
        $163 = (($$01$i) - ($162))|0;
        $164 = (($$01$i) + ($162))|0;
        $165 = (($164|0) / 2)&-1;
        $166 = ($found$0$i|0)==(0);
        if ($166) {
         $$1$i = $162;$$12$i = $$01$i;$dbits$0$i = $163;$found$1$i = 0;$this_bits$1$i = $165;
        } else {
         _memcpy(($123|0),($bst_cod_info$i|0),5252)|0;
         _memcpy(($xrpow|0),($bst_xrpow$i|0),2304)|0;
         $$1$i = $162;$$12$i = $$01$i;$dbits$0$i = $163;$found$1$i = 2;$this_bits$1$i = $165;
        }
       }
       $167 = ($dbits$0$i|0)>(12);
       if ($167) {
        $$0$i1 = $$1$i;$$01$i = $$12$i;$found$0$i = $found$1$i;$this_bits$0$i = $this_bits$1$i;
       } else {
        $found$1$i$lcssa = $found$1$i;
        break;
       }
      }
      HEAP32[$117>>2] = $151;
      $168 = ($found$1$i$lcssa|0)==(2);
      if ($168) {
       $169 = ((((((($gfc)) + 304|0) + (($gr$0*10504)|0)|0) + (($ch$022*5252)|0)|0)) + 2304|0);
       _memcpy(($169|0),($118|0),2304)|0;
      }
      $170 = HEAP32[$116>>2]|0;
      $171 = $170 & 1;
      $172 = ($171|0)==(0);
      if (!($172)) {
       _trancate_smallspectrums($gfc,$123,$146,$xrpow);
      }
      $173 = HEAP32[$153>>2]|0;
      $174 = ((((((($gfc)) + 304|0) + (($gr$0*10504)|0)|0) + (($ch$022*5252)|0)|0)) + 4844|0);
      $175 = HEAP32[$174>>2]|0;
      $176 = (($173) + ($used_bits$124))|0;
      $177 = (($176) + ($175))|0;
      $used_bits$2 = $177;
     }
    } else {
     $142 = ((((((($gfc)) + 304|0) + (($gr$0*10504)|0)|0) + (($ch$022*5252)|0)|0)) + 2304|0);
     _memset(($142|0),0,2304)|0;
     $used_bits$2 = $used_bits$124;
    }
    $178 = (($ch$022) + 1)|0;
    $179 = HEAP32[$$pre$phiZ2D>>2]|0;
    $180 = ($178|0)<($179|0);
    if ($180) {
     $ch$022 = $178;$used_bits$124 = $used_bits$2;
    } else {
     $used_bits$2$lcssa = $used_bits$2;
     break;
    }
   }
   $$pre$pre$pre = HEAP32[$4>>2]|0;
   $$pre$pre = $$pre$pre$pre;$used_bits$1$lcssa = $used_bits$2$lcssa;
  } else {
   $$pre$pre = $120;$used_bits$1$lcssa = $used_bits$0;
  }
  $181 = (($gr$0) + 1)|0;
  $120 = $$pre$pre;$gr$0 = $181;$used_bits$0 = $used_bits$1$lcssa;
 }
 if (!($196)) {
  $265 = HEAP32[$mean_bits>>2]|0;
  _ResvFrameEnd($gfc,$265);
  STACKTOP = sp;return;
 }
 $197 = ((($gfc)) + 304|0);
 $198 = ((($gfc)) + 36|0);
 $$pre34 = HEAP32[$$pre$phiZ2D>>2]|0;
 $254 = $$pre34;$271 = $195;$gr$116 = 0;
 while(1) {
  $255 = ($254|0)>(0);
  if ($255) {
   $ch$115 = 0;
   while(1) {
    $256 = ((((($gfc)) + 304|0) + (($gr$116*10504)|0)|0) + (($ch$115*5252)|0)|0);
    _best_scalefac_store($gfc,$gr$116,$ch$115,$197);
    $257 = HEAP32[$198>>2]|0;
    $258 = ($257|0)==(1);
    if ($258) {
     _best_huffman_divide($gfc,$256);
    }
    _ResvAdjust($gfc,$256);
    $259 = (($ch$115) + 1)|0;
    $260 = HEAP32[$$pre$phiZ2D>>2]|0;
    $261 = ($259|0)<($260|0);
    if ($261) {
     $ch$115 = $259;
    } else {
     $$lcssa = $260;
     break;
    }
   }
   $$pre35 = HEAP32[$4>>2]|0;
   $264 = $$pre35;$272 = $$lcssa;
  } else {
   $264 = $271;$272 = $254;
  }
  $262 = (($gr$116) + 1)|0;
  $263 = ($262|0)<($264|0);
  if ($263) {
   $254 = $272;$271 = $264;$gr$116 = $262;
  } else {
   break;
  }
 }
 $265 = HEAP32[$mean_bits>>2]|0;
 _ResvFrameEnd($gfc,$265);
 STACKTOP = sp;return;
}
function _VBR_new_iteration_loop($gfc,$pe,$ms_ener_ratio,$ratio) {
 $gfc = $gfc|0;
 $pe = $pe|0;
 $ms_ener_ratio = $ms_ener_ratio|0;
 $ratio = $ratio|0;
 var $$i$0 = 0, $$lcssa = 0, $$lcssa65 = 0, $$lcssa69 = 0, $$lobit$i = 0, $$pre = 0, $$pre$i = 0, $$pre$i$lcssa = 0, $$pre44 = 0, $$pre45 = 0, $$pre46 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0;
 var $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0;
 var $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0;
 var $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0;
 var $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0.0, $41 = 0, $42 = 0.0;
 var $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0;
 var $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0;
 var $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0.0;
 var $98 = 0, $99 = 0, $analog_silence$0$lcssa2526$i = 0, $analog_silence$0$lcssa2527$i = 0, $analog_silence$014$i = 0, $analog_silence$1$$i = 0, $analog_silence$1$lcssa$i = 0, $analog_silence$1$lcssa$i$lcssa = 0, $analog_silence$110$i = 0, $avg$i = 0, $bits$015$i = 0, $bits$1$lcssa$i = 0, $bits$1$lcssa$i$lcssa = 0, $bits$111$i = 0, $ch$026 = 0, $ch$09$i = 0, $ch$15$i = 0, $ch$19 = 0, $exitcond$i$i = 0, $frameBits = 0;
 var $gr$016$i = 0, $gr$029 = 0, $gr$110 = 0, $gr$16$i = 0, $i$0$lcssa = 0, $i$0$ph = 0, $i$01$i = 0, $i$01$i$i = 0, $i$01$i2$i = 0, $i$018 = 0, $j$0$lcssa = 0, $j$013 = 0, $l3_xmin = 0, $max_bits = 0, $maximum_framebits$0$i = 0, $mean_bits = 0, $or$cond$i = 0, $sum$i = 0, $vararg_buffer = 0, $xrpow = 0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 9936|0;
 $vararg_buffer = sp;
 $sum$i = sp + 9932|0;
 $avg$i = sp + 9928|0;
 $l3_xmin = sp + 9304|0;
 $xrpow = sp + 88|0;
 $frameBits = sp + 24|0;
 $max_bits = sp + 8|0;
 $mean_bits = sp + 4|0;
 _memset(($xrpow|0),0,9216)|0;
 $0 = ((($gfc)) + 152|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($1|0)==(0);
 if ($2) {
  $3 = ((($gfc)) + 116|0);
  $4 = HEAP32[$3>>2]|0;
  $5 = ((($gfc)) + 84744|0);
  HEAP32[$5>>2] = $4;
  (_ResvFrameBegin($gfc,$avg$i)|0);
  $6 = ((($gfc)) + 52144|0);
  $7 = HEAP32[$6>>2]|0;
  $8 = ((($gfc)) + 112|0);
  $9 = HEAP32[$8>>2]|0;
  HEAP32[$5>>2] = $9;
  HEAP32[$5>>2] = 1;
  $10 = (_getframebits($gfc)|0);
  HEAP32[$sum$i>>2] = $10;
  $11 = HEAP32[$3>>2]|0;
  $12 = ($11|0)<(1);
  if ($12) {
   $19 = $11;
  } else {
   $i$01$i$i = 1;
   while(1) {
    HEAP32[$5>>2] = $i$01$i$i;
    $13 = (_ResvFrameBegin($gfc,$sum$i)|0);
    $14 = (($frameBits) + ($i$01$i$i<<2)|0);
    HEAP32[$14>>2] = $13;
    $15 = (($i$01$i$i) + 1)|0;
    $16 = HEAP32[$3>>2]|0;
    $17 = ($i$01$i$i|0)<($16|0);
    if ($17) {
     $i$01$i$i = $15;
    } else {
     $19 = $16;
     break;
    }
   }
  }
  $18 = (($frameBits) + ($19<<2)|0);
  $20 = HEAP32[$18>>2]|0;
  $163 = $7;$maximum_framebits$0$i = $20;
 } else {
  $21 = ((($gfc)) + 84744|0);
  HEAP32[$21>>2] = 0;
  $22 = (_ResvFrameBegin($gfc,$avg$i)|0);
  HEAP32[$frameBits>>2] = $22;
  $23 = ((($gfc)) + 52144|0);
  $24 = HEAP32[$23>>2]|0;
  $163 = $24;$maximum_framebits$0$i = $22;
 }
 $25 = ((($gfc)) + 76|0);
 $26 = HEAP32[$25>>2]|0;
 $27 = ($26|0)>(0);
 if ($27) {
  $28 = ((($gfc)) + 84756|0);
  $29 = ((($gfc)) + 72|0);
  $30 = ((($gfc)) + 84912|0);
  $31 = ((($gfc)) + 84908|0);
  $analog_silence$014$i = 1;$bits$015$i = 0;$gr$016$i = 0;
  while(1) {
   $35 = (($max_bits) + ($gr$016$i<<3)|0);
   $36 = HEAP32[$avg$i>>2]|0;
   (_on_pe($gfc,$pe,$35,$36,$gr$016$i,0)|0);
   $37 = HEAP32[$28>>2]|0;
   $38 = ($37|0)==(2);
   if ($38) {
    $i$01$i2$i = 0;
    while(1) {
     $39 = ((((($gfc)) + 304|0) + (($gr$016$i*10504)|0)|0) + ($i$01$i2$i<<2)|0);
     $40 = +HEAPF32[$39>>2];
     $41 = ((((((($gfc)) + 304|0) + (($gr$016$i*10504)|0)|0)) + 5252|0) + ($i$01$i2$i<<2)|0);
     $42 = +HEAPF32[$41>>2];
     $43 = $42 + $40;
     $44 = $43 * 0.70710676908493042;
     HEAPF32[$39>>2] = $44;
     $45 = $40 - $42;
     $46 = $45 * 0.70710676908493042;
     HEAPF32[$41>>2] = $46;
     $47 = (($i$01$i2$i) + 1)|0;
     $exitcond$i$i = ($47|0)==(576);
     if ($exitcond$i$i) {
      break;
     } else {
      $i$01$i2$i = $47;
     }
    }
   }
   $48 = HEAP32[$29>>2]|0;
   $49 = ($48|0)>(0);
   if ($49) {
    $analog_silence$110$i = $analog_silence$014$i;$bits$111$i = $bits$015$i;$ch$09$i = 0;
    while(1) {
     $50 = ((((($gfc)) + 304|0) + (($gr$016$i*10504)|0)|0) + (($ch$09$i*5252)|0)|0);
     $51 = +HEAPF32[$30>>2];
     $52 = $51;
     $53 = $52 * 0.10000000000000001;
     $54 = (+Math_pow(10.0,(+$53)));
     $55 = $54;
     HEAPF32[$31>>2] = $55;
     _init_outer_loop($gfc,$50);
     $56 = ((($ratio) + (($gr$016$i*976)|0)|0) + (($ch$09$i*488)|0)|0);
     $57 = ((($l3_xmin) + (($gr$016$i*312)|0)|0) + (($ch$09$i*156)|0)|0);
     $58 = (_calc_xmin($gfc,$56,$50,$57)|0);
     $59 = ($58|0)==(0);
     $analog_silence$1$$i = $59 ? $analog_silence$110$i : 0;
     $60 = ((($max_bits) + ($gr$016$i<<3)|0) + ($ch$09$i<<2)|0);
     $61 = HEAP32[$60>>2]|0;
     $62 = (($61) + ($bits$111$i))|0;
     $63 = (($ch$09$i) + 1)|0;
     $64 = HEAP32[$29>>2]|0;
     $65 = ($63|0)<($64|0);
     if ($65) {
      $analog_silence$110$i = $analog_silence$1$$i;$bits$111$i = $62;$ch$09$i = $63;
     } else {
      $$pre$i = $64;$analog_silence$1$lcssa$i = $analog_silence$1$$i;$bits$1$lcssa$i = $62;
      break;
     }
    }
   } else {
    $$pre$i = $48;$analog_silence$1$lcssa$i = $analog_silence$014$i;$bits$1$lcssa$i = $bits$015$i;
   }
   $66 = (($gr$016$i) + 1)|0;
   $67 = HEAP32[$25>>2]|0;
   $68 = ($66|0)<($67|0);
   if ($68) {
    $analog_silence$014$i = $analog_silence$1$lcssa$i;$bits$015$i = $bits$1$lcssa$i;$gr$016$i = $66;
   } else {
    $$lcssa69 = $67;$$pre$i$lcssa = $$pre$i;$analog_silence$1$lcssa$i$lcssa = $analog_silence$1$lcssa$i;$bits$1$lcssa$i$lcssa = $bits$1$lcssa$i;
    break;
   }
  }
  $32 = ($$lcssa69|0)>(0);
  if ($32) {
   $33 = ($bits$1$lcssa$i$lcssa|0)>($maximum_framebits$0$i|0);
   $34 = ($bits$1$lcssa$i$lcssa|0)>(0);
   $or$cond$i = $33 & $34;
   $69 = $$pre$i$lcssa;$gr$16$i = 0;
   while(1) {
    $70 = ($69|0)>(0);
    if ($70) {
     $165 = $69;$ch$15$i = 0;
     while(1) {
      if ($or$cond$i) {
       $71 = ((($max_bits) + ($gr$16$i<<3)|0) + ($ch$15$i<<2)|0);
       $72 = HEAP32[$71>>2]|0;
       $73 = Math_imul($72, $maximum_framebits$0$i)|0;
       $74 = (($73|0) / ($bits$1$lcssa$i$lcssa|0))&-1;
       HEAP32[$71>>2] = $74;
       $77 = $$pre$i$lcssa;
      } else {
       $77 = $165;
      }
      $75 = (($ch$15$i) + 1)|0;
      $76 = ($75|0)<($77|0);
      if ($76) {
       $165 = $77;$ch$15$i = $75;
      } else {
       $166 = $77;
       break;
      }
     }
    } else {
     $166 = $69;
    }
    $78 = (($gr$16$i) + 1)|0;
    $79 = ($78|0)<($$lcssa69|0);
    if ($79) {
     $69 = $166;$gr$16$i = $78;
    } else {
     break;
    }
   }
  }
  $80 = ($analog_silence$1$lcssa$i$lcssa|0)==(0);
  if ($80) {
   $134 = $163;$81 = $$lcssa69;$analog_silence$0$lcssa2527$i = 0;
  } else {
   $164 = $$lcssa69;$analog_silence$0$lcssa2526$i = $analog_silence$1$lcssa$i$lcssa;
   label = 21;
  }
 } else {
  $164 = $26;$analog_silence$0$lcssa2526$i = 1;
  label = 21;
 }
 if ((label|0) == 21) {
  $134 = 0;$81 = $164;$analog_silence$0$lcssa2527$i = $analog_silence$0$lcssa2526$i;
 }
 $82 = ($81|0)>(0);
 if ($82) {
  $83 = ((($gfc)) + 72|0);
  $84 = ((($gfc)) + 85824|0);
  $85 = ((($gfc)) + 85096|0);
  $$pre = HEAP32[$83>>2]|0;
  $167 = $81;$86 = $$pre;$gr$029 = 0;
  while(1) {
   $87 = ($86|0)>(0);
   if ($87) {
    $ch$026 = 0;
    while(1) {
     $88 = ((((($gfc)) + 304|0) + (($gr$029*10504)|0)|0) + (($ch$026*5252)|0)|0);
     $89 = ((($xrpow) + (($gr$029*4608)|0)|0) + (($ch$026*2304)|0)|0);
     HEAPF32[$sum$i>>2] = 0.0;
     $90 = ((((((($gfc)) + 304|0) + (($gr$029*10504)|0)|0) + (($ch$026*5252)|0)|0)) + 5208|0);
     $91 = HEAP32[$90>>2]|0;
     $92 = ((((((($gfc)) + 304|0) + (($gr$029*10504)|0)|0) + (($ch$026*5252)|0)|0)) + 4764|0);
     HEAPF32[$92>>2] = 0.0;
     $93 = (((($xrpow) + (($gr$029*4608)|0)|0) + (($ch$026*2304)|0)|0) + ($91<<2)|0);
     $94 = (576 - ($91))|0;
     $95 = $94 << 2;
     _memset(($93|0),0,($95|0))|0;
     $96 = HEAP32[$84>>2]|0;
     FUNCTION_TABLE_viiii[$96 & 7]($88,$89,$91,$sum$i);
     $97 = +HEAPF32[$sum$i>>2];
     $98 = $97 > 9.9999996826552254E-21;
     if ($98) {
      $99 = HEAP32[$85>>2]|0;
      $100 = $99 >>> 1;
      $$lobit$i = $100 & 1;
      $101 = ((((((($gfc)) + 304|0) + (($gr$029*10504)|0)|0) + (($ch$026*5252)|0)|0)) + 4864|0);
      $102 = HEAP32[$101>>2]|0;
      $103 = ($102|0)>(0);
      if ($103) {
       $i$01$i = 0;
       while(1) {
        $104 = (((($gfc)) + 84936|0) + ($i$01$i<<2)|0);
        HEAP32[$104>>2] = $$lobit$i;
        $105 = (($i$01$i) + 1)|0;
        $106 = HEAP32[$101>>2]|0;
        $107 = ($105|0)<($106|0);
        if ($107) {
         $i$01$i = $105;
        } else {
         break;
        }
       }
      }
     } else {
      $108 = ((((((($gfc)) + 304|0) + (($gr$029*10504)|0)|0) + (($ch$026*5252)|0)|0)) + 2304|0);
      _memset(($108|0),0,2304)|0;
      $109 = ((($max_bits) + ($gr$029<<3)|0) + ($ch$026<<2)|0);
      HEAP32[$109>>2] = 0;
     }
     $110 = (($ch$026) + 1)|0;
     $111 = HEAP32[$83>>2]|0;
     $112 = ($110|0)<($111|0);
     if ($112) {
      $ch$026 = $110;
     } else {
      $$lcssa65 = $111;
      break;
     }
    }
    $$pre44 = HEAP32[$25>>2]|0;
    $115 = $$pre44;$168 = $$lcssa65;
   } else {
    $115 = $167;$168 = $86;
   }
   $113 = (($gr$029) + 1)|0;
   $114 = ($113|0)<($115|0);
   if ($114) {
    $167 = $115;$86 = $168;$gr$029 = $113;
   } else {
    break;
   }
  }
 }
 $116 = (_VBR_encode_frame(($gfc|0),($xrpow|0),($l3_xmin|0),($max_bits|0))|0);
 $117 = HEAP32[$0>>2]|0;
 $118 = ($117|0)==(0);
 do {
  if ($118) {
   $119 = ($analog_silence$0$lcssa2527$i|0)==(0);
   if ($119) {
    label = 36;
   } else {
    $120 = ((($gfc)) + 124|0);
    $121 = HEAP32[$120>>2]|0;
    $122 = ($121|0)==(0);
    if ($122) {
     $i$0$ph = 1;
    } else {
     label = 36;
    }
   }
   if ((label|0) == 36) {
    $123 = ((($gfc)) + 112|0);
    $124 = HEAP32[$123>>2]|0;
    $i$0$ph = $124;
   }
   $125 = ((($gfc)) + 116|0);
   $126 = HEAP32[$125>>2]|0;
   $127 = ($i$0$ph|0)<($126|0);
   L63: do {
    if ($127) {
     $i$018 = $i$0$ph;
     while(1) {
      $128 = (($frameBits) + ($i$018<<2)|0);
      $129 = HEAP32[$128>>2]|0;
      $130 = ($116|0)>($129|0);
      if (!($130)) {
       $i$0$lcssa = $i$018;
       break L63;
      }
      $131 = (($i$018) + 1)|0;
      $132 = ($131|0)<($126|0);
      if ($132) {
       $i$018 = $131;
      } else {
       $i$0$lcssa = $131;
       break;
      }
     }
    } else {
     $i$0$lcssa = $i$0$ph;
    }
   } while(0);
   $133 = ($i$0$lcssa|0)>($126|0);
   $$i$0 = $133 ? $126 : $i$0$lcssa;
   $135 = ($134|0)>(0);
   if (!($135)) {
    $144 = ((($gfc)) + 84744|0);
    HEAP32[$144>>2] = $$i$0;
    $147 = $$i$0;
    break;
   }
   $136 = ($126|0)>($$i$0|0);
   L71: do {
    if ($136) {
     $j$013 = $126;
     while(1) {
      $137 = (($frameBits) + ($j$013<<2)|0);
      $138 = HEAP32[$137>>2]|0;
      $139 = (($138) - ($116))|0;
      $140 = ($139|0)>($134|0);
      if (!($140)) {
       $j$0$lcssa = $j$013;
       break L71;
      }
      $141 = (($j$013) + -1)|0;
      $142 = ($141|0)>($$i$0|0);
      if ($142) {
       $j$013 = $141;
      } else {
       $j$0$lcssa = $141;
       break;
      }
     }
    } else {
     $j$0$lcssa = $126;
    }
   } while(0);
   $143 = ((($gfc)) + 84744|0);
   HEAP32[$143>>2] = $j$0$lcssa;
   $147 = $j$0$lcssa;
  } else {
   $145 = ((($gfc)) + 84744|0);
   HEAP32[$145>>2] = 0;
   $147 = 0;
  }
 } while(0);
 $146 = (($frameBits) + ($147<<2)|0);
 $148 = HEAP32[$146>>2]|0;
 $149 = ($116|0)>($148|0);
 if ($149) {
  _lame_errorf($gfc,11768,$vararg_buffer);
  _exit(-1);
  // unreachable;
 }
 (_ResvFrameBegin($gfc,$mean_bits)|0);
 $150 = HEAP32[$25>>2]|0;
 $151 = ($150|0)>(0);
 if (!($151)) {
  $162 = HEAP32[$mean_bits>>2]|0;
  _ResvFrameEnd($gfc,$162);
  STACKTOP = sp;return;
 }
 $152 = ((($gfc)) + 72|0);
 $$pre45 = HEAP32[$152>>2]|0;
 $153 = $$pre45;$169 = $150;$gr$110 = 0;
 while(1) {
  $154 = ($153|0)>(0);
  if ($154) {
   $ch$19 = 0;
   while(1) {
    $155 = ((((($gfc)) + 304|0) + (($gr$110*10504)|0)|0) + (($ch$19*5252)|0)|0);
    _ResvAdjust($gfc,$155);
    $156 = (($ch$19) + 1)|0;
    $157 = HEAP32[$152>>2]|0;
    $158 = ($156|0)<($157|0);
    if ($158) {
     $ch$19 = $156;
    } else {
     $$lcssa = $157;
     break;
    }
   }
   $$pre46 = HEAP32[$25>>2]|0;
   $161 = $$pre46;$170 = $$lcssa;
  } else {
   $161 = $169;$170 = $153;
  }
  $159 = (($gr$110) + 1)|0;
  $160 = ($159|0)<($161|0);
  if ($160) {
   $153 = $170;$169 = $161;$gr$110 = $159;
  } else {
   break;
  }
 }
 $162 = HEAP32[$mean_bits>>2]|0;
 _ResvFrameEnd($gfc,$162);
 STACKTOP = sp;return;
}
function _ABR_iteration_loop($gfc,$pe,$ms_ener_ratio,$ratio) {
 $gfc = $gfc|0;
 $pe = $pe|0;
 $ms_ener_ratio = $ms_ener_ratio|0;
 $ratio = $ratio|0;
 var $$add_bits$0$i = 0, $$lcssa39 = 0, $$lobit$i = 0, $$pre = 0, $$pre$i = 0, $$pre37$i = 0, $$pre38$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0;
 var $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0;
 var $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0.0, $132 = 0, $133 = 0.0, $134 = 0.0, $135 = 0.0, $136 = 0.0, $137 = 0.0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0.0;
 var $146 = 0.0, $147 = 0.0, $148 = 0.0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0.0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0;
 var $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0;
 var $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0.0, $26 = 0.0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0, $43 = 0, $44 = 0;
 var $45 = 0.0, $46 = 0.0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0.0, $55 = 0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0;
 var $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0;
 var $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0.0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0.0, $97 = 0, $98 = 0, $99 = 0;
 var $add_bits$0$i = 0, $add_bits$1$i = 0, $ch$013 = 0, $ch$023$i = 0, $ch$128$i = 0, $ch$212$i = 0, $ch$39$i = 0, $exitcond$i = 0, $gr$015 = 0, $gr$030$i = 0, $gr$217$i = 0, $gr$310$i = 0, $i$01$i = 0, $i$01$i1 = 0, $l3_xmin = 0, $masking_lower_db$0 = 0.0, $masking_lower_db$0$in = 0, $mean_bits = 0, $or$cond$i = 0, $res_factor$0$i = 0.0;
 var $res_factor$1$i = 0.0, $sum$024$i = 0, $sum$i = 0, $targ_bits = 0, $totbits$016$i = 0, $totbits$1$lcssa$i = 0, $totbits$1$lcssa$i$lcssa = 0, $totbits$113$i = 0, $xrpow = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 2496|0;
 $sum$i = sp + 2484|0;
 $l3_xmin = sp + 2328|0;
 $xrpow = sp + 24|0;
 $targ_bits = sp + 8|0;
 $mean_bits = sp;
 $0 = ((($gfc)) + 304|0);
 HEAP32[$mean_bits>>2] = 0;
 $1 = ((($gfc)) + 76|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = ((($gfc)) + 116|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ((($gfc)) + 84744|0);
 HEAP32[$5>>2] = $4;
 $6 = (_ResvFrameBegin($gfc,$sum$i)|0);
 HEAP32[$5>>2] = 1;
 $7 = (_getframebits($gfc)|0);
 $8 = ((($gfc)) + 24|0);
 $9 = HEAP32[$8>>2]|0;
 $10 = $9 << 3;
 $11 = (($7) - ($10))|0;
 $12 = HEAP32[$1>>2]|0;
 $13 = ((($gfc)) + 72|0);
 $14 = HEAP32[$13>>2]|0;
 $15 = Math_imul($14, $12)|0;
 $16 = (($11|0) / ($15|0))&-1;
 $17 = ((($gfc)) + 108|0);
 $18 = HEAP32[$17>>2]|0;
 $19 = ($2*576000)|0;
 $20 = Math_imul($19, $18)|0;
 HEAP32[$sum$i>>2] = $20;
 $21 = ((($gfc)) + 85096|0);
 $22 = HEAP32[$21>>2]|0;
 $23 = $22 & 1;
 $24 = ($23|0)==(0);
 if ($24) {
  $31 = $20;
 } else {
  $25 = (+($20|0));
  $26 = $25 * 1.0900000000000001;
  $27 = (~~(($26)));
  HEAP32[$sum$i>>2] = $27;
  $31 = $27;
 }
 $28 = ((($gfc)) + 64|0);
 $29 = HEAP32[$28>>2]|0;
 $30 = (($31|0) / ($29|0))&-1;
 $32 = (($30) - ($10))|0;
 $33 = (($32|0) / ($15|0))&-1;
 HEAP32[$sum$i>>2] = $33;
 $34 = ((($gfc)) + 244|0);
 $35 = +HEAPF32[$34>>2];
 $36 = $35;
 $37 = 11.0 - $36;
 $38 = $37 * 0.012727272727272728;
 $39 = $38 + 0.93000000000000005;
 $40 = $39;
 $41 = $40;
 $42 = $41 < 0.90000000000000002;
 $res_factor$0$i = $42 ? 0.89999997615814208 : $40;
 $43 = ($12|0)>(0);
 if ($43) {
  $44 = $res_factor$0$i > 1.0;
  $res_factor$1$i = $44 ? 1.0 : $res_factor$0$i;
  $45 = (+($33|0));
  $46 = $res_factor$1$i * $45;
  $47 = (~~(($46)));
  $48 = (($33|0) / 2)&-1;
  $49 = ($33*3)|0;
  $50 = (($49|0) / 2)&-1;
  $51 = ($14|0)>(0);
  $gr$030$i = 0;
  while(1) {
   if ($51) {
    $ch$023$i = 0;$sum$024$i = 0;
    while(1) {
     $52 = ((($targ_bits) + ($gr$030$i<<3)|0) + ($ch$023$i<<2)|0);
     HEAP32[$52>>2] = $47;
     $53 = ((($pe) + ($gr$030$i<<3)|0) + ($ch$023$i<<2)|0);
     $54 = +HEAPF32[$53>>2];
     $55 = $54 > 700.0;
     if ($55) {
      $56 = $54 + -700.0;
      $57 = $56;
      $58 = $57 * 0.7142857142857143;
      $59 = (~~(($58)));
      $60 = ((((((($gfc)) + 304|0) + (($gr$030$i*10504)|0)|0) + (($ch$023$i*5252)|0)|0)) + 4788|0);
      $61 = HEAP32[$60>>2]|0;
      $62 = ($61|0)==(2);
      $63 = ($59|0)<($48|0);
      $64 = $63 & $62;
      $add_bits$0$i = $64 ? $48 : $59;
      $65 = ($add_bits$0$i|0)>($50|0);
      $66 = ($add_bits$0$i|0)<(0);
      $$add_bits$0$i = $66 ? 0 : $add_bits$0$i;
      $add_bits$1$i = $65 ? $50 : $$add_bits$0$i;
      $67 = (($add_bits$1$i) + ($47))|0;
      HEAP32[$52>>2] = $67;
      $68 = $67;
     } else {
      $68 = $47;
     }
     $69 = ($68|0)>(4095);
     if ($69) {
      HEAP32[$52>>2] = 4095;
      $71 = 4095;
     } else {
      $71 = $68;
     }
     $70 = (($71) + ($sum$024$i))|0;
     $72 = (($ch$023$i) + 1)|0;
     $73 = ($72|0)<($14|0);
     if ($73) {
      $ch$023$i = $72;$sum$024$i = $70;
     } else {
      $$lcssa39 = $70;
      break;
     }
    }
    $74 = ($$lcssa39|0)>(7680);
    if ($74) {
     $ch$128$i = 0;
     while(1) {
      $75 = ((($targ_bits) + ($gr$030$i<<3)|0) + ($ch$128$i<<2)|0);
      $76 = HEAP32[$75>>2]|0;
      $77 = ($76*7680)|0;
      $78 = (($77|0) / ($$lcssa39|0))&-1;
      HEAP32[$75>>2] = $78;
      $79 = (($ch$128$i) + 1)|0;
      $80 = ($79|0)<($14|0);
      if ($80) {
       $ch$128$i = $79;
      } else {
       break;
      }
     }
    }
   }
   $81 = (($gr$030$i) + 1)|0;
   $82 = ($81|0)<($12|0);
   if ($82) {
    $gr$030$i = $81;
   } else {
    break;
   }
  }
 }
 $83 = ((($gfc)) + 84756|0);
 $84 = HEAP32[$83>>2]|0;
 $85 = ($84|0)==(2);
 if ($85) {
  if ($43) {
   $86 = +HEAPF32[$ms_ener_ratio>>2];
   $87 = Math_imul($33, $14)|0;
   _reduce_side($targ_bits,$86,$87,7680);
   $88 = HEAP32[$1>>2]|0;
   $89 = ($88|0)>(1);
   if ($89) {
    $94 = 1;
    while(1) {
     $$pre$i = HEAP32[$sum$i>>2]|0;
     $$pre37$i = HEAP32[$13>>2]|0;
     $93 = (($targ_bits) + ($94<<3)|0);
     $95 = (($ms_ener_ratio) + ($94<<2)|0);
     $96 = +HEAPF32[$95>>2];
     $97 = Math_imul($$pre$i, $$pre37$i)|0;
     _reduce_side($93,$96,$97,7680);
     $98 = (($94) + 1)|0;
     $99 = HEAP32[$1>>2]|0;
     $100 = ($98|0)<($99|0);
     if ($100) {
      $94 = $98;
     } else {
      $90 = $99;
      label = 17;
      break;
     }
    }
   } else {
    $90 = $88;
    label = 17;
   }
  } else {
   label = 30;
  }
 } else {
  $90 = $12;
  label = 17;
 }
 if ((label|0) == 17) {
  $91 = ($90|0)>(0);
  if ($91) {
   $$pre38$i = HEAP32[$13>>2]|0;
   $92 = ($$pre38$i|0)>(0);
   $gr$217$i = 0;$totbits$016$i = 0;
   while(1) {
    if ($92) {
     $ch$212$i = 0;$totbits$113$i = $totbits$016$i;
     while(1) {
      $101 = ((($targ_bits) + ($gr$217$i<<3)|0) + ($ch$212$i<<2)|0);
      $102 = HEAP32[$101>>2]|0;
      $103 = ($102|0)>(4095);
      if ($103) {
       HEAP32[$101>>2] = 4095;
       $105 = 4095;
      } else {
       $105 = $102;
      }
      $104 = (($105) + ($totbits$113$i))|0;
      $106 = (($ch$212$i) + 1)|0;
      $107 = ($106|0)<($$pre38$i|0);
      if ($107) {
       $ch$212$i = $106;$totbits$113$i = $104;
      } else {
       $totbits$1$lcssa$i = $104;
       break;
      }
     }
    } else {
     $totbits$1$lcssa$i = $totbits$016$i;
    }
    $108 = (($gr$217$i) + 1)|0;
    $109 = ($108|0)<($90|0);
    if ($109) {
     $gr$217$i = $108;$totbits$016$i = $totbits$1$lcssa$i;
    } else {
     $totbits$1$lcssa$i$lcssa = $totbits$1$lcssa$i;
     break;
    }
   }
   $110 = ($totbits$1$lcssa$i$lcssa|0)>($6|0);
   $111 = ($totbits$1$lcssa$i$lcssa|0)>(0);
   $or$cond$i = $111 & $110;
   if ($or$cond$i) {
    $112 = ($$pre38$i|0)>(0);
    $192 = $90;$gr$310$i = 0;
    while(1) {
     if ($112) {
      $ch$39$i = 0;
      while(1) {
       $113 = ((($targ_bits) + ($gr$310$i<<3)|0) + ($ch$39$i<<2)|0);
       $114 = HEAP32[$113>>2]|0;
       $115 = Math_imul($114, $6)|0;
       $116 = (($115|0) / ($totbits$1$lcssa$i$lcssa|0))&-1;
       HEAP32[$113>>2] = $116;
       $117 = (($ch$39$i) + 1)|0;
       $118 = ($117|0)<($$pre38$i|0);
       if ($118) {
        $ch$39$i = $117;
       } else {
        $121 = $90;
        break;
       }
      }
     } else {
      $121 = $192;
     }
     $119 = (($gr$310$i) + 1)|0;
     $120 = ($119|0)<($121|0);
     if ($120) {
      $192 = $121;$gr$310$i = $119;
     } else {
      break;
     }
    }
   }
   $122 = ($90|0)>(0);
   if ($122) {
    $123 = ((($gfc)) + 84912|0);
    $124 = ((($gfc)) + 84916|0);
    $125 = ((($gfc)) + 84908|0);
    $126 = ((($gfc)) + 85824|0);
    $127 = ((($gfc)) + 36|0);
    $gr$015 = 0;
    while(1) {
     $128 = HEAP32[$83>>2]|0;
     $129 = ($128|0)==(2);
     if ($129) {
      $i$01$i = 0;
      while(1) {
       $130 = ((((($gfc)) + 304|0) + (($gr$015*10504)|0)|0) + ($i$01$i<<2)|0);
       $131 = +HEAPF32[$130>>2];
       $132 = ((((((($gfc)) + 304|0) + (($gr$015*10504)|0)|0)) + 5252|0) + ($i$01$i<<2)|0);
       $133 = +HEAPF32[$132>>2];
       $134 = $133 + $131;
       $135 = $134 * 0.70710676908493042;
       HEAPF32[$130>>2] = $135;
       $136 = $131 - $133;
       $137 = $136 * 0.70710676908493042;
       HEAPF32[$132>>2] = $137;
       $138 = (($i$01$i) + 1)|0;
       $exitcond$i = ($138|0)==(576);
       if ($exitcond$i) {
        break;
       } else {
        $i$01$i = $138;
       }
      }
     }
     $139 = HEAP32[$13>>2]|0;
     $140 = ($139|0)>(0);
     if ($140) {
      $ch$013 = 0;
      while(1) {
       $141 = ((((($gfc)) + 304|0) + (($gr$015*10504)|0)|0) + (($ch$013*5252)|0)|0);
       $142 = ((((((($gfc)) + 304|0) + (($gr$015*10504)|0)|0) + (($ch$013*5252)|0)|0)) + 4788|0);
       $143 = HEAP32[$142>>2]|0;
       $144 = ($143|0)==(2);
       $masking_lower_db$0$in = $144 ? $124 : $123;
       $masking_lower_db$0 = +HEAPF32[$masking_lower_db$0$in>>2];
       $145 = $masking_lower_db$0;
       $146 = $145 * 0.10000000000000001;
       $147 = (+Math_pow(10.0,(+$146)));
       $148 = $147;
       HEAPF32[$125>>2] = $148;
       _init_outer_loop($gfc,$141);
       HEAPF32[$sum$i>>2] = 0.0;
       $149 = ((((((($gfc)) + 304|0) + (($gr$015*10504)|0)|0) + (($ch$013*5252)|0)|0)) + 5208|0);
       $150 = HEAP32[$149>>2]|0;
       $151 = ((((((($gfc)) + 304|0) + (($gr$015*10504)|0)|0) + (($ch$013*5252)|0)|0)) + 4764|0);
       HEAPF32[$151>>2] = 0.0;
       $152 = (($xrpow) + ($150<<2)|0);
       $153 = (576 - ($150))|0;
       $154 = $153 << 2;
       _memset(($152|0),0,($154|0))|0;
       $155 = HEAP32[$126>>2]|0;
       FUNCTION_TABLE_viiii[$155 & 7]($141,$xrpow,$150,$sum$i);
       $156 = +HEAPF32[$sum$i>>2];
       $157 = $156 > 9.9999996826552254E-21;
       if ($157) {
        $158 = HEAP32[$21>>2]|0;
        $159 = $158 >>> 1;
        $$lobit$i = $159 & 1;
        $160 = ((((((($gfc)) + 304|0) + (($gr$015*10504)|0)|0) + (($ch$013*5252)|0)|0)) + 4864|0);
        $161 = HEAP32[$160>>2]|0;
        $162 = ($161|0)>(0);
        if ($162) {
         $i$01$i1 = 0;
         while(1) {
          $163 = (((($gfc)) + 84936|0) + ($i$01$i1<<2)|0);
          HEAP32[$163>>2] = $$lobit$i;
          $164 = (($i$01$i1) + 1)|0;
          $165 = HEAP32[$160>>2]|0;
          $166 = ($164|0)<($165|0);
          if ($166) {
           $i$01$i1 = $164;
          } else {
           break;
          }
         }
        }
        $168 = ((($ratio) + (($gr$015*976)|0)|0) + (($ch$013*488)|0)|0);
        $169 = (_calc_xmin($gfc,$168,$141,$l3_xmin)|0);
        $170 = ($169|0)==(0);
        $171 = ((($targ_bits) + ($gr$015<<3)|0) + ($ch$013<<2)|0);
        if ($170) {
         HEAP32[$171>>2] = $16;
         $172 = $16;
        } else {
         $$pre = HEAP32[$171>>2]|0;
         $172 = $$pre;
        }
        (_outer_loop($gfc,$141,$l3_xmin,$xrpow,$ch$013,$172)|0);
       } else {
        $167 = ((((((($gfc)) + 304|0) + (($gr$015*10504)|0)|0) + (($ch$013*5252)|0)|0)) + 2304|0);
        _memset(($167|0),0,2304)|0;
       }
       _best_scalefac_store($gfc,$gr$015,$ch$013,$0);
       $173 = HEAP32[$127>>2]|0;
       $174 = ($173|0)==(1);
       if ($174) {
        _best_huffman_divide($gfc,$141);
       }
       _ResvAdjust($gfc,$141);
       $175 = (($ch$013) + 1)|0;
       $176 = HEAP32[$13>>2]|0;
       $177 = ($175|0)<($176|0);
       if ($177) {
        $ch$013 = $175;
       } else {
        break;
       }
      }
     }
     $178 = (($gr$015) + 1)|0;
     $179 = HEAP32[$1>>2]|0;
     $180 = ($178|0)<($179|0);
     if ($180) {
      $gr$015 = $178;
     } else {
      break;
     }
    }
   }
  } else {
   label = 30;
  }
 }
 if ((label|0) == 30) {
 }
 $181 = ((($gfc)) + 112|0);
 $182 = HEAP32[$181>>2]|0;
 HEAP32[$5>>2] = $182;
 $183 = HEAP32[$3>>2]|0;
 $184 = ($182|0)>($183|0);
 if ($184) {
  $191 = HEAP32[$mean_bits>>2]|0;
  _ResvFrameEnd($gfc,$191);
  STACKTOP = sp;return;
 }
 while(1) {
  $185 = (_ResvFrameBegin($gfc,$mean_bits)|0);
  $186 = ($185|0)>(-1);
  if ($186) {
   label = 51;
   break;
  }
  $187 = HEAP32[$5>>2]|0;
  $188 = (($187) + 1)|0;
  HEAP32[$5>>2] = $188;
  $189 = HEAP32[$3>>2]|0;
  $190 = ($187|0)<($189|0);
  if (!($190)) {
   label = 51;
   break;
  }
 }
 if ((label|0) == 51) {
  $191 = HEAP32[$mean_bits>>2]|0;
  _ResvFrameEnd($gfc,$191);
  STACKTOP = sp;return;
 }
}
function _CBR_iteration_loop($gfc,$pe,$ms_ener_ratio,$ratio) {
 $gfc = $gfc|0;
 $pe = $pe|0;
 $ms_ener_ratio = $ms_ener_ratio|0;
 $ratio = $ratio|0;
 var $$lobit$i = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0.0, $18 = 0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0, $25 = 0;
 var $26 = 0.0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0;
 var $44 = 0, $45 = 0.0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0;
 var $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $7 = 0, $8 = 0, $9 = 0, $ch$03 = 0, $exitcond$i = 0, $gr$04 = 0, $i$01$i = 0, $i$01$i1 = 0, $l3_xmin = 0, $masking_lower_db$0 = 0.0, $masking_lower_db$0$in = 0, $mean_bits = 0, $sum$i = 0;
 var $targ_bits = 0, $xrpow = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 2480|0;
 $sum$i = sp + 2476|0;
 $l3_xmin = sp + 2320|0;
 $xrpow = sp + 16|0;
 $targ_bits = sp + 8|0;
 $mean_bits = sp;
 $0 = ((($gfc)) + 304|0);
 (_ResvFrameBegin($gfc,$mean_bits)|0);
 $1 = ((($gfc)) + 76|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = ($2|0)>(0);
 if (!($3)) {
  $68 = HEAP32[$mean_bits>>2]|0;
  _ResvFrameEnd($gfc,$68);
  STACKTOP = sp;return;
 }
 $4 = ((($gfc)) + 84756|0);
 $5 = ((($gfc)) + 72|0);
 $6 = ((($gfc)) + 84912|0);
 $7 = ((($gfc)) + 84916|0);
 $8 = ((($gfc)) + 84908|0);
 $9 = ((($gfc)) + 85824|0);
 $10 = ((($gfc)) + 85096|0);
 $11 = ((($gfc)) + 36|0);
 $gr$04 = 0;
 while(1) {
  $12 = HEAP32[$mean_bits>>2]|0;
  $13 = (_on_pe($gfc,$pe,$targ_bits,$12,$gr$04,$gr$04)|0);
  $14 = HEAP32[$4>>2]|0;
  $15 = ($14|0)==(2);
  if ($15) {
   $i$01$i = 0;
   while(1) {
    $16 = ((((($gfc)) + 304|0) + (($gr$04*10504)|0)|0) + ($i$01$i<<2)|0);
    $17 = +HEAPF32[$16>>2];
    $18 = ((((((($gfc)) + 304|0) + (($gr$04*10504)|0)|0)) + 5252|0) + ($i$01$i<<2)|0);
    $19 = +HEAPF32[$18>>2];
    $20 = $19 + $17;
    $21 = $20 * 0.70710676908493042;
    HEAPF32[$16>>2] = $21;
    $22 = $17 - $19;
    $23 = $22 * 0.70710676908493042;
    HEAPF32[$18>>2] = $23;
    $24 = (($i$01$i) + 1)|0;
    $exitcond$i = ($24|0)==(576);
    if ($exitcond$i) {
     break;
    } else {
     $i$01$i = $24;
    }
   }
   $25 = (($ms_ener_ratio) + ($gr$04<<2)|0);
   $26 = +HEAPF32[$25>>2];
   $27 = HEAP32[$mean_bits>>2]|0;
   _reduce_side($targ_bits,$26,$27,$13);
  }
  $28 = HEAP32[$5>>2]|0;
  $29 = ($28|0)>(0);
  if ($29) {
   $ch$03 = 0;
   while(1) {
    $30 = ((((($gfc)) + 304|0) + (($gr$04*10504)|0)|0) + (($ch$03*5252)|0)|0);
    $31 = ((((((($gfc)) + 304|0) + (($gr$04*10504)|0)|0) + (($ch$03*5252)|0)|0)) + 4788|0);
    $32 = HEAP32[$31>>2]|0;
    $33 = ($32|0)==(2);
    $masking_lower_db$0$in = $33 ? $7 : $6;
    $masking_lower_db$0 = +HEAPF32[$masking_lower_db$0$in>>2];
    $34 = $masking_lower_db$0;
    $35 = $34 * 0.10000000000000001;
    $36 = (+Math_pow(10.0,(+$35)));
    $37 = $36;
    HEAPF32[$8>>2] = $37;
    _init_outer_loop($gfc,$30);
    HEAPF32[$sum$i>>2] = 0.0;
    $38 = ((((((($gfc)) + 304|0) + (($gr$04*10504)|0)|0) + (($ch$03*5252)|0)|0)) + 5208|0);
    $39 = HEAP32[$38>>2]|0;
    $40 = ((((((($gfc)) + 304|0) + (($gr$04*10504)|0)|0) + (($ch$03*5252)|0)|0)) + 4764|0);
    HEAPF32[$40>>2] = 0.0;
    $41 = (($xrpow) + ($39<<2)|0);
    $42 = (576 - ($39))|0;
    $43 = $42 << 2;
    _memset(($41|0),0,($43|0))|0;
    $44 = HEAP32[$9>>2]|0;
    FUNCTION_TABLE_viiii[$44 & 7]($30,$xrpow,$39,$sum$i);
    $45 = +HEAPF32[$sum$i>>2];
    $46 = $45 > 9.9999996826552254E-21;
    if ($46) {
     $47 = HEAP32[$10>>2]|0;
     $48 = $47 >>> 1;
     $$lobit$i = $48 & 1;
     $49 = ((((((($gfc)) + 304|0) + (($gr$04*10504)|0)|0) + (($ch$03*5252)|0)|0)) + 4864|0);
     $50 = HEAP32[$49>>2]|0;
     $51 = ($50|0)>(0);
     if ($51) {
      $i$01$i1 = 0;
      while(1) {
       $52 = (((($gfc)) + 84936|0) + ($i$01$i1<<2)|0);
       HEAP32[$52>>2] = $$lobit$i;
       $53 = (($i$01$i1) + 1)|0;
       $54 = HEAP32[$49>>2]|0;
       $55 = ($53|0)<($54|0);
       if ($55) {
        $i$01$i1 = $53;
       } else {
        break;
       }
      }
     }
     $57 = ((($ratio) + (($gr$04*976)|0)|0) + (($ch$03*488)|0)|0);
     (_calc_xmin($gfc,$57,$30,$l3_xmin)|0);
     $58 = (($targ_bits) + ($ch$03<<2)|0);
     $59 = HEAP32[$58>>2]|0;
     (_outer_loop($gfc,$30,$l3_xmin,$xrpow,$ch$03,$59)|0);
    } else {
     $56 = ((((((($gfc)) + 304|0) + (($gr$04*10504)|0)|0) + (($ch$03*5252)|0)|0)) + 2304|0);
     _memset(($56|0),0,2304)|0;
    }
    _best_scalefac_store($gfc,$gr$04,$ch$03,$0);
    $60 = HEAP32[$11>>2]|0;
    $61 = ($60|0)==(1);
    if ($61) {
     _best_huffman_divide($gfc,$30);
    }
    _ResvAdjust($gfc,$30);
    $62 = (($ch$03) + 1)|0;
    $63 = HEAP32[$5>>2]|0;
    $64 = ($62|0)<($63|0);
    if ($64) {
     $ch$03 = $62;
    } else {
     break;
    }
   }
  }
  $65 = (($gr$04) + 1)|0;
  $66 = HEAP32[$1>>2]|0;
  $67 = ($65|0)<($66|0);
  if ($67) {
   $gr$04 = $65;
  } else {
   break;
  }
 }
 $68 = HEAP32[$mean_bits>>2]|0;
 _ResvFrameEnd($gfc,$68);
 STACKTOP = sp;return;
}
function _init_xrpow_core_c($cod_info,$xrpow,$upper,$sum) {
 $cod_info = $cod_info|0;
 $xrpow = $xrpow|0;
 $upper = $upper|0;
 $sum = $sum|0;
 var $$pre = 0.0, $0 = 0, $1 = 0, $10 = 0.0, $11 = 0, $12 = 0.0, $13 = 0, $14 = 0, $2 = 0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0.0, $exitcond = 0, $fabsf = 0.0, $i$01 = 0, label = 0;
 var sp = 0;
 sp = STACKTOP;
 HEAPF32[$sum>>2] = 0.0;
 $0 = ($upper|0)<(0);
 if ($0) {
  return;
 }
 $1 = ((($cod_info)) + 4764|0);
 $5 = 0.0;$i$01 = 0;
 while(1) {
  $2 = (($cod_info) + ($i$01<<2)|0);
  $3 = +HEAPF32[$2>>2];
  $fabsf = (+Math_abs((+$3)));
  $4 = $5 + $fabsf;
  HEAPF32[$sum>>2] = $4;
  $6 = $fabsf;
  $7 = (+Math_sqrt((+$6)));
  $8 = $7 * $6;
  $9 = (+Math_sqrt((+$8)));
  $10 = $9;
  $11 = (($xrpow) + ($i$01<<2)|0);
  HEAPF32[$11>>2] = $10;
  $12 = +HEAPF32[$1>>2];
  $13 = $10 > $12;
  if ($13) {
   HEAPF32[$1>>2] = $10;
  }
  $exitcond = ($i$01|0)==($upper|0);
  if ($exitcond) {
   break;
  }
  $14 = (($i$01) + 1)|0;
  $$pre = +HEAPF32[$sum>>2];
  $5 = $$pre;$i$01 = $14;
 }
 return;
}
function _init_outer_loop($gfc,$cod_info) {
 $gfc = $gfc|0;
 $cod_info = $cod_info|0;
 var $$phi$trans$insert = 0, $$pre = 0, $$sink = 0, $$sink27 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0.0, $111 = 0;
 var $112 = 0.0, $113 = 0.0, $114 = 0.0, $115 = 0.0, $116 = 0, $117 = 0.0, $118 = 0, $119 = 0, $12 = 0, $120 = 0.0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0;
 var $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0.0, $137 = 0, $138 = 0.0, $139 = 0.0, $14 = 0, $140 = 0.0, $141 = 0.0, $142 = 0, $143 = 0.0, $144 = 0, $145 = 0, $146 = 0, $147 = 0.0, $148 = 0;
 var $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0.0;
 var $167 = 0, $168 = 0.0, $169 = 0.0, $17 = 0, $170 = 0.0, $171 = 0.0, $172 = 0, $173 = 0.0, $174 = 0, $175 = 0, $176 = 0, $177 = 0.0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0;
 var $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0.0, $198 = 0, $199 = 0.0, $2 = 0, $20 = 0, $200 = 0.0, $201 = 0.0;
 var $202 = 0.0, $203 = 0, $204 = 0.0, $205 = 0, $206 = 0, $207 = 0, $208 = 0.0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0;
 var $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0;
 var $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0;
 var $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0;
 var $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0;
 var $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $ath12$0$i = 0.0, $ath12$0$i$1 = 0.0, $ath12$0$i$2 = 0.0, $ath21$0$i = 0.0, $exitcond = 0, $exitcond20 = 0, $exitcond20$1 = 0, $exitcond20$2 = 0, $exitcond25 = 0, $exitcond26 = 0, $fabsf$i = 0.0;
 var $fabsf$i$1 = 0.0, $fabsf$i$2 = 0.0, $fabsf2$i = 0.0, $gsfb$022$i = 0, $gsfb1$011$i = 0, $gsfb1$011$i$1 = 0, $gsfb1$011$i$2 = 0, $ix$013 = 0, $ix$1$lcssa = 0, $ix$26$us = 0, $ix$26$us$1 = 0, $ix$26$us$2 = 0, $ixwork = 0, $j$015$i = 0, $j$015$in$i = 0, $j$04 = 0, $j5$08$i = 0, $j5$08$i$1 = 0, $j5$08$i$2 = 0, $j5$08$in$i = 0;
 var $j5$08$in$i$1 = 0, $j5$08$in$i$2 = 0, $l$07$us = 0, $l$07$us$1 = 0, $l$07$us$2 = 0, $scevgep = 0, $scevgep$1 = 0, $scevgep$1$sum = 0, $scevgep$2 = 0, $scevgep$sum = 0, $sfb$018 = 0, $sfb$114 = 0, $sfb$25 = 0, $storemerge = 0, dest = 0, label = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 2304|0;
 $ixwork = sp;
 $0 = ((($cod_info)) + 4768|0);
 HEAP32[$0>>2] = 0;
 $1 = ((($cod_info)) + 4772|0);
 HEAP32[$1>>2] = 0;
 $2 = ((($cod_info)) + 4776|0);
 HEAP32[$2>>2] = 0;
 $3 = ((($cod_info)) + 4780|0);
 HEAP32[$3>>2] = 210;
 $4 = ((($cod_info)) + 4784|0);
 HEAP32[$4>>2] = 0;
 $5 = ((($cod_info)) + 4796|0);
 $6 = ((($gfc)) + 64|0);
 dest=$5; stop=dest+52|0; do { HEAP32[dest>>2]=0|0; dest=dest+4|0; } while ((dest|0) < (stop|0));
 $7 = HEAP32[$6>>2]|0;
 $8 = ($7|0)<(8001);
 $9 = ((($cod_info)) + 4848|0);
 if ($8) {
  HEAP32[$9>>2] = 17;
  $$sink = 17;$$sink27 = 9;$18 = 17;
 } else {
  HEAP32[$9>>2] = 21;
  $10 = ((($gfc)) + 85092|0);
  $11 = HEAP32[$10>>2]|0;
  $12 = ($11|0)!=(0);
  $13 = $12 ? 22 : 21;
  $$sink = $13;$$sink27 = 12;$18 = 21;
 }
 $14 = ((($cod_info)) + 4852|0);
 HEAP32[$14>>2] = $$sink27;
 $15 = ((($cod_info)) + 4856|0);
 HEAP32[$15>>2] = $$sink;
 $16 = ((($cod_info)) + 4864|0);
 HEAP32[$16>>2] = $$sink;
 $17 = ((($cod_info)) + 4860|0);
 HEAP32[$17>>2] = $18;
 $19 = ((($cod_info)) + 4868|0);
 HEAP32[$19>>2] = 11;
 $sfb$018 = 0;
 while(1) {
  $20 = (($sfb$018) + 1)|0;
  $21 = (((($gfc)) + 21360|0) + ($20<<2)|0);
  $22 = HEAP32[$21>>2]|0;
  $23 = (((($gfc)) + 21360|0) + ($sfb$018<<2)|0);
  $24 = HEAP32[$23>>2]|0;
  $25 = (($22) - ($24))|0;
  $26 = (((($cod_info)) + 4872|0) + ($sfb$018<<2)|0);
  HEAP32[$26>>2] = $25;
  $27 = (((($cod_info)) + 5028|0) + ($sfb$018<<2)|0);
  HEAP32[$27>>2] = 3;
  $exitcond26 = ($20|0)==(22);
  if ($exitcond26) {
   break;
  } else {
   $sfb$018 = $20;
  }
 }
 $28 = ((($cod_info)) + 4788|0);
 $29 = HEAP32[$28>>2]|0;
 $30 = ($29|0)==(2);
 if ($30) {
  HEAP32[$14>>2] = 0;
  HEAP32[$9>>2] = 0;
  $31 = ((($cod_info)) + 4792|0);
  $32 = HEAP32[$31>>2]|0;
  $33 = ($32|0)==(0);
  if ($33) {
   $41 = 0;$44 = 0;
  } else {
   HEAP32[$14>>2] = 3;
   $34 = ((($gfc)) + 76|0);
   $35 = HEAP32[$34>>2]|0;
   $36 = $35 << 1;
   $37 = (($36) + 4)|0;
   HEAP32[$9>>2] = $37;
   $41 = 3;$44 = $37;
  }
  $38 = HEAP32[$6>>2]|0;
  $39 = ($38|0)<(8001);
  if ($39) {
   $40 = (9 - ($41))|0;
   $42 = ($40*3)|0;
   $43 = (($42) + ($44))|0;
   HEAP32[$16>>2] = $43;
   $storemerge = $43;
  } else {
   $45 = ((($gfc)) + 85092|0);
   $46 = HEAP32[$45>>2]|0;
   $47 = ($46|0)!=(0);
   $48 = $47 ? 13 : 12;
   $49 = (($48) - ($41))|0;
   $50 = ($49*3)|0;
   $51 = (($50) + ($44))|0;
   HEAP32[$16>>2] = $51;
   $52 = (12 - ($41))|0;
   $53 = ($52*3)|0;
   $54 = (($53) + ($44))|0;
   $storemerge = $54;
  }
  HEAP32[$17>>2] = $storemerge;
  $55 = (($storemerge) + -18)|0;
  HEAP32[$19>>2] = $55;
  HEAP32[$15>>2] = $44;
  $56 = (((($gfc)) + 21360|0) + ($44<<2)|0);
  $57 = HEAP32[$56>>2]|0;
  _memcpy(($ixwork|0),($cod_info|0),2304)|0;
  $58 = (($cod_info) + ($57<<2)|0);
  $$phi$trans$insert = (((($gfc)) + 21452|0) + ($41<<2)|0);
  $$pre = HEAP32[$$phi$trans$insert>>2]|0;
  $63 = $$pre;$ix$013 = $58;$sfb$114 = $41;
  while(1) {
   $59 = (($sfb$114) + 1)|0;
   $60 = (((($gfc)) + 21452|0) + ($59<<2)|0);
   $61 = HEAP32[$60>>2]|0;
   $62 = ($61|0)>($63|0);
   if ($62) {
    $69 = (($61) - ($63))|0;
    $ix$26$us = $ix$013;$l$07$us = $63;
    while(1) {
     $64 = ($l$07$us*3)|0;
     $65 = (($ixwork) + ($64<<2)|0);
     $66 = HEAP32[$65>>2]|0;
     $67 = ((($ix$26$us)) + 4|0);
     HEAP32[$ix$26$us>>2] = $66;
     $68 = (($l$07$us) + 1)|0;
     $exitcond20 = ($68|0)==($61|0);
     if ($exitcond20) {
      break;
     } else {
      $ix$26$us = $67;$l$07$us = $68;
     }
    }
    $scevgep = (($ix$013) + ($69<<2)|0);
    $ix$26$us$1 = $scevgep;$l$07$us$1 = $63;
    while(1) {
     $213 = ($l$07$us$1*3)|0;
     $214 = (($213) + 1)|0;
     $215 = (($ixwork) + ($214<<2)|0);
     $216 = HEAP32[$215>>2]|0;
     $217 = ((($ix$26$us$1)) + 4|0);
     HEAP32[$ix$26$us$1>>2] = $216;
     $218 = (($l$07$us$1) + 1)|0;
     $exitcond20$1 = ($218|0)==($61|0);
     if ($exitcond20$1) {
      break;
     } else {
      $ix$26$us$1 = $217;$l$07$us$1 = $218;
     }
    }
    $scevgep$sum = $69 << 1;
    $scevgep$1 = (($ix$013) + ($scevgep$sum<<2)|0);
    $ix$26$us$2 = $scevgep$1;$l$07$us$2 = $63;
    while(1) {
     $219 = ($l$07$us$2*3)|0;
     $220 = (($219) + 2)|0;
     $221 = (($ixwork) + ($220<<2)|0);
     $222 = HEAP32[$221>>2]|0;
     $223 = ((($ix$26$us$2)) + 4|0);
     HEAP32[$ix$26$us$2>>2] = $222;
     $224 = (($l$07$us$2) + 1)|0;
     $exitcond20$2 = ($224|0)==($61|0);
     if ($exitcond20$2) {
      break;
     } else {
      $ix$26$us$2 = $223;$l$07$us$2 = $224;
     }
    }
    $scevgep$1$sum = ($69*3)|0;
    $scevgep$2 = (($ix$013) + ($scevgep$1$sum<<2)|0);
    $ix$1$lcssa = $scevgep$2;
   } else {
    $ix$1$lcssa = $ix$013;
   }
   $exitcond25 = ($59|0)==(13);
   if ($exitcond25) {
    $j$04 = $44;$sfb$25 = $41;
    break;
   } else {
    $63 = $61;$ix$013 = $ix$1$lcssa;$sfb$114 = $59;
   }
  }
  while(1) {
   $70 = (($sfb$25) + 1)|0;
   $71 = (((($gfc)) + 21452|0) + ($70<<2)|0);
   $72 = HEAP32[$71>>2]|0;
   $73 = (((($gfc)) + 21452|0) + ($sfb$25<<2)|0);
   $74 = HEAP32[$73>>2]|0;
   $75 = (($72) - ($74))|0;
   $76 = (($j$04) + 2)|0;
   $77 = (((($cod_info)) + 4872|0) + ($76<<2)|0);
   HEAP32[$77>>2] = $75;
   $78 = (($j$04) + 1)|0;
   $79 = (((($cod_info)) + 4872|0) + ($78<<2)|0);
   HEAP32[$79>>2] = $75;
   $80 = (((($cod_info)) + 4872|0) + ($j$04<<2)|0);
   HEAP32[$80>>2] = $75;
   $81 = (((($cod_info)) + 5028|0) + ($j$04<<2)|0);
   HEAP32[$81>>2] = 0;
   $82 = (((($cod_info)) + 5028|0) + ($78<<2)|0);
   HEAP32[$82>>2] = 1;
   $83 = (((($cod_info)) + 5028|0) + ($76<<2)|0);
   HEAP32[$83>>2] = 2;
   $84 = (($j$04) + 3)|0;
   $exitcond = ($70|0)==(13);
   if ($exitcond) {
    break;
   } else {
    $j$04 = $84;$sfb$25 = $70;
   }
  }
 }
 $85 = ((($cod_info)) + 5184|0);
 HEAP32[$85>>2] = 0;
 $86 = ((($cod_info)) + 5188|0);
 HEAP32[$86>>2] = 11824;
 $87 = ((($cod_info)) + 5192|0);
 $88 = ((($cod_info)) + 5208|0);
 ;HEAP32[$87>>2]=0|0;HEAP32[$87+4>>2]=0|0;HEAP32[$87+8>>2]=0|0;HEAP32[$87+12>>2]=0|0;
 HEAP32[$88>>2] = 575;
 $89 = ((($cod_info)) + 4608|0);
 _memset(($89|0),0,156)|0;
 $90 = ((($gfc)) + 104|0);
 $91 = HEAP32[$90>>2]|0;
 if ((($91|0) == 0) | (($91|0) == 3) | (($91|0) == 4) | (($91|0) == 1)) {
  STACKTOP = sp;return;
 }
 $92 = ((($gfc)) + 85796|0);
 $93 = HEAP32[$92>>2]|0;
 $94 = HEAP32[$28>>2]|0;
 $95 = ($94|0)==(2);
 if (!($95)) {
  $96 = ((($93)) + 8|0);
  $97 = ((($93)) + 20|0);
  $98 = ((($gfc)) + 84852|0);
  $gsfb$022$i = 5;
  L40: while(1) {
   $105 = (((($gfc)) + 21508|0) + ($gsfb$022$i<<2)|0);
   $106 = HEAP32[$105>>2]|0;
   $107 = (($gsfb$022$i) + 1)|0;
   $108 = (((($gfc)) + 21508|0) + ($107<<2)|0);
   $109 = HEAP32[$108>>2]|0;
   $110 = +HEAPF32[$96>>2];
   $111 = (((($93)) + 164|0) + ($gsfb$022$i<<2)|0);
   $112 = +HEAPF32[$111>>2];
   $113 = +HEAPF32[$97>>2];
   $114 = (+_athAdjust($110,$112,$113,0.0));
   $115 = +HEAPF32[$98>>2];
   $116 = $115 > 9.999999960041972E-13;
   $117 = $115 * $114;
   $ath21$0$i = $116 ? $117 : $114;
   $118 = ($109|0)>($106|0);
   if ($118) {
    $j$015$in$i = $109;
    while(1) {
     $j$015$i = (($j$015$in$i) + -1)|0;
     $119 = (($cod_info) + ($j$015$i<<2)|0);
     $120 = +HEAPF32[$119>>2];
     $fabsf2$i = (+Math_abs((+$120)));
     $121 = $fabsf2$i < $ath21$0$i;
     if (!($121)) {
      label = 32;
      break L40;
     }
     HEAPF32[$119>>2] = 0.0;
     $122 = ($j$015$i|0)>($106|0);
     if ($122) {
      $j$015$in$i = $j$015$i;
     } else {
      break;
     }
    }
   }
   $123 = (($gsfb$022$i) + -1)|0;
   $124 = ($gsfb$022$i|0)>(0);
   if ($124) {
    $gsfb$022$i = $123;
   } else {
    label = 32;
    break;
   }
  }
  if ((label|0) == 32) {
   STACKTOP = sp;return;
  }
 }
 $99 = ((($gfc)) + 21500|0);
 $100 = ((($gfc)) + 21504|0);
 $101 = ((($gfc)) + 21536|0);
 $102 = ((($93)) + 8|0);
 $103 = ((($93)) + 20|0);
 $104 = ((($gfc)) + 84904|0);
 $gsfb1$011$i = 5;
 L51: while(1) {
  $125 = HEAP32[$99>>2]|0;
  $126 = ($125*3)|0;
  $127 = (((($gfc)) + 21536|0) + ($gsfb1$011$i<<2)|0);
  $128 = HEAP32[$127>>2]|0;
  $129 = HEAP32[$101>>2]|0;
  $130 = (($128) - ($129))|0;
  $131 = (($126) + ($130))|0;
  $132 = (($gsfb1$011$i) + 1)|0;
  $133 = (((($gfc)) + 21536|0) + ($132<<2)|0);
  $134 = HEAP32[$133>>2]|0;
  $135 = (($134) - ($128))|0;
  $136 = +HEAPF32[$102>>2];
  $137 = (((($93)) + 188|0) + ($gsfb1$011$i<<2)|0);
  $138 = +HEAPF32[$137>>2];
  $139 = +HEAPF32[$103>>2];
  $140 = (+_athAdjust($136,$138,$139,0.0));
  $141 = +HEAPF32[$104>>2];
  $142 = $141 > 9.999999960041972E-13;
  $143 = $141 * $140;
  $ath12$0$i = $142 ? $143 : $140;
  $144 = ($135|0)>(0);
  if ($144) {
   $145 = (($135) + ($131))|0;
   $j5$08$in$i = $145;
   while(1) {
    $j5$08$i = (($j5$08$in$i) + -1)|0;
    $146 = (($cod_info) + ($j5$08$i<<2)|0);
    $147 = +HEAPF32[$146>>2];
    $fabsf$i = (+Math_abs((+$147)));
    $148 = $fabsf$i < $ath12$0$i;
    if (!($148)) {
     $gsfb1$011$i$1 = 5;
     break L51;
    }
    HEAPF32[$146>>2] = 0.0;
    $149 = ($j5$08$i|0)>($131|0);
    if ($149) {
     $j5$08$in$i = $j5$08$i;
    } else {
     break;
    }
   }
  }
  $150 = (($gsfb1$011$i) + -1)|0;
  $151 = ($gsfb1$011$i|0)>(0);
  if ($151) {
   $gsfb1$011$i = $150;
  } else {
   $gsfb1$011$i$1 = 5;
   break;
  }
 }
 L59: while(1) {
  $152 = HEAP32[$99>>2]|0;
  $153 = ($152*3)|0;
  $154 = HEAP32[$100>>2]|0;
  $155 = (($154) - ($152))|0;
  $156 = (($155) + ($153))|0;
  $157 = (((($gfc)) + 21536|0) + ($gsfb1$011$i$1<<2)|0);
  $158 = HEAP32[$157>>2]|0;
  $159 = HEAP32[$101>>2]|0;
  $160 = (($158) - ($159))|0;
  $161 = (($156) + ($160))|0;
  $162 = (($gsfb1$011$i$1) + 1)|0;
  $163 = (((($gfc)) + 21536|0) + ($162<<2)|0);
  $164 = HEAP32[$163>>2]|0;
  $165 = (($164) - ($158))|0;
  $166 = +HEAPF32[$102>>2];
  $167 = (((($93)) + 188|0) + ($gsfb1$011$i$1<<2)|0);
  $168 = +HEAPF32[$167>>2];
  $169 = +HEAPF32[$103>>2];
  $170 = (+_athAdjust($166,$168,$169,0.0));
  $171 = +HEAPF32[$104>>2];
  $172 = $171 > 9.999999960041972E-13;
  $173 = $171 * $170;
  $ath12$0$i$1 = $172 ? $173 : $170;
  $174 = ($165|0)>(0);
  if ($174) {
   $175 = (($165) + ($161))|0;
   $j5$08$in$i$1 = $175;
   while(1) {
    $j5$08$i$1 = (($j5$08$in$i$1) + -1)|0;
    $176 = (($cod_info) + ($j5$08$i$1<<2)|0);
    $177 = +HEAPF32[$176>>2];
    $fabsf$i$1 = (+Math_abs((+$177)));
    $178 = $fabsf$i$1 < $ath12$0$i$1;
    if (!($178)) {
     $gsfb1$011$i$2 = 5;
     break L59;
    }
    HEAPF32[$176>>2] = 0.0;
    $179 = ($j5$08$i$1|0)>($161|0);
    if ($179) {
     $j5$08$in$i$1 = $j5$08$i$1;
    } else {
     break;
    }
   }
  }
  $180 = (($gsfb1$011$i$1) + -1)|0;
  $181 = ($gsfb1$011$i$1|0)>(0);
  if ($181) {
   $gsfb1$011$i$1 = $180;
  } else {
   $gsfb1$011$i$2 = 5;
   break;
  }
 }
 L67: while(1) {
  $182 = HEAP32[$99>>2]|0;
  $183 = ($182*3)|0;
  $184 = HEAP32[$100>>2]|0;
  $185 = (($184) - ($182))|0;
  $186 = $185 << 1;
  $187 = (($186) + ($183))|0;
  $188 = (((($gfc)) + 21536|0) + ($gsfb1$011$i$2<<2)|0);
  $189 = HEAP32[$188>>2]|0;
  $190 = HEAP32[$101>>2]|0;
  $191 = (($189) - ($190))|0;
  $192 = (($187) + ($191))|0;
  $193 = (($gsfb1$011$i$2) + 1)|0;
  $194 = (((($gfc)) + 21536|0) + ($193<<2)|0);
  $195 = HEAP32[$194>>2]|0;
  $196 = (($195) - ($189))|0;
  $197 = +HEAPF32[$102>>2];
  $198 = (((($93)) + 188|0) + ($gsfb1$011$i$2<<2)|0);
  $199 = +HEAPF32[$198>>2];
  $200 = +HEAPF32[$103>>2];
  $201 = (+_athAdjust($197,$199,$200,0.0));
  $202 = +HEAPF32[$104>>2];
  $203 = $202 > 9.999999960041972E-13;
  $204 = $202 * $201;
  $ath12$0$i$2 = $203 ? $204 : $201;
  $205 = ($196|0)>(0);
  if ($205) {
   $206 = (($196) + ($192))|0;
   $j5$08$in$i$2 = $206;
   while(1) {
    $j5$08$i$2 = (($j5$08$in$i$2) + -1)|0;
    $207 = (($cod_info) + ($j5$08$i$2<<2)|0);
    $208 = +HEAPF32[$207>>2];
    $fabsf$i$2 = (+Math_abs((+$208)));
    $209 = $fabsf$i$2 < $ath12$0$i$2;
    if (!($209)) {
     label = 32;
     break L67;
    }
    HEAPF32[$207>>2] = 0.0;
    $210 = ($j5$08$i$2|0)>($192|0);
    if ($210) {
     $j5$08$in$i$2 = $j5$08$i$2;
    } else {
     break;
    }
   }
  }
  $211 = (($gsfb1$011$i$2) + -1)|0;
  $212 = ($gsfb1$011$i$2|0)>(0);
  if ($212) {
   $gsfb1$011$i$2 = $211;
  } else {
   label = 32;
   break;
  }
 }
 if ((label|0) == 32) {
  STACKTOP = sp;return;
 }
}
function _outer_loop($gfc,$cod_info,$l3_xmin,$xrpow,$ch,$targ_bits) {
 $gfc = $gfc|0;
 $cod_info = $cod_info|0;
 $l3_xmin = $l3_xmin|0;
 $xrpow = $xrpow|0;
 $ch = $ch|0;
 $targ_bits = $targ_bits|0;
 var $$ = 0, $$$$i = 0, $$$flag_GoneOver$3$i = 0, $$$i = 0, $$$i$i = 0.0, $$0 = 0, $$1$i$i = 0, $$6 = 0, $$flag_GoneOver$0$i = 0, $$flag_GoneOver$01$i = 0, $$lcssa$i = 0, $$lcssa120 = 0, $$lcssa26 = 0, $$lcssa27 = 0, $$not = 0, $$not84 = 0, $$pre = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i10 = 0.0;
 var $$pre$i13$i = 0, $$pre$phi$i$iZ2D = 0, $$pre41$i$i = 0, $$pre61 = 0.0, $$pre62 = 0.0, $$pre63 = 0.0, $$pre64 = 0.0, $$pre65 = 0, $$s1$0$i$i = 0, $$s1$0$i$i$lcssa = 0, $$s2$0$i$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0.0, $104 = 0, $105 = 0;
 var $106 = 0.0, $107 = 0.0, $108 = 0.0, $109 = 0.0, $11 = 0, $110 = 0, $111 = 0.0, $112 = 0.0, $113 = 0.0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0.0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0;
 var $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0.0, $137 = 0.0, $138 = 0, $139 = 0.0, $14 = 0, $140 = 0, $141 = 0;
 var $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0;
 var $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0;
 var $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0.0, $184 = 0.0, $185 = 0, $186 = 0.0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0;
 var $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0;
 var $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0;
 var $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0;
 var $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0.0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0.0, $264 = 0.0, $265 = 0, $266 = 0.0, $267 = 0, $268 = 0;
 var $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0.0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0.0, $284 = 0.0, $285 = 0, $286 = 0.0;
 var $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0;
 var $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0;
 var $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0;
 var $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0.0, $35 = 0, $350 = 0, $351 = 0.0, $352 = 0.0, $353 = 0.0, $354 = 0.0, $355 = 0.0, $356 = 0, $357 = 0.0, $358 = 0.0;
 var $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0.0, $367 = 0.0, $368 = 0, $369 = 0, $37 = 0, $370 = 0.0, $371 = 0.0, $372 = 0.0, $373 = 0.0, $374 = 0, $375 = 0.0, $376 = 0.0;
 var $377 = 0, $378 = 0.0, $379 = 0.0, $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0.0, $387 = 0.0, $388 = 0.0, $389 = 0.0, $39 = 0, $390 = 0.0, $391 = 0.0, $392 = 0.0, $393 = 0.0, $394 = 0.0;
 var $395 = 0.0, $396 = 0.0, $397 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0, $400 = 0, $401 = 0.0, $402 = 0.0, $403 = 0.0, $404 = 0, $405 = 0.0, $406 = 0, $407 = 0.0, $408 = 0.0, $409 = 0, $41 = 0, $410 = 0, $411 = 0.0;
 var $412 = 0.0, $413 = 0, $414 = 0.0, $415 = 0.0, $416 = 0, $417 = 0, $418 = 0, $419 = 0.0, $42 = 0, $420 = 0, $421 = 0.0, $422 = 0.0, $423 = 0.0, $424 = 0, $425 = 0.0, $426 = 0, $427 = 0.0, $428 = 0, $429 = 0.0, $43 = 0;
 var $430 = 0.0, $431 = 0, $432 = 0.0, $433 = 0.0, $434 = 0.0, $435 = 0.0, $436 = 0, $437 = 0, $438 = 0.0, $439 = 0.0, $44 = 0, $440 = 0, $441 = 0.0, $442 = 0.0, $443 = 0, $444 = 0.0, $445 = 0.0, $446 = 0.0, $447 = 0.0, $448 = 0.0;
 var $449 = 0.0, $45 = 0, $450 = 0, $451 = 0, $452 = 0.0, $453 = 0, $454 = 0.0, $455 = 0.0, $456 = 0.0, $457 = 0.0, $458 = 0.0, $459 = 0.0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0.0, $464 = 0.0, $465 = 0, $466 = 0;
 var $467 = 0.0, $468 = 0.0, $469 = 0.0, $47 = 0, $470 = 0.0, $471 = 0, $472 = 0.0, $473 = 0.0, $474 = 0, $475 = 0.0, $476 = 0.0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0.0, $481 = 0.0, $482 = 0, $483 = 0, $484 = 0.0;
 var $485 = 0.0, $486 = 0.0, $487 = 0.0, $488 = 0, $489 = 0.0, $49 = 0, $490 = 0.0, $491 = 0, $492 = 0.0, $493 = 0.0, $494 = 0, $495 = 0, $496 = 0.0, $497 = 0.0, $498 = 0.0, $499 = 0.0, $5 = 0, $50 = 0, $500 = 0, $501 = 0.0;
 var $502 = 0.0, $503 = 0, $504 = 0.0, $505 = 0.0, $506 = 0, $507 = 0, $508 = 0, $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0.0, $513 = 0.0, $514 = 0, $515 = 0, $516 = 0, $517 = 0, $518 = 0, $519 = 0, $52 = 0;
 var $520 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0, $525 = 0, $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $534 = 0, $535 = 0, $536 = 0, $537 = 0, $538 = 0;
 var $539 = 0, $54 = 0, $540 = 0, $541 = 0, $542 = 0, $543 = 0, $544 = 0, $545 = 0, $546 = 0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0, $552 = 0, $553 = 0, $554 = 0, $555 = 0.0, $556 = 0.0;
 var $557 = 0, $558 = 0, $559 = 0.0, $56 = 0, $560 = 0.0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0;
 var $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0.0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0.0;
 var $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0.0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0.0, $99 = 0, $CurrentStep$06$i = 0, $CurrentStep$1$i = 0, $CurrentStep$2$i = 0, $CurrentStep$3$i = 0, $Direction$08$i = 0, $Direction$1$i = 0, $age$1 = 0, $age$2 = 0;
 var $bRefine$041 = 0, $best_ggain_pass1$042 = 0, $best_noise_info = 0, $best_part2_3_length$040 = 0, $best_part2_3_length$1 = 0, $best_part2_3_length$2 = 0, $best_part2_3_length$3 = 0, $best_part2_3_length$3$ph = 0, $better$0 = 0, $better$0$i = 0, $better$0$in = 0, $better$1$i = 0, $brmerge = 0, $cod_info_w = 0, $distort = 0, $exitcond$i = 0, $fabs$i$i = 0.0, $fabsf$i = 0.0, $fabsf1$i = 0.0, $fabsf10$i = 0.0;
 var $fabsf11$i = 0.0, $fabsf2$i = 0.0, $fabsf3$i = 0.0, $fabsf4$i = 0.0, $fabsf5$i = 0.0, $fabsf6$i = 0.0, $fabsf7$i = 0.0, $fabsf8$i = 0.0, $fabsf9$i = 0.0, $factor$i = 0.0, $factor17$i = 0.0, $flag_GoneOver$07$i = 0, $flag_GoneOver$3$i = 0, $indvars$iv$i$i = 0, $indvars$iv$next$i$i = 0, $indvars$iv$next37$i$i = 0, $indvars$iv36$i$i = 0, $j$0$lcssa$i$i = 0, $j$019$i$i = 0, $j$03$i$i = 0;
 var $j$05$i$i = 0, $j$1$i$i = 0, $klemm_noise$0$lcssa$i$i = 0.0, $klemm_noise$02$i$i = 0.0, $l$01$i$i = 0, $l$015$i$i = 0, $l$02$i$i = 0, $l$126$i$i = 0, $nBits$0$lcssa$i = 0, $nBits$02$i = 0, $noise_info = 0, $noise_shaping_amp$0$i$i = 0, $or$cond = 0, $or$cond$i = 0, $or$cond$i$i = 0, $or$cond$i13 = 0, $or$cond14$i = 0, $or$cond16 = 0, $or$cond3 = 0, $or$cond5$i = 0;
 var $or$cond8 = 0, $or$cond9 = 0, $prev_noise = 0, $s$0$i$i = 0, $s$1$i$i = 0, $s1$0$lcssa$i$i = 0, $s1$07$i$i = 0, $s2$0$lcssa$i$i = 0, $s2$010$i$i = 0, $save_xrpow = 0, $sfb$01$i$i = 0, $sfb$01$i$i11 = 0, $sfb$01$i5$i = 0, $sfb$011$i$i = 0, $sfb$02$i$i = 0, $sfb$031$i$i = 0, $sfb$1$lcssa$i$i = 0, $sfb$13$i$i = 0, $sfb$18$i$i = 0, $sfb$211$i$i = 0;
 var $sfb$3$lcssa$i$i = 0, $sfb$320$i$i = 0, $smax$i$i = 0, $sqrt$i$i = 0.0, $step$0$i = 0, $trigger$0$lcssa$i$i = 0.0, $trigger$012$i$i = 0.0, $trigger$1$i$i = 0.0, $trigger$2$i$i = 0.0, $window$029$i$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 8256|0;
 $cod_info_w = sp + 2992|0;
 $save_xrpow = sp + 688|0;
 $distort = sp + 528|0;
 $best_noise_info = sp + 504|0;
 $prev_noise = sp + 24|0;
 $noise_info = sp;
 $0 = (((($gfc)) + 84928|0) + ($ch<<2)|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = (((($gfc)) + 84920|0) + ($ch<<2)|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ((($cod_info)) + 4780|0);
 HEAP32[$4>>2] = $3;
 $5 = ((($cod_info)) + 4844|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = (($targ_bits) - ($6))|0;
 $8 = (_count_bits($gfc,$xrpow,$cod_info,0)|0);
 $9 = ($1|0)==(1);
 $10 = ($8|0)==($7|0);
 $or$cond5$i = $9 | $10;
 if ($or$cond5$i) {
  $$lcssa$i = $8;
 } else {
  $12 = $8;$CurrentStep$06$i = $1;$Direction$08$i = 0;$flag_GoneOver$07$i = 0;
  while(1) {
   $13 = ($12|0)>($7|0);
   if ($13) {
    $14 = ($Direction$08$i|0)==(2);
    $$flag_GoneOver$0$i = $14 ? 1 : $flag_GoneOver$07$i;
    $15 = ($$flag_GoneOver$0$i|0)==(0);
    $16 = (($CurrentStep$06$i|0) / 2)&-1;
    $CurrentStep$1$i = $15 ? $CurrentStep$06$i : $16;
    $CurrentStep$3$i = $CurrentStep$1$i;$Direction$1$i = 1;$flag_GoneOver$3$i = $$flag_GoneOver$0$i;$step$0$i = $CurrentStep$1$i;
   } else {
    $17 = ($Direction$08$i|0)==(1);
    $$flag_GoneOver$01$i = $17 ? 1 : $flag_GoneOver$07$i;
    $18 = ($$flag_GoneOver$01$i|0)==(0);
    $19 = (($CurrentStep$06$i|0) / 2)&-1;
    $CurrentStep$2$i = $18 ? $CurrentStep$06$i : $19;
    $20 = (0 - ($CurrentStep$2$i))|0;
    $CurrentStep$3$i = $CurrentStep$2$i;$Direction$1$i = 2;$flag_GoneOver$3$i = $$flag_GoneOver$01$i;$step$0$i = $20;
   }
   $21 = HEAP32[$4>>2]|0;
   $22 = (($21) + ($step$0$i))|0;
   $23 = ($22|0)<(0);
   $$$i = $23 ? 0 : $22;
   $24 = ($$$i|0)>(255);
   $$$$i = $24 ? 255 : $$$i;
   HEAP32[$4>>2] = $$$$i;
   $25 = $23 | $24;
   $$$flag_GoneOver$3$i = $25 ? 1 : $flag_GoneOver$3$i;
   $26 = (_count_bits($gfc,$xrpow,$cod_info,0)|0);
   $27 = ($CurrentStep$3$i|0)==(1);
   $28 = ($26|0)==($7|0);
   $or$cond$i = $27 | $28;
   if ($or$cond$i) {
    $$lcssa$i = $26;
    break;
   } else {
    $12 = $26;$CurrentStep$06$i = $CurrentStep$3$i;$Direction$08$i = $Direction$1$i;$flag_GoneOver$07$i = $$$flag_GoneOver$3$i;
   }
  }
 }
 $11 = ($$lcssa$i|0)>($7|0);
 L9: do {
  if ($11) {
   $nBits$02$i = $$lcssa$i;
   while(1) {
    $29 = HEAP32[$4>>2]|0;
    $30 = ($29|0)<(255);
    if (!($30)) {
     $nBits$0$lcssa$i = $nBits$02$i;
     break L9;
    }
    $31 = (($29) + 1)|0;
    HEAP32[$4>>2] = $31;
    $32 = (_count_bits($gfc,$xrpow,$cod_info,0)|0);
    $33 = ($32|0)>($7|0);
    if ($33) {
     $nBits$02$i = $32;
    } else {
     $nBits$0$lcssa$i = $32;
     break;
    }
   }
  } else {
   $nBits$0$lcssa$i = $$lcssa$i;
  }
 } while(0);
 $34 = HEAP32[$4>>2]|0;
 $35 = (($3) - ($34))|0;
 $36 = ($35|0)>(3);
 $37 = $36 ? 4 : 2;
 HEAP32[$0>>2] = $37;
 $38 = HEAP32[$4>>2]|0;
 HEAP32[$2>>2] = $38;
 $39 = ((($cod_info)) + 4768|0);
 HEAP32[$39>>2] = $nBits$0$lcssa$i;
 $40 = ((($gfc)) + 28|0);
 $41 = HEAP32[$40>>2]|0;
 $42 = ($41|0)==(0);
 if ($42) {
  $$0 = 100;
  STACKTOP = sp;return ($$0|0);
 }
 _memset(($prev_noise|0),0,476)|0;
 (_calc_noise($cod_info,$l3_xmin,$distort,$best_noise_info,$prev_noise)|0);
 $43 = HEAP32[$39>>2]|0;
 $44 = ((($best_noise_info)) + 20|0);
 HEAP32[$44>>2] = $43;
 _memcpy(($cod_info_w|0),($cod_info|0),5252)|0;
 _memcpy(($save_xrpow|0),($xrpow|0),2304)|0;
 $45 = ((($gfc)) + 85096|0);
 $46 = ((($gfc)) + 85092|0);
 $47 = ((($cod_info_w)) + 4836|0);
 $48 = ((($cod_info_w)) + 4860|0);
 $49 = ((($gfc)) + 40|0);
 $50 = ((($cod_info_w)) + 4764|0);
 $51 = ((($cod_info_w)) + 4844|0);
 $52 = ((($cod_info_w)) + 4768|0);
 $53 = ((($cod_info_w)) + 4780|0);
 $54 = ((($best_noise_info)) + 12|0);
 $55 = ((($noise_info)) + 20|0);
 $56 = ((($cod_info)) + 4788|0);
 $57 = ((($gfc)) + 84|0);
 $58 = ((($gfc)) + 88|0);
 $59 = ((($noise_info)) + 16|0);
 $60 = ((($best_noise_info)) + 16|0);
 $61 = ((($noise_info)) + 8|0);
 $62 = ((($best_noise_info)) + 8|0);
 $63 = ((($gfc)) + 48|0);
 $64 = ((($noise_info)) + 12|0);
 $65 = ((($noise_info)) + 4|0);
 $66 = ((($best_noise_info)) + 4|0);
 $67 = ((($cod_info_w)) + 4864|0);
 $68 = ((($gfc)) + 84936|0);
 $69 = ((($cod_info_w)) + 4832|0);
 $70 = ((($cod_info_w)) + 4788|0);
 $71 = ((($gfc)) + 32|0);
 $72 = ((($cod_info_w)) + 4848|0);
 $73 = ((($cod_info_w)) + 4868|0);
 $bRefine$041 = 0;$best_ggain_pass1$042 = 0;$best_part2_3_length$040 = 9999999;
 while(1) {
  $74 = ($bRefine$041|0)==(1);
  $$1$i$i = $74 ? 2 : 1;
  $75 = ($bRefine$041|0)!=(0);
  $age$1 = 0;$best_part2_3_length$1 = $best_part2_3_length$040;
  L19: while(1) {
   $76 = HEAP32[$45>>2]|0;
   $77 = $76 & 2;
   $78 = ($77|0)==(0);
   $$ = $78 ? 3 : 20;
   $79 = HEAP32[$46>>2]|0;
   $80 = ($79|0)==(0);
   $$pre = HEAP32[$48>>2]|0;
   if (!($80)) {
    $81 = (($distort) + ($$pre<<2)|0);
    $82 = +HEAPF32[$81>>2];
    $83 = $82 > 1.0;
    if ($83) {
     $best_part2_3_length$3$ph = $best_part2_3_length$1;
     label = 167;
     break;
    }
    $84 = HEAP32[$70>>2]|0;
    $85 = ($84|0)==(2);
    if ($85) {
     $86 = (($$pre) + 1)|0;
     $87 = (($distort) + ($86<<2)|0);
     $88 = +HEAPF32[$87>>2];
     $89 = $88 > 1.0;
     if ($89) {
      $best_part2_3_length$3$ph = $best_part2_3_length$1;
      label = 167;
      break;
     }
     $90 = (($$pre) + 2)|0;
     $91 = (($distort) + ($90<<2)|0);
     $92 = +HEAPF32[$91>>2];
     $93 = $92 > 1.0;
     if ($93) {
      $best_part2_3_length$3$ph = $best_part2_3_length$1;
      label = 167;
      break;
     }
    }
   }
   $94 = HEAP32[$47>>2]|0;
   $95 = ($94|0)==(0);
   $$$i$i = $95 ? 1.2968395948410034 : 1.6817928552627563;
   $96 = ($$pre|0)>(0);
   if ($96) {
    $sfb$011$i$i = 0;$trigger$012$i$i = 0.0;
    while(1) {
     $97 = (($distort) + ($sfb$011$i$i<<2)|0);
     $98 = +HEAPF32[$97>>2];
     $99 = $trigger$012$i$i < $98;
     $trigger$1$i$i = $99 ? $98 : $trigger$012$i$i;
     $100 = (($sfb$011$i$i) + 1)|0;
     $exitcond$i = ($100|0)==($$pre|0);
     if ($exitcond$i) {
      $trigger$0$lcssa$i$i = $trigger$1$i$i;
      break;
     } else {
      $sfb$011$i$i = $100;$trigger$012$i$i = $trigger$1$i$i;
     }
    }
   } else {
    $trigger$0$lcssa$i$i = 0.0;
   }
   $101 = HEAP32[$49>>2]|0;
   $102 = ($101|0)==(3);
   $noise_shaping_amp$0$i$i = $102 ? $$1$i$i : $101;
   do {
    if ((($noise_shaping_amp$0$i$i|0) == 1)) {
     $103 = $trigger$0$lcssa$i$i;
     $104 = $trigger$0$lcssa$i$i > 1.0;
     if ($104) {
      $sqrt$i$i = (+Math_sqrt((+$103)));
      $fabs$i$i = (+Math_abs((+$sqrt$i$i)));
      $105 = $trigger$0$lcssa$i$i == -inf;
      $106 = $fabs$i$i;
      $107 = $105 ? inf : $106;
      $trigger$2$i$i = $107;
      break;
     } else {
      $108 = $103 * 0.94999999999999996;
      $109 = $108;
      $trigger$2$i$i = $109;
      break;
     }
    } else if ((($noise_shaping_amp$0$i$i|0) == 2)) {
     $trigger$2$i$i = $trigger$0$lcssa$i$i;
    } else {
     $110 = $trigger$0$lcssa$i$i > 1.0;
     if ($110) {
      $trigger$2$i$i = 1.0;
     } else {
      $111 = $trigger$0$lcssa$i$i;
      $112 = $111 * 0.94999999999999996;
      $113 = $112;
      $trigger$2$i$i = $113;
     }
    }
   } while(0);
   if ($96) {
    $551 = $101;$552 = $$pre;$j$05$i$i = 0;$sfb$13$i$i = 0;
   } else {
    $best_part2_3_length$3$ph = $best_part2_3_length$1;
    label = 167;
    break;
   }
   while(1) {
    $114 = (((($cod_info_w)) + 4872|0) + ($sfb$13$i$i<<2)|0);
    $115 = HEAP32[$114>>2]|0;
    $116 = (($115) + ($j$05$i$i))|0;
    $117 = (($distort) + ($sfb$13$i$i<<2)|0);
    $118 = +HEAPF32[$117>>2];
    $119 = $118 < $trigger$2$i$i;
    if ($119) {
     $146 = $552;$553 = $551;
    } else {
     $120 = HEAP32[$45>>2]|0;
     $121 = $120 & 2;
     $122 = ($121|0)==(0);
     if (!($122)) {
      $123 = (((($gfc)) + 84936|0) + ($sfb$13$i$i<<2)|0);
      $124 = HEAP32[$123>>2]|0;
      $125 = ($124|0)==(0);
      $126 = $125&1;
      HEAP32[$123>>2] = $126;
      if (!($125)) {
       $127 = HEAP32[$49>>2]|0;
       $128 = ($127|0)==(2);
       if ($128) {
        $554 = 2;
        break;
       }
      }
     }
     $129 = (((($cod_info_w)) + 4608|0) + ($sfb$13$i$i<<2)|0);
     $130 = HEAP32[$129>>2]|0;
     $131 = (($130) + 1)|0;
     HEAP32[$129>>2] = $131;
     $132 = ($115|0)>(0);
     if ($132) {
      $133 = (0 - ($115))|0;
      $$pre61 = +HEAPF32[$50>>2];
      $139 = $$pre61;$l$02$i$i = $133;
      while(1) {
       $134 = (($l$02$i$i) + ($116))|0;
       $135 = (($xrpow) + ($134<<2)|0);
       $136 = +HEAPF32[$135>>2];
       $137 = $136 * $$$i$i;
       HEAPF32[$135>>2] = $137;
       $138 = $137 > $139;
       if ($138) {
        HEAPF32[$50>>2] = $137;
        $555 = $137;
       } else {
        $555 = $139;
       }
       $140 = (($l$02$i$i) + 1)|0;
       $141 = ($l$02$i$i|0)<(-1);
       if ($141) {
        $139 = $555;$l$02$i$i = $140;
       } else {
        break;
       }
      }
     }
     $142 = HEAP32[$49>>2]|0;
     $143 = ($142|0)==(2);
     if ($143) {
      $554 = 2;
      break;
     }
     $$pre$i$i = HEAP32[$48>>2]|0;
     $146 = $$pre$i$i;$553 = $142;
    }
    $144 = (($sfb$13$i$i) + 1)|0;
    $145 = ($144|0)<($146|0);
    if ($145) {
     $551 = $553;$552 = $146;$j$05$i$i = $116;$sfb$13$i$i = $144;
    } else {
     $554 = $553;
     break;
    }
   }
   $$pre$i = HEAP32[$48>>2]|0;
   $147 = ($$pre$i|0)>(0);
   if ($147) {
    $sfb$01$i$i = 0;
   } else {
    $best_part2_3_length$3$ph = $best_part2_3_length$1;
    label = 167;
    break;
   }
   while(1) {
    $150 = (((($cod_info_w)) + 4608|0) + ($sfb$01$i$i<<2)|0);
    $151 = HEAP32[$150>>2]|0;
    $152 = (((($cod_info_w)) + 5028|0) + ($sfb$01$i$i<<2)|0);
    $153 = HEAP32[$152>>2]|0;
    $154 = (((($cod_info_w)) + 4808|0) + ($153<<2)|0);
    $155 = HEAP32[$154>>2]|0;
    $156 = (0 - ($155))|0;
    $157 = ($151|0)==($156|0);
    $148 = (($sfb$01$i$i) + 1)|0;
    if ($157) {
     break;
    }
    $149 = ($148|0)<($$pre$i|0);
    if ($149) {
     $sfb$01$i$i = $148;
    } else {
     $541 = $554;$best_part2_3_length$3 = $best_part2_3_length$1;
     break L19;
    }
   }
   $158 = (_scale_bitcount($gfc,$cod_info_w)|0);
   $159 = ($158|0)==(0);
   if (!($159)) {
    $160 = HEAP32[$40>>2]|0;
    $161 = ($160|0)>(1);
    if (!($161)) {
     $best_part2_3_length$3$ph = $best_part2_3_length$1;
     label = 167;
     break;
    }
    _memset(($68|0),0,156)|0;
    $162 = HEAP32[$47>>2]|0;
    $163 = ($162|0)==(0);
    L65: do {
     if ($163) {
      $164 = HEAP32[$48>>2]|0;
      $165 = ($164|0)>(0);
      if ($165) {
       $j$03$i$i = 0;$sfb$02$i$i = 0;
       while(1) {
        $166 = (((($cod_info_w)) + 4872|0) + ($sfb$02$i$i<<2)|0);
        $167 = HEAP32[$166>>2]|0;
        $168 = (((($cod_info_w)) + 4608|0) + ($sfb$02$i$i<<2)|0);
        $169 = HEAP32[$168>>2]|0;
        $170 = HEAP32[$69>>2]|0;
        $171 = ($170|0)==(0);
        if ($171) {
         $s$0$i$i = $169;
        } else {
         $172 = (12112 + ($sfb$02$i$i<<2)|0);
         $173 = HEAP32[$172>>2]|0;
         $174 = (($173) + ($169))|0;
         $s$0$i$i = $174;
        }
        $175 = (($167) + ($j$03$i$i))|0;
        $176 = $s$0$i$i & 1;
        $177 = ($176|0)==(0);
        do {
         if ($177) {
          $s$1$i$i = $s$0$i$i;
         } else {
          $178 = (($s$0$i$i) + 1)|0;
          $179 = ($167|0)>(0);
          if (!($179)) {
           $s$1$i$i = $178;
           break;
          }
          $180 = (0 - ($167))|0;
          $$pre64 = +HEAPF32[$50>>2];
          $186 = $$pre64;$l$01$i$i = $180;
          while(1) {
           $181 = (($l$01$i$i) + ($175))|0;
           $182 = (($xrpow) + ($181<<2)|0);
           $183 = +HEAPF32[$182>>2];
           $184 = $183 * 1.2968395948410034;
           HEAPF32[$182>>2] = $184;
           $185 = $184 > $186;
           if ($185) {
            HEAPF32[$50>>2] = $184;
            $556 = $184;
           } else {
            $556 = $186;
           }
           $187 = (($l$01$i$i) + 1)|0;
           $188 = ($l$01$i$i|0)<(-1);
           if ($188) {
            $186 = $556;$l$01$i$i = $187;
           } else {
            $s$1$i$i = $178;
            break;
           }
          }
         }
        } while(0);
        $189 = $s$1$i$i >> 1;
        HEAP32[$168>>2] = $189;
        $190 = (($sfb$02$i$i) + 1)|0;
        $191 = HEAP32[$48>>2]|0;
        $192 = ($190|0)<($191|0);
        if ($192) {
         $j$03$i$i = $175;$sfb$02$i$i = $190;
        } else {
         break;
        }
       }
      }
      HEAP32[$69>>2] = 0;
      HEAP32[$47>>2] = 1;
     } else {
      $193 = HEAP32[$70>>2]|0;
      $194 = ($193|0)==(2);
      if (!($194)) {
       $best_part2_3_length$3$ph = $best_part2_3_length$1;
       label = 167;
       break L19;
      }
      $195 = HEAP32[$71>>2]|0;
      $196 = ($195|0)>(0);
      if (!($196)) {
       $best_part2_3_length$3$ph = $best_part2_3_length$1;
       label = 167;
       break L19;
      }
      $197 = HEAP32[$72>>2]|0;
      $198 = ($197|0)>(0);
      if ($198) {
       $sfb$031$i$i = 0;
       while(1) {
        $201 = (((($cod_info_w)) + 4608|0) + ($sfb$031$i$i<<2)|0);
        $202 = HEAP32[$201>>2]|0;
        $203 = ($202|0)>(15);
        $199 = (($sfb$031$i$i) + 1)|0;
        if ($203) {
         $best_part2_3_length$3$ph = $best_part2_3_length$1;
         label = 167;
         break L19;
        }
        $200 = ($199|0)<($197|0);
        if ($200) {
         $sfb$031$i$i = $199;
        } else {
         $205 = $197;$indvars$iv$i$i = 3;$indvars$iv36$i$i = -1;$window$029$i$i = 0;
         break;
        }
       }
      } else {
       $205 = $197;$indvars$iv$i$i = 3;$indvars$iv36$i$i = -1;$window$029$i$i = 0;
      }
      while(1) {
       $204 = (($window$029$i$i) + ($205))|0;
       $206 = HEAP32[$73>>2]|0;
       $207 = ($204|0)<($206|0);
       if ($207) {
        $208 = (($indvars$iv$i$i) + ($205))|0;
        $209 = ($206|0)>($208|0);
        $210 = (($indvars$iv36$i$i) - ($205))|0;
        $s1$07$i$i = 0;$sfb$18$i$i = $204;
        while(1) {
         $217 = (((($cod_info_w)) + 4608|0) + ($sfb$18$i$i<<2)|0);
         $218 = HEAP32[$217>>2]|0;
         $219 = ($s1$07$i$i|0)<($218|0);
         $$s1$0$i$i = $219 ? $218 : $s1$07$i$i;
         $220 = (($sfb$18$i$i) + 3)|0;
         $221 = ($220|0)<($206|0);
         if ($221) {
          $s1$07$i$i = $$s1$0$i$i;$sfb$18$i$i = $220;
         } else {
          $$s1$0$i$i$lcssa = $$s1$0$i$i;
          break;
         }
        }
        $smax$i$i = $209 ? $206 : $208;
        $211 = (($smax$i$i) + ($210))|0;
        $212 = (($211>>>0) % 3)&-1;
        $213 = (($211) + ($208))|0;
        $214 = (($213) - ($212))|0;
        $s1$0$lcssa$i$i = $$s1$0$i$i$lcssa;$sfb$1$lcssa$i$i = $214;
       } else {
        $s1$0$lcssa$i$i = 0;$sfb$1$lcssa$i$i = $204;
       }
       $215 = HEAP32[$48>>2]|0;
       $216 = ($sfb$1$lcssa$i$i|0)<($215|0);
       if ($216) {
        $s2$010$i$i = 0;$sfb$211$i$i = $sfb$1$lcssa$i$i;
        while(1) {
         $222 = (((($cod_info_w)) + 4608|0) + ($sfb$211$i$i<<2)|0);
         $223 = HEAP32[$222>>2]|0;
         $224 = ($s2$010$i$i|0)<($223|0);
         $$s2$0$i$i = $224 ? $223 : $s2$010$i$i;
         $225 = (($sfb$211$i$i) + 3)|0;
         $226 = ($225|0)<($215|0);
         if ($226) {
          $s2$010$i$i = $$s2$0$i$i;$sfb$211$i$i = $225;
         } else {
          $s2$0$lcssa$i$i = $$s2$0$i$i;
          break;
         }
        }
       } else {
        $s2$0$lcssa$i$i = 0;
       }
       $227 = ($s1$0$lcssa$i$i|0)<(16);
       $228 = ($s2$0$lcssa$i$i|0)<(8);
       $or$cond$i$i = $227 & $228;
       do {
        if ($or$cond$i$i) {
         $$pre41$i$i = (($window$029$i$i) + 1)|0;
         $$pre$phi$i$iZ2D = $$pre41$i$i;$557 = $215;
        } else {
         $229 = (((($cod_info_w)) + 4808|0) + ($window$029$i$i<<2)|0);
         $230 = HEAP32[$229>>2]|0;
         $231 = ($230|0)>(6);
         if ($231) {
          $best_part2_3_length$3$ph = $best_part2_3_length$1;
          label = 167;
          break L19;
         }
         $232 = (($230) + 1)|0;
         HEAP32[$229>>2] = $232;
         $233 = HEAP32[$72>>2]|0;
         $234 = (((($gfc)) + 21360|0) + ($233<<2)|0);
         $235 = HEAP32[$234>>2]|0;
         $236 = (($233) + ($window$029$i$i))|0;
         $237 = HEAP32[$48>>2]|0;
         $238 = ($236|0)<($237|0);
         $239 = (($window$029$i$i) + 1)|0;
         if ($238) {
          $240 = (2 - ($window$029$i$i))|0;
          $j$019$i$i = $235;$sfb$320$i$i = $236;
          while(1) {
           $241 = (((($cod_info_w)) + 4872|0) + ($sfb$320$i$i<<2)|0);
           $242 = HEAP32[$241>>2]|0;
           $243 = (((($cod_info_w)) + 4608|0) + ($sfb$320$i$i<<2)|0);
           $244 = HEAP32[$243>>2]|0;
           $245 = HEAP32[$47>>2]|0;
           $246 = 4 >>> $245;
           $247 = (($244) - ($246))|0;
           $248 = ($247|0)>(-1);
           if ($248) {
            HEAP32[$243>>2] = $247;
            $249 = ($242*3)|0;
            $250 = (($249) + ($j$019$i$i))|0;
            $j$1$i$i = $250;
           } else {
            HEAP32[$243>>2] = 0;
            $251 = HEAP32[$47>>2]|0;
            $252 = (($251) + 1)|0;
            $253 = $247 << $252;
            $254 = (($253) + 210)|0;
            $255 = (79704 + ($254<<2)|0);
            $256 = +HEAPF32[$255>>2];
            $257 = Math_imul($242, $239)|0;
            $258 = (($257) + ($j$019$i$i))|0;
            $259 = ($242|0)>(0);
            if ($259) {
             $260 = (0 - ($242))|0;
             $$pre62 = +HEAPF32[$50>>2];
             $266 = $$pre62;$l$015$i$i = $260;
             while(1) {
              $261 = (($l$015$i$i) + ($258))|0;
              $262 = (($xrpow) + ($261<<2)|0);
              $263 = +HEAPF32[$262>>2];
              $264 = $263 * $256;
              HEAPF32[$262>>2] = $264;
              $265 = $264 > $266;
              if ($265) {
               HEAPF32[$50>>2] = $264;
               $559 = $264;
              } else {
               $559 = $266;
              }
              $267 = (($l$015$i$i) + 1)|0;
              $268 = ($l$015$i$i|0)<(-1);
              if ($268) {
               $266 = $559;$l$015$i$i = $267;
              } else {
               break;
              }
             }
            }
            $269 = Math_imul($242, $240)|0;
            $270 = (($258) + ($269))|0;
            $j$1$i$i = $270;
           }
           $271 = (($sfb$320$i$i) + 3)|0;
           $272 = HEAP32[$48>>2]|0;
           $273 = ($271|0)<($272|0);
           if ($273) {
            $j$019$i$i = $j$1$i$i;$sfb$320$i$i = $271;
           } else {
            $558 = $272;$j$0$lcssa$i$i = $j$1$i$i;$sfb$3$lcssa$i$i = $271;
            break;
           }
          }
         } else {
          $558 = $237;$j$0$lcssa$i$i = $235;$sfb$3$lcssa$i$i = $236;
         }
         $274 = +HEAPF32[(80512)>>2];
         $275 = (((($cod_info_w)) + 4872|0) + ($sfb$3$lcssa$i$i<<2)|0);
         $276 = HEAP32[$275>>2]|0;
         $277 = Math_imul($276, $239)|0;
         $278 = (($277) + ($j$0$lcssa$i$i))|0;
         $279 = ($276|0)>(0);
         if (!($279)) {
          $$pre$phi$i$iZ2D = $239;$557 = $558;
          break;
         }
         $280 = (0 - ($276))|0;
         $$pre63 = +HEAPF32[$50>>2];
         $286 = $$pre63;$l$126$i$i = $280;
         while(1) {
          $281 = (($278) + ($l$126$i$i))|0;
          $282 = (($xrpow) + ($281<<2)|0);
          $283 = +HEAPF32[$282>>2];
          $284 = $283 * $274;
          HEAPF32[$282>>2] = $284;
          $285 = $284 > $286;
          if ($285) {
           HEAPF32[$50>>2] = $284;
           $560 = $284;
          } else {
           $560 = $286;
          }
          $287 = (($l$126$i$i) + 1)|0;
          $288 = ($l$126$i$i|0)<(-1);
          if ($288) {
           $286 = $560;$l$126$i$i = $287;
          } else {
           $$pre$phi$i$iZ2D = $239;$557 = $558;
           break;
          }
         }
        }
       } while(0);
       $289 = ($$pre$phi$i$iZ2D|0)<(3);
       if (!($289)) {
        $$lcssa120 = $557;
        break;
       }
       $indvars$iv$next37$i$i = (($indvars$iv36$i$i) + -1)|0;
       $indvars$iv$next$i$i = (($indvars$iv$i$i) + 1)|0;
       $$pre$i13$i = HEAP32[$72>>2]|0;
       $205 = $$pre$i13$i;$indvars$iv$i$i = $indvars$iv$next$i$i;$indvars$iv36$i$i = $indvars$iv$next37$i$i;$window$029$i$i = $$pre$phi$i$iZ2D;
      }
      $290 = ($$lcssa120|0)>(0);
      if ($290) {
       $sfb$01$i5$i = 0;
      } else {
       $best_part2_3_length$3$ph = $best_part2_3_length$1;
       label = 167;
       break L19;
      }
      while(1) {
       $293 = (((($cod_info_w)) + 4608|0) + ($sfb$01$i5$i<<2)|0);
       $294 = HEAP32[$293>>2]|0;
       $295 = (((($cod_info_w)) + 5028|0) + ($sfb$01$i5$i<<2)|0);
       $296 = HEAP32[$295>>2]|0;
       $297 = (((($cod_info_w)) + 4808|0) + ($296<<2)|0);
       $298 = HEAP32[$297>>2]|0;
       $299 = (0 - ($298))|0;
       $300 = ($294|0)==($299|0);
       $291 = (($sfb$01$i5$i) + 1)|0;
       if ($300) {
        break L65;
       }
       $292 = ($291|0)<($$lcssa120|0);
       if ($292) {
        $sfb$01$i5$i = $291;
       } else {
        $best_part2_3_length$3$ph = $best_part2_3_length$1;
        label = 167;
        break L19;
       }
      }
     }
    } while(0);
    $301 = (_scale_bitcount($gfc,$cod_info_w)|0);
    $302 = ($301|0)==(0);
    if (!($302)) {
     $best_part2_3_length$3$ph = $best_part2_3_length$1;
     label = 167;
     break;
    }
   }
   $303 = HEAP32[$47>>2]|0;
   $304 = ($303|0)==(0);
   $$6 = $304 ? 255 : 254;
   $305 = HEAP32[$51>>2]|0;
   $306 = (($targ_bits) - ($305))|0;
   $307 = ($306|0)<(1);
   if ($307) {
    $best_part2_3_length$3$ph = $best_part2_3_length$1;
    label = 167;
    break;
   }
   $308 = (_count_bits($gfc,$xrpow,$cod_info_w,$prev_noise)|0);
   HEAP32[$52>>2] = $308;
   $309 = ($308|0)>($306|0);
   $310 = HEAP32[$53>>2]|0;
   $311 = ($310|0)<=($$6|0);
   $312 = $309 & $311;
   if ($312) {
    $314 = $310;
    while(1) {
     $313 = (($314) + 1)|0;
     HEAP32[$53>>2] = $313;
     $315 = (_count_bits($gfc,$xrpow,$cod_info_w,$prev_noise)|0);
     HEAP32[$52>>2] = $315;
     $316 = ($315|0)>($306|0);
     $317 = HEAP32[$53>>2]|0;
     $318 = ($317|0)<=($$6|0);
     $319 = $316 & $318;
     if ($319) {
      $314 = $317;
     } else {
      $$lcssa26 = $317;
      break;
     }
    }
   } else {
    $$lcssa26 = $310;
   }
   $320 = ($$lcssa26|0)>($$6|0);
   if ($320) {
    $best_part2_3_length$3$ph = $best_part2_3_length$1;
    label = 167;
    break;
   }
   $321 = HEAP32[$54>>2]|0;
   $322 = ($321|0)==(0);
   if ($322) {
    $323 = (_count_bits($gfc,$xrpow,$cod_info_w,$prev_noise)|0);
    HEAP32[$52>>2] = $323;
    $324 = ($323|0)>($best_part2_3_length$1|0);
    $325 = HEAP32[$53>>2]|0;
    $326 = ($325|0)<=($$6|0);
    $327 = $324 & $326;
    if ($327) {
     $329 = $325;
     while(1) {
      $328 = (($329) + 1)|0;
      HEAP32[$53>>2] = $328;
      $330 = (_count_bits($gfc,$xrpow,$cod_info_w,$prev_noise)|0);
      HEAP32[$52>>2] = $330;
      $331 = ($330|0)>($best_part2_3_length$1|0);
      $332 = HEAP32[$53>>2]|0;
      $333 = ($332|0)<=($$6|0);
      $334 = $331 & $333;
      if ($334) {
       $329 = $332;
      } else {
       $$lcssa27 = $332;
       break;
      }
     }
    } else {
     $$lcssa27 = $325;
    }
    $335 = ($$lcssa27|0)>($$6|0);
    if ($335) {
     $best_part2_3_length$3$ph = $best_part2_3_length$1;
     label = 167;
     break;
    }
   }
   (_calc_noise($cod_info_w,$l3_xmin,$distort,$noise_info,$prev_noise)|0);
   $336 = HEAP32[$52>>2]|0;
   HEAP32[$55>>2] = $336;
   $337 = HEAP32[$56>>2]|0;
   $338 = ($337|0)==(2);
   $better$0$in = $338 ? $58 : $57;
   $better$0 = HEAP32[$better$0$in>>2]|0;
   L150: do {
    switch ($better$0|0) {
    case 2:  {
     $407 = +HEAPF32[$65>>2];
     $408 = +HEAPF32[$66>>2];
     $409 = $407 < $408;
     $410 = $409&1;
     $better$0$i = $410;
     break;
    }
    case 3:  {
     $411 = +HEAPF32[$65>>2];
     $412 = +HEAPF32[$66>>2];
     $413 = $411 < $412;
     if ($413) {
      $414 = +HEAPF32[$61>>2];
      $415 = +HEAPF32[$62>>2];
      $416 = $414 < $415;
      $418 = $416;
     } else {
      $418 = 0;
     }
     $417 = $418&1;
     $better$0$i = $417;
     break;
    }
    case 8:  {
     $383 = HEAP32[$67>>2]|0;
     $384 = ($383|0)>(0);
     if ($384) {
      $klemm_noise$02$i$i = 1.0000000000000001E-37;$sfb$01$i$i11 = 0;
      while(1) {
       $385 = (($distort) + ($sfb$01$i$i11<<2)|0);
       $386 = +HEAPF32[$385>>2];
       $387 = $386;
       $388 = $387 * $387;
       $389 = $388 * 0.63200000000000001;
       $390 = $389 * $387;
       $391 = $390 + 0.36799999999999999;
       $392 = $391;
       $393 = (+_fast_log2($392));
       $394 = $393;
       $395 = $394 * 0.30102999566398114;
       $396 = $395 + $klemm_noise$02$i$i;
       $397 = (($sfb$01$i$i11) + 1)|0;
       $398 = HEAP32[$67>>2]|0;
       $399 = ($397|0)<($398|0);
       if ($399) {
        $klemm_noise$02$i$i = $396;$sfb$01$i$i11 = $397;
       } else {
        $klemm_noise$0$lcssa$i$i = $396;
        break;
       }
      }
     } else {
      $klemm_noise$0$lcssa$i$i = 1.0000000000000001E-37;
     }
     $400 = $klemm_noise$0$lcssa$i$i < 9.9999999999999995E-21;
     $401 = $klemm_noise$0$lcssa$i$i;
     $402 = $400 ? 9.9999996826552254E-21 : $401;
     HEAPF32[$61>>2] = $402;
     $405 = $402;
     label = 118;
     break;
    }
    case 1:  {
     $$pre$i10 = +HEAPF32[$61>>2];
     $405 = $$pre$i10;
     label = 118;
     break;
    }
    case 0:  {
     $362 = HEAP32[$64>>2]|0;
     $363 = HEAP32[$54>>2]|0;
     $364 = ($362|0)<($363|0);
     do {
      if ($364) {
       $382 = 1;
      } else {
       $365 = ($362|0)==($363|0);
       if ($365) {
        $366 = +HEAPF32[$noise_info>>2];
        $367 = +HEAPF32[$best_noise_info>>2];
        $368 = $366 < $367;
        if ($368) {
         $382 = 1;
        } else {
         $fabsf9$i = (+Math_abs((+$366)));
         $fabsf10$i = (+Math_abs((+$367)));
         $369 = $fabsf9$i > $fabsf10$i;
         $370 = $366 - $367;
         $fabsf11$i = (+Math_abs((+$370)));
         $371 = $fabsf11$i;
         if ($369) {
          $372 = $fabsf9$i;
          $373 = $372 * 9.9999999747524271E-7;
          $374 = !($371 <= $373);
          if ($374) {
           $382 = 0;
           break;
          }
         } else {
          $375 = $fabsf10$i;
          $376 = $375 * 9.9999999747524271E-7;
          $377 = !($371 <= $376);
          if ($377) {
           $382 = 0;
           break;
          }
         }
         $378 = +HEAPF32[$65>>2];
         $379 = +HEAPF32[$66>>2];
         $380 = $378 < $379;
         $382 = $380;
        }
       } else {
        $382 = 0;
       }
      }
     } while(0);
     $381 = $382&1;
     $better$0$i = $381;
     break;
    }
    case 5:  {
     $463 = +HEAPF32[$noise_info>>2];
     $464 = +HEAPF32[$best_noise_info>>2];
     $465 = $463 < $464;
     do {
      if ($465) {
       $479 = 1;
      } else {
       $fabsf6$i = (+Math_abs((+$463)));
       $fabsf7$i = (+Math_abs((+$464)));
       $466 = $fabsf6$i > $fabsf7$i;
       $467 = $463 - $464;
       $fabsf8$i = (+Math_abs((+$467)));
       $468 = $fabsf8$i;
       if ($466) {
        $469 = $fabsf6$i;
        $470 = $469 * 9.9999999747524271E-7;
        $471 = !($468 <= $470);
        if ($471) {
         $479 = 0;
         break;
        }
       } else {
        $472 = $fabsf7$i;
        $473 = $472 * 9.9999999747524271E-7;
        $474 = !($468 <= $473);
        if ($474) {
         $479 = 0;
         break;
        }
       }
       $475 = +HEAPF32[$65>>2];
       $476 = +HEAPF32[$66>>2];
       $477 = $475 < $476;
       $479 = $477;
      }
     } while(0);
     $478 = $479&1;
     $better$0$i = $478;
     break;
    }
    case 4:  {
     $419 = +HEAPF32[$61>>2];
     $420 = !($419 <= 0.0);
     do {
      if ($420) {
       $421 = $419;
       $442 = $421;
       label = 130;
      } else {
       $422 = +HEAPF32[$62>>2];
       $423 = $422;
       $424 = $423 > 0.20000000000000001;
       if ($424) {
        $462 = 1;
       } else {
        $425 = $419;
        $426 = $422 < 0.0;
        $427 = $425 + -0.20000000000000001;
        $428 = $423 > $427;
        $or$cond16 = $426 & $428;
        if ($or$cond16) {
         $429 = +HEAPF32[$65>>2];
         $430 = +HEAPF32[$66>>2];
         $431 = $429 < $430;
         if ($431) {
          $462 = 1;
          break;
         }
        }
        $$not = !($422 > 0.0);
        $$not84 = $428 ^ 1;
        $brmerge = $$not | $$not84;
        if ($brmerge) {
         $442 = $425;
         label = 130;
        } else {
         $432 = +HEAPF32[$65>>2];
         $433 = +HEAPF32[$66>>2];
         $434 = +HEAPF32[$best_noise_info>>2];
         $435 = $434 + $433;
         $436 = $432 < $435;
         if ($436) {
          $462 = 1;
         } else {
          $442 = $425;
          label = 130;
         }
        }
       }
      }
     } while(0);
     do {
      if ((label|0) == 130) {
       label = 0;
       $437 = $419 > 0.0;
       if ($437) {
        $438 = +HEAPF32[$62>>2];
        $439 = $438;
        $440 = $439 > -0.050000000000000003;
        $441 = $442 + -0.10000000000000001;
        $443 = $439 > $441;
        $or$cond$i13 = $440 & $443;
        if ($or$cond$i13) {
         $444 = +HEAPF32[$65>>2];
         $445 = +HEAPF32[$noise_info>>2];
         $446 = $445 + $444;
         $447 = +HEAPF32[$66>>2];
         $448 = +HEAPF32[$best_noise_info>>2];
         $449 = $448 + $447;
         $450 = $446 < $449;
         if ($450) {
          $462 = 1;
          break;
         }
        }
        $451 = $439 > -0.10000000000000001;
        $452 = $442 + -0.14999999999999999;
        $453 = $439 > $452;
        $or$cond14$i = $451 & $453;
        if ($or$cond14$i) {
         $454 = +HEAPF32[$65>>2];
         $455 = +HEAPF32[$noise_info>>2];
         $factor$i = $455 * 2.0;
         $456 = $factor$i + $454;
         $457 = +HEAPF32[$66>>2];
         $458 = +HEAPF32[$best_noise_info>>2];
         $factor17$i = $458 * 2.0;
         $459 = $factor17$i + $457;
         $460 = $456 < $459;
         $462 = $460;
        } else {
         $462 = 0;
        }
       } else {
        $462 = 0;
       }
      }
     } while(0);
     $461 = $462&1;
     $better$0$i = $461;
     break;
    }
    case 7:  {
     $509 = HEAP32[$64>>2]|0;
     $510 = HEAP32[$54>>2]|0;
     $511 = ($509|0)<($510|0);
     if ($511) {
      $516 = 1;
     } else {
      $512 = +HEAPF32[$noise_info>>2];
      $513 = +HEAPF32[$best_noise_info>>2];
      $514 = $512 < $513;
      $516 = $514;
     }
     $515 = $516&1;
     $better$0$i = $515;
     break;
    }
    case 6:  {
     $480 = +HEAPF32[$noise_info>>2];
     $481 = +HEAPF32[$best_noise_info>>2];
     $482 = $480 < $481;
     do {
      if ($482) {
       $508 = 1;
      } else {
       $fabsf$i = (+Math_abs((+$480)));
       $fabsf1$i = (+Math_abs((+$481)));
       $483 = $fabsf$i > $fabsf1$i;
       $484 = $480 - $481;
       $fabsf2$i = (+Math_abs((+$484)));
       $485 = $fabsf2$i;
       if ($483) {
        $486 = $fabsf$i;
        $487 = $486 * 9.9999999747524271E-7;
        $488 = !($485 <= $487);
        if ($488) {
         $508 = 0;
         break;
        }
       } else {
        $489 = $fabsf1$i;
        $490 = $489 * 9.9999999747524271E-7;
        $491 = !($485 <= $490);
        if ($491) {
         $508 = 0;
         break;
        }
       }
       $492 = +HEAPF32[$61>>2];
       $493 = +HEAPF32[$62>>2];
       $494 = $492 < $493;
       if ($494) {
        $508 = 1;
       } else {
        $fabsf3$i = (+Math_abs((+$492)));
        $fabsf4$i = (+Math_abs((+$493)));
        $495 = $fabsf3$i > $fabsf4$i;
        $496 = $492 - $493;
        $fabsf5$i = (+Math_abs((+$496)));
        $497 = $fabsf5$i;
        if ($495) {
         $498 = $fabsf3$i;
         $499 = $498 * 9.9999999747524271E-7;
         $500 = !($497 <= $499);
         if ($500) {
          $508 = 0;
          break;
         }
        } else {
         $501 = $fabsf4$i;
         $502 = $501 * 9.9999999747524271E-7;
         $503 = !($497 <= $502);
         if ($503) {
          $508 = 0;
          break;
         }
        }
        $504 = +HEAPF32[$65>>2];
        $505 = +HEAPF32[$66>>2];
        $506 = $504 <= $505;
        $508 = $506;
       }
      }
     } while(0);
     $507 = $508&1;
     $better$0$i = $507;
     break;
    }
    default: {
     $339 = HEAP32[$54>>2]|0;
     $340 = ($339|0)>(0);
     if ($340) {
      $341 = HEAP32[$59>>2]|0;
      $342 = HEAP32[$60>>2]|0;
      $343 = ($341|0)<=($342|0);
      $344 = $343&1;
      $345 = ($341|0)==($342|0);
      if (!($345)) {
       $better$0$i = $344;
       break L150;
      }
      $346 = HEAP32[$44>>2]|0;
      $347 = ($336|0)<($346|0);
      $348 = $347&1;
      $better$0$i = $348;
      break L150;
     }
     $349 = +HEAPF32[$61>>2];
     $350 = $349 < 0.0;
     if ($350) {
      $351 = $349 * 10.0;
      $352 = (+($336|0));
      $353 = $351 + $352;
      $354 = +HEAPF32[$62>>2];
      $355 = $354 * 10.0;
      $356 = HEAP32[$44>>2]|0;
      $357 = (+($356|0));
      $358 = $357 + $355;
      $359 = $353 <= $358;
      $361 = $359;
     } else {
      $361 = 0;
     }
     $360 = $361&1;
     $better$0$i = $360;
    }
    }
   } while(0);
   if ((label|0) == 118) {
    label = 0;
    $403 = +HEAPF32[$62>>2];
    $404 = $405 < $403;
    $406 = $404&1;
    $better$0$i = $406;
   }
   $517 = HEAP32[$54>>2]|0;
   $518 = ($517|0)==(0);
   if ($518) {
    $519 = ($better$0$i|0)==(0);
    if ($519) {
     $524 = 0;
    } else {
     $520 = HEAP32[$55>>2]|0;
     $521 = HEAP32[$44>>2]|0;
     $522 = ($520|0)<($521|0);
     $524 = $522;
    }
    $523 = $524&1;
    $better$1$i = $523;
   } else {
    $better$1$i = $better$0$i;
   }
   $525 = ($better$1$i|0)==(0);
   do {
    if ($525) {
     $527 = HEAP32[$63>>2]|0;
     $528 = ($527|0)==(0);
     if ($528) {
      $529 = (($age$1) + 1)|0;
      $530 = ($age$1|0)>=($$|0);
      $or$cond8 = $530 & $518;
      if ($or$cond8) {
       $best_part2_3_length$3$ph = $best_part2_3_length$1;
       label = 167;
       break L19;
      }
      $531 = HEAP32[$49>>2]|0;
      $532 = ($531|0)==(3);
      $or$cond = $75 & $532;
      $533 = ($age$1|0)>(29);
      $or$cond3 = $533 & $or$cond;
      if ($or$cond3) {
       $best_part2_3_length$3$ph = $best_part2_3_length$1;
       label = 167;
       break L19;
      }
      if (!($or$cond)) {
       $age$2 = $529;$best_part2_3_length$2 = $best_part2_3_length$1;
       break;
      }
      $534 = HEAP32[$53>>2]|0;
      $535 = (($534) - ($best_ggain_pass1$042))|0;
      $536 = ($535|0)>(15);
      if ($536) {
       $best_part2_3_length$3$ph = $best_part2_3_length$1;
       label = 167;
       break L19;
      } else {
       $age$2 = $529;$best_part2_3_length$2 = $best_part2_3_length$1;
      }
     } else {
      $age$2 = $age$1;$best_part2_3_length$2 = $best_part2_3_length$1;
     }
    } else {
     $526 = HEAP32[$39>>2]|0;
     ;HEAP32[$best_noise_info>>2]=HEAP32[$noise_info>>2]|0;HEAP32[$best_noise_info+4>>2]=HEAP32[$noise_info+4>>2]|0;HEAP32[$best_noise_info+8>>2]=HEAP32[$noise_info+8>>2]|0;HEAP32[$best_noise_info+12>>2]=HEAP32[$noise_info+12>>2]|0;HEAP32[$best_noise_info+16>>2]=HEAP32[$noise_info+16>>2]|0;HEAP32[$best_noise_info+20>>2]=HEAP32[$noise_info+20>>2]|0;
     _memcpy(($cod_info|0),($cod_info_w|0),5252)|0;
     _memcpy(($save_xrpow|0),($xrpow|0),2304)|0;
     $age$2 = 0;$best_part2_3_length$2 = $526;
    }
   } while(0);
   $537 = HEAP32[$53>>2]|0;
   $538 = HEAP32[$47>>2]|0;
   $539 = (($538) + ($537))|0;
   $540 = ($539|0)<(255);
   if ($540) {
    $age$1 = $age$2;$best_part2_3_length$1 = $best_part2_3_length$2;
   } else {
    $best_part2_3_length$3$ph = $best_part2_3_length$2;
    label = 167;
    break;
   }
  }
  if ((label|0) == 167) {
   label = 0;
   $$pre65 = HEAP32[$49>>2]|0;
   $541 = $$pre65;$best_part2_3_length$3 = $best_part2_3_length$3$ph;
  }
  $542 = ($541|0)==(3);
  $543 = ($bRefine$041|0)==(0);
  $or$cond9 = $543 & $542;
  if (!($or$cond9)) {
   break;
  }
  _memcpy(($cod_info_w|0),($cod_info|0),5252)|0;
  _memcpy(($xrpow|0),($save_xrpow|0),2304)|0;
  $544 = HEAP32[$53>>2]|0;
  $bRefine$041 = 1;$best_ggain_pass1$042 = $544;$best_part2_3_length$040 = $best_part2_3_length$3;
 }
 $545 = ((($gfc)) + 104|0);
 $546 = HEAP32[$545>>2]|0;
 if ((($546|0) == 1) | (($546|0) == 4) | (($546|0) == 2)) {
  _memcpy(($xrpow|0),($save_xrpow|0),2304)|0;
 } else {
  $547 = HEAP32[$45>>2]|0;
  $548 = $547 & 1;
  $549 = ($548|0)==(0);
  if (!($549)) {
   _trancate_smallspectrums($gfc,$cod_info,$l3_xmin,$xrpow);
  }
 }
 $550 = HEAP32[$54>>2]|0;
 $$0 = $550;
 STACKTOP = sp;return ($$0|0);
}
function _trancate_smallspectrums($gfc,$gi,$l3_xmin,$work) {
 $gfc = $gfc|0;
 $gi = $gi|0;
 $l3_xmin = $l3_xmin|0;
 $work = $work|0;
 var $$ = 0, $$lcssa = 0, $$lcssa12 = 0, $$old = 0, $$old46 = 0, $$pre = 0, $$pre$phi$lcssaZ2D = 0, $$pre$phiZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0.0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
 var $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0.0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0, $32 = 0.0, $33 = 0, $34 = 0, $35 = 0.0, $36 = 0.0, $37 = 0.0;
 var $38 = 0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0.0, $49 = 0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0, $53 = 0, $54 = 0.0, $55 = 0;
 var $56 = 0.0, $57 = 0.0, $58 = 0, $59 = 0.0, $6 = 0, $60 = 0.0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0, $71 = 0, $72 = 0.0, $73 = 0;
 var $74 = 0, $75 = 0.0, $76 = 0.0, $77 = 0, $78 = 0.0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0.0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0;
 var $92 = 0, $93 = 0, $allowedNoise$0 = 0.0, $distort = 0, $dummy = 0, $exitcond = 0, $fabsf = 0.0, $fabsf1 = 0.0, $fabsf2 = 0.0, $fabsf3 = 0.0, $fabsf4 = 0.0, $fabsf5 = 0.0, $fabsf6 = 0.0, $j$027 = 0, $j$1 = 0, $nsame$0$lcssa = 0, $nsame$016 = 0, $or$cond = 0, $sfb$0 = 0, $start$0 = 0;
 var $start$0$lcssa = 0, $width$0 = 0, $xr$0 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 192|0;
 $distort = sp + 24|0;
 $dummy = sp;
 $0 = ((($gfc)) + 85096|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = $1 & 4;
 $3 = ($2|0)==(0);
 if ($3) {
  $4 = ((($gi)) + 4788|0);
  $5 = HEAP32[$4>>2]|0;
  $6 = ($5|0)!=(2);
  $7 = $1 & 128;
  $8 = ($7|0)==(0);
  $or$cond = $6 & $8;
  if (!($or$cond)) {
   STACKTOP = sp;return;
  }
 } else {
  $$old = $1 & 128;
  $$old46 = ($$old|0)==(0);
  if (!($$old46)) {
   STACKTOP = sp;return;
  }
 }
 (_calc_noise($gi,$l3_xmin,$distort,$dummy,0)|0);
 $j$027 = 0;
 while(1) {
  $9 = (((($gi)) + 2304|0) + ($j$027<<2)|0);
  $10 = HEAP32[$9>>2]|0;
  $11 = ($10|0)==(0);
  if ($11) {
   $xr$0 = 0.0;
  } else {
   $12 = (($gi) + ($j$027<<2)|0);
   $13 = +HEAPF32[$12>>2];
   $fabsf6 = (+Math_abs((+$13)));
   $xr$0 = $fabsf6;
  }
  $14 = (($work) + ($j$027<<2)|0);
  HEAPF32[$14>>2] = $xr$0;
  $15 = (($j$027) + 1)|0;
  $exitcond = ($15|0)==(576);
  if ($exitcond) {
   break;
  } else {
   $j$027 = $15;
  }
 }
 $16 = ((($gi)) + 4788|0);
 $17 = HEAP32[$16>>2]|0;
 $18 = ($17|0)==(2);
 $$ = $18 ? 6 : 8;
 $19 = ((($gi)) + 4864|0);
 $j$1 = 0;$sfb$0 = $$;
 while(1) {
  $20 = (((($gi)) + 4872|0) + ($sfb$0<<2)|0);
  $21 = HEAP32[$20>>2]|0;
  $22 = (($21) + ($j$1))|0;
  $23 = (($distort) + ($sfb$0<<2)|0);
  $24 = +HEAPF32[$23>>2];
  $25 = !($24 >= 1.0);
  L15: do {
   if ($25) {
    $26 = (($work) + ($j$1<<2)|0);
    _qsort($26,$21,4,1);
    $27 = (($22) + -1)|0;
    $28 = (($work) + ($27<<2)|0);
    $29 = +HEAPF32[$28>>2];
    $fabsf = (+Math_abs((+$29)));
    $30 = $fabsf;
    $31 = ($29 != $29) | (0.0 != 0.0) |($29 == 0.0);
    if ($31) {
     $34 = $29 == 0.0;
     if ($34) {
      break;
     }
    } else {
     $32 = $30 * 9.9999999747524271E-7;
     $33 = !($30 <= $32);
     if (!($33)) {
      break;
     }
    }
    $35 = +HEAPF32[$23>>2];
    $36 = $35;
    $37 = 1.0 - $36;
    $38 = (($l3_xmin) + ($sfb$0<<2)|0);
    $39 = +HEAPF32[$38>>2];
    $40 = $39;
    $41 = $37 * $40;
    $42 = $41;
    $allowedNoise$0 = $42;$start$0 = 0;
    while(1) {
     $43 = (($start$0) + 1)|0;
     $44 = ($43|0)<($21|0);
     L23: do {
      if ($44) {
       $45 = (($start$0) + ($22))|0;
       $46 = (($45) - ($21))|0;
       $47 = (($work) + ($46<<2)|0);
       $48 = +HEAPF32[$47>>2];
       $fabsf3 = (+Math_abs((+$48)));
       $49 = (($start$0) + ($j$1))|0;
       $50 = $fabsf3;
       $51 = $50 * 9.9999999747524271E-7;
       $93 = $43;$nsame$016 = 1;
       while(1) {
        $52 = (($49) + ($nsame$016))|0;
        $53 = (($work) + ($52<<2)|0);
        $54 = +HEAPF32[$53>>2];
        $fabsf4 = (+Math_abs((+$54)));
        $55 = $fabsf3 > $fabsf4;
        $56 = $48 - $54;
        $fabsf5 = (+Math_abs((+$56)));
        $57 = $fabsf5;
        if ($55) {
         $58 = !($57 <= $51);
         if ($58) {
          $$lcssa = $93;$$lcssa12 = 1;$$pre$phiZ2D = $49;$nsame$0$lcssa = $nsame$016;
          break L23;
         }
        } else {
         $59 = $fabsf4;
         $60 = $59 * 9.9999999747524271E-7;
         $61 = !($57 <= $60);
         if ($61) {
          $$lcssa = $93;$$lcssa12 = 1;$$pre$phiZ2D = $49;$nsame$0$lcssa = $nsame$016;
          break L23;
         }
        }
        $62 = (($nsame$016) + 1)|0;
        $63 = (($62) + ($start$0))|0;
        $64 = ($63|0)<($21|0);
        if ($64) {
         $93 = $63;$nsame$016 = $62;
        } else {
         $$lcssa = $63;$$lcssa12 = 0;$$pre$phiZ2D = $49;$nsame$0$lcssa = $62;
         break;
        }
       }
      } else {
       $$pre = (($j$1) + ($start$0))|0;
       $$lcssa = $43;$$lcssa12 = 0;$$pre$phiZ2D = $$pre;$nsame$0$lcssa = 1;
      }
     } while(0);
     $65 = (($work) + ($$pre$phiZ2D<<2)|0);
     $66 = +HEAPF32[$65>>2];
     $67 = (+($nsame$0$lcssa|0));
     $68 = $66 * $66;
     $69 = $68 * $67;
     $70 = $allowedNoise$0 < $69;
     if ($70) {
      $$pre$phi$lcssaZ2D = $$pre$phiZ2D;$start$0$lcssa = $start$0;
      break;
     }
     $72 = $allowedNoise$0 - $69;
     if ($$lcssa12) {
      $allowedNoise$0 = $72;$start$0 = $$lcssa;
     } else {
      break L15;
     }
    }
    $71 = ($start$0$lcssa|0)==(0);
    if (!($71)) {
     $73 = (($$pre$phi$lcssaZ2D) + -1)|0;
     $74 = (($work) + ($73<<2)|0);
     $75 = +HEAPF32[$74>>2];
     $fabsf1 = (+Math_abs((+$75)));
     $76 = $fabsf1;
     $77 = ($75 != $75) | (0.0 != 0.0) |($75 == 0.0);
     if ($77) {
      $80 = $75 == 0.0;
      if ($80) {
       break;
      } else {
       $width$0 = $21;
      }
     } else {
      $78 = $76 * 9.9999999747524271E-7;
      $79 = !($76 <= $78);
      if ($79) {
       $width$0 = $21;
      } else {
       break;
      }
     }
     while(1) {
      $81 = (($22) - ($width$0))|0;
      $82 = (($gi) + ($81<<2)|0);
      $83 = +HEAPF32[$82>>2];
      $fabsf2 = (+Math_abs((+$83)));
      $84 = !($fabsf2 <= $75);
      if (!($84)) {
       $85 = (((($gi)) + 2304|0) + ($81<<2)|0);
       HEAP32[$85>>2] = 0;
      }
      $86 = (($width$0) + -1)|0;
      $87 = ($width$0|0)>(1);
      if ($87) {
       $width$0 = $86;
      } else {
       break;
      }
     }
    }
   }
  } while(0);
  $88 = (($sfb$0) + 1)|0;
  $89 = HEAP32[$19>>2]|0;
  $90 = ($88|0)<($89|0);
  if ($90) {
   $j$1 = $22;$sfb$0 = $88;
  } else {
   break;
  }
 }
 $91 = (_noquant_count_bits($gfc,$gi,0)|0);
 $92 = ((($gi)) + 4768|0);
 HEAP32[$92>>2] = $91;
 STACKTOP = sp;return;
}
function _floatcompare($v1,$v2) {
 $v1 = $v1|0;
 $v2 = $v2|0;
 var $$ = 0, $$0 = 0, $0 = 0.0, $1 = 0.0, $2 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = +HEAPF32[$v1>>2];
 $1 = +HEAPF32[$v2>>2];
 $2 = $0 > $1;
 $3 = $0 < $1;
 $$ = $3 << 31 >> 31;
 $$0 = $2 ? 1 : $$;
 return ($$0|0);
}
function _iteration_init($gfc) {
 $gfc = $gfc|0;
 var $$$i = 0.0, $$1$i = 0.0, $$2$i = 0.0, $$2$i$lcssa = 0.0, $$3$i = 0.0, $$phi$trans$insert$i = 0, $$pre = 0.0, $$pre$i = 0, $$pre50$i = 0, $0 = 0, $1 = 0, $10 = 0.0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0.0, $106 = 0.0, $107 = 0.0;
 var $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0;
 var $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0;
 var $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0.0, $159 = 0.0, $16 = 0, $160 = 0, $161 = 0.0;
 var $162 = 0.0, $163 = 0.0, $164 = 0.0, $165 = 0.0, $166 = 0.0, $167 = 0.0, $168 = 0.0, $169 = 0.0, $17 = 0, $170 = 0, $171 = 0, $172 = 0.0, $173 = 0.0, $174 = 0.0, $175 = 0.0, $176 = 0, $177 = 0, $178 = 0.0, $179 = 0.0, $18 = 0;
 var $180 = 0, $181 = 0.0, $182 = 0.0, $183 = 0.0, $184 = 0.0, $185 = 0.0, $186 = 0.0, $187 = 0.0, $188 = 0.0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0.0, $193 = 0.0, $194 = 0.0, $195 = 0, $196 = 0, $197 = 0, $198 = 0.0;
 var $199 = 0.0, $2 = 0, $20 = 0.0, $200 = 0.0, $201 = 0, $202 = 0, $203 = 0, $204 = 0.0, $205 = 0.0, $206 = 0.0, $207 = 0.0, $208 = 0, $209 = 0, $21 = 0.0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0;
 var $216 = 0.0, $217 = 0.0, $218 = 0.0, $219 = 0.0, $22 = 0.0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0.0, $229 = 0.0, $23 = 0.0, $230 = 0.0, $231 = 0.0, $232 = 0, $233 = 0;
 var $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0.0, $241 = 0.0, $242 = 0.0, $243 = 0.0, $244 = 0, $245 = 0.0, $246 = 0.0, $247 = 0.0, $248 = 0.0, $249 = 0, $25 = 0.0, $250 = 0, $251 = 0;
 var $252 = 0.0, $253 = 0.0, $254 = 0.0, $255 = 0.0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0.0, $260 = 0.0, $261 = 0.0, $262 = 0.0, $263 = 0.0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0.0, $27 = 0.0;
 var $270 = 0.0, $271 = 0.0, $272 = 0.0, $273 = 0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0, $32 = 0, $33 = 0, $34 = 0.0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0.0;
 var $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0;
 var $60 = 0, $61 = 0, $62 = 0, $63 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0.0, $71 = 0.0, $72 = 0.0, $73 = 0.0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0;
 var $79 = 0.0, $8 = 0, $80 = 0.0, $81 = 0.0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0.0, $9 = 0.0, $90 = 0.0, $91 = 0.0, $92 = 0.0, $93 = 0, $94 = 0.0, $95 = 0.0, $96 = 0.0;
 var $97 = 0.0, $98 = 0.0, $99 = 0.0, $ath$0$i$i = 0.0, $ath$0$i11$i = 0.0, $ath$0$i5$i = 0.0, $ath$0$i7$i = 0.0, $ath$0$i9$i = 0.0, $ath$0$p$i$i = 0.0, $ath$0$p$i10$i = 0.0, $ath$0$p$i4$i = 0.0, $ath$0$p$i6$i = 0.0, $ath$0$p$i8$i = 0.0, $exitcond$i = 0, $exitcond43 = 0, $exitcond43$i = 0, $exitcond44 = 0, $exitcond44$i = 0, $exitcond45 = 0, $exitcond45$i = 0;
 var $exitcond46 = 0, $exitcond46$i = 0, $exitcond47$i = 0, $exitcond48$i = 0, $exitcond49$i = 0, $exp2 = 0.0, $exp21 = 0.0, $i$030 = 0, $i$035$i = 0, $i$129 = 0, $i$131$i = 0, $i$226$i = 0, $i$228 = 0, $i$324$i = 0, $i$327 = 0, $sfb$038$i = 0, $sfb$134$i = 0, $sfb$230$i = 0, $sfb$325$i = 0, label = 0;
 var sp = 0;
 sp = STACKTOP;
 $0 = ((($gfc)) + 8|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($1|0)==(0);
 if (!($2)) {
  return;
 }
 HEAP32[$0>>2] = 1;
 $3 = ((($gfc)) + 21312|0);
 HEAP32[$3>>2] = 0;
 $4 = ((($gfc)) + 16|0);
 $5 = ((($gfc)) + 85796|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = ((($gfc)) + 64|0);
 $8 = HEAP32[$7>>2]|0;
 $9 = (+($8|0));
 $10 = $9 * 8.6805556202307343E-4;
 $11 = ((($gfc)) + 224|0);
 $12 = ((($gfc)) + 196|0);
 $sfb$038$i = 0;
 while(1) {
  $14 = (((($gfc)) + 21360|0) + ($sfb$038$i<<2)|0);
  $15 = HEAP32[$14>>2]|0;
  $13 = (($sfb$038$i) + 1)|0;
  $16 = (((($gfc)) + 21360|0) + ($13<<2)|0);
  $17 = HEAP32[$16>>2]|0;
  $18 = (((($6)) + 24|0) + ($sfb$038$i<<2)|0);
  HEAPF32[$18>>2] = 9.9999999338158125E+36;
  $19 = ($15|0)<($17|0);
  if ($19) {
   $i$035$i = $15;
   while(1) {
    $20 = (+($i$035$i|0));
    $21 = $20 * $10;
    $22 = (+_ATHformula($4,$21));
    $23 = +HEAPF32[$11>>2];
    $24 = $23 > 0.0;
    $25 = -$23;
    $ath$0$p$i$i = $24 ? $25 : -100.0;
    $26 = +HEAPF32[$12>>2];
    $ath$0$i$i = $26 + $22;
    $27 = $ath$0$i$i + $ath$0$p$i$i;
    $28 = $27 * 0.10000000149011612;
    $29 = (+Math_pow(10.0,(+$28)));
    $30 = +HEAPF32[$18>>2];
    $31 = $30 < $29;
    $$$i = $31 ? $30 : $29;
    HEAPF32[$18>>2] = $$$i;
    $32 = (($i$035$i) + 1)|0;
    $exitcond48$i = ($32|0)==($17|0);
    if ($exitcond48$i) {
     break;
    } else {
     $i$035$i = $32;
    }
   }
  }
  $exitcond49$i = ($13|0)==(22);
  if ($exitcond49$i) {
   $sfb$134$i = 0;
   break;
  } else {
   $sfb$038$i = $13;
  }
 }
 while(1) {
  $35 = (((($gfc)) + 21508|0) + ($sfb$134$i<<2)|0);
  $36 = HEAP32[$35>>2]|0;
  $33 = (($sfb$134$i) + 1)|0;
  $37 = (((($gfc)) + 21508|0) + ($33<<2)|0);
  $38 = HEAP32[$37>>2]|0;
  $39 = (((($6)) + 164|0) + ($sfb$134$i<<2)|0);
  HEAPF32[$39>>2] = 9.9999999338158125E+36;
  $40 = ($36|0)<($38|0);
  if ($40) {
   $i$131$i = $36;
   while(1) {
    $41 = (+($i$131$i|0));
    $42 = $41 * $10;
    $43 = (+_ATHformula($4,$42));
    $44 = +HEAPF32[$11>>2];
    $45 = $44 > 0.0;
    $46 = -$44;
    $ath$0$p$i4$i = $45 ? $46 : -100.0;
    $47 = +HEAPF32[$12>>2];
    $ath$0$i5$i = $47 + $43;
    $48 = $ath$0$i5$i + $ath$0$p$i4$i;
    $49 = $48 * 0.10000000149011612;
    $50 = (+Math_pow(10.0,(+$49)));
    $51 = +HEAPF32[$39>>2];
    $52 = $51 < $50;
    $$1$i = $52 ? $51 : $50;
    HEAPF32[$39>>2] = $$1$i;
    $53 = (($i$131$i) + 1)|0;
    $exitcond46$i = ($53|0)==($38|0);
    if ($exitcond46$i) {
     break;
    } else {
     $i$131$i = $53;
    }
   }
  }
  $exitcond47$i = ($33|0)==(6);
  if ($exitcond47$i) {
   break;
  } else {
   $sfb$134$i = $33;
  }
 }
 $34 = $9 * 0.0026041667442768812;
 $$phi$trans$insert$i = ((($gfc)) + 21452|0);
 $$pre$i = HEAP32[$$phi$trans$insert$i>>2]|0;
 $61 = $$pre$i;$sfb$230$i = 0;
 while(1) {
  $56 = (((($gfc)) + 21452|0) + ($sfb$230$i<<2)|0);
  $57 = (($sfb$230$i) + 1)|0;
  $58 = (((($gfc)) + 21452|0) + ($57<<2)|0);
  $59 = HEAP32[$58>>2]|0;
  $60 = (((($6)) + 112|0) + ($sfb$230$i<<2)|0);
  HEAPF32[$60>>2] = 9.9999999338158125E+36;
  $62 = ($61|0)<($59|0);
  if ($62) {
   $i$226$i = $61;
   while(1) {
    $63 = (+($i$226$i|0));
    $64 = $63 * $34;
    $65 = (+_ATHformula($4,$64));
    $66 = +HEAPF32[$11>>2];
    $67 = $66 > 0.0;
    $68 = -$66;
    $ath$0$p$i6$i = $67 ? $68 : -100.0;
    $69 = +HEAPF32[$12>>2];
    $ath$0$i7$i = $69 + $65;
    $70 = $ath$0$i7$i + $ath$0$p$i6$i;
    $71 = $70 * 0.10000000149011612;
    $72 = (+Math_pow(10.0,(+$71)));
    $73 = +HEAPF32[$60>>2];
    $74 = $73 < $72;
    $$2$i = $74 ? $73 : $72;
    HEAPF32[$60>>2] = $$2$i;
    $75 = (($i$226$i) + 1)|0;
    $exitcond44$i = ($75|0)==($59|0);
    if ($exitcond44$i) {
     $$2$i$lcssa = $$2$i;
     break;
    } else {
     $i$226$i = $75;
    }
   }
   $$pre50$i = HEAP32[$58>>2]|0;
   $78 = $$pre50$i;$81 = $$2$i$lcssa;
  } else {
   $78 = $59;$81 = 9.9999999338158125E+36;
  }
  $76 = HEAP32[$56>>2]|0;
  $77 = (($78) - ($76))|0;
  $79 = (+($77|0));
  $80 = $79 * $81;
  HEAPF32[$60>>2] = $80;
  $exitcond45$i = ($57|0)==(13);
  if ($exitcond45$i) {
   break;
  } else {
   $61 = $78;$sfb$230$i = $57;
  }
 }
 $54 = ((($gfc)) + 21504|0);
 $55 = ((($gfc)) + 21500|0);
 $sfb$325$i = 0;
 while(1) {
  $82 = (((($gfc)) + 21536|0) + ($sfb$325$i<<2)|0);
  $83 = HEAP32[$82>>2]|0;
  $84 = (($sfb$325$i) + 1)|0;
  $85 = (((($gfc)) + 21536|0) + ($84<<2)|0);
  $86 = HEAP32[$85>>2]|0;
  $87 = (((($6)) + 188|0) + ($sfb$325$i<<2)|0);
  HEAPF32[$87>>2] = 9.9999999338158125E+36;
  $88 = ($83|0)<($86|0);
  if ($88) {
   $i$324$i = $83;
   while(1) {
    $89 = (+($i$324$i|0));
    $90 = $89 * $34;
    $91 = (+_ATHformula($4,$90));
    $92 = +HEAPF32[$11>>2];
    $93 = $92 > 0.0;
    $94 = -$92;
    $ath$0$p$i8$i = $93 ? $94 : -100.0;
    $95 = +HEAPF32[$12>>2];
    $ath$0$i9$i = $95 + $91;
    $96 = $ath$0$i9$i + $ath$0$p$i8$i;
    $97 = $96 * 0.10000000149011612;
    $98 = (+Math_pow(10.0,(+$97)));
    $99 = +HEAPF32[$87>>2];
    $100 = $99 < $98;
    $$3$i = $100 ? $99 : $98;
    HEAPF32[$87>>2] = $$3$i;
    $101 = (($i$324$i) + 1)|0;
    $exitcond$i = ($101|0)==($86|0);
    if ($exitcond$i) {
     $107 = $$3$i;
     break;
    } else {
     $i$324$i = $101;
    }
   }
  } else {
   $107 = 9.9999999338158125E+36;
  }
  $102 = HEAP32[$54>>2]|0;
  $103 = HEAP32[$55>>2]|0;
  $104 = (($102) - ($103))|0;
  $105 = (+($104|0));
  $106 = $105 * $107;
  HEAPF32[$87>>2] = $106;
  $exitcond43$i = ($84|0)==(6);
  if ($exitcond43$i) {
   break;
  } else {
   $sfb$325$i = $84;
  }
 }
 $108 = ((($gfc)) + 220|0);
 $109 = HEAP32[$108>>2]|0;
 $110 = ($109|0)==(0);
 if (!($110)) {
  $111 = ((($6)) + 24|0);
  HEAPF32[$111>>2] = 9.9999996826552254E-21;
  $112 = ((($6)) + 28|0);
  HEAPF32[$112>>2] = 9.9999996826552254E-21;
  $113 = ((($6)) + 32|0);
  HEAPF32[$113>>2] = 9.9999996826552254E-21;
  $114 = ((($6)) + 36|0);
  HEAPF32[$114>>2] = 9.9999996826552254E-21;
  $115 = ((($6)) + 40|0);
  HEAPF32[$115>>2] = 9.9999996826552254E-21;
  $116 = ((($6)) + 44|0);
  HEAPF32[$116>>2] = 9.9999996826552254E-21;
  $117 = ((($6)) + 48|0);
  HEAPF32[$117>>2] = 9.9999996826552254E-21;
  $118 = ((($6)) + 52|0);
  HEAPF32[$118>>2] = 9.9999996826552254E-21;
  $119 = ((($6)) + 56|0);
  HEAPF32[$119>>2] = 9.9999996826552254E-21;
  $120 = ((($6)) + 60|0);
  HEAPF32[$120>>2] = 9.9999996826552254E-21;
  $121 = ((($6)) + 64|0);
  HEAPF32[$121>>2] = 9.9999996826552254E-21;
  $122 = ((($6)) + 68|0);
  HEAPF32[$122>>2] = 9.9999996826552254E-21;
  $123 = ((($6)) + 72|0);
  HEAPF32[$123>>2] = 9.9999996826552254E-21;
  $124 = ((($6)) + 76|0);
  HEAPF32[$124>>2] = 9.9999996826552254E-21;
  $125 = ((($6)) + 80|0);
  HEAPF32[$125>>2] = 9.9999996826552254E-21;
  $126 = ((($6)) + 84|0);
  HEAPF32[$126>>2] = 9.9999996826552254E-21;
  $127 = ((($6)) + 88|0);
  HEAPF32[$127>>2] = 9.9999996826552254E-21;
  $128 = ((($6)) + 92|0);
  HEAPF32[$128>>2] = 9.9999996826552254E-21;
  $129 = ((($6)) + 96|0);
  HEAPF32[$129>>2] = 9.9999996826552254E-21;
  $130 = ((($6)) + 100|0);
  HEAPF32[$130>>2] = 9.9999996826552254E-21;
  $131 = ((($6)) + 104|0);
  HEAPF32[$131>>2] = 9.9999996826552254E-21;
  $132 = ((($6)) + 108|0);
  HEAPF32[$132>>2] = 9.9999996826552254E-21;
  $133 = ((($6)) + 164|0);
  HEAPF32[$133>>2] = 9.9999996826552254E-21;
  $134 = ((($6)) + 168|0);
  HEAPF32[$134>>2] = 9.9999996826552254E-21;
  $135 = ((($6)) + 172|0);
  HEAPF32[$135>>2] = 9.9999996826552254E-21;
  $136 = ((($6)) + 176|0);
  HEAPF32[$136>>2] = 9.9999996826552254E-21;
  $137 = ((($6)) + 180|0);
  HEAPF32[$137>>2] = 9.9999996826552254E-21;
  $138 = ((($6)) + 184|0);
  HEAPF32[$138>>2] = 9.9999996826552254E-21;
  $139 = ((($6)) + 112|0);
  HEAPF32[$139>>2] = 9.9999996826552254E-21;
  $140 = ((($6)) + 116|0);
  HEAPF32[$140>>2] = 9.9999996826552254E-21;
  $141 = ((($6)) + 120|0);
  HEAPF32[$141>>2] = 9.9999996826552254E-21;
  $142 = ((($6)) + 124|0);
  HEAPF32[$142>>2] = 9.9999996826552254E-21;
  $143 = ((($6)) + 128|0);
  HEAPF32[$143>>2] = 9.9999996826552254E-21;
  $144 = ((($6)) + 132|0);
  HEAPF32[$144>>2] = 9.9999996826552254E-21;
  $145 = ((($6)) + 136|0);
  HEAPF32[$145>>2] = 9.9999996826552254E-21;
  $146 = ((($6)) + 140|0);
  HEAPF32[$146>>2] = 9.9999996826552254E-21;
  $147 = ((($6)) + 144|0);
  HEAPF32[$147>>2] = 9.9999996826552254E-21;
  $148 = ((($6)) + 148|0);
  HEAPF32[$148>>2] = 9.9999996826552254E-21;
  $149 = ((($6)) + 152|0);
  HEAPF32[$149>>2] = 9.9999996826552254E-21;
  $150 = ((($6)) + 156|0);
  HEAPF32[$150>>2] = 9.9999996826552254E-21;
  $151 = ((($6)) + 160|0);
  HEAPF32[$151>>2] = 9.9999996826552254E-21;
  $152 = ((($6)) + 188|0);
  HEAPF32[$152>>2] = 9.9999996826552254E-21;
  $153 = ((($6)) + 192|0);
  HEAPF32[$153>>2] = 9.9999996826552254E-21;
  $154 = ((($6)) + 196|0);
  HEAPF32[$154>>2] = 9.9999996826552254E-21;
  $155 = ((($6)) + 200|0);
  HEAPF32[$155>>2] = 9.9999996826552254E-21;
  $156 = ((($6)) + 204|0);
  HEAPF32[$156>>2] = 9.9999996826552254E-21;
  $157 = ((($6)) + 208|0);
  HEAPF32[$157>>2] = 9.9999996826552254E-21;
 }
 $158 = (+_ATHformula($4,-1.0));
 $159 = +HEAPF32[$11>>2];
 $160 = $159 > 0.0;
 $161 = -$159;
 $ath$0$p$i10$i = $160 ? $161 : -100.0;
 $162 = +HEAPF32[$12>>2];
 $ath$0$i11$i = $162 + $158;
 $163 = $ath$0$i11$i + $ath$0$p$i10$i;
 $164 = $163 * 0.10000000149011612;
 $165 = (+Math_pow(10.0,(+$164)));
 $166 = $165;
 $167 = (+_log10($166));
 $168 = $167 * 10.0;
 $169 = $168;
 $170 = HEAP32[$5>>2]|0;
 $171 = ((($170)) + 20|0);
 HEAPF32[$171>>2] = $169;
 HEAPF32[14040>>2] = 0.0;
 $i$030 = 1;
 while(1) {
  $172 = (+($i$030|0));
  $173 = $172;
  $174 = (+Math_pow((+$173),1.3333333333333333));
  $175 = $174;
  $176 = (14040 + ($i$030<<2)|0);
  HEAPF32[$176>>2] = $175;
  $177 = (($i$030) + 1)|0;
  $exitcond46 = ($177|0)==(8208);
  if ($exitcond46) {
   break;
  } else {
   $i$030 = $177;
  }
 }
 HEAPF32[46872>>2] = 0.0;
 $$pre = +HEAPF32[14040>>2];
 $183 = $$pre;$i$129 = 1;
 while(1) {
  $178 = (+($i$129|0));
  $179 = $178 + -0.5;
  $180 = (14040 + ($i$129<<2)|0);
  $181 = +HEAPF32[$180>>2];
  $182 = $181 + $183;
  $184 = $182;
  $185 = $184 * 0.5;
  $186 = (+Math_pow((+$185),0.75));
  $187 = $179 - $186;
  $188 = $187;
  $189 = (46872 + ($i$129<<2)|0);
  HEAPF32[$189>>2] = $188;
  $190 = (($i$129) + 1)|0;
  $exitcond45 = ($190|0)==(8208);
  if ($exitcond45) {
   $i$228 = 0;
   break;
  } else {
   $183 = $181;$i$129 = $190;
  }
 }
 while(1) {
  $191 = (($i$228) + -210)|0;
  $192 = (+($191|0));
  $193 = $192 * -0.1875;
  $exp21 = (+_exp2($193));
  $194 = $exp21;
  $195 = (79704 + ($i$228<<2)|0);
  HEAPF32[$195>>2] = $194;
  $196 = (($i$228) + 1)|0;
  $exitcond44 = ($196|0)==(257);
  if ($exitcond44) {
   $i$327 = 0;
   break;
  } else {
   $i$228 = $196;
  }
 }
 while(1) {
  $197 = (($i$327) + -326)|0;
  $198 = (+($197|0));
  $199 = $198 * 0.25;
  $exp2 = (+_exp2($199));
  $200 = $exp2;
  $201 = (80736 + ($i$327<<2)|0);
  HEAPF32[$201>>2] = $200;
  $202 = (($i$327) + 1)|0;
  $exitcond43 = ($202|0)==(374);
  if ($exitcond43) {
   break;
  } else {
   $i$327 = $202;
  }
 }
 _huffman_init($gfc);
 _init_xrpow_core_init($gfc);
 $203 = ((($gfc)) + 232|0);
 $204 = +HEAPF32[$203>>2];
 $205 = $204 + -0.5;
 $206 = $205 * 0.10000000149011612;
 $207 = (+Math_pow(10.0,(+$206)));
 $208 = ((($gfc)) + 84768|0);
 HEAPF32[$208>>2] = $207;
 $209 = ((($gfc)) + 84772|0);
 HEAPF32[$209>>2] = $207;
 $210 = ((($gfc)) + 84776|0);
 HEAPF32[$210>>2] = $207;
 $211 = ((($gfc)) + 84780|0);
 HEAPF32[$211>>2] = $207;
 $212 = ((($gfc)) + 84784|0);
 HEAPF32[$212>>2] = $207;
 $213 = ((($gfc)) + 84788|0);
 HEAPF32[$213>>2] = $207;
 $214 = ((($gfc)) + 84792|0);
 HEAPF32[$214>>2] = $207;
 $215 = ((($gfc)) + 228|0);
 $216 = +HEAPF32[$215>>2];
 $217 = $216 + -0.25;
 $218 = $217 * 0.10000000149011612;
 $219 = (+Math_pow(10.0,(+$218)));
 $220 = ((($gfc)) + 84796|0);
 HEAPF32[$220>>2] = $219;
 $221 = ((($gfc)) + 84800|0);
 HEAPF32[$221>>2] = $219;
 $222 = ((($gfc)) + 84804|0);
 HEAPF32[$222>>2] = $219;
 $223 = ((($gfc)) + 84808|0);
 HEAPF32[$223>>2] = $219;
 $224 = ((($gfc)) + 84812|0);
 HEAPF32[$224>>2] = $219;
 $225 = ((($gfc)) + 84816|0);
 HEAPF32[$225>>2] = $219;
 $226 = ((($gfc)) + 84820|0);
 HEAPF32[$226>>2] = $219;
 $227 = ((($gfc)) + 236|0);
 $228 = +HEAPF32[$227>>2];
 $229 = $228 + -0.02500000037252903;
 $230 = $229 * 0.10000000149011612;
 $231 = (+Math_pow(10.0,(+$230)));
 $232 = ((($gfc)) + 84824|0);
 HEAPF32[$232>>2] = $231;
 $233 = ((($gfc)) + 84828|0);
 HEAPF32[$233>>2] = $231;
 $234 = ((($gfc)) + 84832|0);
 HEAPF32[$234>>2] = $231;
 $235 = ((($gfc)) + 84836|0);
 HEAPF32[$235>>2] = $231;
 $236 = ((($gfc)) + 84840|0);
 HEAPF32[$236>>2] = $231;
 $237 = ((($gfc)) + 84844|0);
 HEAPF32[$237>>2] = $231;
 $238 = ((($gfc)) + 84848|0);
 HEAPF32[$238>>2] = $231;
 $239 = ((($gfc)) + 240|0);
 $240 = +HEAPF32[$239>>2];
 $241 = $240 + 0.5;
 $242 = $241 * 0.10000000149011612;
 $243 = (+Math_pow(10.0,(+$242)));
 $244 = ((($gfc)) + 84852|0);
 HEAPF32[$244>>2] = $243;
 $245 = +HEAPF32[$203>>2];
 $246 = $245 + -2.0;
 $247 = $246 * 0.10000000149011612;
 $248 = (+Math_pow(10.0,(+$247)));
 $249 = ((($gfc)) + 84856|0);
 HEAPF32[$249>>2] = $248;
 $250 = ((($gfc)) + 84860|0);
 HEAPF32[$250>>2] = $248;
 $251 = ((($gfc)) + 84864|0);
 HEAPF32[$251>>2] = $248;
 $252 = +HEAPF32[$215>>2];
 $253 = $252 + -1.0;
 $254 = $253 * 0.10000000149011612;
 $255 = (+Math_pow(10.0,(+$254)));
 $256 = ((($gfc)) + 84868|0);
 HEAPF32[$256>>2] = $255;
 $257 = ((($gfc)) + 84872|0);
 HEAPF32[$257>>2] = $255;
 $258 = ((($gfc)) + 84876|0);
 HEAPF32[$258>>2] = $255;
 $259 = ((($gfc)) + 84880|0);
 HEAPF32[$259>>2] = $255;
 $260 = +HEAPF32[$227>>2];
 $261 = $260 + -0.05000000074505806;
 $262 = $261 * 0.10000000149011612;
 $263 = (+Math_pow(10.0,(+$262)));
 $264 = ((($gfc)) + 84884|0);
 HEAPF32[$264>>2] = $263;
 $265 = ((($gfc)) + 84888|0);
 HEAPF32[$265>>2] = $263;
 $266 = ((($gfc)) + 84892|0);
 HEAPF32[$266>>2] = $263;
 $267 = ((($gfc)) + 84896|0);
 HEAPF32[$267>>2] = $263;
 $268 = ((($gfc)) + 84900|0);
 HEAPF32[$268>>2] = $263;
 $269 = +HEAPF32[$239>>2];
 $270 = $269 + 0.5;
 $271 = $270 * 0.10000000149011612;
 $272 = (+Math_pow(10.0,(+$271)));
 $273 = ((($gfc)) + 84904|0);
 HEAPF32[$273>>2] = $272;
 return;
}
function _on_pe($gfc,$pe,$targ_bits,$mean_bits,$gr,$cbr) {
 $gfc = $gfc|0;
 $pe = $pe|0;
 $targ_bits = $targ_bits|0;
 $mean_bits = $mean_bits|0;
 $gr = $gr|0;
 $cbr = $cbr|0;
 var $$ = 0, $$3 = 0, $$4 = 0, $$lcssa = 0, $$lcssa43 = 0, $$lcssa44 = 0, $$lcssa45 = 0, $$lcssa46 = 0, $$not = 0, $$not34 = 0, $$storemerge = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 var $17 = 0.0, $18 = 0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0;
 var $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0;
 var $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $8 = 0;
 var $9 = 0, $add_bits = 0, $bits$017 = 0, $bits$19 = 0, $brmerge = 0, $ch$018 = 0, $ch$115 = 0, $ch$212 = 0, $ch$310 = 0, $ch$48 = 0, $extra_bits = 0, $or$cond = 0, $storemerge = 0, $storemerge26 = 0, $tbits = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $extra_bits = sp + 12|0;
 $tbits = sp + 8|0;
 $add_bits = sp;
 HEAP32[$extra_bits>>2] = 0;
 $0 = $add_bits;
 $1 = $0;
 HEAP32[$1>>2] = 0;
 $2 = (($0) + 4)|0;
 $3 = $2;
 HEAP32[$3>>2] = 0;
 _ResvMaxBits($gfc,$mean_bits,$tbits,$extra_bits,$cbr);
 $4 = HEAP32[$tbits>>2]|0;
 $5 = HEAP32[$extra_bits>>2]|0;
 $6 = (($5) + ($4))|0;
 $7 = ($6|0)>(7680);
 $$ = $7 ? 7680 : $6;
 $8 = ((($gfc)) + 72|0);
 $9 = HEAP32[$8>>2]|0;
 $10 = ($9|0)>(0);
 if (!($10)) {
  STACKTOP = sp;return ($$|0);
 }
 $11 = ($mean_bits*3)|0;
 $12 = (($11|0) / 4)&-1;
 $14 = $9;$bits$017 = 0;$ch$018 = 0;
 while(1) {
  $13 = (($4|0) / ($14|0))&-1;
  $15 = ($13|0)>(4095);
  $$3 = $15 ? 4095 : $13;
  $16 = (($targ_bits) + ($ch$018<<2)|0);
  HEAP32[$16>>2] = $$3;
  $17 = (+($$3|0));
  $18 = ((($pe) + ($gr<<3)|0) + ($ch$018<<2)|0);
  $19 = +HEAPF32[$18>>2];
  $20 = $17 * $19;
  $21 = $20;
  $22 = $21 * 0.0014285714285714286;
  $23 = (+($$3|0));
  $24 = $22 - $23;
  $25 = (~~(($24)));
  $26 = (($add_bits) + ($ch$018<<2)|0);
  $27 = ($25|0)>($12|0);
  $storemerge = $27 ? $12 : $25;
  $28 = ($storemerge|0)<(0);
  $$storemerge = $28 ? 0 : $storemerge;
  $29 = (($$storemerge) + ($$3))|0;
  $30 = ($29|0)>(4095);
  if ($30) {
   $31 = (4095 - ($$3))|0;
   $32 = ($31|0)<(0);
   $$4 = $32 ? 0 : $31;
   $storemerge26 = $$4;
  } else {
   $storemerge26 = $$storemerge;
  }
  HEAP32[$26>>2] = $storemerge26;
  $33 = (($storemerge26) + ($bits$017))|0;
  $34 = (($ch$018) + 1)|0;
  $35 = HEAP32[$8>>2]|0;
  $36 = ($34|0)<($35|0);
  if ($36) {
   $14 = $35;$bits$017 = $33;$ch$018 = $34;
  } else {
   $$lcssa45 = $33;$$lcssa46 = $35;
   break;
  }
 }
 $37 = ($$lcssa45|0)>($5|0);
 $38 = ($$lcssa45|0)>(0);
 $or$cond = $38 & $37;
 if ($or$cond) {
  $39 = ($$lcssa46|0)>(0);
  if ($39) {
   $ch$115 = 0;
   while(1) {
    $41 = (($add_bits) + ($ch$115<<2)|0);
    $42 = HEAP32[$41>>2]|0;
    $43 = Math_imul($42, $5)|0;
    $44 = (($43|0) / ($$lcssa45|0))&-1;
    HEAP32[$41>>2] = $44;
    $45 = (($ch$115) + 1)|0;
    $46 = ($45|0)<($$lcssa46|0);
    if ($46) {
     $ch$115 = $45;
    } else {
     break;
    }
   }
  } else {
   STACKTOP = sp;return ($$|0);
  }
 }
 $40 = ($$lcssa46|0)>(0);
 if ($40) {
  $54 = $5;$ch$212 = 0;
 } else {
  STACKTOP = sp;return ($$|0);
 }
 while(1) {
  $48 = (($add_bits) + ($ch$212<<2)|0);
  $49 = HEAP32[$48>>2]|0;
  $50 = (($targ_bits) + ($ch$212<<2)|0);
  $51 = HEAP32[$50>>2]|0;
  $52 = (($51) + ($49))|0;
  HEAP32[$50>>2] = $52;
  $53 = (($54) - ($49))|0;
  $55 = (($ch$212) + 1)|0;
  $56 = HEAP32[$8>>2]|0;
  $57 = ($55|0)<($56|0);
  if ($57) {
   $54 = $53;$ch$212 = $55;
  } else {
   $$lcssa43 = $53;$$lcssa44 = $56;
   break;
  }
 }
 HEAP32[$extra_bits>>2] = $$lcssa43;
 $47 = ($$lcssa44|0)>(0);
 if ($47) {
  $bits$19 = 0;$ch$310 = 0;
 } else {
  STACKTOP = sp;return ($$|0);
 }
 while(1) {
  $58 = (($targ_bits) + ($ch$310<<2)|0);
  $59 = HEAP32[$58>>2]|0;
  $60 = (($59) + ($bits$19))|0;
  $61 = (($ch$310) + 1)|0;
  $62 = ($61|0)<($$lcssa44|0);
  if ($62) {
   $bits$19 = $60;$ch$310 = $61;
  } else {
   $$lcssa = $60;
   break;
  }
 }
 $$not = ($$lcssa|0)<(7681);
 $$not34 = $47 ^ 1;
 $brmerge = $$not | $$not34;
 if ($brmerge) {
  STACKTOP = sp;return ($$|0);
 } else {
  $ch$48 = 0;
 }
 while(1) {
  $63 = (($targ_bits) + ($ch$48<<2)|0);
  $64 = HEAP32[$63>>2]|0;
  $65 = ($64*7680)|0;
  $66 = (($65|0) / ($$lcssa|0))&-1;
  HEAP32[$63>>2] = $66;
  $67 = (($ch$48) + 1)|0;
  $68 = HEAP32[$8>>2]|0;
  $69 = ($67|0)<($68|0);
  if ($69) {
   $ch$48 = $67;
  } else {
   break;
  }
 }
 STACKTOP = sp;return ($$|0);
}
function _reduce_side($targ_bits,$ms_ener_ratio,$mean_bits,$max_bits) {
 $targ_bits = $targ_bits|0;
 $ms_ener_ratio = +$ms_ener_ratio;
 $mean_bits = $mean_bits|0;
 $max_bits = $max_bits|0;
 var $$ = 0, $$op = 0.0, $0 = 0.0, $1 = 0.0, $10 = 0, $11 = 0, $12 = 0.0, $13 = 0.0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0.0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0.0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0.0, $8 = 0, $9 = 0, $fac$0 = 0.0, $move_bits$1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = $ms_ener_ratio;
 $1 = 0.5 - $0;
 $2 = $1 * 0.66000000000000003;
 $3 = $2;
 $4 = $3 < 0.0;
 $fac$0 = $4 ? 0.0 : $3;
 $5 = $fac$0 > 0.5;
 $6 = $fac$0;
 $$op = $6 * 0.5;
 $7 = $5 ? 0.25 : $$op;
 $8 = HEAP32[$targ_bits>>2]|0;
 $9 = ((($targ_bits)) + 4|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = (($10) + ($8))|0;
 $12 = (+($11|0));
 $13 = $12 * $7;
 $14 = (~~(($13)));
 $15 = (4095 - ($8))|0;
 $16 = ($14|0)>($15|0);
 $$ = $16 ? $15 : $14;
 $17 = ($$|0)<(0);
 $move_bits$1 = $17 ? 0 : $$;
 $18 = ($10|0)>(124);
 do {
  if ($18) {
   $19 = (($10) - ($move_bits$1))|0;
   $20 = ($19|0)>(125);
   if (!($20)) {
    $23 = (($8) + -125)|0;
    $24 = (($23) + ($10))|0;
    HEAP32[$targ_bits>>2] = $24;
    HEAP32[$9>>2] = 125;
    $26 = $24;$27 = 125;
    break;
   }
   $21 = ($8|0)<($mean_bits|0);
   if ($21) {
    $22 = (($move_bits$1) + ($8))|0;
    HEAP32[$targ_bits>>2] = $22;
    $33 = $22;
   } else {
    $33 = $8;
   }
   HEAP32[$9>>2] = $19;
   $26 = $33;$27 = $19;
  } else {
   $26 = $8;$27 = $10;
  }
 } while(0);
 $25 = (($27) + ($26))|0;
 $28 = ($25|0)>($max_bits|0);
 if (!($28)) {
  return;
 }
 $29 = Math_imul($26, $max_bits)|0;
 $30 = (($29|0) / ($25|0))&-1;
 HEAP32[$targ_bits>>2] = $30;
 $31 = Math_imul($27, $max_bits)|0;
 $32 = (($31|0) / ($25|0))&-1;
 HEAP32[$9>>2] = $32;
 return;
}
function _athAdjust($a,$x,$athFloor,$ATHfixpoint) {
 $a = +$a;
 $x = +$x;
 $athFloor = +$athFloor;
 $ATHfixpoint = +$ATHfixpoint;
 var $$neg = 0.0, $0 = 0, $1 = 0.0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0.0, $7 = 0, $8 = 0.0;
 var $9 = 0.0, $ATHfixpoint$op = 0.0, $w$0 = 0.0, $w$1 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = $ATHfixpoint < 1.0;
 $1 = (+_fast_log2($x));
 $2 = $1;
 $3 = $2 * 3.0102999566398116;
 $4 = $3;
 $5 = $a * $a;
 $6 = $4 - $athFloor;
 $7 = $5 > 9.9999996826552254E-21;
 if ($7) {
  $8 = (+_fast_log2($5));
  $9 = $8;
  $10 = $9 * 0.03333343265598758;
  $11 = $10 + 1.0;
  $12 = $11;
  $w$0 = $12;
 } else {
  $w$0 = 0.0;
 }
 $13 = $w$0 < 0.0;
 $w$1 = $13 ? 0.0 : $w$0;
 $14 = $w$1 * $6;
 $15 = $athFloor + 90.308731079101563;
 $ATHfixpoint$op = -$ATHfixpoint;
 $$neg = $0 ? -94.824447631835938 : $ATHfixpoint$op;
 $16 = $15 + $$neg;
 $17 = $16 + $14;
 $18 = $17 * 0.10000000149011612;
 $19 = (+Math_pow(10.0,(+$18)));
 return (+$19);
}
function _calc_xmin($gfc,$ratio,$cod_info,$pxmin) {
 $gfc = $gfc|0;
 $ratio = $ratio|0;
 $cod_info = $cod_info|0;
 $pxmin = $pxmin|0;
 var $$0$lcssa = 0, $$040 = 0, $$122 = 0, $$2$lcssa = 0, $$lcssa = 0.0, $$lcssa93 = 0.0, $$lcssa94 = 0.0, $$lcssa95 = 0.0, $$lcssa96 = 0.0, $$lcssa97 = 0.0, $$lcssa98 = 0.0, $$lcssa99 = 0.0, $$neg$i = 0.0, $$neg$i4 = 0.0, $$pre = 0.0, $$rh2$0 = 0.0, $$rh26$0 = 0.0, $$rh26$0$us = 0.0, $$rh26$0$us$1 = 0.0, $$rh26$0$us$2 = 0.0;
 var $0 = 0, $1 = 0, $10 = 0.0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0.0, $110 = 0, $111 = 0, $112 = 0.0, $113 = 0, $114 = 0.0, $115 = 0.0;
 var $116 = 0.0, $117 = 0, $118 = 0.0, $119 = 0.0, $12 = 0.0, $120 = 0.0, $121 = 0.0, $122 = 0.0, $123 = 0.0, $124 = 0, $125 = 0.0, $126 = 0.0, $127 = 0.0, $128 = 0.0, $129 = 0.0, $13 = 0, $130 = 0, $131 = 0.0, $132 = 0.0, $133 = 0.0;
 var $134 = 0.0, $135 = 0.0, $136 = 0.0, $137 = 0, $138 = 0.0, $139 = 0.0, $14 = 0.0, $140 = 0, $141 = 0, $142 = 0.0, $143 = 0.0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0.0, $150 = 0, $151 = 0.0;
 var $152 = 0, $153 = 0, $154 = 0.0, $155 = 0.0, $156 = 0.0, $157 = 0.0, $158 = 0, $159 = 0, $16 = 0.0, $160 = 0, $161 = 0.0, $162 = 0.0, $163 = 0.0, $164 = 0, $165 = 0.0, $166 = 0.0, $167 = 0, $168 = 0, $169 = 0, $17 = 0.0;
 var $170 = 0, $171 = 0, $172 = 0, $173 = 0.0, $174 = 0, $175 = 0, $176 = 0, $177 = 0.0, $178 = 0.0, $179 = 0, $18 = 0.0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0.0, $185 = 0, $186 = 0, $187 = 0, $188 = 0.0;
 var $189 = 0.0, $19 = 0.0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0.0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0.0, $201 = 0.0, $202 = 0, $203 = 0, $204 = 0, $205 = 0;
 var $206 = 0, $207 = 0, $208 = 0, $209 = 0.0, $21 = 0.0, $210 = 0, $211 = 0.0, $212 = 0, $213 = 0.0, $214 = 0, $215 = 0, $216 = 0.0, $217 = 0.0, $218 = 0.0, $219 = 0, $22 = 0.0, $220 = 0.0, $221 = 0.0, $222 = 0.0, $223 = 0;
 var $224 = 0, $225 = 0.0, $226 = 0.0, $227 = 0.0, $228 = 0, $229 = 0, $23 = 0.0, $230 = 0, $231 = 0, $232 = 0, $233 = 0.0, $234 = 0.0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0.0, $240 = 0, $241 = 0.0;
 var $242 = 0.0, $243 = 0.0, $244 = 0, $245 = 0.0, $246 = 0.0, $247 = 0, $248 = 0, $249 = 0, $25 = 0.0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0.0, $255 = 0, $256 = 0, $257 = 0.0, $258 = 0.0, $259 = 0.0, $26 = 0;
 var $260 = 0.0, $261 = 0.0, $262 = 0, $263 = 0, $264 = 0.0, $265 = 0.0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0.0, $270 = 0, $271 = 0, $272 = 0, $273 = 0.0, $274 = 0.0, $275 = 0.0, $276 = 0, $277 = 0.0, $278 = 0.0;
 var $279 = 0, $28 = 0.0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0.0, $287 = 0, $288 = 0, $289 = 0.0, $29 = 0.0, $290 = 0.0, $291 = 0.0, $292 = 0.0, $293 = 0.0, $294 = 0, $295 = 0, $296 = 0.0;
 var $297 = 0.0, $298 = 0, $299 = 0, $3 = 0, $30 = 0.0, $300 = 0, $301 = 0, $302 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0, $34 = 0.0, $35 = 0.0, $36 = 0, $37 = 0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0, $41 = 0;
 var $42 = 0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0, $47 = 0.0, $48 = 0.0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0.0, $57 = 0, $58 = 0, $59 = 0.0, $6 = 0;
 var $60 = 0.0, $61 = 0.0, $62 = 0.0, $63 = 0, $64 = 0, $65 = 0.0, $66 = 0.0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0.0, $76 = 0, $77 = 0, $78 = 0;
 var $79 = 0, $8 = 0.0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0;
 var $97 = 0, $98 = 0, $99 = 0, $ATHfixpoint$op$i = 0.0, $ATHfixpoint$op$i3 = 0.0, $ath_over$0$lcssa = 0, $ath_over$037 = 0, $ath_over$1 = 0, $ath_over$2$lcssa = 0, $ath_over$216 = 0, $ath_over$3$lcssa = 0, $ath_over$4 = 0, $ath_over$4$1 = 0, $ath_over$4$2 = 0, $ath_over$4$us = 0, $ath_over$4$us$1 = 0, $ath_over$4$us$2 = 0, $en0$0$lcssa = 0.0, $en0$030 = 0.0, $en03$07$us = 0.0;
 var $en03$07$us$1 = 0.0, $en03$07$us$2 = 0.0, $exitcond = 0, $exitcond$1 = 0, $exitcond$2 = 0, $exitcond62 = 0, $fabsf = 0.0, $gsfb$0$lcssa = 0, $gsfb$039 = 0, $gsfb$118 = 0, $j$0$lcssa = 0, $j$038 = 0, $j$1$lcssa = 0, $j$131 = 0, $j$217 = 0, $j$3$lcssa = 0, $j$48$us = 0, $j$48$us$1 = 0, $j$48$us$2 = 0, $k$027 = 0;
 var $l$028 = 0, $l2$06$us = 0, $l2$06$us$1 = 0, $l2$06$us$2 = 0, $limit$0 = 0, $limit$0$in = 0, $limit$0$max_nonzero$1 = 0, $max_nonzero$0 = 0, $max_nonzero$1 = 0, $max_nonzero$2 = 0, $or$cond = 0, $or$cond73 = 0, $or$cond74 = 0, $rh2$0$lcssa = 0.0, $rh2$029 = 0.0, $rh26$09$us = 0.0, $rh26$09$us$1 = 0.0, $rh26$09$us$2 = 0.0, $rh3$0 = 0.0, $rh37$0 = 0.0;
 var $rh37$0$us = 0.0, $rh37$0$us$1 = 0.0, $rh37$0$us$2 = 0.0, $sfb$020 = 0, $w$0$i = 0.0, $w$0$i1 = 0.0, $w$1$i = 0.0, $w$1$i2 = 0.0, $xmin$0 = 0.0, $xmin4$0 = 0.0, $xmin4$0$1 = 0.0, $xmin4$0$2 = 0.0, $xmin4$0$us = 0.0, $xmin4$0$us$1 = 0.0, $xmin4$0$us$2 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gfc)) + 85796|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ((($cod_info)) + 4856|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)>(0);
 if ($4) {
  $5 = ((($1)) + 8|0);
  $6 = ((($1)) + 20|0);
  $7 = ((($gfc)) + 224|0);
  $$040 = $pxmin;$ath_over$037 = 0;$gsfb$039 = 0;$j$038 = 0;
  while(1) {
   $8 = +HEAPF32[$5>>2];
   $9 = (((($1)) + 24|0) + ($gsfb$039<<2)|0);
   $10 = +HEAPF32[$9>>2];
   $11 = +HEAPF32[$6>>2];
   $12 = +HEAPF32[$7>>2];
   $13 = $12 < 1.0;
   $14 = (+_fast_log2($10));
   $15 = $14;
   $16 = $15 * 3.0102999566398116;
   $17 = $16;
   $18 = $8 * $8;
   $19 = $17 - $11;
   $20 = $18 > 9.9999996826552254E-21;
   if ($20) {
    $21 = (+_fast_log2($18));
    $22 = $21;
    $23 = $22 * 0.03333343265598758;
    $24 = $23 + 1.0;
    $25 = $24;
    $w$0$i = $25;
   } else {
    $w$0$i = 0.0;
   }
   $26 = $w$0$i < 0.0;
   $w$1$i = $26 ? 0.0 : $w$0$i;
   $27 = $w$1$i * $19;
   $28 = $11 + 90.308731079101563;
   $ATHfixpoint$op$i = -$12;
   $$neg$i = $13 ? -94.824447631835938 : $ATHfixpoint$op$i;
   $29 = $28 + $$neg$i;
   $30 = $29 + $27;
   $31 = $30 * 0.10000000149011612;
   $32 = (+Math_pow(10.0,(+$31)));
   $33 = (((($gfc)) + 84768|0) + ($gsfb$039<<2)|0);
   $34 = +HEAPF32[$33>>2];
   $35 = $34 * $32;
   $36 = (((($cod_info)) + 4872|0) + ($gsfb$039<<2)|0);
   $37 = HEAP32[$36>>2]|0;
   $38 = (+($37|0));
   $39 = $35 / $38;
   $40 = ($37|0)>(0);
   if ($40) {
    $en0$030 = 0.0;$j$131 = $j$038;$l$028 = 0;$rh2$029 = 2.2204460492503131E-16;
    while(1) {
     $41 = (($j$131) + 1)|0;
     $42 = (($cod_info) + ($j$131<<2)|0);
     $43 = +HEAPF32[$42>>2];
     $44 = $43 * $43;
     $45 = $44 + $en0$030;
     $46 = $44 < $39;
     $47 = $46 ? $44 : $39;
     $48 = $47 + $rh2$029;
     $49 = (($l$028) + 1)|0;
     $exitcond62 = ($49|0)==($37|0);
     if ($exitcond62) {
      $$lcssa98 = $45;$$lcssa99 = $48;
      break;
     } else {
      $en0$030 = $45;$j$131 = $41;$l$028 = $49;$rh2$029 = $48;
     }
    }
    $50 = (($j$038) + ($37))|0;
    $en0$0$lcssa = $$lcssa98;$j$1$lcssa = $50;$rh2$0$lcssa = $$lcssa99;
   } else {
    $en0$0$lcssa = 0.0;$j$1$lcssa = $j$038;$rh2$0$lcssa = 2.2204460492503131E-16;
   }
   $51 = $en0$0$lcssa > $35;
   $52 = $51&1;
   $ath_over$1 = (($52) + ($ath_over$037))|0;
   $53 = $en0$0$lcssa < $35;
   $54 = $rh2$0$lcssa < $35;
   $$rh2$0 = $54 ? $35 : $rh2$0$lcssa;
   $rh3$0 = $53 ? $en0$0$lcssa : $$rh2$0;
   $55 = (((($ratio)) + 244|0) + ($gsfb$039<<2)|0);
   $56 = +HEAPF32[$55>>2];
   $57 = $56 > 9.999999960041972E-13;
   if ($57) {
    $58 = (($ratio) + ($gsfb$039<<2)|0);
    $59 = +HEAPF32[$58>>2];
    $60 = $59 * $en0$0$lcssa;
    $61 = $60 / $56;
    $62 = $34 * $61;
    $63 = $rh3$0 < $62;
    if ($63) {
     $xmin$0 = $62;
    } else {
     $xmin$0 = $rh3$0;
    }
   } else {
    $xmin$0 = $rh3$0;
   }
   $64 = $xmin$0 > 2.2204460492503131E-16;
   $65 = $64 ? $xmin$0 : 2.2204460492503131E-16;
   $66 = $65 + 9.9999998245167004E-15;
   $67 = $en0$0$lcssa > $66;
   $68 = $67&1;
   $69 = (((($cod_info)) + 5212|0) + ($gsfb$039)|0);
   HEAP8[$69>>0] = $68;
   $70 = ((($$040)) + 4|0);
   HEAPF32[$$040>>2] = $65;
   $71 = (($gsfb$039) + 1)|0;
   $72 = HEAP32[$2>>2]|0;
   $73 = ($71|0)<($72|0);
   if ($73) {
    $$040 = $70;$ath_over$037 = $ath_over$1;$gsfb$039 = $71;$j$038 = $j$1$lcssa;
   } else {
    $$0$lcssa = $70;$ath_over$0$lcssa = $ath_over$1;$gsfb$0$lcssa = $71;$j$0$lcssa = $j$1$lcssa;
    break;
   }
  }
 } else {
  $$0$lcssa = $pxmin;$ath_over$0$lcssa = 0;$gsfb$0$lcssa = 0;$j$0$lcssa = 0;
 }
 $k$027 = 575;
 while(1) {
  $74 = (($cod_info) + ($k$027<<2)|0);
  $75 = +HEAPF32[$74>>2];
  $fabsf = (+Math_abs((+$75)));
  $76 = $fabsf > 9.999999960041972E-13;
  if ($76) {
   $max_nonzero$0 = $k$027;
   break;
  }
  $77 = (($k$027) + -1)|0;
  $78 = ($k$027|0)>(1);
  if ($78) {
   $k$027 = $77;
  } else {
   $max_nonzero$0 = 0;
   break;
  }
 }
 $79 = ((($cod_info)) + 4788|0);
 $80 = HEAP32[$79>>2]|0;
 $81 = ($80|0)==(2);
 if ($81) {
  $83 = (($max_nonzero$0|0) % 6)&-1;
  $84 = (($max_nonzero$0) + 5)|0;
  $85 = (($84) - ($83))|0;
  $max_nonzero$1 = $85;
 } else {
  $82 = $max_nonzero$0 | 1;
  $max_nonzero$1 = $82;
 }
 $86 = ((($gfc)) + 85092|0);
 $87 = HEAP32[$86>>2]|0;
 $88 = ($87|0)==(0);
 if ($88) {
  $89 = ((($gfc)) + 64|0);
  $90 = HEAP32[$89>>2]|0;
  $91 = ($90|0)<(44000);
  if ($91) {
   $92 = ($90|0)<(8001);
   if ($81) {
    $96 = $92 ? 9 : 12;
    $97 = (((($gfc)) + 21452|0) + ($96<<2)|0);
    $98 = HEAP32[$97>>2]|0;
    $99 = ($98*3)|0;
    $limit$0$in = $99;
   } else {
    $93 = $92 ? 17 : 21;
    $94 = (((($gfc)) + 21360|0) + ($93<<2)|0);
    $95 = HEAP32[$94>>2]|0;
    $limit$0$in = $95;
   }
   $limit$0 = (($limit$0$in) + -1)|0;
   $100 = ($max_nonzero$1|0)>($limit$0|0);
   $limit$0$max_nonzero$1 = $100 ? $limit$0 : $max_nonzero$1;
   $max_nonzero$2 = $limit$0$max_nonzero$1;
  } else {
   $max_nonzero$2 = $max_nonzero$1;
  }
 } else {
  $max_nonzero$2 = $max_nonzero$1;
 }
 $101 = ((($cod_info)) + 5208|0);
 HEAP32[$101>>2] = $max_nonzero$2;
 $102 = ((($cod_info)) + 4864|0);
 $103 = HEAP32[$102>>2]|0;
 $104 = ($gsfb$0$lcssa|0)<($103|0);
 if (!($104)) {
  $ath_over$2$lcssa = $ath_over$0$lcssa;
  return ($ath_over$2$lcssa|0);
 }
 $105 = ((($cod_info)) + 4852|0);
 $106 = HEAP32[$105>>2]|0;
 $107 = ((($1)) + 8|0);
 $108 = ((($1)) + 20|0);
 $109 = ((($gfc)) + 224|0);
 $110 = ((($gfc)) + 92|0);
 $111 = ((($gfc)) + 85800|0);
 $$122 = $$0$lcssa;$ath_over$216 = $ath_over$0$lcssa;$gsfb$118 = $gsfb$0$lcssa;$j$217 = $j$0$lcssa;$sfb$020 = $106;
 while(1) {
  $112 = +HEAPF32[$107>>2];
  $113 = (((($1)) + 112|0) + ($sfb$020<<2)|0);
  $114 = +HEAPF32[$113>>2];
  $115 = +HEAPF32[$108>>2];
  $116 = +HEAPF32[$109>>2];
  $117 = $116 < 1.0;
  $118 = (+_fast_log2($114));
  $119 = $118;
  $120 = $119 * 3.0102999566398116;
  $121 = $120;
  $122 = $112 * $112;
  $123 = $121 - $115;
  $124 = $122 > 9.9999996826552254E-21;
  if ($124) {
   $125 = (+_fast_log2($122));
   $126 = $125;
   $127 = $126 * 0.03333343265598758;
   $128 = $127 + 1.0;
   $129 = $128;
   $w$0$i1 = $129;
  } else {
   $w$0$i1 = 0.0;
  }
  $130 = $w$0$i1 < 0.0;
  $w$1$i2 = $130 ? 0.0 : $w$0$i1;
  $131 = $w$1$i2 * $123;
  $132 = $115 + 90.308731079101563;
  $ATHfixpoint$op$i3 = -$116;
  $$neg$i4 = $117 ? -94.824447631835938 : $ATHfixpoint$op$i3;
  $133 = $132 + $$neg$i4;
  $134 = $133 + $131;
  $135 = $134 * 0.10000000149011612;
  $136 = (+Math_pow(10.0,(+$135)));
  $137 = (((($gfc)) + 84856|0) + ($sfb$020<<2)|0);
  $138 = +HEAPF32[$137>>2];
  $139 = $138 * $136;
  $140 = (((($cod_info)) + 4872|0) + ($gsfb$118<<2)|0);
  $141 = HEAP32[$140>>2]|0;
  $142 = (+($141|0));
  $143 = $139 / $142;
  $144 = ($141|0)>(0);
  if ($144) {
   $en03$07$us = 0.0;$j$48$us = $j$217;$l2$06$us = 0;$rh26$09$us = 2.2204460492503131E-16;
   while(1) {
    $159 = (($j$48$us) + 1)|0;
    $160 = (($cod_info) + ($j$48$us<<2)|0);
    $161 = +HEAPF32[$160>>2];
    $162 = $161 * $161;
    $163 = $162 + $en03$07$us;
    $164 = $162 < $143;
    $165 = $164 ? $162 : $143;
    $166 = $165 + $rh26$09$us;
    $167 = (($l2$06$us) + 1)|0;
    $exitcond = ($167|0)==($141|0);
    if ($exitcond) {
     $$lcssa = $163;$$lcssa93 = $166;
     break;
    } else {
     $en03$07$us = $163;$j$48$us = $159;$l2$06$us = $167;$rh26$09$us = $166;
    }
   }
   $145 = (($141) + ($j$217))|0;
   $146 = $$lcssa > $139;
   $147 = $146&1;
   $ath_over$4$us = (($147) + ($ath_over$216))|0;
   $148 = $$lcssa < $139;
   $149 = $$lcssa93 < $139;
   $$rh26$0$us = $149 ? $139 : $$lcssa93;
   $rh37$0$us = $148 ? $$lcssa : $$rh26$0$us;
   $150 = (((($ratio)) + 332|0) + (($sfb$020*12)|0)|0);
   $151 = +HEAPF32[$150>>2];
   $152 = $151 > 9.999999960041972E-13;
   if ($152) {
    $153 = (((($ratio)) + 88|0) + (($sfb$020*12)|0)|0);
    $154 = +HEAPF32[$153>>2];
    $155 = $154 * $$lcssa;
    $156 = $155 / $151;
    $157 = $138 * $156;
    $158 = $rh37$0$us < $157;
    if ($158) {
     $xmin4$0$us = $157;
    } else {
     $xmin4$0$us = $rh37$0$us;
    }
   } else {
    $xmin4$0$us = $rh37$0$us;
   }
   $232 = $xmin4$0$us > 2.2204460492503131E-16;
   $233 = $232 ? $xmin4$0$us : 2.2204460492503131E-16;
   $234 = $233 + 9.9999998245167004E-15;
   $235 = $$lcssa > $234;
   $236 = $235&1;
   $237 = (((($cod_info)) + 5212|0) + ($gsfb$118)|0);
   HEAP8[$237>>0] = $236;
   $238 = ((($$122)) + 4|0);
   HEAPF32[$$122>>2] = $233;
   $en03$07$us$1 = 0.0;$j$48$us$1 = $145;$l2$06$us$1 = 0;$rh26$09$us$1 = 2.2204460492503131E-16;
   while(1) {
    $239 = (($j$48$us$1) + 1)|0;
    $240 = (($cod_info) + ($j$48$us$1<<2)|0);
    $241 = +HEAPF32[$240>>2];
    $242 = $241 * $241;
    $243 = $242 + $en03$07$us$1;
    $244 = $242 < $143;
    $245 = $244 ? $242 : $143;
    $246 = $245 + $rh26$09$us$1;
    $247 = (($l2$06$us$1) + 1)|0;
    $exitcond$1 = ($247|0)==($141|0);
    if ($exitcond$1) {
     $$lcssa94 = $243;$$lcssa95 = $246;
     break;
    } else {
     $en03$07$us$1 = $243;$j$48$us$1 = $239;$l2$06$us$1 = $247;$rh26$09$us$1 = $246;
    }
   }
   $248 = (($141) + ($145))|0;
   $249 = $$lcssa94 > $139;
   $250 = $249&1;
   $ath_over$4$us$1 = (($250) + ($ath_over$4$us))|0;
   $251 = $$lcssa94 < $139;
   $252 = $$lcssa95 < $139;
   $$rh26$0$us$1 = $252 ? $139 : $$lcssa95;
   $rh37$0$us$1 = $251 ? $$lcssa94 : $$rh26$0$us$1;
   $253 = (((((($ratio)) + 332|0) + (($sfb$020*12)|0)|0)) + 4|0);
   $254 = +HEAPF32[$253>>2];
   $255 = $254 > 9.999999960041972E-13;
   if ($255) {
    $256 = (((((($ratio)) + 88|0) + (($sfb$020*12)|0)|0)) + 4|0);
    $257 = +HEAPF32[$256>>2];
    $258 = $257 * $$lcssa94;
    $259 = $258 / $254;
    $260 = +HEAPF32[$137>>2];
    $261 = $260 * $259;
    $262 = $rh37$0$us$1 < $261;
    if ($262) {
     $xmin4$0$us$1 = $261;
    } else {
     $xmin4$0$us$1 = $rh37$0$us$1;
    }
   } else {
    $xmin4$0$us$1 = $rh37$0$us$1;
   }
   $263 = $xmin4$0$us$1 > 2.2204460492503131E-16;
   $264 = $263 ? $xmin4$0$us$1 : 2.2204460492503131E-16;
   $265 = $264 + 9.9999998245167004E-15;
   $266 = $$lcssa94 > $265;
   $267 = $266&1;
   $268 = (($gsfb$118) + 1)|0;
   $269 = (((($cod_info)) + 5212|0) + ($268)|0);
   HEAP8[$269>>0] = $267;
   $270 = ((($$122)) + 8|0);
   HEAPF32[$238>>2] = $264;
   $en03$07$us$2 = 0.0;$j$48$us$2 = $248;$l2$06$us$2 = 0;$rh26$09$us$2 = 2.2204460492503131E-16;
   while(1) {
    $271 = (($j$48$us$2) + 1)|0;
    $272 = (($cod_info) + ($j$48$us$2<<2)|0);
    $273 = +HEAPF32[$272>>2];
    $274 = $273 * $273;
    $275 = $274 + $en03$07$us$2;
    $276 = $274 < $143;
    $277 = $276 ? $274 : $143;
    $278 = $277 + $rh26$09$us$2;
    $279 = (($l2$06$us$2) + 1)|0;
    $exitcond$2 = ($279|0)==($141|0);
    if ($exitcond$2) {
     $$lcssa96 = $275;$$lcssa97 = $278;
     break;
    } else {
     $en03$07$us$2 = $275;$j$48$us$2 = $271;$l2$06$us$2 = $279;$rh26$09$us$2 = $278;
    }
   }
   $280 = (($141) + ($248))|0;
   $281 = $$lcssa96 > $139;
   $282 = $281&1;
   $ath_over$4$us$2 = (($282) + ($ath_over$4$us$1))|0;
   $283 = $$lcssa96 < $139;
   $284 = $$lcssa97 < $139;
   $$rh26$0$us$2 = $284 ? $139 : $$lcssa97;
   $rh37$0$us$2 = $283 ? $$lcssa96 : $$rh26$0$us$2;
   $285 = (((((($ratio)) + 332|0) + (($sfb$020*12)|0)|0)) + 8|0);
   $286 = +HEAPF32[$285>>2];
   $287 = $286 > 9.999999960041972E-13;
   if ($287) {
    $288 = (((((($ratio)) + 88|0) + (($sfb$020*12)|0)|0)) + 8|0);
    $289 = +HEAPF32[$288>>2];
    $290 = $289 * $$lcssa96;
    $291 = $290 / $286;
    $292 = +HEAPF32[$137>>2];
    $293 = $292 * $291;
    $294 = $rh37$0$us$2 < $293;
    if ($294) {
     $xmin4$0$us$2 = $293;
    } else {
     $xmin4$0$us$2 = $rh37$0$us$2;
    }
   } else {
    $xmin4$0$us$2 = $rh37$0$us$2;
   }
   $295 = $xmin4$0$us$2 > 2.2204460492503131E-16;
   $296 = $295 ? $xmin4$0$us$2 : 2.2204460492503131E-16;
   $297 = $296 + 9.9999998245167004E-15;
   $298 = $$lcssa96 > $297;
   $299 = $298&1;
   $300 = (($gsfb$118) + 2)|0;
   $301 = (((($cod_info)) + 5212|0) + ($300)|0);
   HEAP8[$301>>0] = $299;
   HEAPF32[$270>>2] = $296;
   $302 = $296;$ath_over$3$lcssa = $ath_over$4$us$2;$j$3$lcssa = $280;
  } else {
   $168 = $139 < 0.0;
   $169 = $168&1;
   $ath_over$4 = (($169) + ($ath_over$216))|0;
   $170 = $139 > 0.0;
   $171 = $139 > 2.2204460492503131E-16;
   $$rh26$0 = $171 ? $139 : 2.2204460492503131E-16;
   $rh37$0 = $170 ? 0.0 : $$rh26$0;
   $172 = (((($ratio)) + 332|0) + (($sfb$020*12)|0)|0);
   $173 = +HEAPF32[$172>>2];
   $174 = $173 > 9.999999960041972E-13;
   $175 = $rh37$0 < 0.0;
   $or$cond = $174 & $175;
   $xmin4$0 = $or$cond ? 0.0 : $rh37$0;
   $176 = $xmin4$0 > 2.2204460492503131E-16;
   $177 = $176 ? $xmin4$0 : 2.2204460492503131E-16;
   $178 = $177 + 9.9999998245167004E-15;
   $179 = $178 < 0.0;
   $180 = $179&1;
   $181 = (((($cod_info)) + 5212|0) + ($gsfb$118)|0);
   HEAP8[$181>>0] = $180;
   $182 = ((($$122)) + 4|0);
   HEAPF32[$$122>>2] = $177;
   $ath_over$4$1 = (($169) + ($ath_over$4))|0;
   $183 = (((((($ratio)) + 332|0) + (($sfb$020*12)|0)|0)) + 4|0);
   $184 = +HEAPF32[$183>>2];
   $185 = $184 > 9.999999960041972E-13;
   $186 = $rh37$0 < 0.0;
   $or$cond73 = $185 & $186;
   $xmin4$0$1 = $or$cond73 ? 0.0 : $rh37$0;
   $187 = $xmin4$0$1 > 2.2204460492503131E-16;
   $188 = $187 ? $xmin4$0$1 : 2.2204460492503131E-16;
   $189 = $188 + 9.9999998245167004E-15;
   $190 = $189 < 0.0;
   $191 = $190&1;
   $192 = (($gsfb$118) + 1)|0;
   $193 = (((($cod_info)) + 5212|0) + ($192)|0);
   HEAP8[$193>>0] = $191;
   $194 = ((($$122)) + 8|0);
   HEAPF32[$182>>2] = $188;
   $ath_over$4$2 = (($169) + ($ath_over$4$1))|0;
   $195 = (((((($ratio)) + 332|0) + (($sfb$020*12)|0)|0)) + 8|0);
   $196 = +HEAPF32[$195>>2];
   $197 = $196 > 9.999999960041972E-13;
   $198 = $rh37$0 < 0.0;
   $or$cond74 = $197 & $198;
   $xmin4$0$2 = $or$cond74 ? 0.0 : $rh37$0;
   $199 = $xmin4$0$2 > 2.2204460492503131E-16;
   $200 = $199 ? $xmin4$0$2 : 2.2204460492503131E-16;
   $201 = $200 + 9.9999998245167004E-15;
   $202 = $201 < 0.0;
   $203 = $202&1;
   $204 = (($gsfb$118) + 2)|0;
   $205 = (((($cod_info)) + 5212|0) + ($204)|0);
   HEAP8[$205>>0] = $203;
   HEAPF32[$194>>2] = $200;
   $302 = $200;$ath_over$3$lcssa = $ath_over$4$2;$j$3$lcssa = $j$217;
  }
  $206 = ((($$122)) + 8|0);
  $$2$lcssa = ((($$122)) + 12|0);
  $207 = HEAP32[$110>>2]|0;
  $208 = ($207|0)==(0);
  if (!($208)) {
   $209 = +HEAPF32[$$122>>2];
   $210 = ((($$122)) + 4|0);
   $211 = +HEAPF32[$210>>2];
   $212 = $209 > $211;
   if ($212) {
    $213 = $209 - $211;
    $214 = HEAP32[$111>>2]|0;
    $215 = ((($214)) + 6496|0);
    $216 = +HEAPF32[$215>>2];
    $217 = $216 * $213;
    $218 = $217 + $211;
    HEAPF32[$210>>2] = $218;
    $$pre = +HEAPF32[$206>>2];
    $220 = $$pre;$221 = $218;
   } else {
    $220 = $302;$221 = $211;
   }
   $219 = $221 > $220;
   if ($219) {
    $222 = $221 - $220;
    $223 = HEAP32[$111>>2]|0;
    $224 = ((($223)) + 6496|0);
    $225 = +HEAPF32[$224>>2];
    $226 = $225 * $222;
    $227 = $226 + $220;
    HEAPF32[$206>>2] = $227;
   }
  }
  $228 = (($sfb$020) + 1)|0;
  $229 = (($gsfb$118) + 3)|0;
  $230 = HEAP32[$102>>2]|0;
  $231 = ($229|0)<($230|0);
  if ($231) {
   $$122 = $$2$lcssa;$ath_over$216 = $ath_over$3$lcssa;$gsfb$118 = $229;$j$217 = $j$3$lcssa;$sfb$020 = $228;
  } else {
   $ath_over$2$lcssa = $ath_over$3$lcssa;
   break;
  }
 }
 return ($ath_over$2$lcssa|0);
}
function _calc_noise($cod_info,$l3_xmin,$distort,$res,$prev_noise) {
 $cod_info = $cod_info|0;
 $l3_xmin = $l3_xmin|0;
 $distort = $distort|0;
 $res = $res|0;
 $prev_noise = $prev_noise|0;
 var $$ = 0, $$0114 = 0, $$015 = 0, $$09$i = 0, $$113$i = 0, $$219$i = 0, $$lcssa = 0.0, $$lcssa35 = 0.0, $$lcssa36 = 0.0, $$ph = 0, $$pre = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0.0, $104 = 0, $105 = 0;
 var $106 = 0, $107 = 0.0, $108 = 0.0, $109 = 0.0, $11 = 0, $110 = 0, $111 = 0.0, $112 = 0.0, $113 = 0, $114 = 0.0, $115 = 0, $116 = 0, $117 = 0, $118 = 0.0, $119 = 0.0, $12 = 0, $120 = 0.0, $121 = 0, $122 = 0.0, $123 = 0.0;
 var $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0.0, $134 = 0, $135 = 0.0, $136 = 0.0, $137 = 0.0, $138 = 0.0, $139 = 0.0, $14 = 0, $140 = 0, $141 = 0;
 var $142 = 0, $143 = 0.0, $144 = 0, $145 = 0.0, $146 = 0.0, $147 = 0.0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0.0, $155 = 0, $156 = 0.0, $157 = 0, $158 = 0, $159 = 0, $16 = 0;
 var $160 = 0, $161 = 0, $162 = 0, $163 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0;
 var $31 = 0, $32 = 0, $33 = 0.0, $34 = 0.0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0.0, $44 = 0.0, $45 = 0, $46 = 0.0, $47 = 0, $48 = 0, $49 = 0.0;
 var $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0.0, $66 = 0, $67 = 0.0;
 var $68 = 0.0, $69 = 0, $7 = 0, $70 = 0.0, $71 = 0, $72 = 0.0, $73 = 0.0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0.0, $82 = 0, $83 = 0, $84 = 0, $85 = 0.0;
 var $86 = 0.0, $87 = 0, $88 = 0.0, $89 = 0.0, $9 = 0, $90 = 0, $91 = 0.0, $92 = 0, $93 = 0, $94 = 0, $95 = 0.0, $96 = 0.0, $97 = 0, $98 = 0.0, $99 = 0.0, $distort_$0$ph = 0.0, $fabsf$i = 0.0, $fabsf1$i = 0.0, $fabsf2$i = 0.0, $fabsf3$i = 0.0;
 var $ix01$i = 0, $j$07$i = 0, $j$111$i = 0, $j$217$i = 0, $j$3$i = 0, $l$0 = 0, $max_noise$0$lcssa = 0.0, $max_noise$08 = 0.0, $noise$0$ph = 0.0, $noise$02 = 0.0, $noise$08$i = 0.0, $noise$112$i = 0.0, $noise$218$i = 0.0, $noise$3$i = 0.0, $over$0$lcssa = 0, $over$010 = 0, $over$1 = 0, $over_noise_db$0$lcssa = 0.0, $over_noise_db$06 = 0.0, $over_noise_db$1 = 0.0;
 var $scalefac$09 = 0, $sfb$011 = 0, $tot_noise_db$0$lcssa = 0.0, $tot_noise_db$07 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $ix01$i = sp;
 $0 = ((($res)) + 16|0);
 HEAP32[$0>>2] = 0;
 $1 = ((($cod_info)) + 4864|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = ($2|0)>(0);
 if (!($3)) {
  $max_noise$0$lcssa = -20.0;$over$0$lcssa = 0;$over_noise_db$0$lcssa = 0.0;$tot_noise_db$0$lcssa = 0.0;
  $160 = ((($res)) + 12|0);
  HEAP32[$160>>2] = $over$0$lcssa;
  $161 = ((($res)) + 4|0);
  HEAPF32[$161>>2] = $tot_noise_db$0$lcssa;
  HEAPF32[$res>>2] = $over_noise_db$0$lcssa;
  $162 = ((($res)) + 8|0);
  HEAPF32[$162>>2] = $max_noise$0$lcssa;
  STACKTOP = sp;return ($over$0$lcssa|0);
 }
 $4 = ((($cod_info)) + 4608|0);
 $5 = ((($cod_info)) + 4780|0);
 $6 = ((($cod_info)) + 4832|0);
 $7 = ((($cod_info)) + 4836|0);
 $8 = ($prev_noise|0)!=(0|0);
 $9 = ((($cod_info)) + 5208|0);
 $10 = ((($cod_info)) + 4776|0);
 $11 = ((($cod_info)) + 4772|0);
 $12 = ((($ix01$i)) + 4|0);
 $$0114 = $distort;$$015 = $l3_xmin;$41 = 0;$max_noise$08 = -20.0;$over$010 = 0;$over_noise_db$06 = 0.0;$scalefac$09 = $4;$sfb$011 = 0;$tot_noise_db$07 = 0.0;
 while(1) {
  $13 = HEAP32[$5>>2]|0;
  $14 = ((($scalefac$09)) + 4|0);
  $15 = HEAP32[$scalefac$09>>2]|0;
  $16 = HEAP32[$6>>2]|0;
  $17 = ($16|0)==(0);
  if ($17) {
   $21 = 0;
  } else {
   $18 = (12112 + ($sfb$011<<2)|0);
   $19 = HEAP32[$18>>2]|0;
   $21 = $19;
  }
  $20 = (($21) + ($15))|0;
  $22 = HEAP32[$7>>2]|0;
  $23 = (($22) + 1)|0;
  $24 = $20 << $23;
  $25 = (($13) - ($24))|0;
  $26 = (((($cod_info)) + 5028|0) + ($sfb$011<<2)|0);
  $27 = HEAP32[$26>>2]|0;
  $28 = (((($cod_info)) + 4808|0) + ($27<<2)|0);
  $29 = HEAP32[$28>>2]|0;
  $30 = $29 << 3;
  $31 = (($25) - ($30))|0;
  $32 = ((($$015)) + 4|0);
  $33 = +HEAPF32[$$015>>2];
  $34 = 1.0 / $33;
  if ($8) {
   $35 = (((($prev_noise)) + 8|0) + ($sfb$011<<2)|0);
   $36 = HEAP32[$35>>2]|0;
   $37 = ($36|0)==($31|0);
   if ($37) {
    $38 = (((($cod_info)) + 4872|0) + ($sfb$011<<2)|0);
    $39 = HEAP32[$38>>2]|0;
    $40 = (($39) + ($41))|0;
    $42 = (((($prev_noise)) + 164|0) + ($sfb$011<<2)|0);
    $43 = +HEAPF32[$42>>2];
    $44 = $43 * $34;
    $45 = (((($prev_noise)) + 320|0) + ($sfb$011<<2)|0);
    $46 = +HEAPF32[$45>>2];
    $$ph = $40;$141 = $13;$distort_$0$ph = $44;$noise$0$ph = $46;
    label = 27;
   } else {
    label = 8;
   }
  } else {
   label = 8;
  }
  do {
   if ((label|0) == 8) {
    label = 0;
    $47 = (($31) + 116)|0;
    $48 = (80736 + ($47<<2)|0);
    $49 = +HEAPF32[$48>>2];
    $50 = (((($cod_info)) + 4872|0) + ($sfb$011<<2)|0);
    $51 = HEAP32[$50>>2]|0;
    $52 = $51 >> 1;
    $53 = (($51) + ($41))|0;
    $54 = HEAP32[$9>>2]|0;
    $55 = ($53|0)>($54|0);
    if ($55) {
     $56 = (($54) - ($41))|0;
     $57 = ($56|0)>(-1);
     if ($57) {
      $58 = (($56) + 1)|0;
      $59 = $58 >> 1;
      $l$0 = $59;
     } else {
      $l$0 = 0;
     }
    } else {
     $l$0 = $52;
    }
    $60 = HEAP32[$10>>2]|0;
    $61 = ($41|0)>($60|0);
    do {
     if ($61) {
      $62 = ($l$0|0)==(0);
      if ($62) {
       $j$3$i = $41;$noise$3$i = 0.0;
      } else {
       $$09$i = $l$0;$j$07$i = $41;$noise$08$i = 0.0;
       while(1) {
        $63 = (($$09$i) + -1)|0;
        $64 = (($cod_info) + ($j$07$i<<2)|0);
        $65 = +HEAPF32[$64>>2];
        $66 = (($j$07$i) + 1)|0;
        $67 = $65 * $65;
        $68 = $67 + $noise$08$i;
        $69 = (($cod_info) + ($66<<2)|0);
        $70 = +HEAPF32[$69>>2];
        $71 = (($j$07$i) + 2)|0;
        $72 = $70 * $70;
        $73 = $68 + $72;
        $74 = ($63|0)==(0);
        if ($74) {
         $$lcssa36 = $73;
         break;
        } else {
         $$09$i = $63;$j$07$i = $71;$noise$08$i = $73;
        }
       }
       $125 = $l$0 << 1;
       $126 = (($125) + ($41))|0;
       $j$3$i = $126;$noise$3$i = $$lcssa36;
      }
     } else {
      $75 = HEAP32[$11>>2]|0;
      $76 = ($41|0)>($75|0);
      if ($76) {
       HEAPF32[$ix01$i>>2] = 0.0;
       HEAPF32[$12>>2] = $49;
       $78 = ($l$0|0)==(0);
       if ($78) {
        $j$3$i = $41;$noise$3$i = 0.0;
        break;
       } else {
        $$113$i = $l$0;$j$111$i = $41;$noise$112$i = 0.0;
       }
       while(1) {
        $79 = (($$113$i) + -1)|0;
        $80 = (($cod_info) + ($j$111$i<<2)|0);
        $81 = +HEAPF32[$80>>2];
        $fabsf2$i = (+Math_abs((+$81)));
        $82 = (((($cod_info)) + 2304|0) + ($j$111$i<<2)|0);
        $83 = HEAP32[$82>>2]|0;
        $84 = (($ix01$i) + ($83<<2)|0);
        $85 = +HEAPF32[$84>>2];
        $86 = $fabsf2$i - $85;
        $87 = (($j$111$i) + 1)|0;
        $88 = $86 * $86;
        $89 = $88 + $noise$112$i;
        $90 = (($cod_info) + ($87<<2)|0);
        $91 = +HEAPF32[$90>>2];
        $fabsf3$i = (+Math_abs((+$91)));
        $92 = (((($cod_info)) + 2304|0) + ($87<<2)|0);
        $93 = HEAP32[$92>>2]|0;
        $94 = (($ix01$i) + ($93<<2)|0);
        $95 = +HEAPF32[$94>>2];
        $96 = $fabsf3$i - $95;
        $97 = (($j$111$i) + 2)|0;
        $98 = $96 * $96;
        $99 = $89 + $98;
        $100 = ($79|0)==(0);
        if ($100) {
         $$lcssa35 = $99;
         break;
        } else {
         $$113$i = $79;$j$111$i = $97;$noise$112$i = $99;
        }
       }
       $127 = $l$0 << 1;
       $128 = (($127) + ($41))|0;
       $j$3$i = $128;$noise$3$i = $$lcssa35;
       break;
      } else {
       $77 = ($l$0|0)==(0);
       if ($77) {
        $j$3$i = $41;$noise$3$i = 0.0;
        break;
       } else {
        $$219$i = $l$0;$j$217$i = $41;$noise$218$i = 0.0;
       }
       while(1) {
        $101 = (($$219$i) + -1)|0;
        $102 = (($cod_info) + ($j$217$i<<2)|0);
        $103 = +HEAPF32[$102>>2];
        $fabsf$i = (+Math_abs((+$103)));
        $104 = (((($cod_info)) + 2304|0) + ($j$217$i<<2)|0);
        $105 = HEAP32[$104>>2]|0;
        $106 = (14040 + ($105<<2)|0);
        $107 = +HEAPF32[$106>>2];
        $108 = $107 * $49;
        $109 = $fabsf$i - $108;
        $110 = (($j$217$i) + 1)|0;
        $111 = $109 * $109;
        $112 = $111 + $noise$218$i;
        $113 = (($cod_info) + ($110<<2)|0);
        $114 = +HEAPF32[$113>>2];
        $fabsf1$i = (+Math_abs((+$114)));
        $115 = (((($cod_info)) + 2304|0) + ($110<<2)|0);
        $116 = HEAP32[$115>>2]|0;
        $117 = (14040 + ($116<<2)|0);
        $118 = +HEAPF32[$117>>2];
        $119 = $118 * $49;
        $120 = $fabsf1$i - $119;
        $121 = (($j$217$i) + 2)|0;
        $122 = $120 * $120;
        $123 = $112 + $122;
        $124 = ($101|0)==(0);
        if ($124) {
         $$lcssa = $123;
         break;
        } else {
         $$219$i = $101;$j$217$i = $121;$noise$218$i = $123;
        }
       }
       $129 = $l$0 << 1;
       $130 = (($129) + ($41))|0;
       $j$3$i = $130;$noise$3$i = $$lcssa;
       break;
      }
     }
    } while(0);
    if ($8) {
     $131 = (((($prev_noise)) + 8|0) + ($sfb$011<<2)|0);
     HEAP32[$131>>2] = $31;
     $132 = (((($prev_noise)) + 164|0) + ($sfb$011<<2)|0);
     HEAPF32[$132>>2] = $noise$3$i;
    }
    $133 = $noise$3$i * $34;
    $134 = $133 > 9.9999996826552254E-21;
    $135 = $134 ? $133 : 9.9999996826552254E-21;
    $136 = (+_fast_log2($135));
    $137 = $136;
    $138 = $137 * 0.30102999566398114;
    $139 = $138;
    if ($8) {
     $140 = (((($prev_noise)) + 320|0) + ($sfb$011<<2)|0);
     HEAPF32[$140>>2] = $139;
     $$pre = HEAP32[$5>>2]|0;
     $$ph = $j$3$i;$141 = $$pre;$distort_$0$ph = $133;$noise$0$ph = $139;
     label = 27;
     break;
    } else {
     HEAPF32[$$0114>>2] = $133;
     $163 = $j$3$i;$noise$02 = $139;
     break;
    }
   }
  } while(0);
  if ((label|0) == 27) {
   label = 0;
   HEAPF32[$$0114>>2] = $distort_$0$ph;
   HEAP32[$prev_noise>>2] = $141;
   $163 = $$ph;$noise$02 = $noise$0$ph;
  }
  $142 = ((($$0114)) + 4|0);
  $143 = $noise$02 + $tot_noise_db$07;
  $144 = $noise$02 > 0.0;
  if ($144) {
   $145 = $noise$02 * 10.0;
   $146 = $145;
   $147 = $146 + 0.5;
   $148 = (~~(($147)));
   $149 = ($148|0)>(1);
   $$ = $149 ? $148 : 1;
   $150 = Math_imul($$, $$)|0;
   $151 = HEAP32[$0>>2]|0;
   $152 = (($151) + ($150))|0;
   HEAP32[$0>>2] = $152;
   $153 = (($over$010) + 1)|0;
   $154 = $noise$02 + $over_noise_db$06;
   $over$1 = $153;$over_noise_db$1 = $154;
  } else {
   $over$1 = $over$010;$over_noise_db$1 = $over_noise_db$06;
  }
  $155 = $max_noise$08 > $noise$02;
  $156 = $155 ? $max_noise$08 : $noise$02;
  $157 = (($sfb$011) + 1)|0;
  $158 = HEAP32[$1>>2]|0;
  $159 = ($157|0)<($158|0);
  if ($159) {
   $$0114 = $142;$$015 = $32;$41 = $163;$max_noise$08 = $156;$over$010 = $over$1;$over_noise_db$06 = $over_noise_db$1;$scalefac$09 = $14;$sfb$011 = $157;$tot_noise_db$07 = $143;
  } else {
   $max_noise$0$lcssa = $156;$over$0$lcssa = $over$1;$over_noise_db$0$lcssa = $over_noise_db$1;$tot_noise_db$0$lcssa = $143;
   break;
  }
 }
 $160 = ((($res)) + 12|0);
 HEAP32[$160>>2] = $over$0$lcssa;
 $161 = ((($res)) + 4|0);
 HEAPF32[$161>>2] = $tot_noise_db$0$lcssa;
 HEAPF32[$res>>2] = $over_noise_db$0$lcssa;
 $162 = ((($res)) + 8|0);
 HEAPF32[$162>>2] = $max_noise$0$lcssa;
 STACKTOP = sp;return ($over$0$lcssa|0);
}
function _set_frame_pinfo($gfc,$ratio) {
 $gfc = $gfc|0;
 $ratio = $ratio|0;
 var $$2$i = 0.0, $$3$i = 0.0, $$3$i$1 = 0.0, $$3$i$2 = 0.0, $$3$us$i = 0.0, $$4$i = 0.0, $$lcssa27 = 0.0, $$lcssa28 = 0, $$phi$trans$insert$i = 0, $$phi$trans$insert43$i = 0, $$pre = 0, $$pre$i = 0, $$pre19 = 0, $$pre20 = 0, $$pre44$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0.0, $101 = 0.0;
 var $102 = 0.0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0;
 var $120 = 0, $121 = 0, $122 = 0, $123 = 0.0, $124 = 0, $125 = 0, $126 = 0.0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0.0, $131 = 0.0, $132 = 0, $133 = 0.0, $134 = 0.0, $135 = 0.0, $136 = 0.0, $137 = 0, $138 = 0;
 var $139 = 0.0, $14 = 0, $140 = 0, $141 = 0.0, $142 = 0.0, $143 = 0, $144 = 0.0, $145 = 0.0, $146 = 0.0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0.0, $151 = 0.0, $152 = 0, $153 = 0.0, $154 = 0.0, $155 = 0.0, $156 = 0.0;
 var $157 = 0, $158 = 0, $159 = 0.0, $16 = 0, $160 = 0, $161 = 0.0, $162 = 0, $163 = 0, $164 = 0, $165 = 0.0, $166 = 0.0, $167 = 0, $168 = 0.0, $169 = 0.0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0.0, $174 = 0.0;
 var $175 = 0, $176 = 0, $177 = 0, $178 = 0.0, $179 = 0.0, $18 = 0, $180 = 0.0, $181 = 0.0, $182 = 0, $183 = 0, $184 = 0, $185 = 0.0, $186 = 0.0, $187 = 0.0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0.0, $192 = 0;
 var $193 = 0, $194 = 0, $195 = 0.0, $196 = 0.0, $197 = 0, $198 = 0.0, $199 = 0.0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0.0, $203 = 0.0, $204 = 0, $205 = 0, $206 = 0, $207 = 0.0, $208 = 0.0, $209 = 0.0, $21 = 0;
 var $210 = 0.0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0.0, $216 = 0.0, $217 = 0, $218 = 0.0, $219 = 0.0, $22 = 0, $220 = 0.0, $221 = 0.0, $222 = 0, $223 = 0, $224 = 0.0, $225 = 0, $226 = 0, $227 = 0, $228 = 0;
 var $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0.0, $24 = 0, $240 = 0.0, $241 = 0.0, $242 = 0, $243 = 0.0, $244 = 0.0, $245 = 0.0, $246 = 0;
 var $247 = 0.0, $248 = 0.0, $249 = 0.0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0.0, $261 = 0, $262 = 0, $263 = 0, $264 = 0.0;
 var $265 = 0.0, $266 = 0, $267 = 0.0, $268 = 0.0, $269 = 0, $27 = 0, $270 = 0, $271 = 0.0, $272 = 0.0, $273 = 0, $274 = 0, $275 = 0, $276 = 0.0, $277 = 0.0, $278 = 0.0, $279 = 0.0, $28 = 0, $280 = 0, $281 = 0, $282 = 0;
 var $283 = 0, $284 = 0.0, $285 = 0.0, $286 = 0, $287 = 0.0, $288 = 0.0, $289 = 0.0, $29 = 0, $290 = 0.0, $291 = 0, $292 = 0, $293 = 0.0, $294 = 0, $295 = 0.0, $296 = 0, $297 = 0, $298 = 0, $299 = 0.0, $3 = 0, $30 = 0;
 var $300 = 0.0, $301 = 0, $302 = 0.0, $303 = 0.0, $304 = 0, $305 = 0, $306 = 0.0, $307 = 0.0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0.0, $312 = 0.0, $313 = 0.0, $314 = 0.0, $315 = 0, $316 = 0, $317 = 0, $32 = 0.0;
 var $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0;
 var $51 = 0, $52 = 0, $53 = 0, $54 = 0.0, $55 = 0.0, $56 = 0.0, $57 = 0, $58 = 0.0, $59 = 0.0, $6 = 0, $60 = 0.0, $61 = 0.0, $62 = 0, $63 = 0, $64 = 0.0, $65 = 0.0, $66 = 0, $67 = 0.0, $68 = 0.0, $69 = 0.0;
 var $7 = 0, $70 = 0.0, $71 = 0, $72 = 0, $73 = 0.0, $74 = 0, $75 = 0, $76 = 0, $77 = 0.0, $78 = 0, $79 = 0.0, $8 = 0, $80 = 0.0, $81 = 0, $82 = 0.0, $83 = 0, $84 = 0.0, $85 = 0.0, $86 = 0, $87 = 0;
 var $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0.0, $92 = 0.0, $93 = 0.0, $94 = 0.0, $95 = 0, $96 = 0, $97 = 0, $98 = 0.0, $99 = 0.0, $ch$06 = 0, $en0$0$lcssa$i = 0.0, $en0$019$i = 0.0, $en0$1$i = 0.0, $en0$28$us$i = 0.0, $en0$3$i = 0.0, $en0$3$i$1 = 0.0;
 var $en0$3$i$2 = 0.0, $en0$3$us$i = 0.0, $en0$4$i = 0.0, $en0$4$i$1 = 0.0, $en0$4$i$2 = 0.0, $en0$4$us$i = 0.0, $exitcond38$i = 0, $exitcond39$i = 0, $exitcond40$i = 0, $exitcond41$i = 0, $exitcond42$i = 0, $gr$010 = 0, $i$011$us$i = 0, $j$0$lcssa$i = 0, $j$025$i = 0, $j$1$lcssa$i = 0, $j$118$i = 0, $j$213$i = 0, $j$3$lcssa$i = 0, $j$310$us$i = 0;
 var $j$46$us$i = 0, $l$07$us$i = 0, $l3_xmin$i = 0, $noise$i = 0, $or$cond$i = 0, $scalefac_sav = 0, $sfb$0$lcssa$i = 0, $sfb$026$i = 0, $sfb$05 = 0, $sfb$115$i = 0, $sfb2$045$i = 0, $sfb2$114$i = 0, $sfb2$2$lcssa$i = 0, $sfb2$212$us$i = 0, $xfsf$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 496|0;
 $l3_xmin$i = sp + 340|0;
 $xfsf$i = sp + 184|0;
 $noise$i = sp + 160|0;
 $scalefac_sav = sp;
 $0 = ((($gfc)) + 76|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($1|0)>(0);
 if (!($2)) {
  STACKTOP = sp;return;
 }
 $3 = ((($gfc)) + 72|0);
 $4 = ((($gfc)) + 85804|0);
 $5 = ((($gfc)) + 212|0);
 $6 = ((($gfc)) + 85796|0);
 $$phi$trans$insert$i = ((($gfc)) + 21360|0);
 $7 = ((($gfc)) + 216|0);
 $8 = ((($noise$i)) + 12|0);
 $9 = ((($noise$i)) + 8|0);
 $10 = ((($noise$i)) + 4|0);
 $11 = ((($noise$i)) + 16|0);
 $$pre = HEAP32[$3>>2]|0;
 $12 = $$pre;$315 = $1;$gr$010 = 0;
 while(1) {
  $13 = ($12|0)>(0);
  if ($13) {
   $14 = ($gr$010|0)==(1);
   $ch$06 = 0;
   while(1) {
    $15 = ((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0);
    $16 = ((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4608|0);
    _memcpy(($scalefac_sav|0),($16|0),156)|0;
    if ($14) {
     $17 = (((((($gfc)) + 10808|0) + (($ch$06*5252)|0)|0)) + 4848|0);
     $18 = HEAP32[$17>>2]|0;
     $19 = ($18|0)>(0);
     if ($19) {
      $317 = $18;$sfb$05 = 0;
      while(1) {
       $20 = ((((((($gfc)) + 10808|0) + (($ch$06*5252)|0)|0)) + 4608|0) + ($sfb$05<<2)|0);
       $21 = HEAP32[$20>>2]|0;
       $22 = ($21|0)<(0);
       if ($22) {
        $23 = ((((((($gfc)) + 304|0) + (($ch$06*5252)|0)|0)) + 4608|0) + ($sfb$05<<2)|0);
        $24 = HEAP32[$23>>2]|0;
        HEAP32[$20>>2] = $24;
        $$pre19 = HEAP32[$17>>2]|0;
        $27 = $$pre19;
       } else {
        $27 = $317;
       }
       $25 = (($sfb$05) + 1)|0;
       $26 = ($25|0)<($27|0);
       if ($26) {
        $317 = $27;$sfb$05 = $25;
       } else {
        break;
       }
      }
     }
    }
    $28 = ((($ratio) + (($gr$010*976)|0)|0) + (($ch$06*488)|0)|0);
    $29 = ((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4836|0);
    $30 = HEAP32[$29>>2]|0;
    $31 = ($30|0)==(0);
    $32 = $31 ? 0.5 : 1.0;
    (_calc_xmin($gfc,$28,$15,$l3_xmin$i)|0);
    (_calc_noise($15,$l3_xmin$i,$xfsf$i,$noise$i,0)|0);
    $33 = ((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4848|0);
    $34 = HEAP32[$33>>2]|0;
    $35 = ((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4788|0);
    $36 = HEAP32[$35>>2]|0;
    $37 = ($36|0)==(2);
    if ($37) {
     label = 12;
    } else {
     $38 = ((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4792|0);
     $39 = HEAP32[$38>>2]|0;
     $40 = ($39|0)==(0);
     if ($40) {
      $sfb2$045$i = 22;
      label = 13;
     } else {
      label = 12;
     }
    }
    if ((label|0) == 12) {
     label = 0;
     $41 = ($34|0)>(0);
     if ($41) {
      $sfb2$045$i = $34;
      label = 13;
     } else {
      $j$0$lcssa$i = 0;$sfb$0$lcssa$i = 0;
     }
    }
    if ((label|0) == 13) {
     label = 0;
     $42 = HEAP32[$4>>2]|0;
     $43 = HEAP32[$6>>2]|0;
     $44 = ((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4832|0);
     $45 = HEAP32[$44>>2]|0;
     $46 = ($45|0)!=(0);
     $$pre$i = HEAP32[$$phi$trans$insert$i>>2]|0;
     $51 = $$pre$i;$j$025$i = 0;$sfb$026$i = 0;
     while(1) {
      $47 = (($sfb$026$i) + 1)|0;
      $48 = (((($gfc)) + 21360|0) + ($47<<2)|0);
      $49 = HEAP32[$48>>2]|0;
      $50 = (($49) - ($51))|0;
      $52 = ($j$025$i|0)<($49|0);
      if ($52) {
       $en0$019$i = 0.0;$j$118$i = $j$025$i;
       while(1) {
        $53 = (((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0) + ($j$118$i<<2)|0);
        $54 = +HEAPF32[$53>>2];
        $55 = $54 * $54;
        $56 = $55 + $en0$019$i;
        $57 = (($j$118$i) + 1)|0;
        $exitcond41$i = ($57|0)==($49|0);
        if ($exitcond41$i) {
         $en0$0$lcssa$i = $56;$j$1$lcssa$i = $49;
         break;
        } else {
         $en0$019$i = $56;$j$118$i = $57;
        }
       }
      } else {
       $en0$0$lcssa$i = 0.0;$j$1$lcssa$i = $j$025$i;
      }
      $58 = (+($50|0));
      $59 = $en0$0$lcssa$i / $58;
      $60 = $59 * 999999986991104.0;
      $61 = $60;
      $62 = (((((($42)) + 190712|0) + (($gr$010*704)|0)|0) + (($ch$06*176)|0)|0) + ($sfb$026$i<<3)|0);
      HEAPF64[$62>>3] = $61;
      $63 = (($l3_xmin$i) + ($sfb$026$i<<2)|0);
      $64 = +HEAPF32[$63>>2];
      $65 = $64 * 999999986991104.0;
      $66 = (($xfsf$i) + ($sfb$026$i<<2)|0);
      $67 = +HEAPF32[$66>>2];
      $68 = $65 * $67;
      $69 = $68 / $58;
      $70 = $69;
      $71 = (((((($42)) + 201208|0) + (($gr$010*352)|0)|0) + (($ch$06*176)|0)|0) + ($sfb$026$i<<3)|0);
      HEAPF64[$71>>3] = $70;
      $72 = (((((($ratio) + (($gr$010*976)|0)|0) + (($ch$06*488)|0)|0)) + 244|0) + ($sfb$026$i<<2)|0);
      $73 = +HEAPF32[$72>>2];
      $74 = $73 > 0.0;
      if ($74) {
       $75 = HEAP32[$5>>2]|0;
       $76 = ($75|0)==(0);
       $77 = $59 / $73;
       $$4$i = $76 ? $77 : 0.0;
       $en0$1$i = $$4$i;
      } else {
       $en0$1$i = 0.0;
      }
      $78 = (((($ratio) + (($gr$010*976)|0)|0) + (($ch$06*488)|0)|0) + ($sfb$026$i<<2)|0);
      $79 = +HEAPF32[$78>>2];
      $80 = $79 * $en0$1$i;
      $81 = (((($43)) + 24|0) + ($sfb$026$i<<2)|0);
      $82 = +HEAPF32[$81>>2];
      $83 = $80 > $82;
      $$2$i = $83 ? $80 : $82;
      $84 = $$2$i * 999999986991104.0;
      $85 = $84;
      $86 = (((((($42)) + 189304|0) + (($gr$010*704)|0)|0) + (($ch$06*176)|0)|0) + ($sfb$026$i<<3)|0);
      HEAPF64[$86>>3] = $85;
      $87 = (((((($42)) + 199160|0) + (($gr$010*352)|0)|0) + (($ch$06*176)|0)|0) + ($sfb$026$i<<3)|0);
      HEAPF64[$87>>3] = 0.0;
      $88 = ($sfb$026$i|0)>(10);
      $or$cond$i = $46 & $88;
      if ($or$cond$i) {
       $89 = (12112 + ($sfb$026$i<<2)|0);
       $90 = HEAP32[$89>>2]|0;
       $91 = (+($90|0));
       $92 = $32 * $91;
       $93 = -$92;
       $94 = $93;
       HEAPF64[$87>>3] = $94;
       $102 = $94;
      } else {
       $102 = 0.0;
      }
      $95 = ($sfb$026$i|0)<(21);
      if ($95) {
       $96 = (((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4608|0) + ($sfb$026$i<<2)|0);
       $97 = HEAP32[$96>>2]|0;
       $98 = (+($97|0));
       $99 = $98 * $32;
       $100 = $99;
       $101 = $102 - $100;
       HEAPF64[$87>>3] = $101;
      }
      $exitcond42$i = ($47|0)==($sfb2$045$i|0);
      if ($exitcond42$i) {
       $j$0$lcssa$i = $j$1$lcssa$i;$sfb$0$lcssa$i = $sfb2$045$i;
       break;
      } else {
       $51 = $49;$j$025$i = $j$1$lcssa$i;$sfb$026$i = $47;
      }
     }
    }
    if ($37) {
     $103 = ((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4852|0);
     $104 = HEAP32[$103>>2]|0;
     $105 = ($104|0)<(13);
     if ($105) {
      $106 = HEAP32[$4>>2]|0;
      $107 = HEAP32[$5>>2]|0;
      $108 = ($107|0)==(0);
      $109 = HEAP32[$6>>2]|0;
      $$phi$trans$insert43$i = (((($gfc)) + 21452|0) + ($104<<2)|0);
      $$pre44$i = HEAP32[$$phi$trans$insert43$i>>2]|0;
      $110 = ((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4808|0);
      $111 = ((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4812|0);
      $112 = ((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4816|0);
      $116 = $$pre44$i;$j$213$i = $j$0$lcssa$i;$sfb$115$i = $104;$sfb2$114$i = $sfb$0$lcssa$i;
      while(1) {
       $118 = (($sfb$115$i) + 1)|0;
       $119 = (((($gfc)) + 21452|0) + ($118<<2)|0);
       $120 = HEAP32[$119>>2]|0;
       $121 = (($120) - ($116))|0;
       $122 = ($120|0)>($116|0);
       $123 = (+($121|0));
       $124 = ($sfb$115$i*3)|0;
       $125 = (((($109)) + 112|0) + ($sfb$115$i<<2)|0);
       $126 = +HEAPF32[$125>>2];
       $127 = ($sfb$115$i|0)<(12);
       if ($122) {
        $114 = ($120*3)|0;
        $i$011$us$i = 0;$j$310$us$i = $j$213$i;$sfb2$212$us$i = $sfb2$114$i;
        while(1) {
         $en0$28$us$i = 0.0;$j$46$us$i = $j$310$us$i;$l$07$us$i = $116;
         while(1) {
          $184 = (((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0) + ($j$46$us$i<<2)|0);
          $185 = +HEAPF32[$184>>2];
          $186 = $185 * $185;
          $187 = $186 + $en0$28$us$i;
          $188 = (($j$46$us$i) + 1)|0;
          $189 = (($l$07$us$i) + 1)|0;
          $exitcond38$i = ($189|0)==($120|0);
          if ($exitcond38$i) {
           $$lcssa27 = $187;
           break;
          } else {
           $en0$28$us$i = $187;$j$46$us$i = $188;$l$07$us$i = $189;
          }
         }
         $140 = (($j$310$us$i) + ($121))|0;
         $141 = $$lcssa27 / $123;
         $142 = $141;
         $143 = $142 > 9.9999999999999995E-21;
         $144 = $143 ? $141 : 9.9999996826552254E-21;
         $145 = $144 * 999999986991104.0;
         $146 = $145;
         $147 = (($i$011$us$i) + ($124))|0;
         $148 = (((((($106)) + 194616|0) + (($gr$010*1248)|0)|0) + (($ch$06*312)|0)|0) + ($147<<3)|0);
         HEAPF64[$148>>3] = $146;
         $149 = (($l3_xmin$i) + ($sfb2$212$us$i<<2)|0);
         $150 = +HEAPF32[$149>>2];
         $151 = $150 * 999999986991104.0;
         $152 = (($xfsf$i) + ($sfb2$212$us$i<<2)|0);
         $153 = +HEAPF32[$152>>2];
         $154 = $151 * $153;
         $155 = $154 / $123;
         $156 = $155;
         $157 = (((((($106)) + 201912|0) + (($gr$010*624)|0)|0) + (($ch$06*312)|0)|0) + ($147<<3)|0);
         HEAPF64[$157>>3] = $156;
         $158 = ((((((($ratio) + (($gr$010*976)|0)|0) + (($ch$06*488)|0)|0)) + 332|0) + (($sfb$115$i*12)|0)|0) + ($i$011$us$i<<2)|0);
         $159 = +HEAPF32[$158>>2];
         if ($108) {
          $160 = $159 > 0.0;
          $161 = $144 / $159;
          $en0$3$us$i = $160 ? $161 : 0.0;
          $162 = HEAP32[$7>>2]|0;
          $163 = ($162|0)==(0);
          if ($163) {
           $en0$4$us$i = $en0$3$us$i;
          } else {
           label = 33;
          }
         } else {
          label = 33;
         }
         if ((label|0) == 33) {
          label = 0;
          $en0$4$us$i = 0.0;
         }
         $164 = ((((((($ratio) + (($gr$010*976)|0)|0) + (($ch$06*488)|0)|0)) + 88|0) + (($sfb$115$i*12)|0)|0) + ($i$011$us$i<<2)|0);
         $165 = +HEAPF32[$164>>2];
         $166 = $165 * $en0$4$us$i;
         $167 = $166 > $126;
         $$3$us$i = $167 ? $166 : $126;
         $168 = $$3$us$i * 999999986991104.0;
         $169 = $168;
         $170 = (((((($106)) + 192120|0) + (($gr$010*1248)|0)|0) + (($ch$06*312)|0)|0) + ($147<<3)|0);
         HEAPF64[$170>>3] = $169;
         $171 = (((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4808|0) + ($i$011$us$i<<2)|0);
         $172 = HEAP32[$171>>2]|0;
         $173 = (+($172|0));
         $174 = $173 * -2.0;
         $175 = (((((($106)) + 199864|0) + (($gr$010*624)|0)|0) + (($ch$06*312)|0)|0) + ($147<<3)|0);
         HEAPF64[$175>>3] = $174;
         if ($127) {
          $176 = (((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4608|0) + ($sfb2$212$us$i<<2)|0);
          $177 = HEAP32[$176>>2]|0;
          $178 = (+($177|0));
          $179 = $178 * $32;
          $180 = $179;
          $181 = $174 - $180;
          HEAPF64[$175>>3] = $181;
         }
         $182 = (($sfb2$212$us$i) + 1)|0;
         $183 = (($i$011$us$i) + 1)|0;
         $exitcond39$i = ($183|0)==(3);
         if ($exitcond39$i) {
          break;
         } else {
          $i$011$us$i = $183;$j$310$us$i = $140;$sfb2$212$us$i = $182;
         }
        }
        $113 = (($j$213$i) + ($114))|0;
        $115 = Math_imul($116, -3)|0;
        $117 = (($113) + ($115))|0;
        $j$3$lcssa$i = $117;
       } else {
        $128 = (((((($106)) + 194616|0) + (($gr$010*1248)|0)|0) + (($ch$06*312)|0)|0) + ($124<<3)|0);
        HEAPF64[$128>>3] = 9.9999997473787516E-6;
        $129 = (($l3_xmin$i) + ($sfb2$114$i<<2)|0);
        $130 = +HEAPF32[$129>>2];
        $131 = $130 * 999999986991104.0;
        $132 = (($xfsf$i) + ($sfb2$114$i<<2)|0);
        $133 = +HEAPF32[$132>>2];
        $134 = $131 * $133;
        $135 = $134 / $123;
        $136 = $135;
        $137 = (((((($106)) + 201912|0) + (($gr$010*624)|0)|0) + (($ch$06*312)|0)|0) + ($124<<3)|0);
        HEAPF64[$137>>3] = $136;
        $138 = (((((($ratio) + (($gr$010*976)|0)|0) + (($ch$06*488)|0)|0)) + 332|0) + (($sfb$115$i*12)|0)|0);
        $139 = +HEAPF32[$138>>2];
        if ($108) {
         $190 = $139 > 0.0;
         $191 = 9.9999996826552254E-21 / $139;
         $en0$3$i = $190 ? $191 : 0.0;
         $192 = HEAP32[$7>>2]|0;
         $193 = ($192|0)==(0);
         if ($193) {
          $en0$4$i = $en0$3$i;
         } else {
          label = 40;
         }
        } else {
         label = 40;
        }
        if ((label|0) == 40) {
         label = 0;
         $en0$4$i = 0.0;
        }
        $194 = (((((($ratio) + (($gr$010*976)|0)|0) + (($ch$06*488)|0)|0)) + 88|0) + (($sfb$115$i*12)|0)|0);
        $195 = +HEAPF32[$194>>2];
        $196 = $195 * $en0$4$i;
        $197 = $196 > $126;
        $$3$i = $197 ? $196 : $126;
        $198 = $$3$i * 999999986991104.0;
        $199 = $198;
        $200 = (((((($106)) + 192120|0) + (($gr$010*1248)|0)|0) + (($ch$06*312)|0)|0) + ($124<<3)|0);
        HEAPF64[$200>>3] = $199;
        $201 = HEAP32[$110>>2]|0;
        $202 = (+($201|0));
        $203 = $202 * -2.0;
        $204 = (((((($106)) + 199864|0) + (($gr$010*624)|0)|0) + (($ch$06*312)|0)|0) + ($124<<3)|0);
        HEAPF64[$204>>3] = $203;
        if ($127) {
         $205 = (((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4608|0) + ($sfb2$114$i<<2)|0);
         $206 = HEAP32[$205>>2]|0;
         $207 = (+($206|0));
         $208 = $207 * $32;
         $209 = $208;
         $210 = $203 - $209;
         HEAPF64[$204>>3] = $210;
        }
        $211 = (($sfb2$114$i) + 1)|0;
        $212 = (($124) + 1)|0;
        $213 = (((((($106)) + 194616|0) + (($gr$010*1248)|0)|0) + (($ch$06*312)|0)|0) + ($212<<3)|0);
        HEAPF64[$213>>3] = 9.9999997473787516E-6;
        $214 = (($l3_xmin$i) + ($211<<2)|0);
        $215 = +HEAPF32[$214>>2];
        $216 = $215 * 999999986991104.0;
        $217 = (($xfsf$i) + ($211<<2)|0);
        $218 = +HEAPF32[$217>>2];
        $219 = $216 * $218;
        $220 = $219 / $123;
        $221 = $220;
        $222 = (((((($106)) + 201912|0) + (($gr$010*624)|0)|0) + (($ch$06*312)|0)|0) + ($212<<3)|0);
        HEAPF64[$222>>3] = $221;
        $223 = (((((((($ratio) + (($gr$010*976)|0)|0) + (($ch$06*488)|0)|0)) + 332|0) + (($sfb$115$i*12)|0)|0)) + 4|0);
        $224 = +HEAPF32[$223>>2];
        if ($108) {
         $259 = $224 > 0.0;
         $260 = 9.9999996826552254E-21 / $224;
         $en0$3$i$1 = $259 ? $260 : 0.0;
         $261 = HEAP32[$7>>2]|0;
         $262 = ($261|0)==(0);
         if ($262) {
          $en0$4$i$1 = $en0$3$i$1;
         } else {
          label = 49;
         }
        } else {
         label = 49;
        }
        if ((label|0) == 49) {
         label = 0;
         $en0$4$i$1 = 0.0;
        }
        $263 = (((((((($ratio) + (($gr$010*976)|0)|0) + (($ch$06*488)|0)|0)) + 88|0) + (($sfb$115$i*12)|0)|0)) + 4|0);
        $264 = +HEAPF32[$263>>2];
        $265 = $264 * $en0$4$i$1;
        $266 = $265 > $126;
        $$3$i$1 = $266 ? $265 : $126;
        $267 = $$3$i$1 * 999999986991104.0;
        $268 = $267;
        $269 = (((((($106)) + 192120|0) + (($gr$010*1248)|0)|0) + (($ch$06*312)|0)|0) + ($212<<3)|0);
        HEAPF64[$269>>3] = $268;
        $270 = HEAP32[$111>>2]|0;
        $271 = (+($270|0));
        $272 = $271 * -2.0;
        $273 = (((((($106)) + 199864|0) + (($gr$010*624)|0)|0) + (($ch$06*312)|0)|0) + ($212<<3)|0);
        HEAPF64[$273>>3] = $272;
        if ($127) {
         $274 = (((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4608|0) + ($211<<2)|0);
         $275 = HEAP32[$274>>2]|0;
         $276 = (+($275|0));
         $277 = $276 * $32;
         $278 = $277;
         $279 = $272 - $278;
         HEAPF64[$273>>3] = $279;
        }
        $280 = (($sfb2$114$i) + 2)|0;
        $281 = (($124) + 2)|0;
        $282 = (((((($106)) + 194616|0) + (($gr$010*1248)|0)|0) + (($ch$06*312)|0)|0) + ($281<<3)|0);
        HEAPF64[$282>>3] = 9.9999997473787516E-6;
        $283 = (($l3_xmin$i) + ($280<<2)|0);
        $284 = +HEAPF32[$283>>2];
        $285 = $284 * 999999986991104.0;
        $286 = (($xfsf$i) + ($280<<2)|0);
        $287 = +HEAPF32[$286>>2];
        $288 = $285 * $287;
        $289 = $288 / $123;
        $290 = $289;
        $291 = (((((($106)) + 201912|0) + (($gr$010*624)|0)|0) + (($ch$06*312)|0)|0) + ($281<<3)|0);
        HEAPF64[$291>>3] = $290;
        $292 = (((((((($ratio) + (($gr$010*976)|0)|0) + (($ch$06*488)|0)|0)) + 332|0) + (($sfb$115$i*12)|0)|0)) + 8|0);
        $293 = +HEAPF32[$292>>2];
        if ($108) {
         $294 = $293 > 0.0;
         $295 = 9.9999996826552254E-21 / $293;
         $en0$3$i$2 = $294 ? $295 : 0.0;
         $296 = HEAP32[$7>>2]|0;
         $297 = ($296|0)==(0);
         if ($297) {
          $en0$4$i$2 = $en0$3$i$2;
         } else {
          label = 54;
         }
        } else {
         label = 54;
        }
        if ((label|0) == 54) {
         label = 0;
         $en0$4$i$2 = 0.0;
        }
        $298 = (((((((($ratio) + (($gr$010*976)|0)|0) + (($ch$06*488)|0)|0)) + 88|0) + (($sfb$115$i*12)|0)|0)) + 8|0);
        $299 = +HEAPF32[$298>>2];
        $300 = $299 * $en0$4$i$2;
        $301 = $300 > $126;
        $$3$i$2 = $301 ? $300 : $126;
        $302 = $$3$i$2 * 999999986991104.0;
        $303 = $302;
        $304 = (((((($106)) + 192120|0) + (($gr$010*1248)|0)|0) + (($ch$06*312)|0)|0) + ($281<<3)|0);
        HEAPF64[$304>>3] = $303;
        $305 = HEAP32[$112>>2]|0;
        $306 = (+($305|0));
        $307 = $306 * -2.0;
        $308 = (((((($106)) + 199864|0) + (($gr$010*624)|0)|0) + (($ch$06*312)|0)|0) + ($281<<3)|0);
        HEAPF64[$308>>3] = $307;
        if ($127) {
         $309 = (((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4608|0) + ($280<<2)|0);
         $310 = HEAP32[$309>>2]|0;
         $311 = (+($310|0));
         $312 = $311 * $32;
         $313 = $312;
         $314 = $307 - $313;
         HEAPF64[$308>>3] = $314;
         $j$3$lcssa$i = $j$213$i;
        } else {
         $j$3$lcssa$i = $j$213$i;
        }
       }
       $sfb2$2$lcssa$i = (($sfb2$114$i) + 3)|0;
       $exitcond40$i = ($118|0)==(13);
       if ($exitcond40$i) {
        break;
       } else {
        $116 = $120;$j$213$i = $j$3$lcssa$i;$sfb$115$i = $118;$sfb2$114$i = $sfb2$2$lcssa$i;
       }
      }
     }
    }
    $225 = ((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4780|0);
    $226 = HEAP32[$225>>2]|0;
    $227 = HEAP32[$4>>2]|0;
    $228 = ((((($227)) + 201112|0) + ($gr$010<<3)|0) + ($ch$06<<2)|0);
    HEAP32[$228>>2] = $226;
    $229 = ((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4768|0);
    $230 = HEAP32[$229>>2]|0;
    $231 = ((((((($gfc)) + 304|0) + (($gr$010*10504)|0)|0) + (($ch$06*5252)|0)|0)) + 4844|0);
    $232 = HEAP32[$231>>2]|0;
    $233 = (($232) + ($230))|0;
    $234 = ((((($227)) + 203400|0) + ($gr$010<<3)|0) + ($ch$06<<2)|0);
    HEAP32[$234>>2] = $233;
    $235 = HEAP32[$231>>2]|0;
    $236 = ((((($227)) + 203416|0) + ($gr$010<<3)|0) + ($ch$06<<2)|0);
    HEAP32[$236>>2] = $235;
    $237 = HEAP32[$8>>2]|0;
    $238 = ((((($227)) + 203160|0) + ($gr$010<<3)|0) + ($ch$06<<2)|0);
    HEAP32[$238>>2] = $237;
    $239 = +HEAPF32[$9>>2];
    $240 = $239;
    $241 = $240 * 10.0;
    $242 = ((((($227)) + 203208|0) + ($gr$010<<4)|0) + ($ch$06<<3)|0);
    HEAPF64[$242>>3] = $241;
    $243 = +HEAPF32[$noise$i>>2];
    $244 = $243;
    $245 = $244 * 10.0;
    $246 = ((((($227)) + 203240|0) + ($gr$010<<4)|0) + ($ch$06<<3)|0);
    HEAPF64[$246>>3] = $245;
    $247 = +HEAPF32[$10>>2];
    $248 = $247;
    $249 = $248 * 10.0;
    $250 = ((((($227)) + 203176|0) + ($gr$010<<4)|0) + ($ch$06<<3)|0);
    HEAPF64[$250>>3] = $249;
    $251 = HEAP32[$11>>2]|0;
    $252 = ((((($227)) + 203272|0) + ($gr$010<<3)|0) + ($ch$06<<2)|0);
    HEAP32[$252>>2] = $251;
    _memcpy(($16|0),($scalefac_sav|0),156)|0;
    $253 = (($ch$06) + 1)|0;
    $254 = HEAP32[$3>>2]|0;
    $255 = ($253|0)<($254|0);
    if ($255) {
     $ch$06 = $253;
    } else {
     $$lcssa28 = $254;
     break;
    }
   }
   $$pre20 = HEAP32[$0>>2]|0;
   $258 = $$pre20;$316 = $$lcssa28;
  } else {
   $258 = $315;$316 = $12;
  }
  $256 = (($gr$010) + 1)|0;
  $257 = ($256|0)<($258|0);
  if ($257) {
   $12 = $316;$315 = $258;$gr$010 = $256;
  } else {
   break;
  }
 }
 STACKTOP = sp;return;
}
function _ResvFrameBegin($gfc,$mean_bits) {
 $gfc = $gfc|0;
 $mean_bits = $mean_bits|0;
 var $$ = 0, $$1 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $fullFrameBits$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_getframebits($gfc)|0);
 $1 = ((($gfc)) + 24|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = $2 << 3;
 $4 = (($0) - ($3))|0;
 $5 = ((($gfc)) + 76|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = (($4|0) / ($6|0))&-1;
 $8 = $6 << 11;
 $9 = (($8) + -8)|0;
 $10 = ((($gfc)) + 148|0);
 $11 = HEAP32[$10>>2]|0;
 $12 = (($11) - ($0))|0;
 $13 = ((($gfc)) + 52144|0);
 $14 = ($12|0)>($9|0);
 $$ = $14 ? $9 : $12;
 HEAP32[$13>>2] = $$;
 $15 = ($$|0)<(0);
 if ($15) {
  label = 3;
 } else {
  $16 = ((($gfc)) + 144|0);
  $17 = HEAP32[$16>>2]|0;
  $18 = ($17|0)==(0);
  if ($18) {
   $23 = $$;
  } else {
   label = 3;
  }
 }
 if ((label|0) == 3) {
  HEAP32[$13>>2] = 0;
  $23 = 0;
 }
 $19 = Math_imul($6, $7)|0;
 $20 = ((($gfc)) + 52140|0);
 $21 = HEAP32[$20>>2]|0;
 $22 = ($21|0)<($23|0);
 $$1 = $22 ? $21 : $23;
 $24 = (($$1) + ($19))|0;
 $25 = ($24|0)>($11|0);
 $fullFrameBits$0 = $25 ? $11 : $24;
 $26 = ((($gfc)) + 21320|0);
 HEAP32[$26>>2] = 0;
 $27 = ((($gfc)) + 85804|0);
 $28 = HEAP32[$27>>2]|0;
 $29 = ($28|0)==(0|0);
 if ($29) {
  HEAP32[$mean_bits>>2] = $7;
  return ($fullFrameBits$0|0);
 }
 $30 = (($7|0) / 2)&-1;
 $31 = ((($28)) + 203484|0);
 HEAP32[$31>>2] = $30;
 $32 = ((($28)) + 203488|0);
 HEAP32[$32>>2] = $21;
 HEAP32[$mean_bits>>2] = $7;
 return ($fullFrameBits$0|0);
}
function _ResvMaxBits($gfc,$mean_bits,$targ_bits,$extra_bits,$cbr) {
 $gfc = $gfc|0;
 $mean_bits = $mean_bits|0;
 $targ_bits = $targ_bits|0;
 $extra_bits = $extra_bits|0;
 $cbr = $cbr|0;
 var $$ = 0, $$1 = 0, $$1$ = 0, $0 = 0, $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 var $24 = 0, $25 = 0.0, $26 = 0.0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $ResvMax$0 = 0, $add_bits$0 = 0, $targBits$0 = 0, label = 0;
 var sp = 0;
 sp = STACKTOP;
 $0 = ((($gfc)) + 52140|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ((($gfc)) + 52144|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($cbr|0)==(0);
 $5 = $4 ? 0 : $mean_bits;
 $$1 = (($1) + ($5))|0;
 $6 = ((($gfc)) + 85096|0);
 $7 = HEAP32[$6>>2]|0;
 $8 = $7 & 1;
 $9 = ($8|0)==(0);
 if ($9) {
  $ResvMax$0 = $3;
 } else {
  $10 = (+($3|0));
  $11 = $10 * 0.90000000000000002;
  $12 = (~~(($11)));
  $ResvMax$0 = $12;
 }
 $13 = ($$1*10)|0;
 $14 = ($ResvMax$0*9)|0;
 $15 = ($13|0)>($14|0);
 if ($15) {
  $16 = (($14|0) / 10)&-1;
  $17 = (($$1) - ($16))|0;
  $18 = (($17) + ($mean_bits))|0;
  $19 = $7 | 128;
  HEAP32[$6>>2] = $19;
  $add_bits$0 = $17;$targBits$0 = $18;
 } else {
  $20 = $7 & 127;
  HEAP32[$6>>2] = $20;
  $21 = ((($gfc)) + 144|0);
  $22 = HEAP32[$21>>2]|0;
  $23 = $22 | $8;
  $24 = ($23|0)==(0);
  if ($24) {
   $25 = (+($mean_bits|0));
   $26 = $25 * 0.90000000000000002;
   $27 = (~~(($26)));
   $add_bits$0 = 0;$targBits$0 = $27;
  } else {
   $add_bits$0 = 0;$targBits$0 = $mean_bits;
  }
 }
 $28 = ($3*6)|0;
 $29 = (($28|0) / 10)&-1;
 $30 = ($$1|0)<($29|0);
 $$1$ = $30 ? $$1 : $29;
 $31 = (($$1$) - ($add_bits$0))|0;
 $32 = ($31|0)<(0);
 $$ = $32 ? 0 : $31;
 HEAP32[$targ_bits>>2] = $targBits$0;
 HEAP32[$extra_bits>>2] = $$;
 return;
}
function _ResvAdjust($gfc,$gi) {
 $gfc = $gfc|0;
 $gi = $gi|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $sum = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gi)) + 4768|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ((($gi)) + 4844|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ((($gfc)) + 52140|0);
 $5 = HEAP32[$4>>2]|0;
 $sum = (($3) + ($1))|0;
 $6 = (($5) - ($sum))|0;
 HEAP32[$4>>2] = $6;
 return;
}
function _ResvFrameEnd($gfc,$mean_bits) {
 $gfc = $gfc|0;
 $mean_bits = $mean_bits|0;
 var $$stuffingBits$1 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0;
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $stuffingBits$1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gfc)) + 76|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = Math_imul($1, $mean_bits)|0;
 $3 = ((($gfc)) + 52140|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = (($4) + ($2))|0;
 $6 = ((($gfc)) + 21324|0);
 $7 = ((($gfc)) + 21320|0);
 $8 = (($5|0) % 8)&-1;
 $9 = (($5) - ($8))|0;
 $10 = ((($gfc)) + 52144|0);
 $11 = HEAP32[$10>>2]|0;
 $12 = (($9) - ($11))|0;
 $13 = ($12|0)>(0);
 $14 = $13 ? $12 : 0;
 $stuffingBits$1 = (($14) + ($8))|0;
 $15 = ((($gfc)) + 21312|0);
 $16 = HEAP32[$15>>2]|0;
 $17 = $16 << 3;
 $18 = ($17|0)<($stuffingBits$1|0);
 $$stuffingBits$1 = $18 ? $17 : $stuffingBits$1;
 $19 = (($$stuffingBits$1|0) / 8)&-1;
 $20 = $19 << 3;
 HEAP32[$7>>2] = $20;
 $21 = (($stuffingBits$1) - ($20))|0;
 $22 = (($5) - ($20))|0;
 $23 = (($16) - ($19))|0;
 HEAP32[$15>>2] = $23;
 HEAP32[$6>>2] = $21;
 $24 = (($22) - ($21))|0;
 HEAP32[$3>>2] = $24;
 return;
}
function _lame_set_in_samplerate($gfp,$in_samplerate) {
 $gfp = $gfp|0;
 $in_samplerate = $in_samplerate|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 12|0);
 HEAP32[$2>>2] = $in_samplerate;
 $$0 = 0;
 return ($$0|0);
}
function _lame_set_num_channels($gfp,$num_channels) {
 $gfp = $gfp|0;
 $num_channels = $num_channels|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $or$cond = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ($num_channels|0)>(2);
 $3 = ($num_channels|0)==(0);
 $or$cond = $2 | $3;
 if ($or$cond) {
  $$0 = -1;
  return ($$0|0);
 }
 $4 = ((($gfp)) + 8|0);
 HEAP32[$4>>2] = $num_channels;
 $$0 = 0;
 return ($$0|0);
}
function _lame_set_scale($gfp,$scale) {
 $gfp = $gfp|0;
 $scale = +$scale;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 20|0);
 HEAPF32[$2>>2] = $scale;
 $$0 = 0;
 return ($$0|0);
}
function _lame_get_scale($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0.0, $0 = 0, $1 = 0, $2 = 0, $3 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0.0;
  return (+$$0);
 }
 $2 = ((($gfp)) + 20|0);
 $3 = +HEAPF32[$2>>2];
 $$0 = $3;
 return (+$$0);
}
function _lame_set_mode($gfp,$mode) {
 $gfp = $gfp|0;
 $mode = $mode|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $or$cond = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 $2 = ($mode>>>0)>(4);
 $or$cond = $2 | $1;
 if ($or$cond) {
  $$0 = -1;
  return ($$0|0);
 }
 $3 = ((($gfp)) + 48|0);
 HEAP32[$3>>2] = $mode;
 $$0 = 0;
 return ($$0|0);
}
function _lame_set_brate($gfp,$brate) {
 $gfp = $gfp|0;
 $brate = $brate|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 96|0);
 HEAP32[$2>>2] = $brate;
 $3 = ($brate|0)>(320);
 if (!($3)) {
  $$0 = 0;
  return ($$0|0);
 }
 $4 = ((($gfp)) + 128|0);
 HEAP32[$4>>2] = 1;
 $$0 = 0;
 return ($$0|0);
}
function _lame_set_quant_comp($gfp,$quant_type) {
 $gfp = $gfp|0;
 $quant_type = $quant_type|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 132|0);
 HEAP32[$2>>2] = $quant_type;
 $$0 = 0;
 return ($$0|0);
}
function _lame_set_quant_comp_short($gfp,$quant_type) {
 $gfp = $gfp|0;
 $quant_type = $quant_type|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 136|0);
 HEAP32[$2>>2] = $quant_type;
 $$0 = 0;
 return ($$0|0);
}
function _lame_get_quant_comp($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 132|0);
 $3 = HEAP32[$2>>2]|0;
 $$0 = $3;
 return ($$0|0);
}
function _lame_get_quant_comp_short($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 136|0);
 $3 = HEAP32[$2>>2]|0;
 $$0 = $3;
 return ($$0|0);
}
function _lame_set_experimentalY($gfp,$experimentalY) {
 $gfp = $gfp|0;
 $experimentalY = $experimentalY|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 140|0);
 HEAP32[$2>>2] = $experimentalY;
 $$0 = 0;
 return ($$0|0);
}
function _lame_set_exp_nspsytune($gfp,$exp_nspsytune) {
 $gfp = $gfp|0;
 $exp_nspsytune = $exp_nspsytune|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 148|0);
 HEAP32[$2>>2] = $exp_nspsytune;
 $$0 = 0;
 return ($$0|0);
}
function _lame_get_exp_nspsytune($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 148|0);
 $3 = HEAP32[$2>>2]|0;
 $$0 = $3;
 return ($$0|0);
}
function _lame_set_VBR($gfp,$VBR) {
 $gfp = $gfp|0;
 $VBR = $VBR|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $or$cond = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 $2 = ($VBR>>>0)>(4);
 $or$cond = $2 | $1;
 if ($or$cond) {
  $$0 = -1;
  return ($$0|0);
 }
 $3 = ((($gfp)) + 156|0);
 HEAP32[$3>>2] = $VBR;
 $$0 = 0;
 return ($$0|0);
}
function _lame_get_VBR($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 156|0);
 $3 = HEAP32[$2>>2]|0;
 $$0 = $3;
 return ($$0|0);
}
function _lame_set_VBR_q($gfp,$VBR_q) {
 $gfp = $gfp|0;
 $VBR_q = $VBR_q|0;
 var $$01 = 0, $$1 = 0, $$VBR_q = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $VBR_q$lobit = 0, $ret$1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$01 = -1;
  return ($$01|0);
 }
 $2 = ($VBR_q|0)<(0);
 $$VBR_q = $2 ? 0 : $VBR_q;
 $VBR_q$lobit = $VBR_q >> 31;
 $3 = ($$VBR_q|0)>(9);
 $$1 = $3 ? 9 : $$VBR_q;
 $ret$1 = $3 ? -1 : $VBR_q$lobit;
 $4 = ((($gfp)) + 164|0);
 HEAP32[$4>>2] = $$1;
 $5 = ((($gfp)) + 160|0);
 HEAPF32[$5>>2] = 0.0;
 $$01 = $ret$1;
 return ($$01|0);
}
function _lame_set_VBR_mean_bitrate_kbps($gfp,$VBR_mean_bitrate_kbps) {
 $gfp = $gfp|0;
 $VBR_mean_bitrate_kbps = $VBR_mean_bitrate_kbps|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 168|0);
 HEAP32[$2>>2] = $VBR_mean_bitrate_kbps;
 $$0 = 0;
 return ($$0|0);
}
function _lame_get_VBR_mean_bitrate_kbps($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 168|0);
 $3 = HEAP32[$2>>2]|0;
 $$0 = $3;
 return ($$0|0);
}
function _lame_set_maskingadjust($gfp,$adjust) {
 $gfp = $gfp|0;
 $adjust = +$adjust;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 200|0);
 HEAPF32[$2>>2] = $adjust;
 $$0 = 0;
 return ($$0|0);
}
function _lame_get_maskingadjust($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0.0, $0 = 0, $1 = 0, $2 = 0, $3 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0.0;
  return (+$$0);
 }
 $2 = ((($gfp)) + 200|0);
 $3 = +HEAPF32[$2>>2];
 $$0 = $3;
 return (+$$0);
}
function _lame_set_maskingadjust_short($gfp,$adjust) {
 $gfp = $gfp|0;
 $adjust = +$adjust;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 204|0);
 HEAPF32[$2>>2] = $adjust;
 $$0 = 0;
 return ($$0|0);
}
function _lame_get_maskingadjust_short($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0.0, $0 = 0, $1 = 0, $2 = 0, $3 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0.0;
  return (+$$0);
 }
 $2 = ((($gfp)) + 204|0);
 $3 = +HEAPF32[$2>>2];
 $$0 = $3;
 return (+$$0);
}
function _lame_set_ATHtype($gfp,$ATHtype) {
 $gfp = $gfp|0;
 $ATHtype = $ATHtype|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 220|0);
 HEAP32[$2>>2] = $ATHtype;
 $$0 = 0;
 return ($$0|0);
}
function _lame_set_ATHcurve($gfp,$ATHcurve) {
 $gfp = $gfp|0;
 $ATHcurve = +$ATHcurve;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 224|0);
 HEAPF32[$2>>2] = $ATHcurve;
 $$0 = 0;
 return ($$0|0);
}
function _lame_get_ATHcurve($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0.0, $0 = 0, $1 = 0, $2 = 0, $3 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0.0;
  return (+$$0);
 }
 $2 = ((($gfp)) + 224|0);
 $3 = +HEAPF32[$2>>2];
 $$0 = $3;
 return (+$$0);
}
function _lame_set_ATHlower($gfp,$ATHlower) {
 $gfp = $gfp|0;
 $ATHlower = +$ATHlower;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 228|0);
 HEAPF32[$2>>2] = $ATHlower;
 $$0 = 0;
 return ($$0|0);
}
function _lame_get_ATHlower($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0.0, $0 = 0, $1 = 0, $2 = 0, $3 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0.0;
  return (+$$0);
 }
 $2 = ((($gfp)) + 228|0);
 $3 = +HEAPF32[$2>>2];
 $$0 = $3;
 return (+$$0);
}
function _lame_set_athaa_sensitivity($gfp,$athaa_sensitivity) {
 $gfp = $gfp|0;
 $athaa_sensitivity = +$athaa_sensitivity;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 236|0);
 HEAPF32[$2>>2] = $athaa_sensitivity;
 $$0 = 0;
 return ($$0|0);
}
function _lame_get_athaa_sensitivity($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0.0, $0 = 0, $1 = 0, $2 = 0, $3 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0.0;
  return (+$$0);
 }
 $2 = ((($gfp)) + 236|0);
 $3 = +HEAPF32[$2>>2];
 $$0 = $3;
 return (+$$0);
}
function _lame_set_interChRatio($gfp,$ratio) {
 $gfp = $gfp|0;
 $ratio = +$ratio;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $notlhs = 0, $notrhs = 0, $or$cond$not = 0, $or$cond2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $notlhs = ($0|0)==(0);
 $notrhs = !($ratio >= 0.0);
 $or$cond$not = $notrhs | $notlhs;
 $1 = !($ratio <= 1.0);
 $or$cond2 = $1 | $or$cond$not;
 if ($or$cond2) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 248|0);
 HEAPF32[$2>>2] = $ratio;
 $$0 = 0;
 return ($$0|0);
}
function _lame_get_interChRatio($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0.0, $0 = 0, $1 = 0, $2 = 0, $3 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0.0;
  return (+$$0);
 }
 $2 = ((($gfp)) + 248|0);
 $3 = +HEAPF32[$2>>2];
 $$0 = $3;
 return (+$$0);
}
function _lame_set_sfscale($gfp,$val) {
 $gfp = $gfp|0;
 $val = $val|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ($val|0)!=(0);
 $3 = $2 ? 2 : 1;
 $4 = ((($gfp)) + 84|0);
 HEAP32[$4>>2] = $3;
 $$0 = 0;
 return ($$0|0);
}
function _lame_set_short_threshold_lrm($gfp,$lrm) {
 $gfp = $gfp|0;
 $lrm = +$lrm;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 264|0);
 HEAPF32[$2>>2] = $lrm;
 $$0 = 0;
 return ($$0|0);
}
function _lame_get_short_threshold_lrm($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0.0, $0 = 0, $1 = 0, $2 = 0, $3 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0.0;
  return (+$$0);
 }
 $2 = ((($gfp)) + 264|0);
 $3 = +HEAPF32[$2>>2];
 $$0 = $3;
 return (+$$0);
}
function _lame_set_short_threshold_s($gfp,$s) {
 $gfp = $gfp|0;
 $s = +$s;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = -1;
  return ($$0|0);
 }
 $2 = ((($gfp)) + 268|0);
 HEAPF32[$2>>2] = $s;
 $$0 = 0;
 return ($$0|0);
}
function _lame_get_short_threshold_s($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0.0, $0 = 0, $1 = 0, $2 = 0, $3 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0.0;
  return (+$$0);
 }
 $2 = ((($gfp)) + 268|0);
 $3 = +HEAPF32[$2>>2];
 $$0 = $3;
 return (+$$0);
}
function _lame_set_msfix($gfp,$msfix) {
 $gfp = $gfp|0;
 $msfix = +$msfix;
 var $0 = 0, $1 = 0, $2 = 0.0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  return;
 }
 $2 = $msfix;
 $3 = ((($gfp)) + 252|0);
 HEAPF32[$3>>2] = $2;
 return;
}
function _lame_get_msfix($gfp) {
 $gfp = $gfp|0;
 var $$0 = 0.0, $0 = 0, $1 = 0, $2 = 0, $3 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_is_lame_global_flags_valid($gfp)|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $$0 = 0.0;
  return (+$$0);
 }
 $2 = ((($gfp)) + 252|0);
 $3 = +HEAPF32[$2>>2];
 $$0 = $3;
 return (+$$0);
}
function _noquant_count_bits($gfc,$gi,$prev_noise) {
 $gfc = $gfc|0;
 $gi = $gi|0;
 $prev_noise = $prev_noise|0;
 var $$ = 0, $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0;
 var $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0;
 var $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0;
 var $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0;
 var $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0;
 var $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0;
 var $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $a1$0$lcssa = 0, $a1$04 = 0, $a1$2 = 0, $a2$0$lcssa = 0, $a2$03 = 0, $a2$1 = 0, $bits = 0, $i$0 = 0, $i$0$lcssa = 0, $i$0$lcssa24 = 0, $i$025 = 0, $i$1$ = 0, $i$1$1 = 0, $i$1$lcssa = 0;
 var $i$1$lcssa17 = 0, $i$15 = 0, $sfb$0 = 0, $sfb$0$lcssa = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $bits = sp;
 HEAP32[$bits>>2] = 0;
 $0 = ((($gi)) + 2304|0);
 $1 = ((($gi)) + 5208|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = (($2) + 2)|0;
 $4 = $3 & -2;
 $5 = ($4|0)>(576);
 $$ = $5 ? 576 : $4;
 $6 = ($prev_noise|0)!=(0|0);
 if ($6) {
  $7 = ((($prev_noise)) + 4|0);
  HEAP32[$7>>2] = 0;
  $i$0 = $$;
 } else {
  $i$0 = $$;
 }
 while(1) {
  $8 = ($i$0|0)>(1);
  if (!($8)) {
   $i$0$lcssa = $i$0;
   label = 4;
   break;
  }
  $10 = (($i$0) + -1)|0;
  $11 = (((($gi)) + 2304|0) + ($10<<2)|0);
  $12 = HEAP32[$11>>2]|0;
  $13 = (($i$0) + -2)|0;
  $14 = (((($gi)) + 2304|0) + ($13<<2)|0);
  $15 = HEAP32[$14>>2]|0;
  $16 = $15 | $12;
  $17 = ($16|0)==(0);
  if ($17) {
   $i$0 = $13;
  } else {
   $i$0$lcssa24 = $i$0;
   label = 6;
   break;
  }
 }
 if ((label|0) == 4) {
  $9 = ((($gi)) + 4776|0);
  HEAP32[$9>>2] = $i$0$lcssa;
  $i$025 = $i$0$lcssa;
  label = 9;
 }
 else if ((label|0) == 6) {
  $18 = ((($gi)) + 4776|0);
  HEAP32[$18>>2] = $i$0$lcssa24;
  $19 = ($i$0$lcssa24|0)>(3);
  if ($19) {
   $a1$04 = 0;$a2$03 = 0;$i$15 = $i$0$lcssa24;
   while(1) {
    $20 = (($i$15) + -4)|0;
    $21 = (((($gi)) + 2304|0) + ($20<<2)|0);
    $22 = HEAP32[$21>>2]|0;
    $23 = (($i$15) + -3)|0;
    $24 = (((($gi)) + 2304|0) + ($23<<2)|0);
    $25 = HEAP32[$24>>2]|0;
    $26 = (($i$15) + -2)|0;
    $27 = (((($gi)) + 2304|0) + ($26<<2)|0);
    $28 = HEAP32[$27>>2]|0;
    $29 = (($i$15) + -1)|0;
    $30 = (((($gi)) + 2304|0) + ($29<<2)|0);
    $31 = HEAP32[$30>>2]|0;
    $32 = $25 | $22;
    $33 = $32 | $28;
    $34 = $33 | $31;
    $35 = ($34>>>0)>(1);
    if ($35) {
     $a1$0$lcssa = $a1$04;$a2$0$lcssa = $a2$03;$i$1$lcssa = $i$15;
     break;
    }
    $36 = $22 << 1;
    $37 = (($36) + ($25))|0;
    $38 = $37 << 1;
    $39 = (($38) + ($28))|0;
    $40 = $39 << 1;
    $41 = (($40) + ($31))|0;
    $42 = (82240 + ($41)|0);
    $43 = HEAP8[$42>>0]|0;
    $44 = $43&255;
    $45 = (($44) + ($a1$04))|0;
    $46 = (82256 + ($41)|0);
    $47 = HEAP8[$46>>0]|0;
    $48 = $47&255;
    $49 = (($48) + ($a2$03))|0;
    $50 = ($20|0)>(3);
    if ($50) {
     $a1$04 = $45;$a2$03 = $49;$i$15 = $20;
    } else {
     $a1$0$lcssa = $45;$a2$0$lcssa = $49;$i$1$lcssa = $20;
     break;
    }
   }
   HEAP32[$bits>>2] = $a1$0$lcssa;
   $52 = ((($gi)) + 4840|0);
   HEAP32[$52>>2] = 0;
   $53 = ($a1$0$lcssa|0)>($a2$0$lcssa|0);
   if ($53) {
    HEAP32[$bits>>2] = $a2$0$lcssa;
    HEAP32[$52>>2] = 1;
    $55 = $a2$0$lcssa;$i$1$lcssa17 = $i$1$lcssa;
   } else {
    $55 = $a1$0$lcssa;$i$1$lcssa17 = $i$1$lcssa;
   }
  } else {
   $i$025 = $i$0$lcssa24;
   label = 9;
  }
 }
 if ((label|0) == 9) {
  HEAP32[$bits>>2] = 0;
  $51 = ((($gi)) + 4840|0);
  HEAP32[$51>>2] = 0;
  $55 = 0;$i$1$lcssa17 = $i$025;
 }
 $54 = ((($gi)) + 5184|0);
 HEAP32[$54>>2] = $55;
 $56 = ((($gi)) + 4772|0);
 HEAP32[$56>>2] = $i$1$lcssa17;
 $57 = ($i$1$lcssa17|0)==(0);
 if ($57) {
  $$0 = HEAP32[$bits>>2]|0;
  STACKTOP = sp;return ($$0|0);
 }
 $58 = ((($gi)) + 4788|0);
 $59 = HEAP32[$58>>2]|0;
 if ((($59|0) == 2)) {
  $60 = ((($gfc)) + 21464|0);
  $61 = HEAP32[$60>>2]|0;
  $62 = ($61*3)|0;
  $63 = ($62|0)>($i$1$lcssa17|0);
  $i$1$ = $63 ? $i$1$lcssa17 : $62;
  $a1$2 = $i$1$;$a2$1 = $i$1$lcssa17;
 } else if ((($59|0) == 0)) {
  $64 = (($i$1$lcssa17) + -2)|0;
  $65 = (((($gfc)) + 85100|0) + ($64)|0);
  $66 = HEAP8[$65>>0]|0;
  $67 = $66 << 24 >> 24;
  $68 = ((($gi)) + 4824|0);
  HEAP32[$68>>2] = $67;
  $69 = (($i$1$lcssa17) + -1)|0;
  $70 = (((($gfc)) + 85100|0) + ($69)|0);
  $71 = HEAP8[$70>>0]|0;
  $72 = $71 << 24 >> 24;
  $73 = ((($gi)) + 4828|0);
  HEAP32[$73>>2] = $72;
  $74 = (($67) + 2)|0;
  $75 = (($74) + ($72))|0;
  $76 = (((($gfc)) + 21360|0) + ($75<<2)|0);
  $77 = HEAP32[$76>>2]|0;
  $78 = (($67) + 1)|0;
  $79 = (((($gfc)) + 21360|0) + ($78<<2)|0);
  $80 = HEAP32[$79>>2]|0;
  $81 = ($77|0)<($i$1$lcssa17|0);
  if ($81) {
   $82 = ((($gfc)) + 85816|0);
   $83 = HEAP32[$82>>2]|0;
   $84 = (((($gi)) + 2304|0) + ($77<<2)|0);
   $85 = (((($gi)) + 2304|0) + ($i$1$lcssa17<<2)|0);
   $86 = (FUNCTION_TABLE_iiii[$83 & 3]($84,$85,$bits)|0);
   $87 = ((($gi)) + 4804|0);
   HEAP32[$87>>2] = $86;
   $a1$2 = $80;$a2$1 = $77;
  } else {
   $a1$2 = $80;$a2$1 = $77;
  }
 } else {
  $88 = ((($gi)) + 4824|0);
  HEAP32[$88>>2] = 7;
  $89 = ((($gi)) + 4828|0);
  HEAP32[$89>>2] = 13;
  $90 = ((($gfc)) + 21392|0);
  $91 = HEAP32[$90>>2]|0;
  $92 = ($91|0)>($i$1$lcssa17|0);
  $i$1$1 = $92 ? $i$1$lcssa17 : $91;
  $a1$2 = $i$1$1;$a2$1 = $i$1$lcssa17;
 }
 $93 = ($a1$2|0)<($i$1$lcssa17|0);
 $94 = $93 ? $a1$2 : $i$1$lcssa17;
 $95 = ($a2$1|0)<($i$1$lcssa17|0);
 $96 = $95 ? $a2$1 : $i$1$lcssa17;
 $97 = ($94|0)>(0);
 if ($97) {
  $98 = ((($gfc)) + 85816|0);
  $99 = HEAP32[$98>>2]|0;
  $100 = (((($gi)) + 2304|0) + ($94<<2)|0);
  $101 = (FUNCTION_TABLE_iiii[$99 & 3]($0,$100,$bits)|0);
  $102 = ((($gi)) + 4796|0);
  HEAP32[$102>>2] = $101;
 }
 $103 = ($94|0)<($96|0);
 if ($103) {
  $104 = ((($gfc)) + 85816|0);
  $105 = HEAP32[$104>>2]|0;
  $106 = (((($gi)) + 2304|0) + ($94<<2)|0);
  $107 = (((($gi)) + 2304|0) + ($96<<2)|0);
  $108 = (FUNCTION_TABLE_iiii[$105 & 3]($106,$107,$bits)|0);
  $109 = ((($gi)) + 4800|0);
  HEAP32[$109>>2] = $108;
 }
 $110 = ((($gfc)) + 36|0);
 $111 = HEAP32[$110>>2]|0;
 $112 = ($111|0)==(2);
 if ($112) {
  $113 = HEAP32[$bits>>2]|0;
  $114 = ((($gi)) + 4768|0);
  HEAP32[$114>>2] = $113;
  _best_huffman_divide($gfc,$gi);
  $115 = HEAP32[$114>>2]|0;
  HEAP32[$bits>>2] = $115;
 }
 if (!($6)) {
  $$0 = HEAP32[$bits>>2]|0;
  STACKTOP = sp;return ($$0|0);
 }
 $116 = HEAP32[$58>>2]|0;
 $117 = ($116|0)==(0);
 if (!($117)) {
  $$0 = HEAP32[$bits>>2]|0;
  STACKTOP = sp;return ($$0|0);
 }
 $118 = HEAP32[$56>>2]|0;
 $sfb$0 = 0;
 while(1) {
  $119 = (((($gfc)) + 21360|0) + ($sfb$0<<2)|0);
  $120 = HEAP32[$119>>2]|0;
  $121 = ($120|0)<($118|0);
  $122 = (($sfb$0) + 1)|0;
  if ($121) {
   $sfb$0 = $122;
  } else {
   $sfb$0$lcssa = $sfb$0;
   break;
  }
 }
 $123 = ((($prev_noise)) + 4|0);
 HEAP32[$123>>2] = $sfb$0$lcssa;
 $$0 = HEAP32[$bits>>2]|0;
 STACKTOP = sp;return ($$0|0);
}
function _best_huffman_divide($gfc,$gi) {
 $gfc = $gfc|0;
 $gi = $gi|0;
 var $$ = 0, $$lcssa = 0, $$lcssa16 = 0, $$pre = 0, $$pre$phiZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0;
 var $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0;
 var $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0;
 var $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0;
 var $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0;
 var $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0;
 var $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0;
 var $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0;
 var $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0;
 var $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0;
 var $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $a1$0$lcssa = 0, $a1$06 = 0, $a2$0$a1$0 = 0, $a2$0$lcssa = 0, $a2$05 = 0, $bits$i2 = 0, $cod_info2 = 0;
 var $gi$idx = 0, $gi$idx$val = 0, $i$0$ = 0, $i$07 = 0, $r0$12$i = 0, $r01_bits = 0, $r01_div = 0, $r0_tbl = 0, $r0bits$i = 0, $r1$01$i = 0, $r1_tbl = 0, $r2$01$i = 0, $r2$01$i3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 5632|0;
 $bits$i2 = sp + 5624|0;
 $r0bits$i = sp + 5620|0;
 $cod_info2 = sp + 368|0;
 $r01_bits = sp + 276|0;
 $r01_div = sp + 184|0;
 $r0_tbl = sp + 92|0;
 $r1_tbl = sp;
 $0 = ((($gi)) + 2304|0);
 $1 = ((($gi)) + 4788|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = ($2|0)==(2);
 do {
  if ($3) {
   $4 = ((($gfc)) + 76|0);
   $5 = HEAP32[$4>>2]|0;
   $6 = ($5|0)==(1);
   if ($6) {
    STACKTOP = sp;return;
   } else {
    _memcpy(($cod_info2|0),($gi|0),5252)|0;
    $207 = $gi;
    label = 5;
    break;
   }
  } else {
   _memcpy(($cod_info2|0),($gi|0),5252)|0;
   $7 = ($2|0)==(0);
   if ($7) {
    $gi$idx = ((($gi)) + 4772|0);
    $gi$idx$val = HEAP32[$gi$idx>>2]|0;
    HEAP32[$r01_bits>>2] = 100000;
    $8 = ((($r01_bits)) + 4|0);
    HEAP32[$8>>2] = 100000;
    $9 = ((($r01_bits)) + 8|0);
    HEAP32[$9>>2] = 100000;
    $10 = ((($r01_bits)) + 12|0);
    HEAP32[$10>>2] = 100000;
    $11 = ((($r01_bits)) + 16|0);
    HEAP32[$11>>2] = 100000;
    $12 = ((($r01_bits)) + 20|0);
    HEAP32[$12>>2] = 100000;
    $13 = ((($r01_bits)) + 24|0);
    HEAP32[$13>>2] = 100000;
    $14 = ((($r01_bits)) + 28|0);
    HEAP32[$14>>2] = 100000;
    $15 = ((($r01_bits)) + 32|0);
    HEAP32[$15>>2] = 100000;
    $16 = ((($r01_bits)) + 36|0);
    HEAP32[$16>>2] = 100000;
    $17 = ((($r01_bits)) + 40|0);
    HEAP32[$17>>2] = 100000;
    $18 = ((($r01_bits)) + 44|0);
    HEAP32[$18>>2] = 100000;
    $19 = ((($r01_bits)) + 48|0);
    HEAP32[$19>>2] = 100000;
    $20 = ((($r01_bits)) + 52|0);
    HEAP32[$20>>2] = 100000;
    $21 = ((($r01_bits)) + 56|0);
    HEAP32[$21>>2] = 100000;
    $22 = ((($r01_bits)) + 60|0);
    HEAP32[$22>>2] = 100000;
    $23 = ((($r01_bits)) + 64|0);
    HEAP32[$23>>2] = 100000;
    $24 = ((($r01_bits)) + 68|0);
    HEAP32[$24>>2] = 100000;
    $25 = ((($r01_bits)) + 72|0);
    HEAP32[$25>>2] = 100000;
    $26 = ((($r01_bits)) + 76|0);
    HEAP32[$26>>2] = 100000;
    $27 = ((($r01_bits)) + 80|0);
    HEAP32[$27>>2] = 100000;
    $28 = ((($r01_bits)) + 84|0);
    HEAP32[$28>>2] = 100000;
    $29 = ((($r01_bits)) + 88|0);
    HEAP32[$29>>2] = 100000;
    $30 = ((($gfc)) + 85816|0);
    $r0$12$i = 0;
    while(1) {
     $31 = (($r0$12$i) + 1)|0;
     $33 = (((($gfc)) + 21360|0) + ($31<<2)|0);
     $34 = HEAP32[$33>>2]|0;
     $35 = ($34|0)<($gi$idx$val|0);
     if (!($35)) {
      break;
     }
     HEAP32[$r0bits$i>>2] = 0;
     $36 = HEAP32[$30>>2]|0;
     $37 = (((($gi)) + 2304|0) + ($34<<2)|0);
     $38 = (FUNCTION_TABLE_iiii[$36 & 3]($0,$37,$r0bits$i)|0);
     $r1$01$i = 0;
     while(1) {
      $39 = (($r1$01$i) + ($r0$12$i))|0;
      $40 = (($39) + 2)|0;
      $41 = (((($gfc)) + 21360|0) + ($40<<2)|0);
      $42 = HEAP32[$41>>2]|0;
      $43 = ($42|0)<($gi$idx$val|0);
      if (!($43)) {
       break;
      }
      $44 = HEAP32[$r0bits$i>>2]|0;
      HEAP32[$bits$i2>>2] = $44;
      $45 = HEAP32[$30>>2]|0;
      $46 = (((($gi)) + 2304|0) + ($42<<2)|0);
      $47 = (FUNCTION_TABLE_iiii[$45 & 3]($37,$46,$bits$i2)|0);
      $48 = (($r01_bits) + ($39<<2)|0);
      $49 = HEAP32[$48>>2]|0;
      $50 = HEAP32[$bits$i2>>2]|0;
      $51 = ($49|0)>($50|0);
      if ($51) {
       HEAP32[$48>>2] = $50;
       $52 = (($r01_div) + ($39<<2)|0);
       HEAP32[$52>>2] = $r0$12$i;
       $53 = (($r0_tbl) + ($39<<2)|0);
       HEAP32[$53>>2] = $38;
       $54 = (($r1_tbl) + ($39<<2)|0);
       HEAP32[$54>>2] = $47;
      }
      $55 = (($r1$01$i) + 1)|0;
      $56 = ($55|0)<(8);
      if ($56) {
       $r1$01$i = $55;
      } else {
       break;
      }
     }
     $32 = ($31|0)<(16);
     if ($32) {
      $r0$12$i = $31;
     } else {
      break;
     }
    }
    $57 = ((($cod_info2)) + 4772|0);
    $58 = HEAP32[$57>>2]|0;
    $59 = ((($cod_info2)) + 5184|0);
    $60 = ((($gi)) + 4768|0);
    $61 = (((($gi)) + 2304|0) + ($58<<2)|0);
    $62 = ((($gi)) + 4824|0);
    $63 = ((($gi)) + 4828|0);
    $64 = ((($gi)) + 4796|0);
    $65 = ((($gi)) + 4800|0);
    $66 = ((($gi)) + 4804|0);
    $r2$01$i = 2;
    while(1) {
     $67 = (((($gfc)) + 21360|0) + ($r2$01$i<<2)|0);
     $68 = HEAP32[$67>>2]|0;
     $69 = ($68|0)<($58|0);
     if (!($69)) {
      break;
     }
     $70 = (($r2$01$i) + -2)|0;
     $71 = (($r01_bits) + ($70<<2)|0);
     $72 = HEAP32[$71>>2]|0;
     $73 = HEAP32[$59>>2]|0;
     $74 = (($73) + ($72))|0;
     HEAP32[$bits$i2>>2] = $74;
     $75 = HEAP32[$60>>2]|0;
     $76 = ($75|0)>($74|0);
     if (!($76)) {
      break;
     }
     $77 = HEAP32[$30>>2]|0;
     $78 = (((($gi)) + 2304|0) + ($68<<2)|0);
     $79 = (FUNCTION_TABLE_iiii[$77 & 3]($78,$61,$bits$i2)|0);
     $80 = HEAP32[$60>>2]|0;
     $81 = HEAP32[$bits$i2>>2]|0;
     $82 = ($80|0)>($81|0);
     if ($82) {
      _memcpy(($gi|0),($cod_info2|0),5252)|0;
      HEAP32[$60>>2] = $81;
      $83 = (($r01_div) + ($70<<2)|0);
      $84 = HEAP32[$83>>2]|0;
      HEAP32[$62>>2] = $84;
      $85 = (($70) - ($84))|0;
      HEAP32[$63>>2] = $85;
      $86 = (($r0_tbl) + ($70<<2)|0);
      $87 = HEAP32[$86>>2]|0;
      HEAP32[$64>>2] = $87;
      $88 = (($r1_tbl) + ($70<<2)|0);
      $89 = HEAP32[$88>>2]|0;
      HEAP32[$65>>2] = $89;
      HEAP32[$66>>2] = $79;
     }
     $90 = (($r2$01$i) + 1)|0;
     $91 = ($90|0)<(23);
     if ($91) {
      $r2$01$i = $90;
     } else {
      break;
     }
    }
    $$pre$phiZ2D = $57;$106 = $gi;
   } else {
    $207 = $gi;
    label = 5;
   }
  }
 } while(0);
 if ((label|0) == 5) {
  $$pre = ((($cod_info2)) + 4772|0);
  $$pre$phiZ2D = $$pre;$106 = $207;
 }
 $92 = HEAP32[$$pre$phiZ2D>>2]|0;
 $93 = ($92|0)==(0);
 if ($93) {
  STACKTOP = sp;return;
 }
 $94 = (($92) + -2)|0;
 $95 = (((($gi)) + 2304|0) + ($94<<2)|0);
 $96 = HEAP32[$95>>2]|0;
 $97 = (($92) + -1)|0;
 $98 = (((($gi)) + 2304|0) + ($97<<2)|0);
 $99 = HEAP32[$98>>2]|0;
 $100 = $99 | $96;
 $101 = ($100>>>0)>(1);
 if ($101) {
  STACKTOP = sp;return;
 }
 $102 = ((($gi)) + 4776|0);
 $103 = HEAP32[$102>>2]|0;
 $104 = (($103) + 2)|0;
 $105 = ($104|0)>(576);
 if ($105) {
  STACKTOP = sp;return;
 }
 _memcpy(($cod_info2|0),($106|0),5252)|0;
 $107 = ((($cod_info2)) + 4776|0);
 HEAP32[$107>>2] = $104;
 $108 = HEAP32[$$pre$phiZ2D>>2]|0;
 $109 = ($104|0)>($108|0);
 if ($109) {
  $110 = (($103) + -2)|0;
  $111 = ($108|0)>($110|0);
  $112 = $111 ? $110 : $108;
  $113 = $112 ^ -1;
  $114 = (($103) + ($113))|0;
  $115 = (($114) + 2)|0;
  $116 = $115 & -4;
  $a1$06 = 0;$a2$05 = 0;$i$07 = $104;
  while(1) {
   $117 = (($i$07) + -4)|0;
   $118 = (((($gi)) + 2304|0) + ($117<<2)|0);
   $119 = HEAP32[$118>>2]|0;
   $120 = $119 << 1;
   $121 = (($i$07) + -3)|0;
   $122 = (((($gi)) + 2304|0) + ($121<<2)|0);
   $123 = HEAP32[$122>>2]|0;
   $124 = (($120) + ($123))|0;
   $125 = $124 << 1;
   $126 = (($i$07) + -2)|0;
   $127 = (((($gi)) + 2304|0) + ($126<<2)|0);
   $128 = HEAP32[$127>>2]|0;
   $129 = (($125) + ($128))|0;
   $130 = $129 << 1;
   $131 = (($i$07) + -1)|0;
   $132 = (((($gi)) + 2304|0) + ($131<<2)|0);
   $133 = HEAP32[$132>>2]|0;
   $134 = (($130) + ($133))|0;
   $135 = (82240 + ($134)|0);
   $136 = HEAP8[$135>>0]|0;
   $137 = $136&255;
   $138 = (($137) + ($a1$06))|0;
   $139 = (82256 + ($134)|0);
   $140 = HEAP8[$139>>0]|0;
   $141 = $140&255;
   $142 = (($141) + ($a2$05))|0;
   $143 = ($117|0)>($108|0);
   if ($143) {
    $a1$06 = $138;$a2$05 = $142;$i$07 = $117;
   } else {
    $$lcssa = $138;$$lcssa16 = $142;
    break;
   }
  }
  $144 = (($103) + -2)|0;
  $145 = (($144) - ($116))|0;
  $146 = $145;$a1$0$lcssa = $$lcssa;$a2$0$lcssa = $$lcssa16;
 } else {
  $146 = $104;$a1$0$lcssa = 0;$a2$0$lcssa = 0;
 }
 HEAP32[$$pre$phiZ2D>>2] = $146;
 $147 = ((($cod_info2)) + 4840|0);
 $148 = ($a1$0$lcssa|0)>($a2$0$lcssa|0);
 $$ = $148&1;
 $a2$0$a1$0 = $148 ? $a2$0$lcssa : $a1$0$lcssa;
 HEAP32[$147>>2] = $$;
 $149 = ((($cod_info2)) + 5184|0);
 HEAP32[$149>>2] = $a2$0$a1$0;
 $150 = ((($cod_info2)) + 4788|0);
 $151 = HEAP32[$150>>2]|0;
 $152 = ($151|0)==(0);
 if ($152) {
  $153 = ((($gi)) + 4768|0);
  $154 = ((($gfc)) + 85816|0);
  $155 = (((($gi)) + 2304|0) + ($146<<2)|0);
  $156 = ((($gi)) + 4824|0);
  $157 = ((($gi)) + 4828|0);
  $158 = ((($gi)) + 4796|0);
  $159 = ((($gi)) + 4800|0);
  $160 = ((($gi)) + 4804|0);
  $r2$01$i3 = 2;
  while(1) {
   $161 = (((($gfc)) + 21360|0) + ($r2$01$i3<<2)|0);
   $162 = HEAP32[$161>>2]|0;
   $163 = ($162|0)<($146|0);
   if (!($163)) {
    break;
   }
   $164 = (($r2$01$i3) + -2)|0;
   $165 = (($r01_bits) + ($164<<2)|0);
   $166 = HEAP32[$165>>2]|0;
   $167 = HEAP32[$149>>2]|0;
   $168 = (($167) + ($166))|0;
   HEAP32[$bits$i2>>2] = $168;
   $169 = HEAP32[$153>>2]|0;
   $170 = ($169|0)>($168|0);
   if (!($170)) {
    break;
   }
   $171 = HEAP32[$154>>2]|0;
   $172 = (((($gi)) + 2304|0) + ($162<<2)|0);
   $173 = (FUNCTION_TABLE_iiii[$171 & 3]($172,$155,$bits$i2)|0);
   $174 = HEAP32[$153>>2]|0;
   $175 = HEAP32[$bits$i2>>2]|0;
   $176 = ($174|0)>($175|0);
   if ($176) {
    _memcpy(($106|0),($cod_info2|0),5252)|0;
    HEAP32[$153>>2] = $175;
    $177 = (($r01_div) + ($164<<2)|0);
    $178 = HEAP32[$177>>2]|0;
    HEAP32[$156>>2] = $178;
    $179 = (($164) - ($178))|0;
    HEAP32[$157>>2] = $179;
    $180 = (($r0_tbl) + ($164<<2)|0);
    $181 = HEAP32[$180>>2]|0;
    HEAP32[$158>>2] = $181;
    $182 = (($r1_tbl) + ($164<<2)|0);
    $183 = HEAP32[$182>>2]|0;
    HEAP32[$159>>2] = $183;
    HEAP32[$160>>2] = $173;
   }
   $184 = (($r2$01$i3) + 1)|0;
   $185 = ($184|0)<(23);
   if ($185) {
    $r2$01$i3 = $184;
   } else {
    break;
   }
  }
  STACKTOP = sp;return;
 } else {
  $186 = ((($cod_info2)) + 4768|0);
  HEAP32[$186>>2] = $a2$0$a1$0;
  $187 = ((($gfc)) + 21392|0);
  $188 = HEAP32[$187>>2]|0;
  $189 = ($188|0)>($146|0);
  $i$0$ = $189 ? $146 : $188;
  $190 = ($i$0$|0)>(0);
  if ($190) {
   $191 = ((($gfc)) + 85816|0);
   $192 = HEAP32[$191>>2]|0;
   $193 = (((($gi)) + 2304|0) + ($i$0$<<2)|0);
   $194 = (FUNCTION_TABLE_iiii[$192 & 3]($0,$193,$186)|0);
   $195 = ((($cod_info2)) + 4796|0);
   HEAP32[$195>>2] = $194;
  }
  $196 = ($146|0)>($i$0$|0);
  if ($196) {
   $197 = ((($gfc)) + 85816|0);
   $198 = HEAP32[$197>>2]|0;
   $199 = (((($gi)) + 2304|0) + ($i$0$<<2)|0);
   $200 = (((($gi)) + 2304|0) + ($146<<2)|0);
   $201 = (FUNCTION_TABLE_iiii[$198 & 3]($199,$200,$186)|0);
   $202 = ((($cod_info2)) + 4800|0);
   HEAP32[$202>>2] = $201;
  }
  $203 = ((($gi)) + 4768|0);
  $204 = HEAP32[$203>>2]|0;
  $205 = HEAP32[$186>>2]|0;
  $206 = ($204|0)>($205|0);
  if (!($206)) {
   STACKTOP = sp;return;
  }
  _memcpy(($106|0),($cod_info2|0),5252)|0;
  STACKTOP = sp;return;
 }
}
function _count_bits($gfc,$xr,$gi,$prev_noise) {
 $gfc = $gfc|0;
 $xr = $xr|0;
 $gi = $gi|0;
 $prev_noise = $prev_noise|0;
 var $$$i = 0, $$0 = 0, $$0$acc_xp$0$i = 0, $$041$i = 0, $$1$i = 0, $$2$i = 0, $$pre$pre = 0, $$pre7 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0;
 var $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0.0, $119 = 0, $12 = 0, $120 = 0, $121 = 0.0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0;
 var $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0.0, $137 = 0.0, $138 = 0.0, $139 = 0.0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0;
 var $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0.0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0;
 var $17 = 0.0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0.0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0;
 var $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0.0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0.0, $49 = 0, $5 = 0, $50 = 0, $51 = 0.0, $52 = 0;
 var $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0.0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0;
 var $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0.0, $83 = 0, $84 = 0, $85 = 0.0, $86 = 0, $87 = 0, $88 = 0, $89 = 0;
 var $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0.0, $97 = 0, $98 = 0, $99 = 0.0, $acc_iData$037$i = 0, $acc_iData$2$i = 0, $acc_iData$3$i = 0, $acc_iData$4$i = 0, $acc_iData$4$i$lcssa = 0, $acc_iData$5$i = 0, $acc_iData$5$i$lcssa = 0, $acc_xp$039$i = 0, $acc_xp$2$i = 0;
 var $acc_xp$3$i = 0, $acc_xp$4$i = 0, $acc_xp$4$i$lcssa = 0, $acc_xp$5$i = 0, $acc_xp$5$i$lcssa = 0, $accumulate$035$i = 0, $accumulate$3$i = 0, $accumulate$3$i$lcssa = 0, $accumulate$4$i = 0, $accumulate$4$i$lcssa = 0, $accumulate01$036$i = 0, $accumulate01$2$i = 0, $accumulate01$2$i$lcssa = 0, $accumulate01$4$i = 0, $accumulate01$4$i$lcssa = 0, $i$02$i$i = 0, $i$02$i14$i = 0, $i$02$i4$i = 0, $i$02$i9$i = 0, $iData$0$acc_iData$0$i = 0;
 var $iData$031$i = 0, $iData$1$i = 0, $j$028$i = 0, $j$03 = 0, $j$1$i = 0, $k$02 = 0, $l$0$i = 0, $not$$i$i = 0, $not$$i10$i = 0, $not$$i15$i = 0, $not$$i5$i = 0, $not$1$i$i = 0, $not$1$i11$i = 0, $not$1$i16$i = 0, $not$1$i6$i = 0, $or$cond = 0, $or$cond$i = 0, $or$cond3$i = 0, $sfb$029$i = 0, $sfb$04 = 0;
 var $sfb$1$i = 0, $sfb$2$i = 0, $step$019$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gi)) + 4780|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = (79704 + ($1<<2)|0);
 $3 = +HEAPF32[$2>>2];
 $4 = 8206.0 / $3;
 $5 = ((($gi)) + 4764|0);
 $6 = +HEAPF32[$5>>2];
 $7 = $6 > $4;
 if ($7) {
  $$0 = 100000;
  return ($$0|0);
 }
 $8 = ((($gi)) + 2304|0);
 $9 = ($prev_noise|0)!=(0|0);
 if ($9) {
  $10 = HEAP32[$prev_noise>>2]|0;
  $11 = ($1|0)==($10|0);
  $161 = $11;
 } else {
  $161 = 0;
 }
 $12 = ((($gi)) + 4788|0);
 $13 = HEAP32[$12>>2]|0;
 $14 = ($13|0)==(2);
 $$2$i = $14 ? 38 : 21;
 $15 = ((($gi)) + 4832|0);
 $16 = ((($gi)) + 4836|0);
 $17 = 0.59459996223449707 / $3;
 $18 = ((($gi)) + 5208|0);
 $19 = (($$2$i) + 1)|0;
 $20 = ((($prev_noise)) + 4|0);
 $$041$i = $xr;$acc_iData$037$i = $8;$acc_xp$039$i = $xr;$accumulate$035$i = 0;$accumulate01$036$i = 0;$iData$031$i = $8;$j$028$i = 0;$sfb$029$i = 0;
 while(1) {
  if ($161) {
   label = 7;
  } else {
   $21 = HEAP32[$12>>2]|0;
   $22 = ($21|0)==(0);
   if ($22) {
    label = 7;
   } else {
    $step$019$i = -1;
    label = 15;
   }
  }
  if ((label|0) == 7) {
   label = 0;
   $23 = HEAP32[$0>>2]|0;
   $24 = (((($gi)) + 4608|0) + ($sfb$029$i<<2)|0);
   $25 = HEAP32[$24>>2]|0;
   $26 = HEAP32[$15>>2]|0;
   $27 = ($26|0)==(0);
   if ($27) {
    $31 = 0;
   } else {
    $28 = (12112 + ($sfb$029$i<<2)|0);
    $29 = HEAP32[$28>>2]|0;
    $31 = $29;
   }
   $30 = (($31) + ($25))|0;
   $32 = HEAP32[$16>>2]|0;
   $33 = (($32) + 1)|0;
   $34 = $30 << $33;
   $35 = (($23) - ($34))|0;
   $36 = (((($gi)) + 5028|0) + ($sfb$029$i<<2)|0);
   $37 = HEAP32[$36>>2]|0;
   $38 = (((($gi)) + 4808|0) + ($37<<2)|0);
   $39 = HEAP32[$38>>2]|0;
   $40 = $39 << 3;
   $41 = (($35) - ($40))|0;
   if ($161) {
    $42 = (((($prev_noise)) + 8|0) + ($sfb$029$i<<2)|0);
    $43 = HEAP32[$42>>2]|0;
    $44 = ($43|0)==($41|0);
    if ($44) {
     $45 = ($accumulate$035$i|0)==(0);
     if (!($45)) {
      _quantize_lines_xrpow($accumulate$035$i,$3,$acc_xp$039$i,$acc_iData$037$i);
     }
     $46 = ($accumulate01$036$i|0)==(0);
     if ($46) {
      $acc_iData$5$i = $acc_iData$037$i;$acc_xp$5$i = $acc_xp$039$i;$accumulate$4$i = 0;$accumulate01$4$i = 0;$sfb$2$i = $sfb$029$i;
     } else {
      $i$02$i$i = 0;
      while(1) {
       $47 = (($acc_xp$039$i) + ($i$02$i$i<<2)|0);
       $48 = +HEAPF32[$47>>2];
       $49 = $i$02$i$i | 1;
       $50 = (($acc_xp$039$i) + ($49<<2)|0);
       $51 = +HEAPF32[$50>>2];
       $not$$i$i = !($17 > $48);
       $52 = $not$$i$i&1;
       $not$1$i$i = !($17 > $51);
       $53 = $not$1$i$i&1;
       $54 = (($acc_iData$037$i) + ($i$02$i$i<<2)|0);
       HEAP32[$54>>2] = $52;
       $55 = (($acc_iData$037$i) + ($49<<2)|0);
       HEAP32[$55>>2] = $53;
       $56 = (($i$02$i$i) + 2)|0;
       $57 = ($56>>>0)<($accumulate01$036$i>>>0);
       if ($57) {
        $i$02$i$i = $56;
       } else {
        $acc_iData$5$i = $acc_iData$037$i;$acc_xp$5$i = $acc_xp$039$i;$accumulate$4$i = 0;$accumulate01$4$i = 0;$sfb$2$i = $sfb$029$i;
        break;
       }
      }
     }
    } else {
     $step$019$i = $41;
     label = 15;
    }
   } else {
    $step$019$i = $41;
    label = 15;
   }
  }
  if ((label|0) == 15) {
   label = 0;
   $58 = (((($gi)) + 4872|0) + ($sfb$029$i<<2)|0);
   $59 = HEAP32[$58>>2]|0;
   $60 = (($59) + ($j$028$i))|0;
   $61 = HEAP32[$18>>2]|0;
   $62 = ($60|0)>($61|0);
   if ($62) {
    $63 = (($61) - ($j$028$i))|0;
    $64 = (($63) + 1)|0;
    $65 = (((($gi)) + 2304|0) + ($61<<2)|0);
    $66 = (576 - ($61))|0;
    $67 = $66 << 2;
    _memset(($65|0),0,($67|0))|0;
    $68 = ($64|0)<(0);
    $$$i = $68 ? 0 : $64;
    $l$0$i = $$$i;$sfb$1$i = $19;
   } else {
    $l$0$i = $59;$sfb$1$i = $sfb$029$i;
   }
   $69 = ($accumulate$035$i|0)==(0);
   $70 = ($accumulate01$036$i|0)==(0);
   $71 = $accumulate$035$i | $accumulate01$036$i;
   $72 = ($71|0)==(0);
   $iData$0$acc_iData$0$i = $72 ? $iData$031$i : $acc_iData$037$i;
   $$0$acc_xp$0$i = $72 ? $$041$i : $acc_xp$039$i;
   if ($9) {
    $73 = HEAP32[$20>>2]|0;
    $74 = ($73|0)<(1);
    $75 = ($sfb$1$i|0)<($73|0);
    $or$cond$i = $74 | $75;
    if ($or$cond$i) {
     label = 23;
    } else {
     $76 = (((($prev_noise)) + 8|0) + ($sfb$1$i<<2)|0);
     $77 = HEAP32[$76>>2]|0;
     $78 = ($77|0)<(1);
     $79 = ($step$019$i|0)<($77|0);
     $or$cond3$i = $78 | $79;
     if ($or$cond3$i) {
      label = 23;
     } else {
      if ($69) {
       $acc_iData$2$i = $iData$0$acc_iData$0$i;$acc_xp$2$i = $$0$acc_xp$0$i;
      } else {
       _quantize_lines_xrpow($accumulate$035$i,$3,$$0$acc_xp$0$i,$iData$0$acc_iData$0$i);
       $acc_iData$2$i = $iData$031$i;$acc_xp$2$i = $$041$i;
      }
      $80 = (($l$0$i) + ($accumulate01$036$i))|0;
      $acc_iData$4$i = $acc_iData$2$i;$acc_xp$4$i = $acc_xp$2$i;$accumulate$3$i = 0;$accumulate01$2$i = $80;
     }
    }
   } else {
    label = 23;
   }
   if ((label|0) == 23) {
    label = 0;
    if ($70) {
     $acc_iData$3$i = $iData$0$acc_iData$0$i;$acc_xp$3$i = $$0$acc_xp$0$i;
    } else {
     $i$02$i9$i = 0;
     while(1) {
      $81 = (($$0$acc_xp$0$i) + ($i$02$i9$i<<2)|0);
      $82 = +HEAPF32[$81>>2];
      $83 = $i$02$i9$i | 1;
      $84 = (($$0$acc_xp$0$i) + ($83<<2)|0);
      $85 = +HEAPF32[$84>>2];
      $not$$i10$i = !($17 > $82);
      $86 = $not$$i10$i&1;
      $not$1$i11$i = !($17 > $85);
      $87 = $not$1$i11$i&1;
      $88 = (($iData$0$acc_iData$0$i) + ($i$02$i9$i<<2)|0);
      HEAP32[$88>>2] = $86;
      $89 = (($iData$0$acc_iData$0$i) + ($83<<2)|0);
      HEAP32[$89>>2] = $87;
      $90 = (($i$02$i9$i) + 2)|0;
      $91 = ($90>>>0)<($accumulate01$036$i>>>0);
      if ($91) {
       $i$02$i9$i = $90;
      } else {
       $acc_iData$3$i = $iData$031$i;$acc_xp$3$i = $$041$i;
       break;
      }
     }
    }
    $92 = (($l$0$i) + ($accumulate$035$i))|0;
    $acc_iData$4$i = $acc_iData$3$i;$acc_xp$4$i = $acc_xp$3$i;$accumulate$3$i = $92;$accumulate01$2$i = 0;
   }
   $93 = ($l$0$i|0)<(1);
   if ($93) {
    $acc_iData$4$i$lcssa = $acc_iData$4$i;$acc_xp$4$i$lcssa = $acc_xp$4$i;$accumulate$3$i$lcssa = $accumulate$3$i;$accumulate01$2$i$lcssa = $accumulate01$2$i;
    label = 27;
    break;
   } else {
    $acc_iData$5$i = $acc_iData$4$i;$acc_xp$5$i = $acc_xp$4$i;$accumulate$4$i = $accumulate$3$i;$accumulate01$4$i = $accumulate01$2$i;$sfb$2$i = $sfb$1$i;
   }
  }
  $107 = ($sfb$2$i|0)>($$2$i|0);
  if ($107) {
   $$1$i = $$041$i;$iData$1$i = $iData$031$i;$j$1$i = $j$028$i;
  } else {
   $108 = (((($gi)) + 4872|0) + ($sfb$2$i<<2)|0);
   $109 = HEAP32[$108>>2]|0;
   $110 = (($iData$031$i) + ($109<<2)|0);
   $111 = (($$041$i) + ($109<<2)|0);
   $112 = (($109) + ($j$028$i))|0;
   $$1$i = $111;$iData$1$i = $110;$j$1$i = $112;
  }
  $113 = (($sfb$2$i) + 1)|0;
  $114 = ($sfb$2$i|0)<($$2$i|0);
  if ($114) {
   $$041$i = $$1$i;$acc_iData$037$i = $acc_iData$5$i;$acc_xp$039$i = $acc_xp$5$i;$accumulate$035$i = $accumulate$4$i;$accumulate01$036$i = $accumulate01$4$i;$iData$031$i = $iData$1$i;$j$028$i = $j$1$i;$sfb$029$i = $113;
  } else {
   $acc_iData$5$i$lcssa = $acc_iData$5$i;$acc_xp$5$i$lcssa = $acc_xp$5$i;$accumulate$4$i$lcssa = $accumulate$4$i;$accumulate01$4$i$lcssa = $accumulate01$4$i;
   label = 34;
   break;
  }
 }
 if ((label|0) == 27) {
  $94 = ($accumulate01$2$i$lcssa|0)==(0);
  if (!($94)) {
   $i$02$i14$i = 0;
   while(1) {
    $95 = (($acc_xp$4$i$lcssa) + ($i$02$i14$i<<2)|0);
    $96 = +HEAPF32[$95>>2];
    $97 = $i$02$i14$i | 1;
    $98 = (($acc_xp$4$i$lcssa) + ($97<<2)|0);
    $99 = +HEAPF32[$98>>2];
    $not$$i15$i = !($17 > $96);
    $100 = $not$$i15$i&1;
    $not$1$i16$i = !($17 > $99);
    $101 = $not$1$i16$i&1;
    $102 = (($acc_iData$4$i$lcssa) + ($i$02$i14$i<<2)|0);
    HEAP32[$102>>2] = $100;
    $103 = (($acc_iData$4$i$lcssa) + ($97<<2)|0);
    HEAP32[$103>>2] = $101;
    $104 = (($i$02$i14$i) + 2)|0;
    $105 = ($104>>>0)<($accumulate01$2$i$lcssa>>>0);
    if ($105) {
     $i$02$i14$i = $104;
    } else {
     break;
    }
   }
  }
  $106 = ($accumulate$3$i$lcssa|0)==(0);
  if (!($106)) {
   _quantize_lines_xrpow($accumulate$3$i$lcssa,$3,$acc_xp$4$i$lcssa,$acc_iData$4$i$lcssa);
  }
 }
 else if ((label|0) == 34) {
  $115 = ($accumulate$4$i$lcssa|0)==(0);
  if (!($115)) {
   _quantize_lines_xrpow($accumulate$4$i$lcssa,$3,$acc_xp$5$i$lcssa,$acc_iData$5$i$lcssa);
  }
  $116 = ($accumulate01$4$i$lcssa|0)==(0);
  if (!($116)) {
   $i$02$i4$i = 0;
   while(1) {
    $117 = (($acc_xp$5$i$lcssa) + ($i$02$i4$i<<2)|0);
    $118 = +HEAPF32[$117>>2];
    $119 = $i$02$i4$i | 1;
    $120 = (($acc_xp$5$i$lcssa) + ($119<<2)|0);
    $121 = +HEAPF32[$120>>2];
    $not$$i5$i = !($17 > $118);
    $122 = $not$$i5$i&1;
    $not$1$i6$i = !($17 > $121);
    $123 = $not$1$i6$i&1;
    $124 = (($acc_iData$5$i$lcssa) + ($i$02$i4$i<<2)|0);
    HEAP32[$124>>2] = $122;
    $125 = (($acc_iData$5$i$lcssa) + ($119<<2)|0);
    HEAP32[$125>>2] = $123;
    $126 = (($i$02$i4$i) + 2)|0;
    $127 = ($126>>>0)<($accumulate01$4$i$lcssa>>>0);
    if ($127) {
     $i$02$i4$i = $126;
    } else {
     break;
    }
   }
  }
 }
 $128 = ((($gfc)) + 85096|0);
 $129 = HEAP32[$128>>2]|0;
 $130 = $129 & 2;
 $131 = ($130|0)==(0);
 if (!($131)) {
  $132 = HEAP32[$0>>2]|0;
  $133 = HEAP32[$16>>2]|0;
  $134 = (($133) + ($132))|0;
  $135 = (79704 + ($134<<2)|0);
  $136 = +HEAPF32[$135>>2];
  $137 = $136;
  $138 = 0.63452168224243899 / $137;
  $139 = $138;
  $140 = ((($gi)) + 4860|0);
  $141 = HEAP32[$140>>2]|0;
  $142 = ($141|0)>(0);
  if ($142) {
   $162 = $141;$j$03 = 0;$sfb$04 = 0;
   while(1) {
    $143 = (((($gi)) + 4872|0) + ($sfb$04<<2)|0);
    $144 = HEAP32[$143>>2]|0;
    $145 = (((($gfc)) + 84936|0) + ($sfb$04<<2)|0);
    $146 = HEAP32[$145>>2]|0;
    $147 = ($146|0)!=(0);
    $148 = (($144) + ($j$03))|0;
    $149 = ($144|0)>(0);
    $or$cond = $147 & $149;
    if ($or$cond) {
     $k$02 = $j$03;
     while(1) {
      $150 = (($xr) + ($k$02<<2)|0);
      $151 = +HEAPF32[$150>>2];
      $152 = !($151 >= $139);
      $$pre7 = (((($gi)) + 2304|0) + ($k$02<<2)|0);
      if ($152) {
       $154 = 0;
      } else {
       $153 = HEAP32[$$pre7>>2]|0;
       $154 = $153;
      }
      HEAP32[$$pre7>>2] = $154;
      $155 = (($k$02) + 1)|0;
      $156 = ($155|0)<($148|0);
      if ($156) {
       $k$02 = $155;
      } else {
       break;
      }
     }
     $$pre$pre = HEAP32[$140>>2]|0;
     $159 = $$pre$pre;
    } else {
     $159 = $162;
    }
    $157 = (($sfb$04) + 1)|0;
    $158 = ($157|0)<($159|0);
    if ($158) {
     $162 = $159;$j$03 = $148;$sfb$04 = $157;
    } else {
     break;
    }
   }
  }
 }
 $160 = (_noquant_count_bits($gfc,$gi,$prev_noise)|0);
 $$0 = $160;
 return ($$0|0);
}
function _best_scalefac_store($gfc,$gr,$ch,$l3_side) {
 $gfc = $gfc|0;
 $gr = $gr|0;
 $ch = $ch|0;
 $l3_side = $l3_side|0;
 var $$pre = 0, $$pre$i = 0, $$pre42 = 0, $$pre43 = 0, $$s$0 = 0, $$s$0$lcssa = 0, $$s1$0$1$i = 0, $$s1$0$10$i = 0, $$s1$0$2$i = 0, $$s1$0$3$i = 0, $$s1$0$4$i = 0, $$s1$0$5$i = 0, $$s1$0$6$i = 0, $$s1$0$7$i = 0, $$s1$0$8$i = 0, $$s1$0$9$i = 0, $$s1$0$i = 0, $$s2$0$i = 0, $$s2$0$i$1 = 0, $$s2$0$i$2 = 0;
 var $$s2$0$i$3 = 0, $$s2$0$i$4 = 0, $$s2$0$i$5 = 0, $$s2$0$i$6 = 0, $$s2$0$i$7 = 0, $$s2$0$i$8 = 0, $$s2$0$i$9 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0;
 var $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0;
 var $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0;
 var $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0;
 var $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0;
 var $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0;
 var $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0;
 var $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0;
 var $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0;
 var $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0;
 var $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0;
 var $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0;
 var $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0;
 var $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0;
 var $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0;
 var $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0;
 var $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $c1$1$1$i = 0, $c1$1$10$i = 0, $c1$1$2$i = 0, $c1$1$3$i = 0, $c1$1$4$i = 0, $c1$1$5$i = 0, $c1$1$6$i = 0, $c1$1$7$i = 0, $c1$1$8$i = 0, $c1$1$9$i = 0, $c1$1$i = 0;
 var $c2$1$i = 0, $c2$1$i$1 = 0, $c2$1$i$2 = 0, $c2$1$i$3 = 0, $c2$1$i$4 = 0, $c2$1$i$5 = 0, $c2$1$i$6 = 0, $c2$1$i$7 = 0, $c2$1$i$8 = 0, $c2$1$i$9 = 0, $exitcond$i = 0, $i$14$i = 0, $j$027 = 0, $l$0$lcssa = 0, $l$020 = 0, $or$cond = 0, $or$cond$i = 0, $or$cond$i$1 = 0, $or$cond$i$2 = 0, $or$cond$i$3 = 0;
 var $or$cond3 = 0, $or$cond4 = 0, $or$cond4$1 = 0, $or$cond4$2 = 0, $or$cond4$3 = 0, $or$cond4$4 = 0, $or$cond4$5 = 0, $or$cond4$6 = 0, $or$cond4$7 = 0, $or$cond4$8 = 0, $or$cond4$9 = 0, $recalc$0$lcssa = 0, $recalc$028 = 0, $recalc$1 = 0, $recalc$2 = 0, $recalc$3 = 0, $recalc$4 = 0, $s$017 = 0, $s1$1$1$i = 0, $s1$1$10$i = 0;
 var $s1$1$2$i = 0, $s1$1$3$i = 0, $s1$1$4$i = 0, $s1$1$5$i = 0, $s1$1$6$i = 0, $s1$1$7$i = 0, $s1$1$8$i = 0, $s1$1$9$i = 0, $s1$1$i = 0, $s2$1$i = 0, $s2$1$i$1 = 0, $s2$1$i$2 = 0, $s2$1$i$3 = 0, $s2$1$i$4 = 0, $s2$1$i$5 = 0, $s2$1$i$6 = 0, $s2$1$i$7 = 0, $s2$1$i$8 = 0, $s2$1$i$9 = 0, $scevgep = 0;
 var $scevgep38 = 0, $scevgep38$1 = 0, $scevgep38$2 = 0, $scevgep38$3 = 0, $scevgep40 = 0, $sfb$0$lcssa$i = 0, $sfb$0$lcssa$i$1 = 0, $sfb$0$lcssa$i$2 = 0, $sfb$0$lcssa$i$3 = 0, $sfb$012$i = 0, $sfb$012$i$1 = 0, $sfb$012$i$2 = 0, $sfb$012$i$3 = 0, $sfb$029 = 0, $sfb$116 = 0, $sfb$213 = 0, $sfb$59 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0);
 $1 = ((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4860|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = ($2|0)>(0);
 if ($3) {
  $319 = $2;$j$027 = 0;$recalc$028 = 0;$sfb$029 = 0;
  while(1) {
   $4 = (((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4872|0) + ($sfb$029<<2)|0);
   $5 = HEAP32[$4>>2]|0;
   $6 = (($5) + ($j$027))|0;
   $7 = ($5|0)>(0);
   L4: do {
    if ($7) {
     $l$020 = $j$027;
     while(1) {
      $8 = (((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 2304|0) + ($l$020<<2)|0);
      $9 = HEAP32[$8>>2]|0;
      $10 = ($9|0)==(0);
      if (!($10)) {
       $l$0$lcssa = $l$020;
       break L4;
      }
      $11 = (($l$020) + 1)|0;
      $12 = ($11|0)<($6|0);
      if ($12) {
       $l$020 = $11;
      } else {
       $l$0$lcssa = $11;
       break;
      }
     }
    } else {
     $l$0$lcssa = $j$027;
    }
   } while(0);
   $13 = ($l$0$lcssa|0)==($6|0);
   if ($13) {
    $14 = (((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4608|0) + ($sfb$029<<2)|0);
    HEAP32[$14>>2] = -2;
    $$pre = HEAP32[$1>>2]|0;
    $17 = $$pre;$recalc$1 = -2;
   } else {
    $17 = $319;$recalc$1 = $recalc$028;
   }
   $15 = (($sfb$029) + 1)|0;
   $16 = ($15|0)<($17|0);
   if ($16) {
    $319 = $17;$j$027 = $6;$recalc$028 = $recalc$1;$sfb$029 = $15;
   } else {
    $24 = $17;$recalc$0$lcssa = $recalc$1;
    break;
   }
  }
 } else {
  $24 = $2;$recalc$0$lcssa = 0;
 }
 $18 = ((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4836|0);
 $19 = HEAP32[$18>>2]|0;
 $20 = ($19|0)==(0);
 $21 = ((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4832|0);
 if ($20) {
  $22 = HEAP32[$21>>2]|0;
  $23 = ($22|0)==(0);
  if ($23) {
   $25 = ($24|0)>(0);
   if ($25) {
    $s$017 = 0;$sfb$116 = 0;
    while(1) {
     $26 = (((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4608|0) + ($sfb$116<<2)|0);
     $27 = HEAP32[$26>>2]|0;
     $28 = ($27|0)>(0);
     $29 = $28 ? $27 : 0;
     $$s$0 = $29 | $s$017;
     $30 = (($sfb$116) + 1)|0;
     $31 = ($30|0)<($24|0);
     if ($31) {
      $s$017 = $$s$0;$sfb$116 = $30;
     } else {
      $$s$0$lcssa = $$s$0;
      break;
     }
    }
    $32 = $$s$0$lcssa & 1;
    $33 = ($32|0)==(0);
    $34 = ($$s$0$lcssa|0)!=(0);
    $or$cond = $34 & $33;
    if ($or$cond) {
     if ($25) {
      $320 = $24;$sfb$213 = 0;
      while(1) {
       $35 = (((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4608|0) + ($sfb$213<<2)|0);
       $36 = HEAP32[$35>>2]|0;
       $37 = ($36|0)>(0);
       if ($37) {
        $38 = $36 >> 1;
        HEAP32[$35>>2] = $38;
        $$pre42 = HEAP32[$1>>2]|0;
        $41 = $$pre42;
       } else {
        $41 = $320;
       }
       $39 = (($sfb$213) + 1)|0;
       $40 = ($39|0)<($41|0);
       if ($40) {
        $320 = $41;$sfb$213 = $39;
       } else {
        break;
       }
      }
     }
     HEAP32[$18>>2] = 1;
     $recalc$2 = 1;
    } else {
     $recalc$2 = $recalc$0$lcssa;
    }
   } else {
    $recalc$2 = $recalc$0$lcssa;
   }
  } else {
   $recalc$2 = $recalc$0$lcssa;
  }
 } else {
  $recalc$2 = $recalc$0$lcssa;
 }
 $42 = HEAP32[$21>>2]|0;
 $43 = ($42|0)==(0);
 if ($43) {
  $44 = ((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4788|0);
  $45 = HEAP32[$44>>2]|0;
  $46 = ($45|0)==(2);
  if ($46) {
   $recalc$3 = $recalc$2;
  } else {
   $47 = ((($gfc)) + 76|0);
   $48 = HEAP32[$47>>2]|0;
   $49 = ($48|0)==(2);
   if ($49) {
    $50 = ((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4652|0);
    $51 = HEAP32[$50>>2]|0;
    $52 = HEAP32[(12156)>>2]|0;
    $53 = ($51|0)>=($52|0);
    $54 = ($51|0)==(-2);
    $or$cond4 = $54 | $53;
    if ($or$cond4) {
     $55 = ((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4656|0);
     $56 = HEAP32[$55>>2]|0;
     $57 = HEAP32[(12160)>>2]|0;
     $58 = ($56|0)>=($57|0);
     $59 = ($56|0)==(-2);
     $or$cond4$1 = $59 | $58;
     if ($or$cond4$1) {
      $267 = ((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4660|0);
      $263 = HEAP32[$267>>2]|0;
      $266 = HEAP32[(12164)>>2]|0;
      $303 = ($263|0)>=($266|0);
      $304 = ($263|0)==(-2);
      $or$cond4$2 = $304 | $303;
      if ($or$cond4$2) {
       $272 = ((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4664|0);
       $268 = HEAP32[$272>>2]|0;
       $271 = HEAP32[(12168)>>2]|0;
       $305 = ($268|0)>=($271|0);
       $306 = ($268|0)==(-2);
       $or$cond4$3 = $306 | $305;
       if ($or$cond4$3) {
        $277 = ((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4668|0);
        $273 = HEAP32[$277>>2]|0;
        $276 = HEAP32[(12172)>>2]|0;
        $307 = ($273|0)>=($276|0);
        $308 = ($273|0)==(-2);
        $or$cond4$4 = $308 | $307;
        if ($or$cond4$4) {
         $282 = ((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4672|0);
         $278 = HEAP32[$282>>2]|0;
         $281 = HEAP32[(12176)>>2]|0;
         $309 = ($278|0)>=($281|0);
         $310 = ($278|0)==(-2);
         $or$cond4$5 = $310 | $309;
         if ($or$cond4$5) {
          $287 = ((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4676|0);
          $283 = HEAP32[$287>>2]|0;
          $286 = HEAP32[(12180)>>2]|0;
          $311 = ($283|0)>=($286|0);
          $312 = ($283|0)==(-2);
          $or$cond4$6 = $312 | $311;
          if ($or$cond4$6) {
           $292 = ((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4680|0);
           $288 = HEAP32[$292>>2]|0;
           $291 = HEAP32[(12184)>>2]|0;
           $313 = ($288|0)>=($291|0);
           $314 = ($288|0)==(-2);
           $or$cond4$7 = $314 | $313;
           if ($or$cond4$7) {
            $297 = ((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4684|0);
            $293 = HEAP32[$297>>2]|0;
            $296 = HEAP32[(12188)>>2]|0;
            $315 = ($293|0)>=($296|0);
            $316 = ($293|0)==(-2);
            $or$cond4$8 = $316 | $315;
            if ($or$cond4$8) {
             $302 = ((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4688|0);
             $298 = HEAP32[$302>>2]|0;
             $301 = HEAP32[(12192)>>2]|0;
             $317 = ($298|0)>=($301|0);
             $318 = ($298|0)==(-2);
             $or$cond4$9 = $318 | $317;
             if ($or$cond4$9) {
              $60 = ($51|0)>(0);
              if ($60) {
               $61 = (($51) - ($52))|0;
               HEAP32[$50>>2] = $61;
              }
              $62 = ($56|0)>(0);
              if ($62) {
               $262 = (($56) - ($57))|0;
               HEAP32[$55>>2] = $262;
              }
              $264 = ($263|0)>(0);
              if ($264) {
               $265 = (($263) - ($266))|0;
               HEAP32[$267>>2] = $265;
              }
              $269 = ($268|0)>(0);
              if ($269) {
               $270 = (($268) - ($271))|0;
               HEAP32[$272>>2] = $270;
              }
              $274 = ($273|0)>(0);
              if ($274) {
               $275 = (($273) - ($276))|0;
               HEAP32[$277>>2] = $275;
              }
              $279 = ($278|0)>(0);
              if ($279) {
               $280 = (($278) - ($281))|0;
               HEAP32[$282>>2] = $280;
              }
              $284 = ($283|0)>(0);
              if ($284) {
               $285 = (($283) - ($286))|0;
               HEAP32[$287>>2] = $285;
              }
              $289 = ($288|0)>(0);
              if ($289) {
               $290 = (($288) - ($291))|0;
               HEAP32[$292>>2] = $290;
              }
              $294 = ($293|0)>(0);
              if ($294) {
               $295 = (($293) - ($296))|0;
               HEAP32[$297>>2] = $295;
              }
              $299 = ($298|0)>(0);
              if ($299) {
               $300 = (($298) - ($301))|0;
               HEAP32[$302>>2] = $300;
              }
              HEAP32[$21>>2] = 1;
              $recalc$3 = 1;
             } else {
              $recalc$3 = $recalc$2;
             }
            } else {
             $recalc$3 = $recalc$2;
            }
           } else {
            $recalc$3 = $recalc$2;
           }
          } else {
           $recalc$3 = $recalc$2;
          }
         } else {
          $recalc$3 = $recalc$2;
         }
        } else {
         $recalc$3 = $recalc$2;
        }
       } else {
        $recalc$3 = $recalc$2;
       }
      } else {
       $recalc$3 = $recalc$2;
      }
     } else {
      $recalc$3 = $recalc$2;
     }
    } else {
     $recalc$3 = $recalc$2;
    }
   } else {
    $recalc$3 = $recalc$2;
   }
  }
 } else {
  $recalc$3 = $recalc$2;
 }
 $63 = $ch << 2;
 $64 = (($63) + 4)|0;
 $scevgep40 = (((($l3_side)) + 21008|0) + ($64<<2)|0);
 ;HEAP32[$scevgep40>>2]=0|0;HEAP32[$scevgep40+4>>2]=0|0;HEAP32[$scevgep40+8>>2]=0|0;HEAP32[$scevgep40+12>>2]=0|0;
 $65 = ((($gfc)) + 76|0);
 $66 = HEAP32[$65>>2]|0;
 $67 = ($66|0)==(2);
 $68 = ($gr|0)==(1);
 $or$cond3 = $68 & $67;
 if ($or$cond3) {
  $69 = (((($l3_side) + (($ch*5252)|0)|0)) + 4788|0);
  $70 = HEAP32[$69>>2]|0;
  $71 = ($70|0)==(2);
  if ($71) {
   $recalc$4 = $recalc$3;
  } else {
   $72 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4788|0);
   $73 = HEAP32[$72>>2]|0;
   $74 = ($73|0)==(2);
   if ($74) {
    $recalc$4 = $recalc$3;
   } else {
    $$pre$i = HEAP32[84136>>2]|0;
    $scevgep = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4608|0);
    $75 = HEAP32[(84140)>>2]|0;
    $76 = ($75|0)>($$pre$i|0);
    L77: do {
     if ($76) {
      $sfb$012$i = $$pre$i;
      while(1) {
       $77 = ((((($l3_side) + (($ch*5252)|0)|0)) + 4608|0) + ($sfb$012$i<<2)|0);
       $78 = HEAP32[$77>>2]|0;
       $79 = ((((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4608|0) + ($sfb$012$i<<2)|0);
       $80 = HEAP32[$79>>2]|0;
       $81 = ($78|0)!=($80|0);
       $82 = ($80|0)>(-1);
       $or$cond$i = $81 & $82;
       if ($or$cond$i) {
        $sfb$0$lcssa$i = $sfb$012$i;
        break L77;
       }
       $83 = (($sfb$012$i) + 1)|0;
       $84 = ($83|0)<($75|0);
       if ($84) {
        $sfb$012$i = $83;
       } else {
        $sfb$0$lcssa$i = $83;
        break;
       }
      }
     } else {
      $sfb$0$lcssa$i = $$pre$i;
     }
    } while(0);
    $85 = ($sfb$0$lcssa$i|0)==($75|0);
    if ($85) {
     if ($76) {
      $scevgep38 = ((((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4608|0) + ($$pre$i<<2)|0);
      $88 = (($75) - ($$pre$i))|0;
      $89 = $88 << 2;
      _memset(($scevgep38|0),-1,($89|0))|0;
     }
     $90 = (((($l3_side)) + 21024|0) + ($ch<<4)|0);
     HEAP32[$90>>2] = 1;
    }
    $86 = HEAP32[(84144)>>2]|0;
    $87 = ($86|0)>($75|0);
    L88: do {
     if ($87) {
      $sfb$012$i$1 = $75;
      while(1) {
       $216 = ((((($l3_side) + (($ch*5252)|0)|0)) + 4608|0) + ($sfb$012$i$1<<2)|0);
       $217 = HEAP32[$216>>2]|0;
       $218 = ((((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4608|0) + ($sfb$012$i$1<<2)|0);
       $219 = HEAP32[$218>>2]|0;
       $220 = ($217|0)!=($219|0);
       $221 = ($219|0)>(-1);
       $or$cond$i$1 = $220 & $221;
       if ($or$cond$i$1) {
        $sfb$0$lcssa$i$1 = $sfb$012$i$1;
        break L88;
       }
       $222 = (($sfb$012$i$1) + 1)|0;
       $223 = ($222|0)<($86|0);
       if ($223) {
        $sfb$012$i$1 = $222;
       } else {
        $sfb$0$lcssa$i$1 = $222;
        break;
       }
      }
     } else {
      $sfb$0$lcssa$i$1 = $75;
     }
    } while(0);
    $224 = ($sfb$0$lcssa$i$1|0)==($86|0);
    if ($224) {
     if ($87) {
      $scevgep38$1 = ((((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4608|0) + ($75<<2)|0);
      $225 = (($86) - ($75))|0;
      $226 = $225 << 2;
      _memset(($scevgep38$1|0),-1,($226|0))|0;
     }
     $227 = (((((($l3_side)) + 21024|0) + ($ch<<4)|0)) + 4|0);
     HEAP32[$227>>2] = 1;
    }
    $228 = HEAP32[(84148)>>2]|0;
    $229 = ($228|0)>($86|0);
    L99: do {
     if ($229) {
      $sfb$012$i$2 = $86;
      while(1) {
       $230 = ((((($l3_side) + (($ch*5252)|0)|0)) + 4608|0) + ($sfb$012$i$2<<2)|0);
       $231 = HEAP32[$230>>2]|0;
       $232 = ((((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4608|0) + ($sfb$012$i$2<<2)|0);
       $233 = HEAP32[$232>>2]|0;
       $234 = ($231|0)!=($233|0);
       $235 = ($233|0)>(-1);
       $or$cond$i$2 = $234 & $235;
       if ($or$cond$i$2) {
        $sfb$0$lcssa$i$2 = $sfb$012$i$2;
        break L99;
       }
       $236 = (($sfb$012$i$2) + 1)|0;
       $237 = ($236|0)<($228|0);
       if ($237) {
        $sfb$012$i$2 = $236;
       } else {
        $sfb$0$lcssa$i$2 = $236;
        break;
       }
      }
     } else {
      $sfb$0$lcssa$i$2 = $86;
     }
    } while(0);
    $238 = ($sfb$0$lcssa$i$2|0)==($228|0);
    if ($238) {
     if ($229) {
      $scevgep38$2 = ((((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4608|0) + ($86<<2)|0);
      $239 = (($228) - ($86))|0;
      $240 = $239 << 2;
      _memset(($scevgep38$2|0),-1,($240|0))|0;
     }
     $241 = (((((($l3_side)) + 21024|0) + ($ch<<4)|0)) + 8|0);
     HEAP32[$241>>2] = 1;
    }
    $242 = HEAP32[(84152)>>2]|0;
    $243 = ($242|0)>($228|0);
    L110: do {
     if ($243) {
      $sfb$012$i$3 = $228;
      while(1) {
       $244 = ((((($l3_side) + (($ch*5252)|0)|0)) + 4608|0) + ($sfb$012$i$3<<2)|0);
       $245 = HEAP32[$244>>2]|0;
       $246 = ((((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4608|0) + ($sfb$012$i$3<<2)|0);
       $247 = HEAP32[$246>>2]|0;
       $248 = ($245|0)!=($247|0);
       $249 = ($247|0)>(-1);
       $or$cond$i$3 = $248 & $249;
       if ($or$cond$i$3) {
        $sfb$0$lcssa$i$3 = $sfb$012$i$3;
        break L110;
       }
       $250 = (($sfb$012$i$3) + 1)|0;
       $251 = ($250|0)<($242|0);
       if ($251) {
        $sfb$012$i$3 = $250;
       } else {
        $sfb$0$lcssa$i$3 = $250;
        break;
       }
      }
     } else {
      $sfb$0$lcssa$i$3 = $228;
     }
    } while(0);
    $252 = ($sfb$0$lcssa$i$3|0)==($242|0);
    if ($252) {
     if ($243) {
      $scevgep38$3 = ((((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4608|0) + ($228<<2)|0);
      $253 = (($242) - ($228))|0;
      $254 = $253 << 2;
      _memset(($scevgep38$3|0),-1,($254|0))|0;
     }
     $255 = (((((($l3_side)) + 21024|0) + ($ch<<4)|0)) + 12|0);
     HEAP32[$255>>2] = 1;
    }
    $256 = HEAP32[$scevgep>>2]|0;
    $257 = ($256|0)==(-1);
    $258 = ($256|0)>(0);
    $$s1$0$i = $258 ? $256 : 0;
    $259 = $257&1;
    $c1$1$i = $259 ^ 1;
    $s1$1$i = $257 ? 0 : $$s1$0$i;
    $260 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4612|0);
    $119 = HEAP32[$260>>2]|0;
    $261 = ($119|0)==(-1);
    if ($261) {
     $c1$1$1$i = $c1$1$i;$s1$1$1$i = $s1$1$i;
    } else {
     $117 = (($c1$1$i) + 1)|0;
     $118 = ($s1$1$i|0)<($119|0);
     $$s1$0$1$i = $118 ? $119 : $s1$1$i;
     $c1$1$1$i = $117;$s1$1$1$i = $$s1$0$1$i;
    }
    $120 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4616|0);
    $121 = HEAP32[$120>>2]|0;
    $122 = ($121|0)==(-1);
    if ($122) {
     $c1$1$2$i = $c1$1$1$i;$s1$1$2$i = $s1$1$1$i;
    } else {
     $123 = (($c1$1$1$i) + 1)|0;
     $124 = ($s1$1$1$i|0)<($121|0);
     $$s1$0$2$i = $124 ? $121 : $s1$1$1$i;
     $c1$1$2$i = $123;$s1$1$2$i = $$s1$0$2$i;
    }
    $125 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4620|0);
    $126 = HEAP32[$125>>2]|0;
    $127 = ($126|0)==(-1);
    if ($127) {
     $c1$1$3$i = $c1$1$2$i;$s1$1$3$i = $s1$1$2$i;
    } else {
     $128 = (($c1$1$2$i) + 1)|0;
     $129 = ($s1$1$2$i|0)<($126|0);
     $$s1$0$3$i = $129 ? $126 : $s1$1$2$i;
     $c1$1$3$i = $128;$s1$1$3$i = $$s1$0$3$i;
    }
    $130 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4624|0);
    $131 = HEAP32[$130>>2]|0;
    $132 = ($131|0)==(-1);
    if ($132) {
     $c1$1$4$i = $c1$1$3$i;$s1$1$4$i = $s1$1$3$i;
    } else {
     $133 = (($c1$1$3$i) + 1)|0;
     $134 = ($s1$1$3$i|0)<($131|0);
     $$s1$0$4$i = $134 ? $131 : $s1$1$3$i;
     $c1$1$4$i = $133;$s1$1$4$i = $$s1$0$4$i;
    }
    $135 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4628|0);
    $136 = HEAP32[$135>>2]|0;
    $137 = ($136|0)==(-1);
    if ($137) {
     $c1$1$5$i = $c1$1$4$i;$s1$1$5$i = $s1$1$4$i;
    } else {
     $138 = (($c1$1$4$i) + 1)|0;
     $139 = ($s1$1$4$i|0)<($136|0);
     $$s1$0$5$i = $139 ? $136 : $s1$1$4$i;
     $c1$1$5$i = $138;$s1$1$5$i = $$s1$0$5$i;
    }
    $140 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4632|0);
    $141 = HEAP32[$140>>2]|0;
    $142 = ($141|0)==(-1);
    if ($142) {
     $c1$1$6$i = $c1$1$5$i;$s1$1$6$i = $s1$1$5$i;
    } else {
     $143 = (($c1$1$5$i) + 1)|0;
     $144 = ($s1$1$5$i|0)<($141|0);
     $$s1$0$6$i = $144 ? $141 : $s1$1$5$i;
     $c1$1$6$i = $143;$s1$1$6$i = $$s1$0$6$i;
    }
    $145 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4636|0);
    $146 = HEAP32[$145>>2]|0;
    $147 = ($146|0)==(-1);
    if ($147) {
     $c1$1$7$i = $c1$1$6$i;$s1$1$7$i = $s1$1$6$i;
    } else {
     $148 = (($c1$1$6$i) + 1)|0;
     $149 = ($s1$1$6$i|0)<($146|0);
     $$s1$0$7$i = $149 ? $146 : $s1$1$6$i;
     $c1$1$7$i = $148;$s1$1$7$i = $$s1$0$7$i;
    }
    $150 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4640|0);
    $151 = HEAP32[$150>>2]|0;
    $152 = ($151|0)==(-1);
    if ($152) {
     $c1$1$8$i = $c1$1$7$i;$s1$1$8$i = $s1$1$7$i;
    } else {
     $153 = (($c1$1$7$i) + 1)|0;
     $154 = ($s1$1$7$i|0)<($151|0);
     $$s1$0$8$i = $154 ? $151 : $s1$1$7$i;
     $c1$1$8$i = $153;$s1$1$8$i = $$s1$0$8$i;
    }
    $155 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4644|0);
    $156 = HEAP32[$155>>2]|0;
    $157 = ($156|0)==(-1);
    if ($157) {
     $c1$1$9$i = $c1$1$8$i;$s1$1$9$i = $s1$1$8$i;
    } else {
     $158 = (($c1$1$8$i) + 1)|0;
     $159 = ($s1$1$8$i|0)<($156|0);
     $$s1$0$9$i = $159 ? $156 : $s1$1$8$i;
     $c1$1$9$i = $158;$s1$1$9$i = $$s1$0$9$i;
    }
    $160 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4648|0);
    $161 = HEAP32[$160>>2]|0;
    $162 = ($161|0)==(-1);
    if ($162) {
     $c1$1$10$i = $c1$1$9$i;$s1$1$10$i = $s1$1$9$i;
    } else {
     $163 = (($c1$1$9$i) + 1)|0;
     $164 = ($s1$1$9$i|0)<($161|0);
     $$s1$0$10$i = $164 ? $161 : $s1$1$9$i;
     $c1$1$10$i = $163;$s1$1$10$i = $$s1$0$10$i;
    }
    $91 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4652|0);
    $92 = HEAP32[$91>>2]|0;
    $93 = ($92|0)==(-1);
    $94 = ($92|0)>(0);
    $$s2$0$i = $94 ? $92 : 0;
    $95 = $93&1;
    $c2$1$i = $95 ^ 1;
    $s2$1$i = $93 ? 0 : $$s2$0$i;
    $96 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4656|0);
    $97 = HEAP32[$96>>2]|0;
    $98 = ($97|0)==(-1);
    if ($98) {
     $c2$1$i$1 = $c2$1$i;$s2$1$i$1 = $s2$1$i;
    } else {
     $174 = (($c2$1$i) + 1)|0;
     $175 = ($s2$1$i|0)<($97|0);
     $$s2$0$i$1 = $175 ? $97 : $s2$1$i;
     $c2$1$i$1 = $174;$s2$1$i$1 = $$s2$0$i$1;
    }
    $176 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4660|0);
    $177 = HEAP32[$176>>2]|0;
    $178 = ($177|0)==(-1);
    if ($178) {
     $c2$1$i$2 = $c2$1$i$1;$s2$1$i$2 = $s2$1$i$1;
    } else {
     $179 = (($c2$1$i$1) + 1)|0;
     $180 = ($s2$1$i$1|0)<($177|0);
     $$s2$0$i$2 = $180 ? $177 : $s2$1$i$1;
     $c2$1$i$2 = $179;$s2$1$i$2 = $$s2$0$i$2;
    }
    $181 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4664|0);
    $182 = HEAP32[$181>>2]|0;
    $183 = ($182|0)==(-1);
    if ($183) {
     $c2$1$i$3 = $c2$1$i$2;$s2$1$i$3 = $s2$1$i$2;
    } else {
     $184 = (($c2$1$i$2) + 1)|0;
     $185 = ($s2$1$i$2|0)<($182|0);
     $$s2$0$i$3 = $185 ? $182 : $s2$1$i$2;
     $c2$1$i$3 = $184;$s2$1$i$3 = $$s2$0$i$3;
    }
    $186 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4668|0);
    $187 = HEAP32[$186>>2]|0;
    $188 = ($187|0)==(-1);
    if ($188) {
     $c2$1$i$4 = $c2$1$i$3;$s2$1$i$4 = $s2$1$i$3;
    } else {
     $189 = (($c2$1$i$3) + 1)|0;
     $190 = ($s2$1$i$3|0)<($187|0);
     $$s2$0$i$4 = $190 ? $187 : $s2$1$i$3;
     $c2$1$i$4 = $189;$s2$1$i$4 = $$s2$0$i$4;
    }
    $191 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4672|0);
    $192 = HEAP32[$191>>2]|0;
    $193 = ($192|0)==(-1);
    if ($193) {
     $c2$1$i$5 = $c2$1$i$4;$s2$1$i$5 = $s2$1$i$4;
    } else {
     $194 = (($c2$1$i$4) + 1)|0;
     $195 = ($s2$1$i$4|0)<($192|0);
     $$s2$0$i$5 = $195 ? $192 : $s2$1$i$4;
     $c2$1$i$5 = $194;$s2$1$i$5 = $$s2$0$i$5;
    }
    $196 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4676|0);
    $197 = HEAP32[$196>>2]|0;
    $198 = ($197|0)==(-1);
    if ($198) {
     $c2$1$i$6 = $c2$1$i$5;$s2$1$i$6 = $s2$1$i$5;
    } else {
     $199 = (($c2$1$i$5) + 1)|0;
     $200 = ($s2$1$i$5|0)<($197|0);
     $$s2$0$i$6 = $200 ? $197 : $s2$1$i$5;
     $c2$1$i$6 = $199;$s2$1$i$6 = $$s2$0$i$6;
    }
    $201 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4680|0);
    $202 = HEAP32[$201>>2]|0;
    $203 = ($202|0)==(-1);
    if ($203) {
     $c2$1$i$7 = $c2$1$i$6;$s2$1$i$7 = $s2$1$i$6;
    } else {
     $204 = (($c2$1$i$6) + 1)|0;
     $205 = ($s2$1$i$6|0)<($202|0);
     $$s2$0$i$7 = $205 ? $202 : $s2$1$i$6;
     $c2$1$i$7 = $204;$s2$1$i$7 = $$s2$0$i$7;
    }
    $206 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4684|0);
    $207 = HEAP32[$206>>2]|0;
    $208 = ($207|0)==(-1);
    if ($208) {
     $c2$1$i$8 = $c2$1$i$7;$s2$1$i$8 = $s2$1$i$7;
    } else {
     $209 = (($c2$1$i$7) + 1)|0;
     $210 = ($s2$1$i$7|0)<($207|0);
     $$s2$0$i$8 = $210 ? $207 : $s2$1$i$7;
     $c2$1$i$8 = $209;$s2$1$i$8 = $$s2$0$i$8;
    }
    $211 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4688|0);
    $212 = HEAP32[$211>>2]|0;
    $213 = ($212|0)==(-1);
    if ($213) {
     $c2$1$i$9 = $c2$1$i$8;$s2$1$i$9 = $s2$1$i$8;
    } else {
     $214 = (($c2$1$i$8) + 1)|0;
     $215 = ($s2$1$i$8|0)<($212|0);
     $$s2$0$i$9 = $215 ? $212 : $s2$1$i$8;
     $c2$1$i$9 = $214;$s2$1$i$9 = $$s2$0$i$9;
    }
    $113 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4844|0);
    $115 = (((((($l3_side)) + 10504|0) + (($ch*5252)|0)|0)) + 4784|0);
    $i$14$i = 0;
    while(1) {
     $99 = (88776 + ($i$14$i<<2)|0);
     $100 = HEAP32[$99>>2]|0;
     $101 = ($s1$1$10$i|0)<($100|0);
     do {
      if ($101) {
       $102 = (88840 + ($i$14$i<<2)|0);
       $103 = HEAP32[$102>>2]|0;
       $104 = ($s2$1$i$9|0)<($103|0);
       if (!($104)) {
        break;
       }
       $105 = (88648 + ($i$14$i<<2)|0);
       $106 = HEAP32[$105>>2]|0;
       $107 = Math_imul($106, $c1$1$10$i)|0;
       $108 = (88712 + ($i$14$i<<2)|0);
       $109 = HEAP32[$108>>2]|0;
       $110 = Math_imul($109, $c2$1$i$9)|0;
       $111 = (($110) + ($107))|0;
       $112 = HEAP32[$113>>2]|0;
       $114 = ($112|0)>($111|0);
       if (!($114)) {
        break;
       }
       HEAP32[$113>>2] = $111;
       HEAP32[$115>>2] = $i$14$i;
      }
     } while(0);
     $116 = (($i$14$i) + 1)|0;
     $exitcond$i = ($116|0)==(16);
     if ($exitcond$i) {
      $recalc$4 = 0;
      break;
     } else {
      $i$14$i = $116;
     }
    }
   }
  }
 } else {
  $recalc$4 = $recalc$3;
 }
 $165 = HEAP32[$1>>2]|0;
 $166 = ($165|0)>(0);
 if ($166) {
  $321 = $165;$sfb$59 = 0;
  while(1) {
   $167 = (((((($l3_side) + (($gr*10504)|0)|0) + (($ch*5252)|0)|0)) + 4608|0) + ($sfb$59<<2)|0);
   $168 = HEAP32[$167>>2]|0;
   $169 = ($168|0)==(-2);
   if ($169) {
    HEAP32[$167>>2] = 0;
    $$pre43 = HEAP32[$1>>2]|0;
    $172 = $$pre43;
   } else {
    $172 = $321;
   }
   $170 = (($sfb$59) + 1)|0;
   $171 = ($170|0)<($172|0);
   if ($171) {
    $321 = $172;$sfb$59 = $170;
   } else {
    break;
   }
  }
 }
 $173 = ($recalc$4|0)==(0);
 if ($173) {
  return;
 }
 (_scale_bitcount($gfc,$0)|0);
 return;
}
function _scale_bitcount($gfc,$cod_info) {
 $gfc = $gfc|0;
 $cod_info = $cod_info|0;
 var $$$i = 0, $$$i1 = 0, $$0 = 0, $$lcssa = 0, $$lcssa30 = 0, $$lcssa31 = 0, $$max_slen1$0$i = 0, $$max_slen1$0$i$lcssa = 0, $$max_slen2$0$i = 0, $$over$0$1$i = 0, $$over$0$2$i = 0, $$over$0$3$i = 0, $$phi$trans$insert29$i = 0, $$phi$trans$insert31$i = 0, $$phi$trans$insert33$i = 0, $$pre$i = 0, $$pre28$i = 0, $$pre30$i = 0, $$pre32$i = 0, $$pre34$i = 0;
 var $$sink$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0;
 var $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0;
 var $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0;
 var $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0;
 var $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0;
 var $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0;
 var $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0;
 var $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0;
 var $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0;
 var $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0;
 var $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0;
 var $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $exitcond = 0, $exitcond$i = 0, $exitcond$i6 = 0, $exitcond16 = 0, $exitcond23$1$i = 0, $exitcond23$2$i = 0;
 var $exitcond23$3$i = 0, $exitcond23$i = 0, $i$19$i = 0, $i$213$1$i = 0, $i$213$2$i = 0, $i$213$3$i = 0, $k$04$i = 0, $max_sfac$i = 0, $max_slen1$0$lcssa$i = 0, $max_slen1$08$i = 0, $max_slen2$0$lcssa$i = 0, $max_slen2$06$i = 0, $partition$012$i = 0, $row_in_table$0$i = 0, $sfb$011$i = 0, $sfb$1$lcssa$i = 0, $sfb$110$i = 0, $sfb$2$lcssa$i = 0, $sfb$27$i = 0, $sfb$3$lcssa$1$i = 0;
 var $sfb$3$lcssa$2$i = 0, $sfb$3$lcssa$i = 0, $sfb$314$1$i = 0, $sfb$314$2$i = 0, $sfb$314$3$i = 0, $sfb$314$i = 0, $sfb$35$i = 0, $smax$i = 0, $smax$i3 = 0, $tab$0$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $max_sfac$i = sp;
 $0 = ((($gfc)) + 76|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($1|0)==(2);
 if ($2) {
  $3 = ((($cod_info)) + 4788|0);
  $4 = HEAP32[$3>>2]|0;
  $5 = ($4|0)==(2);
  if ($5) {
   $6 = ((($cod_info)) + 4792|0);
   $7 = HEAP32[$6>>2]|0;
   $8 = ($7|0)!=(0);
   $$$i = $8 ? 88904 : 88968;
   $tab$0$i = $$$i;
  } else {
   $9 = ((($cod_info)) + 4832|0);
   $10 = HEAP32[$9>>2]|0;
   $11 = ($10|0)==(0);
   if ($11) {
    $12 = ((($cod_info)) + 4652|0);
    $13 = HEAP32[$12>>2]|0;
    $14 = HEAP32[(12156)>>2]|0;
    $15 = ($13|0)<($14|0);
    if ($15) {
     $tab$0$i = 89032;
    } else {
     $16 = ((($cod_info)) + 4656|0);
     $17 = HEAP32[$16>>2]|0;
     $18 = HEAP32[(12160)>>2]|0;
     $19 = ($17|0)<($18|0);
     if ($19) {
      $tab$0$i = 89032;
     } else {
      $25 = ((($cod_info)) + 4660|0);
      $24 = HEAP32[$25>>2]|0;
      $23 = HEAP32[(12164)>>2]|0;
      $82 = ($24|0)<($23|0);
      if ($82) {
       $tab$0$i = 89032;
      } else {
       $29 = ((($cod_info)) + 4664|0);
       $28 = HEAP32[$29>>2]|0;
       $27 = HEAP32[(12168)>>2]|0;
       $83 = ($28|0)<($27|0);
       if ($83) {
        $tab$0$i = 89032;
       } else {
        $33 = ((($cod_info)) + 4668|0);
        $32 = HEAP32[$33>>2]|0;
        $31 = HEAP32[(12172)>>2]|0;
        $84 = ($32|0)<($31|0);
        if ($84) {
         $tab$0$i = 89032;
        } else {
         $37 = ((($cod_info)) + 4672|0);
         $36 = HEAP32[$37>>2]|0;
         $35 = HEAP32[(12176)>>2]|0;
         $85 = ($36|0)<($35|0);
         if ($85) {
          $tab$0$i = 89032;
         } else {
          $41 = ((($cod_info)) + 4676|0);
          $40 = HEAP32[$41>>2]|0;
          $39 = HEAP32[(12180)>>2]|0;
          $86 = ($40|0)<($39|0);
          if ($86) {
           $tab$0$i = 89032;
          } else {
           $45 = ((($cod_info)) + 4680|0);
           $44 = HEAP32[$45>>2]|0;
           $43 = HEAP32[(12184)>>2]|0;
           $87 = ($44|0)<($43|0);
           if ($87) {
            $tab$0$i = 89032;
           } else {
            $49 = ((($cod_info)) + 4684|0);
            $48 = HEAP32[$49>>2]|0;
            $47 = HEAP32[(12188)>>2]|0;
            $88 = ($48|0)<($47|0);
            if ($88) {
             $tab$0$i = 89032;
            } else {
             $53 = ((($cod_info)) + 4688|0);
             $52 = HEAP32[$53>>2]|0;
             $51 = HEAP32[(12192)>>2]|0;
             $89 = ($52|0)<($51|0);
             if ($89) {
              $tab$0$i = 89032;
             } else {
              HEAP32[$9>>2] = 1;
              $20 = (($13) - ($14))|0;
              HEAP32[$12>>2] = $20;
              $21 = (($17) - ($18))|0;
              HEAP32[$16>>2] = $21;
              $22 = (($24) - ($23))|0;
              HEAP32[$25>>2] = $22;
              $26 = (($28) - ($27))|0;
              HEAP32[$29>>2] = $26;
              $30 = (($32) - ($31))|0;
              HEAP32[$33>>2] = $30;
              $34 = (($36) - ($35))|0;
              HEAP32[$37>>2] = $34;
              $38 = (($40) - ($39))|0;
              HEAP32[$41>>2] = $38;
              $42 = (($44) - ($43))|0;
              HEAP32[$45>>2] = $42;
              $46 = (($48) - ($47))|0;
              HEAP32[$49>>2] = $46;
              $50 = (($52) - ($51))|0;
              HEAP32[$53>>2] = $50;
              $tab$0$i = 89032;
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   } else {
    $tab$0$i = 89032;
   }
  }
  $54 = ((($cod_info)) + 4868|0);
  $55 = HEAP32[$54>>2]|0;
  $56 = ($55|0)>(0);
  if ($56) {
   $max_slen1$08$i = 0;$sfb$27$i = 0;
   while(1) {
    $61 = (((($cod_info)) + 4608|0) + ($sfb$27$i<<2)|0);
    $62 = HEAP32[$61>>2]|0;
    $63 = ($max_slen1$08$i|0)<($62|0);
    $$max_slen1$0$i = $63 ? $62 : $max_slen1$08$i;
    $64 = (($sfb$27$i) + 1)|0;
    $exitcond16 = ($64|0)==($55|0);
    if ($exitcond16) {
     $$max_slen1$0$i$lcssa = $$max_slen1$0$i;
     break;
    } else {
     $max_slen1$08$i = $$max_slen1$0$i;$sfb$27$i = $64;
    }
   }
   $57 = ($55|0)>(1);
   $smax$i = $57 ? $55 : 1;
   $max_slen1$0$lcssa$i = $$max_slen1$0$i$lcssa;$sfb$2$lcssa$i = $smax$i;
  } else {
   $max_slen1$0$lcssa$i = 0;$sfb$2$lcssa$i = 0;
  }
  $58 = ((($cod_info)) + 4860|0);
  $59 = HEAP32[$58>>2]|0;
  $60 = ($sfb$2$lcssa$i|0)<($59|0);
  if ($60) {
   $max_slen2$06$i = 0;$sfb$35$i = $sfb$2$lcssa$i;
   while(1) {
    $65 = (((($cod_info)) + 4608|0) + ($sfb$35$i<<2)|0);
    $66 = HEAP32[$65>>2]|0;
    $67 = ($max_slen2$06$i|0)<($66|0);
    $$max_slen2$0$i = $67 ? $66 : $max_slen2$06$i;
    $68 = (($sfb$35$i) + 1)|0;
    $exitcond = ($68|0)==($59|0);
    if ($exitcond) {
     $max_slen2$0$lcssa$i = $$max_slen2$0$i;
     break;
    } else {
     $max_slen2$06$i = $$max_slen2$0$i;$sfb$35$i = $68;
    }
   }
  } else {
   $max_slen2$0$lcssa$i = 0;
  }
  $69 = ((($cod_info)) + 4844|0);
  HEAP32[$69>>2] = 100000;
  $70 = ((($cod_info)) + 4784|0);
  $79 = 100000;$k$04$i = 0;
  while(1) {
   $71 = (88776 + ($k$04$i<<2)|0);
   $72 = HEAP32[$71>>2]|0;
   $73 = ($max_slen1$0$lcssa$i|0)<($72|0);
   if ($73) {
    $74 = (88840 + ($k$04$i<<2)|0);
    $75 = HEAP32[$74>>2]|0;
    $76 = ($max_slen2$0$lcssa$i|0)<($75|0);
    if ($76) {
     $77 = (($tab$0$i) + ($k$04$i<<2)|0);
     $78 = HEAP32[$77>>2]|0;
     $80 = ($79|0)>($78|0);
     if ($80) {
      HEAP32[$69>>2] = $78;
      HEAP32[$70>>2] = $k$04$i;
      $224 = $78;
     } else {
      $224 = $79;
     }
    } else {
     $224 = $79;
    }
   } else {
    $224 = $79;
   }
   $81 = (($k$04$i) + 1)|0;
   $exitcond$i = ($81|0)==(16);
   if ($exitcond$i) {
    $$lcssa = $224;
    break;
   } else {
    $79 = $224;$k$04$i = $81;
   }
  }
  $90 = ($$lcssa|0)==(100000);
  $91 = $90&1;
  $$0 = $91;
  STACKTOP = sp;return ($$0|0);
 }
 $92 = ((($cod_info)) + 4832|0);
 $93 = HEAP32[$92>>2]|0;
 $94 = ($93|0)==(0);
 ;HEAP32[$max_sfac$i>>2]=0|0;HEAP32[$max_sfac$i+4>>2]=0|0;HEAP32[$max_sfac$i+8>>2]=0|0;HEAP32[$max_sfac$i+12>>2]=0|0;
 $$$i1 = $94 ? 0 : 2;
 $95 = ((($cod_info)) + 4788|0);
 $96 = HEAP32[$95>>2]|0;
 $97 = ($96|0)==(2);
 if ($97) {
  $partition$012$i = 0;$sfb$011$i = 0;
  while(1) {
   $101 = ((((11824 + (($$$i1*48)|0)|0)) + 16|0) + ($partition$012$i<<2)|0);
   $102 = HEAP32[$101>>2]|0;
   $103 = (($102|0) / 3)&-1;
   $104 = ($102|0)>(2);
   if ($104) {
    $105 = (($max_sfac$i) + ($partition$012$i<<2)|0);
    $106 = ($103|0)>(1);
    $$pre$i = HEAP32[$105>>2]|0;
    $111 = $$pre$i;$i$19$i = 0;$sfb$110$i = $sfb$011$i;
    while(1) {
     $107 = ($sfb$110$i*3)|0;
     $108 = (((($cod_info)) + 4608|0) + ($107<<2)|0);
     $109 = HEAP32[$108>>2]|0;
     $110 = ($109|0)>($111|0);
     if ($110) {
      HEAP32[$105>>2] = $109;
      $116 = $109;
     } else {
      $116 = $111;
     }
     $112 = (($107) + 1)|0;
     $113 = (((($cod_info)) + 4608|0) + ($112<<2)|0);
     $114 = HEAP32[$113>>2]|0;
     $115 = ($114|0)>($116|0);
     if ($115) {
      HEAP32[$105>>2] = $114;
      $191 = $114;
     } else {
      $191 = $116;
     }
     $187 = (($107) + 2)|0;
     $188 = (((($cod_info)) + 4608|0) + ($187<<2)|0);
     $189 = HEAP32[$188>>2]|0;
     $190 = ($189|0)>($191|0);
     if ($190) {
      HEAP32[$105>>2] = $189;
      $228 = $189;
     } else {
      $228 = $191;
     }
     $192 = (($i$19$i) + 1)|0;
     $193 = (($sfb$110$i) + 1)|0;
     $194 = ($192|0)<($103|0);
     if ($194) {
      $111 = $228;$i$19$i = $192;$sfb$110$i = $193;
     } else {
      break;
     }
    }
    $smax$i3 = $106 ? $103 : 1;
    $117 = (($smax$i3) + ($sfb$011$i))|0;
    $sfb$1$lcssa$i = $117;
   } else {
    $sfb$1$lcssa$i = $sfb$011$i;
   }
   $118 = (($partition$012$i) + 1)|0;
   $exitcond$i6 = ($118|0)==(4);
   if ($exitcond$i6) {
    break;
   } else {
    $partition$012$i = $118;$sfb$011$i = $sfb$1$lcssa$i;
   }
  }
  $$pre28$i = HEAP32[$max_sfac$i>>2]|0;
  $$phi$trans$insert29$i = ((($max_sfac$i)) + 4|0);
  $$pre30$i = HEAP32[$$phi$trans$insert29$i>>2]|0;
  $$phi$trans$insert31$i = ((($max_sfac$i)) + 8|0);
  $$pre32$i = HEAP32[$$phi$trans$insert31$i>>2]|0;
  $$phi$trans$insert33$i = ((($max_sfac$i)) + 12|0);
  $$pre34$i = HEAP32[$$phi$trans$insert33$i>>2]|0;
  $129 = $$pre28$i;$134 = $$pre30$i;$139 = $$pre32$i;$144 = $$pre34$i;$row_in_table$0$i = 1;
 } else {
  $98 = (11824 + (($$$i1*48)|0)|0);
  $99 = HEAP32[$98>>2]|0;
  $100 = ($99|0)>(0);
  if ($100) {
   $122 = 0;$sfb$314$i = 0;
   while(1) {
    $119 = (((($cod_info)) + 4608|0) + ($sfb$314$i<<2)|0);
    $120 = HEAP32[$119>>2]|0;
    $121 = ($120|0)>($122|0);
    if ($121) {
     HEAP32[$max_sfac$i>>2] = $120;
     $226 = $120;
    } else {
     $226 = $122;
    }
    $123 = (($sfb$314$i) + 1)|0;
    $exitcond23$i = ($123|0)==($99|0);
    if ($exitcond23$i) {
     $225 = $226;$sfb$3$lcssa$i = $99;
     break;
    } else {
     $122 = $226;$sfb$314$i = $123;
    }
   }
  } else {
   $225 = 0;$sfb$3$lcssa$i = 0;
  }
  $124 = (((11824 + (($$$i1*48)|0)|0)) + 4|0);
  $125 = HEAP32[$124>>2]|0;
  $126 = ($125|0)>(0);
  if ($126) {
   $195 = ((($max_sfac$i)) + 4|0);
   $199 = 0;$i$213$1$i = 0;$sfb$314$1$i = $sfb$3$lcssa$i;
   while(1) {
    $196 = (((($cod_info)) + 4608|0) + ($sfb$314$1$i<<2)|0);
    $197 = HEAP32[$196>>2]|0;
    $198 = ($197|0)>($199|0);
    if ($198) {
     HEAP32[$195>>2] = $197;
     $229 = $197;
    } else {
     $229 = $199;
    }
    $200 = (($i$213$1$i) + 1)|0;
    $201 = (($sfb$314$1$i) + 1)|0;
    $exitcond23$1$i = ($200|0)==($125|0);
    if ($exitcond23$1$i) {
     $$lcssa31 = $229;
     break;
    } else {
     $199 = $229;$i$213$1$i = $200;$sfb$314$1$i = $201;
    }
   }
   $202 = (($125) + ($sfb$3$lcssa$i))|0;
   $227 = $$lcssa31;$sfb$3$lcssa$1$i = $202;
  } else {
   $227 = 0;$sfb$3$lcssa$1$i = $sfb$3$lcssa$i;
  }
  $203 = (((11824 + (($$$i1*48)|0)|0)) + 8|0);
  $204 = HEAP32[$203>>2]|0;
  $205 = ($204|0)>(0);
  if ($205) {
   $206 = ((($max_sfac$i)) + 8|0);
   $210 = 0;$i$213$2$i = 0;$sfb$314$2$i = $sfb$3$lcssa$1$i;
   while(1) {
    $207 = (((($cod_info)) + 4608|0) + ($sfb$314$2$i<<2)|0);
    $208 = HEAP32[$207>>2]|0;
    $209 = ($208|0)>($210|0);
    if ($209) {
     HEAP32[$206>>2] = $208;
     $231 = $208;
    } else {
     $231 = $210;
    }
    $211 = (($i$213$2$i) + 1)|0;
    $212 = (($sfb$314$2$i) + 1)|0;
    $exitcond23$2$i = ($211|0)==($204|0);
    if ($exitcond23$2$i) {
     $$lcssa30 = $231;
     break;
    } else {
     $210 = $231;$i$213$2$i = $211;$sfb$314$2$i = $212;
    }
   }
   $213 = (($204) + ($sfb$3$lcssa$1$i))|0;
   $230 = $$lcssa30;$sfb$3$lcssa$2$i = $213;
  } else {
   $230 = 0;$sfb$3$lcssa$2$i = $sfb$3$lcssa$1$i;
  }
  $214 = (((11824 + (($$$i1*48)|0)|0)) + 12|0);
  $215 = HEAP32[$214>>2]|0;
  $216 = ($215|0)>(0);
  if ($216) {
   $217 = ((($max_sfac$i)) + 12|0);
   $221 = 0;$i$213$3$i = 0;$sfb$314$3$i = $sfb$3$lcssa$2$i;
   while(1) {
    $218 = (((($cod_info)) + 4608|0) + ($sfb$314$3$i<<2)|0);
    $219 = HEAP32[$218>>2]|0;
    $220 = ($219|0)>($221|0);
    if ($220) {
     HEAP32[$217>>2] = $219;
     $232 = $219;
    } else {
     $232 = $221;
    }
    $222 = (($i$213$3$i) + 1)|0;
    $223 = (($sfb$314$3$i) + 1)|0;
    $exitcond23$3$i = ($222|0)==($215|0);
    if ($exitcond23$3$i) {
     $129 = $225;$134 = $227;$139 = $230;$144 = $232;$row_in_table$0$i = 0;
     break;
    } else {
     $221 = $232;$i$213$3$i = $222;$sfb$314$3$i = $223;
    }
   }
  } else {
   $129 = $225;$134 = $227;$139 = $230;$144 = 0;$row_in_table$0$i = 0;
  }
 }
 $127 = (89096 + ($$$i1<<4)|0);
 $128 = HEAP32[$127>>2]|0;
 $130 = ($129|0)>($128|0);
 $131 = $130&1;
 $132 = (((89096 + ($$$i1<<4)|0)) + 4|0);
 $133 = HEAP32[$132>>2]|0;
 $135 = ($134|0)>($133|0);
 $136 = $135&1;
 $$over$0$1$i = (($136) + ($131))|0;
 $137 = (((89096 + ($$$i1<<4)|0)) + 8|0);
 $138 = HEAP32[$137>>2]|0;
 $140 = ($139|0)>($138|0);
 $141 = $140&1;
 $$over$0$2$i = (($$over$0$1$i) + ($141))|0;
 $142 = (((89096 + ($$$i1<<4)|0)) + 12|0);
 $143 = HEAP32[$142>>2]|0;
 $145 = ($144|0)>($143|0);
 $146 = $145&1;
 $$over$0$3$i = (($$over$0$2$i) + ($146))|0;
 $147 = ($$over$0$3$i|0)==(0);
 if ($147) {
  $148 = ((11824 + (($$$i1*48)|0)|0) + ($row_in_table$0$i<<4)|0);
  $149 = ((($cod_info)) + 5188|0);
  HEAP32[$149>>2] = $148;
  $150 = (89192 + ($129<<2)|0);
  $151 = HEAP32[$150>>2]|0;
  $152 = ((($cod_info)) + 5192|0);
  HEAP32[$152>>2] = $151;
  $153 = (89192 + ($134<<2)|0);
  $154 = HEAP32[$153>>2]|0;
  $155 = ((($cod_info)) + 5196|0);
  HEAP32[$155>>2] = $154;
  $156 = (89192 + ($139<<2)|0);
  $157 = HEAP32[$156>>2]|0;
  $158 = ((($cod_info)) + 5200|0);
  HEAP32[$158>>2] = $157;
  $159 = (89192 + ($144<<2)|0);
  $160 = HEAP32[$159>>2]|0;
  $161 = ((($cod_info)) + 5204|0);
  HEAP32[$161>>2] = $160;
  if ($94) {
   $162 = ($151*5)|0;
   $163 = (($162) + ($154))|0;
   $164 = $163 << 4;
   $165 = $157 << 2;
   $166 = (($165) + ($164))|0;
   $167 = (($166) + ($160))|0;
   $$sink$i = $167;
  } else {
   $168 = ($151*3)|0;
   $169 = (($168) + 500)|0;
   $170 = (($169) + ($154))|0;
   $$sink$i = $170;
  }
  $171 = ((($cod_info)) + 4784|0);
  HEAP32[$171>>2] = $$sink$i;
  $172 = ((($cod_info)) + 4844|0);
  $173 = HEAP32[$148>>2]|0;
  $174 = Math_imul($173, $151)|0;
  $175 = ((((11824 + (($$$i1*48)|0)|0) + ($row_in_table$0$i<<4)|0)) + 4|0);
  $176 = HEAP32[$175>>2]|0;
  $177 = Math_imul($176, $154)|0;
  $178 = (($177) + ($174))|0;
  $179 = ((((11824 + (($$$i1*48)|0)|0) + ($row_in_table$0$i<<4)|0)) + 8|0);
  $180 = HEAP32[$179>>2]|0;
  $181 = Math_imul($180, $157)|0;
  $182 = (($178) + ($181))|0;
  $183 = ((((11824 + (($$$i1*48)|0)|0) + ($row_in_table$0$i<<4)|0)) + 12|0);
  $184 = HEAP32[$183>>2]|0;
  $185 = Math_imul($184, $160)|0;
  $186 = (($182) + ($185))|0;
  HEAP32[$172>>2] = $186;
 }
 $$0 = $$over$0$3$i;
 STACKTOP = sp;return ($$0|0);
}
function _huffman_init($gfc) {
 $gfc = $gfc|0;
 var $$bv_index$0$lcssa = 0, $$bv_index$2$lcssa = 0, $$lcssa = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 var $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $bv_index$0 = 0, $bv_index$0$lcssa = 0, $bv_index$2 = 0, $bv_index$2$lcssa = 0, $i$01 = 0, $scfb_anz$0 = 0;
 var $sext = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gfc)) + 85816|0);
 HEAP32[$0>>2] = 2;
 $i$01 = 2;
 while(1) {
  $scfb_anz$0 = 0;
  while(1) {
   $1 = (($scfb_anz$0) + 1)|0;
   $2 = (((($gfc)) + 21360|0) + ($1<<2)|0);
   $3 = HEAP32[$2>>2]|0;
   $4 = ($3|0)<($i$01|0);
   if ($4) {
    $scfb_anz$0 = $1;
   } else {
    $$lcssa = $1;
    break;
   }
  }
  $5 = (89256 + ($$lcssa<<3)|0);
  $6 = HEAP32[$5>>2]|0;
  $bv_index$0 = $6;
  while(1) {
   $7 = (($bv_index$0) + 1)|0;
   $8 = (((($gfc)) + 21360|0) + ($7<<2)|0);
   $9 = HEAP32[$8>>2]|0;
   $10 = ($9|0)>($i$01|0);
   $11 = (($bv_index$0) + -1)|0;
   if ($10) {
    $bv_index$0 = $11;
   } else {
    $bv_index$0$lcssa = $bv_index$0;
    break;
   }
  }
  $12 = ($bv_index$0$lcssa|0)<(0);
  $$bv_index$0$lcssa = $12 ? $6 : $bv_index$0$lcssa;
  $13 = $$bv_index$0$lcssa&255;
  $14 = (($i$01) + -2)|0;
  $15 = (((($gfc)) + 85100|0) + ($14)|0);
  HEAP8[$15>>0] = $13;
  $16 = (((89256 + ($$lcssa<<3)|0)) + 4|0);
  $17 = HEAP32[$16>>2]|0;
  $sext = $$bv_index$0$lcssa << 24;
  $18 = $sext >> 24;
  $bv_index$2 = $17;
  while(1) {
   $19 = (($bv_index$2) + 2)|0;
   $20 = (($19) + ($18))|0;
   $21 = (((($gfc)) + 21360|0) + ($20<<2)|0);
   $22 = HEAP32[$21>>2]|0;
   $23 = ($22|0)>($i$01|0);
   $24 = (($bv_index$2) + -1)|0;
   if ($23) {
    $bv_index$2 = $24;
   } else {
    $bv_index$2$lcssa = $bv_index$2;
    break;
   }
  }
  $25 = ($bv_index$2$lcssa|0)<(0);
  $$bv_index$2$lcssa = $25 ? $17 : $bv_index$2$lcssa;
  $26 = $$bv_index$2$lcssa&255;
  $27 = (($i$01) + -1)|0;
  $28 = (((($gfc)) + 85100|0) + ($27)|0);
  HEAP8[$28>>0] = $26;
  $29 = (($i$01) + 2)|0;
  $30 = ($29|0)<(577);
  if ($30) {
   $i$01 = $29;
  } else {
   break;
  }
 }
 return;
}
function _quantize_lines_xrpow($l,$istep,$xp,$pi) {
 $l = $l|0;
 $istep = +$istep;
 $xp = $xp|0;
 $pi = $pi|0;
 var $$01$lcssa = 0, $$013 = 0, $$04 = 0, $0 = 0, $1 = 0, $10 = 0.0, $100 = 0, $11 = 0.0, $12 = 0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0;
 var $23 = 0.0, $24 = 0, $25 = 0.0, $26 = 0.0, $27 = 0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0, $39 = 0, $4 = 0, $40 = 0;
 var $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0, $46 = 0, $47 = 0, $48 = 0.0, $49 = 0.0, $5 = 0.0, $50 = 0.0, $51 = 0.0, $52 = 0, $53 = 0, $54 = 0, $55 = 0.0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0;
 var $6 = 0.0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0.0, $70 = 0, $71 = 0.0, $72 = 0.0, $73 = 0.0, $74 = 0, $75 = 0.0, $76 = 0.0, $77 = 0.0;
 var $78 = 0.0, $79 = 0.0, $8 = 0, $80 = 0.0, $81 = 0.0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0.0, $87 = 0.0, $88 = 0.0, $89 = 0.0, $9 = 0.0, $90 = 0, $91 = 0, $92 = 0, $93 = 0.0, $94 = 0.0, $95 = 0.0;
 var $96 = 0.0, $97 = 0, $98 = 0, $99 = 0, $fi$0$lcssa = 0, $fi$02 = 0, $scevgep = 0, $scevgep7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = $l & 2;
 $1 = $l >>> 2;
 $2 = ($1|0)==(0);
 if ($2) {
  $$01$lcssa = $xp;$fi$0$lcssa = $pi;
 } else {
  $3 = $1 << 2;
  $scevgep7 = (($pi) + ($3<<2)|0);
  $$013 = $xp;$$04 = $1;$fi$02 = $pi;
  while(1) {
   $4 = (($$04) + -1)|0;
   $5 = +HEAPF32[$$013>>2];
   $6 = $5 * $istep;
   $7 = $6;
   $8 = ((($$013)) + 4|0);
   $9 = +HEAPF32[$8>>2];
   $10 = $9 * $istep;
   $11 = $10;
   $12 = ((($$013)) + 8|0);
   $13 = +HEAPF32[$12>>2];
   $14 = $13 * $istep;
   $15 = $14;
   $16 = ((($$013)) + 12|0);
   $17 = +HEAPF32[$16>>2];
   $18 = $17 * $istep;
   $19 = $18;
   $20 = $7 + 8388608.0;
   $21 = $20;
   $22 = $11 + 8388608.0;
   $23 = $22;
   $24 = ((($fi$02)) + 4|0);
   $25 = $15 + 8388608.0;
   $26 = $25;
   $27 = ((($fi$02)) + 8|0);
   $28 = $19 + 8388608.0;
   $29 = $28;
   $30 = ((($fi$02)) + 12|0);
   $31 = (HEAPF32[tempDoublePtr>>2]=$21,HEAP32[tempDoublePtr>>2]|0);
   $32 = (($31) + -1258291200)|0;
   $33 = (46872 + ($32<<2)|0);
   $34 = +HEAPF32[$33>>2];
   $35 = $34;
   $36 = $35 + $20;
   $37 = $36;
   $38 = (HEAPF32[tempDoublePtr>>2]=$23,HEAP32[tempDoublePtr>>2]|0);
   $39 = (($38) + -1258291200)|0;
   $40 = (46872 + ($39<<2)|0);
   $41 = +HEAPF32[$40>>2];
   $42 = $41;
   $43 = $42 + $22;
   $44 = $43;
   $45 = (HEAPF32[tempDoublePtr>>2]=$26,HEAP32[tempDoublePtr>>2]|0);
   $46 = (($45) + -1258291200)|0;
   $47 = (46872 + ($46<<2)|0);
   $48 = +HEAPF32[$47>>2];
   $49 = $48;
   $50 = $49 + $25;
   $51 = $50;
   $52 = (HEAPF32[tempDoublePtr>>2]=$29,HEAP32[tempDoublePtr>>2]|0);
   $53 = (($52) + -1258291200)|0;
   $54 = (46872 + ($53<<2)|0);
   $55 = +HEAPF32[$54>>2];
   $56 = $55;
   $57 = $56 + $28;
   $58 = $57;
   $59 = (HEAPF32[tempDoublePtr>>2]=$37,HEAP32[tempDoublePtr>>2]|0);
   $60 = (($59) + -1258291200)|0;
   HEAP32[$fi$02>>2] = $60;
   $61 = (HEAPF32[tempDoublePtr>>2]=$44,HEAP32[tempDoublePtr>>2]|0);
   $62 = (($61) + -1258291200)|0;
   HEAP32[$24>>2] = $62;
   $63 = (HEAPF32[tempDoublePtr>>2]=$51,HEAP32[tempDoublePtr>>2]|0);
   $64 = (($63) + -1258291200)|0;
   HEAP32[$27>>2] = $64;
   $65 = (HEAPF32[tempDoublePtr>>2]=$58,HEAP32[tempDoublePtr>>2]|0);
   $66 = (($65) + -1258291200)|0;
   HEAP32[$30>>2] = $66;
   $67 = ((($fi$02)) + 16|0);
   $68 = ((($$013)) + 16|0);
   $69 = ($4|0)==(0);
   if ($69) {
    break;
   } else {
    $$013 = $68;$$04 = $4;$fi$02 = $67;
   }
  }
  $scevgep = (($xp) + ($3<<2)|0);
  $$01$lcssa = $scevgep;$fi$0$lcssa = $scevgep7;
 }
 $70 = ($0|0)==(0);
 if ($70) {
  return;
 }
 $71 = +HEAPF32[$$01$lcssa>>2];
 $72 = $71 * $istep;
 $73 = $72;
 $74 = ((($$01$lcssa)) + 4|0);
 $75 = +HEAPF32[$74>>2];
 $76 = $75 * $istep;
 $77 = $76;
 $78 = $73 + 8388608.0;
 $79 = $78;
 $80 = $77 + 8388608.0;
 $81 = $80;
 $82 = ((($fi$0$lcssa)) + 4|0);
 $83 = (HEAPF32[tempDoublePtr>>2]=$79,HEAP32[tempDoublePtr>>2]|0);
 $84 = (($83) + -1258291200)|0;
 $85 = (46872 + ($84<<2)|0);
 $86 = +HEAPF32[$85>>2];
 $87 = $86;
 $88 = $87 + $78;
 $89 = $88;
 $90 = (HEAPF32[tempDoublePtr>>2]=$81,HEAP32[tempDoublePtr>>2]|0);
 $91 = (($90) + -1258291200)|0;
 $92 = (46872 + ($91<<2)|0);
 $93 = +HEAPF32[$92>>2];
 $94 = $93;
 $95 = $94 + $80;
 $96 = $95;
 $97 = (HEAPF32[tempDoublePtr>>2]=$89,HEAP32[tempDoublePtr>>2]|0);
 $98 = (($97) + -1258291200)|0;
 HEAP32[$fi$0$lcssa>>2] = $98;
 $99 = (HEAPF32[tempDoublePtr>>2]=$96,HEAP32[tempDoublePtr>>2]|0);
 $100 = (($99) + -1258291200)|0;
 HEAP32[$82>>2] = $100;
 return;
}
function _choose_table_nonMMX($ix,$end,$_s) {
 $ix = $ix|0;
 $end = $end|0;
 $_s = $_s|0;
 var $$0 = 0, $$0$i = 0, $$0$i1 = 0, $$2$i = 0, $$lcssa = 0, $$max1$0$i = 0, $$max1$0$i$lcssa = 0, $$op$i = 0, $$sum$0$i = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 var $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0;
 var $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0;
 var $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $7 = 0, $8 = 0, $9 = 0, $choice$0$lcssa = 0, $choice$02 = 0, $choice2$0$lcssa$ph = 0, $choice2$0$lcssa8 = 0, $max1$0$i = 0, $max2$0$i = 0, $max2$1$$max1$0$i = 0, $max2$1$i = 0, $max2$1$i$lcssa = 0, $sum$0$i = 0;
 var $sum$2$i = 0, $t2$t1$i = 0, $y$0$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $$0$i = $ix;$max1$0$i = 0;$max2$0$i = 0;
 while(1) {
  $0 = ((($$0$i)) + 4|0);
  $1 = HEAP32[$$0$i>>2]|0;
  $2 = ((($$0$i)) + 8|0);
  $3 = HEAP32[$0>>2]|0;
  $4 = ($max1$0$i|0)<($1|0);
  $$max1$0$i = $4 ? $1 : $max1$0$i;
  $5 = ($max2$0$i|0)<($3|0);
  $max2$1$i = $5 ? $3 : $max2$0$i;
  $6 = ($2>>>0)<($end>>>0);
  if ($6) {
   $$0$i = $2;$max1$0$i = $$max1$0$i;$max2$0$i = $max2$1$i;
  } else {
   $$max1$0$i$lcssa = $$max1$0$i;$max2$1$i$lcssa = $max2$1$i;
   break;
  }
 }
 $7 = ($$max1$0$i$lcssa|0)<($max2$1$i$lcssa|0);
 $max2$1$$max1$0$i = $7 ? $max2$1$i$lcssa : $$max1$0$i$lcssa;
 $8 = ($max2$1$$max1$0$i>>>0)<(16);
 if ($8) {
  $9 = (89440 + ($max2$1$$max1$0$i<<2)|0);
  $10 = HEAP32[$9>>2]|0;
  $11 = (FUNCTION_TABLE_iiiii[$10 & 7]($ix,$end,$max2$1$$max1$0$i,$_s)|0);
  $$0 = $11;
  return ($$0|0);
 }
 $12 = ($max2$1$$max1$0$i>>>0)>(8206);
 if ($12) {
  HEAP32[$_s>>2] = 100000;
  $$0 = -1;
  return ($$0|0);
 }
 $13 = (($max2$1$$max1$0$i) + -15)|0;
 $14 = HEAP32[(82660)>>2]|0;
 $15 = ($14>>>0)<($13>>>0);
 if ($15) {
  $16 = HEAP32[(82676)>>2]|0;
  $17 = ($16>>>0)<($13>>>0);
  if ($17) {
   $49 = HEAP32[(82692)>>2]|0;
   $50 = ($49>>>0)<($13>>>0);
   if ($50) {
    $51 = HEAP32[(82708)>>2]|0;
    $52 = ($51>>>0)<($13>>>0);
    if ($52) {
     $53 = HEAP32[(82724)>>2]|0;
     $54 = ($53>>>0)<($13>>>0);
     if ($54) {
      $55 = HEAP32[(82740)>>2]|0;
      $56 = ($55>>>0)<($13>>>0);
      if ($56) {
       $57 = HEAP32[(82756)>>2]|0;
       $58 = ($57>>>0)<($13>>>0);
       if ($58) {
        $59 = HEAP32[(82772)>>2]|0;
        $60 = ($59>>>0)<($13>>>0);
        if ($60) {
         $choice$0$lcssa = 24;$choice2$0$lcssa8 = 32;
        } else {
         $choice2$0$lcssa$ph = 31;
         label = 9;
        }
       } else {
        $choice2$0$lcssa$ph = 30;
        label = 9;
       }
      } else {
       $choice2$0$lcssa$ph = 29;
       label = 9;
      }
     } else {
      $choice2$0$lcssa$ph = 28;
      label = 9;
     }
    } else {
     $choice2$0$lcssa$ph = 27;
     label = 9;
    }
   } else {
    $choice2$0$lcssa$ph = 26;
    label = 9;
   }
  } else {
   $choice2$0$lcssa$ph = 25;
   label = 9;
  }
 } else {
  $choice2$0$lcssa$ph = 24;
  label = 9;
 }
 L20: do {
  if ((label|0) == 9) {
   $18 = (($choice2$0$lcssa$ph) + -8)|0;
   $choice$02 = $18;
   while(1) {
    $19 = (((82272 + ($choice$02<<4)|0)) + 4|0);
    $20 = HEAP32[$19>>2]|0;
    $21 = ($20>>>0)<($13>>>0);
    if (!($21)) {
     $choice$0$lcssa = $choice$02;$choice2$0$lcssa8 = $choice2$0$lcssa$ph;
     break L20;
    }
    $22 = (($choice$02) + 1)|0;
    $23 = ($22|0)<(24);
    if ($23) {
     $choice$02 = $22;
    } else {
     $choice$0$lcssa = $22;$choice2$0$lcssa8 = $choice2$0$lcssa$ph;
     break;
    }
   }
  }
 } while(0);
 $24 = (82272 + ($choice$0$lcssa<<4)|0);
 $25 = HEAP32[$24>>2]|0;
 $26 = $25 << 16;
 $27 = (82272 + ($choice2$0$lcssa8<<4)|0);
 $28 = HEAP32[$27>>2]|0;
 $29 = (($26) + ($28))|0;
 $$0$i1 = $ix;$sum$0$i = 0;
 while(1) {
  $30 = ((($$0$i1)) + 4|0);
  $31 = HEAP32[$$0$i1>>2]|0;
  $32 = ((($$0$i1)) + 8|0);
  $33 = HEAP32[$30>>2]|0;
  $34 = ($31>>>0)>(14);
  $35 = $34 ? $29 : 0;
  $$sum$0$i = (($35) + ($sum$0$i))|0;
  $36 = ($33>>>0)>(14);
  $37 = $36 ? $29 : 0;
  $y$0$i = $36 ? 15 : $33;
  $$op$i = $31 << 4;
  $38 = $34 ? 240 : $$op$i;
  $39 = (($y$0$i) + ($38))|0;
  $40 = (82816 + ($39<<2)|0);
  $41 = HEAP32[$40>>2]|0;
  $sum$2$i = (($$sum$0$i) + ($41))|0;
  $42 = (($sum$2$i) + ($37))|0;
  $43 = ($32>>>0)<($end>>>0);
  if ($43) {
   $$0$i1 = $32;$sum$0$i = $42;
  } else {
   $$lcssa = $42;
   break;
  }
 }
 $44 = $$lcssa & 65535;
 $45 = $$lcssa >>> 16;
 $46 = ($45>>>0)>($44>>>0);
 $t2$t1$i = $46 ? $choice2$0$lcssa8 : $choice$0$lcssa;
 $$2$i = $46 ? $44 : $45;
 $47 = HEAP32[$_s>>2]|0;
 $48 = (($47) + ($$2$i))|0;
 HEAP32[$_s>>2] = $48;
 $$0 = $t2$t1$i;
 return ($$0|0);
}
function _count_bit_null($ix,$end,$max,$s) {
 $ix = $ix|0;
 $end = $end|0;
 $max = $max|0;
 $s = $s|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return 0;
}
function _count_bit_noESC($ix,$end,$mx,$s) {
 $ix = $ix|0;
 $end = $end|0;
 $mx = $mx|0;
 $s = $s|0;
 var $$0 = 0, $$lcssa = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $sum1$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = HEAP32[(82300)>>2]|0;
 $$0 = $ix;$sum1$0 = 0;
 while(1) {
  $1 = ((($$0)) + 4|0);
  $2 = HEAP32[$$0>>2]|0;
  $3 = ((($$0)) + 8|0);
  $4 = HEAP32[$1>>2]|0;
  $5 = $2 << 1;
  $6 = (($5) + ($4))|0;
  $7 = (($0) + ($6)|0);
  $8 = HEAP8[$7>>0]|0;
  $9 = $8&255;
  $10 = (($9) + ($sum1$0))|0;
  $11 = ($3>>>0)<($end>>>0);
  if ($11) {
   $$0 = $3;$sum1$0 = $10;
  } else {
   $$lcssa = $10;
   break;
  }
 }
 $12 = HEAP32[$s>>2]|0;
 $13 = (($12) + ($$lcssa))|0;
 HEAP32[$s>>2] = $13;
 return 1;
}
function _count_bit_noESC_from2($ix,$end,$max,$s) {
 $ix = $ix|0;
 $end = $end|0;
 $max = $max|0;
 $s = $s|0;
 var $$ = 0, $$0 = 0, $$1 = 0, $$lcssa = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $sum$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (($max) + -1)|0;
 $1 = (89504 + ($0<<2)|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = (82272 + ($2<<4)|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ($0|0)==(1);
 $6 = $5 ? 83840 : 83880;
 $$0 = $ix;$sum$0 = 0;
 while(1) {
  $7 = ((($$0)) + 4|0);
  $8 = HEAP32[$$0>>2]|0;
  $9 = ((($$0)) + 8|0);
  $10 = HEAP32[$7>>2]|0;
  $11 = Math_imul($8, $4)|0;
  $12 = (($11) + ($10))|0;
  $13 = (($6) + ($12<<2)|0);
  $14 = HEAP32[$13>>2]|0;
  $15 = (($14) + ($sum$0))|0;
  $16 = ($9>>>0)<($end>>>0);
  if ($16) {
   $$0 = $9;$sum$0 = $15;
  } else {
   $$lcssa = $15;
   break;
  }
 }
 $17 = $$lcssa & 65535;
 $18 = $$lcssa >>> 16;
 $19 = ($18>>>0)>($17>>>0);
 $$ = $19 ? $17 : $18;
 $20 = $19&1;
 $$1 = (($20) + ($2))|0;
 $21 = HEAP32[$s>>2]|0;
 $22 = (($21) + ($$))|0;
 HEAP32[$s>>2] = $22;
 return ($$1|0);
}
function _count_bit_noESC_from3($ix,$end,$max,$s) {
 $ix = $ix|0;
 $end = $end|0;
 $max = $max|0;
 $s = $s|0;
 var $$ = 0, $$0 = 0, $$1 = 0, $$lcssa = 0, $$lcssa12 = 0, $$lcssa13 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0;
 var $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0, $9 = 0, $sum1$0 = 0, $sum1$2 = 0, $sum2$0 = 0, $sum3$0 = 0, $t$1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (($max) + -1)|0;
 $1 = (89504 + ($0<<2)|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = (82272 + ($2<<4)|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = (((82272 + ($2<<4)|0)) + 12|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = (($2) + 1)|0;
 $8 = (((82272 + ($7<<4)|0)) + 12|0);
 $9 = HEAP32[$8>>2]|0;
 $10 = (($2) + 2)|0;
 $11 = (((82272 + ($10<<4)|0)) + 12|0);
 $12 = HEAP32[$11>>2]|0;
 $$0 = $ix;$sum1$0 = 0;$sum2$0 = 0;$sum3$0 = 0;
 while(1) {
  $13 = ((($$0)) + 4|0);
  $14 = HEAP32[$$0>>2]|0;
  $15 = ((($$0)) + 8|0);
  $16 = HEAP32[$13>>2]|0;
  $17 = Math_imul($14, $4)|0;
  $18 = (($17) + ($16))|0;
  $19 = (($6) + ($18)|0);
  $20 = HEAP8[$19>>0]|0;
  $21 = $20&255;
  $22 = (($21) + ($sum1$0))|0;
  $23 = (($9) + ($18)|0);
  $24 = HEAP8[$23>>0]|0;
  $25 = $24&255;
  $26 = (($25) + ($sum2$0))|0;
  $27 = (($12) + ($18)|0);
  $28 = HEAP8[$27>>0]|0;
  $29 = $28&255;
  $30 = (($29) + ($sum3$0))|0;
  $31 = ($15>>>0)<($end>>>0);
  if ($31) {
   $$0 = $15;$sum1$0 = $22;$sum2$0 = $26;$sum3$0 = $30;
  } else {
   $$lcssa = $22;$$lcssa12 = $26;$$lcssa13 = $30;
   break;
  }
 }
 $32 = ($$lcssa>>>0)>($$lcssa12>>>0);
 $$ = $32 ? $7 : $2;
 $$1 = $32 ? $$lcssa12 : $$lcssa;
 $33 = ($$1>>>0)>($$lcssa13>>>0);
 $t$1 = $33 ? $10 : $$;
 $sum1$2 = $33 ? $$lcssa13 : $$1;
 $34 = HEAP32[$s>>2]|0;
 $35 = (($34) + ($sum1$2))|0;
 HEAP32[$s>>2] = $35;
 return ($t$1|0);
}
function _free_id3tag($gfc) {
 $gfc = $gfc|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $node$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gfc)) + 85704|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($1|0)==(0|0);
 if (!($2)) {
  _free($1);
  HEAP32[$0>>2] = 0;
 }
 $3 = ((($gfc)) + 85708|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ($4|0)==(0|0);
 if (!($5)) {
  _free($4);
  HEAP32[$3>>2] = 0;
 }
 $6 = ((($gfc)) + 85712|0);
 $7 = HEAP32[$6>>2]|0;
 $8 = ($7|0)==(0|0);
 if (!($8)) {
  _free($7);
  HEAP32[$6>>2] = 0;
 }
 $9 = ((($gfc)) + 85716|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = ($10|0)==(0|0);
 if (!($11)) {
  _free($10);
  HEAP32[$9>>2] = 0;
 }
 $12 = ((($gfc)) + 85728|0);
 $13 = HEAP32[$12>>2]|0;
 $14 = ($13|0)==(0|0);
 if (!($14)) {
  _free($13);
  HEAP32[$12>>2] = 0;
  $15 = ((($gfc)) + 85732|0);
  HEAP32[$15>>2] = 0;
  $16 = ((($gfc)) + 85740|0);
  HEAP32[$16>>2] = 0;
 }
 $17 = ((($gfc)) + 85744|0);
 $18 = HEAP32[$17>>2]|0;
 $19 = ($18|0)==(0|0);
 if ($19) {
  return;
 } else {
  $node$0 = $18;
 }
 while(1) {
  $20 = ((($node$0)) + 12|0);
  $21 = HEAP32[$20>>2]|0;
  $22 = ((($node$0)) + 24|0);
  $23 = HEAP32[$22>>2]|0;
  $24 = HEAP32[$node$0>>2]|0;
  _free($21);
  _free($23);
  _free($node$0);
  $25 = ($24|0)==(0|0);
  if ($25) {
   break;
  } else {
   $node$0 = $24;
  }
 }
 HEAP32[$17>>2] = 0;
 $26 = ((($gfc)) + 85748|0);
 HEAP32[$26>>2] = 0;
 return;
}
function _freegfc($gfc) {
 $gfc = $gfc|0;
 var $$in$i = 0, $$pre$i = 0, $$pre1$i = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 var $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $exitcond = 0, $i$01 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $i$01 = 0;
 while(1) {
  $0 = (((($gfc)) + 37192|0) + ($i$01<<2)|0);
  $1 = HEAP32[$0>>2]|0;
  $2 = ($1|0)==(0|0);
  if (!($2)) {
   _free($1);
   HEAP32[$0>>2] = 0;
  }
  $3 = (($i$01) + 1)|0;
  $exitcond = ($3|0)==(641);
  if ($exitcond) {
   break;
  } else {
   $i$01 = $3;
  }
 }
 $4 = ((($gfc)) + 37184|0);
 $5 = HEAP32[$4>>2]|0;
 $6 = ($5|0)==(0|0);
 if (!($6)) {
  _free($5);
  HEAP32[$4>>2] = 0;
 }
 $7 = ((($gfc)) + 37188|0);
 $8 = HEAP32[$7>>2]|0;
 $9 = ($8|0)==(0|0);
 if (!($9)) {
  _free($8);
  HEAP32[$7>>2] = 0;
 }
 $10 = ((($gfc)) + 284|0);
 $11 = HEAP32[$10>>2]|0;
 $12 = ($11|0)==(0|0);
 if (!($12)) {
  _free($11);
  HEAP32[$10>>2] = 0;
 }
 $13 = ((($gfc)) + 85780|0);
 $14 = HEAP32[$13>>2]|0;
 $15 = ($14|0)==(0|0);
 if (!($15)) {
  _free($14);
  HEAP32[$13>>2] = 0;
  $16 = ((($gfc)) + 85776|0);
  HEAP32[$16>>2] = 0;
 }
 $17 = ((($gfc)) + 85796|0);
 $18 = HEAP32[$17>>2]|0;
 $19 = ($18|0)==(0|0);
 if (!($19)) {
  _free($18);
 }
 $20 = ((($gfc)) + 85676|0);
 $21 = HEAP32[$20>>2]|0;
 $22 = ($21|0)==(0|0);
 if (!($22)) {
  _free($21);
 }
 $23 = ((($gfc)) + 52152|0);
 $24 = HEAP32[$23>>2]|0;
 $25 = ($24|0)==(0|0);
 if (!($25)) {
  _free($24);
 }
 $26 = ((($gfc)) + 52156|0);
 $27 = HEAP32[$26>>2]|0;
 $28 = ($27|0)==(0|0);
 if (!($28)) {
  _free($27);
 }
 _free_id3tag($gfc);
 $29 = ((($gfc)) + 85808|0);
 $30 = HEAP32[$29>>2]|0;
 $31 = ($30|0)==(0|0);
 if (!($31)) {
  (_hip_decode_exit(($30|0))|0);
  HEAP32[$29>>2] = 0;
 }
 $32 = ((($gfc)) + 85800|0);
 $33 = HEAP32[$32>>2]|0;
 $34 = ($33|0)==(0|0);
 if ($34) {
  _free($gfc);
  return;
 }
 $35 = ((($33)) + 2156|0);
 $36 = HEAP32[$35>>2]|0;
 $37 = ($36|0)==(0|0);
 if ($37) {
  $$in$i = $33;
 } else {
  _free($36);
  $$pre$i = HEAP32[$32>>2]|0;
  $$in$i = $$pre$i;
 }
 $38 = ((($$in$i)) + 4316|0);
 $39 = HEAP32[$38>>2]|0;
 $40 = ($39|0)==(0|0);
 if ($40) {
  $41 = $$in$i;
 } else {
  _free($39);
  $$pre1$i = HEAP32[$32>>2]|0;
  $41 = $$pre1$i;
 }
 _free($41);
 _free($gfc);
 return;
}
function _ATHformula($cfg,$f) {
 $cfg = $cfg|0;
 $f = +$f;
 var $0 = 0, $1 = 0, $10 = 0.0, $100 = 0.0, $101 = 0.0, $102 = 0, $103 = 0.0, $104 = 0, $105 = 0.0, $106 = 0, $107 = 0.0, $108 = 0.0, $109 = 0.0, $11 = 0.0, $110 = 0.0, $111 = 0.0, $112 = 0.0, $113 = 0.0, $114 = 0.0, $115 = 0.0;
 var $116 = 0.0, $117 = 0.0, $118 = 0.0, $119 = 0.0, $12 = 0.0, $120 = 0.0, $121 = 0.0, $122 = 0.0, $123 = 0.0, $124 = 0.0, $125 = 0.0, $126 = 0.0, $127 = 0.0, $128 = 0, $129 = 0.0, $13 = 0.0, $130 = 0.0, $131 = 0, $132 = 0.0, $133 = 0;
 var $134 = 0.0, $135 = 0, $136 = 0.0, $137 = 0.0, $138 = 0.0, $139 = 0.0, $14 = 0.0, $140 = 0.0, $141 = 0.0, $142 = 0.0, $143 = 0.0, $144 = 0.0, $145 = 0.0, $146 = 0.0, $147 = 0.0, $148 = 0.0, $149 = 0.0, $15 = 0.0, $150 = 0.0, $151 = 0.0;
 var $152 = 0.0, $153 = 0.0, $154 = 0.0, $155 = 0.0, $156 = 0.0, $157 = 0.0, $158 = 0, $159 = 0.0, $16 = 0.0, $160 = 0, $161 = 0.0, $162 = 0, $163 = 0.0, $164 = 0.0, $165 = 0.0, $166 = 0.0, $167 = 0.0, $168 = 0.0, $169 = 0.0, $17 = 0.0;
 var $170 = 0.0, $171 = 0.0, $172 = 0.0, $173 = 0.0, $174 = 0.0, $175 = 0.0, $176 = 0.0, $177 = 0.0, $178 = 0.0, $179 = 0.0, $18 = 0.0, $180 = 0.0, $19 = 0.0, $2 = 0.0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0;
 var $26 = 0.0, $27 = 0, $28 = 0.0, $29 = 0, $3 = 0, $30 = 0.0, $31 = 0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0.0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0;
 var $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0, $52 = 0.0, $53 = 0, $54 = 0.0, $55 = 0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0.0, $6 = 0.0, $60 = 0.0, $61 = 0.0;
 var $62 = 0.0, $63 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0.0, $71 = 0.0, $72 = 0.0, $73 = 0.0, $74 = 0.0, $75 = 0, $76 = 0.0, $77 = 0, $78 = 0.0, $79 = 0, $8 = 0.0;
 var $80 = 0.0, $81 = 0.0, $82 = 0.0, $83 = 0.0, $84 = 0.0, $85 = 0.0, $86 = 0.0, $87 = 0.0, $88 = 0.0, $89 = 0.0, $9 = 0.0, $90 = 0.0, $91 = 0.0, $92 = 0.0, $93 = 0.0, $94 = 0.0, $95 = 0.0, $96 = 0.0, $97 = 0.0, $98 = 0.0;
 var $99 = 0, $ath$0 = 0.0, $f$op$i = 0.0, $f$op$i1 = 0.0, $f$op$i10 = 0.0, $f$op$i13 = 0.0, $f$op$i16 = 0.0, $f$op$i4 = 0.0, $f$op$i7 = 0.0, $pow2$i = 0.0, $pow2$i11 = 0.0, $pow2$i14 = 0.0, $pow2$i17 = 0.0, $pow2$i2 = 0.0, $pow2$i5 = 0.0, $pow2$i8 = 0.0, $pow21$i = 0.0, $pow21$i12 = 0.0, $pow21$i15 = 0.0, $pow21$i18 = 0.0;
 var $pow21$i3 = 0.0, $pow21$i6 = 0.0, $pow21$i9 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($cfg)) + 192|0);
 $1 = HEAP32[$0>>2]|0;
 switch ($1|0) {
 case 5:  {
  $128 = ((($cfg)) + 188|0);
  $129 = +HEAPF32[$128>>2];
  $130 = $f;
  $131 = $130 < -0.29999999999999999;
  $f$op$i13 = $f * 0.0010000000474974513;
  $132 = $131 ? 3.4100000858306885 : $f$op$i13;
  $133 = $132 < 3.4100000858306885;
  $134 = $133 ? 3.4100000858306885 : $132;
  $135 = $134 > 16.100000381469727;
  $136 = $134;
  $137 = $135 ? 16.100000381469727 : $136;
  $138 = (+Math_pow((+$137),-0.80000000000000004));
  $139 = $138 * 3.6400000000000001;
  $140 = $137 + -3.3999999999999999;
  $pow2$i14 = $140 * $140;
  $141 = $pow2$i14 * -0.59999999999999998;
  $142 = (+Math_exp((+$141)));
  $143 = $142 * 6.7999999999999998;
  $144 = $139 - $143;
  $145 = $137 + -8.6999999999999993;
  $pow21$i15 = $145 * $145;
  $146 = $pow21$i15 * -0.14999999999999999;
  $147 = (+Math_exp((+$146)));
  $148 = $147 * 6.0;
  $149 = $144 + $148;
  $150 = $129;
  $151 = $150 * 4.0000000000000003E-5;
  $152 = $151 + 5.9999999999999995E-4;
  $153 = (+Math_pow((+$137),4.0));
  $154 = $153 * $152;
  $155 = $149 + $154;
  $156 = $155;
  $ath$0 = $156;
  return (+$ath$0);
  break;
 }
 case 1:  {
  $26 = $f;
  $27 = $26 < -0.29999999999999999;
  $f$op$i1 = $f * 0.0010000000474974513;
  $28 = $27 ? 3.4100000858306885 : $f$op$i1;
  $29 = $28 < 0.10000000149011612;
  $30 = $29 ? 0.10000000149011612 : $28;
  $31 = $30 > 24.0;
  $32 = $30;
  $33 = $31 ? 24.0 : $32;
  $34 = (+Math_pow((+$33),-0.80000000000000004));
  $35 = $34 * 3.6400000000000001;
  $36 = $33 + -3.3999999999999999;
  $pow2$i2 = $36 * $36;
  $37 = $pow2$i2 * -0.59999999999999998;
  $38 = (+Math_exp((+$37)));
  $39 = $38 * 6.7999999999999998;
  $40 = $35 - $39;
  $41 = $33 + -8.6999999999999993;
  $pow21$i3 = $41 * $41;
  $42 = $pow21$i3 * -0.14999999999999999;
  $43 = (+Math_exp((+$42)));
  $44 = $43 * 6.0;
  $45 = $40 + $44;
  $46 = (+Math_pow((+$33),4.0));
  $47 = $46 * 5.5999999999999995E-4;
  $48 = $45 + $47;
  $49 = $48;
  $ath$0 = $49;
  return (+$ath$0);
  break;
 }
 case 0:  {
  $2 = $f;
  $3 = $2 < -0.29999999999999999;
  $f$op$i = $f * 0.0010000000474974513;
  $4 = $3 ? 3.4100000858306885 : $f$op$i;
  $5 = $4 < 0.10000000149011612;
  $6 = $5 ? 0.10000000149011612 : $4;
  $7 = $6 > 24.0;
  $8 = $6;
  $9 = $7 ? 24.0 : $8;
  $10 = (+Math_pow((+$9),-0.80000000000000004));
  $11 = $10 * 3.6400000000000001;
  $12 = $9 + -3.3999999999999999;
  $pow2$i = $12 * $12;
  $13 = $pow2$i * -0.59999999999999998;
  $14 = (+Math_exp((+$13)));
  $15 = $14 * 6.7999999999999998;
  $16 = $11 - $15;
  $17 = $9 + -8.6999999999999993;
  $pow21$i = $17 * $17;
  $18 = $pow21$i * -0.14999999999999999;
  $19 = (+Math_exp((+$18)));
  $20 = $19 * 6.0;
  $21 = $16 + $20;
  $22 = (+Math_pow((+$9),4.0));
  $23 = $22 * 9.5999999999999991E-4;
  $24 = $21 + $23;
  $25 = $24;
  $ath$0 = $25;
  return (+$ath$0);
  break;
 }
 case 3:  {
  $74 = $f;
  $75 = $74 < -0.29999999999999999;
  $f$op$i7 = $f * 0.0010000000474974513;
  $76 = $75 ? 3.4100000858306885 : $f$op$i7;
  $77 = $76 < 0.10000000149011612;
  $78 = $77 ? 0.10000000149011612 : $76;
  $79 = $78 > 24.0;
  $80 = $78;
  $81 = $79 ? 24.0 : $80;
  $82 = (+Math_pow((+$81),-0.80000000000000004));
  $83 = $82 * 3.6400000000000001;
  $84 = $81 + -3.3999999999999999;
  $pow2$i8 = $84 * $84;
  $85 = $pow2$i8 * -0.59999999999999998;
  $86 = (+Math_exp((+$85)));
  $87 = $86 * 6.7999999999999998;
  $88 = $83 - $87;
  $89 = $81 + -8.6999999999999993;
  $pow21$i9 = $89 * $89;
  $90 = $pow21$i9 * -0.14999999999999999;
  $91 = (+Math_exp((+$90)));
  $92 = $91 * 6.0;
  $93 = $88 + $92;
  $94 = (+Math_pow((+$81),4.0));
  $95 = $94 * 6.3999999999999994E-4;
  $96 = $93 + $95;
  $97 = $96;
  $98 = $97 + 6.0;
  $ath$0 = $98;
  return (+$ath$0);
  break;
 }
 case 4:  {
  $99 = ((($cfg)) + 188|0);
  $100 = +HEAPF32[$99>>2];
  $101 = $f;
  $102 = $101 < -0.29999999999999999;
  $f$op$i10 = $f * 0.0010000000474974513;
  $103 = $102 ? 3.4100000858306885 : $f$op$i10;
  $104 = $103 < 0.10000000149011612;
  $105 = $104 ? 0.10000000149011612 : $103;
  $106 = $105 > 24.0;
  $107 = $105;
  $108 = $106 ? 24.0 : $107;
  $109 = (+Math_pow((+$108),-0.80000000000000004));
  $110 = $109 * 3.6400000000000001;
  $111 = $108 + -3.3999999999999999;
  $pow2$i11 = $111 * $111;
  $112 = $pow2$i11 * -0.59999999999999998;
  $113 = (+Math_exp((+$112)));
  $114 = $113 * 6.7999999999999998;
  $115 = $110 - $114;
  $116 = $108 + -8.6999999999999993;
  $pow21$i12 = $116 * $116;
  $117 = $pow21$i12 * -0.14999999999999999;
  $118 = (+Math_exp((+$117)));
  $119 = $118 * 6.0;
  $120 = $115 + $119;
  $121 = $100;
  $122 = $121 * 4.0000000000000003E-5;
  $123 = $122 + 5.9999999999999995E-4;
  $124 = (+Math_pow((+$108),4.0));
  $125 = $124 * $123;
  $126 = $120 + $125;
  $127 = $126;
  $ath$0 = $127;
  return (+$ath$0);
  break;
 }
 case 2:  {
  $50 = $f;
  $51 = $50 < -0.29999999999999999;
  $f$op$i4 = $f * 0.0010000000474974513;
  $52 = $51 ? 3.4100000858306885 : $f$op$i4;
  $53 = $52 < 0.10000000149011612;
  $54 = $53 ? 0.10000000149011612 : $52;
  $55 = $54 > 24.0;
  $56 = $54;
  $57 = $55 ? 24.0 : $56;
  $58 = (+Math_pow((+$57),-0.80000000000000004));
  $59 = $58 * 3.6400000000000001;
  $60 = $57 + -3.3999999999999999;
  $pow2$i5 = $60 * $60;
  $61 = $pow2$i5 * -0.59999999999999998;
  $62 = (+Math_exp((+$61)));
  $63 = $62 * 6.7999999999999998;
  $64 = $59 - $63;
  $65 = $57 + -8.6999999999999993;
  $pow21$i6 = $65 * $65;
  $66 = $pow21$i6 * -0.14999999999999999;
  $67 = (+Math_exp((+$66)));
  $68 = $67 * 6.0;
  $69 = $64 + $68;
  $70 = (+Math_pow((+$57),4.0));
  $71 = $70 * 5.9999999999999995E-4;
  $72 = $69 + $71;
  $73 = $72;
  $ath$0 = $73;
  return (+$ath$0);
  break;
 }
 default: {
  $157 = $f;
  $158 = $157 < -0.29999999999999999;
  $f$op$i16 = $f * 0.0010000000474974513;
  $159 = $158 ? 3.4100000858306885 : $f$op$i16;
  $160 = $159 < 0.10000000149011612;
  $161 = $160 ? 0.10000000149011612 : $159;
  $162 = $161 > 24.0;
  $163 = $161;
  $164 = $162 ? 24.0 : $163;
  $165 = (+Math_pow((+$164),-0.80000000000000004));
  $166 = $165 * 3.6400000000000001;
  $167 = $164 + -3.3999999999999999;
  $pow2$i17 = $167 * $167;
  $168 = $pow2$i17 * -0.59999999999999998;
  $169 = (+Math_exp((+$168)));
  $170 = $169 * 6.7999999999999998;
  $171 = $166 - $170;
  $172 = $164 + -8.6999999999999993;
  $pow21$i18 = $172 * $172;
  $173 = $pow21$i18 * -0.14999999999999999;
  $174 = (+Math_exp((+$173)));
  $175 = $174 * 6.0;
  $176 = $171 + $175;
  $177 = (+Math_pow((+$164),4.0));
  $178 = $177 * 5.9999999999999995E-4;
  $179 = $176 + $178;
  $180 = $179;
  $ath$0 = $180;
  return (+$ath$0);
 }
 }
 return +(0.0);
}
function _freq2bark($freq) {
 $freq = +$freq;
 var $$op = 0.0, $0 = 0, $1 = 0.0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = $freq < 0.0;
 $1 = $freq;
 $$op = $1 * 0.001;
 $2 = $$op;
 $3 = $0 ? 0.0 : $2;
 $4 = $3;
 $5 = $4 * 0.76000000000000001;
 $6 = (+Math_atan((+$5)));
 $7 = $6 * 13.0;
 $8 = $3 * $3;
 $9 = $8;
 $10 = $9 * 0.017777777777777778;
 $11 = (+Math_atan((+$10)));
 $12 = $11 * 3.5;
 $13 = $12 + $7;
 $14 = $13;
 return (+$14);
}
function _FindNearestBitrate($bRate,$version,$samplerate) {
 $bRate = $bRate|0;
 $version = $version|0;
 $samplerate = $samplerate|0;
 var $$bitrate$0 = 0, $$version = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $bitrate$01 = 0, $bitrate$1 = 0;
 var $bitrate$1$lcssa = 0, $exitcond = 0, $i$02 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($samplerate|0)<(16000);
 $$version = $0 ? 2 : $version;
 $1 = (((83944 + ($$version<<6)|0)) + 4|0);
 $2 = HEAP32[$1>>2]|0;
 $bitrate$01 = $2;$i$02 = 2;
 while(1) {
  $3 = ((83944 + ($$version<<6)|0) + ($i$02<<2)|0);
  $4 = HEAP32[$3>>2]|0;
  $5 = ($4|0)>(0);
  if ($5) {
   $6 = (($4) - ($bRate))|0;
   $7 = ($6|0)>(0);
   $8 = (0 - ($6))|0;
   $9 = $7 ? $6 : $8;
   $10 = (($bitrate$01) - ($bRate))|0;
   $11 = ($10|0)>(0);
   $12 = (0 - ($10))|0;
   $13 = $11 ? $10 : $12;
   $14 = ($9|0)<($13|0);
   $$bitrate$0 = $14 ? $4 : $bitrate$01;
   $bitrate$1 = $$bitrate$0;
  } else {
   $bitrate$1 = $bitrate$01;
  }
  $15 = (($i$02) + 1)|0;
  $exitcond = ($15|0)==(15);
  if ($exitcond) {
   $bitrate$1$lcssa = $bitrate$1;
   break;
  } else {
   $bitrate$01 = $bitrate$1;$i$02 = $15;
  }
 }
 return ($bitrate$1$lcssa|0);
}
function _nearestBitrateFullIndex($bitrate) {
 $bitrate = $bitrate|0;
 var $$ = 0, $$lcssa = 0, $$lcssa12 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $b$0 = 0, $b$0$lcssa11 = 0, $lower_range$0 = 0, $lower_range$0$upper_range$0 = 0, $lower_range_kbps$0 = 0;
 var $upper_range$0 = 0, $upper_range_kbps$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = $bitrate&65535;
 $b$0 = 0;
 while(1) {
  $1 = ($b$0|0)<(16);
  if (!($1)) {
   $lower_range$0 = 16;$lower_range_kbps$0 = 320;$upper_range$0 = 16;$upper_range_kbps$0 = 320;
   break;
  }
  $2 = (($b$0) + 1)|0;
  $3 = (89568 + ($2<<2)|0);
  $4 = HEAP32[$3>>2]|0;
  $5 = ($0|0)>($4|0);
  $$ = $5 ? $0 : $4;
  $6 = ($$|0)==($0|0);
  if ($6) {
   $b$0 = $2;
  } else {
   $$lcssa = $2;$$lcssa12 = $4;$b$0$lcssa11 = $b$0;
   label = 4;
   break;
  }
 }
 if ((label|0) == 4) {
  $7 = (89568 + ($b$0$lcssa11<<2)|0);
  $8 = HEAP32[$7>>2]|0;
  $lower_range$0 = $b$0$lcssa11;$lower_range_kbps$0 = $8;$upper_range$0 = $$lcssa;$upper_range_kbps$0 = $$lcssa12;
 }
 $9 = (($upper_range_kbps$0) - ($0))|0;
 $10 = (($0) - ($lower_range_kbps$0))|0;
 $11 = ($9|0)>($10|0);
 $lower_range$0$upper_range$0 = $11 ? $lower_range$0 : $upper_range$0;
 return ($lower_range$0$upper_range$0|0);
}
function _map2MP3Frequency($freq) {
 $freq = $freq|0;
 var $$ = 0, $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($freq|0)<(8001);
 if ($0) {
  $$0 = 8000;
 } else {
  $1 = ($freq|0)<(11026);
  if ($1) {
   $$0 = 11025;
  } else {
   $2 = ($freq|0)<(12001);
   if ($2) {
    $$0 = 12000;
   } else {
    $3 = ($freq|0)<(16001);
    if ($3) {
     $$0 = 16000;
    } else {
     $4 = ($freq|0)<(22051);
     if ($4) {
      $$0 = 22050;
     } else {
      $5 = ($freq|0)<(24001);
      if ($5) {
       $$0 = 24000;
      } else {
       $6 = ($freq|0)<(32001);
       if ($6) {
        $$0 = 32000;
       } else {
        $7 = ($freq|0)<(44101);
        $$ = $7 ? 44100 : 48000;
        $$0 = $$;
       }
      }
     }
    }
   }
  }
 }
 return ($$0|0);
}
function _BitrateIndex($bRate,$version,$samplerate) {
 $bRate = $bRate|0;
 $version = $version|0;
 $samplerate = $samplerate|0;
 var $$ = 0, $$0 = 0, $$version = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 var $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0;
 var $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0;
 var $60 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond$1 = 0, $or$cond$10 = 0, $or$cond$11 = 0, $or$cond$12 = 0, $or$cond$13 = 0, $or$cond$14 = 0, $or$cond$2 = 0, $or$cond$3 = 0, $or$cond$4 = 0, $or$cond$5 = 0, $or$cond$6 = 0, $or$cond$7 = 0, $or$cond$8 = 0, $or$cond$9 = 0, label = 0;
 var sp = 0;
 sp = STACKTOP;
 $0 = ($samplerate|0)<(16000);
 $$version = $0 ? 2 : $version;
 $1 = (83944 + ($$version<<6)|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = ($2|0)>(0);
 $4 = ($2|0)==($bRate|0);
 $or$cond = $3 & $4;
 if ($or$cond) {
  $$0 = 0;
  return ($$0|0);
 }
 $5 = (((83944 + ($$version<<6)|0)) + 4|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = ($6|0)>(0);
 $8 = ($6|0)==($bRate|0);
 $or$cond$1 = $7 & $8;
 if ($or$cond$1) {
  $$0 = 1;
  return ($$0|0);
 }
 $9 = (((83944 + ($$version<<6)|0)) + 8|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = ($10|0)>(0);
 $12 = ($10|0)==($bRate|0);
 $or$cond$2 = $11 & $12;
 if ($or$cond$2) {
  $$0 = 2;
  return ($$0|0);
 }
 $13 = (((83944 + ($$version<<6)|0)) + 12|0);
 $14 = HEAP32[$13>>2]|0;
 $15 = ($14|0)>(0);
 $16 = ($14|0)==($bRate|0);
 $or$cond$3 = $15 & $16;
 if ($or$cond$3) {
  $$0 = 3;
  return ($$0|0);
 }
 $17 = (((83944 + ($$version<<6)|0)) + 16|0);
 $18 = HEAP32[$17>>2]|0;
 $19 = ($18|0)>(0);
 $20 = ($18|0)==($bRate|0);
 $or$cond$4 = $19 & $20;
 if ($or$cond$4) {
  $$0 = 4;
  return ($$0|0);
 }
 $21 = (((83944 + ($$version<<6)|0)) + 20|0);
 $22 = HEAP32[$21>>2]|0;
 $23 = ($22|0)>(0);
 $24 = ($22|0)==($bRate|0);
 $or$cond$5 = $23 & $24;
 if ($or$cond$5) {
  $$0 = 5;
  return ($$0|0);
 }
 $25 = (((83944 + ($$version<<6)|0)) + 24|0);
 $26 = HEAP32[$25>>2]|0;
 $27 = ($26|0)>(0);
 $28 = ($26|0)==($bRate|0);
 $or$cond$6 = $27 & $28;
 if ($or$cond$6) {
  $$0 = 6;
  return ($$0|0);
 }
 $29 = (((83944 + ($$version<<6)|0)) + 28|0);
 $30 = HEAP32[$29>>2]|0;
 $31 = ($30|0)>(0);
 $32 = ($30|0)==($bRate|0);
 $or$cond$7 = $31 & $32;
 if ($or$cond$7) {
  $$0 = 7;
  return ($$0|0);
 }
 $33 = (((83944 + ($$version<<6)|0)) + 32|0);
 $34 = HEAP32[$33>>2]|0;
 $35 = ($34|0)>(0);
 $36 = ($34|0)==($bRate|0);
 $or$cond$8 = $35 & $36;
 if ($or$cond$8) {
  $$0 = 8;
  return ($$0|0);
 }
 $37 = (((83944 + ($$version<<6)|0)) + 36|0);
 $38 = HEAP32[$37>>2]|0;
 $39 = ($38|0)>(0);
 $40 = ($38|0)==($bRate|0);
 $or$cond$9 = $39 & $40;
 if ($or$cond$9) {
  $$0 = 9;
  return ($$0|0);
 }
 $41 = (((83944 + ($$version<<6)|0)) + 40|0);
 $42 = HEAP32[$41>>2]|0;
 $43 = ($42|0)>(0);
 $44 = ($42|0)==($bRate|0);
 $or$cond$10 = $43 & $44;
 if ($or$cond$10) {
  $$0 = 10;
  return ($$0|0);
 }
 $45 = (((83944 + ($$version<<6)|0)) + 44|0);
 $46 = HEAP32[$45>>2]|0;
 $47 = ($46|0)>(0);
 $48 = ($46|0)==($bRate|0);
 $or$cond$11 = $47 & $48;
 if ($or$cond$11) {
  $$0 = 11;
  return ($$0|0);
 }
 $49 = (((83944 + ($$version<<6)|0)) + 48|0);
 $50 = HEAP32[$49>>2]|0;
 $51 = ($50|0)>(0);
 $52 = ($50|0)==($bRate|0);
 $or$cond$12 = $51 & $52;
 if ($or$cond$12) {
  $$0 = 12;
  return ($$0|0);
 }
 $53 = (((83944 + ($$version<<6)|0)) + 52|0);
 $54 = HEAP32[$53>>2]|0;
 $55 = ($54|0)>(0);
 $56 = ($54|0)==($bRate|0);
 $or$cond$13 = $55 & $56;
 if ($or$cond$13) {
  $$0 = 13;
  return ($$0|0);
 } else {
  $57 = (((83944 + ($$version<<6)|0)) + 56|0);
  $58 = HEAP32[$57>>2]|0;
  $59 = ($58|0)>(0);
  $60 = ($58|0)==($bRate|0);
  $or$cond$14 = $59 & $60;
  $$ = $or$cond$14 ? 14 : -1;
  return ($$|0);
 }
 return (0)|0;
}
function _SmpFrqIndex($sample_freq,$version) {
 $sample_freq = $sample_freq|0;
 $version = $version|0;
 var $$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 do {
  if ((($sample_freq|0) == 12000)) {
   HEAP32[$version>>2] = 0;
   $$0 = 1;
  } else if ((($sample_freq|0) == 44100)) {
   HEAP32[$version>>2] = 1;
   $$0 = 0;
  } else if ((($sample_freq|0) == 11025)) {
   HEAP32[$version>>2] = 0;
   $$0 = 0;
  } else if ((($sample_freq|0) == 16000)) {
   HEAP32[$version>>2] = 0;
   $$0 = 2;
  } else if ((($sample_freq|0) == 48000)) {
   HEAP32[$version>>2] = 1;
   $$0 = 1;
  } else if ((($sample_freq|0) == 22050)) {
   HEAP32[$version>>2] = 0;
   $$0 = 0;
  } else if ((($sample_freq|0) == 24000)) {
   HEAP32[$version>>2] = 0;
   $$0 = 1;
  } else if ((($sample_freq|0) == 8000)) {
   HEAP32[$version>>2] = 0;
   $$0 = 2;
  } else if ((($sample_freq|0) == 32000)) {
   HEAP32[$version>>2] = 1;
   $$0 = 2;
  } else {
   HEAP32[$version>>2] = 0;
   $$0 = -1;
  }
 } while(0);
 return ($$0|0);
}
function _isResamplingNecessary($cfg) {
 $cfg = $cfg|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0.0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0.0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($cfg)) + 48|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = (+($1|0));
 $3 = $2 * 0.99949997663497925;
 $4 = (~~(($3)));
 $5 = ((($cfg)) + 44|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = ($6|0)<($4|0);
 if ($7) {
  $12 = 1;
  $11 = $12&1;
  return ($11|0);
 }
 $8 = $2 * 1.000499963760376;
 $9 = (~~(($8)));
 $10 = ($9|0)<($6|0);
 $12 = $10;
 $11 = $12&1;
 return ($11|0);
}
function _fill_buffer($gfc,$mfbuf,$in_buffer,$nsamples,$n_in,$n_out) {
 $gfc = $gfc|0;
 $mfbuf = $mfbuf|0;
 $in_buffer = $in_buffer|0;
 $nsamples = $nsamples|0;
 $n_in = $n_in|0;
 $n_out = $n_out|0;
 var $$$i = 0, $$0$i$i = 0.0, $$0$in$i$i = 0.0, $$01$i$i = 0.0, $$1$i$i = 0.0, $$in$i = 0, $$lcssa = 0.0, $$lcssa20 = 0.0, $$neg4$i = 0.0, $$neg7$i = 0, $$op$i = 0.0, $$op54$i = 0, $$op54$op$i = 0, $$op54$op$op$i = 0, $$op55$i = 0, $$pre = 0, $$pre$i = 0.0, $$pre$phi52$iZ2D = 0, $$pre10 = 0, $$pre49$i = 0.0;
 var $$pre50$i = 0, $$pre51$i = 0, $$sum = 0, $0 = 0, $1 = 0, $10 = 0.0, $100 = 0.0, $101 = 0.0, $102 = 0.0, $103 = 0.0, $104 = 0.0, $105 = 0, $106 = 0.0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0.0, $111 = 0.0, $112 = 0;
 var $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0.0, $125 = 0.0, $126 = 0.0, $127 = 0.0, $128 = 0.0, $129 = 0.0, $13 = 0, $130 = 0.0;
 var $131 = 0.0, $132 = 0, $133 = 0, $134 = 0, $135 = 0.0, $136 = 0.0, $137 = 0.0, $138 = 0.0, $139 = 0.0, $14 = 0, $140 = 0.0, $141 = 0.0, $142 = 0.0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0;
 var $15 = 0.0, $150 = 0, $151 = 0, $152 = 0.0, $153 = 0, $154 = 0.0, $155 = 0.0, $156 = 0.0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0.0, $165 = 0.0, $166 = 0.0, $167 = 0.0;
 var $168 = 0.0, $169 = 0.0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0;
 var $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0;
 var $203 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0.0, $28 = 0, $29 = 0.0, $3 = 0, $30 = 0, $31 = 0.0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0.0, $38 = 0.0;
 var $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0, $42 = 0.0, $43 = 0.0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0;
 var $57 = 0.0, $58 = 0.0, $59 = 0.0, $6 = 0, $60 = 0.0, $61 = 0.0, $62 = 0.0, $63 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0.0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0.0, $72 = 0.0, $73 = 0.0, $74 = 0;
 var $75 = 0, $76 = 0.0, $77 = 0.0, $78 = 0.0, $79 = 0, $8 = 0, $80 = 0, $81 = 0.0, $82 = 0.0, $83 = 0, $84 = 0.0, $85 = 0.0, $86 = 0.0, $87 = 0.0, $88 = 0.0, $89 = 0.0, $9 = 0.0, $90 = 0.0, $91 = 0.0, $92 = 0.0;
 var $93 = 0.0, $94 = 0.0, $95 = 0.0, $96 = 0.0, $97 = 0.0, $98 = 0.0, $99 = 0.0, $ch$0 = 0, $ch$1 = 0, $exitcond$i = 0, $exitcond46$i = 0, $fabsf$i$i = 0.0, $i$033$i = 0, $i$126$i = 0, $i$227$i = 0, $i$316$i = 0, $i$411$i = 0, $i$5$lcssa$i = 0, $i$514$i = 0, $i$613$i = 0;
 var $i$tr$lcssa$i$i = 0, $i$tr1$i$i = 0, $i$tr1$i$i$phi = 0, $j$0$lcssa$i = 0, $j$028$i = 0, $j$1$i = 0, $j$3$i = 0, $j$412$i = 0, $j$tr2$i$i = 0, $k$0$lcssa$i = 0, $k$0$lcssa$i$lcssa = 0, $k$018$i = 0, $len$$i = 0, $sum$025$i = 0.0, $xvalue$017$i = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($gfc)) + 84036|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ((($gfc)) + 76|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3*576)|0;
 $5 = ((($gfc)) + 72|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = ((($gfc)) + 64|0);
 $8 = HEAP32[$7>>2]|0;
 $9 = (+($8|0));
 $10 = $9 * 0.99949997663497925;
 $11 = (~~(($10)));
 $12 = ((($gfc)) + 60|0);
 $13 = HEAP32[$12>>2]|0;
 $14 = ($13|0)<($11|0);
 if (!($14)) {
  $15 = $9 * 1.000499963760376;
  $16 = (~~(($15)));
  $17 = ($16|0)<($13|0);
  if (!($17)) {
   $194 = ($4|0)<($nsamples|0);
   $195 = $194 ? $4 : $nsamples;
   $196 = $195 << 2;
   $ch$1 = 0;
   while(1) {
    $197 = (($mfbuf) + ($ch$1<<2)|0);
    $198 = HEAP32[$197>>2]|0;
    $199 = (($198) + ($1<<2)|0);
    $200 = (($in_buffer) + ($ch$1<<2)|0);
    $201 = HEAP32[$200>>2]|0;
    _memcpy(($199|0),($201|0),($196|0))|0;
    $202 = (($ch$1) + 1)|0;
    $203 = ($202|0)<($6|0);
    if ($203) {
     $ch$1 = $202;
    } else {
     break;
    }
   }
   HEAP32[$n_out>>2] = $195;
   HEAP32[$n_in>>2] = $195;
   return;
  }
 }
 $18 = ((($gfc)) + 12|0);
 $19 = ((($gfc)) + 37184|0);
 $20 = ((($gfc)) + 37188|0);
 $21 = ((($gfc)) + 37168|0);
 $22 = ($3|0)>(0);
 $28 = $13;$30 = $8;$ch$0 = 0;
 while(1) {
  $23 = (($mfbuf) + ($ch$0<<2)|0);
  $24 = HEAP32[$23>>2]|0;
  $25 = (($in_buffer) + ($ch$0<<2)|0);
  $26 = HEAP32[$25>>2]|0;
  $27 = (+($28|0));
  $29 = (+($30|0));
  $31 = $27 / $29;
  $32 = ($28|0)==(0);
  if ($32) {
   $i$tr$lcssa$i$i = $30;
  } else {
   $i$tr1$i$i = $30;$j$tr2$i$i = $28;
   while(1) {
    $33 = (($i$tr1$i$i|0) % ($j$tr2$i$i|0))&-1;
    $34 = ($33|0)==(0);
    if ($34) {
     $i$tr$lcssa$i$i = $j$tr2$i$i;
     break;
    } else {
     $i$tr1$i$i$phi = $j$tr2$i$i;$j$tr2$i$i = $33;$i$tr1$i$i = $i$tr1$i$i$phi;
    }
   }
  }
  $35 = (($30|0) / ($i$tr$lcssa$i$i|0))&-1;
  $36 = ($35|0)>(320);
  $$$i = $36 ? 320 : $35;
  $37 = $31 + 0.5;
  $38 = (+Math_floor((+$37)));
  $39 = $31 - $38;
  $40 = (+Math_abs((+$39)));
  $41 = $40 < 1.0E-4;
  $42 = 1.0 / $31;
  $43 = $42;
  $44 = $43 > 1.0;
  $45 = $41 ? 32 : 31;
  $46 = (($45) + 1)|0;
  $47 = HEAP32[$18>>2]|0;
  $48 = ($47|0)==(0);
  if ($48) {
   $49 = (_calloc($46,4)|0);
   HEAP32[$19>>2] = $49;
   $50 = (_calloc($46,4)|0);
   HEAP32[$20>>2] = $50;
   $51 = $$$i << 1;
   $52 = ($$$i|0)<(0);
   if ($52) {
    ;HEAP32[$21>>2]=0|0;HEAP32[$21+4>>2]=0|0;HEAP32[$21+8>>2]=0|0;HEAP32[$21+12>>2]=0|0;
    $j$0$lcssa$i = 0;
   } else {
    $i$033$i = 0;
    while(1) {
     $53 = (_calloc($46,4)|0);
     $54 = (((($gfc)) + 37192|0) + ($i$033$i<<2)|0);
     HEAP32[$54>>2] = $53;
     $55 = (($i$033$i) + 1)|0;
     $56 = ($i$033$i|0)<($51|0);
     if ($56) {
      $i$033$i = $55;
     } else {
      break;
     }
    }
    ;HEAP32[$21>>2]=0|0;HEAP32[$21+4>>2]=0|0;HEAP32[$21+8>>2]=0|0;HEAP32[$21+12>>2]=0|0;
    $57 = (+($$$i|0));
    $58 = $57 * 2.0;
    $59 = $43;
    $$op$i = $59 * 3.1415926535897931;
    $60 = $$op$i;
    $61 = $44 ? 3.1415927410125732 : $60;
    $62 = (+($45|0));
    $63 = $61;
    $64 = $63 * 0.31830988618379069;
    $65 = $61 * $62;
    $66 = (+($45|0));
    $67 = $66 * 3.1415926535897931;
    $68 = ($35|0)<(320);
    $$op54$i = $35 << 1;
    $$op54$op$i = $$op54$i ^ -2;
    $$op54$op$op$i = (-2 - ($$op54$op$i))|0;
    $69 = $68 ? $$op54$op$op$i : 640;
    $j$028$i = 0;
    while(1) {
     $70 = (($j$028$i) - ($$$i))|0;
     $71 = (+($70|0));
     $72 = $71 / $58;
     $73 = $72;
     $74 = (((($gfc)) + 37192|0) + ($j$028$i<<2)|0);
     $75 = HEAP32[$74>>2]|0;
     $i$126$i = 0;$sum$025$i = 0.0;
     while(1) {
      $76 = (+($i$126$i|0));
      $77 = $76 - $73;
      $78 = $77 / $62;
      $79 = $78 < 0.0;
      $$01$i$i = $79 ? 0.0 : $78;
      $80 = $$01$i$i > 1.0;
      $$1$i$i = $80 ? 1.0 : $$01$i$i;
      $81 = $$1$i$i + -0.5;
      $fabsf$i$i = (+Math_abs((+$81)));
      $82 = $fabsf$i$i;
      $83 = $82 < 1.0000000000000001E-9;
      if ($83) {
       $$0$in$i$i = $64;
      } else {
       $84 = $81;
       $85 = $$1$i$i * 2.0;
       $86 = $85;
       $87 = $86 * 3.1415926535897931;
       $88 = (+Math_cos((+$87)));
       $89 = $88 * 0.5;
       $90 = 0.41999999999999998 - $89;
       $91 = $$1$i$i * 4.0;
       $92 = $91;
       $93 = $92 * 3.1415926535897931;
       $94 = (+Math_cos((+$93)));
       $95 = $94 * 0.080000000000000002;
       $96 = $90 + $95;
       $97 = $96;
       $98 = $97;
       $99 = $65 * $81;
       $100 = $99;
       $101 = (+Math_sin((+$100)));
       $102 = $98 * $101;
       $103 = $67 * $84;
       $104 = $102 / $103;
       $$0$in$i$i = $104;
      }
      $$0$i$i = $$0$in$i$i;
      $105 = (($75) + ($i$126$i<<2)|0);
      HEAPF32[$105>>2] = $$0$i$i;
      $106 = $$0$i$i + $sum$025$i;
      $107 = (($i$126$i) + 1)|0;
      $108 = ($i$126$i|0)<($45|0);
      if ($108) {
       $i$126$i = $107;$sum$025$i = $106;
      } else {
       $$lcssa = $106;
       break;
      }
     }
     $i$227$i = 0;
     while(1) {
      $109 = (($75) + ($i$227$i<<2)|0);
      $110 = +HEAPF32[$109>>2];
      $111 = $110 / $$lcssa;
      HEAPF32[$109>>2] = $111;
      $112 = (($i$227$i) + 1)|0;
      $113 = ($i$227$i|0)<($45|0);
      if ($113) {
       $i$227$i = $112;
      } else {
       break;
      }
     }
     $114 = (($j$028$i) + 1)|0;
     $115 = ($j$028$i|0)<($51|0);
     if ($115) {
      $j$028$i = $114;
     } else {
      break;
     }
    }
    $116 = ($69|0)>(0);
    $$op55$i = $69 | 1;
    $117 = $116 ? $$op55$i : 1;
    $j$0$lcssa$i = $117;
   }
   HEAP32[$18>>2] = 1;
   $j$1$i = $j$0$lcssa$i;
  } else {
   $j$1$i = 0;
  }
  $118 = (((($gfc)) + 37184|0) + ($ch$0<<2)|0);
  $119 = HEAP32[$118>>2]|0;
  $120 = (((($gfc)) + 37168|0) + ($ch$0<<3)|0);
  L36: do {
   if ($22) {
    $121 = $45 >>> 1;
    $122 = (($45) - ($121))|0;
    $123 = $45 & 1;
    $124 = (+($123|0));
    $125 = $124 * 0.5;
    $126 = (+($$$i|0));
    $127 = $126 * 2.0;
    $$pre$i = +HEAPF64[$120>>3];
    $k$018$i = 0;
    while(1) {
     $128 = (+($k$018$i|0));
     $129 = $128 * $31;
     $130 = $129 - $$pre$i;
     $131 = (+Math_floor((+$130)));
     $132 = (~~(($131)));
     $133 = (($132) + ($122))|0;
     $134 = ($133|0)<($nsamples|0);
     if (!($134)) {
      $$pre$phi52$iZ2D = $122;$168 = $$pre$i;$j$3$i = $132;$k$0$lcssa$i = $k$018$i;
      break L36;
     }
     $135 = (+($132|0));
     $$neg4$i = $130 - $125;
     $136 = $$neg4$i - $135;
     $137 = $136;
     $138 = $127 * $137;
     $139 = $138 + $126;
     $140 = $139;
     $141 = $140 + 0.5;
     $142 = (+Math_floor((+$141)));
     $143 = (~~(($142)));
     $144 = (($132) - ($121))|0;
     $145 = (((($gfc)) + 37192|0) + ($143<<2)|0);
     $146 = HEAP32[$145>>2]|0;
     $i$316$i = 0;$xvalue$017$i = 0.0;
     while(1) {
      $147 = (($i$316$i) + ($144))|0;
      $148 = ($147|0)<(0);
      $149 = (($147) + ($46))|0;
      $150 = (($119) + ($149<<2)|0);
      $151 = (($26) + ($147<<2)|0);
      $$in$i = $148 ? $150 : $151;
      $152 = +HEAPF32[$$in$i>>2];
      $153 = (($146) + ($i$316$i<<2)|0);
      $154 = +HEAPF32[$153>>2];
      $155 = $154 * $152;
      $156 = $155 + $xvalue$017$i;
      $157 = (($i$316$i) + 1)|0;
      $158 = ($i$316$i|0)<($45|0);
      if ($158) {
       $i$316$i = $157;$xvalue$017$i = $156;
      } else {
       $$lcssa20 = $156;
       break;
      }
     }
     $$sum = (($k$018$i) + ($1))|0;
     $159 = (($24) + ($$sum<<2)|0);
     HEAPF32[$159>>2] = $$lcssa20;
     $160 = (($k$018$i) + 1)|0;
     $161 = ($160|0)<($4|0);
     if ($161) {
      $k$018$i = $160;
     } else {
      $$pre$phi52$iZ2D = $122;$168 = $$pre$i;$j$3$i = $132;$k$0$lcssa$i = $160;
      break;
     }
    }
   } else {
    $$pre49$i = +HEAPF64[$120>>3];
    $$pre50$i = $45 >>> 1;
    $$pre51$i = (($45) - ($$pre50$i))|0;
    $$pre$phi52$iZ2D = $$pre51$i;$168 = $$pre49$i;$j$3$i = $j$1$i;$k$0$lcssa$i = 0;
   }
  } while(0);
  $162 = (($j$3$i) + ($$pre$phi52$iZ2D))|0;
  $163 = ($162|0)>($nsamples|0);
  $len$$i = $163 ? $nsamples : $162;
  HEAP32[$n_in>>2] = $len$$i;
  $164 = (+($len$$i|0));
  $165 = (+($k$0$lcssa$i|0));
  $166 = $165 * $31;
  $167 = $168 - $166;
  $169 = $167 + $164;
  HEAPF64[$120>>3] = $169;
  $170 = ($45|0)<($len$$i|0);
  if ($170) {
   $$neg7$i = $45 ^ -1;
   $171 = (($len$$i) + ($$neg7$i))|0;
   $i$411$i = 0;
   while(1) {
    $172 = (($171) + ($i$411$i))|0;
    $173 = (($26) + ($172<<2)|0);
    $174 = HEAP32[$173>>2]|0;
    $175 = (($119) + ($i$411$i<<2)|0);
    HEAP32[$175>>2] = $174;
    $176 = (($i$411$i) + 1)|0;
    $177 = ($176|0)<($46|0);
    if ($177) {
     $i$411$i = $176;
    } else {
     break;
    }
   }
  } else {
   $178 = (($46) - ($len$$i))|0;
   $179 = ($178|0)>(0);
   if ($179) {
    $i$514$i = 0;
    while(1) {
     $182 = (($i$514$i) + ($len$$i))|0;
     $183 = (($119) + ($182<<2)|0);
     $184 = HEAP32[$183>>2]|0;
     $185 = (($119) + ($i$514$i<<2)|0);
     HEAP32[$185>>2] = $184;
     $186 = (($i$514$i) + 1)|0;
     $exitcond46$i = ($186|0)==($178|0);
     if ($exitcond46$i) {
      $i$5$lcssa$i = $178;
      break;
     } else {
      $i$514$i = $186;
     }
    }
   } else {
    $i$5$lcssa$i = 0;
   }
   $180 = ($45|0)<($i$5$lcssa$i|0);
   if (!($180)) {
    $181 = (($46) - ($i$5$lcssa$i))|0;
    $i$613$i = $i$5$lcssa$i;$j$412$i = 0;
    while(1) {
     $187 = (($26) + ($j$412$i<<2)|0);
     $188 = HEAP32[$187>>2]|0;
     $189 = (($119) + ($i$613$i<<2)|0);
     HEAP32[$189>>2] = $188;
     $190 = (($i$613$i) + 1)|0;
     $191 = (($j$412$i) + 1)|0;
     $exitcond$i = ($191|0)==($181|0);
     if ($exitcond$i) {
      break;
     } else {
      $i$613$i = $190;$j$412$i = $191;
     }
    }
   }
  }
  $192 = (($ch$0) + 1)|0;
  $193 = ($192|0)<($6|0);
  if (!($193)) {
   $k$0$lcssa$i$lcssa = $k$0$lcssa$i;
   break;
  }
  $$pre = HEAP32[$12>>2]|0;
  $$pre10 = HEAP32[$7>>2]|0;
  $28 = $$pre;$30 = $$pre10;$ch$0 = $192;
 }
 HEAP32[$n_out>>2] = $k$0$lcssa$i$lcssa;
 return;
}
function _lame_report_def($format,$args) {
 $format = $format|0;
 $args = $args|0;
 var $0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = HEAP32[_stderr>>2]|0;
 (_vfprintf(($0|0),($format|0),($args|0))|0);
 (_fflush(($0|0))|0);
 return;
}
function _lame_msgf($gfc,$format,$varargs) {
 $gfc = $gfc|0;
 $format = $format|0;
 $varargs = $varargs|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $args = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $args = sp;
 $0 = ($gfc|0)==(0|0);
 if ($0) {
  STACKTOP = sp;return;
 }
 $1 = ((($gfc)) + 85828|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = ($2|0)==(0|0);
 if ($3) {
  STACKTOP = sp;return;
 }
 HEAP32[$args>>2] = $varargs;
 $4 = HEAP32[$1>>2]|0;
 FUNCTION_TABLE_vii[$4 & 3]($format,$args);
 STACKTOP = sp;return;
}
function _lame_errorf($gfc,$format,$varargs) {
 $gfc = $gfc|0;
 $format = $format|0;
 $varargs = $varargs|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $args = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $args = sp;
 $0 = ($gfc|0)==(0|0);
 if ($0) {
  STACKTOP = sp;return;
 }
 $1 = ((($gfc)) + 85836|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = ($2|0)==(0|0);
 if ($3) {
  STACKTOP = sp;return;
 }
 HEAP32[$args>>2] = $varargs;
 $4 = HEAP32[$1>>2]|0;
 FUNCTION_TABLE_vii[$4 & 3]($format,$args);
 STACKTOP = sp;return;
}
function _has_MMX() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return 0;
}
function _has_3DNow() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return 0;
}
function _has_SSE() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return 0;
}
function _has_SSE2() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return 0;
}
function _disable_FPE() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return;
}
function _init_log_table() {
 var $0 = 0, $1 = 0, $10 = 0, $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0, $exitcond = 0, $j$01 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = HEAP32[89640>>2]|0;
 $1 = ($0|0)==(0);
 if ($1) {
  $j$01 = 0;
 } else {
  HEAP32[89640>>2] = 1;
  return;
 }
 while(1) {
  $2 = (+($j$01|0));
  $3 = $2 * 0.001953125;
  $4 = $3 + 1.0;
  $5 = $4;
  $6 = (+Math_log((+$5)));
  $7 = $6 * 1.4426950408889634;
  $8 = $7;
  $9 = (89648 + ($j$01<<2)|0);
  HEAPF32[$9>>2] = $8;
  $10 = (($j$01) + 1)|0;
  $exitcond = ($10|0)==(513);
  if ($exitcond) {
   break;
  } else {
   $j$01 = $10;
  }
 }
 HEAP32[89640>>2] = 1;
 return;
}
function _fast_log2($x) {
 $x = +$x;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0, $15 = 0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $3 = 0, $4 = 0.0, $5 = 0, $6 = 0.0, $7 = 0.0, $8 = 0, $9 = 0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (HEAPF32[tempDoublePtr>>2]=$x,HEAP32[tempDoublePtr>>2]|0);
 $1 = $0 >>> 23;
 $2 = $1 & 255;
 $3 = (($2) + -127)|0;
 $4 = (+($3|0));
 $5 = $0 & 16383;
 $6 = (+($5|0));
 $7 = $6 * 6.103515625E-5;
 $8 = $0 >>> 14;
 $9 = $8 & 511;
 $10 = (89648 + ($9<<2)|0);
 $11 = +HEAPF32[$10>>2];
 $12 = 1.0 - $7;
 $13 = $11 * $12;
 $14 = (($9) + 1)|0;
 $15 = (89648 + ($14<<2)|0);
 $16 = +HEAPF32[$15>>2];
 $17 = $16 * $7;
 $18 = $13 + $4;
 $19 = $18 + $17;
 return (+$19);
}
function _get_lame_short_version() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (91704|0);
}
function _qsort($base,$nel,$width,$cmp) {
 $base = $base|0;
 $nel = $nel|0;
 $width = $width|0;
 $cmp = $cmp|0;
 var $$ = 0, $$0$be$i = 0, $$0$be$i19 = 0, $$0$i44 = 0, $$01$be$i = 0, $$01$be$i18 = 0, $$012$i = 0, $$012$i15 = 0, $$02$i$i = 0, $$02$i3$i = 0, $$02$us$i = 0, $$02$us$i30 = 0, $$03$i = 0, $$03$i14 = 0, $$66 = 0, $$67 = 0, $$lcssa = 0, $$lcssa102 = 0, $$lcssa70 = 0, $$lcssa71 = 0;
 var $$pre = 0, $$pre$i = 0, $$pre$i21 = 0, $$pre6$i = 0, $$pre6$i26 = 0, $$sum = 0, $$sum$i = 0, $$sum$i17 = 0, $$sum2 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0;
 var $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0;
 var $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0;
 var $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0;
 var $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0;
 var $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $4$phi = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0;
 var $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0;
 var $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0;
 var $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $ar$i = 0;
 var $exitcond$i = 0, $exitcond$i29 = 0, $head$0$lcssa = 0, $head$076 = 0, $head$174 = 0, $i$0 = 0, $i$0$lcssa$i = 0, $i$0$lcssa$i23 = 0, $i$01$us$i = 0, $i$01$us$i28 = 0, $i$04$i = 0, $i$04$i13 = 0, $lp = 0, $nTrailingZeros$03$i$i = 0, $nTrailingZeros$03$i2$i = 0, $nTrailingZeros$03$i2$i$lcssa = 0, $or$cond = 0, $or$cond68 = 0, $or$cond6873 = 0, $or$cond72 = 0;
 var $pshift$0$lcssa = 0, $pshift$077 = 0, $pshift$1 = 0, $pshift$275 = 0, $sum = 0, $sum$i = 0, $sum$i16 = 0, $tmp$i25 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 688|0;
 $tmp$i25 = sp + 424|0;
 $ar$i = sp + 192|0;
 $lp = sp;
 $0 = Math_imul($width, $nel)|0;
 $1 = ($0|0)==(0);
 if ($1) {
  STACKTOP = sp;return;
 }
 $$sum = (($0) - ($width))|0;
 $2 = ((($lp)) + 4|0);
 HEAP32[$2>>2] = $width;
 HEAP32[$lp>>2] = $width;
 $4 = $width;$6 = $width;$i$0 = 2;
 while(1) {
  $3 = (($4) + ($width))|0;
  $5 = (($3) + ($6))|0;
  $7 = (($lp) + ($i$0<<2)|0);
  HEAP32[$7>>2] = $5;
  $8 = ($5>>>0)<($0>>>0);
  $9 = (($i$0) + 1)|0;
  if ($8) {
   $4$phi = $6;$6 = $5;$i$0 = $9;$4 = $4$phi;
  } else {
   break;
  }
 }
 $10 = (0 - ($width))|0;
 $11 = (($base) + ($$sum)|0);
 $12 = ($$sum|0)>(0);
 if ($12) {
  $13 = ($width|0)==(0);
  $14 = $11;
  $16 = 1;$51 = 0;$head$076 = $base;$pshift$077 = 1;
  while(1) {
   $15 = $16 & 3;
   $17 = ($15|0)==(3);
   do {
    if ($17) {
     HEAP32[$ar$i>>2] = $head$076;
     $18 = ($pshift$077|0)>(1);
     L13: do {
      if ($18) {
       $$012$i = $pshift$077;$$03$i = $head$076;$24 = $head$076;$i$04$i = 1;
       while(1) {
        $19 = (($$03$i) + ($10)|0);
        $20 = (($$012$i) + -2)|0;
        $21 = (($lp) + ($20<<2)|0);
        $22 = HEAP32[$21>>2]|0;
        $sum$i = (($22) + ($width))|0;
        $$sum$i = (0 - ($sum$i))|0;
        $23 = (($$03$i) + ($$sum$i)|0);
        $25 = (FUNCTION_TABLE_iii[$cmp & 1]($24,$23)|0);
        $26 = ($25|0)>(-1);
        if ($26) {
         $27 = (FUNCTION_TABLE_iii[$cmp & 1]($24,$19)|0);
         $28 = ($27|0)>(-1);
         if ($28) {
          $i$0$lcssa$i = $i$04$i;
          break;
         }
        }
        $29 = (FUNCTION_TABLE_iii[$cmp & 1]($23,$19)|0);
        $30 = ($29|0)>(-1);
        $31 = (($i$04$i) + 1)|0;
        $32 = (($ar$i) + ($i$04$i<<2)|0);
        if ($30) {
         HEAP32[$32>>2] = $23;
         $33 = (($$012$i) + -1)|0;
         $$0$be$i = $23;$$01$be$i = $33;
        } else {
         HEAP32[$32>>2] = $19;
         $$0$be$i = $19;$$01$be$i = $20;
        }
        $34 = ($$01$be$i|0)>(1);
        if (!($34)) {
         $i$0$lcssa$i = $31;
         break;
        }
        $$pre$i = HEAP32[$ar$i>>2]|0;
        $$012$i = $$01$be$i;$$03$i = $$0$be$i;$24 = $$pre$i;$i$04$i = $31;
       }
       $35 = ($i$0$lcssa$i|0)<(2);
       if (!($35)) {
        $36 = (($ar$i) + ($i$0$lcssa$i<<2)|0);
        HEAP32[$36>>2] = $tmp$i25;
        if (!($13)) {
         $$02$us$i = $width;$48 = $tmp$i25;
         while(1) {
          $46 = ($$02$us$i>>>0)>(256);
          $38 = $46 ? 256 : $$02$us$i;
          $47 = HEAP32[$ar$i>>2]|0;
          _memcpy(($48|0),($47|0),($38|0))|0;
          $44 = $47;$i$01$us$i = 0;
          while(1) {
           $40 = (($ar$i) + ($i$01$us$i<<2)|0);
           $41 = (($i$01$us$i) + 1)|0;
           $42 = (($ar$i) + ($41<<2)|0);
           $43 = HEAP32[$42>>2]|0;
           _memcpy(($44|0),($43|0),($38|0))|0;
           $45 = (($44) + ($38)|0);
           HEAP32[$40>>2] = $45;
           $exitcond$i = ($41|0)==($i$0$lcssa$i|0);
           if ($exitcond$i) {
            break;
           } else {
            $44 = $43;$i$01$us$i = $41;
           }
          }
          $37 = ($$02$us$i|0)==($38|0);
          if ($37) {
           break L13;
          }
          $39 = (($$02$us$i) - ($38))|0;
          $$pre6$i = HEAP32[$36>>2]|0;
          $$02$us$i = $39;$48 = $$pre6$i;
         }
        }
       }
      } else {
      }
     } while(0);
     $49 = $16 >>> 2;
     $50 = $51 << 30;
     $52 = $49 | $50;
     $53 = $51 >>> 2;
     $54 = (($pshift$077) + 2)|0;
     $105 = $52;$168 = $53;$pshift$1 = $54;
    } else {
     $55 = (($pshift$077) + -1)|0;
     $56 = (($lp) + ($55<<2)|0);
     $57 = HEAP32[$56>>2]|0;
     $58 = $head$076;
     $59 = (($14) - ($58))|0;
     $60 = ($57>>>0)<($59>>>0);
     if ($60) {
      HEAP32[$ar$i>>2] = $head$076;
      $61 = ($pshift$077|0)>(1);
      L38: do {
       if ($61) {
        $$012$i15 = $pshift$077;$$03$i14 = $head$076;$67 = $head$076;$i$04$i13 = 1;
        while(1) {
         $62 = (($$03$i14) + ($10)|0);
         $63 = (($$012$i15) + -2)|0;
         $64 = (($lp) + ($63<<2)|0);
         $65 = HEAP32[$64>>2]|0;
         $sum$i16 = (($65) + ($width))|0;
         $$sum$i17 = (0 - ($sum$i16))|0;
         $66 = (($$03$i14) + ($$sum$i17)|0);
         $68 = (FUNCTION_TABLE_iii[$cmp & 1]($67,$66)|0);
         $69 = ($68|0)>(-1);
         if ($69) {
          $70 = (FUNCTION_TABLE_iii[$cmp & 1]($67,$62)|0);
          $71 = ($70|0)>(-1);
          if ($71) {
           $i$0$lcssa$i23 = $i$04$i13;
           break;
          }
         }
         $72 = (FUNCTION_TABLE_iii[$cmp & 1]($66,$62)|0);
         $73 = ($72|0)>(-1);
         $74 = (($i$04$i13) + 1)|0;
         $75 = (($ar$i) + ($i$04$i13<<2)|0);
         if ($73) {
          HEAP32[$75>>2] = $66;
          $76 = (($$012$i15) + -1)|0;
          $$0$be$i19 = $66;$$01$be$i18 = $76;
         } else {
          HEAP32[$75>>2] = $62;
          $$0$be$i19 = $62;$$01$be$i18 = $63;
         }
         $77 = ($$01$be$i18|0)>(1);
         if (!($77)) {
          $i$0$lcssa$i23 = $74;
          break;
         }
         $$pre$i21 = HEAP32[$ar$i>>2]|0;
         $$012$i15 = $$01$be$i18;$$03$i14 = $$0$be$i19;$67 = $$pre$i21;$i$04$i13 = $74;
        }
        $78 = ($i$0$lcssa$i23|0)<(2);
        if (!($78)) {
         $79 = (($ar$i) + ($i$0$lcssa$i23<<2)|0);
         HEAP32[$79>>2] = $tmp$i25;
         if (!($13)) {
          $$02$us$i30 = $width;$91 = $tmp$i25;
          while(1) {
           $89 = ($$02$us$i30>>>0)>(256);
           $81 = $89 ? 256 : $$02$us$i30;
           $90 = HEAP32[$ar$i>>2]|0;
           _memcpy(($91|0),($90|0),($81|0))|0;
           $87 = $90;$i$01$us$i28 = 0;
           while(1) {
            $83 = (($ar$i) + ($i$01$us$i28<<2)|0);
            $84 = (($i$01$us$i28) + 1)|0;
            $85 = (($ar$i) + ($84<<2)|0);
            $86 = HEAP32[$85>>2]|0;
            _memcpy(($87|0),($86|0),($81|0))|0;
            $88 = (($87) + ($81)|0);
            HEAP32[$83>>2] = $88;
            $exitcond$i29 = ($84|0)==($i$0$lcssa$i23|0);
            if ($exitcond$i29) {
             break;
            } else {
             $87 = $86;$i$01$us$i28 = $84;
            }
           }
           $80 = ($$02$us$i30|0)==($81|0);
           if ($80) {
            break L38;
           }
           $82 = (($$02$us$i30) - ($81))|0;
           $$pre6$i26 = HEAP32[$79>>2]|0;
           $$02$us$i30 = $82;$91 = $$pre6$i26;
          }
         }
        }
       } else {
       }
      } while(0);
     } else {
      _trinkle($head$076,$width,$cmp,$16,$51,$pshift$077,0,$lp);
     }
     $92 = ($pshift$077|0)==(1);
     if ($92) {
      $93 = $51 << 1;
      $94 = $16 >>> 31;
      $95 = $94 | $93;
      $96 = $16 << 1;
      $105 = $96;$168 = $95;$pshift$1 = 0;
      break;
     } else {
      $97 = ($55>>>0)>(31);
      $98 = (($pshift$077) + -33)|0;
      $$ = $97 ? 0 : $16;
      $$66 = $97 ? $16 : $51;
      $$67 = $97 ? $98 : $55;
      $99 = $$66 << $$67;
      $100 = (32 - ($$67))|0;
      $101 = $$ >>> $100;
      $102 = $101 | $99;
      $103 = $$ << $$67;
      $105 = $103;$168 = $102;$pshift$1 = 1;
      break;
     }
    }
   } while(0);
   $104 = $105 | 1;
   $106 = (($head$076) + ($width)|0);
   $107 = ($106>>>0)<($11>>>0);
   if ($107) {
    $16 = $104;$51 = $168;$head$076 = $106;$pshift$077 = $pshift$1;
   } else {
    $$lcssa70 = $168;$$lcssa71 = $104;$head$0$lcssa = $106;$pshift$0$lcssa = $pshift$1;
    break;
   }
  }
 } else {
  $$lcssa70 = 0;$$lcssa71 = 1;$head$0$lcssa = $base;$pshift$0$lcssa = 1;
 }
 _trinkle($head$0$lcssa,$width,$cmp,$$lcssa71,$$lcssa70,$pshift$0$lcssa,0,$lp);
 $108 = ($pshift$0$lcssa|0)==(1);
 $109 = ($$lcssa71|0)==(1);
 $or$cond72 = $109 & $108;
 $110 = ($$lcssa70|0)==(0);
 $or$cond6873 = $110 & $or$cond72;
 if ($or$cond6873) {
  STACKTOP = sp;return;
 } else {
  $113 = $$lcssa71;$122 = $$lcssa70;$head$174 = $head$0$lcssa;$pshift$275 = $pshift$0$lcssa;
 }
 while(1) {
  $111 = ($pshift$275|0)<(2);
  if (!($111)) {
   $136 = $122 << 2;
   $137 = $113 >>> 30;
   $138 = $137 | $136;
   $139 = (($pshift$275) + -2)|0;
   $140 = $113 << 1;
   $141 = $140 & 2147483646;
   $142 = $137 << 31;
   $143 = $141 | $142;
   $144 = $143 ^ 3;
   $145 = $138 >>> 1;
   $146 = (($lp) + ($139<<2)|0);
   $147 = HEAP32[$146>>2]|0;
   $sum = (($147) + ($width))|0;
   $$sum2 = (0 - ($sum))|0;
   $148 = (($head$174) + ($$sum2)|0);
   $149 = (($pshift$275) + -1)|0;
   _trinkle($148,$width,$cmp,$144,$145,$149,1,$lp);
   $150 = $145 << 1;
   $151 = $137 & 1;
   $152 = $150 | $151;
   $153 = $144 << 1;
   $154 = $153 | 1;
   $155 = (($head$174) + ($10)|0);
   _trinkle($155,$width,$cmp,$154,$152,$139,1,$lp);
   $113 = $154;$122 = $152;$head$174 = $155;$pshift$275 = $139;
   continue;
  }
  $112 = (($113) + -1)|0;
  $114 = ($112|0)==(0);
  do {
   if ($114) {
    $135 = 32;
    label = 56;
   } else {
    $115 = $112 & 1;
    $116 = ($115|0)==(0);
    if ($116) {
     $$02$i$i = $112;$nTrailingZeros$03$i$i = 0;
     while(1) {
      $117 = (($nTrailingZeros$03$i$i) + 1)|0;
      $118 = $$02$i$i >>> 1;
      $119 = $118 & 1;
      $120 = ($119|0)==(0);
      if ($120) {
       $$02$i$i = $118;$nTrailingZeros$03$i$i = $117;
      } else {
       $$lcssa = $117;
       break;
      }
     }
     $121 = ($$lcssa|0)==(0);
     if ($121) {
      label = 51;
     } else {
      $132 = $$lcssa;
     }
    } else {
     label = 51;
    }
    if ((label|0) == 51) {
     label = 0;
     $123 = ($122|0)==(0);
     if ($123) {
      $135 = 64;
      label = 56;
      break;
     }
     $124 = $122 & 1;
     $125 = ($124|0)==(0);
     if ($125) {
      $$02$i3$i = $122;$nTrailingZeros$03$i2$i = 0;
     } else {
      $$0$i44 = 0;$157 = $113;$160 = $122;$164 = 0;
      break;
     }
     while(1) {
      $126 = (($nTrailingZeros$03$i2$i) + 1)|0;
      $127 = $$02$i3$i >>> 1;
      $128 = $127 & 1;
      $129 = ($128|0)==(0);
      if ($129) {
       $$02$i3$i = $127;$nTrailingZeros$03$i2$i = $126;
      } else {
       $$lcssa102 = $126;$nTrailingZeros$03$i2$i$lcssa = $nTrailingZeros$03$i2$i;
       break;
      }
     }
     $130 = (($nTrailingZeros$03$i2$i$lcssa) + 33)|0;
     $131 = ($$lcssa102|0)==(0);
     if ($131) {
      $$0$i44 = 0;$157 = $113;$160 = $122;$164 = 0;
      break;
     } else {
      $132 = $130;
     }
    }
    $133 = ($132>>>0)>(31);
    if ($133) {
     $135 = $132;
     label = 56;
    } else {
     $$0$i44 = $132;$157 = $113;$160 = $122;$164 = $132;
    }
   }
  } while(0);
  if ((label|0) == 56) {
   label = 0;
   $134 = (($135) + -32)|0;
   $$0$i44 = $134;$157 = $122;$160 = 0;$164 = $135;
  }
  $156 = $157 >>> $$0$i44;
  $158 = (32 - ($$0$i44))|0;
  $159 = $160 << $158;
  $161 = $159 | $156;
  $162 = $160 >>> $$0$i44;
  $163 = (($164) + ($pshift$275))|0;
  $$pre = (($head$174) + ($10)|0);
  $165 = ($163|0)==(1);
  $166 = ($161|0)==(1);
  $or$cond = $166 & $165;
  $167 = ($162|0)==(0);
  $or$cond68 = $167 & $or$cond;
  if ($or$cond68) {
   break;
  } else {
   $113 = $161;$122 = $162;$head$174 = $$pre;$pshift$275 = $163;
  }
 }
 STACKTOP = sp;return;
}
function _trinkle($head,$width,$cmp,$pp$val,$pp$1$val,$pshift,$trusty,$lp) {
 $head = $head|0;
 $width = $width|0;
 $cmp = $cmp|0;
 $pp$val = $pp$val|0;
 $pp$1$val = $pp$1$val|0;
 $pshift = $pshift|0;
 $trusty = $trusty|0;
 $lp = $lp|0;
 var $$0$be$i = 0, $$0$i = 0, $$0$lcssa = 0, $$0$lcssa49 = 0, $$01$be$i = 0, $$01162 = 0, $$01162$phi = 0, $$012$i = 0, $$02$i$i = 0, $$02$i3$i = 0, $$02$lcssa = 0, $$02$lcssa51 = 0, $$02$us$i = 0, $$02$us$i10 = 0, $$02964 = 0, $$03$i = 0, $$03$lcssa = 0, $$03865 = 0, $$lcssa = 0, $$lcssa76 = 0;
 var $$pre = 0, $$pre$i = 0, $$pre6$i = 0, $$pre6$i6 = 0, $$sum = 0, $$sum$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0;
 var $110 = 0, $111 = 0, $112 = 0, $113 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0;
 var $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0;
 var $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0;
 var $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0;
 var $ar = 0, $ar$i = 0, $exitcond$i = 0, $exitcond$i9 = 0, $i$0$lcssa = 0, $i$0$lcssa$i = 0, $i$0$lcssa50 = 0, $i$01$us$i = 0, $i$01$us$i8 = 0, $i$01063 = 0, $i$04$i = 0, $nTrailingZeros$03$i$i = 0, $nTrailingZeros$03$i2$i = 0, $nTrailingZeros$03$i2$i$lcssa = 0, $or$cond = 0, $pp$val1666 = 0, $sum = 0, $sum$i = 0, $tmp$i5 = 0, label = 0;
 var sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 720|0;
 $tmp$i5 = sp + 456|0;
 $ar$i = sp + 228|0;
 $ar = sp;
 HEAP32[$ar>>2] = $head;
 $0 = (0 - ($width))|0;
 $1 = ($pp$val|0)!=(1);
 $2 = ($pp$1$val|0)!=(0);
 $3 = $2 | $1;
 L1: do {
  if ($3) {
   $4 = (($lp) + ($pshift<<2)|0);
   $5 = HEAP32[$4>>2]|0;
   $6 = (0 - ($5))|0;
   $7 = (($head) + ($6)|0);
   $8 = (FUNCTION_TABLE_iii[$cmp & 1]($7,$head)|0);
   $9 = ($8|0)<(1);
   if ($9) {
    $$0$lcssa = $head;$$02$lcssa = $pshift;$$03$lcssa = $trusty;$i$0$lcssa = 1;
    label = 18;
   } else {
    $$01162 = $head;$$02964 = $pshift;$$03865 = $trusty;$16 = $7;$33 = $pp$1$val;$i$01063 = 1;$pp$val1666 = $pp$val;
    while(1) {
     $10 = ($$03865|0)==(0);
     $11 = ($$02964|0)>(1);
     $or$cond = $10 & $11;
     if ($or$cond) {
      $12 = (($$01162) + ($0)|0);
      $13 = (($$02964) + -2)|0;
      $14 = (($lp) + ($13<<2)|0);
      $15 = HEAP32[$14>>2]|0;
      $17 = (FUNCTION_TABLE_iii[$cmp & 1]($12,$16)|0);
      $18 = ($17|0)>(-1);
      if ($18) {
       $$0$lcssa49 = $$01162;$$02$lcssa51 = $$02964;$i$0$lcssa50 = $i$01063;
       break L1;
      }
      $sum = (($15) + ($width))|0;
      $$sum = (0 - ($sum))|0;
      $19 = (($$01162) + ($$sum)|0);
      $20 = (FUNCTION_TABLE_iii[$cmp & 1]($19,$16)|0);
      $21 = ($20|0)>(-1);
      if ($21) {
       $$0$lcssa49 = $$01162;$$02$lcssa51 = $$02964;$i$0$lcssa50 = $i$01063;
       break L1;
      }
     }
     $22 = (($i$01063) + 1)|0;
     $23 = (($ar) + ($i$01063<<2)|0);
     HEAP32[$23>>2] = $16;
     $24 = (($pp$val1666) + -1)|0;
     $25 = ($24|0)==(0);
     do {
      if ($25) {
       $46 = 32;
       label = 15;
      } else {
       $26 = $24 & 1;
       $27 = ($26|0)==(0);
       if ($27) {
        $$02$i$i = $24;$nTrailingZeros$03$i$i = 0;
        while(1) {
         $28 = (($nTrailingZeros$03$i$i) + 1)|0;
         $29 = $$02$i$i >>> 1;
         $30 = $29 & 1;
         $31 = ($30|0)==(0);
         if ($31) {
          $$02$i$i = $29;$nTrailingZeros$03$i$i = $28;
         } else {
          $$lcssa = $28;
          break;
         }
        }
        $32 = ($$lcssa|0)==(0);
        if ($32) {
         label = 10;
        } else {
         $43 = $$lcssa;
        }
       } else {
        label = 10;
       }
       if ((label|0) == 10) {
        label = 0;
        $34 = ($33|0)==(0);
        if ($34) {
         $46 = 64;
         label = 15;
         break;
        }
        $35 = $33 & 1;
        $36 = ($35|0)==(0);
        if ($36) {
         $$02$i3$i = $33;$nTrailingZeros$03$i2$i = 0;
        } else {
         $$0$i = 0;$48 = $pp$val1666;$51 = $33;$55 = 0;
         break;
        }
        while(1) {
         $37 = (($nTrailingZeros$03$i2$i) + 1)|0;
         $38 = $$02$i3$i >>> 1;
         $39 = $38 & 1;
         $40 = ($39|0)==(0);
         if ($40) {
          $$02$i3$i = $38;$nTrailingZeros$03$i2$i = $37;
         } else {
          $$lcssa76 = $37;$nTrailingZeros$03$i2$i$lcssa = $nTrailingZeros$03$i2$i;
          break;
         }
        }
        $41 = (($nTrailingZeros$03$i2$i$lcssa) + 33)|0;
        $42 = ($$lcssa76|0)==(0);
        if ($42) {
         $$0$i = 0;$48 = $pp$val1666;$51 = $33;$55 = 0;
         break;
        } else {
         $43 = $41;
        }
       }
       $44 = ($43>>>0)>(31);
       if ($44) {
        $46 = $43;
        label = 15;
       } else {
        $$0$i = $43;$48 = $pp$val1666;$51 = $33;$55 = $43;
       }
      }
     } while(0);
     if ((label|0) == 15) {
      label = 0;
      $45 = (($46) + -32)|0;
      $$0$i = $45;$48 = $33;$51 = 0;$55 = $46;
     }
     $47 = $48 >>> $$0$i;
     $49 = (32 - ($$0$i))|0;
     $50 = $51 << $49;
     $52 = $50 | $47;
     $53 = $51 >>> $$0$i;
     $54 = (($55) + ($$02964))|0;
     $56 = ($52|0)!=(1);
     $57 = ($53|0)!=(0);
     $58 = $57 | $56;
     if (!($58)) {
      $$0$lcssa49 = $16;$$02$lcssa51 = $54;$i$0$lcssa50 = $22;
      break L1;
     }
     $$pre = HEAP32[$ar>>2]|0;
     $59 = (($lp) + ($54<<2)|0);
     $60 = HEAP32[$59>>2]|0;
     $61 = (0 - ($60))|0;
     $62 = (($16) + ($61)|0);
     $63 = (FUNCTION_TABLE_iii[$cmp & 1]($62,$$pre)|0);
     $64 = ($63|0)<(1);
     if ($64) {
      $$0$lcssa = $16;$$02$lcssa = $54;$$03$lcssa = 0;$i$0$lcssa = $22;
      label = 18;
      break;
     } else {
      $$01162$phi = $16;$$02964 = $54;$$03865 = 0;$16 = $62;$33 = $53;$i$01063 = $22;$pp$val1666 = $52;$$01162 = $$01162$phi;
     }
    }
   }
  } else {
   $$0$lcssa = $head;$$02$lcssa = $pshift;$$03$lcssa = $trusty;$i$0$lcssa = 1;
   label = 18;
  }
 } while(0);
 if ((label|0) == 18) {
  $65 = ($$03$lcssa|0)==(0);
  if ($65) {
   $$0$lcssa49 = $$0$lcssa;$$02$lcssa51 = $$02$lcssa;$i$0$lcssa50 = $i$0$lcssa;
  } else {
   STACKTOP = sp;return;
  }
 }
 $66 = ($i$0$lcssa50|0)<(2);
 L30: do {
  if (!($66)) {
   $67 = (($ar) + ($i$0$lcssa50<<2)|0);
   HEAP32[$67>>2] = $tmp$i5;
   $68 = ($width|0)==(0);
   if (!($68)) {
    $$02$us$i10 = $width;$80 = $tmp$i5;
    while(1) {
     $78 = ($$02$us$i10>>>0)>(256);
     $70 = $78 ? 256 : $$02$us$i10;
     $79 = HEAP32[$ar>>2]|0;
     _memcpy(($80|0),($79|0),($70|0))|0;
     $76 = $79;$i$01$us$i8 = 0;
     while(1) {
      $72 = (($ar) + ($i$01$us$i8<<2)|0);
      $73 = (($i$01$us$i8) + 1)|0;
      $74 = (($ar) + ($73<<2)|0);
      $75 = HEAP32[$74>>2]|0;
      _memcpy(($76|0),($75|0),($70|0))|0;
      $77 = (($76) + ($70)|0);
      HEAP32[$72>>2] = $77;
      $exitcond$i9 = ($73|0)==($i$0$lcssa50|0);
      if ($exitcond$i9) {
       break;
      } else {
       $76 = $75;$i$01$us$i8 = $73;
      }
     }
     $69 = ($$02$us$i10|0)==($70|0);
     if ($69) {
      break L30;
     }
     $71 = (($$02$us$i10) - ($70))|0;
     $$pre6$i6 = HEAP32[$67>>2]|0;
     $$02$us$i10 = $71;$80 = $$pre6$i6;
    }
   }
  }
 } while(0);
 HEAP32[$ar$i>>2] = $$0$lcssa49;
 $81 = ($$02$lcssa51|0)>(1);
 L39: do {
  if ($81) {
   $$012$i = $$02$lcssa51;$$03$i = $$0$lcssa49;$87 = $$0$lcssa49;$i$04$i = 1;
   while(1) {
    $82 = (($$03$i) + ($0)|0);
    $83 = (($$012$i) + -2)|0;
    $84 = (($lp) + ($83<<2)|0);
    $85 = HEAP32[$84>>2]|0;
    $sum$i = (($85) + ($width))|0;
    $$sum$i = (0 - ($sum$i))|0;
    $86 = (($$03$i) + ($$sum$i)|0);
    $88 = (FUNCTION_TABLE_iii[$cmp & 1]($87,$86)|0);
    $89 = ($88|0)>(-1);
    if ($89) {
     $90 = (FUNCTION_TABLE_iii[$cmp & 1]($87,$82)|0);
     $91 = ($90|0)>(-1);
     if ($91) {
      $i$0$lcssa$i = $i$04$i;
      break;
     }
    }
    $92 = (FUNCTION_TABLE_iii[$cmp & 1]($86,$82)|0);
    $93 = ($92|0)>(-1);
    $94 = (($i$04$i) + 1)|0;
    $95 = (($ar$i) + ($i$04$i<<2)|0);
    if ($93) {
     HEAP32[$95>>2] = $86;
     $96 = (($$012$i) + -1)|0;
     $$0$be$i = $86;$$01$be$i = $96;
    } else {
     HEAP32[$95>>2] = $82;
     $$0$be$i = $82;$$01$be$i = $83;
    }
    $97 = ($$01$be$i|0)>(1);
    if (!($97)) {
     $i$0$lcssa$i = $94;
     break;
    }
    $$pre$i = HEAP32[$ar$i>>2]|0;
    $$012$i = $$01$be$i;$$03$i = $$0$be$i;$87 = $$pre$i;$i$04$i = $94;
   }
   $98 = ($i$0$lcssa$i|0)<(2);
   if ($98) {
    $113 = $tmp$i5;
   } else {
    $99 = (($ar$i) + ($i$0$lcssa$i<<2)|0);
    HEAP32[$99>>2] = $tmp$i5;
    $100 = ($width|0)==(0);
    if ($100) {
     $113 = $tmp$i5;
    } else {
     $$02$us$i = $width;$112 = $tmp$i5;
     while(1) {
      $110 = ($$02$us$i>>>0)>(256);
      $102 = $110 ? 256 : $$02$us$i;
      $111 = HEAP32[$ar$i>>2]|0;
      _memcpy(($112|0),($111|0),($102|0))|0;
      $108 = $111;$i$01$us$i = 0;
      while(1) {
       $104 = (($ar$i) + ($i$01$us$i<<2)|0);
       $105 = (($i$01$us$i) + 1)|0;
       $106 = (($ar$i) + ($105<<2)|0);
       $107 = HEAP32[$106>>2]|0;
       _memcpy(($108|0),($107|0),($102|0))|0;
       $109 = (($108) + ($102)|0);
       HEAP32[$104>>2] = $109;
       $exitcond$i = ($105|0)==($i$0$lcssa$i|0);
       if ($exitcond$i) {
        break;
       } else {
        $108 = $107;$i$01$us$i = $105;
       }
      }
      $101 = ($$02$us$i|0)==($102|0);
      if ($101) {
       $113 = $tmp$i5;
       break L39;
      }
      $103 = (($$02$us$i) - ($102))|0;
      $$pre6$i = HEAP32[$99>>2]|0;
      $$02$us$i = $103;$112 = $$pre6$i;
     }
    }
   }
  } else {
   $113 = $tmp$i5;
  }
 } while(0);
 STACKTOP = sp;return;
}
function _isupper($c) {
 $c = $c|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (($c) + -65)|0;
 $1 = ($0>>>0)<(26);
 $2 = $1&1;
 return ($2|0);
}
function _tolower($c) {
 $c = $c|0;
 var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_isupper($c)|0);
 $1 = ($0|0)==(0);
 $2 = $c | 32;
 $$0 = $1 ? $c : $2;
 return ($$0|0);
}
function _exp2($x) {
 $x = +$x;
 var $$0 = 0.0, $0 = 0, $1 = 0, $10 = 0.0, $11 = 0, $12 = 0.0, $13 = 0, $14 = 0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0, $23 = 0.0, $24 = 0.0, $25 = 0;
 var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0, $33 = 0, $34 = 0, $35 = 0.0, $36 = 0, $37 = 0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0;
 var $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0.0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $__x = 0, $or$cond = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $__x = sp;
 HEAPF64[tempDoublePtr>>3] = $x;$0 = HEAP32[tempDoublePtr>>2]|0;
 $1 = HEAP32[tempDoublePtr+4>>2]|0;
 $2 = $1 & 2147483647;
 $3 = ($2>>>0)>(1083174911);
 do {
  if ($3) {
   $4 = ($2>>>0)>(1083179007);
   $5 = ($1|0)>(-1);
   $6 = ($0>>>0)>(4294967295);
   $7 = ($1|0)==(-1);
   $8 = $7 & $6;
   $9 = $5 | $8;
   $or$cond = $9 & $4;
   if ($or$cond) {
    $10 = $x * 8.9884656743115795E+307;
    $$0 = $10;
    STACKTOP = sp;return (+$$0);
   }
   $11 = ($2>>>0)>(2146435071);
   if ($11) {
    $12 = -1.0 / $x;
    $$0 = $12;
    STACKTOP = sp;return (+$$0);
   }
   $13 = ($1|0)<(0);
   if ($13) {
    $14 = !($x <= -1075.0);
    if ($14) {
     $17 = $x + -4503599627370496.0;
     $18 = $17 + 4503599627370496.0;
     $19 = $18 != $x;
     if (!($19)) {
      break;
     }
     $20 = -1.4012984643248171E-45 / $x;
     $21 = $20;
     HEAPF32[$__x>>2] = $21;
     break;
    } else {
     $15 = -1.4012984643248171E-45 / $x;
     $16 = $15;
     HEAPF32[$__x>>2] = $16;
     $$0 = 0.0;
     STACKTOP = sp;return (+$$0);
    }
   }
  } else {
   $22 = ($2>>>0)<(1016070144);
   if ($22) {
    $23 = $x + 1.0;
    $$0 = $23;
    STACKTOP = sp;return (+$$0);
   }
  }
 } while(0);
 $24 = $x + 26388279066624.0;
 HEAPF64[tempDoublePtr>>3] = $24;$25 = HEAP32[tempDoublePtr>>2]|0;
 $26 = HEAP32[tempDoublePtr+4>>2]|0;
 $27 = (($25) + 128)|0;
 $28 = $27 & -256;
 $29 = (($28|0) / 256)&-1;
 $30 = $24 + -26388279066624.0;
 $31 = $x - $30;
 $32 = $27 << 1;
 $33 = $32 & 510;
 $34 = (91712 + ($33<<3)|0);
 $35 = +HEAPF64[$34>>3];
 $36 = $33 | 1;
 $37 = (91712 + ($36<<3)|0);
 $38 = +HEAPF64[$37>>3];
 $39 = $31 - $38;
 $40 = $35 * $39;
 $41 = $39 * 0.0013333559164630223;
 $42 = $41 + 0.0096181298421260663;
 $43 = $39 * $42;
 $44 = $43 + 0.055504108664821403;
 $45 = $39 * $44;
 $46 = $45 + 0.2402265069591;
 $47 = $39 * $46;
 $48 = $47 + 0.69314718055994529;
 $49 = $40 * $48;
 $50 = $35 + $49;
 $51 = (+_scalbn($50,$29));
 $$0 = $51;
 STACKTOP = sp;return (+$$0);
}
function _frexp($x,$e) {
 $x = +$x;
 $e = $e|0;
 var $$0 = 0.0, $$01 = 0.0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0.0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0.0, $8 = 0, $9 = 0, $storemerge = 0, label = 0, sp = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr>>3] = $x;$0 = HEAP32[tempDoublePtr>>2]|0;
 $1 = HEAP32[tempDoublePtr+4>>2]|0;
 $2 = (_bitshift64Lshr(($0|0),($1|0),52)|0);
 $3 = tempRet0;
 $4 = $2 & 2047;
 if ((($4|0) == 0)) {
  $5 = $x != 0.0;
  if ($5) {
   $6 = $x * 1.8446744073709552E+19;
   $7 = (+_frexp($6,$e));
   $8 = HEAP32[$e>>2]|0;
   $9 = (($8) + -64)|0;
   $$01 = $7;$storemerge = $9;
  } else {
   $$01 = $x;$storemerge = 0;
  }
  HEAP32[$e>>2] = $storemerge;
  $$0 = $$01;
  return (+$$0);
 } else if ((($4|0) == 2047)) {
  $$0 = $x;
  return (+$$0);
 } else {
  $10 = (($4) + -1022)|0;
  HEAP32[$e>>2] = $10;
  $11 = $1 & -2146435073;
  $12 = $11 | 1071644672;
  HEAP32[tempDoublePtr>>2] = $0;HEAP32[tempDoublePtr+4>>2] = $12;$13 = +HEAPF64[tempDoublePtr>>3];
  $$0 = $13;
  return (+$$0);
 }
 return +(0.0);
}
function _frexpl($x,$e) {
 $x = +$x;
 $e = $e|0;
 var $0 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (+_frexp($x,$e));
 return (+$0);
}
function _log10($x) {
 $x = +$x;
 var $$0 = 0.0, $0 = 0, $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0.0;
 var $26 = 0, $27 = 0.0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0;
 var $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0, $49 = 0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0.0, $6 = 0, $60 = 0.0, $61 = 0.0;
 var $62 = 0.0, $63 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0, $8 = 0.0, $9 = 0.0, $hx$0 = 0, $k$0 = 0, $or$cond = 0, $or$cond4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr>>3] = $x;$0 = HEAP32[tempDoublePtr>>2]|0;
 $1 = HEAP32[tempDoublePtr+4>>2]|0;
 $2 = ($1>>>0)<(1048576);
 $3 = ($1|0)<(0);
 $or$cond = $3 | $2;
 do {
  if ($or$cond) {
   $4 = $1 & 2147483647;
   $5 = ($0|0)==(0);
   $6 = ($4|0)==(0);
   $7 = $5 & $6;
   if ($7) {
    $8 = $x * $x;
    $9 = -1.0 / $8;
    $$0 = $9;
    return (+$$0);
   }
   if (!($3)) {
    $12 = $x * 18014398509481984.0;
    HEAPF64[tempDoublePtr>>3] = $12;$13 = HEAP32[tempDoublePtr>>2]|0;
    $14 = HEAP32[tempDoublePtr+4>>2]|0;
    $26 = $13;$70 = $14;$hx$0 = $14;$k$0 = -1077;
    break;
   }
   $10 = $x - $x;
   $11 = $10 / 0.0;
   $$0 = $11;
   return (+$$0);
  } else {
   $15 = ($1>>>0)>(2146435071);
   if ($15) {
    $$0 = $x;
    return (+$$0);
   }
   $16 = ($1|0)==(1072693248);
   $17 = ($0|0)==(0);
   $18 = (0)==(0);
   $19 = $17 & $18;
   $or$cond4 = $19 & $16;
   if ($or$cond4) {
    $$0 = 0.0;
    return (+$$0);
   } else {
    $26 = $0;$70 = $1;$hx$0 = $1;$k$0 = -1023;
   }
  }
 } while(0);
 $20 = (($hx$0) + 614242)|0;
 $21 = $20 >>> 20;
 $22 = (($k$0) + ($21))|0;
 $23 = $20 & 1048575;
 $24 = (($23) + 1072079006)|0;
 HEAP32[tempDoublePtr>>2] = $26;HEAP32[tempDoublePtr+4>>2] = $24;$25 = +HEAPF64[tempDoublePtr>>3];
 $27 = $25 + -1.0;
 $28 = $27 * 0.5;
 $29 = $27 * $28;
 $30 = $27 + 2.0;
 $31 = $27 / $30;
 $32 = $31 * $31;
 $33 = $32 * $32;
 $34 = $33 * 0.15313837699209373;
 $35 = $34 + 0.22222198432149784;
 $36 = $33 * $35;
 $37 = $36 + 0.39999999999409419;
 $38 = $33 * $37;
 $39 = $33 * 0.14798198605116586;
 $40 = $39 + 0.1818357216161805;
 $41 = $33 * $40;
 $42 = $41 + 0.28571428743662391;
 $43 = $33 * $42;
 $44 = $43 + 0.66666666666667351;
 $45 = $32 * $44;
 $46 = $38 + $45;
 $47 = $27 - $29;
 HEAPF64[tempDoublePtr>>3] = $47;$48 = HEAP32[tempDoublePtr>>2]|0;
 $49 = HEAP32[tempDoublePtr+4>>2]|0;
 HEAP32[tempDoublePtr>>2] = 0;HEAP32[tempDoublePtr+4>>2] = $49;$50 = +HEAPF64[tempDoublePtr>>3];
 $51 = $27 - $50;
 $52 = $51 - $29;
 $53 = $29 + $46;
 $54 = $31 * $53;
 $55 = $54 + $52;
 $56 = $50 * 0.43429448187816888;
 $57 = (+($22|0));
 $58 = $57 * 0.30102999566361177;
 $59 = $57 * 3.6942390771589308E-13;
 $60 = $50 + $55;
 $61 = $60 * 2.5082946711645275E-11;
 $62 = $59 + $61;
 $63 = $55 * 0.43429448187816888;
 $64 = $63 + $62;
 $65 = $58 + $56;
 $66 = $58 - $65;
 $67 = $56 + $66;
 $68 = $67 + $64;
 $69 = $65 + $68;
 $$0 = $69;
 return (+$$0);
}
function _scalbn($x,$n) {
 $x = +$x;
 $n = $n|0;
 var $$ = 0, $$0 = 0, $$1 = 0, $0 = 0, $1 = 0.0, $10 = 0, $11 = 0.0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0.0, $18 = 0.0, $2 = 0, $3 = 0, $4 = 0.0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0.0, $9 = 0, $y$0 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($n|0)>(1023);
 if ($0) {
  $1 = $x * 8.9884656743115795E+307;
  $2 = (($n) + -1023)|0;
  $3 = ($2|0)>(1023);
  if ($3) {
   $4 = $1 * 8.9884656743115795E+307;
   $5 = (($n) + -2046)|0;
   $6 = ($5|0)>(1023);
   $$ = $6 ? 1023 : $5;
   $$0 = $$;$y$0 = $4;
  } else {
   $$0 = $2;$y$0 = $1;
  }
 } else {
  $7 = ($n|0)<(-1022);
  if ($7) {
   $8 = $x * 2.2250738585072014E-308;
   $9 = (($n) + 1022)|0;
   $10 = ($9|0)<(-1022);
   if ($10) {
    $11 = $8 * 2.2250738585072014E-308;
    $12 = (($n) + 2044)|0;
    $13 = ($12|0)<(-1022);
    $$1 = $13 ? -1022 : $12;
    $$0 = $$1;$y$0 = $11;
   } else {
    $$0 = $9;$y$0 = $8;
   }
  } else {
   $$0 = $n;$y$0 = $x;
  }
 }
 $14 = (($$0) + 1023)|0;
 $15 = (_bitshift64Shl(($14|0),0,52)|0);
 $16 = tempRet0;
 HEAP32[tempDoublePtr>>2] = $15;HEAP32[tempDoublePtr+4>>2] = $16;$17 = +HEAPF64[tempDoublePtr>>3];
 $18 = $y$0 * $17;
 return (+$18);
}
function _wctomb($s,$wc) {
 $s = $s|0;
 $wc = $wc|0;
 var $$0 = 0, $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($s|0)==(0|0);
 if ($0) {
  $$0 = 0;
 } else {
  $1 = (_wcrtomb($s,$wc,0)|0);
  $$0 = $1;
 }
 return ($$0|0);
}
function _wcrtomb($s,$wc,$st) {
 $s = $s|0;
 $wc = $wc|0;
 $st = $st|0;
 var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0;
 var $44 = 0, $45 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($s|0)==(0|0);
 if ($0) {
  $$0 = 1;
  return ($$0|0);
 }
 $1 = ($wc>>>0)<(128);
 if ($1) {
  $2 = $wc&255;
  HEAP8[$s>>0] = $2;
  $$0 = 1;
  return ($$0|0);
 }
 $3 = ($wc>>>0)<(2048);
 if ($3) {
  $4 = $wc >>> 6;
  $5 = $4 | 192;
  $6 = $5&255;
  $7 = ((($s)) + 1|0);
  HEAP8[$s>>0] = $6;
  $8 = $wc & 63;
  $9 = $8 | 128;
  $10 = $9&255;
  HEAP8[$7>>0] = $10;
  $$0 = 2;
  return ($$0|0);
 }
 $11 = ($wc>>>0)<(55296);
 $12 = $wc & -8192;
 $13 = ($12|0)==(57344);
 $or$cond = $11 | $13;
 if ($or$cond) {
  $14 = $wc >>> 12;
  $15 = $14 | 224;
  $16 = $15&255;
  $17 = ((($s)) + 1|0);
  HEAP8[$s>>0] = $16;
  $18 = $wc >>> 6;
  $19 = $18 & 63;
  $20 = $19 | 128;
  $21 = $20&255;
  $22 = ((($s)) + 2|0);
  HEAP8[$17>>0] = $21;
  $23 = $wc & 63;
  $24 = $23 | 128;
  $25 = $24&255;
  HEAP8[$22>>0] = $25;
  $$0 = 3;
  return ($$0|0);
 }
 $26 = (($wc) + -65536)|0;
 $27 = ($26>>>0)<(1048576);
 if ($27) {
  $28 = $wc >>> 18;
  $29 = $28 | 240;
  $30 = $29&255;
  $31 = ((($s)) + 1|0);
  HEAP8[$s>>0] = $30;
  $32 = $wc >>> 12;
  $33 = $32 & 63;
  $34 = $33 | 128;
  $35 = $34&255;
  $36 = ((($s)) + 2|0);
  HEAP8[$31>>0] = $35;
  $37 = $wc >>> 6;
  $38 = $37 & 63;
  $39 = $38 | 128;
  $40 = $39&255;
  $41 = ((($s)) + 3|0);
  HEAP8[$36>>0] = $40;
  $42 = $wc & 63;
  $43 = $42 | 128;
  $44 = $43&255;
  HEAP8[$41>>0] = $44;
  $$0 = 4;
  return ($$0|0);
 } else {
  $45 = (___errno_location()|0);
  HEAP32[$45>>2] = 84;
  $$0 = -1;
  return ($$0|0);
 }
 return (0)|0;
}
function ___towrite($f) {
 $f = $f|0;
 var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($f)) + 74|0);
 $1 = HEAP8[$0>>0]|0;
 $2 = $1 << 24 >> 24;
 $3 = (($2) + 255)|0;
 $4 = $3 | $2;
 $5 = $4&255;
 HEAP8[$0>>0] = $5;
 $6 = HEAP32[$f>>2]|0;
 $7 = $6 & 8;
 $8 = ($7|0)==(0);
 if ($8) {
  $10 = ((($f)) + 8|0);
  HEAP32[$10>>2] = 0;
  $11 = ((($f)) + 4|0);
  HEAP32[$11>>2] = 0;
  $12 = ((($f)) + 44|0);
  $13 = HEAP32[$12>>2]|0;
  $14 = ((($f)) + 28|0);
  HEAP32[$14>>2] = $13;
  $15 = ((($f)) + 20|0);
  HEAP32[$15>>2] = $13;
  $16 = $13;
  $17 = ((($f)) + 48|0);
  $18 = HEAP32[$17>>2]|0;
  $19 = (($16) + ($18)|0);
  $20 = ((($f)) + 16|0);
  HEAP32[$20>>2] = $19;
  $$0 = 0;
  return ($$0|0);
 } else {
  $9 = $6 | 32;
  HEAP32[$f>>2] = $9;
  $$0 = -1;
  return ($$0|0);
 }
 return (0)|0;
}
function ___fwritex($s,$l,$f) {
 $s = $s|0;
 $l = $l|0;
 $f = $f|0;
 var $$0 = 0, $$01 = 0, $$02 = 0, $$pre = 0, $$pre6 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0;
 var $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $i$0 = 0, $i$0$lcssa10 = 0;
 var $i$1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($f)) + 16|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($1|0)==(0|0);
 do {
  if ($2) {
   $3 = (___towrite($f)|0);
   $4 = ($3|0)==(0);
   if ($4) {
    $$pre = HEAP32[$0>>2]|0;
    $7 = $$pre;
    break;
   } else {
    $$0 = 0;
    return ($$0|0);
   }
  } else {
   $7 = $1;
  }
 } while(0);
 $5 = ((($f)) + 20|0);
 $6 = HEAP32[$5>>2]|0;
 $8 = $7;
 $9 = $6;
 $10 = (($8) - ($9))|0;
 $11 = ($10>>>0)<($l>>>0);
 if ($11) {
  $12 = ((($f)) + 36|0);
  $13 = HEAP32[$12>>2]|0;
  $14 = (FUNCTION_TABLE_iiii[$13 & 3]($f,$s,$l)|0);
  $$0 = $14;
  return ($$0|0);
 }
 $15 = ((($f)) + 75|0);
 $16 = HEAP8[$15>>0]|0;
 $17 = ($16<<24>>24)>(-1);
 L11: do {
  if ($17) {
   $i$0 = $l;
   while(1) {
    $18 = ($i$0|0)==(0);
    if ($18) {
     $$01 = $l;$$02 = $s;$29 = $6;$i$1 = 0;
     break L11;
    }
    $19 = (($i$0) + -1)|0;
    $20 = (($s) + ($19)|0);
    $21 = HEAP8[$20>>0]|0;
    $22 = ($21<<24>>24)==(10);
    if ($22) {
     $i$0$lcssa10 = $i$0;
     break;
    } else {
     $i$0 = $19;
    }
   }
   $23 = ((($f)) + 36|0);
   $24 = HEAP32[$23>>2]|0;
   $25 = (FUNCTION_TABLE_iiii[$24 & 3]($f,$s,$i$0$lcssa10)|0);
   $26 = ($25>>>0)<($i$0$lcssa10>>>0);
   if ($26) {
    $$0 = $i$0$lcssa10;
    return ($$0|0);
   } else {
    $27 = (($s) + ($i$0$lcssa10)|0);
    $28 = (($l) - ($i$0$lcssa10))|0;
    $$pre6 = HEAP32[$5>>2]|0;
    $$01 = $28;$$02 = $27;$29 = $$pre6;$i$1 = $i$0$lcssa10;
    break;
   }
  } else {
   $$01 = $l;$$02 = $s;$29 = $6;$i$1 = 0;
  }
 } while(0);
 _memcpy(($29|0),($$02|0),($$01|0))|0;
 $30 = HEAP32[$5>>2]|0;
 $31 = (($30) + ($$01)|0);
 HEAP32[$5>>2] = $31;
 $32 = (($i$1) + ($$01))|0;
 $$0 = $32;
 return ($$0|0);
}
function _sprintf($s,$fmt,$varargs) {
 $s = $s|0;
 $fmt = $fmt|0;
 $varargs = $varargs|0;
 var $0 = 0, $ap = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $ap = sp;
 HEAP32[$ap>>2] = $varargs;
 $0 = (_vsprintf($s,$fmt,$ap)|0);
 STACKTOP = sp;return ($0|0);
}
function _MUSL_vfprintf($f,$fmt,$ap) {
 $f = $f|0;
 $fmt = $fmt|0;
 $ap = $ap|0;
 var $$ = 0, $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 var $ap2 = 0, $internal_buf = 0, $nl_arg = 0, $nl_type = 0, $ret$1 = 0, $vacopy_currentptr = 0, dest = 0, label = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 224|0;
 $ap2 = sp + 120|0;
 $nl_type = sp + 80|0;
 $nl_arg = sp;
 $internal_buf = sp + 136|0;
 dest=$nl_type; stop=dest+40|0; do { HEAP32[dest>>2]=0|0; dest=dest+4|0; } while ((dest|0) < (stop|0));
 $vacopy_currentptr = HEAP32[$ap>>2]|0;
 HEAP32[$ap2>>2] = $vacopy_currentptr;
 $0 = (_printf_core(0,$fmt,$ap2,$nl_arg,$nl_type)|0);
 $1 = ($0|0)<(0);
 if ($1) {
  $$0 = -1;
  STACKTOP = sp;return ($$0|0);
 }
 $2 = ((($f)) + 48|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)==(0);
 if ($4) {
  $6 = ((($f)) + 44|0);
  $7 = HEAP32[$6>>2]|0;
  HEAP32[$6>>2] = $internal_buf;
  $8 = ((($f)) + 28|0);
  HEAP32[$8>>2] = $internal_buf;
  $9 = ((($f)) + 20|0);
  HEAP32[$9>>2] = $internal_buf;
  HEAP32[$2>>2] = 80;
  $10 = ((($internal_buf)) + 80|0);
  $11 = ((($f)) + 16|0);
  HEAP32[$11>>2] = $10;
  $12 = (_printf_core($f,$fmt,$ap2,$nl_arg,$nl_type)|0);
  $13 = ($7|0)==(0|0);
  if ($13) {
   $ret$1 = $12;
  } else {
   $14 = ((($f)) + 36|0);
   $15 = HEAP32[$14>>2]|0;
   (FUNCTION_TABLE_iiii[$15 & 3]($f,0,0)|0);
   $16 = HEAP32[$9>>2]|0;
   $17 = ($16|0)==(0|0);
   $$ = $17 ? -1 : $12;
   HEAP32[$6>>2] = $7;
   HEAP32[$2>>2] = 0;
   HEAP32[$11>>2] = 0;
   HEAP32[$8>>2] = 0;
   HEAP32[$9>>2] = 0;
   $ret$1 = $$;
  }
 } else {
  $5 = (_printf_core($f,$fmt,$ap2,$nl_arg,$nl_type)|0);
  $ret$1 = $5;
 }
 $$0 = $ret$1;
 STACKTOP = sp;return ($$0|0);
}
function _vsnprintf($s,$n,$fmt,$ap) {
 $s = $s|0;
 $n = $n|0;
 $fmt = $fmt|0;
 $ap = $ap|0;
 var $$$02 = 0, $$0 = 0, $$01 = 0, $$02 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $b = 0, $f = 0, dest = 0, label = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128|0;
 $b = sp + 112|0;
 $f = sp;
 dest=$f; src=95808; stop=dest+112|0; do { HEAP32[dest>>2]=HEAP32[src>>2]|0; dest=dest+4|0; src=src+4|0; } while ((dest|0) < (stop|0));
 $0 = (($n) + -1)|0;
 $1 = ($0>>>0)>(2147483646);
 if ($1) {
  $2 = ($n|0)==(0);
  if ($2) {
   $$01 = $b;$$02 = 1;
  } else {
   $3 = (___errno_location()|0);
   HEAP32[$3>>2] = 75;
   $$0 = -1;
   STACKTOP = sp;return ($$0|0);
  }
 } else {
  $$01 = $s;$$02 = $n;
 }
 $4 = $$01;
 $5 = (-2 - ($4))|0;
 $6 = ($$02>>>0)>($5>>>0);
 $$$02 = $6 ? $5 : $$02;
 $7 = ((($f)) + 48|0);
 HEAP32[$7>>2] = $$$02;
 $8 = ((($f)) + 20|0);
 HEAP32[$8>>2] = $$01;
 $9 = ((($f)) + 44|0);
 HEAP32[$9>>2] = $$01;
 $10 = (($$01) + ($$$02)|0);
 $11 = ((($f)) + 16|0);
 HEAP32[$11>>2] = $10;
 $12 = ((($f)) + 28|0);
 HEAP32[$12>>2] = $10;
 $13 = (_MUSL_vfprintf($f,$fmt,$ap)|0);
 $14 = ($$$02|0)==(0);
 if ($14) {
  $$0 = $13;
  STACKTOP = sp;return ($$0|0);
 }
 $15 = HEAP32[$8>>2]|0;
 $16 = HEAP32[$11>>2]|0;
 $17 = ($15|0)==($16|0);
 $18 = $17 << 31 >> 31;
 $19 = (($15) + ($18)|0);
 HEAP8[$19>>0] = 0;
 $$0 = $13;
 STACKTOP = sp;return ($$0|0);
}
function _vsprintf($s,$fmt,$ap) {
 $s = $s|0;
 $fmt = $fmt|0;
 $ap = $ap|0;
 var $0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (_vsnprintf($s,2147483647,$fmt,$ap)|0);
 return ($0|0);
}
function _memchr($src,$c,$n) {
 $src = $src|0;
 $c = $c|0;
 $n = $n|0;
 var $$0$lcssa = 0, $$0$lcssa44 = 0, $$019 = 0, $$1$lcssa = 0, $$110 = 0, $$110$lcssa = 0, $$24 = 0, $$3 = 0, $$lcssa = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 var $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0;
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond18 = 0, $s$0$lcssa = 0, $s$0$lcssa43 = 0, $s$020 = 0, $s$15 = 0, $s$2 = 0, $w$0$lcssa = 0, $w$011 = 0, $w$011$lcssa = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = $c & 255;
 $1 = $src;
 $2 = $1 & 3;
 $3 = ($2|0)!=(0);
 $4 = ($n|0)!=(0);
 $or$cond18 = $4 & $3;
 L1: do {
  if ($or$cond18) {
   $5 = $c&255;
   $$019 = $n;$s$020 = $src;
   while(1) {
    $6 = HEAP8[$s$020>>0]|0;
    $7 = ($6<<24>>24)==($5<<24>>24);
    if ($7) {
     $$0$lcssa44 = $$019;$s$0$lcssa43 = $s$020;
     label = 6;
     break L1;
    }
    $8 = ((($s$020)) + 1|0);
    $9 = (($$019) + -1)|0;
    $10 = $8;
    $11 = $10 & 3;
    $12 = ($11|0)!=(0);
    $13 = ($9|0)!=(0);
    $or$cond = $13 & $12;
    if ($or$cond) {
     $$019 = $9;$s$020 = $8;
    } else {
     $$0$lcssa = $9;$$lcssa = $13;$s$0$lcssa = $8;
     label = 5;
     break;
    }
   }
  } else {
   $$0$lcssa = $n;$$lcssa = $4;$s$0$lcssa = $src;
   label = 5;
  }
 } while(0);
 if ((label|0) == 5) {
  if ($$lcssa) {
   $$0$lcssa44 = $$0$lcssa;$s$0$lcssa43 = $s$0$lcssa;
   label = 6;
  } else {
   $$3 = 0;$s$2 = $s$0$lcssa;
  }
 }
 L8: do {
  if ((label|0) == 6) {
   $14 = HEAP8[$s$0$lcssa43>>0]|0;
   $15 = $c&255;
   $16 = ($14<<24>>24)==($15<<24>>24);
   if ($16) {
    $$3 = $$0$lcssa44;$s$2 = $s$0$lcssa43;
   } else {
    $17 = Math_imul($0, 16843009)|0;
    $18 = ($$0$lcssa44>>>0)>(3);
    L11: do {
     if ($18) {
      $$110 = $$0$lcssa44;$w$011 = $s$0$lcssa43;
      while(1) {
       $19 = HEAP32[$w$011>>2]|0;
       $20 = $19 ^ $17;
       $21 = (($20) + -16843009)|0;
       $22 = $20 & -2139062144;
       $23 = $22 ^ -2139062144;
       $24 = $23 & $21;
       $25 = ($24|0)==(0);
       if (!($25)) {
        $$110$lcssa = $$110;$w$011$lcssa = $w$011;
        break;
       }
       $26 = ((($w$011)) + 4|0);
       $27 = (($$110) + -4)|0;
       $28 = ($27>>>0)>(3);
       if ($28) {
        $$110 = $27;$w$011 = $26;
       } else {
        $$1$lcssa = $27;$w$0$lcssa = $26;
        label = 11;
        break L11;
       }
      }
      $$24 = $$110$lcssa;$s$15 = $w$011$lcssa;
     } else {
      $$1$lcssa = $$0$lcssa44;$w$0$lcssa = $s$0$lcssa43;
      label = 11;
     }
    } while(0);
    if ((label|0) == 11) {
     $29 = ($$1$lcssa|0)==(0);
     if ($29) {
      $$3 = 0;$s$2 = $w$0$lcssa;
      break;
     } else {
      $$24 = $$1$lcssa;$s$15 = $w$0$lcssa;
     }
    }
    while(1) {
     $30 = HEAP8[$s$15>>0]|0;
     $31 = ($30<<24>>24)==($15<<24>>24);
     if ($31) {
      $$3 = $$24;$s$2 = $s$15;
      break L8;
     }
     $32 = ((($s$15)) + 1|0);
     $33 = (($$24) + -1)|0;
     $34 = ($33|0)==(0);
     if ($34) {
      $$3 = 0;$s$2 = $32;
      break;
     } else {
      $$24 = $33;$s$15 = $32;
     }
    }
   }
  }
 } while(0);
 $35 = ($$3|0)!=(0);
 $36 = $35 ? $s$2 : 0;
 return ($36|0);
}
function _printf_core($f,$fmt,$ap,$nl_arg,$nl_type) {
 $f = $f|0;
 $fmt = $fmt|0;
 $ap = $ap|0;
 $nl_arg = $nl_arg|0;
 $nl_type = $nl_type|0;
 var $$ = 0, $$$i = 0, $$0 = 0, $$0$i = 0, $$0$lcssa$i = 0, $$0$lcssa$i$i = 0, $$0$lcssa$i104$i = 0, $$0$lcssa$i128$i = 0, $$0$lcssa$i143$i = 0, $$0$lcssa$i39$i = 0, $$0$lcssa$i46 = 0, $$0$lcssa$i46$i = 0, $$0$lcssa$i48$i = 0, $$0$lcssa$i51 = 0, $$0$lcssa$i53 = 0, $$0$lcssa$i56$i = 0, $$0$lcssa$i61 = 0, $$0$lcssa$i63$i = 0, $$0$lcssa$i68 = 0, $$0$lcssa$i69$i = 0;
 var $$0$lcssa$i75 = 0, $$0$lcssa$i76$i = 0, $$0$lcssa$i84$i = 0, $$0$lcssa$i85 = 0, $$0$lcssa$i97$i = 0, $$01$i = 0, $$01$i$i = 0, $$01$i102$i = 0, $$01$i126$i = 0, $$01$i141$i = 0, $$01$i37$i = 0, $$01$i44 = 0, $$01$i44$i = 0, $$01$i54$i = 0, $$01$i59 = 0, $$01$i61$i = 0, $$01$i66 = 0, $$01$i67$i = 0, $$01$i73 = 0, $$01$i74$i = 0;
 var $$01$i83 = 0, $$01$i95$i = 0, $$01$lcssa$off0$i = 0, $$01$lcssa$off0$i$i = 0, $$01$lcssa$off0$i85$i = 0, $$012$i = 0, $$013$i = 0, $$03$i48 = 0, $$05$i = 0, $$05$i$i = 0, $$05$i79$i = 0, $$07$i = 0.0, $$1$i = 0.0, $$1$lcssa$i$i = 0, $$1$lcssa$i112$i = 0, $$114$i = 0, $$12$i = 0, $$12$i$i = 0, $$12$i110$i = 0, $$12$i119$i = 0;
 var $$12$i134$i = 0, $$12$i134$i$lcssa = 0, $$12$i87$i = 0, $$2$i = 0.0, $$2$us$i = 0.0, $$2$us$us$i = 0.0, $$20$i = 0.0, $$21$i = 0, $$210$$22$i = 0, $$210$$24$i = 0, $$210$i = 0, $$23$i = 0, $$24 = 0, $$25 = 0, $$3$i = 0.0, $$31$i = 0, $$311$i = 0, $$4$i = 0.0, $$412$lcssa$i = 0, $$412184$i = 0;
 var $$5196$i = 0, $$92 = 0, $$a$3$i = 0, $$a$3$us$i = 0, $$a$3$us303$i = 0, $$a$3$us304$i = 0, $$a$3305$i = 0, $$a$3306$i = 0, $$fl$4 = 0, $$l10n$0 = 0, $$lcssa106 = 0, $$lcssa275$i = 0, $$lcssa450 = 0, $$lcssa451 = 0, $$lcssa455 = 0, $$lcssa457 = 0, $$lcssa458 = 0, $$lcssa459 = 0, $$lcssa460 = 0, $$lcssa461 = 0;
 var $$lcssa463 = 0, $$lcssa464 = 0, $$lcssa470 = 0, $$lcssa474 = 0, $$lcssa476 = 0, $$lcssa479 = 0, $$lcssa480 = 0, $$lcssa483 = 0.0, $$lcssa484 = 0, $$lcssa487 = 0, $$lcssa491 = 0, $$mask$i = 0, $$mask$i38 = 0, $$mask1$i = 0, $$mask1$i37 = 0, $$neg151$i = 0, $$neg152$i = 0, $$p$$i = 0, $$p$5 = 0, $$p$i = 0;
 var $$pn$i = 0, $$pr$i = 0, $$pr146$i = 0, $$pre = 0, $$pre$i = 0, $$pre$phi302$iZ2D = 0, $$pre270 = 0, $$pre300$i = 0, $$pre301$i = 0, $$sum$i = 0, $$sum15$i = 0, $$sum16$i = 0, $$z$3$i = 0, $$z$4$i = 0, $$z$4$us$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $1000 = 0;
 var $1001 = 0, $1002 = 0, $1003 = 0, $1004 = 0, $1005 = 0, $1006 = 0, $1007 = 0, $1008 = 0, $1009 = 0, $101 = 0, $1010 = 0, $1011 = 0, $1012 = 0, $1013 = 0, $1014 = 0, $1015 = 0, $1016 = 0, $1017 = 0, $1018 = 0, $1019 = 0;
 var $102 = 0, $1020 = 0, $1021 = 0, $1022 = 0, $1023 = 0, $1024 = 0, $1025 = 0, $1026 = 0, $1027 = 0, $1028 = 0, $1029 = 0, $103 = 0, $1030 = 0, $1031 = 0, $1032 = 0, $1033 = 0, $1034 = 0, $1035 = 0, $1036 = 0, $1037 = 0;
 var $1038 = 0, $1039 = 0, $104 = 0, $1040 = 0, $1041 = 0, $1042 = 0, $1043 = 0, $1044 = 0, $1045 = 0, $1046 = 0, $1047 = 0, $1048 = 0, $1049 = 0, $105 = 0, $1050 = 0, $1051 = 0, $1052 = 0, $1053 = 0, $1054 = 0, $1055 = 0;
 var $1056 = 0, $1057 = 0, $1058 = 0, $1059 = 0, $106 = 0, $1060 = 0, $1061 = 0, $1062 = 0, $1063 = 0, $1064 = 0, $1065 = 0, $1066 = 0, $1067 = 0, $1068 = 0, $1069 = 0, $107 = 0, $1070 = 0, $1071 = 0, $1072 = 0, $1073 = 0;
 var $1074 = 0, $1075 = 0, $1076 = 0, $1077 = 0, $1078 = 0, $1079 = 0, $108 = 0, $1080 = 0, $1081 = 0, $1082 = 0, $1083 = 0, $1084 = 0, $1085 = 0, $1086 = 0, $1087 = 0, $1088 = 0, $1089 = 0, $109 = 0, $1090 = 0, $1091 = 0;
 var $1092 = 0, $1093 = 0, $1094 = 0, $1095 = 0, $1096 = 0, $1097 = 0, $1098 = 0, $1099 = 0, $11 = 0, $110 = 0, $1100 = 0, $1101 = 0, $1102 = 0, $1103 = 0, $1104 = 0, $1105 = 0, $1106 = 0, $1107 = 0, $1108 = 0, $1109 = 0;
 var $111 = 0, $1110 = 0, $1111 = 0, $1112 = 0, $1113 = 0, $1114 = 0, $1115 = 0, $1116 = 0, $1117 = 0, $1118 = 0, $1119 = 0, $112 = 0, $1120 = 0, $1121 = 0, $1122 = 0, $1123 = 0, $1124 = 0, $1125 = 0, $1126 = 0, $1127 = 0;
 var $1128 = 0, $1129 = 0, $113 = 0, $1130 = 0, $1131 = 0, $1132 = 0, $1133 = 0, $1134 = 0, $1135 = 0, $1136 = 0, $1137 = 0, $1138 = 0, $1139 = 0, $114 = 0, $1140 = 0, $1141 = 0, $1142 = 0, $1143 = 0, $1144 = 0, $1145 = 0;
 var $1146 = 0, $1147 = 0, $1148 = 0, $1149 = 0, $115 = 0, $1150 = 0, $1151 = 0, $1152 = 0, $1153 = 0, $1154 = 0.0, $1155 = 0, $1156 = 0, $1157 = 0, $1158 = 0, $1159 = 0, $116 = 0, $1160 = 0, $1161 = 0.0, $1162 = 0, $1163 = 0;
 var $1164 = 0, $1165 = 0, $1166 = 0, $1167 = 0, $1168 = 0, $1169 = 0, $1169$phi = 0, $117 = 0, $1170 = 0, $1170$phi = 0, $1171 = 0, $1172 = 0, $1173 = 0, $1174 = 0, $1175 = 0, $1176 = 0, $1177 = 0, $1178 = 0, $1179 = 0, $118 = 0;
 var $1180 = 0, $1181 = 0, $1182 = 0, $1183 = 0, $1184 = 0, $1185 = 0, $1186 = 0, $1187 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0;
 var $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0;
 var $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0;
 var $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0;
 var $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0;
 var $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0;
 var $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0;
 var $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0.0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0.0, $253 = 0, $254 = 0, $255 = 0;
 var $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0;
 var $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0;
 var $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0;
 var $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0;
 var $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0;
 var $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0;
 var $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0;
 var $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0;
 var $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0;
 var $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0.0, $431 = 0, $432 = 0.0, $433 = 0, $434 = 0, $435 = 0;
 var $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0;
 var $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $469 = 0, $47 = 0, $470 = 0, $471 = 0.0;
 var $472 = 0.0, $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0, $486 = 0, $487 = 0.0, $488 = 0, $489 = 0, $49 = 0;
 var $490 = 0, $491 = 0.0, $492 = 0.0, $493 = 0.0, $494 = 0.0, $495 = 0.0, $496 = 0.0, $497 = 0, $498 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $502 = 0, $503 = 0, $504 = 0, $505 = 0, $506 = 0, $507 = 0;
 var $508 = 0, $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $514 = 0, $515 = 0, $516 = 0, $517 = 0, $518 = 0, $519 = 0, $52 = 0, $520 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0, $525 = 0;
 var $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $534 = 0, $535 = 0, $536 = 0, $537 = 0, $538 = 0, $539 = 0, $54 = 0, $540 = 0, $541 = 0, $542 = 0, $543 = 0;
 var $544 = 0.0, $545 = 0.0, $546 = 0.0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0, $552 = 0, $553 = 0, $554 = 0, $555 = 0, $556 = 0, $557 = 0, $558 = 0, $559 = 0.0, $56 = 0, $560 = 0.0, $561 = 0.0;
 var $562 = 0, $563 = 0, $564 = 0, $565 = 0, $566 = 0, $567 = 0, $568 = 0, $569 = 0, $57 = 0, $570 = 0, $571 = 0, $572 = 0, $573 = 0, $574 = 0.0, $575 = 0.0, $576 = 0.0, $577 = 0, $578 = 0, $579 = 0, $58 = 0;
 var $580 = 0, $581 = 0, $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0, $587 = 0, $588 = 0, $589 = 0, $59 = 0, $590 = 0, $591 = 0, $592 = 0, $593 = 0, $594 = 0, $595 = 0, $596 = 0, $597 = 0, $598 = 0;
 var $599 = 0, $6 = 0, $60 = 0, $600 = 0, $601 = 0, $602 = 0, $603 = 0, $604 = 0, $605 = 0, $606 = 0, $607 = 0, $608 = 0, $609 = 0, $61 = 0, $610 = 0, $611 = 0, $612 = 0, $613 = 0, $614 = 0, $615 = 0;
 var $616 = 0, $617 = 0, $618 = 0, $619 = 0, $62 = 0, $620 = 0, $621 = 0, $622 = 0, $623 = 0, $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0, $629 = 0, $63 = 0, $630 = 0, $631 = 0.0, $632 = 0, $633 = 0;
 var $634 = 0, $635 = 0, $636 = 0, $637 = 0, $638 = 0, $639 = 0.0, $64 = 0, $640 = 0.0, $641 = 0.0, $642 = 0, $643 = 0, $644 = 0, $645 = 0, $646 = 0, $647 = 0, $648 = 0, $649 = 0, $65 = 0, $650 = 0, $651 = 0;
 var $652 = 0, $653 = 0, $654 = 0, $655 = 0, $656 = 0, $657 = 0, $658 = 0, $659 = 0, $66 = 0, $660 = 0, $661 = 0, $662 = 0, $663 = 0, $664 = 0, $665 = 0, $666 = 0, $667 = 0, $668 = 0, $669 = 0, $67 = 0;
 var $670 = 0, $671 = 0, $672 = 0, $673 = 0, $674 = 0, $675 = 0, $676 = 0, $677 = 0, $678 = 0, $679 = 0, $68 = 0, $680 = 0, $681 = 0, $682 = 0, $683 = 0, $684 = 0, $685 = 0, $686 = 0, $687 = 0, $688 = 0;
 var $689 = 0, $69 = 0, $690 = 0, $691 = 0, $692 = 0, $693 = 0, $694 = 0, $695 = 0, $696 = 0, $697 = 0, $698 = 0, $699 = 0, $7 = 0, $70 = 0, $700 = 0, $701 = 0, $702 = 0, $703 = 0, $704 = 0, $705 = 0;
 var $706 = 0, $707 = 0, $708 = 0, $709 = 0, $71 = 0, $710 = 0, $711 = 0, $712 = 0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $72 = 0, $720 = 0, $721 = 0, $722 = 0, $723 = 0;
 var $724 = 0, $725 = 0, $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0, $730 = 0, $731 = 0, $732 = 0, $733 = 0, $734 = 0, $735 = 0, $736 = 0, $737 = 0, $738 = 0, $739 = 0, $74 = 0, $740 = 0, $741 = 0;
 var $742 = 0, $743 = 0, $744 = 0, $745 = 0, $746 = 0, $747 = 0, $748 = 0, $749 = 0, $75 = 0, $750 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0, $755 = 0, $756 = 0, $757 = 0, $758 = 0, $759 = 0, $76 = 0;
 var $760 = 0, $761 = 0, $762 = 0, $763 = 0, $764 = 0, $765 = 0, $766 = 0, $767 = 0, $768 = 0, $769 = 0, $77 = 0, $770 = 0, $771 = 0, $772 = 0, $773 = 0, $774 = 0, $775 = 0, $776 = 0, $777 = 0, $778 = 0;
 var $779 = 0, $78 = 0, $780 = 0.0, $781 = 0.0, $782 = 0, $783 = 0.0, $784 = 0, $785 = 0, $786 = 0, $787 = 0, $788 = 0, $789 = 0, $79 = 0, $790 = 0, $791 = 0, $792 = 0, $793 = 0, $794 = 0, $795 = 0, $796 = 0;
 var $797 = 0, $798 = 0, $799 = 0, $8 = 0, $80 = 0, $800 = 0, $801 = 0, $802 = 0, $803 = 0, $804 = 0, $805 = 0, $806 = 0, $807 = 0, $808 = 0, $809 = 0, $81 = 0, $810 = 0, $811 = 0, $812 = 0, $813 = 0;
 var $814 = 0, $815 = 0, $816 = 0, $817 = 0, $818 = 0, $819 = 0, $82 = 0, $820 = 0, $821 = 0, $822 = 0, $823 = 0, $824 = 0, $825 = 0, $826 = 0, $827 = 0, $828 = 0, $829 = 0, $83 = 0, $830 = 0, $831 = 0;
 var $832 = 0, $833 = 0, $834 = 0, $835 = 0, $836 = 0, $837 = 0, $838 = 0, $839 = 0, $84 = 0, $840 = 0, $841 = 0, $842 = 0, $843 = 0, $844 = 0, $845 = 0, $846 = 0, $847 = 0, $848 = 0, $849 = 0, $85 = 0;
 var $850 = 0, $851 = 0, $852 = 0, $853 = 0, $854 = 0, $855 = 0, $856 = 0, $857 = 0, $858 = 0, $859 = 0, $86 = 0, $860 = 0, $861 = 0, $862 = 0, $863 = 0, $864 = 0, $865 = 0, $866 = 0, $867 = 0, $868 = 0;
 var $869 = 0, $87 = 0, $870 = 0, $871 = 0, $872 = 0, $873 = 0, $874 = 0, $875 = 0, $876 = 0, $877 = 0, $878 = 0, $879 = 0, $88 = 0, $880 = 0, $881 = 0, $882 = 0, $883 = 0, $884 = 0, $885 = 0, $886 = 0;
 var $887 = 0, $888 = 0, $889 = 0, $89 = 0, $890 = 0, $891 = 0, $892 = 0, $893 = 0, $894 = 0, $895 = 0, $896 = 0, $897 = 0, $898 = 0, $899 = 0, $9 = 0, $90 = 0, $900 = 0, $901 = 0, $902 = 0, $903 = 0;
 var $904 = 0, $905 = 0, $906 = 0, $907 = 0, $908 = 0, $909 = 0, $91 = 0, $910 = 0, $911 = 0, $912 = 0, $913 = 0, $914 = 0, $915 = 0, $916 = 0, $917 = 0, $918 = 0, $919 = 0, $92 = 0, $920 = 0, $921 = 0;
 var $922 = 0, $923 = 0, $924 = 0, $925 = 0, $926 = 0, $927 = 0, $928 = 0, $929 = 0, $93 = 0, $930 = 0, $931 = 0, $932 = 0, $933 = 0, $934 = 0, $935 = 0, $936 = 0, $937 = 0, $938 = 0, $939 = 0, $94 = 0;
 var $940 = 0, $941 = 0, $942 = 0, $943 = 0, $944 = 0, $945 = 0, $946 = 0, $947 = 0, $948 = 0, $949 = 0, $95 = 0, $950 = 0, $951 = 0, $952 = 0, $953 = 0, $954 = 0, $955 = 0, $956 = 0, $957 = 0, $958 = 0;
 var $959 = 0, $96 = 0, $960 = 0, $961 = 0, $962 = 0, $963 = 0, $964 = 0, $965 = 0, $966 = 0, $967 = 0, $968 = 0, $969 = 0, $97 = 0, $970 = 0, $971 = 0, $972 = 0, $973 = 0, $974 = 0, $975 = 0, $976 = 0;
 var $977 = 0, $978 = 0, $979 = 0, $98 = 0, $980 = 0, $981 = 0, $982 = 0, $983 = 0, $984 = 0, $985 = 0, $986 = 0, $987 = 0, $988 = 0, $989 = 0, $99 = 0, $990 = 0, $991 = 0, $992 = 0, $993 = 0, $994 = 0;
 var $995 = 0, $996 = 0, $997 = 0, $998 = 0, $999 = 0, $a$0 = 0, $a$1 = 0, $a$1$lcssa$i = 0, $a$1253$i = 0, $a$2 = 0, $a$2$ph$i = 0, $a$3$lcssa$i = 0, $a$3240$i = 0, $a$3240$us$i = 0, $a$5$lcssa$i = 0, $a$5215$i = 0, $a$6$i = 0, $a$7$i = 0, $a$8$ph$i = 0, $arglist_current = 0;
 var $arglist_current11 = 0, $arglist_current14 = 0, $arglist_current17 = 0, $arglist_current2 = 0, $arglist_current20 = 0, $arglist_current23 = 0, $arglist_current26 = 0, $arglist_current29 = 0, $arglist_current32 = 0, $arglist_current35 = 0, $arglist_current38 = 0, $arglist_current41 = 0, $arglist_current44 = 0, $arglist_current47 = 0, $arglist_current5 = 0, $arglist_current50 = 0, $arglist_current53 = 0, $arglist_current56 = 0, $arglist_current59 = 0, $arglist_current62 = 0;
 var $arglist_current8 = 0, $arglist_next = 0, $arglist_next12 = 0, $arglist_next15 = 0, $arglist_next18 = 0, $arglist_next21 = 0, $arglist_next24 = 0, $arglist_next27 = 0, $arglist_next3 = 0, $arglist_next30 = 0, $arglist_next33 = 0, $arglist_next36 = 0, $arglist_next39 = 0, $arglist_next42 = 0, $arglist_next45 = 0, $arglist_next48 = 0, $arglist_next51 = 0, $arglist_next54 = 0, $arglist_next57 = 0, $arglist_next6 = 0;
 var $arglist_next60 = 0, $arglist_next63 = 0, $arglist_next9 = 0, $argpos$0 = 0, $big$i = 0, $buf = 0, $buf$i = 0, $carry$0246$i = 0, $carry3$0234$i = 0, $carry3$0234$us$i = 0, $cnt$0 = 0, $cnt$1 = 0, $cnt$1$lcssa = 0, $d$0$i = 0, $d$0245$i = 0, $d$0247$i = 0, $d$1233$i = 0, $d$1233$us$i = 0, $d$2$lcssa$i = 0, $d$2214$i = 0;
 var $d$3$i = 0, $d$4191$i = 0, $d$5183$i = 0, $d$6195$i = 0, $e$0229$i = 0, $e$1$i = 0, $e$2210$i = 0, $e$3$i = 0, $e$4$ph$i = 0, $e2$i = 0, $ebuf0$i = 0, $estr$0$i = 0, $estr$1$lcssa$i = 0, $estr$1$ph$i = 0, $estr$1201$i = 0, $estr$2$i = 0, $exitcond$i = 0, $expanded = 0, $expanded101 = 0, $expanded102 = 0;
 var $expanded103 = 0, $expanded105 = 0, $expanded106 = 0, $expanded108 = 0, $expanded109 = 0, $expanded110 = 0, $expanded112 = 0, $expanded113 = 0, $expanded115 = 0, $expanded116 = 0, $expanded117 = 0, $expanded119 = 0, $expanded120 = 0, $expanded122 = 0, $expanded123 = 0, $expanded124 = 0, $expanded126 = 0, $expanded127 = 0, $expanded129 = 0, $expanded130 = 0;
 var $expanded131 = 0, $expanded133 = 0, $expanded134 = 0, $expanded136 = 0, $expanded137 = 0, $expanded138 = 0, $expanded140 = 0, $expanded141 = 0, $expanded143 = 0, $expanded144 = 0, $expanded145 = 0, $expanded147 = 0, $expanded148 = 0, $expanded150 = 0, $expanded151 = 0, $expanded152 = 0, $expanded154 = 0, $expanded155 = 0, $expanded157 = 0, $expanded158 = 0;
 var $expanded159 = 0, $expanded161 = 0, $expanded162 = 0, $expanded164 = 0, $expanded165 = 0, $expanded166 = 0, $expanded168 = 0, $expanded169 = 0, $expanded171 = 0, $expanded172 = 0, $expanded173 = 0, $expanded175 = 0, $expanded176 = 0, $expanded178 = 0, $expanded179 = 0, $expanded180 = 0, $expanded182 = 0, $expanded183 = 0, $expanded185 = 0, $expanded186 = 0;
 var $expanded187 = 0, $expanded189 = 0, $expanded190 = 0, $expanded192 = 0, $expanded193 = 0, $expanded194 = 0, $expanded196 = 0, $expanded197 = 0, $expanded199 = 0, $expanded200 = 0, $expanded201 = 0, $expanded203 = 0, $expanded204 = 0, $expanded206 = 0, $expanded207 = 0, $expanded208 = 0, $expanded210 = 0, $expanded211 = 0, $expanded213 = 0, $expanded214 = 0;
 var $expanded215 = 0, $expanded64 = 0, $expanded66 = 0, $expanded67 = 0, $expanded68 = 0, $expanded70 = 0, $expanded71 = 0, $expanded73 = 0, $expanded74 = 0, $expanded75 = 0, $expanded77 = 0, $expanded78 = 0, $expanded80 = 0, $expanded81 = 0, $expanded82 = 0, $expanded84 = 0, $expanded85 = 0, $expanded87 = 0, $expanded88 = 0, $expanded89 = 0;
 var $expanded91 = 0, $expanded92 = 0, $expanded94 = 0, $expanded95 = 0, $expanded96 = 0, $expanded98 = 0, $expanded99 = 0, $fl$0110 = 0, $fl$0170 = 0, $fl$1 = 0, $fl$1$ = 0, $fl$3 = 0, $fl$4 = 0, $fl$6 = 0, $i$0$lcssa = 0, $i$0$lcssa273 = 0, $i$0175 = 0, $i$0228$i = 0, $i$03$i = 0, $i$03$i30 = 0;
 var $i$1$lcssa$i = 0, $i$1186 = 0, $i$1222$i = 0, $i$2162 = 0, $i$2162$lcssa = 0, $i$2209$i = 0, $i$3160 = 0, $i$3205$i = 0, $isdigit = 0, $isdigit$i = 0, $isdigit$i32 = 0, $isdigit10 = 0, $isdigit12 = 0, $isdigit2$i = 0, $isdigit2$i28 = 0, $isdigittmp = 0, $isdigittmp$ = 0, $isdigittmp$i = 0, $isdigittmp$i31 = 0, $isdigittmp1$i = 0;
 var $isdigittmp1$i27 = 0, $isdigittmp11 = 0, $isdigittmp4$i = 0, $isdigittmp4$i29 = 0, $isdigittmp9 = 0, $j$0$i = 0, $j$0221$i = 0, $j$0223$i = 0, $j$1206$i = 0, $j$2$i = 0, $l$0 = 0, $l$0$i = 0, $l$1$i = 0, $l$1174 = 0, $l$2 = 0, $l10n$0 = 0, $l10n$0$lcssa = 0, $l10n$0$phi = 0, $l10n$1 = 0, $l10n$2 = 0;
 var $l10n$3 = 0, $mb = 0, $notlhs$us$us$i = 0, $notrhs$i = 0, $or$cond = 0, $or$cond$i = 0, $or$cond$i$i = 0, $or$cond$i100$i = 0, $or$cond$i35$i = 0, $or$cond$i42$i = 0, $or$cond$i52$i = 0, $or$cond$i57 = 0, $or$cond$i59$i = 0, $or$cond$i64 = 0, $or$cond$i71 = 0, $or$cond$i72$i = 0, $or$cond$i79 = 0, $or$cond$i81 = 0, $or$cond$i93$i = 0, $or$cond15 = 0;
 var $or$cond19 = 0, $or$cond22 = 0, $or$cond29$i = 0, $or$cond332 = 0, $or$cond6$i = 0, $p$0 = 0, $p$1 = 0, $p$2 = 0, $p$2$ = 0, $p$3 = 0, $p$4272 = 0, $p$5 = 0, $pad$i = 0, $pl$0 = 0, $pl$0$i = 0, $pl$1 = 0, $pl$1$i = 0, $pl$2 = 0, $prefix$0 = 0, $prefix$0$$i = 0;
 var $prefix$0$i = 0, $prefix$1 = 0, $prefix$2 = 0, $r$0$a$8$i = 0, $re$1179$i = 0, $round$0178$i = 0.0, $round6$1$i = 0.0, $s$0$i = 0, $s$0$us$i = 0, $s$0$us$us$i = 0, $s$1$i = 0, $s$1$lcssa$i = 0, $s$1$us$i = 0, $s$1$us$us$i = 0, $s1$0$i = 0, $s7$0188$i = 0, $s7$1$i = 0, $s8$0$lcssa$i = 0, $s8$0180$i = 0, $s9$0$i = 0;
 var $s9$1192$i = 0, $s9$2$i = 0, $sext = 0, $sext93 = 0, $small$0$i = 0.0, $small$1$i = 0.0, $st$0 = 0, $st$0$lcssa456 = 0, $storemerge = 0, $storemerge13 = 0, $storemerge8108 = 0, $storemerge8169 = 0, $t$0 = 0, $t$1 = 0, $w$$i = 0, $w$0 = 0, $w$1 = 0, $w$2 = 0, $w$30$i = 0, $wc = 0;
 var $ws$0176 = 0, $ws$1187 = 0, $y$03$i = 0, $y$03$i$i = 0, $y$03$i109$i = 0, $y$03$i118$i = 0, $y$03$i133$i = 0, $y$03$i86$i = 0, $z$0$i = 0, $z$0$lcssa = 0, $z$0163 = 0, $z$1 = 0, $z$1$lcssa$i = 0, $z$1252$i = 0, $z$2 = 0, $z$2$i = 0, $z$2$i$lcssa = 0, $z$3$lcssa$i = 0, $z$3239$i = 0, $z$3239$us$i = 0;
 var $z$4$i = 0, $z$4$us$i = 0, $z$6$$i = 0, $z$6$i = 0, $z$6$i$lcssa = 0, $z$6$ph$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 864|0;
 $big$i = sp + 16|0;
 $e2$i = sp + 8|0;
 $buf$i = sp + 836|0;
 $0 = $buf$i;
 $ebuf0$i = sp + 824|0;
 $pad$i = sp + 568|0;
 $buf = sp + 528|0;
 $wc = sp;
 $mb = sp + 520|0;
 $1 = ($f|0)!=(0|0);
 $2 = ((($buf)) + 40|0);
 $3 = $2;
 $4 = ((($buf)) + 39|0);
 $5 = ((($wc)) + 4|0);
 $6 = $wc;
 $7 = ((($ebuf0$i)) + 12|0);
 $8 = ((($ebuf0$i)) + 11|0);
 $9 = $7;
 $10 = (($9) - ($0))|0;
 $11 = (-2 - ($0))|0;
 $12 = (($9) + 2)|0;
 $13 = ((($big$i)) + 288|0);
 $14 = ((($buf$i)) + 9|0);
 $15 = $14;
 $16 = ((($buf$i)) + 8|0);
 $1169 = 0;$1170 = 0;$23 = $fmt;$cnt$0 = 0;$l$0 = 0;$l10n$0 = 0;
 L1: while(1) {
  $17 = ($cnt$0|0)>(-1);
  do {
   if ($17) {
    $18 = (2147483647 - ($cnt$0))|0;
    $19 = ($l$0|0)>($18|0);
    if ($19) {
     $20 = (___errno_location()|0);
     HEAP32[$20>>2] = 75;
     $cnt$1 = -1;
     break;
    } else {
     $21 = (($l$0) + ($cnt$0))|0;
     $cnt$1 = $21;
     break;
    }
   } else {
    $cnt$1 = $cnt$0;
   }
  } while(0);
  $22 = HEAP8[$23>>0]|0;
  $24 = ($22<<24>>24)==(0);
  if ($24) {
   $cnt$1$lcssa = $cnt$1;$l10n$0$lcssa = $l10n$0;
   label = 344;
   break;
  } else {
   $1171 = $22;$26 = $23;
  }
  while(1) {
   if ((($1171<<24>>24) == 0)) {
    $$lcssa106 = $26;$z$0$lcssa = $26;
    break;
   } else if ((($1171<<24>>24) == 37)) {
    $28 = $26;$z$0163 = $26;
    label = 9;
    break;
   }
   $25 = ((($26)) + 1|0);
   $$pre = HEAP8[$25>>0]|0;
   $1171 = $$pre;$26 = $25;
  }
  L12: do {
   if ((label|0) == 9) {
    while(1) {
     label = 0;
     $27 = ((($28)) + 1|0);
     $29 = HEAP8[$27>>0]|0;
     $30 = ($29<<24>>24)==(37);
     if (!($30)) {
      $$lcssa106 = $28;$z$0$lcssa = $z$0163;
      break L12;
     }
     $31 = ((($z$0163)) + 1|0);
     $32 = ((($28)) + 2|0);
     $33 = HEAP8[$32>>0]|0;
     $34 = ($33<<24>>24)==(37);
     if ($34) {
      $28 = $32;$z$0163 = $31;
      label = 9;
     } else {
      $$lcssa106 = $32;$z$0$lcssa = $31;
      break;
     }
    }
   }
  } while(0);
  $35 = $z$0$lcssa;
  $36 = $23;
  $37 = (($35) - ($36))|0;
  if ($1) {
   (___fwritex($23,$37,$f)|0);
  }
  $38 = ($z$0$lcssa|0)==($23|0);
  if (!($38)) {
   $l10n$0$phi = $l10n$0;$1170$phi = $1170;$1169$phi = $1169;$23 = $$lcssa106;$cnt$0 = $cnt$1;$l$0 = $37;$l10n$0 = $l10n$0$phi;$1170 = $1170$phi;$1169 = $1169$phi;
   continue;
  }
  $39 = ((($$lcssa106)) + 1|0);
  $40 = HEAP8[$39>>0]|0;
  $41 = $40 << 24 >> 24;
  $isdigittmp = (($41) + -48)|0;
  $isdigit = ($isdigittmp>>>0)<(10);
  if ($isdigit) {
   $42 = ((($$lcssa106)) + 2|0);
   $43 = HEAP8[$42>>0]|0;
   $44 = ($43<<24>>24)==(36);
   $45 = ((($$lcssa106)) + 3|0);
   $$92 = $44 ? $45 : $39;
   $$l10n$0 = $44 ? 1 : $l10n$0;
   $isdigittmp$ = $44 ? $isdigittmp : -1;
   $$pre270 = HEAP8[$$92>>0]|0;
   $47 = $$pre270;$argpos$0 = $isdigittmp$;$l10n$1 = $$l10n$0;$storemerge = $$92;
  } else {
   $47 = $40;$argpos$0 = -1;$l10n$1 = $l10n$0;$storemerge = $39;
  }
  $46 = $47 << 24 >> 24;
  $48 = $46 & -32;
  $49 = ($48|0)==(32);
  L24: do {
   if ($49) {
    $51 = $46;$56 = $47;$fl$0170 = 0;$storemerge8169 = $storemerge;
    while(1) {
     $50 = (($51) + -32)|0;
     $52 = 1 << $50;
     $53 = $52 & 75913;
     $54 = ($53|0)==(0);
     if ($54) {
      $65 = $56;$fl$0110 = $fl$0170;$storemerge8108 = $storemerge8169;
      break L24;
     }
     $55 = $56 << 24 >> 24;
     $57 = (($55) + -32)|0;
     $58 = 1 << $57;
     $59 = $58 | $fl$0170;
     $60 = ((($storemerge8169)) + 1|0);
     $61 = HEAP8[$60>>0]|0;
     $62 = $61 << 24 >> 24;
     $63 = $62 & -32;
     $64 = ($63|0)==(32);
     if ($64) {
      $51 = $62;$56 = $61;$fl$0170 = $59;$storemerge8169 = $60;
     } else {
      $65 = $61;$fl$0110 = $59;$storemerge8108 = $60;
      break;
     }
    }
   } else {
    $65 = $47;$fl$0110 = 0;$storemerge8108 = $storemerge;
   }
  } while(0);
  $66 = ($65<<24>>24)==(42);
  do {
   if ($66) {
    $67 = ((($storemerge8108)) + 1|0);
    $68 = HEAP8[$67>>0]|0;
    $69 = $68 << 24 >> 24;
    $isdigittmp11 = (($69) + -48)|0;
    $isdigit12 = ($isdigittmp11>>>0)<(10);
    if ($isdigit12) {
     $70 = ((($storemerge8108)) + 2|0);
     $71 = HEAP8[$70>>0]|0;
     $72 = ($71<<24>>24)==(36);
     if ($72) {
      $73 = (($nl_type) + ($isdigittmp11<<2)|0);
      HEAP32[$73>>2] = 10;
      $74 = HEAP8[$67>>0]|0;
      $75 = $74 << 24 >> 24;
      $76 = (($75) + -48)|0;
      $77 = (($nl_arg) + ($76<<3)|0);
      $78 = $77;
      $79 = $78;
      $80 = HEAP32[$79>>2]|0;
      $81 = (($78) + 4)|0;
      $82 = $81;
      $83 = HEAP32[$82>>2]|0;
      $84 = ((($storemerge8108)) + 3|0);
      $l10n$2 = 1;$storemerge13 = $84;$w$0 = $80;
     } else {
      label = 23;
     }
    } else {
     label = 23;
    }
    if ((label|0) == 23) {
     label = 0;
     $85 = ($l10n$1|0)==(0);
     if (!($85)) {
      $$0 = -1;
      label = 363;
      break L1;
     }
     if (!($1)) {
      $105 = $67;$fl$1 = $fl$0110;$l10n$3 = 0;$w$1 = 0;
      break;
     }
     $arglist_current = HEAP32[$ap>>2]|0;
     $86 = $arglist_current;
     $87 = ((0) + 4|0);
     $expanded64 = $87;
     $expanded = (($expanded64) - 1)|0;
     $88 = (($86) + ($expanded))|0;
     $89 = ((0) + 4|0);
     $expanded68 = $89;
     $expanded67 = (($expanded68) - 1)|0;
     $expanded66 = $expanded67 ^ -1;
     $90 = $88 & $expanded66;
     $91 = $90;
     $92 = HEAP32[$91>>2]|0;
     $arglist_next = ((($91)) + 4|0);
     HEAP32[$ap>>2] = $arglist_next;
     $l10n$2 = 0;$storemerge13 = $67;$w$0 = $92;
    }
    $93 = ($w$0|0)<(0);
    if ($93) {
     $94 = $fl$0110 | 8192;
     $95 = (0 - ($w$0))|0;
     $105 = $storemerge13;$fl$1 = $94;$l10n$3 = $l10n$2;$w$1 = $95;
    } else {
     $105 = $storemerge13;$fl$1 = $fl$0110;$l10n$3 = $l10n$2;$w$1 = $w$0;
    }
   } else {
    $96 = $65 << 24 >> 24;
    $isdigittmp1$i = (($96) + -48)|0;
    $isdigit2$i = ($isdigittmp1$i>>>0)<(10);
    if ($isdigit2$i) {
     $100 = $storemerge8108;$i$03$i = 0;$isdigittmp4$i = $isdigittmp1$i;
     while(1) {
      $97 = ($i$03$i*10)|0;
      $98 = (($97) + ($isdigittmp4$i))|0;
      $99 = ((($100)) + 1|0);
      $101 = HEAP8[$99>>0]|0;
      $102 = $101 << 24 >> 24;
      $isdigittmp$i = (($102) + -48)|0;
      $isdigit$i = ($isdigittmp$i>>>0)<(10);
      if ($isdigit$i) {
       $100 = $99;$i$03$i = $98;$isdigittmp4$i = $isdigittmp$i;
      } else {
       $$lcssa450 = $98;$$lcssa451 = $99;
       break;
      }
     }
     $103 = ($$lcssa450|0)<(0);
     if ($103) {
      $$0 = -1;
      label = 363;
      break L1;
     } else {
      $105 = $$lcssa451;$fl$1 = $fl$0110;$l10n$3 = $l10n$1;$w$1 = $$lcssa450;
     }
    } else {
     $105 = $storemerge8108;$fl$1 = $fl$0110;$l10n$3 = $l10n$1;$w$1 = 0;
    }
   }
  } while(0);
  $104 = HEAP8[$105>>0]|0;
  $106 = ($104<<24>>24)==(46);
  L45: do {
   if ($106) {
    $107 = ((($105)) + 1|0);
    $108 = HEAP8[$107>>0]|0;
    $109 = ($108<<24>>24)==(42);
    if (!($109)) {
     $136 = $108 << 24 >> 24;
     $isdigittmp1$i27 = (($136) + -48)|0;
     $isdigit2$i28 = ($isdigittmp1$i27>>>0)<(10);
     if ($isdigit2$i28) {
      $140 = $107;$i$03$i30 = 0;$isdigittmp4$i29 = $isdigittmp1$i27;
     } else {
      $1172 = $107;$p$0 = 0;
      break;
     }
     while(1) {
      $137 = ($i$03$i30*10)|0;
      $138 = (($137) + ($isdigittmp4$i29))|0;
      $139 = ((($140)) + 1|0);
      $141 = HEAP8[$139>>0]|0;
      $142 = $141 << 24 >> 24;
      $isdigittmp$i31 = (($142) + -48)|0;
      $isdigit$i32 = ($isdigittmp$i31>>>0)<(10);
      if ($isdigit$i32) {
       $140 = $139;$i$03$i30 = $138;$isdigittmp4$i29 = $isdigittmp$i31;
      } else {
       $1172 = $139;$p$0 = $138;
       break L45;
      }
     }
    }
    $110 = ((($105)) + 2|0);
    $111 = HEAP8[$110>>0]|0;
    $112 = $111 << 24 >> 24;
    $isdigittmp9 = (($112) + -48)|0;
    $isdigit10 = ($isdigittmp9>>>0)<(10);
    if ($isdigit10) {
     $113 = ((($105)) + 3|0);
     $114 = HEAP8[$113>>0]|0;
     $115 = ($114<<24>>24)==(36);
     if ($115) {
      $116 = (($nl_type) + ($isdigittmp9<<2)|0);
      HEAP32[$116>>2] = 10;
      $117 = HEAP8[$110>>0]|0;
      $118 = $117 << 24 >> 24;
      $119 = (($118) + -48)|0;
      $120 = (($nl_arg) + ($119<<3)|0);
      $121 = $120;
      $122 = $121;
      $123 = HEAP32[$122>>2]|0;
      $124 = (($121) + 4)|0;
      $125 = $124;
      $126 = HEAP32[$125>>2]|0;
      $127 = ((($105)) + 4|0);
      $1172 = $127;$p$0 = $123;
      break;
     }
    }
    $128 = ($l10n$3|0)==(0);
    if (!($128)) {
     $$0 = -1;
     label = 363;
     break L1;
    }
    if ($1) {
     $arglist_current2 = HEAP32[$ap>>2]|0;
     $129 = $arglist_current2;
     $130 = ((0) + 4|0);
     $expanded71 = $130;
     $expanded70 = (($expanded71) - 1)|0;
     $131 = (($129) + ($expanded70))|0;
     $132 = ((0) + 4|0);
     $expanded75 = $132;
     $expanded74 = (($expanded75) - 1)|0;
     $expanded73 = $expanded74 ^ -1;
     $133 = $131 & $expanded73;
     $134 = $133;
     $135 = HEAP32[$134>>2]|0;
     $arglist_next3 = ((($134)) + 4|0);
     HEAP32[$ap>>2] = $arglist_next3;
     $1172 = $110;$p$0 = $135;
    } else {
     $1172 = $110;$p$0 = 0;
    }
   } else {
    $1172 = $105;$p$0 = -1;
   }
  } while(0);
  $144 = $1172;$st$0 = 0;
  while(1) {
   $143 = HEAP8[$144>>0]|0;
   $145 = $143 << 24 >> 24;
   $146 = (($145) + -65)|0;
   $147 = ($146>>>0)>(57);
   if ($147) {
    $$0 = -1;
    label = 363;
    break L1;
   }
   $148 = ((($144)) + 1|0);
   $149 = ((95920 + (($st$0*58)|0)|0) + ($146)|0);
   $150 = HEAP8[$149>>0]|0;
   $151 = $150&255;
   $152 = (($151) + -1)|0;
   $153 = ($152>>>0)<(8);
   if ($153) {
    $144 = $148;$st$0 = $151;
   } else {
    $$lcssa455 = $144;$$lcssa457 = $148;$$lcssa458 = $150;$$lcssa459 = $151;$st$0$lcssa456 = $st$0;
    break;
   }
  }
  $154 = ($$lcssa458<<24>>24)==(0);
  if ($154) {
   $$0 = -1;
   label = 363;
   break;
  }
  $155 = ($$lcssa458<<24>>24)==(19);
  $156 = ($argpos$0|0)>(-1);
  L64: do {
   if ($155) {
    if ($156) {
     $$0 = -1;
     label = 363;
     break L1;
    } else {
     $1173 = $1169;$1174 = $1170;
     label = 62;
    }
   } else {
    if ($156) {
     $157 = (($nl_type) + ($argpos$0<<2)|0);
     HEAP32[$157>>2] = $$lcssa459;
     $158 = (($nl_arg) + ($argpos$0<<3)|0);
     $159 = HEAP32[$158>>2]|0;
     $160 = ((($158)) + 4|0);
     $161 = HEAP32[$160>>2]|0;
     $1173 = $161;$1174 = $159;
     label = 62;
     break;
    }
    if (!($1)) {
     $$0 = 0;
     label = 363;
     break L1;
    }
    $162 = ($$lcssa458&255)>(20);
    if ($162) {
     $264 = $1170;$291 = $1169;
    } else {
     do {
      switch ($$lcssa459|0) {
      case 15:  {
       $arglist_current23 = HEAP32[$ap>>2]|0;
       $218 = $arglist_current23;
       $219 = ((0) + 4|0);
       $expanded120 = $219;
       $expanded119 = (($expanded120) - 1)|0;
       $220 = (($218) + ($expanded119))|0;
       $221 = ((0) + 4|0);
       $expanded124 = $221;
       $expanded123 = (($expanded124) - 1)|0;
       $expanded122 = $expanded123 ^ -1;
       $222 = $220 & $expanded122;
       $223 = $222;
       $224 = HEAP32[$223>>2]|0;
       $arglist_next24 = ((($223)) + 4|0);
       HEAP32[$ap>>2] = $arglist_next24;
       $225 = $224&255;
       $226 = $225 << 24 >> 24;
       $227 = ($226|0)<(0);
       $228 = $227 << 31 >> 31;
       $sext = $224 << 24;
       $229 = $sext >> 24;
       $264 = $229;$291 = $228;
       break L64;
       break;
      }
      case 12:  {
       $arglist_current14 = HEAP32[$ap>>2]|0;
       $187 = $arglist_current14;
       $188 = ((0) + 8|0);
       $expanded99 = $188;
       $expanded98 = (($expanded99) - 1)|0;
       $189 = (($187) + ($expanded98))|0;
       $190 = ((0) + 8|0);
       $expanded103 = $190;
       $expanded102 = (($expanded103) - 1)|0;
       $expanded101 = $expanded102 ^ -1;
       $191 = $189 & $expanded101;
       $192 = $191;
       $193 = $192;
       $194 = $193;
       $195 = HEAP32[$194>>2]|0;
       $196 = (($193) + 4)|0;
       $197 = $196;
       $198 = HEAP32[$197>>2]|0;
       $arglist_next15 = ((($192)) + 8|0);
       HEAP32[$ap>>2] = $arglist_next15;
       $264 = $195;$291 = $198;
       break L64;
       break;
      }
      case 17:  {
       $arglist_current29 = HEAP32[$ap>>2]|0;
       $237 = $arglist_current29;
       $238 = ((0) + 8|0);
       $expanded134 = $238;
       $expanded133 = (($expanded134) - 1)|0;
       $239 = (($237) + ($expanded133))|0;
       $240 = ((0) + 8|0);
       $expanded138 = $240;
       $expanded137 = (($expanded138) - 1)|0;
       $expanded136 = $expanded137 ^ -1;
       $241 = $239 & $expanded136;
       $242 = $241;
       $243 = +HEAPF64[$242>>3];
       $arglist_next30 = ((($242)) + 8|0);
       HEAP32[$ap>>2] = $arglist_next30;
       HEAPF64[tempDoublePtr>>3] = $243;$244 = HEAP32[tempDoublePtr>>2]|0;
       $245 = HEAP32[tempDoublePtr+4>>2]|0;
       $264 = $244;$291 = $245;
       break L64;
       break;
      }
      case 11:  {
       $arglist_current11 = HEAP32[$ap>>2]|0;
       $180 = $arglist_current11;
       $181 = ((0) + 4|0);
       $expanded92 = $181;
       $expanded91 = (($expanded92) - 1)|0;
       $182 = (($180) + ($expanded91))|0;
       $183 = ((0) + 4|0);
       $expanded96 = $183;
       $expanded95 = (($expanded96) - 1)|0;
       $expanded94 = $expanded95 ^ -1;
       $184 = $182 & $expanded94;
       $185 = $184;
       $186 = HEAP32[$185>>2]|0;
       $arglist_next12 = ((($185)) + 4|0);
       HEAP32[$ap>>2] = $arglist_next12;
       $264 = $186;$291 = 0;
       break L64;
       break;
      }
      case 10:  {
       $arglist_current8 = HEAP32[$ap>>2]|0;
       $171 = $arglist_current8;
       $172 = ((0) + 4|0);
       $expanded85 = $172;
       $expanded84 = (($expanded85) - 1)|0;
       $173 = (($171) + ($expanded84))|0;
       $174 = ((0) + 4|0);
       $expanded89 = $174;
       $expanded88 = (($expanded89) - 1)|0;
       $expanded87 = $expanded88 ^ -1;
       $175 = $173 & $expanded87;
       $176 = $175;
       $177 = HEAP32[$176>>2]|0;
       $arglist_next9 = ((($176)) + 4|0);
       HEAP32[$ap>>2] = $arglist_next9;
       $178 = ($177|0)<(0);
       $179 = $178 << 31 >> 31;
       $264 = $177;$291 = $179;
       break L64;
       break;
      }
      case 9:  {
       $arglist_current5 = HEAP32[$ap>>2]|0;
       $163 = $arglist_current5;
       $164 = ((0) + 4|0);
       $expanded78 = $164;
       $expanded77 = (($expanded78) - 1)|0;
       $165 = (($163) + ($expanded77))|0;
       $166 = ((0) + 4|0);
       $expanded82 = $166;
       $expanded81 = (($expanded82) - 1)|0;
       $expanded80 = $expanded81 ^ -1;
       $167 = $165 & $expanded80;
       $168 = $167;
       $169 = HEAP32[$168>>2]|0;
       $arglist_next6 = ((($168)) + 4|0);
       HEAP32[$ap>>2] = $arglist_next6;
       $170 = $169;
       $264 = $170;$291 = $1169;
       break L64;
       break;
      }
      case 13:  {
       $arglist_current17 = HEAP32[$ap>>2]|0;
       $199 = $arglist_current17;
       $200 = ((0) + 4|0);
       $expanded106 = $200;
       $expanded105 = (($expanded106) - 1)|0;
       $201 = (($199) + ($expanded105))|0;
       $202 = ((0) + 4|0);
       $expanded110 = $202;
       $expanded109 = (($expanded110) - 1)|0;
       $expanded108 = $expanded109 ^ -1;
       $203 = $201 & $expanded108;
       $204 = $203;
       $205 = HEAP32[$204>>2]|0;
       $arglist_next18 = ((($204)) + 4|0);
       HEAP32[$ap>>2] = $arglist_next18;
       $206 = $205&65535;
       $207 = $206 << 16 >> 16;
       $208 = ($207|0)<(0);
       $209 = $208 << 31 >> 31;
       $sext93 = $205 << 16;
       $210 = $sext93 >> 16;
       $264 = $210;$291 = $209;
       break L64;
       break;
      }
      case 16:  {
       $arglist_current26 = HEAP32[$ap>>2]|0;
       $230 = $arglist_current26;
       $231 = ((0) + 4|0);
       $expanded127 = $231;
       $expanded126 = (($expanded127) - 1)|0;
       $232 = (($230) + ($expanded126))|0;
       $233 = ((0) + 4|0);
       $expanded131 = $233;
       $expanded130 = (($expanded131) - 1)|0;
       $expanded129 = $expanded130 ^ -1;
       $234 = $232 & $expanded129;
       $235 = $234;
       $236 = HEAP32[$235>>2]|0;
       $arglist_next27 = ((($235)) + 4|0);
       HEAP32[$ap>>2] = $arglist_next27;
       $$mask$i38 = $236 & 255;
       $264 = $$mask$i38;$291 = 0;
       break L64;
       break;
      }
      case 18:  {
       $arglist_current32 = HEAP32[$ap>>2]|0;
       $246 = $arglist_current32;
       $247 = ((0) + 8|0);
       $expanded141 = $247;
       $expanded140 = (($expanded141) - 1)|0;
       $248 = (($246) + ($expanded140))|0;
       $249 = ((0) + 8|0);
       $expanded145 = $249;
       $expanded144 = (($expanded145) - 1)|0;
       $expanded143 = $expanded144 ^ -1;
       $250 = $248 & $expanded143;
       $251 = $250;
       $252 = +HEAPF64[$251>>3];
       $arglist_next33 = ((($251)) + 8|0);
       HEAP32[$ap>>2] = $arglist_next33;
       HEAPF64[tempDoublePtr>>3] = $252;$253 = HEAP32[tempDoublePtr>>2]|0;
       $254 = HEAP32[tempDoublePtr+4>>2]|0;
       $264 = $253;$291 = $254;
       break L64;
       break;
      }
      case 14:  {
       $arglist_current20 = HEAP32[$ap>>2]|0;
       $211 = $arglist_current20;
       $212 = ((0) + 4|0);
       $expanded113 = $212;
       $expanded112 = (($expanded113) - 1)|0;
       $213 = (($211) + ($expanded112))|0;
       $214 = ((0) + 4|0);
       $expanded117 = $214;
       $expanded116 = (($expanded117) - 1)|0;
       $expanded115 = $expanded116 ^ -1;
       $215 = $213 & $expanded115;
       $216 = $215;
       $217 = HEAP32[$216>>2]|0;
       $arglist_next21 = ((($216)) + 4|0);
       HEAP32[$ap>>2] = $arglist_next21;
       $$mask1$i37 = $217 & 65535;
       $264 = $$mask1$i37;$291 = 0;
       break L64;
       break;
      }
      default: {
       $264 = $1170;$291 = $1169;
       break L64;
      }
      }
     } while(0);
    }
   }
  } while(0);
  if ((label|0) == 62) {
   label = 0;
   if ($1) {
    $264 = $1174;$291 = $1173;
   } else {
    $1169 = $1173;$1170 = $1174;$23 = $$lcssa457;$cnt$0 = $cnt$1;$l$0 = $37;$l10n$0 = $l10n$3;
    continue;
   }
  }
  $255 = HEAP8[$$lcssa455>>0]|0;
  $256 = $255 << 24 >> 24;
  $257 = ($st$0$lcssa456|0)!=(0);
  $258 = $256 & 15;
  $259 = ($258|0)==(3);
  $or$cond15 = $257 & $259;
  $260 = $256 & -33;
  $t$0 = $or$cond15 ? $260 : $256;
  $261 = $fl$1 & 8192;
  $262 = ($261|0)==(0);
  $263 = $fl$1 & -65537;
  $fl$1$ = $262 ? $fl$1 : $263;
  L86: do {
   switch ($t$0|0) {
   case 117:  {
    $336 = $291;$338 = $264;$pl$0 = 0;$prefix$0 = 96400;
    label = 84;
    break;
   }
   case 111:  {
    $312 = ($264|0)==(0);
    $313 = ($291|0)==(0);
    $314 = $312 & $313;
    if ($314) {
     $$0$lcssa$i51 = $2;
    } else {
     $$03$i48 = $2;$316 = $264;$320 = $291;
     while(1) {
      $315 = $316 & 7;
      $317 = $315 | 48;
      $318 = $317&255;
      $319 = ((($$03$i48)) + -1|0);
      HEAP8[$319>>0] = $318;
      $321 = (_bitshift64Lshr(($316|0),($320|0),3)|0);
      $322 = tempRet0;
      $323 = ($321|0)==(0);
      $324 = ($322|0)==(0);
      $325 = $323 & $324;
      if ($325) {
       $$0$lcssa$i51 = $319;
       break;
      } else {
       $$03$i48 = $319;$316 = $321;$320 = $322;
      }
     }
    }
    $326 = $fl$1$ & 8;
    $327 = ($326|0)==(0);
    $or$cond19 = $327 | $314;
    $$24 = $or$cond19 ? 96400 : (96405);
    $328 = $or$cond19&1;
    $$25 = $328 ^ 1;
    $366 = $264;$368 = $291;$a$0 = $$0$lcssa$i51;$fl$4 = $fl$1$;$p$2 = $p$0;$pl$1 = $$25;$prefix$1 = $$24;
    label = 89;
    break;
   }
   case 67:  {
    HEAP32[$wc>>2] = $264;
    HEAP32[$5>>2] = 0;
    $1179 = $wc;$1180 = $6;$p$4272 = -1;
    label = 97;
    break;
   }
   case 83:  {
    $391 = $264;
    $392 = ($p$0|0)==(0);
    if ($392) {
     $1181 = $264;$1182 = $391;$i$0$lcssa273 = 0;
     label = 102;
    } else {
     $1179 = $391;$1180 = $264;$p$4272 = $p$0;
     label = 97;
    }
    break;
   }
   case 110:  {
    switch ($st$0$lcssa456|0) {
    case 7:  {
     $279 = ($cnt$1|0)<(0);
     $280 = $279 << 31 >> 31;
     $281 = $264;
     $282 = $281;
     $283 = $282;
     HEAP32[$283>>2] = $cnt$1;
     $284 = (($282) + 4)|0;
     $285 = $284;
     HEAP32[$285>>2] = $280;
     $1169 = $291;$1170 = $264;$23 = $$lcssa457;$cnt$0 = $cnt$1;$l$0 = $37;$l10n$0 = $l10n$3;
     continue L1;
     break;
    }
    case 0:  {
     $265 = $264;
     HEAP32[$265>>2] = $cnt$1;
     $1169 = $291;$1170 = $264;$23 = $$lcssa457;$cnt$0 = $cnt$1;$l$0 = $37;$l10n$0 = $l10n$3;
     continue L1;
     break;
    }
    case 1:  {
     $266 = $264;
     HEAP32[$266>>2] = $cnt$1;
     $1169 = $291;$1170 = $264;$23 = $$lcssa457;$cnt$0 = $cnt$1;$l$0 = $37;$l10n$0 = $l10n$3;
     continue L1;
     break;
    }
    case 2:  {
     $267 = ($cnt$1|0)<(0);
     $268 = $267 << 31 >> 31;
     $269 = $264;
     $270 = $269;
     $271 = $270;
     HEAP32[$271>>2] = $cnt$1;
     $272 = (($270) + 4)|0;
     $273 = $272;
     HEAP32[$273>>2] = $268;
     $1169 = $291;$1170 = $264;$23 = $$lcssa457;$cnt$0 = $cnt$1;$l$0 = $37;$l10n$0 = $l10n$3;
     continue L1;
     break;
    }
    case 3:  {
     $274 = $cnt$1&65535;
     $275 = $264;
     HEAP16[$275>>1] = $274;
     $1169 = $291;$1170 = $264;$23 = $$lcssa457;$cnt$0 = $cnt$1;$l$0 = $37;$l10n$0 = $l10n$3;
     continue L1;
     break;
    }
    case 4:  {
     $276 = $cnt$1&255;
     $277 = $264;
     HEAP8[$277>>0] = $276;
     $1169 = $291;$1170 = $264;$23 = $$lcssa457;$cnt$0 = $cnt$1;$l$0 = $37;$l10n$0 = $l10n$3;
     continue L1;
     break;
    }
    case 6:  {
     $278 = $264;
     HEAP32[$278>>2] = $cnt$1;
     $1169 = $291;$1170 = $264;$23 = $$lcssa457;$cnt$0 = $cnt$1;$l$0 = $37;$l10n$0 = $l10n$3;
     continue L1;
     break;
    }
    default: {
     $1169 = $291;$1170 = $264;$23 = $$lcssa457;$cnt$0 = $cnt$1;$l$0 = $37;$l10n$0 = $l10n$3;
     continue L1;
    }
    }
    break;
   }
   case 65: case 71: case 70: case 69: case 97: case 103: case 102: case 101:  {
    HEAP32[tempDoublePtr>>2] = $264;HEAP32[tempDoublePtr+4>>2] = $291;$430 = +HEAPF64[tempDoublePtr>>3];
    HEAP32[$e2$i>>2] = 0;
    $431 = ($291|0)<(0);
    if ($431) {
     $432 = -$430;
     $$07$i = $432;$pl$0$i = 1;$prefix$0$i = 96424;
    } else {
     $433 = $fl$1$ & 2048;
     $434 = ($433|0)==(0);
     if ($434) {
      $435 = $fl$1$ & 1;
      $436 = ($435|0)==(0);
      $$$i = $436 ? (96425) : (96430);
      $$07$i = $430;$pl$0$i = $435;$prefix$0$i = $$$i;
     } else {
      $$07$i = $430;$pl$0$i = 1;$prefix$0$i = (96427);
     }
    }
    HEAPF64[tempDoublePtr>>3] = $$07$i;$437 = HEAP32[tempDoublePtr>>2]|0;
    $438 = HEAP32[tempDoublePtr+4>>2]|0;
    $439 = $438 & 2146435072;
    $440 = ($439>>>0)<(2146435072);
    $441 = (0)<(0);
    $442 = ($439|0)==(2146435072);
    $443 = $442 & $441;
    $444 = $440 | $443;
    do {
     if ($444) {
      $471 = (+_frexpl($$07$i,$e2$i));
      $472 = $471 * 2.0;
      $473 = $472 != 0.0;
      if ($473) {
       $474 = HEAP32[$e2$i>>2]|0;
       $475 = (($474) + -1)|0;
       HEAP32[$e2$i>>2] = $475;
      }
      $476 = $t$0 | 32;
      $477 = ($476|0)==(97);
      if ($477) {
       $478 = $t$0 & 32;
       $479 = ($478|0)==(0);
       $480 = ((($prefix$0$i)) + 9|0);
       $prefix$0$$i = $479 ? $prefix$0$i : $480;
       $481 = $pl$0$i | 2;
       $482 = ($p$0>>>0)>(11);
       $483 = (12 - ($p$0))|0;
       $484 = ($483|0)==(0);
       $485 = $482 | $484;
       do {
        if ($485) {
         $$1$i = $472;
        } else {
         $re$1179$i = $483;$round$0178$i = 8.0;
         while(1) {
          $486 = (($re$1179$i) + -1)|0;
          $487 = $round$0178$i * 16.0;
          $488 = ($486|0)==(0);
          if ($488) {
           $$lcssa483 = $487;
           break;
          } else {
           $re$1179$i = $486;$round$0178$i = $487;
          }
         }
         $489 = HEAP8[$prefix$0$$i>>0]|0;
         $490 = ($489<<24>>24)==(45);
         if ($490) {
          $491 = -$472;
          $492 = $491 - $$lcssa483;
          $493 = $$lcssa483 + $492;
          $494 = -$493;
          $$1$i = $494;
          break;
         } else {
          $495 = $472 + $$lcssa483;
          $496 = $495 - $$lcssa483;
          $$1$i = $496;
          break;
         }
        }
       } while(0);
       $497 = HEAP32[$e2$i>>2]|0;
       $498 = ($497|0)<(0);
       $499 = (0 - ($497))|0;
       $500 = $498 ? $499 : $497;
       $501 = ($500|0)<(0);
       if ($501) {
        $502 = ($500|0)<(0);
        $503 = $502 << 31 >> 31;
        $$05$i$i = $7;$504 = $500;$505 = $503;
        while(1) {
         $506 = (___uremdi3(($504|0),($505|0),10,0)|0);
         $507 = tempRet0;
         $508 = $506 | 48;
         $509 = $508&255;
         $510 = ((($$05$i$i)) + -1|0);
         HEAP8[$510>>0] = $509;
         $511 = (___udivdi3(($504|0),($505|0),10,0)|0);
         $512 = tempRet0;
         $513 = ($505>>>0)>(9);
         $514 = ($504>>>0)>(4294967295);
         $515 = ($505|0)==(9);
         $516 = $515 & $514;
         $517 = $513 | $516;
         if ($517) {
          $$05$i$i = $510;$504 = $511;$505 = $512;
         } else {
          $$lcssa484 = $510;$1183 = $511;$1184 = $512;
          break;
         }
        }
        $$0$lcssa$i48$i = $$lcssa484;$$01$lcssa$off0$i$i = $1183;
       } else {
        $$0$lcssa$i48$i = $7;$$01$lcssa$off0$i$i = $500;
       }
       $518 = ($$01$lcssa$off0$i$i|0)==(0);
       if ($518) {
        $$1$lcssa$i$i = $$0$lcssa$i48$i;
       } else {
        $$12$i$i = $$0$lcssa$i48$i;$y$03$i$i = $$01$lcssa$off0$i$i;
        while(1) {
         $519 = (($y$03$i$i>>>0) % 10)&-1;
         $520 = $519 | 48;
         $521 = $520&255;
         $522 = ((($$12$i$i)) + -1|0);
         HEAP8[$522>>0] = $521;
         $523 = (($y$03$i$i>>>0) / 10)&-1;
         $524 = ($y$03$i$i>>>0)<(10);
         if ($524) {
          $$1$lcssa$i$i = $522;
          break;
         } else {
          $$12$i$i = $522;$y$03$i$i = $523;
         }
        }
       }
       $525 = ($$1$lcssa$i$i|0)==($7|0);
       if ($525) {
        HEAP8[$8>>0] = 48;
        $estr$0$i = $8;
       } else {
        $estr$0$i = $$1$lcssa$i$i;
       }
       $526 = HEAP32[$e2$i>>2]|0;
       $527 = $526 >> 31;
       $528 = $527 & 2;
       $529 = (($528) + 43)|0;
       $530 = $529&255;
       $531 = ((($estr$0$i)) + -1|0);
       HEAP8[$531>>0] = $530;
       $532 = (($t$0) + 15)|0;
       $533 = $532&255;
       $534 = ((($estr$0$i)) + -2|0);
       HEAP8[$534>>0] = $533;
       $535 = $fl$1$ & 8;
       $536 = ($535|0)==(0);
       if ($536) {
        $notrhs$i = ($p$0|0)<(1);
        if ($notrhs$i) {
         $$2$us$us$i = $$1$i;$s$0$us$us$i = $buf$i;
         while(1) {
          $537 = (~~(($$2$us$us$i)));
          $538 = (96384 + ($537)|0);
          $539 = HEAP8[$538>>0]|0;
          $540 = $539&255;
          $541 = $540 | $478;
          $542 = $541&255;
          $543 = ((($s$0$us$us$i)) + 1|0);
          HEAP8[$s$0$us$us$i>>0] = $542;
          $544 = (+($537|0));
          $545 = $$2$us$us$i - $544;
          $546 = $545 * 16.0;
          $547 = $543;
          $548 = (($547) - ($0))|0;
          $549 = ($548|0)!=(1);
          $notlhs$us$us$i = $546 == 0.0;
          $or$cond$i79 = $549 | $notlhs$us$us$i;
          if ($or$cond$i79) {
           $s$1$us$us$i = $543;
          } else {
           $550 = ((($s$0$us$us$i)) + 2|0);
           HEAP8[$543>>0] = 46;
           $s$1$us$us$i = $550;
          }
          $551 = $546 != 0.0;
          if ($551) {
           $$2$us$us$i = $546;$s$0$us$us$i = $s$1$us$us$i;
          } else {
           $s$1$lcssa$i = $s$1$us$us$i;
           break;
          }
         }
        } else {
         $$2$us$i = $$1$i;$s$0$us$i = $buf$i;
         while(1) {
          $552 = (~~(($$2$us$i)));
          $553 = (96384 + ($552)|0);
          $554 = HEAP8[$553>>0]|0;
          $555 = $554&255;
          $556 = $555 | $478;
          $557 = $556&255;
          $558 = ((($s$0$us$i)) + 1|0);
          HEAP8[$s$0$us$i>>0] = $557;
          $559 = (+($552|0));
          $560 = $$2$us$i - $559;
          $561 = $560 * 16.0;
          $562 = $558;
          $563 = (($562) - ($0))|0;
          $564 = ($563|0)==(1);
          if ($564) {
           $565 = ((($s$0$us$i)) + 2|0);
           HEAP8[$558>>0] = 46;
           $s$1$us$i = $565;
          } else {
           $s$1$us$i = $558;
          }
          $566 = $561 != 0.0;
          if ($566) {
           $$2$us$i = $561;$s$0$us$i = $s$1$us$i;
          } else {
           $s$1$lcssa$i = $s$1$us$i;
           break;
          }
         }
        }
       } else {
        $$2$i = $$1$i;$s$0$i = $buf$i;
        while(1) {
         $567 = (~~(($$2$i)));
         $568 = (96384 + ($567)|0);
         $569 = HEAP8[$568>>0]|0;
         $570 = $569&255;
         $571 = $570 | $478;
         $572 = $571&255;
         $573 = ((($s$0$i)) + 1|0);
         HEAP8[$s$0$i>>0] = $572;
         $574 = (+($567|0));
         $575 = $$2$i - $574;
         $576 = $575 * 16.0;
         $577 = $573;
         $578 = (($577) - ($0))|0;
         $579 = ($578|0)==(1);
         if ($579) {
          $580 = ((($s$0$i)) + 2|0);
          HEAP8[$573>>0] = 46;
          $s$1$i = $580;
         } else {
          $s$1$i = $573;
         }
         $581 = $576 != 0.0;
         if ($581) {
          $$2$i = $576;$s$0$i = $s$1$i;
         } else {
          $s$1$lcssa$i = $s$1$i;
          break;
         }
        }
       }
       $582 = ($p$0|0)!=(0);
       $$pre300$i = $s$1$lcssa$i;
       $583 = (($11) + ($$pre300$i))|0;
       $584 = ($583|0)<($p$0|0);
       $or$cond332 = $582 & $584;
       $585 = $534;
       $586 = (($12) + ($p$0))|0;
       $587 = (($586) - ($585))|0;
       $588 = $534;
       $589 = (($10) - ($588))|0;
       $590 = (($589) + ($$pre300$i))|0;
       $l$0$i = $or$cond332 ? $587 : $590;
       $591 = (($l$0$i) + ($481))|0;
       $592 = $fl$1$ & 73728;
       $593 = ($592|0)==(0);
       $594 = ($w$1|0)>($591|0);
       $or$cond$i52$i = $593 & $594;
       if ($or$cond$i52$i) {
        $595 = (($w$1) - ($591))|0;
        $596 = ($595>>>0)>(256);
        $597 = $596 ? 256 : $595;
        _memset(($pad$i|0),32,($597|0))|0;
        $598 = ($595>>>0)>(255);
        if ($598) {
         $$01$i54$i = $595;
         while(1) {
          (___fwritex($pad$i,256,$f)|0);
          $599 = (($$01$i54$i) + -256)|0;
          $600 = ($599>>>0)>(255);
          if ($600) {
           $$01$i54$i = $599;
          } else {
           break;
          }
         }
         $601 = $595 & 255;
         $$0$lcssa$i56$i = $601;
        } else {
         $$0$lcssa$i56$i = $595;
        }
        (___fwritex($pad$i,$$0$lcssa$i56$i,$f)|0);
       }
       (___fwritex($prefix$0$$i,$481,$f)|0);
       $602 = ($592|0)==(65536);
       $or$cond$i59$i = $602 & $594;
       if ($or$cond$i59$i) {
        $603 = (($w$1) - ($591))|0;
        $604 = ($603>>>0)>(256);
        $605 = $604 ? 256 : $603;
        _memset(($pad$i|0),48,($605|0))|0;
        $606 = ($603>>>0)>(255);
        if ($606) {
         $$01$i61$i = $603;
         while(1) {
          (___fwritex($pad$i,256,$f)|0);
          $607 = (($$01$i61$i) + -256)|0;
          $608 = ($607>>>0)>(255);
          if ($608) {
           $$01$i61$i = $607;
          } else {
           break;
          }
         }
         $609 = $603 & 255;
         $$0$lcssa$i63$i = $609;
        } else {
         $$0$lcssa$i63$i = $603;
        }
        (___fwritex($pad$i,$$0$lcssa$i63$i,$f)|0);
       }
       $610 = (($$pre300$i) - ($0))|0;
       (___fwritex($buf$i,$610,$f)|0);
       $611 = $534;
       $612 = (($9) - ($611))|0;
       $613 = (($l$0$i) - ($612))|0;
       $614 = (($613) - ($610))|0;
       $615 = ($614|0)>(0);
       if ($615) {
        $616 = ($614>>>0)>(256);
        $617 = $616 ? 256 : $614;
        _memset(($pad$i|0),48,($617|0))|0;
        $618 = ($614>>>0)>(255);
        if ($618) {
         $$01$i67$i = $614;
         while(1) {
          (___fwritex($pad$i,256,$f)|0);
          $619 = (($$01$i67$i) + -256)|0;
          $620 = ($619>>>0)>(255);
          if ($620) {
           $$01$i67$i = $619;
          } else {
           break;
          }
         }
         $621 = $614 & 255;
         $$0$lcssa$i69$i = $621;
        } else {
         $$0$lcssa$i69$i = $614;
        }
        (___fwritex($pad$i,$$0$lcssa$i69$i,$f)|0);
       }
       (___fwritex($534,$612,$f)|0);
       $622 = ($592|0)==(8192);
       $or$cond$i72$i = $622 & $594;
       if ($or$cond$i72$i) {
        $623 = (($w$1) - ($591))|0;
        $624 = ($623>>>0)>(256);
        $625 = $624 ? 256 : $623;
        _memset(($pad$i|0),32,($625|0))|0;
        $626 = ($623>>>0)>(255);
        if ($626) {
         $$01$i74$i = $623;
         while(1) {
          (___fwritex($pad$i,256,$f)|0);
          $627 = (($$01$i74$i) + -256)|0;
          $628 = ($627>>>0)>(255);
          if ($628) {
           $$01$i74$i = $627;
          } else {
           break;
          }
         }
         $629 = $623 & 255;
         $$0$lcssa$i76$i = $629;
        } else {
         $$0$lcssa$i76$i = $623;
        }
        (___fwritex($pad$i,$$0$lcssa$i76$i,$f)|0);
       }
       $w$$i = $594 ? $w$1 : $591;
       $$0$i = $w$$i;
       break;
      }
      $630 = ($p$0|0)<(0);
      $$p$i = $630 ? 6 : $p$0;
      if ($473) {
       $631 = $472 * 268435456.0;
       $632 = HEAP32[$e2$i>>2]|0;
       $633 = (($632) + -28)|0;
       HEAP32[$e2$i>>2] = $633;
       $$3$i = $631;$634 = $633;
      } else {
       $$pre$i = HEAP32[$e2$i>>2]|0;
       $$3$i = $472;$634 = $$pre$i;
      }
      $635 = ($634|0)<(0);
      $$31$i = $635 ? $big$i : $13;
      $636 = $$31$i;
      $$4$i = $$3$i;$z$0$i = $$31$i;
      while(1) {
       $637 = (~~(($$4$i))>>>0);
       HEAP32[$z$0$i>>2] = $637;
       $638 = ((($z$0$i)) + 4|0);
       $639 = (+($637>>>0));
       $640 = $$4$i - $639;
       $641 = $640 * 1.0E+9;
       $642 = $641 != 0.0;
       if ($642) {
        $$4$i = $641;$z$0$i = $638;
       } else {
        $$lcssa460 = $638;
        break;
       }
      }
      $$pr$i = HEAP32[$e2$i>>2]|0;
      $643 = ($$pr$i|0)>(0);
      if ($643) {
       $644 = $$pr$i;$a$1253$i = $$31$i;$z$1252$i = $$lcssa460;
       while(1) {
        $645 = ($644|0)>(29);
        $646 = $645 ? 29 : $644;
        $d$0245$i = ((($z$1252$i)) + -4|0);
        $647 = ($d$0245$i>>>0)<($a$1253$i>>>0);
        do {
         if ($647) {
          $a$2$ph$i = $a$1253$i;
         } else {
          $carry$0246$i = 0;$d$0247$i = $d$0245$i;
          while(1) {
           $648 = HEAP32[$d$0247$i>>2]|0;
           $649 = (_bitshift64Shl(($648|0),0,($646|0))|0);
           $650 = tempRet0;
           $651 = (_i64Add(($649|0),($650|0),($carry$0246$i|0),0)|0);
           $652 = tempRet0;
           $653 = (___uremdi3(($651|0),($652|0),1000000000,0)|0);
           $654 = tempRet0;
           HEAP32[$d$0247$i>>2] = $653;
           $655 = (___udivdi3(($651|0),($652|0),1000000000,0)|0);
           $656 = tempRet0;
           $d$0$i = ((($d$0247$i)) + -4|0);
           $657 = ($d$0$i>>>0)<($a$1253$i>>>0);
           if ($657) {
            $$lcssa461 = $655;
            break;
           } else {
            $carry$0246$i = $655;$d$0247$i = $d$0$i;
           }
          }
          $658 = ($$lcssa461|0)==(0);
          if ($658) {
           $a$2$ph$i = $a$1253$i;
           break;
          }
          $659 = ((($a$1253$i)) + -4|0);
          HEAP32[$659>>2] = $$lcssa461;
          $a$2$ph$i = $659;
         }
        } while(0);
        $z$2$i = $z$1252$i;
        while(1) {
         $660 = ($z$2$i>>>0)>($a$2$ph$i>>>0);
         if (!($660)) {
          $z$2$i$lcssa = $z$2$i;
          break;
         }
         $661 = ((($z$2$i)) + -4|0);
         $662 = HEAP32[$661>>2]|0;
         $663 = ($662|0)==(0);
         if ($663) {
          $z$2$i = $661;
         } else {
          $z$2$i$lcssa = $z$2$i;
          break;
         }
        }
        $664 = HEAP32[$e2$i>>2]|0;
        $665 = (($664) - ($646))|0;
        HEAP32[$e2$i>>2] = $665;
        $666 = ($665|0)>(0);
        if ($666) {
         $644 = $665;$a$1253$i = $a$2$ph$i;$z$1252$i = $z$2$i$lcssa;
        } else {
         $$pr146$i = $665;$a$1$lcssa$i = $a$2$ph$i;$z$1$lcssa$i = $z$2$i$lcssa;
         break;
        }
       }
      } else {
       $$pr146$i = $$pr$i;$a$1$lcssa$i = $$31$i;$z$1$lcssa$i = $$lcssa460;
      }
      $667 = ($$pr146$i|0)<(0);
      L228: do {
       if ($667) {
        $668 = (($$p$i) + 25)|0;
        $669 = (($668|0) / 9)&-1;
        $670 = (($669) + 1)|0;
        $671 = ($476|0)==(102);
        if (!($671)) {
         $704 = $$pr146$i;$a$3240$i = $a$1$lcssa$i;$z$3239$i = $z$1$lcssa$i;
         while(1) {
          $703 = (0 - ($704))|0;
          $705 = ($703|0)>(9);
          $706 = $705 ? 9 : $703;
          $707 = ($a$3240$i>>>0)<($z$3239$i>>>0);
          do {
           if ($707) {
            $711 = 1 << $706;
            $712 = (($711) + -1)|0;
            $713 = 1000000000 >>> $706;
            $carry3$0234$i = 0;$d$1233$i = $a$3240$i;
            while(1) {
             $714 = HEAP32[$d$1233$i>>2]|0;
             $715 = $714 & $712;
             $716 = $714 >>> $706;
             $717 = (($716) + ($carry3$0234$i))|0;
             HEAP32[$d$1233$i>>2] = $717;
             $718 = Math_imul($715, $713)|0;
             $719 = ((($d$1233$i)) + 4|0);
             $720 = ($719>>>0)<($z$3239$i>>>0);
             if ($720) {
              $carry3$0234$i = $718;$d$1233$i = $719;
             } else {
              $$lcssa463 = $718;
              break;
             }
            }
            $721 = HEAP32[$a$3240$i>>2]|0;
            $722 = ($721|0)==(0);
            $723 = ((($a$3240$i)) + 4|0);
            $$a$3$i = $722 ? $723 : $a$3240$i;
            $724 = ($$lcssa463|0)==(0);
            if ($724) {
             $$a$3306$i = $$a$3$i;$z$4$i = $z$3239$i;
             break;
            }
            $725 = ((($z$3239$i)) + 4|0);
            HEAP32[$z$3239$i>>2] = $$lcssa463;
            $$a$3306$i = $$a$3$i;$z$4$i = $725;
           } else {
            $708 = HEAP32[$a$3240$i>>2]|0;
            $709 = ($708|0)==(0);
            $710 = ((($a$3240$i)) + 4|0);
            $$a$3305$i = $709 ? $710 : $a$3240$i;
            $$a$3306$i = $$a$3305$i;$z$4$i = $z$3239$i;
           }
          } while(0);
          $726 = $z$4$i;
          $727 = $$a$3306$i;
          $728 = (($726) - ($727))|0;
          $729 = $728 >> 2;
          $730 = ($729|0)>($670|0);
          $731 = (($$a$3306$i) + ($670<<2)|0);
          $$z$4$i = $730 ? $731 : $z$4$i;
          $732 = HEAP32[$e2$i>>2]|0;
          $733 = (($732) + ($706))|0;
          HEAP32[$e2$i>>2] = $733;
          $734 = ($733|0)<(0);
          if ($734) {
           $704 = $733;$a$3240$i = $$a$3306$i;$z$3239$i = $$z$4$i;
          } else {
           $a$3$lcssa$i = $$a$3306$i;$z$3$lcssa$i = $$z$4$i;
           break L228;
          }
         }
        }
        $672 = (($$31$i) + ($670<<2)|0);
        $674 = $$pr146$i;$a$3240$us$i = $a$1$lcssa$i;$z$3239$us$i = $z$1$lcssa$i;
        while(1) {
         $673 = (0 - ($674))|0;
         $675 = ($673|0)>(9);
         $676 = $675 ? 9 : $673;
         $677 = ($a$3240$us$i>>>0)<($z$3239$us$i>>>0);
         do {
          if ($677) {
           $702 = 1 << $676;
           $695 = (($702) + -1)|0;
           $699 = 1000000000 >>> $676;
           $carry3$0234$us$i = 0;$d$1233$us$i = $a$3240$us$i;
           while(1) {
            $693 = HEAP32[$d$1233$us$i>>2]|0;
            $694 = $693 & $695;
            $696 = $693 >>> $676;
            $697 = (($696) + ($carry3$0234$us$i))|0;
            HEAP32[$d$1233$us$i>>2] = $697;
            $698 = Math_imul($694, $699)|0;
            $700 = ((($d$1233$us$i)) + 4|0);
            $701 = ($700>>>0)<($z$3239$us$i>>>0);
            if ($701) {
             $carry3$0234$us$i = $698;$d$1233$us$i = $700;
            } else {
             $$lcssa464 = $698;
             break;
            }
           }
           $681 = HEAP32[$a$3240$us$i>>2]|0;
           $682 = ($681|0)==(0);
           $683 = ((($a$3240$us$i)) + 4|0);
           $$a$3$us$i = $682 ? $683 : $a$3240$us$i;
           $684 = ($$lcssa464|0)==(0);
           if ($684) {
            $$a$3$us304$i = $$a$3$us$i;$z$4$us$i = $z$3239$us$i;
            break;
           }
           $685 = ((($z$3239$us$i)) + 4|0);
           HEAP32[$z$3239$us$i>>2] = $$lcssa464;
           $$a$3$us304$i = $$a$3$us$i;$z$4$us$i = $685;
          } else {
           $678 = HEAP32[$a$3240$us$i>>2]|0;
           $679 = ($678|0)==(0);
           $680 = ((($a$3240$us$i)) + 4|0);
           $$a$3$us303$i = $679 ? $680 : $a$3240$us$i;
           $$a$3$us304$i = $$a$3$us303$i;$z$4$us$i = $z$3239$us$i;
          }
         } while(0);
         $686 = $z$4$us$i;
         $687 = (($686) - ($636))|0;
         $688 = $687 >> 2;
         $689 = ($688|0)>($670|0);
         $$z$4$us$i = $689 ? $672 : $z$4$us$i;
         $690 = HEAP32[$e2$i>>2]|0;
         $691 = (($690) + ($676))|0;
         HEAP32[$e2$i>>2] = $691;
         $692 = ($691|0)<(0);
         if ($692) {
          $674 = $691;$a$3240$us$i = $$a$3$us304$i;$z$3239$us$i = $$z$4$us$i;
         } else {
          $a$3$lcssa$i = $$a$3$us304$i;$z$3$lcssa$i = $$z$4$us$i;
          break;
         }
        }
       } else {
        $a$3$lcssa$i = $a$1$lcssa$i;$z$3$lcssa$i = $z$1$lcssa$i;
       }
      } while(0);
      $735 = ($a$3$lcssa$i>>>0)<($z$3$lcssa$i>>>0);
      do {
       if ($735) {
        $736 = $a$3$lcssa$i;
        $737 = (($636) - ($736))|0;
        $738 = $737 >> 2;
        $739 = ($738*9)|0;
        $740 = HEAP32[$a$3$lcssa$i>>2]|0;
        $741 = ($740>>>0)<(10);
        if ($741) {
         $e$1$i = $739;
         break;
        } else {
         $e$0229$i = $739;$i$0228$i = 10;
        }
        while(1) {
         $742 = ($i$0228$i*10)|0;
         $743 = (($e$0229$i) + 1)|0;
         $744 = ($740>>>0)<($742>>>0);
         if ($744) {
          $e$1$i = $743;
          break;
         } else {
          $e$0229$i = $743;$i$0228$i = $742;
         }
        }
       } else {
        $e$1$i = 0;
       }
      } while(0);
      $745 = ($476|0)!=(102);
      $746 = $745 ? $e$1$i : 0;
      $747 = (($$p$i) - ($746))|0;
      $748 = ($476|0)==(103);
      $749 = ($$p$i|0)!=(0);
      $750 = $749 & $748;
      $$neg151$i = $750 << 31 >> 31;
      $751 = (($747) + ($$neg151$i))|0;
      $752 = $z$3$lcssa$i;
      $753 = (($752) - ($636))|0;
      $754 = $753 >> 2;
      $755 = ($754*9)|0;
      $756 = (($755) + -9)|0;
      $757 = ($751|0)<($756|0);
      if ($757) {
       $758 = (($751) + 9216)|0;
       $759 = (($758|0) / 9)&-1;
       $$sum$i = (($759) + -1023)|0;
       $760 = (($$31$i) + ($$sum$i<<2)|0);
       $761 = (($758|0) % 9)&-1;
       $j$0221$i = (($761) + 1)|0;
       $762 = ($j$0221$i|0)<(9);
       if ($762) {
        $i$1222$i = 10;$j$0223$i = $j$0221$i;
        while(1) {
         $763 = ($i$1222$i*10)|0;
         $j$0$i = (($j$0223$i) + 1)|0;
         $exitcond$i = ($j$0$i|0)==(9);
         if ($exitcond$i) {
          $i$1$lcssa$i = $763;
          break;
         } else {
          $i$1222$i = $763;$j$0223$i = $j$0$i;
         }
        }
       } else {
        $i$1$lcssa$i = 10;
       }
       $764 = HEAP32[$760>>2]|0;
       $765 = (($764>>>0) % ($i$1$lcssa$i>>>0))&-1;
       $766 = ($765|0)==(0);
       if ($766) {
        $$sum15$i = (($759) + -1022)|0;
        $767 = (($$31$i) + ($$sum15$i<<2)|0);
        $768 = ($767|0)==($z$3$lcssa$i|0);
        if ($768) {
         $a$7$i = $a$3$lcssa$i;$d$3$i = $760;$e$3$i = $e$1$i;
        } else {
         label = 221;
        }
       } else {
        label = 221;
       }
       do {
        if ((label|0) == 221) {
         label = 0;
         $769 = (($764>>>0) / ($i$1$lcssa$i>>>0))&-1;
         $770 = $769 & 1;
         $771 = ($770|0)==(0);
         $$20$i = $771 ? 9007199254740992.0 : 9007199254740994.0;
         $772 = (($i$1$lcssa$i|0) / 2)&-1;
         $773 = ($765>>>0)<($772>>>0);
         do {
          if ($773) {
           $small$0$i = 0.5;
          } else {
           $774 = ($765|0)==($772|0);
           if ($774) {
            $$sum16$i = (($759) + -1022)|0;
            $775 = (($$31$i) + ($$sum16$i<<2)|0);
            $776 = ($775|0)==($z$3$lcssa$i|0);
            if ($776) {
             $small$0$i = 1.0;
             break;
            }
           }
           $small$0$i = 1.5;
          }
         } while(0);
         $777 = ($pl$0$i|0)==(0);
         do {
          if ($777) {
           $round6$1$i = $$20$i;$small$1$i = $small$0$i;
          } else {
           $778 = HEAP8[$prefix$0$i>>0]|0;
           $779 = ($778<<24>>24)==(45);
           if (!($779)) {
            $round6$1$i = $$20$i;$small$1$i = $small$0$i;
            break;
           }
           $780 = -$$20$i;
           $781 = -$small$0$i;
           $round6$1$i = $780;$small$1$i = $781;
          }
         } while(0);
         $782 = (($764) - ($765))|0;
         HEAP32[$760>>2] = $782;
         $783 = $round6$1$i + $small$1$i;
         $784 = $783 != $round6$1$i;
         if (!($784)) {
          $a$7$i = $a$3$lcssa$i;$d$3$i = $760;$e$3$i = $e$1$i;
          break;
         }
         $785 = (($782) + ($i$1$lcssa$i))|0;
         HEAP32[$760>>2] = $785;
         $786 = ($785>>>0)>(999999999);
         if ($786) {
          $a$5215$i = $a$3$lcssa$i;$d$2214$i = $760;
          while(1) {
           $787 = ((($d$2214$i)) + -4|0);
           HEAP32[$d$2214$i>>2] = 0;
           $788 = ($787>>>0)<($a$5215$i>>>0);
           if ($788) {
            $789 = ((($a$5215$i)) + -4|0);
            HEAP32[$789>>2] = 0;
            $a$6$i = $789;
           } else {
            $a$6$i = $a$5215$i;
           }
           $790 = HEAP32[$787>>2]|0;
           $791 = (($790) + 1)|0;
           HEAP32[$787>>2] = $791;
           $792 = ($791>>>0)>(999999999);
           if ($792) {
            $a$5215$i = $a$6$i;$d$2214$i = $787;
           } else {
            $a$5$lcssa$i = $a$6$i;$d$2$lcssa$i = $787;
            break;
           }
          }
         } else {
          $a$5$lcssa$i = $a$3$lcssa$i;$d$2$lcssa$i = $760;
         }
         $793 = $a$5$lcssa$i;
         $794 = (($636) - ($793))|0;
         $795 = $794 >> 2;
         $796 = ($795*9)|0;
         $797 = HEAP32[$a$5$lcssa$i>>2]|0;
         $798 = ($797>>>0)<(10);
         if ($798) {
          $a$7$i = $a$5$lcssa$i;$d$3$i = $d$2$lcssa$i;$e$3$i = $796;
          break;
         } else {
          $e$2210$i = $796;$i$2209$i = 10;
         }
         while(1) {
          $799 = ($i$2209$i*10)|0;
          $800 = (($e$2210$i) + 1)|0;
          $801 = ($797>>>0)<($799>>>0);
          if ($801) {
           $a$7$i = $a$5$lcssa$i;$d$3$i = $d$2$lcssa$i;$e$3$i = $800;
           break;
          } else {
           $e$2210$i = $800;$i$2209$i = $799;
          }
         }
        }
       } while(0);
       $802 = ((($d$3$i)) + 4|0);
       $803 = ($z$3$lcssa$i>>>0)>($802>>>0);
       $$z$3$i = $803 ? $802 : $z$3$lcssa$i;
       $a$8$ph$i = $a$7$i;$e$4$ph$i = $e$3$i;$z$6$ph$i = $$z$3$i;
      } else {
       $a$8$ph$i = $a$3$lcssa$i;$e$4$ph$i = $e$1$i;$z$6$ph$i = $z$3$lcssa$i;
      }
      $804 = (0 - ($e$4$ph$i))|0;
      $z$6$i = $z$6$ph$i;
      while(1) {
       $805 = ($z$6$i>>>0)>($a$8$ph$i>>>0);
       if (!($805)) {
        $$lcssa275$i = 0;$z$6$i$lcssa = $z$6$i;
        break;
       }
       $806 = ((($z$6$i)) + -4|0);
       $807 = HEAP32[$806>>2]|0;
       $808 = ($807|0)==(0);
       if ($808) {
        $z$6$i = $806;
       } else {
        $$lcssa275$i = 1;$z$6$i$lcssa = $z$6$i;
        break;
       }
      }
      do {
       if ($748) {
        $809 = $749&1;
        $810 = $809 ^ 1;
        $$p$$i = (($810) + ($$p$i))|0;
        $811 = ($$p$$i|0)>($e$4$ph$i|0);
        $812 = ($e$4$ph$i|0)>(-5);
        $or$cond6$i = $811 & $812;
        if ($or$cond6$i) {
         $813 = (($t$0) + -1)|0;
         $$neg152$i = (($$p$$i) + -1)|0;
         $814 = (($$neg152$i) - ($e$4$ph$i))|0;
         $$013$i = $813;$$210$i = $814;
        } else {
         $815 = (($t$0) + -2)|0;
         $816 = (($$p$$i) + -1)|0;
         $$013$i = $815;$$210$i = $816;
        }
        $817 = $fl$1$ & 8;
        $818 = ($817|0)==(0);
        if (!($818)) {
         $$114$i = $$013$i;$$311$i = $$210$i;$$pre$phi302$iZ2D = $817;
         break;
        }
        do {
         if ($$lcssa275$i) {
          $819 = ((($z$6$i$lcssa)) + -4|0);
          $820 = HEAP32[$819>>2]|0;
          $821 = ($820|0)==(0);
          if ($821) {
           $j$2$i = 9;
           break;
          }
          $822 = (($820>>>0) % 10)&-1;
          $823 = ($822|0)==(0);
          if ($823) {
           $i$3205$i = 10;$j$1206$i = 0;
          } else {
           $j$2$i = 0;
           break;
          }
          while(1) {
           $824 = ($i$3205$i*10)|0;
           $825 = (($j$1206$i) + 1)|0;
           $826 = (($820>>>0) % ($824>>>0))&-1;
           $827 = ($826|0)==(0);
           if ($827) {
            $i$3205$i = $824;$j$1206$i = $825;
           } else {
            $j$2$i = $825;
            break;
           }
          }
         } else {
          $j$2$i = 9;
         }
        } while(0);
        $828 = $$013$i | 32;
        $829 = ($828|0)==(102);
        $830 = $z$6$i$lcssa;
        $831 = (($830) - ($636))|0;
        $832 = $831 >> 2;
        $833 = ($832*9)|0;
        $834 = (($833) + -9)|0;
        if ($829) {
         $835 = (($834) - ($j$2$i))|0;
         $836 = ($835|0)<(0);
         $$21$i = $836 ? 0 : $835;
         $837 = ($$210$i|0)<($$21$i|0);
         $$210$$22$i = $837 ? $$210$i : $$21$i;
         $$114$i = $$013$i;$$311$i = $$210$$22$i;$$pre$phi302$iZ2D = 0;
         break;
        } else {
         $838 = (($834) + ($e$4$ph$i))|0;
         $839 = (($838) - ($j$2$i))|0;
         $840 = ($839|0)<(0);
         $$23$i = $840 ? 0 : $839;
         $841 = ($$210$i|0)<($$23$i|0);
         $$210$$24$i = $841 ? $$210$i : $$23$i;
         $$114$i = $$013$i;$$311$i = $$210$$24$i;$$pre$phi302$iZ2D = 0;
         break;
        }
       } else {
        $$pre301$i = $fl$1$ & 8;
        $$114$i = $t$0;$$311$i = $$p$i;$$pre$phi302$iZ2D = $$pre301$i;
       }
      } while(0);
      $842 = $$311$i | $$pre$phi302$iZ2D;
      $843 = ($842|0)!=(0);
      $844 = $843&1;
      $845 = $$114$i | 32;
      $846 = ($845|0)==(102);
      if ($846) {
       $847 = ($e$4$ph$i|0)>(0);
       $848 = $847 ? $e$4$ph$i : 0;
       $$pn$i = $848;$estr$2$i = 0;
      } else {
       $849 = ($e$4$ph$i|0)<(0);
       $850 = $849 ? $804 : $e$4$ph$i;
       $851 = ($850|0)<(0);
       if ($851) {
        $852 = ($850|0)<(0);
        $853 = $852 << 31 >> 31;
        $$05$i79$i = $7;$854 = $850;$855 = $853;
        while(1) {
         $856 = (___uremdi3(($854|0),($855|0),10,0)|0);
         $857 = tempRet0;
         $858 = $856 | 48;
         $859 = $858&255;
         $860 = ((($$05$i79$i)) + -1|0);
         HEAP8[$860>>0] = $859;
         $861 = (___udivdi3(($854|0),($855|0),10,0)|0);
         $862 = tempRet0;
         $863 = ($855>>>0)>(9);
         $864 = ($854>>>0)>(4294967295);
         $865 = ($855|0)==(9);
         $866 = $865 & $864;
         $867 = $863 | $866;
         if ($867) {
          $$05$i79$i = $860;$854 = $861;$855 = $862;
         } else {
          $$lcssa470 = $860;$1185 = $861;$1186 = $862;
          break;
         }
        }
        $$0$lcssa$i84$i = $$lcssa470;$$01$lcssa$off0$i85$i = $1185;
       } else {
        $$0$lcssa$i84$i = $7;$$01$lcssa$off0$i85$i = $850;
       }
       $868 = ($$01$lcssa$off0$i85$i|0)==(0);
       if ($868) {
        $estr$1$ph$i = $$0$lcssa$i84$i;
       } else {
        $$12$i87$i = $$0$lcssa$i84$i;$y$03$i86$i = $$01$lcssa$off0$i85$i;
        while(1) {
         $869 = (($y$03$i86$i>>>0) % 10)&-1;
         $870 = $869 | 48;
         $871 = $870&255;
         $872 = ((($$12$i87$i)) + -1|0);
         HEAP8[$872>>0] = $871;
         $873 = (($y$03$i86$i>>>0) / 10)&-1;
         $874 = ($y$03$i86$i>>>0)<(10);
         if ($874) {
          $estr$1$ph$i = $872;
          break;
         } else {
          $$12$i87$i = $872;$y$03$i86$i = $873;
         }
        }
       }
       $875 = $estr$1$ph$i;
       $876 = (($9) - ($875))|0;
       $877 = ($876|0)<(2);
       if ($877) {
        $estr$1201$i = $estr$1$ph$i;
        while(1) {
         $878 = ((($estr$1201$i)) + -1|0);
         HEAP8[$878>>0] = 48;
         $879 = $878;
         $880 = (($9) - ($879))|0;
         $881 = ($880|0)<(2);
         if ($881) {
          $estr$1201$i = $878;
         } else {
          $estr$1$lcssa$i = $878;
          break;
         }
        }
       } else {
        $estr$1$lcssa$i = $estr$1$ph$i;
       }
       $882 = $e$4$ph$i >> 31;
       $883 = $882 & 2;
       $884 = (($883) + 43)|0;
       $885 = $884&255;
       $886 = ((($estr$1$lcssa$i)) + -1|0);
       HEAP8[$886>>0] = $885;
       $887 = $$114$i&255;
       $888 = ((($estr$1$lcssa$i)) + -2|0);
       HEAP8[$888>>0] = $887;
       $889 = $888;
       $890 = (($9) - ($889))|0;
       $$pn$i = $890;$estr$2$i = $888;
      }
      $891 = (($pl$0$i) + 1)|0;
      $892 = (($891) + ($$311$i))|0;
      $l$1$i = (($892) + ($844))|0;
      $893 = (($l$1$i) + ($$pn$i))|0;
      $894 = $fl$1$ & 73728;
      $895 = ($894|0)==(0);
      $896 = ($w$1|0)>($893|0);
      $or$cond$i93$i = $895 & $896;
      if ($or$cond$i93$i) {
       $897 = (($w$1) - ($893))|0;
       $898 = ($897>>>0)>(256);
       $899 = $898 ? 256 : $897;
       _memset(($pad$i|0),32,($899|0))|0;
       $900 = ($897>>>0)>(255);
       if ($900) {
        $$01$i95$i = $897;
        while(1) {
         (___fwritex($pad$i,256,$f)|0);
         $901 = (($$01$i95$i) + -256)|0;
         $902 = ($901>>>0)>(255);
         if ($902) {
          $$01$i95$i = $901;
         } else {
          break;
         }
        }
        $903 = $897 & 255;
        $$0$lcssa$i97$i = $903;
       } else {
        $$0$lcssa$i97$i = $897;
       }
       (___fwritex($pad$i,$$0$lcssa$i97$i,$f)|0);
      }
      (___fwritex($prefix$0$i,$pl$0$i,$f)|0);
      $904 = ($894|0)==(65536);
      $or$cond$i100$i = $904 & $896;
      if ($or$cond$i100$i) {
       $905 = (($w$1) - ($893))|0;
       $906 = ($905>>>0)>(256);
       $907 = $906 ? 256 : $905;
       _memset(($pad$i|0),48,($907|0))|0;
       $908 = ($905>>>0)>(255);
       if ($908) {
        $$01$i102$i = $905;
        while(1) {
         (___fwritex($pad$i,256,$f)|0);
         $909 = (($$01$i102$i) + -256)|0;
         $910 = ($909>>>0)>(255);
         if ($910) {
          $$01$i102$i = $909;
         } else {
          break;
         }
        }
        $911 = $905 & 255;
        $$0$lcssa$i104$i = $911;
       } else {
        $$0$lcssa$i104$i = $905;
       }
       (___fwritex($pad$i,$$0$lcssa$i104$i,$f)|0);
      }
      if ($846) {
       $912 = ($a$8$ph$i>>>0)>($$31$i>>>0);
       $r$0$a$8$i = $912 ? $$31$i : $a$8$ph$i;
       $d$4191$i = $r$0$a$8$i;
       while(1) {
        $913 = HEAP32[$d$4191$i>>2]|0;
        $914 = ($913|0)==(0);
        if ($914) {
         $$1$lcssa$i112$i = $14;
        } else {
         $$12$i110$i = $14;$y$03$i109$i = $913;
         while(1) {
          $915 = (($y$03$i109$i>>>0) % 10)&-1;
          $916 = $915 | 48;
          $917 = $916&255;
          $918 = ((($$12$i110$i)) + -1|0);
          HEAP8[$918>>0] = $917;
          $919 = (($y$03$i109$i>>>0) / 10)&-1;
          $920 = ($y$03$i109$i>>>0)<(10);
          if ($920) {
           $$1$lcssa$i112$i = $918;
           break;
          } else {
           $$12$i110$i = $918;$y$03$i109$i = $919;
          }
         }
        }
        $921 = ($d$4191$i|0)==($r$0$a$8$i|0);
        do {
         if ($921) {
          $925 = ($$1$lcssa$i112$i|0)==($14|0);
          if (!($925)) {
           $s7$1$i = $$1$lcssa$i112$i;
           break;
          }
          HEAP8[$16>>0] = 48;
          $s7$1$i = $16;
         } else {
          $922 = ($$1$lcssa$i112$i>>>0)>($buf$i>>>0);
          if ($922) {
           $s7$0188$i = $$1$lcssa$i112$i;
          } else {
           $s7$1$i = $$1$lcssa$i112$i;
           break;
          }
          while(1) {
           $923 = ((($s7$0188$i)) + -1|0);
           HEAP8[$923>>0] = 48;
           $924 = ($923>>>0)>($buf$i>>>0);
           if ($924) {
            $s7$0188$i = $923;
           } else {
            $s7$1$i = $923;
            break;
           }
          }
         }
        } while(0);
        $926 = $s7$1$i;
        $927 = (($15) - ($926))|0;
        (___fwritex($s7$1$i,$927,$f)|0);
        $928 = ((($d$4191$i)) + 4|0);
        $929 = ($928>>>0)>($$31$i>>>0);
        if ($929) {
         $$lcssa479 = $928;
         break;
        } else {
         $d$4191$i = $928;
        }
       }
       $930 = ($842|0)==(0);
       if (!($930)) {
        (___fwritex(96480,1,$f)|0);
       }
       $931 = ($$lcssa479>>>0)<($z$6$i$lcssa>>>0);
       $932 = ($$311$i|0)>(0);
       $933 = $932 & $931;
       if ($933) {
        $$412184$i = $$311$i;$d$5183$i = $$lcssa479;
        while(1) {
         $934 = HEAP32[$d$5183$i>>2]|0;
         $935 = ($934|0)==(0);
         if ($935) {
          $s8$0180$i = $14;
          label = 289;
         } else {
          $$12$i119$i = $14;$y$03$i118$i = $934;
          while(1) {
           $936 = (($y$03$i118$i>>>0) % 10)&-1;
           $937 = $936 | 48;
           $938 = $937&255;
           $939 = ((($$12$i119$i)) + -1|0);
           HEAP8[$939>>0] = $938;
           $940 = (($y$03$i118$i>>>0) / 10)&-1;
           $941 = ($y$03$i118$i>>>0)<(10);
           if ($941) {
            $$lcssa480 = $939;
            break;
           } else {
            $$12$i119$i = $939;$y$03$i118$i = $940;
           }
          }
          $942 = ($$lcssa480>>>0)>($buf$i>>>0);
          if ($942) {
           $s8$0180$i = $$lcssa480;
           label = 289;
          } else {
           $s8$0$lcssa$i = $$lcssa480;
          }
         }
         if ((label|0) == 289) {
          while(1) {
           label = 0;
           $943 = ((($s8$0180$i)) + -1|0);
           HEAP8[$943>>0] = 48;
           $944 = ($943>>>0)>($buf$i>>>0);
           if ($944) {
            $s8$0180$i = $943;
            label = 289;
           } else {
            $s8$0$lcssa$i = $943;
            break;
           }
          }
         }
         $945 = ($$412184$i|0)>(9);
         $946 = $945 ? 9 : $$412184$i;
         (___fwritex($s8$0$lcssa$i,$946,$f)|0);
         $947 = ((($d$5183$i)) + 4|0);
         $948 = (($$412184$i) + -9)|0;
         $949 = ($947>>>0)<($z$6$i$lcssa>>>0);
         $950 = $945 & $949;
         if ($950) {
          $$412184$i = $948;$d$5183$i = $947;
         } else {
          $$412$lcssa$i = $948;
          break;
         }
        }
       } else {
        $$412$lcssa$i = $$311$i;
       }
       $951 = ($$412$lcssa$i|0)>(0);
       if ($951) {
        $952 = ($$412$lcssa$i>>>0)>(256);
        $953 = $952 ? 256 : $$412$lcssa$i;
        _memset(($pad$i|0),48,($953|0))|0;
        $954 = ($$412$lcssa$i>>>0)>(255);
        if ($954) {
         $$01$i126$i = $$412$lcssa$i;
         while(1) {
          (___fwritex($pad$i,256,$f)|0);
          $955 = (($$01$i126$i) + -256)|0;
          $956 = ($955>>>0)>(255);
          if ($956) {
           $$01$i126$i = $955;
          } else {
           break;
          }
         }
         $957 = $$412$lcssa$i & 255;
         $$0$lcssa$i128$i = $957;
        } else {
         $$0$lcssa$i128$i = $$412$lcssa$i;
        }
        (___fwritex($pad$i,$$0$lcssa$i128$i,$f)|0);
       }
      } else {
       $958 = ((($a$8$ph$i)) + 4|0);
       $z$6$$i = $$lcssa275$i ? $z$6$i$lcssa : $958;
       $959 = ($$311$i|0)>(-1);
       do {
        if ($959) {
         $960 = ($$pre$phi302$iZ2D|0)==(0);
         $$5196$i = $$311$i;$d$6195$i = $a$8$ph$i;
         while(1) {
          $961 = HEAP32[$d$6195$i>>2]|0;
          $962 = ($961|0)==(0);
          if ($962) {
           label = 303;
          } else {
           $$12$i134$i = $14;$y$03$i133$i = $961;
           while(1) {
            $963 = (($y$03$i133$i>>>0) % 10)&-1;
            $964 = $963 | 48;
            $965 = $964&255;
            $966 = ((($$12$i134$i)) + -1|0);
            HEAP8[$966>>0] = $965;
            $967 = (($y$03$i133$i>>>0) / 10)&-1;
            $968 = ($y$03$i133$i>>>0)<(10);
            if ($968) {
             $$12$i134$i$lcssa = $$12$i134$i;$$lcssa474 = $966;
             break;
            } else {
             $$12$i134$i = $966;$y$03$i133$i = $967;
            }
           }
           $969 = ($$lcssa474|0)==($14|0);
           if ($969) {
            label = 303;
           } else {
            $1187 = $$12$i134$i$lcssa;$s9$0$i = $$lcssa474;
           }
          }
          if ((label|0) == 303) {
           label = 0;
           HEAP8[$16>>0] = 48;
           $1187 = $14;$s9$0$i = $16;
          }
          $970 = ($d$6195$i|0)==($a$8$ph$i|0);
          do {
           if ($970) {
            (___fwritex($s9$0$i,1,$f)|0);
            $974 = ($$5196$i|0)<(1);
            $or$cond29$i = $960 & $974;
            if ($or$cond29$i) {
             $s9$2$i = $1187;
             break;
            }
            (___fwritex(96480,1,$f)|0);
            $s9$2$i = $1187;
           } else {
            $971 = ($s9$0$i>>>0)>($buf$i>>>0);
            if ($971) {
             $s9$1192$i = $s9$0$i;
            } else {
             $s9$2$i = $s9$0$i;
             break;
            }
            while(1) {
             $972 = ((($s9$1192$i)) + -1|0);
             HEAP8[$972>>0] = 48;
             $973 = ($972>>>0)>($buf$i>>>0);
             if ($973) {
              $s9$1192$i = $972;
             } else {
              $s9$2$i = $972;
              break;
             }
            }
           }
          } while(0);
          $975 = $s9$2$i;
          $976 = (($15) - ($975))|0;
          $977 = ($$5196$i|0)>($976|0);
          $978 = $977 ? $976 : $$5196$i;
          (___fwritex($s9$2$i,$978,$f)|0);
          $979 = (($$5196$i) - ($976))|0;
          $980 = ((($d$6195$i)) + 4|0);
          $981 = ($980>>>0)<($z$6$$i>>>0);
          $982 = ($979|0)>(-1);
          $983 = $981 & $982;
          if ($983) {
           $$5196$i = $979;$d$6195$i = $980;
          } else {
           $$lcssa476 = $979;
           break;
          }
         }
         $984 = ($$lcssa476|0)>(0);
         if (!($984)) {
          break;
         }
         $985 = ($$lcssa476>>>0)>(256);
         $986 = $985 ? 256 : $$lcssa476;
         _memset(($pad$i|0),48,($986|0))|0;
         $987 = ($$lcssa476>>>0)>(255);
         if ($987) {
          $$01$i141$i = $$lcssa476;
          while(1) {
           (___fwritex($pad$i,256,$f)|0);
           $988 = (($$01$i141$i) + -256)|0;
           $989 = ($988>>>0)>(255);
           if ($989) {
            $$01$i141$i = $988;
           } else {
            break;
           }
          }
          $990 = $$lcssa476 & 255;
          $$0$lcssa$i143$i = $990;
         } else {
          $$0$lcssa$i143$i = $$lcssa476;
         }
         (___fwritex($pad$i,$$0$lcssa$i143$i,$f)|0);
        } else {
        }
       } while(0);
       $991 = $estr$2$i;
       $992 = (($9) - ($991))|0;
       (___fwritex($estr$2$i,$992,$f)|0);
      }
      $993 = ($894|0)==(8192);
      $or$cond$i$i = $993 & $896;
      if ($or$cond$i$i) {
       $994 = (($w$1) - ($893))|0;
       $995 = ($994>>>0)>(256);
       $996 = $995 ? 256 : $994;
       _memset(($pad$i|0),32,($996|0))|0;
       $997 = ($994>>>0)>(255);
       if ($997) {
        $$01$i$i = $994;
        while(1) {
         (___fwritex($pad$i,256,$f)|0);
         $998 = (($$01$i$i) + -256)|0;
         $999 = ($998>>>0)>(255);
         if ($999) {
          $$01$i$i = $998;
         } else {
          break;
         }
        }
        $1000 = $994 & 255;
        $$0$lcssa$i$i = $1000;
       } else {
        $$0$lcssa$i$i = $994;
       }
       (___fwritex($pad$i,$$0$lcssa$i$i,$f)|0);
      }
      $w$30$i = $896 ? $w$1 : $893;
      $$0$i = $w$30$i;
     } else {
      $445 = $t$0 & 32;
      $446 = ($445|0)!=(0);
      $447 = $446 ? 96448 : 96456;
      $448 = ($$07$i != $$07$i) | (0.0 != 0.0);
      $449 = $446 ? 96464 : 96472;
      $pl$1$i = $448 ? 0 : $pl$0$i;
      $s1$0$i = $448 ? $449 : $447;
      $450 = (($pl$1$i) + 3)|0;
      $451 = $fl$1$ & 8192;
      $452 = ($451|0)==(0);
      $453 = ($w$1|0)>($450|0);
      $or$cond$i35$i = $452 & $453;
      if ($or$cond$i35$i) {
       $454 = (($w$1) - ($450))|0;
       $455 = ($454>>>0)>(256);
       $456 = $455 ? 256 : $454;
       _memset(($pad$i|0),32,($456|0))|0;
       $457 = ($454>>>0)>(255);
       if ($457) {
        $$01$i37$i = $454;
        while(1) {
         (___fwritex($pad$i,256,$f)|0);
         $458 = (($$01$i37$i) + -256)|0;
         $459 = ($458>>>0)>(255);
         if ($459) {
          $$01$i37$i = $458;
         } else {
          break;
         }
        }
        $460 = $454 & 255;
        $$0$lcssa$i39$i = $460;
       } else {
        $$0$lcssa$i39$i = $454;
       }
       (___fwritex($pad$i,$$0$lcssa$i39$i,$f)|0);
      }
      (___fwritex($prefix$0$i,$pl$1$i,$f)|0);
      (___fwritex($s1$0$i,3,$f)|0);
      $461 = $fl$1$ & 73728;
      $462 = ($461|0)==(8192);
      $or$cond$i42$i = $462 & $453;
      if ($or$cond$i42$i) {
       $463 = (($w$1) - ($450))|0;
       $464 = ($463>>>0)>(256);
       $465 = $464 ? 256 : $463;
       _memset(($pad$i|0),32,($465|0))|0;
       $466 = ($463>>>0)>(255);
       if ($466) {
        $$01$i44$i = $463;
        while(1) {
         (___fwritex($pad$i,256,$f)|0);
         $467 = (($$01$i44$i) + -256)|0;
         $468 = ($467>>>0)>(255);
         if ($468) {
          $$01$i44$i = $467;
         } else {
          break;
         }
        }
        $469 = $463 & 255;
        $$0$lcssa$i46$i = $469;
       } else {
        $$0$lcssa$i46$i = $463;
       }
       (___fwritex($pad$i,$$0$lcssa$i46$i,$f)|0);
      }
      $470 = $453 ? $w$1 : $450;
      $$0$i = $470;
     }
    } while(0);
    $1169 = $291;$1170 = $264;$23 = $$lcssa457;$cnt$0 = $cnt$1;$l$0 = $$0$i;$l10n$0 = $l10n$3;
    continue L1;
    break;
   }
   case 112:  {
    $286 = ($p$0>>>0)>(8);
    $287 = $286 ? $p$0 : 8;
    $288 = $fl$1$ | 8;
    $fl$3 = $288;$p$1 = $287;$t$1 = 120;
    label = 73;
    break;
   }
   case 88: case 120:  {
    $fl$3 = $fl$1$;$p$1 = $p$0;$t$1 = $t$0;
    label = 73;
    break;
   }
   case 105: case 100:  {
    $329 = ($291|0)<(0);
    if ($329) {
     $330 = (_i64Subtract(0,0,($264|0),($291|0))|0);
     $331 = tempRet0;
     $336 = $331;$338 = $330;$pl$0 = 1;$prefix$0 = 96400;
     label = 84;
     break L86;
    }
    $332 = $fl$1$ & 2048;
    $333 = ($332|0)==(0);
    if ($333) {
     $334 = $fl$1$ & 1;
     $335 = ($334|0)==(0);
     $$ = $335 ? 96400 : (96402);
     $336 = $291;$338 = $264;$pl$0 = $334;$prefix$0 = $$;
     label = 84;
    } else {
     $336 = $291;$338 = $264;$pl$0 = 1;$prefix$0 = (96401);
     label = 84;
    }
    break;
   }
   case 99:  {
    $378 = $264&255;
    HEAP8[$4>>0] = $378;
    $1175 = $291;$1176 = $264;$a$2 = $4;$fl$6 = $263;$p$5 = 1;$pl$2 = 0;$prefix$2 = 96400;$z$2 = $2;
    break;
   }
   case 109:  {
    $379 = (___errno_location()|0);
    $380 = HEAP32[$379>>2]|0;
    $381 = (_strerror(($380|0))|0);
    $a$1 = $381;
    label = 94;
    break;
   }
   case 115:  {
    $382 = $264;
    $383 = ($264|0)!=(0);
    $384 = $383 ? $382 : 96416;
    $a$1 = $384;
    label = 94;
    break;
   }
   default: {
    $1175 = $291;$1176 = $264;$a$2 = $23;$fl$6 = $fl$1$;$p$5 = $p$0;$pl$2 = 0;$prefix$2 = 96400;$z$2 = $2;
   }
   }
  } while(0);
  if ((label|0) == 73) {
   label = 0;
   $289 = $t$1 & 32;
   $290 = ($264|0)==(0);
   $292 = ($291|0)==(0);
   $293 = $290 & $292;
   if ($293) {
    $366 = $264;$368 = $291;$a$0 = $2;$fl$4 = $fl$3;$p$2 = $p$1;$pl$1 = 0;$prefix$1 = 96400;
    label = 89;
   } else {
    $$012$i = $2;$295 = $264;$302 = $291;
    while(1) {
     $294 = $295 & 15;
     $296 = (96384 + ($294)|0);
     $297 = HEAP8[$296>>0]|0;
     $298 = $297&255;
     $299 = $298 | $289;
     $300 = $299&255;
     $301 = ((($$012$i)) + -1|0);
     HEAP8[$301>>0] = $300;
     $303 = (_bitshift64Lshr(($295|0),($302|0),4)|0);
     $304 = tempRet0;
     $305 = ($303|0)==(0);
     $306 = ($304|0)==(0);
     $307 = $305 & $306;
     if ($307) {
      $$lcssa491 = $301;
      break;
     } else {
      $$012$i = $301;$295 = $303;$302 = $304;
     }
    }
    $308 = $fl$3 & 8;
    $309 = ($308|0)==(0);
    if ($309) {
     $366 = $264;$368 = $291;$a$0 = $$lcssa491;$fl$4 = $fl$3;$p$2 = $p$1;$pl$1 = 0;$prefix$1 = 96400;
     label = 89;
    } else {
     $310 = $t$1 >> 4;
     $311 = (96400 + ($310)|0);
     $366 = $264;$368 = $291;$a$0 = $$lcssa491;$fl$4 = $fl$3;$p$2 = $p$1;$pl$1 = 2;$prefix$1 = $311;
     label = 89;
    }
   }
  }
  else if ((label|0) == 84) {
   label = 0;
   $337 = ($336>>>0)>(0);
   $339 = ($338>>>0)>(4294967295);
   $340 = ($336|0)==(0);
   $341 = $340 & $339;
   $342 = $337 | $341;
   if ($342) {
    $$05$i = $2;$343 = $338;$344 = $336;
    while(1) {
     $345 = (___uremdi3(($343|0),($344|0),10,0)|0);
     $346 = tempRet0;
     $347 = $345 | 48;
     $348 = $347&255;
     $349 = ((($$05$i)) + -1|0);
     HEAP8[$349>>0] = $348;
     $350 = (___udivdi3(($343|0),($344|0),10,0)|0);
     $351 = tempRet0;
     $352 = ($344>>>0)>(9);
     $353 = ($343>>>0)>(4294967295);
     $354 = ($344|0)==(9);
     $355 = $354 & $353;
     $356 = $352 | $355;
     if ($356) {
      $$05$i = $349;$343 = $350;$344 = $351;
     } else {
      $$lcssa487 = $349;$1177 = $350;$1178 = $351;
      break;
     }
    }
    $$0$lcssa$i53 = $$lcssa487;$$01$lcssa$off0$i = $1177;
   } else {
    $$0$lcssa$i53 = $2;$$01$lcssa$off0$i = $338;
   }
   $357 = ($$01$lcssa$off0$i|0)==(0);
   if ($357) {
    $366 = $338;$368 = $336;$a$0 = $$0$lcssa$i53;$fl$4 = $fl$1$;$p$2 = $p$0;$pl$1 = $pl$0;$prefix$1 = $prefix$0;
    label = 89;
   } else {
    $$12$i = $$0$lcssa$i53;$y$03$i = $$01$lcssa$off0$i;
    while(1) {
     $358 = (($y$03$i>>>0) % 10)&-1;
     $359 = $358 | 48;
     $360 = $359&255;
     $361 = ((($$12$i)) + -1|0);
     HEAP8[$361>>0] = $360;
     $362 = (($y$03$i>>>0) / 10)&-1;
     $363 = ($y$03$i>>>0)<(10);
     if ($363) {
      $366 = $338;$368 = $336;$a$0 = $361;$fl$4 = $fl$1$;$p$2 = $p$0;$pl$1 = $pl$0;$prefix$1 = $prefix$0;
      label = 89;
      break;
     } else {
      $$12$i = $361;$y$03$i = $362;
     }
    }
   }
  }
  else if ((label|0) == 94) {
   label = 0;
   $385 = (_memchr($a$1,0,$p$0)|0);
   $386 = ($385|0)==(0|0);
   $387 = $385;
   $388 = $a$1;
   $389 = (($387) - ($388))|0;
   $390 = (($a$1) + ($p$0)|0);
   $z$1 = $386 ? $390 : $385;
   $p$3 = $386 ? $p$0 : $389;
   $1175 = $291;$1176 = $264;$a$2 = $a$1;$fl$6 = $263;$p$5 = $p$3;$pl$2 = 0;$prefix$2 = 96400;$z$2 = $z$1;
  }
  else if ((label|0) == 97) {
   label = 0;
   $i$0175 = 0;$l$1174 = 0;$ws$0176 = $1179;
   while(1) {
    $393 = HEAP32[$ws$0176>>2]|0;
    $394 = ($393|0)==(0);
    if ($394) {
     $i$0$lcssa = $i$0175;$l$2 = $l$1174;
     break;
    }
    $395 = (_wctomb($mb,$393)|0);
    $396 = ($395|0)<(0);
    $397 = (($p$4272) - ($i$0175))|0;
    $398 = ($395>>>0)>($397>>>0);
    $or$cond22 = $396 | $398;
    if ($or$cond22) {
     $i$0$lcssa = $i$0175;$l$2 = $395;
     break;
    }
    $399 = ((($ws$0176)) + 4|0);
    $400 = (($395) + ($i$0175))|0;
    $401 = ($p$4272>>>0)>($400>>>0);
    if ($401) {
     $i$0175 = $400;$l$1174 = $395;$ws$0176 = $399;
    } else {
     $i$0$lcssa = $400;$l$2 = $395;
     break;
    }
   }
   $402 = ($l$2|0)<(0);
   if ($402) {
    $$0 = -1;
    label = 363;
    break;
   } else {
    $1181 = $1180;$1182 = $1179;$i$0$lcssa273 = $i$0$lcssa;
    label = 102;
   }
  }
  if ((label|0) == 89) {
   label = 0;
   $364 = ($p$2|0)>(-1);
   $365 = $fl$4 & -65537;
   $$fl$4 = $364 ? $365 : $fl$4;
   $367 = ($366|0)!=(0);
   $369 = ($368|0)!=(0);
   $370 = $367 | $369;
   $371 = ($p$2|0)!=(0);
   $or$cond = $370 | $371;
   if ($or$cond) {
    $372 = $a$0;
    $373 = (($3) - ($372))|0;
    $374 = $370&1;
    $375 = $374 ^ 1;
    $376 = (($375) + ($373))|0;
    $377 = ($p$2|0)>($376|0);
    $p$2$ = $377 ? $p$2 : $376;
    $1175 = $368;$1176 = $366;$a$2 = $a$0;$fl$6 = $$fl$4;$p$5 = $p$2$;$pl$2 = $pl$1;$prefix$2 = $prefix$1;$z$2 = $2;
   } else {
    $1175 = $368;$1176 = $366;$a$2 = $2;$fl$6 = $$fl$4;$p$5 = 0;$pl$2 = $pl$1;$prefix$2 = $prefix$1;$z$2 = $2;
   }
  }
  else if ((label|0) == 102) {
   label = 0;
   $403 = $fl$1$ & 73728;
   $404 = ($403|0)==(0);
   $405 = ($w$1|0)>($i$0$lcssa273|0);
   $or$cond$i64 = $404 & $405;
   if ($or$cond$i64) {
    $406 = (($w$1) - ($i$0$lcssa273))|0;
    $407 = ($406>>>0)>(256);
    $408 = $407 ? 256 : $406;
    _memset(($pad$i|0),32,($408|0))|0;
    $409 = ($406>>>0)>(255);
    if ($409) {
     $$01$i66 = $406;
     while(1) {
      (___fwritex($pad$i,256,$f)|0);
      $410 = (($$01$i66) + -256)|0;
      $411 = ($410>>>0)>(255);
      if ($411) {
       $$01$i66 = $410;
      } else {
       break;
      }
     }
     $412 = $406 & 255;
     $$0$lcssa$i68 = $412;
    } else {
     $$0$lcssa$i68 = $406;
    }
    (___fwritex($pad$i,$$0$lcssa$i68,$f)|0);
   }
   $413 = ($i$0$lcssa273|0)==(0);
   L465: do {
    if (!($413)) {
     $i$1186 = 0;$ws$1187 = $1182;
     while(1) {
      $414 = HEAP32[$ws$1187>>2]|0;
      $415 = ($414|0)==(0);
      if ($415) {
       break L465;
      }
      $416 = (_wctomb($mb,$414)|0);
      $417 = (($416) + ($i$1186))|0;
      $418 = ($417|0)>($i$0$lcssa273|0);
      if ($418) {
       break L465;
      }
      $419 = ((($ws$1187)) + 4|0);
      (___fwritex($mb,$416,$f)|0);
      $420 = ($417>>>0)<($i$0$lcssa273>>>0);
      if ($420) {
       $i$1186 = $417;$ws$1187 = $419;
      } else {
       break;
      }
     }
    }
   } while(0);
   $421 = ($403|0)==(8192);
   $or$cond$i71 = $421 & $405;
   if ($or$cond$i71) {
    $422 = (($w$1) - ($i$0$lcssa273))|0;
    $423 = ($422>>>0)>(256);
    $424 = $423 ? 256 : $422;
    _memset(($pad$i|0),32,($424|0))|0;
    $425 = ($422>>>0)>(255);
    if ($425) {
     $$01$i73 = $422;
     while(1) {
      (___fwritex($pad$i,256,$f)|0);
      $426 = (($$01$i73) + -256)|0;
      $427 = ($426>>>0)>(255);
      if ($427) {
       $$01$i73 = $426;
      } else {
       break;
      }
     }
     $428 = $422 & 255;
     $$0$lcssa$i75 = $428;
    } else {
     $$0$lcssa$i75 = $422;
    }
    (___fwritex($pad$i,$$0$lcssa$i75,$f)|0);
   }
   $429 = $405 ? $w$1 : $i$0$lcssa273;
   $1169 = $291;$1170 = $1181;$23 = $$lcssa457;$cnt$0 = $cnt$1;$l$0 = $429;$l10n$0 = $l10n$3;
   continue;
  }
  $1001 = $z$2;
  $1002 = $a$2;
  $1003 = (($1001) - ($1002))|0;
  $1004 = ($p$5|0)<($1003|0);
  $$p$5 = $1004 ? $1003 : $p$5;
  $1005 = (($pl$2) + ($$p$5))|0;
  $1006 = ($w$1|0)<($1005|0);
  $w$2 = $1006 ? $1005 : $w$1;
  $1007 = $fl$6 & 73728;
  $1008 = ($1007|0)==(0);
  $1009 = ($w$2|0)>($1005|0);
  $or$cond$i81 = $1008 & $1009;
  if ($or$cond$i81) {
   $1010 = (($w$2) - ($1005))|0;
   $1011 = ($1010>>>0)>(256);
   $1012 = $1011 ? 256 : $1010;
   _memset(($pad$i|0),32,($1012|0))|0;
   $1013 = ($1010>>>0)>(255);
   if ($1013) {
    $$01$i83 = $1010;
    while(1) {
     (___fwritex($pad$i,256,$f)|0);
     $1014 = (($$01$i83) + -256)|0;
     $1015 = ($1014>>>0)>(255);
     if ($1015) {
      $$01$i83 = $1014;
     } else {
      break;
     }
    }
    $1016 = $1010 & 255;
    $$0$lcssa$i85 = $1016;
   } else {
    $$0$lcssa$i85 = $1010;
   }
   (___fwritex($pad$i,$$0$lcssa$i85,$f)|0);
  }
  (___fwritex($prefix$2,$pl$2,$f)|0);
  $1017 = ($1007|0)==(65536);
  $or$cond$i57 = $1017 & $1009;
  if ($or$cond$i57) {
   $1018 = (($w$2) - ($1005))|0;
   $1019 = ($1018>>>0)>(256);
   $1020 = $1019 ? 256 : $1018;
   _memset(($pad$i|0),48,($1020|0))|0;
   $1021 = ($1018>>>0)>(255);
   if ($1021) {
    $$01$i59 = $1018;
    while(1) {
     (___fwritex($pad$i,256,$f)|0);
     $1022 = (($$01$i59) + -256)|0;
     $1023 = ($1022>>>0)>(255);
     if ($1023) {
      $$01$i59 = $1022;
     } else {
      break;
     }
    }
    $1024 = $1018 & 255;
    $$0$lcssa$i61 = $1024;
   } else {
    $$0$lcssa$i61 = $1018;
   }
   (___fwritex($pad$i,$$0$lcssa$i61,$f)|0);
  }
  $1025 = ($$p$5|0)>($1003|0);
  if ($1025) {
   $1026 = (($$p$5) - ($1003))|0;
   $1027 = ($1026>>>0)>(256);
   $1028 = $1027 ? 256 : $1026;
   _memset(($pad$i|0),48,($1028|0))|0;
   $1029 = ($1026>>>0)>(255);
   if ($1029) {
    $$01$i44 = $1026;
    while(1) {
     (___fwritex($pad$i,256,$f)|0);
     $1030 = (($$01$i44) + -256)|0;
     $1031 = ($1030>>>0)>(255);
     if ($1031) {
      $$01$i44 = $1030;
     } else {
      break;
     }
    }
    $1032 = $1026 & 255;
    $$0$lcssa$i46 = $1032;
   } else {
    $$0$lcssa$i46 = $1026;
   }
   (___fwritex($pad$i,$$0$lcssa$i46,$f)|0);
  }
  (___fwritex($a$2,$1003,$f)|0);
  $1033 = ($1007|0)==(8192);
  $or$cond$i = $1033 & $1009;
  if ($or$cond$i) {
   $1034 = (($w$2) - ($1005))|0;
   $1035 = ($1034>>>0)>(256);
   $1036 = $1035 ? 256 : $1034;
   _memset(($pad$i|0),32,($1036|0))|0;
   $1037 = ($1034>>>0)>(255);
   if ($1037) {
    $$01$i = $1034;
    while(1) {
     (___fwritex($pad$i,256,$f)|0);
     $1038 = (($$01$i) + -256)|0;
     $1039 = ($1038>>>0)>(255);
     if ($1039) {
      $$01$i = $1038;
     } else {
      break;
     }
    }
    $1040 = $1034 & 255;
    $$0$lcssa$i = $1040;
   } else {
    $$0$lcssa$i = $1034;
   }
   (___fwritex($pad$i,$$0$lcssa$i,$f)|0);
  }
  $1169 = $1175;$1170 = $1176;$23 = $$lcssa457;$cnt$0 = $cnt$1;$l$0 = $w$2;$l10n$0 = $l10n$3;
 }
 if ((label|0) == 344) {
  $1041 = ($f|0)==(0|0);
  if (!($1041)) {
   $$0 = $cnt$1$lcssa;
   STACKTOP = sp;return ($$0|0);
  }
  $1042 = ($l10n$0$lcssa|0)==(0);
  if ($1042) {
   $$0 = 0;
   STACKTOP = sp;return ($$0|0);
  } else {
   $i$2162 = 1;
  }
  while(1) {
   $1043 = (($nl_type) + ($i$2162<<2)|0);
   $1044 = HEAP32[$1043>>2]|0;
   $1045 = ($1044|0)==(0);
   if ($1045) {
    $i$2162$lcssa = $i$2162;
    break;
   }
   $1047 = (($nl_arg) + ($i$2162<<3)|0);
   $1048 = ($1044>>>0)>(20);
   L530: do {
    if (!($1048)) {
     do {
      switch ($1044|0) {
      case 9:  {
       $arglist_current35 = HEAP32[$ap>>2]|0;
       $1049 = $arglist_current35;
       $1050 = ((0) + 4|0);
       $expanded148 = $1050;
       $expanded147 = (($expanded148) - 1)|0;
       $1051 = (($1049) + ($expanded147))|0;
       $1052 = ((0) + 4|0);
       $expanded152 = $1052;
       $expanded151 = (($expanded152) - 1)|0;
       $expanded150 = $expanded151 ^ -1;
       $1053 = $1051 & $expanded150;
       $1054 = $1053;
       $1055 = HEAP32[$1054>>2]|0;
       $arglist_next36 = ((($1054)) + 4|0);
       HEAP32[$ap>>2] = $arglist_next36;
       HEAP32[$1047>>2] = $1055;
       break L530;
       break;
      }
      case 10:  {
       $arglist_current38 = HEAP32[$ap>>2]|0;
       $1056 = $arglist_current38;
       $1057 = ((0) + 4|0);
       $expanded155 = $1057;
       $expanded154 = (($expanded155) - 1)|0;
       $1058 = (($1056) + ($expanded154))|0;
       $1059 = ((0) + 4|0);
       $expanded159 = $1059;
       $expanded158 = (($expanded159) - 1)|0;
       $expanded157 = $expanded158 ^ -1;
       $1060 = $1058 & $expanded157;
       $1061 = $1060;
       $1062 = HEAP32[$1061>>2]|0;
       $arglist_next39 = ((($1061)) + 4|0);
       HEAP32[$ap>>2] = $arglist_next39;
       $1063 = ($1062|0)<(0);
       $1064 = $1063 << 31 >> 31;
       $1065 = $1047;
       $1066 = $1065;
       HEAP32[$1066>>2] = $1062;
       $1067 = (($1065) + 4)|0;
       $1068 = $1067;
       HEAP32[$1068>>2] = $1064;
       break L530;
       break;
      }
      case 11:  {
       $arglist_current41 = HEAP32[$ap>>2]|0;
       $1069 = $arglist_current41;
       $1070 = ((0) + 4|0);
       $expanded162 = $1070;
       $expanded161 = (($expanded162) - 1)|0;
       $1071 = (($1069) + ($expanded161))|0;
       $1072 = ((0) + 4|0);
       $expanded166 = $1072;
       $expanded165 = (($expanded166) - 1)|0;
       $expanded164 = $expanded165 ^ -1;
       $1073 = $1071 & $expanded164;
       $1074 = $1073;
       $1075 = HEAP32[$1074>>2]|0;
       $arglist_next42 = ((($1074)) + 4|0);
       HEAP32[$ap>>2] = $arglist_next42;
       $1076 = $1047;
       $1077 = $1076;
       HEAP32[$1077>>2] = $1075;
       $1078 = (($1076) + 4)|0;
       $1079 = $1078;
       HEAP32[$1079>>2] = 0;
       break L530;
       break;
      }
      case 12:  {
       $arglist_current44 = HEAP32[$ap>>2]|0;
       $1080 = $arglist_current44;
       $1081 = ((0) + 8|0);
       $expanded169 = $1081;
       $expanded168 = (($expanded169) - 1)|0;
       $1082 = (($1080) + ($expanded168))|0;
       $1083 = ((0) + 8|0);
       $expanded173 = $1083;
       $expanded172 = (($expanded173) - 1)|0;
       $expanded171 = $expanded172 ^ -1;
       $1084 = $1082 & $expanded171;
       $1085 = $1084;
       $1086 = $1085;
       $1087 = $1086;
       $1088 = HEAP32[$1087>>2]|0;
       $1089 = (($1086) + 4)|0;
       $1090 = $1089;
       $1091 = HEAP32[$1090>>2]|0;
       $arglist_next45 = ((($1085)) + 8|0);
       HEAP32[$ap>>2] = $arglist_next45;
       $1092 = $1047;
       $1093 = $1092;
       HEAP32[$1093>>2] = $1088;
       $1094 = (($1092) + 4)|0;
       $1095 = $1094;
       HEAP32[$1095>>2] = $1091;
       break L530;
       break;
      }
      case 13:  {
       $arglist_current47 = HEAP32[$ap>>2]|0;
       $1096 = $arglist_current47;
       $1097 = ((0) + 4|0);
       $expanded176 = $1097;
       $expanded175 = (($expanded176) - 1)|0;
       $1098 = (($1096) + ($expanded175))|0;
       $1099 = ((0) + 4|0);
       $expanded180 = $1099;
       $expanded179 = (($expanded180) - 1)|0;
       $expanded178 = $expanded179 ^ -1;
       $1100 = $1098 & $expanded178;
       $1101 = $1100;
       $1102 = HEAP32[$1101>>2]|0;
       $arglist_next48 = ((($1101)) + 4|0);
       HEAP32[$ap>>2] = $arglist_next48;
       $1103 = $1102&65535;
       $1104 = $1103 << 16 >> 16;
       $1105 = ($1104|0)<(0);
       $1106 = $1105 << 31 >> 31;
       $1107 = $1047;
       $1108 = $1107;
       HEAP32[$1108>>2] = $1104;
       $1109 = (($1107) + 4)|0;
       $1110 = $1109;
       HEAP32[$1110>>2] = $1106;
       break L530;
       break;
      }
      case 14:  {
       $arglist_current50 = HEAP32[$ap>>2]|0;
       $1111 = $arglist_current50;
       $1112 = ((0) + 4|0);
       $expanded183 = $1112;
       $expanded182 = (($expanded183) - 1)|0;
       $1113 = (($1111) + ($expanded182))|0;
       $1114 = ((0) + 4|0);
       $expanded187 = $1114;
       $expanded186 = (($expanded187) - 1)|0;
       $expanded185 = $expanded186 ^ -1;
       $1115 = $1113 & $expanded185;
       $1116 = $1115;
       $1117 = HEAP32[$1116>>2]|0;
       $arglist_next51 = ((($1116)) + 4|0);
       HEAP32[$ap>>2] = $arglist_next51;
       $$mask1$i = $1117 & 65535;
       $1118 = $1047;
       $1119 = $1118;
       HEAP32[$1119>>2] = $$mask1$i;
       $1120 = (($1118) + 4)|0;
       $1121 = $1120;
       HEAP32[$1121>>2] = 0;
       break L530;
       break;
      }
      case 15:  {
       $arglist_current53 = HEAP32[$ap>>2]|0;
       $1122 = $arglist_current53;
       $1123 = ((0) + 4|0);
       $expanded190 = $1123;
       $expanded189 = (($expanded190) - 1)|0;
       $1124 = (($1122) + ($expanded189))|0;
       $1125 = ((0) + 4|0);
       $expanded194 = $1125;
       $expanded193 = (($expanded194) - 1)|0;
       $expanded192 = $expanded193 ^ -1;
       $1126 = $1124 & $expanded192;
       $1127 = $1126;
       $1128 = HEAP32[$1127>>2]|0;
       $arglist_next54 = ((($1127)) + 4|0);
       HEAP32[$ap>>2] = $arglist_next54;
       $1129 = $1128&255;
       $1130 = $1129 << 24 >> 24;
       $1131 = ($1130|0)<(0);
       $1132 = $1131 << 31 >> 31;
       $1133 = $1047;
       $1134 = $1133;
       HEAP32[$1134>>2] = $1130;
       $1135 = (($1133) + 4)|0;
       $1136 = $1135;
       HEAP32[$1136>>2] = $1132;
       break L530;
       break;
      }
      case 16:  {
       $arglist_current56 = HEAP32[$ap>>2]|0;
       $1137 = $arglist_current56;
       $1138 = ((0) + 4|0);
       $expanded197 = $1138;
       $expanded196 = (($expanded197) - 1)|0;
       $1139 = (($1137) + ($expanded196))|0;
       $1140 = ((0) + 4|0);
       $expanded201 = $1140;
       $expanded200 = (($expanded201) - 1)|0;
       $expanded199 = $expanded200 ^ -1;
       $1141 = $1139 & $expanded199;
       $1142 = $1141;
       $1143 = HEAP32[$1142>>2]|0;
       $arglist_next57 = ((($1142)) + 4|0);
       HEAP32[$ap>>2] = $arglist_next57;
       $$mask$i = $1143 & 255;
       $1144 = $1047;
       $1145 = $1144;
       HEAP32[$1145>>2] = $$mask$i;
       $1146 = (($1144) + 4)|0;
       $1147 = $1146;
       HEAP32[$1147>>2] = 0;
       break L530;
       break;
      }
      case 17:  {
       $arglist_current59 = HEAP32[$ap>>2]|0;
       $1148 = $arglist_current59;
       $1149 = ((0) + 8|0);
       $expanded204 = $1149;
       $expanded203 = (($expanded204) - 1)|0;
       $1150 = (($1148) + ($expanded203))|0;
       $1151 = ((0) + 8|0);
       $expanded208 = $1151;
       $expanded207 = (($expanded208) - 1)|0;
       $expanded206 = $expanded207 ^ -1;
       $1152 = $1150 & $expanded206;
       $1153 = $1152;
       $1154 = +HEAPF64[$1153>>3];
       $arglist_next60 = ((($1153)) + 8|0);
       HEAP32[$ap>>2] = $arglist_next60;
       HEAPF64[$1047>>3] = $1154;
       break L530;
       break;
      }
      case 18:  {
       $arglist_current62 = HEAP32[$ap>>2]|0;
       $1155 = $arglist_current62;
       $1156 = ((0) + 8|0);
       $expanded211 = $1156;
       $expanded210 = (($expanded211) - 1)|0;
       $1157 = (($1155) + ($expanded210))|0;
       $1158 = ((0) + 8|0);
       $expanded215 = $1158;
       $expanded214 = (($expanded215) - 1)|0;
       $expanded213 = $expanded214 ^ -1;
       $1159 = $1157 & $expanded213;
       $1160 = $1159;
       $1161 = +HEAPF64[$1160>>3];
       $arglist_next63 = ((($1160)) + 8|0);
       HEAP32[$ap>>2] = $arglist_next63;
       HEAPF64[$1047>>3] = $1161;
       break L530;
       break;
      }
      default: {
       break L530;
      }
      }
     } while(0);
    }
   } while(0);
   $1162 = (($i$2162) + 1)|0;
   $1163 = ($1162|0)<(10);
   if ($1163) {
    $i$2162 = $1162;
   } else {
    $$0 = 1;
    label = 363;
    break;
   }
  }
  if ((label|0) == 363) {
   STACKTOP = sp;return ($$0|0);
  }
  $1046 = ($i$2162$lcssa|0)<(10);
  if ($1046) {
   $i$3160 = $i$2162$lcssa;
  } else {
   $$0 = 1;
   STACKTOP = sp;return ($$0|0);
  }
  while(1) {
   $1166 = (($nl_type) + ($i$3160<<2)|0);
   $1167 = HEAP32[$1166>>2]|0;
   $1168 = ($1167|0)==(0);
   $1164 = (($i$3160) + 1)|0;
   if (!($1168)) {
    $$0 = -1;
    label = 363;
    break;
   }
   $1165 = ($1164|0)<(10);
   if ($1165) {
    $i$3160 = $1164;
   } else {
    $$0 = 1;
    label = 363;
    break;
   }
  }
  if ((label|0) == 363) {
   STACKTOP = sp;return ($$0|0);
  }
 }
 else if ((label|0) == 363) {
  STACKTOP = sp;return ($$0|0);
 }
 return (0)|0;
}
function _sn_write($f,$s,$l) {
 $f = $f|0;
 $s = $s|0;
 $l = $l|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $l$ = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ((($f)) + 16|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ((($f)) + 20|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = $1;
 $5 = $3;
 $6 = (($4) - ($5))|0;
 $7 = ($6>>>0)>($l>>>0);
 $l$ = $7 ? $l : $6;
 _memcpy(($3|0),($s|0),($l$|0))|0;
 $8 = HEAP32[$2>>2]|0;
 $9 = (($8) + ($l$)|0);
 HEAP32[$2>>2] = $9;
 return ($l|0);
}
function _malloc($bytes) {
 $bytes = $bytes|0;
 var $$3$i = 0, $$lcssa = 0, $$lcssa211 = 0, $$lcssa215 = 0, $$lcssa216 = 0, $$lcssa217 = 0, $$lcssa219 = 0, $$lcssa222 = 0, $$lcssa224 = 0, $$lcssa226 = 0, $$lcssa228 = 0, $$lcssa230 = 0, $$lcssa232 = 0, $$pre = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i22$i = 0, $$pre$i25 = 0, $$pre$phi$i$iZ2D = 0, $$pre$phi$i23$iZ2D = 0;
 var $$pre$phi$i26Z2D = 0, $$pre$phi$iZ2D = 0, $$pre$phi58$i$iZ2D = 0, $$pre$phiZ2D = 0, $$pre105 = 0, $$pre106 = 0, $$pre14$i$i = 0, $$pre43$i = 0, $$pre56$i$i = 0, $$pre57$i$i = 0, $$pre8$i = 0, $$rsize$0$i = 0, $$rsize$3$i = 0, $$sum = 0, $$sum$i$i = 0, $$sum$i$i$i = 0, $$sum$i13$i = 0, $$sum$i14$i = 0, $$sum$i17$i = 0, $$sum$i19$i = 0;
 var $$sum$i2334 = 0, $$sum$i32 = 0, $$sum$i35 = 0, $$sum1 = 0, $$sum1$i = 0, $$sum1$i$i = 0, $$sum1$i15$i = 0, $$sum1$i20$i = 0, $$sum1$i24 = 0, $$sum10 = 0, $$sum10$i = 0, $$sum10$i$i = 0, $$sum11$i = 0, $$sum11$i$i = 0, $$sum1112 = 0, $$sum112$i = 0, $$sum113$i = 0, $$sum114$i = 0, $$sum115$i = 0, $$sum116$i = 0;
 var $$sum117$i = 0, $$sum118$i = 0, $$sum119$i = 0, $$sum12$i = 0, $$sum12$i$i = 0, $$sum120$i = 0, $$sum121$i = 0, $$sum122$i = 0, $$sum123$i = 0, $$sum124$i = 0, $$sum125$i = 0, $$sum13$i = 0, $$sum13$i$i = 0, $$sum14$i$i = 0, $$sum15$i = 0, $$sum15$i$i = 0, $$sum16$i = 0, $$sum16$i$i = 0, $$sum17$i = 0, $$sum17$i$i = 0;
 var $$sum18$i = 0, $$sum1819$i$i = 0, $$sum2 = 0, $$sum2$i = 0, $$sum2$i$i = 0, $$sum2$i$i$i = 0, $$sum2$i16$i = 0, $$sum2$i18$i = 0, $$sum2$i21$i = 0, $$sum20$i$i = 0, $$sum21$i$i = 0, $$sum22$i$i = 0, $$sum23$i$i = 0, $$sum24$i$i = 0, $$sum25$i$i = 0, $$sum27$i$i = 0, $$sum28$i$i = 0, $$sum29$i$i = 0, $$sum3$i = 0, $$sum3$i27 = 0;
 var $$sum30$i$i = 0, $$sum3132$i$i = 0, $$sum34$i$i = 0, $$sum3536$i$i = 0, $$sum3738$i$i = 0, $$sum39$i$i = 0, $$sum4 = 0, $$sum4$i = 0, $$sum4$i$i = 0, $$sum4$i28 = 0, $$sum40$i$i = 0, $$sum41$i$i = 0, $$sum42$i$i = 0, $$sum5$i = 0, $$sum5$i$i = 0, $$sum56 = 0, $$sum6$i = 0, $$sum67$i$i = 0, $$sum7$i = 0, $$sum8$i = 0;
 var $$sum9 = 0, $$sum9$i = 0, $$sum9$i$i = 0, $$tsize$1$i = 0, $$v$0$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $1000 = 0, $1001 = 0, $1002 = 0, $1003 = 0, $1004 = 0, $1005 = 0, $1006 = 0, $1007 = 0, $1008 = 0, $1009 = 0, $101 = 0;
 var $1010 = 0, $1011 = 0, $1012 = 0, $1013 = 0, $1014 = 0, $1015 = 0, $1016 = 0, $1017 = 0, $1018 = 0, $1019 = 0, $102 = 0, $1020 = 0, $1021 = 0, $1022 = 0, $1023 = 0, $1024 = 0, $1025 = 0, $1026 = 0, $1027 = 0, $1028 = 0;
 var $1029 = 0, $103 = 0, $1030 = 0, $1031 = 0, $1032 = 0, $1033 = 0, $1034 = 0, $1035 = 0, $1036 = 0, $1037 = 0, $1038 = 0, $1039 = 0, $104 = 0, $1040 = 0, $1041 = 0, $1042 = 0, $1043 = 0, $1044 = 0, $1045 = 0, $1046 = 0;
 var $1047 = 0, $1048 = 0, $1049 = 0, $105 = 0, $1050 = 0, $1051 = 0, $1052 = 0, $1053 = 0, $1054 = 0, $1055 = 0, $1056 = 0, $1057 = 0, $1058 = 0, $1059 = 0, $106 = 0, $1060 = 0, $1061 = 0, $1062 = 0, $1063 = 0, $1064 = 0;
 var $1065 = 0, $1066 = 0, $1067 = 0, $1068 = 0, $1069 = 0, $107 = 0, $1070 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0;
 var $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0;
 var $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0;
 var $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0;
 var $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0;
 var $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0;
 var $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0;
 var $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0;
 var $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0;
 var $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0;
 var $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0;
 var $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0;
 var $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0;
 var $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0;
 var $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0;
 var $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0;
 var $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0;
 var $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0;
 var $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0, $432 = 0, $433 = 0, $434 = 0, $435 = 0, $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0;
 var $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0, $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0;
 var $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $469 = 0, $47 = 0, $470 = 0, $471 = 0, $472 = 0, $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0;
 var $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0, $486 = 0, $487 = 0, $488 = 0, $489 = 0, $49 = 0, $490 = 0, $491 = 0, $492 = 0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0;
 var $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $502 = 0, $503 = 0, $504 = 0, $505 = 0, $506 = 0, $507 = 0, $508 = 0, $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $514 = 0, $515 = 0;
 var $516 = 0, $517 = 0, $518 = 0, $519 = 0, $52 = 0, $520 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0, $525 = 0, $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0;
 var $534 = 0, $535 = 0, $536 = 0, $537 = 0, $538 = 0, $539 = 0, $54 = 0, $540 = 0, $541 = 0, $542 = 0, $543 = 0, $544 = 0, $545 = 0, $546 = 0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0;
 var $552 = 0, $553 = 0, $554 = 0, $555 = 0, $556 = 0, $557 = 0, $558 = 0, $559 = 0, $56 = 0, $560 = 0, $561 = 0, $562 = 0, $563 = 0, $564 = 0, $565 = 0, $566 = 0, $567 = 0, $568 = 0, $569 = 0, $57 = 0;
 var $570 = 0, $571 = 0, $572 = 0, $573 = 0, $574 = 0, $575 = 0, $576 = 0, $577 = 0, $578 = 0, $579 = 0, $58 = 0, $580 = 0, $581 = 0, $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0, $587 = 0, $588 = 0;
 var $589 = 0, $59 = 0, $590 = 0, $591 = 0, $592 = 0, $593 = 0, $594 = 0, $595 = 0, $596 = 0, $597 = 0, $598 = 0, $599 = 0, $6 = 0, $60 = 0, $600 = 0, $601 = 0, $602 = 0, $603 = 0, $604 = 0, $605 = 0;
 var $606 = 0, $607 = 0, $608 = 0, $609 = 0, $61 = 0, $610 = 0, $611 = 0, $612 = 0, $613 = 0, $614 = 0, $615 = 0, $616 = 0, $617 = 0, $618 = 0, $619 = 0, $62 = 0, $620 = 0, $621 = 0, $622 = 0, $623 = 0;
 var $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0, $629 = 0, $63 = 0, $630 = 0, $631 = 0, $632 = 0, $633 = 0, $634 = 0, $635 = 0, $636 = 0, $637 = 0, $638 = 0, $639 = 0, $64 = 0, $640 = 0, $641 = 0;
 var $642 = 0, $643 = 0, $644 = 0, $645 = 0, $646 = 0, $647 = 0, $648 = 0, $649 = 0, $65 = 0, $650 = 0, $651 = 0, $652 = 0, $653 = 0, $654 = 0, $655 = 0, $656 = 0, $657 = 0, $658 = 0, $659 = 0, $66 = 0;
 var $660 = 0, $661 = 0, $662 = 0, $663 = 0, $664 = 0, $665 = 0, $666 = 0, $667 = 0, $668 = 0, $669 = 0, $67 = 0, $670 = 0, $671 = 0, $672 = 0, $673 = 0, $674 = 0, $675 = 0, $676 = 0, $677 = 0, $678 = 0;
 var $679 = 0, $68 = 0, $680 = 0, $681 = 0, $682 = 0, $683 = 0, $684 = 0, $685 = 0, $686 = 0, $687 = 0, $688 = 0, $689 = 0, $69 = 0, $690 = 0, $691 = 0, $692 = 0, $693 = 0, $694 = 0, $695 = 0, $696 = 0;
 var $697 = 0, $698 = 0, $699 = 0, $7 = 0, $70 = 0, $700 = 0, $701 = 0, $702 = 0, $703 = 0, $704 = 0, $705 = 0, $706 = 0, $707 = 0, $708 = 0, $709 = 0, $71 = 0, $710 = 0, $711 = 0, $712 = 0, $713 = 0;
 var $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $72 = 0, $720 = 0, $721 = 0, $722 = 0, $723 = 0, $724 = 0, $725 = 0, $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0, $730 = 0, $731 = 0;
 var $732 = 0, $733 = 0, $734 = 0, $735 = 0, $736 = 0, $737 = 0, $738 = 0, $739 = 0, $74 = 0, $740 = 0, $741 = 0, $742 = 0, $743 = 0, $744 = 0, $745 = 0, $746 = 0, $747 = 0, $748 = 0, $749 = 0, $75 = 0;
 var $750 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0, $755 = 0, $756 = 0, $757 = 0, $758 = 0, $759 = 0, $76 = 0, $760 = 0, $761 = 0, $762 = 0, $763 = 0, $764 = 0, $765 = 0, $766 = 0, $767 = 0, $768 = 0;
 var $769 = 0, $77 = 0, $770 = 0, $771 = 0, $772 = 0, $773 = 0, $774 = 0, $775 = 0, $776 = 0, $777 = 0, $778 = 0, $779 = 0, $78 = 0, $780 = 0, $781 = 0, $782 = 0, $783 = 0, $784 = 0, $785 = 0, $786 = 0;
 var $787 = 0, $788 = 0, $789 = 0, $79 = 0, $790 = 0, $791 = 0, $792 = 0, $793 = 0, $794 = 0, $795 = 0, $796 = 0, $797 = 0, $798 = 0, $799 = 0, $8 = 0, $80 = 0, $800 = 0, $801 = 0, $802 = 0, $803 = 0;
 var $804 = 0, $805 = 0, $806 = 0, $807 = 0, $808 = 0, $809 = 0, $81 = 0, $810 = 0, $811 = 0, $812 = 0, $813 = 0, $814 = 0, $815 = 0, $816 = 0, $817 = 0, $818 = 0, $819 = 0, $82 = 0, $820 = 0, $821 = 0;
 var $822 = 0, $823 = 0, $824 = 0, $825 = 0, $826 = 0, $827 = 0, $828 = 0, $829 = 0, $83 = 0, $830 = 0, $831 = 0, $832 = 0, $833 = 0, $834 = 0, $835 = 0, $836 = 0, $837 = 0, $838 = 0, $839 = 0, $84 = 0;
 var $840 = 0, $841 = 0, $842 = 0, $843 = 0, $844 = 0, $845 = 0, $846 = 0, $847 = 0, $848 = 0, $849 = 0, $85 = 0, $850 = 0, $851 = 0, $852 = 0, $853 = 0, $854 = 0, $855 = 0, $856 = 0, $857 = 0, $858 = 0;
 var $859 = 0, $86 = 0, $860 = 0, $861 = 0, $862 = 0, $863 = 0, $864 = 0, $865 = 0, $866 = 0, $867 = 0, $868 = 0, $869 = 0, $87 = 0, $870 = 0, $871 = 0, $872 = 0, $873 = 0, $874 = 0, $875 = 0, $876 = 0;
 var $877 = 0, $878 = 0, $879 = 0, $88 = 0, $880 = 0, $881 = 0, $882 = 0, $883 = 0, $884 = 0, $885 = 0, $886 = 0, $887 = 0, $888 = 0, $889 = 0, $89 = 0, $890 = 0, $891 = 0, $892 = 0, $893 = 0, $894 = 0;
 var $895 = 0, $896 = 0, $897 = 0, $898 = 0, $899 = 0, $9 = 0, $90 = 0, $900 = 0, $901 = 0, $902 = 0, $903 = 0, $904 = 0, $905 = 0, $906 = 0, $907 = 0, $908 = 0, $909 = 0, $91 = 0, $910 = 0, $911 = 0;
 var $912 = 0, $913 = 0, $914 = 0, $915 = 0, $916 = 0, $917 = 0, $918 = 0, $919 = 0, $92 = 0, $920 = 0, $921 = 0, $922 = 0, $923 = 0, $924 = 0, $925 = 0, $926 = 0, $927 = 0, $928 = 0, $929 = 0, $93 = 0;
 var $930 = 0, $931 = 0, $932 = 0, $933 = 0, $934 = 0, $935 = 0, $936 = 0, $937 = 0, $938 = 0, $939 = 0, $94 = 0, $940 = 0, $941 = 0, $942 = 0, $943 = 0, $944 = 0, $945 = 0, $946 = 0, $947 = 0, $948 = 0;
 var $949 = 0, $95 = 0, $950 = 0, $951 = 0, $952 = 0, $953 = 0, $954 = 0, $955 = 0, $956 = 0, $957 = 0, $958 = 0, $959 = 0, $96 = 0, $960 = 0, $961 = 0, $962 = 0, $963 = 0, $964 = 0, $965 = 0, $966 = 0;
 var $967 = 0, $968 = 0, $969 = 0, $97 = 0, $970 = 0, $971 = 0, $972 = 0, $973 = 0, $974 = 0, $975 = 0, $976 = 0, $977 = 0, $978 = 0, $979 = 0, $98 = 0, $980 = 0, $981 = 0, $982 = 0, $983 = 0, $984 = 0;
 var $985 = 0, $986 = 0, $987 = 0, $988 = 0, $989 = 0, $99 = 0, $990 = 0, $991 = 0, $992 = 0, $993 = 0, $994 = 0, $995 = 0, $996 = 0, $997 = 0, $998 = 0, $999 = 0, $F$0$i$i = 0, $F1$0$i = 0, $F4$0 = 0, $F4$0$i$i = 0;
 var $F5$0$i = 0, $I1$0$i$i = 0, $I7$0$i = 0, $I7$0$i$i = 0, $K12$029$i = 0, $K2$07$i$i = 0, $K8$051$i$i = 0, $R$0$i = 0, $R$0$i$i = 0, $R$0$i$i$lcssa = 0, $R$0$i$lcssa = 0, $R$0$i18 = 0, $R$0$i18$lcssa = 0, $R$1$i = 0, $R$1$i$i = 0, $R$1$i20 = 0, $RP$0$i = 0, $RP$0$i$i = 0, $RP$0$i$i$lcssa = 0, $RP$0$i$lcssa = 0;
 var $RP$0$i17 = 0, $RP$0$i17$lcssa = 0, $T$0$lcssa$i = 0, $T$0$lcssa$i$i = 0, $T$0$lcssa$i25$i = 0, $T$028$i = 0, $T$028$i$lcssa = 0, $T$050$i$i = 0, $T$050$i$i$lcssa = 0, $T$06$i$i = 0, $T$06$i$i$lcssa = 0, $br$0$ph$i = 0, $cond$i = 0, $cond$i$i = 0, $cond$i21 = 0, $exitcond$i$i = 0, $i$02$i$i = 0, $idx$0$i = 0, $mem$0 = 0, $nb$0 = 0;
 var $not$$i = 0, $not$$i$i = 0, $not$$i26$i = 0, $oldfirst$0$i$i = 0, $or$cond$i = 0, $or$cond$i30 = 0, $or$cond1$i = 0, $or$cond19$i = 0, $or$cond2$i = 0, $or$cond3$i = 0, $or$cond5$i = 0, $or$cond57$i = 0, $or$cond6$i = 0, $or$cond8$i = 0, $or$cond9$i = 0, $qsize$0$i$i = 0, $rsize$0$i = 0, $rsize$0$i$lcssa = 0, $rsize$0$i15 = 0, $rsize$1$i = 0;
 var $rsize$2$i = 0, $rsize$3$lcssa$i = 0, $rsize$331$i = 0, $rst$0$i = 0, $rst$1$i = 0, $sizebits$0$i = 0, $sp$0$i$i = 0, $sp$0$i$i$i = 0, $sp$084$i = 0, $sp$084$i$lcssa = 0, $sp$183$i = 0, $sp$183$i$lcssa = 0, $ssize$0$$i = 0, $ssize$0$i = 0, $ssize$1$ph$i = 0, $ssize$2$i = 0, $t$0$i = 0, $t$0$i14 = 0, $t$1$i = 0, $t$2$ph$i = 0;
 var $t$2$v$3$i = 0, $t$230$i = 0, $tbase$255$i = 0, $tsize$0$ph$i = 0, $tsize$0323944$i = 0, $tsize$1$i = 0, $tsize$254$i = 0, $v$0$i = 0, $v$0$i$lcssa = 0, $v$0$i16 = 0, $v$1$i = 0, $v$2$i = 0, $v$3$lcssa$i = 0, $v$3$ph$i = 0, $v$332$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($bytes>>>0)<(245);
 do {
  if ($0) {
   $1 = ($bytes>>>0)<(11);
   $2 = (($bytes) + 11)|0;
   $3 = $2 & -8;
   $4 = $1 ? 16 : $3;
   $5 = $4 >>> 3;
   $6 = HEAP32[96488>>2]|0;
   $7 = $6 >>> $5;
   $8 = $7 & 3;
   $9 = ($8|0)==(0);
   if (!($9)) {
    $10 = $7 & 1;
    $11 = $10 ^ 1;
    $12 = (($11) + ($5))|0;
    $13 = $12 << 1;
    $14 = (96528 + ($13<<2)|0);
    $$sum10 = (($13) + 2)|0;
    $15 = (96528 + ($$sum10<<2)|0);
    $16 = HEAP32[$15>>2]|0;
    $17 = ((($16)) + 8|0);
    $18 = HEAP32[$17>>2]|0;
    $19 = ($14|0)==($18|0);
    do {
     if ($19) {
      $20 = 1 << $12;
      $21 = $20 ^ -1;
      $22 = $6 & $21;
      HEAP32[96488>>2] = $22;
     } else {
      $23 = HEAP32[(96504)>>2]|0;
      $24 = ($18>>>0)<($23>>>0);
      if ($24) {
       _abort();
       // unreachable;
      }
      $25 = ((($18)) + 12|0);
      $26 = HEAP32[$25>>2]|0;
      $27 = ($26|0)==($16|0);
      if ($27) {
       HEAP32[$25>>2] = $14;
       HEAP32[$15>>2] = $18;
       break;
      } else {
       _abort();
       // unreachable;
      }
     }
    } while(0);
    $28 = $12 << 3;
    $29 = $28 | 3;
    $30 = ((($16)) + 4|0);
    HEAP32[$30>>2] = $29;
    $$sum1112 = $28 | 4;
    $31 = (($16) + ($$sum1112)|0);
    $32 = HEAP32[$31>>2]|0;
    $33 = $32 | 1;
    HEAP32[$31>>2] = $33;
    $mem$0 = $17;
    return ($mem$0|0);
   }
   $34 = HEAP32[(96496)>>2]|0;
   $35 = ($4>>>0)>($34>>>0);
   if ($35) {
    $36 = ($7|0)==(0);
    if (!($36)) {
     $37 = $7 << $5;
     $38 = 2 << $5;
     $39 = (0 - ($38))|0;
     $40 = $38 | $39;
     $41 = $37 & $40;
     $42 = (0 - ($41))|0;
     $43 = $41 & $42;
     $44 = (($43) + -1)|0;
     $45 = $44 >>> 12;
     $46 = $45 & 16;
     $47 = $44 >>> $46;
     $48 = $47 >>> 5;
     $49 = $48 & 8;
     $50 = $49 | $46;
     $51 = $47 >>> $49;
     $52 = $51 >>> 2;
     $53 = $52 & 4;
     $54 = $50 | $53;
     $55 = $51 >>> $53;
     $56 = $55 >>> 1;
     $57 = $56 & 2;
     $58 = $54 | $57;
     $59 = $55 >>> $57;
     $60 = $59 >>> 1;
     $61 = $60 & 1;
     $62 = $58 | $61;
     $63 = $59 >>> $61;
     $64 = (($62) + ($63))|0;
     $65 = $64 << 1;
     $66 = (96528 + ($65<<2)|0);
     $$sum4 = (($65) + 2)|0;
     $67 = (96528 + ($$sum4<<2)|0);
     $68 = HEAP32[$67>>2]|0;
     $69 = ((($68)) + 8|0);
     $70 = HEAP32[$69>>2]|0;
     $71 = ($66|0)==($70|0);
     do {
      if ($71) {
       $72 = 1 << $64;
       $73 = $72 ^ -1;
       $74 = $6 & $73;
       HEAP32[96488>>2] = $74;
       $88 = $34;
      } else {
       $75 = HEAP32[(96504)>>2]|0;
       $76 = ($70>>>0)<($75>>>0);
       if ($76) {
        _abort();
        // unreachable;
       }
       $77 = ((($70)) + 12|0);
       $78 = HEAP32[$77>>2]|0;
       $79 = ($78|0)==($68|0);
       if ($79) {
        HEAP32[$77>>2] = $66;
        HEAP32[$67>>2] = $70;
        $$pre = HEAP32[(96496)>>2]|0;
        $88 = $$pre;
        break;
       } else {
        _abort();
        // unreachable;
       }
      }
     } while(0);
     $80 = $64 << 3;
     $81 = (($80) - ($4))|0;
     $82 = $4 | 3;
     $83 = ((($68)) + 4|0);
     HEAP32[$83>>2] = $82;
     $84 = (($68) + ($4)|0);
     $85 = $81 | 1;
     $$sum56 = $4 | 4;
     $86 = (($68) + ($$sum56)|0);
     HEAP32[$86>>2] = $85;
     $87 = (($68) + ($80)|0);
     HEAP32[$87>>2] = $81;
     $89 = ($88|0)==(0);
     if (!($89)) {
      $90 = HEAP32[(96508)>>2]|0;
      $91 = $88 >>> 3;
      $92 = $91 << 1;
      $93 = (96528 + ($92<<2)|0);
      $94 = HEAP32[96488>>2]|0;
      $95 = 1 << $91;
      $96 = $94 & $95;
      $97 = ($96|0)==(0);
      if ($97) {
       $98 = $94 | $95;
       HEAP32[96488>>2] = $98;
       $$pre105 = (($92) + 2)|0;
       $$pre106 = (96528 + ($$pre105<<2)|0);
       $$pre$phiZ2D = $$pre106;$F4$0 = $93;
      } else {
       $$sum9 = (($92) + 2)|0;
       $99 = (96528 + ($$sum9<<2)|0);
       $100 = HEAP32[$99>>2]|0;
       $101 = HEAP32[(96504)>>2]|0;
       $102 = ($100>>>0)<($101>>>0);
       if ($102) {
        _abort();
        // unreachable;
       } else {
        $$pre$phiZ2D = $99;$F4$0 = $100;
       }
      }
      HEAP32[$$pre$phiZ2D>>2] = $90;
      $103 = ((($F4$0)) + 12|0);
      HEAP32[$103>>2] = $90;
      $104 = ((($90)) + 8|0);
      HEAP32[$104>>2] = $F4$0;
      $105 = ((($90)) + 12|0);
      HEAP32[$105>>2] = $93;
     }
     HEAP32[(96496)>>2] = $81;
     HEAP32[(96508)>>2] = $84;
     $mem$0 = $69;
     return ($mem$0|0);
    }
    $106 = HEAP32[(96492)>>2]|0;
    $107 = ($106|0)==(0);
    if ($107) {
     $nb$0 = $4;
    } else {
     $108 = (0 - ($106))|0;
     $109 = $106 & $108;
     $110 = (($109) + -1)|0;
     $111 = $110 >>> 12;
     $112 = $111 & 16;
     $113 = $110 >>> $112;
     $114 = $113 >>> 5;
     $115 = $114 & 8;
     $116 = $115 | $112;
     $117 = $113 >>> $115;
     $118 = $117 >>> 2;
     $119 = $118 & 4;
     $120 = $116 | $119;
     $121 = $117 >>> $119;
     $122 = $121 >>> 1;
     $123 = $122 & 2;
     $124 = $120 | $123;
     $125 = $121 >>> $123;
     $126 = $125 >>> 1;
     $127 = $126 & 1;
     $128 = $124 | $127;
     $129 = $125 >>> $127;
     $130 = (($128) + ($129))|0;
     $131 = (96792 + ($130<<2)|0);
     $132 = HEAP32[$131>>2]|0;
     $133 = ((($132)) + 4|0);
     $134 = HEAP32[$133>>2]|0;
     $135 = $134 & -8;
     $136 = (($135) - ($4))|0;
     $rsize$0$i = $136;$t$0$i = $132;$v$0$i = $132;
     while(1) {
      $137 = ((($t$0$i)) + 16|0);
      $138 = HEAP32[$137>>2]|0;
      $139 = ($138|0)==(0|0);
      if ($139) {
       $140 = ((($t$0$i)) + 20|0);
       $141 = HEAP32[$140>>2]|0;
       $142 = ($141|0)==(0|0);
       if ($142) {
        $rsize$0$i$lcssa = $rsize$0$i;$v$0$i$lcssa = $v$0$i;
        break;
       } else {
        $144 = $141;
       }
      } else {
       $144 = $138;
      }
      $143 = ((($144)) + 4|0);
      $145 = HEAP32[$143>>2]|0;
      $146 = $145 & -8;
      $147 = (($146) - ($4))|0;
      $148 = ($147>>>0)<($rsize$0$i>>>0);
      $$rsize$0$i = $148 ? $147 : $rsize$0$i;
      $$v$0$i = $148 ? $144 : $v$0$i;
      $rsize$0$i = $$rsize$0$i;$t$0$i = $144;$v$0$i = $$v$0$i;
     }
     $149 = HEAP32[(96504)>>2]|0;
     $150 = ($v$0$i$lcssa>>>0)<($149>>>0);
     if ($150) {
      _abort();
      // unreachable;
     }
     $151 = (($v$0$i$lcssa) + ($4)|0);
     $152 = ($v$0$i$lcssa>>>0)<($151>>>0);
     if (!($152)) {
      _abort();
      // unreachable;
     }
     $153 = ((($v$0$i$lcssa)) + 24|0);
     $154 = HEAP32[$153>>2]|0;
     $155 = ((($v$0$i$lcssa)) + 12|0);
     $156 = HEAP32[$155>>2]|0;
     $157 = ($156|0)==($v$0$i$lcssa|0);
     do {
      if ($157) {
       $167 = ((($v$0$i$lcssa)) + 20|0);
       $168 = HEAP32[$167>>2]|0;
       $169 = ($168|0)==(0|0);
       if ($169) {
        $170 = ((($v$0$i$lcssa)) + 16|0);
        $171 = HEAP32[$170>>2]|0;
        $172 = ($171|0)==(0|0);
        if ($172) {
         $R$1$i = 0;
         break;
        } else {
         $R$0$i = $171;$RP$0$i = $170;
        }
       } else {
        $R$0$i = $168;$RP$0$i = $167;
       }
       while(1) {
        $173 = ((($R$0$i)) + 20|0);
        $174 = HEAP32[$173>>2]|0;
        $175 = ($174|0)==(0|0);
        if (!($175)) {
         $R$0$i = $174;$RP$0$i = $173;
         continue;
        }
        $176 = ((($R$0$i)) + 16|0);
        $177 = HEAP32[$176>>2]|0;
        $178 = ($177|0)==(0|0);
        if ($178) {
         $R$0$i$lcssa = $R$0$i;$RP$0$i$lcssa = $RP$0$i;
         break;
        } else {
         $R$0$i = $177;$RP$0$i = $176;
        }
       }
       $179 = ($RP$0$i$lcssa>>>0)<($149>>>0);
       if ($179) {
        _abort();
        // unreachable;
       } else {
        HEAP32[$RP$0$i$lcssa>>2] = 0;
        $R$1$i = $R$0$i$lcssa;
        break;
       }
      } else {
       $158 = ((($v$0$i$lcssa)) + 8|0);
       $159 = HEAP32[$158>>2]|0;
       $160 = ($159>>>0)<($149>>>0);
       if ($160) {
        _abort();
        // unreachable;
       }
       $161 = ((($159)) + 12|0);
       $162 = HEAP32[$161>>2]|0;
       $163 = ($162|0)==($v$0$i$lcssa|0);
       if (!($163)) {
        _abort();
        // unreachable;
       }
       $164 = ((($156)) + 8|0);
       $165 = HEAP32[$164>>2]|0;
       $166 = ($165|0)==($v$0$i$lcssa|0);
       if ($166) {
        HEAP32[$161>>2] = $156;
        HEAP32[$164>>2] = $159;
        $R$1$i = $156;
        break;
       } else {
        _abort();
        // unreachable;
       }
      }
     } while(0);
     $180 = ($154|0)==(0|0);
     do {
      if (!($180)) {
       $181 = ((($v$0$i$lcssa)) + 28|0);
       $182 = HEAP32[$181>>2]|0;
       $183 = (96792 + ($182<<2)|0);
       $184 = HEAP32[$183>>2]|0;
       $185 = ($v$0$i$lcssa|0)==($184|0);
       if ($185) {
        HEAP32[$183>>2] = $R$1$i;
        $cond$i = ($R$1$i|0)==(0|0);
        if ($cond$i) {
         $186 = 1 << $182;
         $187 = $186 ^ -1;
         $188 = HEAP32[(96492)>>2]|0;
         $189 = $188 & $187;
         HEAP32[(96492)>>2] = $189;
         break;
        }
       } else {
        $190 = HEAP32[(96504)>>2]|0;
        $191 = ($154>>>0)<($190>>>0);
        if ($191) {
         _abort();
         // unreachable;
        }
        $192 = ((($154)) + 16|0);
        $193 = HEAP32[$192>>2]|0;
        $194 = ($193|0)==($v$0$i$lcssa|0);
        if ($194) {
         HEAP32[$192>>2] = $R$1$i;
        } else {
         $195 = ((($154)) + 20|0);
         HEAP32[$195>>2] = $R$1$i;
        }
        $196 = ($R$1$i|0)==(0|0);
        if ($196) {
         break;
        }
       }
       $197 = HEAP32[(96504)>>2]|0;
       $198 = ($R$1$i>>>0)<($197>>>0);
       if ($198) {
        _abort();
        // unreachable;
       }
       $199 = ((($R$1$i)) + 24|0);
       HEAP32[$199>>2] = $154;
       $200 = ((($v$0$i$lcssa)) + 16|0);
       $201 = HEAP32[$200>>2]|0;
       $202 = ($201|0)==(0|0);
       do {
        if (!($202)) {
         $203 = ($201>>>0)<($197>>>0);
         if ($203) {
          _abort();
          // unreachable;
         } else {
          $204 = ((($R$1$i)) + 16|0);
          HEAP32[$204>>2] = $201;
          $205 = ((($201)) + 24|0);
          HEAP32[$205>>2] = $R$1$i;
          break;
         }
        }
       } while(0);
       $206 = ((($v$0$i$lcssa)) + 20|0);
       $207 = HEAP32[$206>>2]|0;
       $208 = ($207|0)==(0|0);
       if (!($208)) {
        $209 = HEAP32[(96504)>>2]|0;
        $210 = ($207>>>0)<($209>>>0);
        if ($210) {
         _abort();
         // unreachable;
        } else {
         $211 = ((($R$1$i)) + 20|0);
         HEAP32[$211>>2] = $207;
         $212 = ((($207)) + 24|0);
         HEAP32[$212>>2] = $R$1$i;
         break;
        }
       }
      }
     } while(0);
     $213 = ($rsize$0$i$lcssa>>>0)<(16);
     if ($213) {
      $214 = (($rsize$0$i$lcssa) + ($4))|0;
      $215 = $214 | 3;
      $216 = ((($v$0$i$lcssa)) + 4|0);
      HEAP32[$216>>2] = $215;
      $$sum4$i = (($214) + 4)|0;
      $217 = (($v$0$i$lcssa) + ($$sum4$i)|0);
      $218 = HEAP32[$217>>2]|0;
      $219 = $218 | 1;
      HEAP32[$217>>2] = $219;
     } else {
      $220 = $4 | 3;
      $221 = ((($v$0$i$lcssa)) + 4|0);
      HEAP32[$221>>2] = $220;
      $222 = $rsize$0$i$lcssa | 1;
      $$sum$i35 = $4 | 4;
      $223 = (($v$0$i$lcssa) + ($$sum$i35)|0);
      HEAP32[$223>>2] = $222;
      $$sum1$i = (($rsize$0$i$lcssa) + ($4))|0;
      $224 = (($v$0$i$lcssa) + ($$sum1$i)|0);
      HEAP32[$224>>2] = $rsize$0$i$lcssa;
      $225 = HEAP32[(96496)>>2]|0;
      $226 = ($225|0)==(0);
      if (!($226)) {
       $227 = HEAP32[(96508)>>2]|0;
       $228 = $225 >>> 3;
       $229 = $228 << 1;
       $230 = (96528 + ($229<<2)|0);
       $231 = HEAP32[96488>>2]|0;
       $232 = 1 << $228;
       $233 = $231 & $232;
       $234 = ($233|0)==(0);
       if ($234) {
        $235 = $231 | $232;
        HEAP32[96488>>2] = $235;
        $$pre$i = (($229) + 2)|0;
        $$pre8$i = (96528 + ($$pre$i<<2)|0);
        $$pre$phi$iZ2D = $$pre8$i;$F1$0$i = $230;
       } else {
        $$sum3$i = (($229) + 2)|0;
        $236 = (96528 + ($$sum3$i<<2)|0);
        $237 = HEAP32[$236>>2]|0;
        $238 = HEAP32[(96504)>>2]|0;
        $239 = ($237>>>0)<($238>>>0);
        if ($239) {
         _abort();
         // unreachable;
        } else {
         $$pre$phi$iZ2D = $236;$F1$0$i = $237;
        }
       }
       HEAP32[$$pre$phi$iZ2D>>2] = $227;
       $240 = ((($F1$0$i)) + 12|0);
       HEAP32[$240>>2] = $227;
       $241 = ((($227)) + 8|0);
       HEAP32[$241>>2] = $F1$0$i;
       $242 = ((($227)) + 12|0);
       HEAP32[$242>>2] = $230;
      }
      HEAP32[(96496)>>2] = $rsize$0$i$lcssa;
      HEAP32[(96508)>>2] = $151;
     }
     $243 = ((($v$0$i$lcssa)) + 8|0);
     $mem$0 = $243;
     return ($mem$0|0);
    }
   } else {
    $nb$0 = $4;
   }
  } else {
   $244 = ($bytes>>>0)>(4294967231);
   if ($244) {
    $nb$0 = -1;
   } else {
    $245 = (($bytes) + 11)|0;
    $246 = $245 & -8;
    $247 = HEAP32[(96492)>>2]|0;
    $248 = ($247|0)==(0);
    if ($248) {
     $nb$0 = $246;
    } else {
     $249 = (0 - ($246))|0;
     $250 = $245 >>> 8;
     $251 = ($250|0)==(0);
     if ($251) {
      $idx$0$i = 0;
     } else {
      $252 = ($246>>>0)>(16777215);
      if ($252) {
       $idx$0$i = 31;
      } else {
       $253 = (($250) + 1048320)|0;
       $254 = $253 >>> 16;
       $255 = $254 & 8;
       $256 = $250 << $255;
       $257 = (($256) + 520192)|0;
       $258 = $257 >>> 16;
       $259 = $258 & 4;
       $260 = $259 | $255;
       $261 = $256 << $259;
       $262 = (($261) + 245760)|0;
       $263 = $262 >>> 16;
       $264 = $263 & 2;
       $265 = $260 | $264;
       $266 = (14 - ($265))|0;
       $267 = $261 << $264;
       $268 = $267 >>> 15;
       $269 = (($266) + ($268))|0;
       $270 = $269 << 1;
       $271 = (($269) + 7)|0;
       $272 = $246 >>> $271;
       $273 = $272 & 1;
       $274 = $273 | $270;
       $idx$0$i = $274;
      }
     }
     $275 = (96792 + ($idx$0$i<<2)|0);
     $276 = HEAP32[$275>>2]|0;
     $277 = ($276|0)==(0|0);
     L123: do {
      if ($277) {
       $rsize$2$i = $249;$t$1$i = 0;$v$2$i = 0;
       label = 86;
      } else {
       $278 = ($idx$0$i|0)==(31);
       $279 = $idx$0$i >>> 1;
       $280 = (25 - ($279))|0;
       $281 = $278 ? 0 : $280;
       $282 = $246 << $281;
       $rsize$0$i15 = $249;$rst$0$i = 0;$sizebits$0$i = $282;$t$0$i14 = $276;$v$0$i16 = 0;
       while(1) {
        $283 = ((($t$0$i14)) + 4|0);
        $284 = HEAP32[$283>>2]|0;
        $285 = $284 & -8;
        $286 = (($285) - ($246))|0;
        $287 = ($286>>>0)<($rsize$0$i15>>>0);
        if ($287) {
         $288 = ($285|0)==($246|0);
         if ($288) {
          $rsize$331$i = $286;$t$230$i = $t$0$i14;$v$332$i = $t$0$i14;
          label = 90;
          break L123;
         } else {
          $rsize$1$i = $286;$v$1$i = $t$0$i14;
         }
        } else {
         $rsize$1$i = $rsize$0$i15;$v$1$i = $v$0$i16;
        }
        $289 = ((($t$0$i14)) + 20|0);
        $290 = HEAP32[$289>>2]|0;
        $291 = $sizebits$0$i >>> 31;
        $292 = (((($t$0$i14)) + 16|0) + ($291<<2)|0);
        $293 = HEAP32[$292>>2]|0;
        $294 = ($290|0)==(0|0);
        $295 = ($290|0)==($293|0);
        $or$cond19$i = $294 | $295;
        $rst$1$i = $or$cond19$i ? $rst$0$i : $290;
        $296 = ($293|0)==(0|0);
        $297 = $sizebits$0$i << 1;
        if ($296) {
         $rsize$2$i = $rsize$1$i;$t$1$i = $rst$1$i;$v$2$i = $v$1$i;
         label = 86;
         break;
        } else {
         $rsize$0$i15 = $rsize$1$i;$rst$0$i = $rst$1$i;$sizebits$0$i = $297;$t$0$i14 = $293;$v$0$i16 = $v$1$i;
        }
       }
      }
     } while(0);
     if ((label|0) == 86) {
      $298 = ($t$1$i|0)==(0|0);
      $299 = ($v$2$i|0)==(0|0);
      $or$cond$i = $298 & $299;
      if ($or$cond$i) {
       $300 = 2 << $idx$0$i;
       $301 = (0 - ($300))|0;
       $302 = $300 | $301;
       $303 = $247 & $302;
       $304 = ($303|0)==(0);
       if ($304) {
        $nb$0 = $246;
        break;
       }
       $305 = (0 - ($303))|0;
       $306 = $303 & $305;
       $307 = (($306) + -1)|0;
       $308 = $307 >>> 12;
       $309 = $308 & 16;
       $310 = $307 >>> $309;
       $311 = $310 >>> 5;
       $312 = $311 & 8;
       $313 = $312 | $309;
       $314 = $310 >>> $312;
       $315 = $314 >>> 2;
       $316 = $315 & 4;
       $317 = $313 | $316;
       $318 = $314 >>> $316;
       $319 = $318 >>> 1;
       $320 = $319 & 2;
       $321 = $317 | $320;
       $322 = $318 >>> $320;
       $323 = $322 >>> 1;
       $324 = $323 & 1;
       $325 = $321 | $324;
       $326 = $322 >>> $324;
       $327 = (($325) + ($326))|0;
       $328 = (96792 + ($327<<2)|0);
       $329 = HEAP32[$328>>2]|0;
       $t$2$ph$i = $329;$v$3$ph$i = 0;
      } else {
       $t$2$ph$i = $t$1$i;$v$3$ph$i = $v$2$i;
      }
      $330 = ($t$2$ph$i|0)==(0|0);
      if ($330) {
       $rsize$3$lcssa$i = $rsize$2$i;$v$3$lcssa$i = $v$3$ph$i;
      } else {
       $rsize$331$i = $rsize$2$i;$t$230$i = $t$2$ph$i;$v$332$i = $v$3$ph$i;
       label = 90;
      }
     }
     if ((label|0) == 90) {
      while(1) {
       label = 0;
       $331 = ((($t$230$i)) + 4|0);
       $332 = HEAP32[$331>>2]|0;
       $333 = $332 & -8;
       $334 = (($333) - ($246))|0;
       $335 = ($334>>>0)<($rsize$331$i>>>0);
       $$rsize$3$i = $335 ? $334 : $rsize$331$i;
       $t$2$v$3$i = $335 ? $t$230$i : $v$332$i;
       $336 = ((($t$230$i)) + 16|0);
       $337 = HEAP32[$336>>2]|0;
       $338 = ($337|0)==(0|0);
       if (!($338)) {
        $rsize$331$i = $$rsize$3$i;$t$230$i = $337;$v$332$i = $t$2$v$3$i;
        label = 90;
        continue;
       }
       $339 = ((($t$230$i)) + 20|0);
       $340 = HEAP32[$339>>2]|0;
       $341 = ($340|0)==(0|0);
       if ($341) {
        $rsize$3$lcssa$i = $$rsize$3$i;$v$3$lcssa$i = $t$2$v$3$i;
        break;
       } else {
        $rsize$331$i = $$rsize$3$i;$t$230$i = $340;$v$332$i = $t$2$v$3$i;
        label = 90;
       }
      }
     }
     $342 = ($v$3$lcssa$i|0)==(0|0);
     if ($342) {
      $nb$0 = $246;
     } else {
      $343 = HEAP32[(96496)>>2]|0;
      $344 = (($343) - ($246))|0;
      $345 = ($rsize$3$lcssa$i>>>0)<($344>>>0);
      if ($345) {
       $346 = HEAP32[(96504)>>2]|0;
       $347 = ($v$3$lcssa$i>>>0)<($346>>>0);
       if ($347) {
        _abort();
        // unreachable;
       }
       $348 = (($v$3$lcssa$i) + ($246)|0);
       $349 = ($v$3$lcssa$i>>>0)<($348>>>0);
       if (!($349)) {
        _abort();
        // unreachable;
       }
       $350 = ((($v$3$lcssa$i)) + 24|0);
       $351 = HEAP32[$350>>2]|0;
       $352 = ((($v$3$lcssa$i)) + 12|0);
       $353 = HEAP32[$352>>2]|0;
       $354 = ($353|0)==($v$3$lcssa$i|0);
       do {
        if ($354) {
         $364 = ((($v$3$lcssa$i)) + 20|0);
         $365 = HEAP32[$364>>2]|0;
         $366 = ($365|0)==(0|0);
         if ($366) {
          $367 = ((($v$3$lcssa$i)) + 16|0);
          $368 = HEAP32[$367>>2]|0;
          $369 = ($368|0)==(0|0);
          if ($369) {
           $R$1$i20 = 0;
           break;
          } else {
           $R$0$i18 = $368;$RP$0$i17 = $367;
          }
         } else {
          $R$0$i18 = $365;$RP$0$i17 = $364;
         }
         while(1) {
          $370 = ((($R$0$i18)) + 20|0);
          $371 = HEAP32[$370>>2]|0;
          $372 = ($371|0)==(0|0);
          if (!($372)) {
           $R$0$i18 = $371;$RP$0$i17 = $370;
           continue;
          }
          $373 = ((($R$0$i18)) + 16|0);
          $374 = HEAP32[$373>>2]|0;
          $375 = ($374|0)==(0|0);
          if ($375) {
           $R$0$i18$lcssa = $R$0$i18;$RP$0$i17$lcssa = $RP$0$i17;
           break;
          } else {
           $R$0$i18 = $374;$RP$0$i17 = $373;
          }
         }
         $376 = ($RP$0$i17$lcssa>>>0)<($346>>>0);
         if ($376) {
          _abort();
          // unreachable;
         } else {
          HEAP32[$RP$0$i17$lcssa>>2] = 0;
          $R$1$i20 = $R$0$i18$lcssa;
          break;
         }
        } else {
         $355 = ((($v$3$lcssa$i)) + 8|0);
         $356 = HEAP32[$355>>2]|0;
         $357 = ($356>>>0)<($346>>>0);
         if ($357) {
          _abort();
          // unreachable;
         }
         $358 = ((($356)) + 12|0);
         $359 = HEAP32[$358>>2]|0;
         $360 = ($359|0)==($v$3$lcssa$i|0);
         if (!($360)) {
          _abort();
          // unreachable;
         }
         $361 = ((($353)) + 8|0);
         $362 = HEAP32[$361>>2]|0;
         $363 = ($362|0)==($v$3$lcssa$i|0);
         if ($363) {
          HEAP32[$358>>2] = $353;
          HEAP32[$361>>2] = $356;
          $R$1$i20 = $353;
          break;
         } else {
          _abort();
          // unreachable;
         }
        }
       } while(0);
       $377 = ($351|0)==(0|0);
       do {
        if (!($377)) {
         $378 = ((($v$3$lcssa$i)) + 28|0);
         $379 = HEAP32[$378>>2]|0;
         $380 = (96792 + ($379<<2)|0);
         $381 = HEAP32[$380>>2]|0;
         $382 = ($v$3$lcssa$i|0)==($381|0);
         if ($382) {
          HEAP32[$380>>2] = $R$1$i20;
          $cond$i21 = ($R$1$i20|0)==(0|0);
          if ($cond$i21) {
           $383 = 1 << $379;
           $384 = $383 ^ -1;
           $385 = HEAP32[(96492)>>2]|0;
           $386 = $385 & $384;
           HEAP32[(96492)>>2] = $386;
           break;
          }
         } else {
          $387 = HEAP32[(96504)>>2]|0;
          $388 = ($351>>>0)<($387>>>0);
          if ($388) {
           _abort();
           // unreachable;
          }
          $389 = ((($351)) + 16|0);
          $390 = HEAP32[$389>>2]|0;
          $391 = ($390|0)==($v$3$lcssa$i|0);
          if ($391) {
           HEAP32[$389>>2] = $R$1$i20;
          } else {
           $392 = ((($351)) + 20|0);
           HEAP32[$392>>2] = $R$1$i20;
          }
          $393 = ($R$1$i20|0)==(0|0);
          if ($393) {
           break;
          }
         }
         $394 = HEAP32[(96504)>>2]|0;
         $395 = ($R$1$i20>>>0)<($394>>>0);
         if ($395) {
          _abort();
          // unreachable;
         }
         $396 = ((($R$1$i20)) + 24|0);
         HEAP32[$396>>2] = $351;
         $397 = ((($v$3$lcssa$i)) + 16|0);
         $398 = HEAP32[$397>>2]|0;
         $399 = ($398|0)==(0|0);
         do {
          if (!($399)) {
           $400 = ($398>>>0)<($394>>>0);
           if ($400) {
            _abort();
            // unreachable;
           } else {
            $401 = ((($R$1$i20)) + 16|0);
            HEAP32[$401>>2] = $398;
            $402 = ((($398)) + 24|0);
            HEAP32[$402>>2] = $R$1$i20;
            break;
           }
          }
         } while(0);
         $403 = ((($v$3$lcssa$i)) + 20|0);
         $404 = HEAP32[$403>>2]|0;
         $405 = ($404|0)==(0|0);
         if (!($405)) {
          $406 = HEAP32[(96504)>>2]|0;
          $407 = ($404>>>0)<($406>>>0);
          if ($407) {
           _abort();
           // unreachable;
          } else {
           $408 = ((($R$1$i20)) + 20|0);
           HEAP32[$408>>2] = $404;
           $409 = ((($404)) + 24|0);
           HEAP32[$409>>2] = $R$1$i20;
           break;
          }
         }
        }
       } while(0);
       $410 = ($rsize$3$lcssa$i>>>0)<(16);
       L199: do {
        if ($410) {
         $411 = (($rsize$3$lcssa$i) + ($246))|0;
         $412 = $411 | 3;
         $413 = ((($v$3$lcssa$i)) + 4|0);
         HEAP32[$413>>2] = $412;
         $$sum18$i = (($411) + 4)|0;
         $414 = (($v$3$lcssa$i) + ($$sum18$i)|0);
         $415 = HEAP32[$414>>2]|0;
         $416 = $415 | 1;
         HEAP32[$414>>2] = $416;
        } else {
         $417 = $246 | 3;
         $418 = ((($v$3$lcssa$i)) + 4|0);
         HEAP32[$418>>2] = $417;
         $419 = $rsize$3$lcssa$i | 1;
         $$sum$i2334 = $246 | 4;
         $420 = (($v$3$lcssa$i) + ($$sum$i2334)|0);
         HEAP32[$420>>2] = $419;
         $$sum1$i24 = (($rsize$3$lcssa$i) + ($246))|0;
         $421 = (($v$3$lcssa$i) + ($$sum1$i24)|0);
         HEAP32[$421>>2] = $rsize$3$lcssa$i;
         $422 = $rsize$3$lcssa$i >>> 3;
         $423 = ($rsize$3$lcssa$i>>>0)<(256);
         if ($423) {
          $424 = $422 << 1;
          $425 = (96528 + ($424<<2)|0);
          $426 = HEAP32[96488>>2]|0;
          $427 = 1 << $422;
          $428 = $426 & $427;
          $429 = ($428|0)==(0);
          if ($429) {
           $430 = $426 | $427;
           HEAP32[96488>>2] = $430;
           $$pre$i25 = (($424) + 2)|0;
           $$pre43$i = (96528 + ($$pre$i25<<2)|0);
           $$pre$phi$i26Z2D = $$pre43$i;$F5$0$i = $425;
          } else {
           $$sum17$i = (($424) + 2)|0;
           $431 = (96528 + ($$sum17$i<<2)|0);
           $432 = HEAP32[$431>>2]|0;
           $433 = HEAP32[(96504)>>2]|0;
           $434 = ($432>>>0)<($433>>>0);
           if ($434) {
            _abort();
            // unreachable;
           } else {
            $$pre$phi$i26Z2D = $431;$F5$0$i = $432;
           }
          }
          HEAP32[$$pre$phi$i26Z2D>>2] = $348;
          $435 = ((($F5$0$i)) + 12|0);
          HEAP32[$435>>2] = $348;
          $$sum15$i = (($246) + 8)|0;
          $436 = (($v$3$lcssa$i) + ($$sum15$i)|0);
          HEAP32[$436>>2] = $F5$0$i;
          $$sum16$i = (($246) + 12)|0;
          $437 = (($v$3$lcssa$i) + ($$sum16$i)|0);
          HEAP32[$437>>2] = $425;
          break;
         }
         $438 = $rsize$3$lcssa$i >>> 8;
         $439 = ($438|0)==(0);
         if ($439) {
          $I7$0$i = 0;
         } else {
          $440 = ($rsize$3$lcssa$i>>>0)>(16777215);
          if ($440) {
           $I7$0$i = 31;
          } else {
           $441 = (($438) + 1048320)|0;
           $442 = $441 >>> 16;
           $443 = $442 & 8;
           $444 = $438 << $443;
           $445 = (($444) + 520192)|0;
           $446 = $445 >>> 16;
           $447 = $446 & 4;
           $448 = $447 | $443;
           $449 = $444 << $447;
           $450 = (($449) + 245760)|0;
           $451 = $450 >>> 16;
           $452 = $451 & 2;
           $453 = $448 | $452;
           $454 = (14 - ($453))|0;
           $455 = $449 << $452;
           $456 = $455 >>> 15;
           $457 = (($454) + ($456))|0;
           $458 = $457 << 1;
           $459 = (($457) + 7)|0;
           $460 = $rsize$3$lcssa$i >>> $459;
           $461 = $460 & 1;
           $462 = $461 | $458;
           $I7$0$i = $462;
          }
         }
         $463 = (96792 + ($I7$0$i<<2)|0);
         $$sum2$i = (($246) + 28)|0;
         $464 = (($v$3$lcssa$i) + ($$sum2$i)|0);
         HEAP32[$464>>2] = $I7$0$i;
         $$sum3$i27 = (($246) + 16)|0;
         $465 = (($v$3$lcssa$i) + ($$sum3$i27)|0);
         $$sum4$i28 = (($246) + 20)|0;
         $466 = (($v$3$lcssa$i) + ($$sum4$i28)|0);
         HEAP32[$466>>2] = 0;
         HEAP32[$465>>2] = 0;
         $467 = HEAP32[(96492)>>2]|0;
         $468 = 1 << $I7$0$i;
         $469 = $467 & $468;
         $470 = ($469|0)==(0);
         if ($470) {
          $471 = $467 | $468;
          HEAP32[(96492)>>2] = $471;
          HEAP32[$463>>2] = $348;
          $$sum5$i = (($246) + 24)|0;
          $472 = (($v$3$lcssa$i) + ($$sum5$i)|0);
          HEAP32[$472>>2] = $463;
          $$sum6$i = (($246) + 12)|0;
          $473 = (($v$3$lcssa$i) + ($$sum6$i)|0);
          HEAP32[$473>>2] = $348;
          $$sum7$i = (($246) + 8)|0;
          $474 = (($v$3$lcssa$i) + ($$sum7$i)|0);
          HEAP32[$474>>2] = $348;
          break;
         }
         $475 = HEAP32[$463>>2]|0;
         $476 = ((($475)) + 4|0);
         $477 = HEAP32[$476>>2]|0;
         $478 = $477 & -8;
         $479 = ($478|0)==($rsize$3$lcssa$i|0);
         L217: do {
          if ($479) {
           $T$0$lcssa$i = $475;
          } else {
           $480 = ($I7$0$i|0)==(31);
           $481 = $I7$0$i >>> 1;
           $482 = (25 - ($481))|0;
           $483 = $480 ? 0 : $482;
           $484 = $rsize$3$lcssa$i << $483;
           $K12$029$i = $484;$T$028$i = $475;
           while(1) {
            $491 = $K12$029$i >>> 31;
            $492 = (((($T$028$i)) + 16|0) + ($491<<2)|0);
            $487 = HEAP32[$492>>2]|0;
            $493 = ($487|0)==(0|0);
            if ($493) {
             $$lcssa232 = $492;$T$028$i$lcssa = $T$028$i;
             break;
            }
            $485 = $K12$029$i << 1;
            $486 = ((($487)) + 4|0);
            $488 = HEAP32[$486>>2]|0;
            $489 = $488 & -8;
            $490 = ($489|0)==($rsize$3$lcssa$i|0);
            if ($490) {
             $T$0$lcssa$i = $487;
             break L217;
            } else {
             $K12$029$i = $485;$T$028$i = $487;
            }
           }
           $494 = HEAP32[(96504)>>2]|0;
           $495 = ($$lcssa232>>>0)<($494>>>0);
           if ($495) {
            _abort();
            // unreachable;
           } else {
            HEAP32[$$lcssa232>>2] = $348;
            $$sum11$i = (($246) + 24)|0;
            $496 = (($v$3$lcssa$i) + ($$sum11$i)|0);
            HEAP32[$496>>2] = $T$028$i$lcssa;
            $$sum12$i = (($246) + 12)|0;
            $497 = (($v$3$lcssa$i) + ($$sum12$i)|0);
            HEAP32[$497>>2] = $348;
            $$sum13$i = (($246) + 8)|0;
            $498 = (($v$3$lcssa$i) + ($$sum13$i)|0);
            HEAP32[$498>>2] = $348;
            break L199;
           }
          }
         } while(0);
         $499 = ((($T$0$lcssa$i)) + 8|0);
         $500 = HEAP32[$499>>2]|0;
         $501 = HEAP32[(96504)>>2]|0;
         $502 = ($500>>>0)>=($501>>>0);
         $not$$i = ($T$0$lcssa$i>>>0)>=($501>>>0);
         $503 = $502 & $not$$i;
         if ($503) {
          $504 = ((($500)) + 12|0);
          HEAP32[$504>>2] = $348;
          HEAP32[$499>>2] = $348;
          $$sum8$i = (($246) + 8)|0;
          $505 = (($v$3$lcssa$i) + ($$sum8$i)|0);
          HEAP32[$505>>2] = $500;
          $$sum9$i = (($246) + 12)|0;
          $506 = (($v$3$lcssa$i) + ($$sum9$i)|0);
          HEAP32[$506>>2] = $T$0$lcssa$i;
          $$sum10$i = (($246) + 24)|0;
          $507 = (($v$3$lcssa$i) + ($$sum10$i)|0);
          HEAP32[$507>>2] = 0;
          break;
         } else {
          _abort();
          // unreachable;
         }
        }
       } while(0);
       $508 = ((($v$3$lcssa$i)) + 8|0);
       $mem$0 = $508;
       return ($mem$0|0);
      } else {
       $nb$0 = $246;
      }
     }
    }
   }
  }
 } while(0);
 $509 = HEAP32[(96496)>>2]|0;
 $510 = ($509>>>0)<($nb$0>>>0);
 if (!($510)) {
  $511 = (($509) - ($nb$0))|0;
  $512 = HEAP32[(96508)>>2]|0;
  $513 = ($511>>>0)>(15);
  if ($513) {
   $514 = (($512) + ($nb$0)|0);
   HEAP32[(96508)>>2] = $514;
   HEAP32[(96496)>>2] = $511;
   $515 = $511 | 1;
   $$sum2 = (($nb$0) + 4)|0;
   $516 = (($512) + ($$sum2)|0);
   HEAP32[$516>>2] = $515;
   $517 = (($512) + ($509)|0);
   HEAP32[$517>>2] = $511;
   $518 = $nb$0 | 3;
   $519 = ((($512)) + 4|0);
   HEAP32[$519>>2] = $518;
  } else {
   HEAP32[(96496)>>2] = 0;
   HEAP32[(96508)>>2] = 0;
   $520 = $509 | 3;
   $521 = ((($512)) + 4|0);
   HEAP32[$521>>2] = $520;
   $$sum1 = (($509) + 4)|0;
   $522 = (($512) + ($$sum1)|0);
   $523 = HEAP32[$522>>2]|0;
   $524 = $523 | 1;
   HEAP32[$522>>2] = $524;
  }
  $525 = ((($512)) + 8|0);
  $mem$0 = $525;
  return ($mem$0|0);
 }
 $526 = HEAP32[(96500)>>2]|0;
 $527 = ($526>>>0)>($nb$0>>>0);
 if ($527) {
  $528 = (($526) - ($nb$0))|0;
  HEAP32[(96500)>>2] = $528;
  $529 = HEAP32[(96512)>>2]|0;
  $530 = (($529) + ($nb$0)|0);
  HEAP32[(96512)>>2] = $530;
  $531 = $528 | 1;
  $$sum = (($nb$0) + 4)|0;
  $532 = (($529) + ($$sum)|0);
  HEAP32[$532>>2] = $531;
  $533 = $nb$0 | 3;
  $534 = ((($529)) + 4|0);
  HEAP32[$534>>2] = $533;
  $535 = ((($529)) + 8|0);
  $mem$0 = $535;
  return ($mem$0|0);
 }
 $536 = HEAP32[96960>>2]|0;
 $537 = ($536|0)==(0);
 do {
  if ($537) {
   $538 = (_sysconf(30)|0);
   $539 = (($538) + -1)|0;
   $540 = $539 & $538;
   $541 = ($540|0)==(0);
   if ($541) {
    HEAP32[(96968)>>2] = $538;
    HEAP32[(96964)>>2] = $538;
    HEAP32[(96972)>>2] = -1;
    HEAP32[(96976)>>2] = -1;
    HEAP32[(96980)>>2] = 0;
    HEAP32[(96932)>>2] = 0;
    $542 = (_time((0|0))|0);
    $543 = $542 & -16;
    $544 = $543 ^ 1431655768;
    HEAP32[96960>>2] = $544;
    break;
   } else {
    _abort();
    // unreachable;
   }
  }
 } while(0);
 $545 = (($nb$0) + 48)|0;
 $546 = HEAP32[(96968)>>2]|0;
 $547 = (($nb$0) + 47)|0;
 $548 = (($546) + ($547))|0;
 $549 = (0 - ($546))|0;
 $550 = $548 & $549;
 $551 = ($550>>>0)>($nb$0>>>0);
 if (!($551)) {
  $mem$0 = 0;
  return ($mem$0|0);
 }
 $552 = HEAP32[(96928)>>2]|0;
 $553 = ($552|0)==(0);
 if (!($553)) {
  $554 = HEAP32[(96920)>>2]|0;
  $555 = (($554) + ($550))|0;
  $556 = ($555>>>0)<=($554>>>0);
  $557 = ($555>>>0)>($552>>>0);
  $or$cond1$i = $556 | $557;
  if ($or$cond1$i) {
   $mem$0 = 0;
   return ($mem$0|0);
  }
 }
 $558 = HEAP32[(96932)>>2]|0;
 $559 = $558 & 4;
 $560 = ($559|0)==(0);
 L258: do {
  if ($560) {
   $561 = HEAP32[(96512)>>2]|0;
   $562 = ($561|0)==(0|0);
   L260: do {
    if ($562) {
     label = 174;
    } else {
     $sp$0$i$i = (96936);
     while(1) {
      $563 = HEAP32[$sp$0$i$i>>2]|0;
      $564 = ($563>>>0)>($561>>>0);
      if (!($564)) {
       $565 = ((($sp$0$i$i)) + 4|0);
       $566 = HEAP32[$565>>2]|0;
       $567 = (($563) + ($566)|0);
       $568 = ($567>>>0)>($561>>>0);
       if ($568) {
        $$lcssa228 = $sp$0$i$i;$$lcssa230 = $565;
        break;
       }
      }
      $569 = ((($sp$0$i$i)) + 8|0);
      $570 = HEAP32[$569>>2]|0;
      $571 = ($570|0)==(0|0);
      if ($571) {
       label = 174;
       break L260;
      } else {
       $sp$0$i$i = $570;
      }
     }
     $594 = HEAP32[(96500)>>2]|0;
     $595 = (($548) - ($594))|0;
     $596 = $595 & $549;
     $597 = ($596>>>0)<(2147483647);
     if ($597) {
      $598 = (_sbrk(($596|0))|0);
      $599 = HEAP32[$$lcssa228>>2]|0;
      $600 = HEAP32[$$lcssa230>>2]|0;
      $601 = (($599) + ($600)|0);
      $602 = ($598|0)==($601|0);
      $$3$i = $602 ? $596 : 0;
      if ($602) {
       $603 = ($598|0)==((-1)|0);
       if ($603) {
        $tsize$0323944$i = $$3$i;
       } else {
        $tbase$255$i = $598;$tsize$254$i = $$3$i;
        label = 194;
        break L258;
       }
      } else {
       $br$0$ph$i = $598;$ssize$1$ph$i = $596;$tsize$0$ph$i = $$3$i;
       label = 184;
      }
     } else {
      $tsize$0323944$i = 0;
     }
    }
   } while(0);
   do {
    if ((label|0) == 174) {
     $572 = (_sbrk(0)|0);
     $573 = ($572|0)==((-1)|0);
     if ($573) {
      $tsize$0323944$i = 0;
     } else {
      $574 = $572;
      $575 = HEAP32[(96964)>>2]|0;
      $576 = (($575) + -1)|0;
      $577 = $576 & $574;
      $578 = ($577|0)==(0);
      if ($578) {
       $ssize$0$i = $550;
      } else {
       $579 = (($576) + ($574))|0;
       $580 = (0 - ($575))|0;
       $581 = $579 & $580;
       $582 = (($550) - ($574))|0;
       $583 = (($582) + ($581))|0;
       $ssize$0$i = $583;
      }
      $584 = HEAP32[(96920)>>2]|0;
      $585 = (($584) + ($ssize$0$i))|0;
      $586 = ($ssize$0$i>>>0)>($nb$0>>>0);
      $587 = ($ssize$0$i>>>0)<(2147483647);
      $or$cond$i30 = $586 & $587;
      if ($or$cond$i30) {
       $588 = HEAP32[(96928)>>2]|0;
       $589 = ($588|0)==(0);
       if (!($589)) {
        $590 = ($585>>>0)<=($584>>>0);
        $591 = ($585>>>0)>($588>>>0);
        $or$cond2$i = $590 | $591;
        if ($or$cond2$i) {
         $tsize$0323944$i = 0;
         break;
        }
       }
       $592 = (_sbrk(($ssize$0$i|0))|0);
       $593 = ($592|0)==($572|0);
       $ssize$0$$i = $593 ? $ssize$0$i : 0;
       if ($593) {
        $tbase$255$i = $572;$tsize$254$i = $ssize$0$$i;
        label = 194;
        break L258;
       } else {
        $br$0$ph$i = $592;$ssize$1$ph$i = $ssize$0$i;$tsize$0$ph$i = $ssize$0$$i;
        label = 184;
       }
      } else {
       $tsize$0323944$i = 0;
      }
     }
    }
   } while(0);
   L280: do {
    if ((label|0) == 184) {
     $604 = (0 - ($ssize$1$ph$i))|0;
     $605 = ($br$0$ph$i|0)!=((-1)|0);
     $606 = ($ssize$1$ph$i>>>0)<(2147483647);
     $or$cond5$i = $606 & $605;
     $607 = ($545>>>0)>($ssize$1$ph$i>>>0);
     $or$cond6$i = $607 & $or$cond5$i;
     do {
      if ($or$cond6$i) {
       $608 = HEAP32[(96968)>>2]|0;
       $609 = (($547) - ($ssize$1$ph$i))|0;
       $610 = (($609) + ($608))|0;
       $611 = (0 - ($608))|0;
       $612 = $610 & $611;
       $613 = ($612>>>0)<(2147483647);
       if ($613) {
        $614 = (_sbrk(($612|0))|0);
        $615 = ($614|0)==((-1)|0);
        if ($615) {
         (_sbrk(($604|0))|0);
         $tsize$0323944$i = $tsize$0$ph$i;
         break L280;
        } else {
         $616 = (($612) + ($ssize$1$ph$i))|0;
         $ssize$2$i = $616;
         break;
        }
       } else {
        $ssize$2$i = $ssize$1$ph$i;
       }
      } else {
       $ssize$2$i = $ssize$1$ph$i;
      }
     } while(0);
     $617 = ($br$0$ph$i|0)==((-1)|0);
     if ($617) {
      $tsize$0323944$i = $tsize$0$ph$i;
     } else {
      $tbase$255$i = $br$0$ph$i;$tsize$254$i = $ssize$2$i;
      label = 194;
      break L258;
     }
    }
   } while(0);
   $618 = HEAP32[(96932)>>2]|0;
   $619 = $618 | 4;
   HEAP32[(96932)>>2] = $619;
   $tsize$1$i = $tsize$0323944$i;
   label = 191;
  } else {
   $tsize$1$i = 0;
   label = 191;
  }
 } while(0);
 if ((label|0) == 191) {
  $620 = ($550>>>0)<(2147483647);
  if ($620) {
   $621 = (_sbrk(($550|0))|0);
   $622 = (_sbrk(0)|0);
   $623 = ($621|0)!=((-1)|0);
   $624 = ($622|0)!=((-1)|0);
   $or$cond3$i = $623 & $624;
   $625 = ($621>>>0)<($622>>>0);
   $or$cond8$i = $625 & $or$cond3$i;
   if ($or$cond8$i) {
    $626 = $622;
    $627 = $621;
    $628 = (($626) - ($627))|0;
    $629 = (($nb$0) + 40)|0;
    $630 = ($628>>>0)>($629>>>0);
    $$tsize$1$i = $630 ? $628 : $tsize$1$i;
    if ($630) {
     $tbase$255$i = $621;$tsize$254$i = $$tsize$1$i;
     label = 194;
    }
   }
  }
 }
 if ((label|0) == 194) {
  $631 = HEAP32[(96920)>>2]|0;
  $632 = (($631) + ($tsize$254$i))|0;
  HEAP32[(96920)>>2] = $632;
  $633 = HEAP32[(96924)>>2]|0;
  $634 = ($632>>>0)>($633>>>0);
  if ($634) {
   HEAP32[(96924)>>2] = $632;
  }
  $635 = HEAP32[(96512)>>2]|0;
  $636 = ($635|0)==(0|0);
  L299: do {
   if ($636) {
    $637 = HEAP32[(96504)>>2]|0;
    $638 = ($637|0)==(0|0);
    $639 = ($tbase$255$i>>>0)<($637>>>0);
    $or$cond9$i = $638 | $639;
    if ($or$cond9$i) {
     HEAP32[(96504)>>2] = $tbase$255$i;
    }
    HEAP32[(96936)>>2] = $tbase$255$i;
    HEAP32[(96940)>>2] = $tsize$254$i;
    HEAP32[(96948)>>2] = 0;
    $640 = HEAP32[96960>>2]|0;
    HEAP32[(96524)>>2] = $640;
    HEAP32[(96520)>>2] = -1;
    $i$02$i$i = 0;
    while(1) {
     $641 = $i$02$i$i << 1;
     $642 = (96528 + ($641<<2)|0);
     $$sum$i$i = (($641) + 3)|0;
     $643 = (96528 + ($$sum$i$i<<2)|0);
     HEAP32[$643>>2] = $642;
     $$sum1$i$i = (($641) + 2)|0;
     $644 = (96528 + ($$sum1$i$i<<2)|0);
     HEAP32[$644>>2] = $642;
     $645 = (($i$02$i$i) + 1)|0;
     $exitcond$i$i = ($645|0)==(32);
     if ($exitcond$i$i) {
      break;
     } else {
      $i$02$i$i = $645;
     }
    }
    $646 = (($tsize$254$i) + -40)|0;
    $647 = ((($tbase$255$i)) + 8|0);
    $648 = $647;
    $649 = $648 & 7;
    $650 = ($649|0)==(0);
    $651 = (0 - ($648))|0;
    $652 = $651 & 7;
    $653 = $650 ? 0 : $652;
    $654 = (($tbase$255$i) + ($653)|0);
    $655 = (($646) - ($653))|0;
    HEAP32[(96512)>>2] = $654;
    HEAP32[(96500)>>2] = $655;
    $656 = $655 | 1;
    $$sum$i13$i = (($653) + 4)|0;
    $657 = (($tbase$255$i) + ($$sum$i13$i)|0);
    HEAP32[$657>>2] = $656;
    $$sum2$i$i = (($tsize$254$i) + -36)|0;
    $658 = (($tbase$255$i) + ($$sum2$i$i)|0);
    HEAP32[$658>>2] = 40;
    $659 = HEAP32[(96976)>>2]|0;
    HEAP32[(96516)>>2] = $659;
   } else {
    $sp$084$i = (96936);
    while(1) {
     $660 = HEAP32[$sp$084$i>>2]|0;
     $661 = ((($sp$084$i)) + 4|0);
     $662 = HEAP32[$661>>2]|0;
     $663 = (($660) + ($662)|0);
     $664 = ($tbase$255$i|0)==($663|0);
     if ($664) {
      $$lcssa222 = $660;$$lcssa224 = $661;$$lcssa226 = $662;$sp$084$i$lcssa = $sp$084$i;
      label = 204;
      break;
     }
     $665 = ((($sp$084$i)) + 8|0);
     $666 = HEAP32[$665>>2]|0;
     $667 = ($666|0)==(0|0);
     if ($667) {
      break;
     } else {
      $sp$084$i = $666;
     }
    }
    if ((label|0) == 204) {
     $668 = ((($sp$084$i$lcssa)) + 12|0);
     $669 = HEAP32[$668>>2]|0;
     $670 = $669 & 8;
     $671 = ($670|0)==(0);
     if ($671) {
      $672 = ($635>>>0)>=($$lcssa222>>>0);
      $673 = ($635>>>0)<($tbase$255$i>>>0);
      $or$cond57$i = $673 & $672;
      if ($or$cond57$i) {
       $674 = (($$lcssa226) + ($tsize$254$i))|0;
       HEAP32[$$lcssa224>>2] = $674;
       $675 = HEAP32[(96500)>>2]|0;
       $676 = (($675) + ($tsize$254$i))|0;
       $677 = ((($635)) + 8|0);
       $678 = $677;
       $679 = $678 & 7;
       $680 = ($679|0)==(0);
       $681 = (0 - ($678))|0;
       $682 = $681 & 7;
       $683 = $680 ? 0 : $682;
       $684 = (($635) + ($683)|0);
       $685 = (($676) - ($683))|0;
       HEAP32[(96512)>>2] = $684;
       HEAP32[(96500)>>2] = $685;
       $686 = $685 | 1;
       $$sum$i17$i = (($683) + 4)|0;
       $687 = (($635) + ($$sum$i17$i)|0);
       HEAP32[$687>>2] = $686;
       $$sum2$i18$i = (($676) + 4)|0;
       $688 = (($635) + ($$sum2$i18$i)|0);
       HEAP32[$688>>2] = 40;
       $689 = HEAP32[(96976)>>2]|0;
       HEAP32[(96516)>>2] = $689;
       break;
      }
     }
    }
    $690 = HEAP32[(96504)>>2]|0;
    $691 = ($tbase$255$i>>>0)<($690>>>0);
    if ($691) {
     HEAP32[(96504)>>2] = $tbase$255$i;
     $755 = $tbase$255$i;
    } else {
     $755 = $690;
    }
    $692 = (($tbase$255$i) + ($tsize$254$i)|0);
    $sp$183$i = (96936);
    while(1) {
     $693 = HEAP32[$sp$183$i>>2]|0;
     $694 = ($693|0)==($692|0);
     if ($694) {
      $$lcssa219 = $sp$183$i;$sp$183$i$lcssa = $sp$183$i;
      label = 212;
      break;
     }
     $695 = ((($sp$183$i)) + 8|0);
     $696 = HEAP32[$695>>2]|0;
     $697 = ($696|0)==(0|0);
     if ($697) {
      $sp$0$i$i$i = (96936);
      break;
     } else {
      $sp$183$i = $696;
     }
    }
    if ((label|0) == 212) {
     $698 = ((($sp$183$i$lcssa)) + 12|0);
     $699 = HEAP32[$698>>2]|0;
     $700 = $699 & 8;
     $701 = ($700|0)==(0);
     if ($701) {
      HEAP32[$$lcssa219>>2] = $tbase$255$i;
      $702 = ((($sp$183$i$lcssa)) + 4|0);
      $703 = HEAP32[$702>>2]|0;
      $704 = (($703) + ($tsize$254$i))|0;
      HEAP32[$702>>2] = $704;
      $705 = ((($tbase$255$i)) + 8|0);
      $706 = $705;
      $707 = $706 & 7;
      $708 = ($707|0)==(0);
      $709 = (0 - ($706))|0;
      $710 = $709 & 7;
      $711 = $708 ? 0 : $710;
      $712 = (($tbase$255$i) + ($711)|0);
      $$sum112$i = (($tsize$254$i) + 8)|0;
      $713 = (($tbase$255$i) + ($$sum112$i)|0);
      $714 = $713;
      $715 = $714 & 7;
      $716 = ($715|0)==(0);
      $717 = (0 - ($714))|0;
      $718 = $717 & 7;
      $719 = $716 ? 0 : $718;
      $$sum113$i = (($719) + ($tsize$254$i))|0;
      $720 = (($tbase$255$i) + ($$sum113$i)|0);
      $721 = $720;
      $722 = $712;
      $723 = (($721) - ($722))|0;
      $$sum$i19$i = (($711) + ($nb$0))|0;
      $724 = (($tbase$255$i) + ($$sum$i19$i)|0);
      $725 = (($723) - ($nb$0))|0;
      $726 = $nb$0 | 3;
      $$sum1$i20$i = (($711) + 4)|0;
      $727 = (($tbase$255$i) + ($$sum1$i20$i)|0);
      HEAP32[$727>>2] = $726;
      $728 = ($720|0)==($635|0);
      L324: do {
       if ($728) {
        $729 = HEAP32[(96500)>>2]|0;
        $730 = (($729) + ($725))|0;
        HEAP32[(96500)>>2] = $730;
        HEAP32[(96512)>>2] = $724;
        $731 = $730 | 1;
        $$sum42$i$i = (($$sum$i19$i) + 4)|0;
        $732 = (($tbase$255$i) + ($$sum42$i$i)|0);
        HEAP32[$732>>2] = $731;
       } else {
        $733 = HEAP32[(96508)>>2]|0;
        $734 = ($720|0)==($733|0);
        if ($734) {
         $735 = HEAP32[(96496)>>2]|0;
         $736 = (($735) + ($725))|0;
         HEAP32[(96496)>>2] = $736;
         HEAP32[(96508)>>2] = $724;
         $737 = $736 | 1;
         $$sum40$i$i = (($$sum$i19$i) + 4)|0;
         $738 = (($tbase$255$i) + ($$sum40$i$i)|0);
         HEAP32[$738>>2] = $737;
         $$sum41$i$i = (($736) + ($$sum$i19$i))|0;
         $739 = (($tbase$255$i) + ($$sum41$i$i)|0);
         HEAP32[$739>>2] = $736;
         break;
        }
        $$sum2$i21$i = (($tsize$254$i) + 4)|0;
        $$sum114$i = (($$sum2$i21$i) + ($719))|0;
        $740 = (($tbase$255$i) + ($$sum114$i)|0);
        $741 = HEAP32[$740>>2]|0;
        $742 = $741 & 3;
        $743 = ($742|0)==(1);
        if ($743) {
         $744 = $741 & -8;
         $745 = $741 >>> 3;
         $746 = ($741>>>0)<(256);
         L331: do {
          if ($746) {
           $$sum3738$i$i = $719 | 8;
           $$sum124$i = (($$sum3738$i$i) + ($tsize$254$i))|0;
           $747 = (($tbase$255$i) + ($$sum124$i)|0);
           $748 = HEAP32[$747>>2]|0;
           $$sum39$i$i = (($tsize$254$i) + 12)|0;
           $$sum125$i = (($$sum39$i$i) + ($719))|0;
           $749 = (($tbase$255$i) + ($$sum125$i)|0);
           $750 = HEAP32[$749>>2]|0;
           $751 = $745 << 1;
           $752 = (96528 + ($751<<2)|0);
           $753 = ($748|0)==($752|0);
           do {
            if (!($753)) {
             $754 = ($748>>>0)<($755>>>0);
             if ($754) {
              _abort();
              // unreachable;
             }
             $756 = ((($748)) + 12|0);
             $757 = HEAP32[$756>>2]|0;
             $758 = ($757|0)==($720|0);
             if ($758) {
              break;
             }
             _abort();
             // unreachable;
            }
           } while(0);
           $759 = ($750|0)==($748|0);
           if ($759) {
            $760 = 1 << $745;
            $761 = $760 ^ -1;
            $762 = HEAP32[96488>>2]|0;
            $763 = $762 & $761;
            HEAP32[96488>>2] = $763;
            break;
           }
           $764 = ($750|0)==($752|0);
           do {
            if ($764) {
             $$pre57$i$i = ((($750)) + 8|0);
             $$pre$phi58$i$iZ2D = $$pre57$i$i;
            } else {
             $765 = ($750>>>0)<($755>>>0);
             if ($765) {
              _abort();
              // unreachable;
             }
             $766 = ((($750)) + 8|0);
             $767 = HEAP32[$766>>2]|0;
             $768 = ($767|0)==($720|0);
             if ($768) {
              $$pre$phi58$i$iZ2D = $766;
              break;
             }
             _abort();
             // unreachable;
            }
           } while(0);
           $769 = ((($748)) + 12|0);
           HEAP32[$769>>2] = $750;
           HEAP32[$$pre$phi58$i$iZ2D>>2] = $748;
          } else {
           $$sum34$i$i = $719 | 24;
           $$sum115$i = (($$sum34$i$i) + ($tsize$254$i))|0;
           $770 = (($tbase$255$i) + ($$sum115$i)|0);
           $771 = HEAP32[$770>>2]|0;
           $$sum5$i$i = (($tsize$254$i) + 12)|0;
           $$sum116$i = (($$sum5$i$i) + ($719))|0;
           $772 = (($tbase$255$i) + ($$sum116$i)|0);
           $773 = HEAP32[$772>>2]|0;
           $774 = ($773|0)==($720|0);
           do {
            if ($774) {
             $$sum67$i$i = $719 | 16;
             $$sum122$i = (($$sum2$i21$i) + ($$sum67$i$i))|0;
             $784 = (($tbase$255$i) + ($$sum122$i)|0);
             $785 = HEAP32[$784>>2]|0;
             $786 = ($785|0)==(0|0);
             if ($786) {
              $$sum123$i = (($$sum67$i$i) + ($tsize$254$i))|0;
              $787 = (($tbase$255$i) + ($$sum123$i)|0);
              $788 = HEAP32[$787>>2]|0;
              $789 = ($788|0)==(0|0);
              if ($789) {
               $R$1$i$i = 0;
               break;
              } else {
               $R$0$i$i = $788;$RP$0$i$i = $787;
              }
             } else {
              $R$0$i$i = $785;$RP$0$i$i = $784;
             }
             while(1) {
              $790 = ((($R$0$i$i)) + 20|0);
              $791 = HEAP32[$790>>2]|0;
              $792 = ($791|0)==(0|0);
              if (!($792)) {
               $R$0$i$i = $791;$RP$0$i$i = $790;
               continue;
              }
              $793 = ((($R$0$i$i)) + 16|0);
              $794 = HEAP32[$793>>2]|0;
              $795 = ($794|0)==(0|0);
              if ($795) {
               $R$0$i$i$lcssa = $R$0$i$i;$RP$0$i$i$lcssa = $RP$0$i$i;
               break;
              } else {
               $R$0$i$i = $794;$RP$0$i$i = $793;
              }
             }
             $796 = ($RP$0$i$i$lcssa>>>0)<($755>>>0);
             if ($796) {
              _abort();
              // unreachable;
             } else {
              HEAP32[$RP$0$i$i$lcssa>>2] = 0;
              $R$1$i$i = $R$0$i$i$lcssa;
              break;
             }
            } else {
             $$sum3536$i$i = $719 | 8;
             $$sum117$i = (($$sum3536$i$i) + ($tsize$254$i))|0;
             $775 = (($tbase$255$i) + ($$sum117$i)|0);
             $776 = HEAP32[$775>>2]|0;
             $777 = ($776>>>0)<($755>>>0);
             if ($777) {
              _abort();
              // unreachable;
             }
             $778 = ((($776)) + 12|0);
             $779 = HEAP32[$778>>2]|0;
             $780 = ($779|0)==($720|0);
             if (!($780)) {
              _abort();
              // unreachable;
             }
             $781 = ((($773)) + 8|0);
             $782 = HEAP32[$781>>2]|0;
             $783 = ($782|0)==($720|0);
             if ($783) {
              HEAP32[$778>>2] = $773;
              HEAP32[$781>>2] = $776;
              $R$1$i$i = $773;
              break;
             } else {
              _abort();
              // unreachable;
             }
            }
           } while(0);
           $797 = ($771|0)==(0|0);
           if ($797) {
            break;
           }
           $$sum30$i$i = (($tsize$254$i) + 28)|0;
           $$sum118$i = (($$sum30$i$i) + ($719))|0;
           $798 = (($tbase$255$i) + ($$sum118$i)|0);
           $799 = HEAP32[$798>>2]|0;
           $800 = (96792 + ($799<<2)|0);
           $801 = HEAP32[$800>>2]|0;
           $802 = ($720|0)==($801|0);
           do {
            if ($802) {
             HEAP32[$800>>2] = $R$1$i$i;
             $cond$i$i = ($R$1$i$i|0)==(0|0);
             if (!($cond$i$i)) {
              break;
             }
             $803 = 1 << $799;
             $804 = $803 ^ -1;
             $805 = HEAP32[(96492)>>2]|0;
             $806 = $805 & $804;
             HEAP32[(96492)>>2] = $806;
             break L331;
            } else {
             $807 = HEAP32[(96504)>>2]|0;
             $808 = ($771>>>0)<($807>>>0);
             if ($808) {
              _abort();
              // unreachable;
             }
             $809 = ((($771)) + 16|0);
             $810 = HEAP32[$809>>2]|0;
             $811 = ($810|0)==($720|0);
             if ($811) {
              HEAP32[$809>>2] = $R$1$i$i;
             } else {
              $812 = ((($771)) + 20|0);
              HEAP32[$812>>2] = $R$1$i$i;
             }
             $813 = ($R$1$i$i|0)==(0|0);
             if ($813) {
              break L331;
             }
            }
           } while(0);
           $814 = HEAP32[(96504)>>2]|0;
           $815 = ($R$1$i$i>>>0)<($814>>>0);
           if ($815) {
            _abort();
            // unreachable;
           }
           $816 = ((($R$1$i$i)) + 24|0);
           HEAP32[$816>>2] = $771;
           $$sum3132$i$i = $719 | 16;
           $$sum119$i = (($$sum3132$i$i) + ($tsize$254$i))|0;
           $817 = (($tbase$255$i) + ($$sum119$i)|0);
           $818 = HEAP32[$817>>2]|0;
           $819 = ($818|0)==(0|0);
           do {
            if (!($819)) {
             $820 = ($818>>>0)<($814>>>0);
             if ($820) {
              _abort();
              // unreachable;
             } else {
              $821 = ((($R$1$i$i)) + 16|0);
              HEAP32[$821>>2] = $818;
              $822 = ((($818)) + 24|0);
              HEAP32[$822>>2] = $R$1$i$i;
              break;
             }
            }
           } while(0);
           $$sum120$i = (($$sum2$i21$i) + ($$sum3132$i$i))|0;
           $823 = (($tbase$255$i) + ($$sum120$i)|0);
           $824 = HEAP32[$823>>2]|0;
           $825 = ($824|0)==(0|0);
           if ($825) {
            break;
           }
           $826 = HEAP32[(96504)>>2]|0;
           $827 = ($824>>>0)<($826>>>0);
           if ($827) {
            _abort();
            // unreachable;
           } else {
            $828 = ((($R$1$i$i)) + 20|0);
            HEAP32[$828>>2] = $824;
            $829 = ((($824)) + 24|0);
            HEAP32[$829>>2] = $R$1$i$i;
            break;
           }
          }
         } while(0);
         $$sum9$i$i = $744 | $719;
         $$sum121$i = (($$sum9$i$i) + ($tsize$254$i))|0;
         $830 = (($tbase$255$i) + ($$sum121$i)|0);
         $831 = (($744) + ($725))|0;
         $oldfirst$0$i$i = $830;$qsize$0$i$i = $831;
        } else {
         $oldfirst$0$i$i = $720;$qsize$0$i$i = $725;
        }
        $832 = ((($oldfirst$0$i$i)) + 4|0);
        $833 = HEAP32[$832>>2]|0;
        $834 = $833 & -2;
        HEAP32[$832>>2] = $834;
        $835 = $qsize$0$i$i | 1;
        $$sum10$i$i = (($$sum$i19$i) + 4)|0;
        $836 = (($tbase$255$i) + ($$sum10$i$i)|0);
        HEAP32[$836>>2] = $835;
        $$sum11$i$i = (($qsize$0$i$i) + ($$sum$i19$i))|0;
        $837 = (($tbase$255$i) + ($$sum11$i$i)|0);
        HEAP32[$837>>2] = $qsize$0$i$i;
        $838 = $qsize$0$i$i >>> 3;
        $839 = ($qsize$0$i$i>>>0)<(256);
        if ($839) {
         $840 = $838 << 1;
         $841 = (96528 + ($840<<2)|0);
         $842 = HEAP32[96488>>2]|0;
         $843 = 1 << $838;
         $844 = $842 & $843;
         $845 = ($844|0)==(0);
         do {
          if ($845) {
           $846 = $842 | $843;
           HEAP32[96488>>2] = $846;
           $$pre$i22$i = (($840) + 2)|0;
           $$pre56$i$i = (96528 + ($$pre$i22$i<<2)|0);
           $$pre$phi$i23$iZ2D = $$pre56$i$i;$F4$0$i$i = $841;
          } else {
           $$sum29$i$i = (($840) + 2)|0;
           $847 = (96528 + ($$sum29$i$i<<2)|0);
           $848 = HEAP32[$847>>2]|0;
           $849 = HEAP32[(96504)>>2]|0;
           $850 = ($848>>>0)<($849>>>0);
           if (!($850)) {
            $$pre$phi$i23$iZ2D = $847;$F4$0$i$i = $848;
            break;
           }
           _abort();
           // unreachable;
          }
         } while(0);
         HEAP32[$$pre$phi$i23$iZ2D>>2] = $724;
         $851 = ((($F4$0$i$i)) + 12|0);
         HEAP32[$851>>2] = $724;
         $$sum27$i$i = (($$sum$i19$i) + 8)|0;
         $852 = (($tbase$255$i) + ($$sum27$i$i)|0);
         HEAP32[$852>>2] = $F4$0$i$i;
         $$sum28$i$i = (($$sum$i19$i) + 12)|0;
         $853 = (($tbase$255$i) + ($$sum28$i$i)|0);
         HEAP32[$853>>2] = $841;
         break;
        }
        $854 = $qsize$0$i$i >>> 8;
        $855 = ($854|0)==(0);
        do {
         if ($855) {
          $I7$0$i$i = 0;
         } else {
          $856 = ($qsize$0$i$i>>>0)>(16777215);
          if ($856) {
           $I7$0$i$i = 31;
           break;
          }
          $857 = (($854) + 1048320)|0;
          $858 = $857 >>> 16;
          $859 = $858 & 8;
          $860 = $854 << $859;
          $861 = (($860) + 520192)|0;
          $862 = $861 >>> 16;
          $863 = $862 & 4;
          $864 = $863 | $859;
          $865 = $860 << $863;
          $866 = (($865) + 245760)|0;
          $867 = $866 >>> 16;
          $868 = $867 & 2;
          $869 = $864 | $868;
          $870 = (14 - ($869))|0;
          $871 = $865 << $868;
          $872 = $871 >>> 15;
          $873 = (($870) + ($872))|0;
          $874 = $873 << 1;
          $875 = (($873) + 7)|0;
          $876 = $qsize$0$i$i >>> $875;
          $877 = $876 & 1;
          $878 = $877 | $874;
          $I7$0$i$i = $878;
         }
        } while(0);
        $879 = (96792 + ($I7$0$i$i<<2)|0);
        $$sum12$i$i = (($$sum$i19$i) + 28)|0;
        $880 = (($tbase$255$i) + ($$sum12$i$i)|0);
        HEAP32[$880>>2] = $I7$0$i$i;
        $$sum13$i$i = (($$sum$i19$i) + 16)|0;
        $881 = (($tbase$255$i) + ($$sum13$i$i)|0);
        $$sum14$i$i = (($$sum$i19$i) + 20)|0;
        $882 = (($tbase$255$i) + ($$sum14$i$i)|0);
        HEAP32[$882>>2] = 0;
        HEAP32[$881>>2] = 0;
        $883 = HEAP32[(96492)>>2]|0;
        $884 = 1 << $I7$0$i$i;
        $885 = $883 & $884;
        $886 = ($885|0)==(0);
        if ($886) {
         $887 = $883 | $884;
         HEAP32[(96492)>>2] = $887;
         HEAP32[$879>>2] = $724;
         $$sum15$i$i = (($$sum$i19$i) + 24)|0;
         $888 = (($tbase$255$i) + ($$sum15$i$i)|0);
         HEAP32[$888>>2] = $879;
         $$sum16$i$i = (($$sum$i19$i) + 12)|0;
         $889 = (($tbase$255$i) + ($$sum16$i$i)|0);
         HEAP32[$889>>2] = $724;
         $$sum17$i$i = (($$sum$i19$i) + 8)|0;
         $890 = (($tbase$255$i) + ($$sum17$i$i)|0);
         HEAP32[$890>>2] = $724;
         break;
        }
        $891 = HEAP32[$879>>2]|0;
        $892 = ((($891)) + 4|0);
        $893 = HEAP32[$892>>2]|0;
        $894 = $893 & -8;
        $895 = ($894|0)==($qsize$0$i$i|0);
        L417: do {
         if ($895) {
          $T$0$lcssa$i25$i = $891;
         } else {
          $896 = ($I7$0$i$i|0)==(31);
          $897 = $I7$0$i$i >>> 1;
          $898 = (25 - ($897))|0;
          $899 = $896 ? 0 : $898;
          $900 = $qsize$0$i$i << $899;
          $K8$051$i$i = $900;$T$050$i$i = $891;
          while(1) {
           $907 = $K8$051$i$i >>> 31;
           $908 = (((($T$050$i$i)) + 16|0) + ($907<<2)|0);
           $903 = HEAP32[$908>>2]|0;
           $909 = ($903|0)==(0|0);
           if ($909) {
            $$lcssa = $908;$T$050$i$i$lcssa = $T$050$i$i;
            break;
           }
           $901 = $K8$051$i$i << 1;
           $902 = ((($903)) + 4|0);
           $904 = HEAP32[$902>>2]|0;
           $905 = $904 & -8;
           $906 = ($905|0)==($qsize$0$i$i|0);
           if ($906) {
            $T$0$lcssa$i25$i = $903;
            break L417;
           } else {
            $K8$051$i$i = $901;$T$050$i$i = $903;
           }
          }
          $910 = HEAP32[(96504)>>2]|0;
          $911 = ($$lcssa>>>0)<($910>>>0);
          if ($911) {
           _abort();
           // unreachable;
          } else {
           HEAP32[$$lcssa>>2] = $724;
           $$sum23$i$i = (($$sum$i19$i) + 24)|0;
           $912 = (($tbase$255$i) + ($$sum23$i$i)|0);
           HEAP32[$912>>2] = $T$050$i$i$lcssa;
           $$sum24$i$i = (($$sum$i19$i) + 12)|0;
           $913 = (($tbase$255$i) + ($$sum24$i$i)|0);
           HEAP32[$913>>2] = $724;
           $$sum25$i$i = (($$sum$i19$i) + 8)|0;
           $914 = (($tbase$255$i) + ($$sum25$i$i)|0);
           HEAP32[$914>>2] = $724;
           break L324;
          }
         }
        } while(0);
        $915 = ((($T$0$lcssa$i25$i)) + 8|0);
        $916 = HEAP32[$915>>2]|0;
        $917 = HEAP32[(96504)>>2]|0;
        $918 = ($916>>>0)>=($917>>>0);
        $not$$i26$i = ($T$0$lcssa$i25$i>>>0)>=($917>>>0);
        $919 = $918 & $not$$i26$i;
        if ($919) {
         $920 = ((($916)) + 12|0);
         HEAP32[$920>>2] = $724;
         HEAP32[$915>>2] = $724;
         $$sum20$i$i = (($$sum$i19$i) + 8)|0;
         $921 = (($tbase$255$i) + ($$sum20$i$i)|0);
         HEAP32[$921>>2] = $916;
         $$sum21$i$i = (($$sum$i19$i) + 12)|0;
         $922 = (($tbase$255$i) + ($$sum21$i$i)|0);
         HEAP32[$922>>2] = $T$0$lcssa$i25$i;
         $$sum22$i$i = (($$sum$i19$i) + 24)|0;
         $923 = (($tbase$255$i) + ($$sum22$i$i)|0);
         HEAP32[$923>>2] = 0;
         break;
        } else {
         _abort();
         // unreachable;
        }
       }
      } while(0);
      $$sum1819$i$i = $711 | 8;
      $924 = (($tbase$255$i) + ($$sum1819$i$i)|0);
      $mem$0 = $924;
      return ($mem$0|0);
     } else {
      $sp$0$i$i$i = (96936);
     }
    }
    while(1) {
     $925 = HEAP32[$sp$0$i$i$i>>2]|0;
     $926 = ($925>>>0)>($635>>>0);
     if (!($926)) {
      $927 = ((($sp$0$i$i$i)) + 4|0);
      $928 = HEAP32[$927>>2]|0;
      $929 = (($925) + ($928)|0);
      $930 = ($929>>>0)>($635>>>0);
      if ($930) {
       $$lcssa215 = $925;$$lcssa216 = $928;$$lcssa217 = $929;
       break;
      }
     }
     $931 = ((($sp$0$i$i$i)) + 8|0);
     $932 = HEAP32[$931>>2]|0;
     $sp$0$i$i$i = $932;
    }
    $$sum$i14$i = (($$lcssa216) + -47)|0;
    $$sum1$i15$i = (($$lcssa216) + -39)|0;
    $933 = (($$lcssa215) + ($$sum1$i15$i)|0);
    $934 = $933;
    $935 = $934 & 7;
    $936 = ($935|0)==(0);
    $937 = (0 - ($934))|0;
    $938 = $937 & 7;
    $939 = $936 ? 0 : $938;
    $$sum2$i16$i = (($$sum$i14$i) + ($939))|0;
    $940 = (($$lcssa215) + ($$sum2$i16$i)|0);
    $941 = ((($635)) + 16|0);
    $942 = ($940>>>0)<($941>>>0);
    $943 = $942 ? $635 : $940;
    $944 = ((($943)) + 8|0);
    $945 = (($tsize$254$i) + -40)|0;
    $946 = ((($tbase$255$i)) + 8|0);
    $947 = $946;
    $948 = $947 & 7;
    $949 = ($948|0)==(0);
    $950 = (0 - ($947))|0;
    $951 = $950 & 7;
    $952 = $949 ? 0 : $951;
    $953 = (($tbase$255$i) + ($952)|0);
    $954 = (($945) - ($952))|0;
    HEAP32[(96512)>>2] = $953;
    HEAP32[(96500)>>2] = $954;
    $955 = $954 | 1;
    $$sum$i$i$i = (($952) + 4)|0;
    $956 = (($tbase$255$i) + ($$sum$i$i$i)|0);
    HEAP32[$956>>2] = $955;
    $$sum2$i$i$i = (($tsize$254$i) + -36)|0;
    $957 = (($tbase$255$i) + ($$sum2$i$i$i)|0);
    HEAP32[$957>>2] = 40;
    $958 = HEAP32[(96976)>>2]|0;
    HEAP32[(96516)>>2] = $958;
    $959 = ((($943)) + 4|0);
    HEAP32[$959>>2] = 27;
    ;HEAP32[$944>>2]=HEAP32[(96936)>>2]|0;HEAP32[$944+4>>2]=HEAP32[(96936)+4>>2]|0;HEAP32[$944+8>>2]=HEAP32[(96936)+8>>2]|0;HEAP32[$944+12>>2]=HEAP32[(96936)+12>>2]|0;
    HEAP32[(96936)>>2] = $tbase$255$i;
    HEAP32[(96940)>>2] = $tsize$254$i;
    HEAP32[(96948)>>2] = 0;
    HEAP32[(96944)>>2] = $944;
    $960 = ((($943)) + 28|0);
    HEAP32[$960>>2] = 7;
    $961 = ((($943)) + 32|0);
    $962 = ($961>>>0)<($$lcssa217>>>0);
    if ($962) {
     $964 = $960;
     while(1) {
      $963 = ((($964)) + 4|0);
      HEAP32[$963>>2] = 7;
      $965 = ((($964)) + 8|0);
      $966 = ($965>>>0)<($$lcssa217>>>0);
      if ($966) {
       $964 = $963;
      } else {
       break;
      }
     }
    }
    $967 = ($943|0)==($635|0);
    if (!($967)) {
     $968 = $943;
     $969 = $635;
     $970 = (($968) - ($969))|0;
     $971 = HEAP32[$959>>2]|0;
     $972 = $971 & -2;
     HEAP32[$959>>2] = $972;
     $973 = $970 | 1;
     $974 = ((($635)) + 4|0);
     HEAP32[$974>>2] = $973;
     HEAP32[$943>>2] = $970;
     $975 = $970 >>> 3;
     $976 = ($970>>>0)<(256);
     if ($976) {
      $977 = $975 << 1;
      $978 = (96528 + ($977<<2)|0);
      $979 = HEAP32[96488>>2]|0;
      $980 = 1 << $975;
      $981 = $979 & $980;
      $982 = ($981|0)==(0);
      if ($982) {
       $983 = $979 | $980;
       HEAP32[96488>>2] = $983;
       $$pre$i$i = (($977) + 2)|0;
       $$pre14$i$i = (96528 + ($$pre$i$i<<2)|0);
       $$pre$phi$i$iZ2D = $$pre14$i$i;$F$0$i$i = $978;
      } else {
       $$sum4$i$i = (($977) + 2)|0;
       $984 = (96528 + ($$sum4$i$i<<2)|0);
       $985 = HEAP32[$984>>2]|0;
       $986 = HEAP32[(96504)>>2]|0;
       $987 = ($985>>>0)<($986>>>0);
       if ($987) {
        _abort();
        // unreachable;
       } else {
        $$pre$phi$i$iZ2D = $984;$F$0$i$i = $985;
       }
      }
      HEAP32[$$pre$phi$i$iZ2D>>2] = $635;
      $988 = ((($F$0$i$i)) + 12|0);
      HEAP32[$988>>2] = $635;
      $989 = ((($635)) + 8|0);
      HEAP32[$989>>2] = $F$0$i$i;
      $990 = ((($635)) + 12|0);
      HEAP32[$990>>2] = $978;
      break;
     }
     $991 = $970 >>> 8;
     $992 = ($991|0)==(0);
     if ($992) {
      $I1$0$i$i = 0;
     } else {
      $993 = ($970>>>0)>(16777215);
      if ($993) {
       $I1$0$i$i = 31;
      } else {
       $994 = (($991) + 1048320)|0;
       $995 = $994 >>> 16;
       $996 = $995 & 8;
       $997 = $991 << $996;
       $998 = (($997) + 520192)|0;
       $999 = $998 >>> 16;
       $1000 = $999 & 4;
       $1001 = $1000 | $996;
       $1002 = $997 << $1000;
       $1003 = (($1002) + 245760)|0;
       $1004 = $1003 >>> 16;
       $1005 = $1004 & 2;
       $1006 = $1001 | $1005;
       $1007 = (14 - ($1006))|0;
       $1008 = $1002 << $1005;
       $1009 = $1008 >>> 15;
       $1010 = (($1007) + ($1009))|0;
       $1011 = $1010 << 1;
       $1012 = (($1010) + 7)|0;
       $1013 = $970 >>> $1012;
       $1014 = $1013 & 1;
       $1015 = $1014 | $1011;
       $I1$0$i$i = $1015;
      }
     }
     $1016 = (96792 + ($I1$0$i$i<<2)|0);
     $1017 = ((($635)) + 28|0);
     HEAP32[$1017>>2] = $I1$0$i$i;
     $1018 = ((($635)) + 20|0);
     HEAP32[$1018>>2] = 0;
     HEAP32[$941>>2] = 0;
     $1019 = HEAP32[(96492)>>2]|0;
     $1020 = 1 << $I1$0$i$i;
     $1021 = $1019 & $1020;
     $1022 = ($1021|0)==(0);
     if ($1022) {
      $1023 = $1019 | $1020;
      HEAP32[(96492)>>2] = $1023;
      HEAP32[$1016>>2] = $635;
      $1024 = ((($635)) + 24|0);
      HEAP32[$1024>>2] = $1016;
      $1025 = ((($635)) + 12|0);
      HEAP32[$1025>>2] = $635;
      $1026 = ((($635)) + 8|0);
      HEAP32[$1026>>2] = $635;
      break;
     }
     $1027 = HEAP32[$1016>>2]|0;
     $1028 = ((($1027)) + 4|0);
     $1029 = HEAP32[$1028>>2]|0;
     $1030 = $1029 & -8;
     $1031 = ($1030|0)==($970|0);
     L459: do {
      if ($1031) {
       $T$0$lcssa$i$i = $1027;
      } else {
       $1032 = ($I1$0$i$i|0)==(31);
       $1033 = $I1$0$i$i >>> 1;
       $1034 = (25 - ($1033))|0;
       $1035 = $1032 ? 0 : $1034;
       $1036 = $970 << $1035;
       $K2$07$i$i = $1036;$T$06$i$i = $1027;
       while(1) {
        $1043 = $K2$07$i$i >>> 31;
        $1044 = (((($T$06$i$i)) + 16|0) + ($1043<<2)|0);
        $1039 = HEAP32[$1044>>2]|0;
        $1045 = ($1039|0)==(0|0);
        if ($1045) {
         $$lcssa211 = $1044;$T$06$i$i$lcssa = $T$06$i$i;
         break;
        }
        $1037 = $K2$07$i$i << 1;
        $1038 = ((($1039)) + 4|0);
        $1040 = HEAP32[$1038>>2]|0;
        $1041 = $1040 & -8;
        $1042 = ($1041|0)==($970|0);
        if ($1042) {
         $T$0$lcssa$i$i = $1039;
         break L459;
        } else {
         $K2$07$i$i = $1037;$T$06$i$i = $1039;
        }
       }
       $1046 = HEAP32[(96504)>>2]|0;
       $1047 = ($$lcssa211>>>0)<($1046>>>0);
       if ($1047) {
        _abort();
        // unreachable;
       } else {
        HEAP32[$$lcssa211>>2] = $635;
        $1048 = ((($635)) + 24|0);
        HEAP32[$1048>>2] = $T$06$i$i$lcssa;
        $1049 = ((($635)) + 12|0);
        HEAP32[$1049>>2] = $635;
        $1050 = ((($635)) + 8|0);
        HEAP32[$1050>>2] = $635;
        break L299;
       }
      }
     } while(0);
     $1051 = ((($T$0$lcssa$i$i)) + 8|0);
     $1052 = HEAP32[$1051>>2]|0;
     $1053 = HEAP32[(96504)>>2]|0;
     $1054 = ($1052>>>0)>=($1053>>>0);
     $not$$i$i = ($T$0$lcssa$i$i>>>0)>=($1053>>>0);
     $1055 = $1054 & $not$$i$i;
     if ($1055) {
      $1056 = ((($1052)) + 12|0);
      HEAP32[$1056>>2] = $635;
      HEAP32[$1051>>2] = $635;
      $1057 = ((($635)) + 8|0);
      HEAP32[$1057>>2] = $1052;
      $1058 = ((($635)) + 12|0);
      HEAP32[$1058>>2] = $T$0$lcssa$i$i;
      $1059 = ((($635)) + 24|0);
      HEAP32[$1059>>2] = 0;
      break;
     } else {
      _abort();
      // unreachable;
     }
    }
   }
  } while(0);
  $1060 = HEAP32[(96500)>>2]|0;
  $1061 = ($1060>>>0)>($nb$0>>>0);
  if ($1061) {
   $1062 = (($1060) - ($nb$0))|0;
   HEAP32[(96500)>>2] = $1062;
   $1063 = HEAP32[(96512)>>2]|0;
   $1064 = (($1063) + ($nb$0)|0);
   HEAP32[(96512)>>2] = $1064;
   $1065 = $1062 | 1;
   $$sum$i32 = (($nb$0) + 4)|0;
   $1066 = (($1063) + ($$sum$i32)|0);
   HEAP32[$1066>>2] = $1065;
   $1067 = $nb$0 | 3;
   $1068 = ((($1063)) + 4|0);
   HEAP32[$1068>>2] = $1067;
   $1069 = ((($1063)) + 8|0);
   $mem$0 = $1069;
   return ($mem$0|0);
  }
 }
 $1070 = (___errno_location()|0);
 HEAP32[$1070>>2] = 12;
 $mem$0 = 0;
 return ($mem$0|0);
}
function _free($mem) {
 $mem = $mem|0;
 var $$lcssa = 0, $$pre = 0, $$pre$phi59Z2D = 0, $$pre$phi61Z2D = 0, $$pre$phiZ2D = 0, $$pre57 = 0, $$pre58 = 0, $$pre60 = 0, $$sum = 0, $$sum11 = 0, $$sum12 = 0, $$sum13 = 0, $$sum14 = 0, $$sum1718 = 0, $$sum19 = 0, $$sum2 = 0, $$sum20 = 0, $$sum22 = 0, $$sum23 = 0, $$sum24 = 0;
 var $$sum25 = 0, $$sum26 = 0, $$sum27 = 0, $$sum28 = 0, $$sum29 = 0, $$sum3 = 0, $$sum30 = 0, $$sum31 = 0, $$sum5 = 0, $$sum67 = 0, $$sum8 = 0, $$sum9 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0;
 var $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0;
 var $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0;
 var $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0;
 var $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0;
 var $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0;
 var $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0;
 var $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0;
 var $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0;
 var $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0;
 var $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0;
 var $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0;
 var $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0;
 var $321 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0;
 var $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0;
 var $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0;
 var $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $F16$0 = 0, $I18$0 = 0, $K19$052 = 0, $R$0 = 0, $R$0$lcssa = 0, $R$1 = 0;
 var $R7$0 = 0, $R7$0$lcssa = 0, $R7$1 = 0, $RP$0 = 0, $RP$0$lcssa = 0, $RP9$0 = 0, $RP9$0$lcssa = 0, $T$0$lcssa = 0, $T$051 = 0, $T$051$lcssa = 0, $cond = 0, $cond47 = 0, $not$ = 0, $p$0 = 0, $psize$0 = 0, $psize$1 = 0, $sp$0$i = 0, $sp$0$in$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($mem|0)==(0|0);
 if ($0) {
  return;
 }
 $1 = ((($mem)) + -8|0);
 $2 = HEAP32[(96504)>>2]|0;
 $3 = ($1>>>0)<($2>>>0);
 if ($3) {
  _abort();
  // unreachable;
 }
 $4 = ((($mem)) + -4|0);
 $5 = HEAP32[$4>>2]|0;
 $6 = $5 & 3;
 $7 = ($6|0)==(1);
 if ($7) {
  _abort();
  // unreachable;
 }
 $8 = $5 & -8;
 $$sum = (($8) + -8)|0;
 $9 = (($mem) + ($$sum)|0);
 $10 = $5 & 1;
 $11 = ($10|0)==(0);
 do {
  if ($11) {
   $12 = HEAP32[$1>>2]|0;
   $13 = ($6|0)==(0);
   if ($13) {
    return;
   }
   $$sum2 = (-8 - ($12))|0;
   $14 = (($mem) + ($$sum2)|0);
   $15 = (($12) + ($8))|0;
   $16 = ($14>>>0)<($2>>>0);
   if ($16) {
    _abort();
    // unreachable;
   }
   $17 = HEAP32[(96508)>>2]|0;
   $18 = ($14|0)==($17|0);
   if ($18) {
    $$sum3 = (($8) + -4)|0;
    $103 = (($mem) + ($$sum3)|0);
    $104 = HEAP32[$103>>2]|0;
    $105 = $104 & 3;
    $106 = ($105|0)==(3);
    if (!($106)) {
     $p$0 = $14;$psize$0 = $15;
     break;
    }
    HEAP32[(96496)>>2] = $15;
    $107 = $104 & -2;
    HEAP32[$103>>2] = $107;
    $108 = $15 | 1;
    $$sum20 = (($$sum2) + 4)|0;
    $109 = (($mem) + ($$sum20)|0);
    HEAP32[$109>>2] = $108;
    HEAP32[$9>>2] = $15;
    return;
   }
   $19 = $12 >>> 3;
   $20 = ($12>>>0)<(256);
   if ($20) {
    $$sum30 = (($$sum2) + 8)|0;
    $21 = (($mem) + ($$sum30)|0);
    $22 = HEAP32[$21>>2]|0;
    $$sum31 = (($$sum2) + 12)|0;
    $23 = (($mem) + ($$sum31)|0);
    $24 = HEAP32[$23>>2]|0;
    $25 = $19 << 1;
    $26 = (96528 + ($25<<2)|0);
    $27 = ($22|0)==($26|0);
    if (!($27)) {
     $28 = ($22>>>0)<($2>>>0);
     if ($28) {
      _abort();
      // unreachable;
     }
     $29 = ((($22)) + 12|0);
     $30 = HEAP32[$29>>2]|0;
     $31 = ($30|0)==($14|0);
     if (!($31)) {
      _abort();
      // unreachable;
     }
    }
    $32 = ($24|0)==($22|0);
    if ($32) {
     $33 = 1 << $19;
     $34 = $33 ^ -1;
     $35 = HEAP32[96488>>2]|0;
     $36 = $35 & $34;
     HEAP32[96488>>2] = $36;
     $p$0 = $14;$psize$0 = $15;
     break;
    }
    $37 = ($24|0)==($26|0);
    if ($37) {
     $$pre60 = ((($24)) + 8|0);
     $$pre$phi61Z2D = $$pre60;
    } else {
     $38 = ($24>>>0)<($2>>>0);
     if ($38) {
      _abort();
      // unreachable;
     }
     $39 = ((($24)) + 8|0);
     $40 = HEAP32[$39>>2]|0;
     $41 = ($40|0)==($14|0);
     if ($41) {
      $$pre$phi61Z2D = $39;
     } else {
      _abort();
      // unreachable;
     }
    }
    $42 = ((($22)) + 12|0);
    HEAP32[$42>>2] = $24;
    HEAP32[$$pre$phi61Z2D>>2] = $22;
    $p$0 = $14;$psize$0 = $15;
    break;
   }
   $$sum22 = (($$sum2) + 24)|0;
   $43 = (($mem) + ($$sum22)|0);
   $44 = HEAP32[$43>>2]|0;
   $$sum23 = (($$sum2) + 12)|0;
   $45 = (($mem) + ($$sum23)|0);
   $46 = HEAP32[$45>>2]|0;
   $47 = ($46|0)==($14|0);
   do {
    if ($47) {
     $$sum25 = (($$sum2) + 20)|0;
     $57 = (($mem) + ($$sum25)|0);
     $58 = HEAP32[$57>>2]|0;
     $59 = ($58|0)==(0|0);
     if ($59) {
      $$sum24 = (($$sum2) + 16)|0;
      $60 = (($mem) + ($$sum24)|0);
      $61 = HEAP32[$60>>2]|0;
      $62 = ($61|0)==(0|0);
      if ($62) {
       $R$1 = 0;
       break;
      } else {
       $R$0 = $61;$RP$0 = $60;
      }
     } else {
      $R$0 = $58;$RP$0 = $57;
     }
     while(1) {
      $63 = ((($R$0)) + 20|0);
      $64 = HEAP32[$63>>2]|0;
      $65 = ($64|0)==(0|0);
      if (!($65)) {
       $R$0 = $64;$RP$0 = $63;
       continue;
      }
      $66 = ((($R$0)) + 16|0);
      $67 = HEAP32[$66>>2]|0;
      $68 = ($67|0)==(0|0);
      if ($68) {
       $R$0$lcssa = $R$0;$RP$0$lcssa = $RP$0;
       break;
      } else {
       $R$0 = $67;$RP$0 = $66;
      }
     }
     $69 = ($RP$0$lcssa>>>0)<($2>>>0);
     if ($69) {
      _abort();
      // unreachable;
     } else {
      HEAP32[$RP$0$lcssa>>2] = 0;
      $R$1 = $R$0$lcssa;
      break;
     }
    } else {
     $$sum29 = (($$sum2) + 8)|0;
     $48 = (($mem) + ($$sum29)|0);
     $49 = HEAP32[$48>>2]|0;
     $50 = ($49>>>0)<($2>>>0);
     if ($50) {
      _abort();
      // unreachable;
     }
     $51 = ((($49)) + 12|0);
     $52 = HEAP32[$51>>2]|0;
     $53 = ($52|0)==($14|0);
     if (!($53)) {
      _abort();
      // unreachable;
     }
     $54 = ((($46)) + 8|0);
     $55 = HEAP32[$54>>2]|0;
     $56 = ($55|0)==($14|0);
     if ($56) {
      HEAP32[$51>>2] = $46;
      HEAP32[$54>>2] = $49;
      $R$1 = $46;
      break;
     } else {
      _abort();
      // unreachable;
     }
    }
   } while(0);
   $70 = ($44|0)==(0|0);
   if ($70) {
    $p$0 = $14;$psize$0 = $15;
   } else {
    $$sum26 = (($$sum2) + 28)|0;
    $71 = (($mem) + ($$sum26)|0);
    $72 = HEAP32[$71>>2]|0;
    $73 = (96792 + ($72<<2)|0);
    $74 = HEAP32[$73>>2]|0;
    $75 = ($14|0)==($74|0);
    if ($75) {
     HEAP32[$73>>2] = $R$1;
     $cond = ($R$1|0)==(0|0);
     if ($cond) {
      $76 = 1 << $72;
      $77 = $76 ^ -1;
      $78 = HEAP32[(96492)>>2]|0;
      $79 = $78 & $77;
      HEAP32[(96492)>>2] = $79;
      $p$0 = $14;$psize$0 = $15;
      break;
     }
    } else {
     $80 = HEAP32[(96504)>>2]|0;
     $81 = ($44>>>0)<($80>>>0);
     if ($81) {
      _abort();
      // unreachable;
     }
     $82 = ((($44)) + 16|0);
     $83 = HEAP32[$82>>2]|0;
     $84 = ($83|0)==($14|0);
     if ($84) {
      HEAP32[$82>>2] = $R$1;
     } else {
      $85 = ((($44)) + 20|0);
      HEAP32[$85>>2] = $R$1;
     }
     $86 = ($R$1|0)==(0|0);
     if ($86) {
      $p$0 = $14;$psize$0 = $15;
      break;
     }
    }
    $87 = HEAP32[(96504)>>2]|0;
    $88 = ($R$1>>>0)<($87>>>0);
    if ($88) {
     _abort();
     // unreachable;
    }
    $89 = ((($R$1)) + 24|0);
    HEAP32[$89>>2] = $44;
    $$sum27 = (($$sum2) + 16)|0;
    $90 = (($mem) + ($$sum27)|0);
    $91 = HEAP32[$90>>2]|0;
    $92 = ($91|0)==(0|0);
    do {
     if (!($92)) {
      $93 = ($91>>>0)<($87>>>0);
      if ($93) {
       _abort();
       // unreachable;
      } else {
       $94 = ((($R$1)) + 16|0);
       HEAP32[$94>>2] = $91;
       $95 = ((($91)) + 24|0);
       HEAP32[$95>>2] = $R$1;
       break;
      }
     }
    } while(0);
    $$sum28 = (($$sum2) + 20)|0;
    $96 = (($mem) + ($$sum28)|0);
    $97 = HEAP32[$96>>2]|0;
    $98 = ($97|0)==(0|0);
    if ($98) {
     $p$0 = $14;$psize$0 = $15;
    } else {
     $99 = HEAP32[(96504)>>2]|0;
     $100 = ($97>>>0)<($99>>>0);
     if ($100) {
      _abort();
      // unreachable;
     } else {
      $101 = ((($R$1)) + 20|0);
      HEAP32[$101>>2] = $97;
      $102 = ((($97)) + 24|0);
      HEAP32[$102>>2] = $R$1;
      $p$0 = $14;$psize$0 = $15;
      break;
     }
    }
   }
  } else {
   $p$0 = $1;$psize$0 = $8;
  }
 } while(0);
 $110 = ($p$0>>>0)<($9>>>0);
 if (!($110)) {
  _abort();
  // unreachable;
 }
 $$sum19 = (($8) + -4)|0;
 $111 = (($mem) + ($$sum19)|0);
 $112 = HEAP32[$111>>2]|0;
 $113 = $112 & 1;
 $114 = ($113|0)==(0);
 if ($114) {
  _abort();
  // unreachable;
 }
 $115 = $112 & 2;
 $116 = ($115|0)==(0);
 if ($116) {
  $117 = HEAP32[(96512)>>2]|0;
  $118 = ($9|0)==($117|0);
  if ($118) {
   $119 = HEAP32[(96500)>>2]|0;
   $120 = (($119) + ($psize$0))|0;
   HEAP32[(96500)>>2] = $120;
   HEAP32[(96512)>>2] = $p$0;
   $121 = $120 | 1;
   $122 = ((($p$0)) + 4|0);
   HEAP32[$122>>2] = $121;
   $123 = HEAP32[(96508)>>2]|0;
   $124 = ($p$0|0)==($123|0);
   if (!($124)) {
    return;
   }
   HEAP32[(96508)>>2] = 0;
   HEAP32[(96496)>>2] = 0;
   return;
  }
  $125 = HEAP32[(96508)>>2]|0;
  $126 = ($9|0)==($125|0);
  if ($126) {
   $127 = HEAP32[(96496)>>2]|0;
   $128 = (($127) + ($psize$0))|0;
   HEAP32[(96496)>>2] = $128;
   HEAP32[(96508)>>2] = $p$0;
   $129 = $128 | 1;
   $130 = ((($p$0)) + 4|0);
   HEAP32[$130>>2] = $129;
   $131 = (($p$0) + ($128)|0);
   HEAP32[$131>>2] = $128;
   return;
  }
  $132 = $112 & -8;
  $133 = (($132) + ($psize$0))|0;
  $134 = $112 >>> 3;
  $135 = ($112>>>0)<(256);
  do {
   if ($135) {
    $136 = (($mem) + ($8)|0);
    $137 = HEAP32[$136>>2]|0;
    $$sum1718 = $8 | 4;
    $138 = (($mem) + ($$sum1718)|0);
    $139 = HEAP32[$138>>2]|0;
    $140 = $134 << 1;
    $141 = (96528 + ($140<<2)|0);
    $142 = ($137|0)==($141|0);
    if (!($142)) {
     $143 = HEAP32[(96504)>>2]|0;
     $144 = ($137>>>0)<($143>>>0);
     if ($144) {
      _abort();
      // unreachable;
     }
     $145 = ((($137)) + 12|0);
     $146 = HEAP32[$145>>2]|0;
     $147 = ($146|0)==($9|0);
     if (!($147)) {
      _abort();
      // unreachable;
     }
    }
    $148 = ($139|0)==($137|0);
    if ($148) {
     $149 = 1 << $134;
     $150 = $149 ^ -1;
     $151 = HEAP32[96488>>2]|0;
     $152 = $151 & $150;
     HEAP32[96488>>2] = $152;
     break;
    }
    $153 = ($139|0)==($141|0);
    if ($153) {
     $$pre58 = ((($139)) + 8|0);
     $$pre$phi59Z2D = $$pre58;
    } else {
     $154 = HEAP32[(96504)>>2]|0;
     $155 = ($139>>>0)<($154>>>0);
     if ($155) {
      _abort();
      // unreachable;
     }
     $156 = ((($139)) + 8|0);
     $157 = HEAP32[$156>>2]|0;
     $158 = ($157|0)==($9|0);
     if ($158) {
      $$pre$phi59Z2D = $156;
     } else {
      _abort();
      // unreachable;
     }
    }
    $159 = ((($137)) + 12|0);
    HEAP32[$159>>2] = $139;
    HEAP32[$$pre$phi59Z2D>>2] = $137;
   } else {
    $$sum5 = (($8) + 16)|0;
    $160 = (($mem) + ($$sum5)|0);
    $161 = HEAP32[$160>>2]|0;
    $$sum67 = $8 | 4;
    $162 = (($mem) + ($$sum67)|0);
    $163 = HEAP32[$162>>2]|0;
    $164 = ($163|0)==($9|0);
    do {
     if ($164) {
      $$sum9 = (($8) + 12)|0;
      $175 = (($mem) + ($$sum9)|0);
      $176 = HEAP32[$175>>2]|0;
      $177 = ($176|0)==(0|0);
      if ($177) {
       $$sum8 = (($8) + 8)|0;
       $178 = (($mem) + ($$sum8)|0);
       $179 = HEAP32[$178>>2]|0;
       $180 = ($179|0)==(0|0);
       if ($180) {
        $R7$1 = 0;
        break;
       } else {
        $R7$0 = $179;$RP9$0 = $178;
       }
      } else {
       $R7$0 = $176;$RP9$0 = $175;
      }
      while(1) {
       $181 = ((($R7$0)) + 20|0);
       $182 = HEAP32[$181>>2]|0;
       $183 = ($182|0)==(0|0);
       if (!($183)) {
        $R7$0 = $182;$RP9$0 = $181;
        continue;
       }
       $184 = ((($R7$0)) + 16|0);
       $185 = HEAP32[$184>>2]|0;
       $186 = ($185|0)==(0|0);
       if ($186) {
        $R7$0$lcssa = $R7$0;$RP9$0$lcssa = $RP9$0;
        break;
       } else {
        $R7$0 = $185;$RP9$0 = $184;
       }
      }
      $187 = HEAP32[(96504)>>2]|0;
      $188 = ($RP9$0$lcssa>>>0)<($187>>>0);
      if ($188) {
       _abort();
       // unreachable;
      } else {
       HEAP32[$RP9$0$lcssa>>2] = 0;
       $R7$1 = $R7$0$lcssa;
       break;
      }
     } else {
      $165 = (($mem) + ($8)|0);
      $166 = HEAP32[$165>>2]|0;
      $167 = HEAP32[(96504)>>2]|0;
      $168 = ($166>>>0)<($167>>>0);
      if ($168) {
       _abort();
       // unreachable;
      }
      $169 = ((($166)) + 12|0);
      $170 = HEAP32[$169>>2]|0;
      $171 = ($170|0)==($9|0);
      if (!($171)) {
       _abort();
       // unreachable;
      }
      $172 = ((($163)) + 8|0);
      $173 = HEAP32[$172>>2]|0;
      $174 = ($173|0)==($9|0);
      if ($174) {
       HEAP32[$169>>2] = $163;
       HEAP32[$172>>2] = $166;
       $R7$1 = $163;
       break;
      } else {
       _abort();
       // unreachable;
      }
     }
    } while(0);
    $189 = ($161|0)==(0|0);
    if (!($189)) {
     $$sum12 = (($8) + 20)|0;
     $190 = (($mem) + ($$sum12)|0);
     $191 = HEAP32[$190>>2]|0;
     $192 = (96792 + ($191<<2)|0);
     $193 = HEAP32[$192>>2]|0;
     $194 = ($9|0)==($193|0);
     if ($194) {
      HEAP32[$192>>2] = $R7$1;
      $cond47 = ($R7$1|0)==(0|0);
      if ($cond47) {
       $195 = 1 << $191;
       $196 = $195 ^ -1;
       $197 = HEAP32[(96492)>>2]|0;
       $198 = $197 & $196;
       HEAP32[(96492)>>2] = $198;
       break;
      }
     } else {
      $199 = HEAP32[(96504)>>2]|0;
      $200 = ($161>>>0)<($199>>>0);
      if ($200) {
       _abort();
       // unreachable;
      }
      $201 = ((($161)) + 16|0);
      $202 = HEAP32[$201>>2]|0;
      $203 = ($202|0)==($9|0);
      if ($203) {
       HEAP32[$201>>2] = $R7$1;
      } else {
       $204 = ((($161)) + 20|0);
       HEAP32[$204>>2] = $R7$1;
      }
      $205 = ($R7$1|0)==(0|0);
      if ($205) {
       break;
      }
     }
     $206 = HEAP32[(96504)>>2]|0;
     $207 = ($R7$1>>>0)<($206>>>0);
     if ($207) {
      _abort();
      // unreachable;
     }
     $208 = ((($R7$1)) + 24|0);
     HEAP32[$208>>2] = $161;
     $$sum13 = (($8) + 8)|0;
     $209 = (($mem) + ($$sum13)|0);
     $210 = HEAP32[$209>>2]|0;
     $211 = ($210|0)==(0|0);
     do {
      if (!($211)) {
       $212 = ($210>>>0)<($206>>>0);
       if ($212) {
        _abort();
        // unreachable;
       } else {
        $213 = ((($R7$1)) + 16|0);
        HEAP32[$213>>2] = $210;
        $214 = ((($210)) + 24|0);
        HEAP32[$214>>2] = $R7$1;
        break;
       }
      }
     } while(0);
     $$sum14 = (($8) + 12)|0;
     $215 = (($mem) + ($$sum14)|0);
     $216 = HEAP32[$215>>2]|0;
     $217 = ($216|0)==(0|0);
     if (!($217)) {
      $218 = HEAP32[(96504)>>2]|0;
      $219 = ($216>>>0)<($218>>>0);
      if ($219) {
       _abort();
       // unreachable;
      } else {
       $220 = ((($R7$1)) + 20|0);
       HEAP32[$220>>2] = $216;
       $221 = ((($216)) + 24|0);
       HEAP32[$221>>2] = $R7$1;
       break;
      }
     }
    }
   }
  } while(0);
  $222 = $133 | 1;
  $223 = ((($p$0)) + 4|0);
  HEAP32[$223>>2] = $222;
  $224 = (($p$0) + ($133)|0);
  HEAP32[$224>>2] = $133;
  $225 = HEAP32[(96508)>>2]|0;
  $226 = ($p$0|0)==($225|0);
  if ($226) {
   HEAP32[(96496)>>2] = $133;
   return;
  } else {
   $psize$1 = $133;
  }
 } else {
  $227 = $112 & -2;
  HEAP32[$111>>2] = $227;
  $228 = $psize$0 | 1;
  $229 = ((($p$0)) + 4|0);
  HEAP32[$229>>2] = $228;
  $230 = (($p$0) + ($psize$0)|0);
  HEAP32[$230>>2] = $psize$0;
  $psize$1 = $psize$0;
 }
 $231 = $psize$1 >>> 3;
 $232 = ($psize$1>>>0)<(256);
 if ($232) {
  $233 = $231 << 1;
  $234 = (96528 + ($233<<2)|0);
  $235 = HEAP32[96488>>2]|0;
  $236 = 1 << $231;
  $237 = $235 & $236;
  $238 = ($237|0)==(0);
  if ($238) {
   $239 = $235 | $236;
   HEAP32[96488>>2] = $239;
   $$pre = (($233) + 2)|0;
   $$pre57 = (96528 + ($$pre<<2)|0);
   $$pre$phiZ2D = $$pre57;$F16$0 = $234;
  } else {
   $$sum11 = (($233) + 2)|0;
   $240 = (96528 + ($$sum11<<2)|0);
   $241 = HEAP32[$240>>2]|0;
   $242 = HEAP32[(96504)>>2]|0;
   $243 = ($241>>>0)<($242>>>0);
   if ($243) {
    _abort();
    // unreachable;
   } else {
    $$pre$phiZ2D = $240;$F16$0 = $241;
   }
  }
  HEAP32[$$pre$phiZ2D>>2] = $p$0;
  $244 = ((($F16$0)) + 12|0);
  HEAP32[$244>>2] = $p$0;
  $245 = ((($p$0)) + 8|0);
  HEAP32[$245>>2] = $F16$0;
  $246 = ((($p$0)) + 12|0);
  HEAP32[$246>>2] = $234;
  return;
 }
 $247 = $psize$1 >>> 8;
 $248 = ($247|0)==(0);
 if ($248) {
  $I18$0 = 0;
 } else {
  $249 = ($psize$1>>>0)>(16777215);
  if ($249) {
   $I18$0 = 31;
  } else {
   $250 = (($247) + 1048320)|0;
   $251 = $250 >>> 16;
   $252 = $251 & 8;
   $253 = $247 << $252;
   $254 = (($253) + 520192)|0;
   $255 = $254 >>> 16;
   $256 = $255 & 4;
   $257 = $256 | $252;
   $258 = $253 << $256;
   $259 = (($258) + 245760)|0;
   $260 = $259 >>> 16;
   $261 = $260 & 2;
   $262 = $257 | $261;
   $263 = (14 - ($262))|0;
   $264 = $258 << $261;
   $265 = $264 >>> 15;
   $266 = (($263) + ($265))|0;
   $267 = $266 << 1;
   $268 = (($266) + 7)|0;
   $269 = $psize$1 >>> $268;
   $270 = $269 & 1;
   $271 = $270 | $267;
   $I18$0 = $271;
  }
 }
 $272 = (96792 + ($I18$0<<2)|0);
 $273 = ((($p$0)) + 28|0);
 HEAP32[$273>>2] = $I18$0;
 $274 = ((($p$0)) + 16|0);
 $275 = ((($p$0)) + 20|0);
 HEAP32[$275>>2] = 0;
 HEAP32[$274>>2] = 0;
 $276 = HEAP32[(96492)>>2]|0;
 $277 = 1 << $I18$0;
 $278 = $276 & $277;
 $279 = ($278|0)==(0);
 L199: do {
  if ($279) {
   $280 = $276 | $277;
   HEAP32[(96492)>>2] = $280;
   HEAP32[$272>>2] = $p$0;
   $281 = ((($p$0)) + 24|0);
   HEAP32[$281>>2] = $272;
   $282 = ((($p$0)) + 12|0);
   HEAP32[$282>>2] = $p$0;
   $283 = ((($p$0)) + 8|0);
   HEAP32[$283>>2] = $p$0;
  } else {
   $284 = HEAP32[$272>>2]|0;
   $285 = ((($284)) + 4|0);
   $286 = HEAP32[$285>>2]|0;
   $287 = $286 & -8;
   $288 = ($287|0)==($psize$1|0);
   L201: do {
    if ($288) {
     $T$0$lcssa = $284;
    } else {
     $289 = ($I18$0|0)==(31);
     $290 = $I18$0 >>> 1;
     $291 = (25 - ($290))|0;
     $292 = $289 ? 0 : $291;
     $293 = $psize$1 << $292;
     $K19$052 = $293;$T$051 = $284;
     while(1) {
      $300 = $K19$052 >>> 31;
      $301 = (((($T$051)) + 16|0) + ($300<<2)|0);
      $296 = HEAP32[$301>>2]|0;
      $302 = ($296|0)==(0|0);
      if ($302) {
       $$lcssa = $301;$T$051$lcssa = $T$051;
       break;
      }
      $294 = $K19$052 << 1;
      $295 = ((($296)) + 4|0);
      $297 = HEAP32[$295>>2]|0;
      $298 = $297 & -8;
      $299 = ($298|0)==($psize$1|0);
      if ($299) {
       $T$0$lcssa = $296;
       break L201;
      } else {
       $K19$052 = $294;$T$051 = $296;
      }
     }
     $303 = HEAP32[(96504)>>2]|0;
     $304 = ($$lcssa>>>0)<($303>>>0);
     if ($304) {
      _abort();
      // unreachable;
     } else {
      HEAP32[$$lcssa>>2] = $p$0;
      $305 = ((($p$0)) + 24|0);
      HEAP32[$305>>2] = $T$051$lcssa;
      $306 = ((($p$0)) + 12|0);
      HEAP32[$306>>2] = $p$0;
      $307 = ((($p$0)) + 8|0);
      HEAP32[$307>>2] = $p$0;
      break L199;
     }
    }
   } while(0);
   $308 = ((($T$0$lcssa)) + 8|0);
   $309 = HEAP32[$308>>2]|0;
   $310 = HEAP32[(96504)>>2]|0;
   $311 = ($309>>>0)>=($310>>>0);
   $not$ = ($T$0$lcssa>>>0)>=($310>>>0);
   $312 = $311 & $not$;
   if ($312) {
    $313 = ((($309)) + 12|0);
    HEAP32[$313>>2] = $p$0;
    HEAP32[$308>>2] = $p$0;
    $314 = ((($p$0)) + 8|0);
    HEAP32[$314>>2] = $309;
    $315 = ((($p$0)) + 12|0);
    HEAP32[$315>>2] = $T$0$lcssa;
    $316 = ((($p$0)) + 24|0);
    HEAP32[$316>>2] = 0;
    break;
   } else {
    _abort();
    // unreachable;
   }
  }
 } while(0);
 $317 = HEAP32[(96520)>>2]|0;
 $318 = (($317) + -1)|0;
 HEAP32[(96520)>>2] = $318;
 $319 = ($318|0)==(0);
 if ($319) {
  $sp$0$in$i = (96944);
 } else {
  return;
 }
 while(1) {
  $sp$0$i = HEAP32[$sp$0$in$i>>2]|0;
  $320 = ($sp$0$i|0)==(0|0);
  $321 = ((($sp$0$i)) + 8|0);
  if ($320) {
   break;
  } else {
   $sp$0$in$i = $321;
  }
 }
 HEAP32[(96520)>>2] = -1;
 return;
}
function _calloc($n_elements,$elem_size) {
 $n_elements = $n_elements|0;
 $elem_size = $elem_size|0;
 var $$ = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $req$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($n_elements|0)==(0);
 if ($0) {
  $req$0 = 0;
 } else {
  $1 = Math_imul($elem_size, $n_elements)|0;
  $2 = $elem_size | $n_elements;
  $3 = ($2>>>0)>(65535);
  if ($3) {
   $4 = (($1>>>0) / ($n_elements>>>0))&-1;
   $5 = ($4|0)==($elem_size|0);
   $$ = $5 ? $1 : -1;
   $req$0 = $$;
  } else {
   $req$0 = $1;
  }
 }
 $6 = (_malloc($req$0)|0);
 $7 = ($6|0)==(0|0);
 if ($7) {
  return ($6|0);
 }
 $8 = ((($6)) + -4|0);
 $9 = HEAP32[$8>>2]|0;
 $10 = $9 & 3;
 $11 = ($10|0)==(0);
 if ($11) {
  return ($6|0);
 }
 _memset(($6|0),0,($req$0|0))|0;
 return ($6|0);
}
function runPostSets() {

}
function _i64Subtract(a, b, c, d) {
    a = a|0; b = b|0; c = c|0; d = d|0;
    var l = 0, h = 0;
    l = (a - c)>>>0;
    h = (b - d)>>>0;
    h = (b - d - (((c>>>0) > (a>>>0))|0))>>>0; // Borrow one from high word to low word on underflow.
    return ((tempRet0 = h,l|0)|0);
}
function _memset(ptr, value, num) {
    ptr = ptr|0; value = value|0; num = num|0;
    var stop = 0, value4 = 0, stop4 = 0, unaligned = 0;
    stop = (ptr + num)|0;
    if ((num|0) >= 20) {
      // This is unaligned, but quite large, so work hard to get to aligned settings
      value = value & 0xff;
      unaligned = ptr & 3;
      value4 = value | (value << 8) | (value << 16) | (value << 24);
      stop4 = stop & ~3;
      if (unaligned) {
        unaligned = (ptr + 4 - unaligned)|0;
        while ((ptr|0) < (unaligned|0)) { // no need to check for stop, since we have large num
          HEAP8[((ptr)>>0)]=value;
          ptr = (ptr+1)|0;
        }
      }
      while ((ptr|0) < (stop4|0)) {
        HEAP32[((ptr)>>2)]=value4;
        ptr = (ptr+4)|0;
      }
    }
    while ((ptr|0) < (stop|0)) {
      HEAP8[((ptr)>>0)]=value;
      ptr = (ptr+1)|0;
    }
    return (ptr-num)|0;
}
function _strlen(ptr) {
    ptr = ptr|0;
    var curr = 0;
    curr = ptr;
    while (((HEAP8[((curr)>>0)])|0)) {
      curr = (curr + 1)|0;
    }
    return (curr - ptr)|0;
}
function _i64Add(a, b, c, d) {
    /*
      x = a + b*2^32
      y = c + d*2^32
      result = l + h*2^32
    */
    a = a|0; b = b|0; c = c|0; d = d|0;
    var l = 0, h = 0;
    l = (a + c)>>>0;
    h = (b + d + (((l>>>0) < (a>>>0))|0))>>>0; // Add carry from low word to high word on overflow.
    return ((tempRet0 = h,l|0)|0);
}
function _bitshift64Lshr(low, high, bits) {
    low = low|0; high = high|0; bits = bits|0;
    var ander = 0;
    if ((bits|0) < 32) {
      ander = ((1 << bits) - 1)|0;
      tempRet0 = high >>> bits;
      return (low >>> bits) | ((high&ander) << (32 - bits));
    }
    tempRet0 = 0;
    return (high >>> (bits - 32))|0;
}
function _memcpy(dest, src, num) {
    dest = dest|0; src = src|0; num = num|0;
    var ret = 0;
    if ((num|0) >= 4096) return _emscripten_memcpy_big(dest|0, src|0, num|0)|0;
    ret = dest|0;
    if ((dest&3) == (src&3)) {
      while (dest & 3) {
        if ((num|0) == 0) return ret|0;
        HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);
        dest = (dest+1)|0;
        src = (src+1)|0;
        num = (num-1)|0;
      }
      while ((num|0) >= 4) {
        HEAP32[((dest)>>2)]=((HEAP32[((src)>>2)])|0);
        dest = (dest+4)|0;
        src = (src+4)|0;
        num = (num-4)|0;
      }
    }
    while ((num|0) > 0) {
      HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);
      dest = (dest+1)|0;
      src = (src+1)|0;
      num = (num-1)|0;
    }
    return ret|0;
}
function _bitshift64Shl(low, high, bits) {
    low = low|0; high = high|0; bits = bits|0;
    var ander = 0;
    if ((bits|0) < 32) {
      ander = ((1 << bits) - 1)|0;
      tempRet0 = (high << bits) | ((low&(ander << (32 - bits))) >>> (32 - bits));
      return low << bits;
    }
    tempRet0 = low << (bits - 32);
    return 0;
}
function _bitshift64Ashr(low, high, bits) {
    low = low|0; high = high|0; bits = bits|0;
    var ander = 0;
    if ((bits|0) < 32) {
      ander = ((1 << bits) - 1)|0;
      tempRet0 = high >> bits;
      return (low >>> bits) | ((high&ander) << (32 - bits));
    }
    tempRet0 = (high|0) < 0 ? -1 : 0;
    return (high >> (bits - 32))|0;
  }
function _llvm_cttz_i32(x) {
    x = x|0;
    var ret = 0;
    ret = ((HEAP8[(((cttz_i8)+(x & 0xff))>>0)])|0);
    if ((ret|0) < 8) return ret|0;
    ret = ((HEAP8[(((cttz_i8)+((x >> 8)&0xff))>>0)])|0);
    if ((ret|0) < 8) return (ret + 8)|0;
    ret = ((HEAP8[(((cttz_i8)+((x >> 16)&0xff))>>0)])|0);
    if ((ret|0) < 8) return (ret + 16)|0;
    return (((HEAP8[(((cttz_i8)+(x >>> 24))>>0)])|0) + 24)|0;
  }

// ======== compiled code from system/lib/compiler-rt , see readme therein
function ___muldsi3($a, $b) {
  $a = $a | 0;
  $b = $b | 0;
  var $1 = 0, $2 = 0, $3 = 0, $6 = 0, $8 = 0, $11 = 0, $12 = 0;
  $1 = $a & 65535;
  $2 = $b & 65535;
  $3 = Math_imul($2, $1) | 0;
  $6 = $a >>> 16;
  $8 = ($3 >>> 16) + (Math_imul($2, $6) | 0) | 0;
  $11 = $b >>> 16;
  $12 = Math_imul($11, $1) | 0;
  return (tempRet0 = (($8 >>> 16) + (Math_imul($11, $6) | 0) | 0) + ((($8 & 65535) + $12 | 0) >>> 16) | 0, 0 | ($8 + $12 << 16 | $3 & 65535)) | 0;
}
function ___divdi3($a$0, $a$1, $b$0, $b$1) {
  $a$0 = $a$0 | 0;
  $a$1 = $a$1 | 0;
  $b$0 = $b$0 | 0;
  $b$1 = $b$1 | 0;
  var $1$0 = 0, $1$1 = 0, $2$0 = 0, $2$1 = 0, $4$0 = 0, $4$1 = 0, $6$0 = 0, $7$0 = 0, $7$1 = 0, $8$0 = 0, $10$0 = 0;
  $1$0 = $a$1 >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1;
  $1$1 = (($a$1 | 0) < 0 ? -1 : 0) >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1;
  $2$0 = $b$1 >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1;
  $2$1 = (($b$1 | 0) < 0 ? -1 : 0) >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1;
  $4$0 = _i64Subtract($1$0 ^ $a$0, $1$1 ^ $a$1, $1$0, $1$1) | 0;
  $4$1 = tempRet0;
  $6$0 = _i64Subtract($2$0 ^ $b$0, $2$1 ^ $b$1, $2$0, $2$1) | 0;
  $7$0 = $2$0 ^ $1$0;
  $7$1 = $2$1 ^ $1$1;
  $8$0 = ___udivmoddi4($4$0, $4$1, $6$0, tempRet0, 0) | 0;
  $10$0 = _i64Subtract($8$0 ^ $7$0, tempRet0 ^ $7$1, $7$0, $7$1) | 0;
  return $10$0 | 0;
}
function ___remdi3($a$0, $a$1, $b$0, $b$1) {
  $a$0 = $a$0 | 0;
  $a$1 = $a$1 | 0;
  $b$0 = $b$0 | 0;
  $b$1 = $b$1 | 0;
  var $rem = 0, $1$0 = 0, $1$1 = 0, $2$0 = 0, $2$1 = 0, $4$0 = 0, $4$1 = 0, $6$0 = 0, $10$0 = 0, $10$1 = 0, __stackBase__ = 0;
  __stackBase__ = STACKTOP;
  STACKTOP = STACKTOP + 8 | 0;
  $rem = __stackBase__ | 0;
  $1$0 = $a$1 >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1;
  $1$1 = (($a$1 | 0) < 0 ? -1 : 0) >> 31 | (($a$1 | 0) < 0 ? -1 : 0) << 1;
  $2$0 = $b$1 >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1;
  $2$1 = (($b$1 | 0) < 0 ? -1 : 0) >> 31 | (($b$1 | 0) < 0 ? -1 : 0) << 1;
  $4$0 = _i64Subtract($1$0 ^ $a$0, $1$1 ^ $a$1, $1$0, $1$1) | 0;
  $4$1 = tempRet0;
  $6$0 = _i64Subtract($2$0 ^ $b$0, $2$1 ^ $b$1, $2$0, $2$1) | 0;
  ___udivmoddi4($4$0, $4$1, $6$0, tempRet0, $rem) | 0;
  $10$0 = _i64Subtract(HEAP32[$rem >> 2] ^ $1$0, HEAP32[$rem + 4 >> 2] ^ $1$1, $1$0, $1$1) | 0;
  $10$1 = tempRet0;
  STACKTOP = __stackBase__;
  return (tempRet0 = $10$1, $10$0) | 0;
}
function ___muldi3($a$0, $a$1, $b$0, $b$1) {
  $a$0 = $a$0 | 0;
  $a$1 = $a$1 | 0;
  $b$0 = $b$0 | 0;
  $b$1 = $b$1 | 0;
  var $x_sroa_0_0_extract_trunc = 0, $y_sroa_0_0_extract_trunc = 0, $1$0 = 0, $1$1 = 0, $2 = 0;
  $x_sroa_0_0_extract_trunc = $a$0;
  $y_sroa_0_0_extract_trunc = $b$0;
  $1$0 = ___muldsi3($x_sroa_0_0_extract_trunc, $y_sroa_0_0_extract_trunc) | 0;
  $1$1 = tempRet0;
  $2 = Math_imul($a$1, $y_sroa_0_0_extract_trunc) | 0;
  return (tempRet0 = ((Math_imul($b$1, $x_sroa_0_0_extract_trunc) | 0) + $2 | 0) + $1$1 | $1$1 & 0, 0 | $1$0 & -1) | 0;
}
function ___udivdi3($a$0, $a$1, $b$0, $b$1) {
  $a$0 = $a$0 | 0;
  $a$1 = $a$1 | 0;
  $b$0 = $b$0 | 0;
  $b$1 = $b$1 | 0;
  var $1$0 = 0;
  $1$0 = ___udivmoddi4($a$0, $a$1, $b$0, $b$1, 0) | 0;
  return $1$0 | 0;
}
function ___uremdi3($a$0, $a$1, $b$0, $b$1) {
  $a$0 = $a$0 | 0;
  $a$1 = $a$1 | 0;
  $b$0 = $b$0 | 0;
  $b$1 = $b$1 | 0;
  var $rem = 0, __stackBase__ = 0;
  __stackBase__ = STACKTOP;
  STACKTOP = STACKTOP + 8 | 0;
  $rem = __stackBase__ | 0;
  ___udivmoddi4($a$0, $a$1, $b$0, $b$1, $rem) | 0;
  STACKTOP = __stackBase__;
  return (tempRet0 = HEAP32[$rem + 4 >> 2] | 0, HEAP32[$rem >> 2] | 0) | 0;
}
function ___udivmoddi4($a$0, $a$1, $b$0, $b$1, $rem) {
  $a$0 = $a$0 | 0;
  $a$1 = $a$1 | 0;
  $b$0 = $b$0 | 0;
  $b$1 = $b$1 | 0;
  $rem = $rem | 0;
  var $n_sroa_0_0_extract_trunc = 0, $n_sroa_1_4_extract_shift$0 = 0, $n_sroa_1_4_extract_trunc = 0, $d_sroa_0_0_extract_trunc = 0, $d_sroa_1_4_extract_shift$0 = 0, $d_sroa_1_4_extract_trunc = 0, $4 = 0, $17 = 0, $37 = 0, $49 = 0, $51 = 0, $57 = 0, $58 = 0, $66 = 0, $78 = 0, $86 = 0, $88 = 0, $89 = 0, $91 = 0, $92 = 0, $95 = 0, $105 = 0, $117 = 0, $119 = 0, $125 = 0, $126 = 0, $130 = 0, $q_sroa_1_1_ph = 0, $q_sroa_0_1_ph = 0, $r_sroa_1_1_ph = 0, $r_sroa_0_1_ph = 0, $sr_1_ph = 0, $d_sroa_0_0_insert_insert99$0 = 0, $d_sroa_0_0_insert_insert99$1 = 0, $137$0 = 0, $137$1 = 0, $carry_0203 = 0, $sr_1202 = 0, $r_sroa_0_1201 = 0, $r_sroa_1_1200 = 0, $q_sroa_0_1199 = 0, $q_sroa_1_1198 = 0, $147 = 0, $149 = 0, $r_sroa_0_0_insert_insert42$0 = 0, $r_sroa_0_0_insert_insert42$1 = 0, $150$1 = 0, $151$0 = 0, $152 = 0, $154$0 = 0, $r_sroa_0_0_extract_trunc = 0, $r_sroa_1_4_extract_trunc = 0, $155 = 0, $carry_0_lcssa$0 = 0, $carry_0_lcssa$1 = 0, $r_sroa_0_1_lcssa = 0, $r_sroa_1_1_lcssa = 0, $q_sroa_0_1_lcssa = 0, $q_sroa_1_1_lcssa = 0, $q_sroa_0_0_insert_ext75$0 = 0, $q_sroa_0_0_insert_ext75$1 = 0, $q_sroa_0_0_insert_insert77$1 = 0, $_0$0 = 0, $_0$1 = 0;
  $n_sroa_0_0_extract_trunc = $a$0;
  $n_sroa_1_4_extract_shift$0 = $a$1;
  $n_sroa_1_4_extract_trunc = $n_sroa_1_4_extract_shift$0;
  $d_sroa_0_0_extract_trunc = $b$0;
  $d_sroa_1_4_extract_shift$0 = $b$1;
  $d_sroa_1_4_extract_trunc = $d_sroa_1_4_extract_shift$0;
  if (($n_sroa_1_4_extract_trunc | 0) == 0) {
    $4 = ($rem | 0) != 0;
    if (($d_sroa_1_4_extract_trunc | 0) == 0) {
      if ($4) {
        HEAP32[$rem >> 2] = ($n_sroa_0_0_extract_trunc >>> 0) % ($d_sroa_0_0_extract_trunc >>> 0);
        HEAP32[$rem + 4 >> 2] = 0;
      }
      $_0$1 = 0;
      $_0$0 = ($n_sroa_0_0_extract_trunc >>> 0) / ($d_sroa_0_0_extract_trunc >>> 0) >>> 0;
      return (tempRet0 = $_0$1, $_0$0) | 0;
    } else {
      if (!$4) {
        $_0$1 = 0;
        $_0$0 = 0;
        return (tempRet0 = $_0$1, $_0$0) | 0;
      }
      HEAP32[$rem >> 2] = $a$0 & -1;
      HEAP32[$rem + 4 >> 2] = $a$1 & 0;
      $_0$1 = 0;
      $_0$0 = 0;
      return (tempRet0 = $_0$1, $_0$0) | 0;
    }
  }
  $17 = ($d_sroa_1_4_extract_trunc | 0) == 0;
  do {
    if (($d_sroa_0_0_extract_trunc | 0) == 0) {
      if ($17) {
        if (($rem | 0) != 0) {
          HEAP32[$rem >> 2] = ($n_sroa_1_4_extract_trunc >>> 0) % ($d_sroa_0_0_extract_trunc >>> 0);
          HEAP32[$rem + 4 >> 2] = 0;
        }
        $_0$1 = 0;
        $_0$0 = ($n_sroa_1_4_extract_trunc >>> 0) / ($d_sroa_0_0_extract_trunc >>> 0) >>> 0;
        return (tempRet0 = $_0$1, $_0$0) | 0;
      }
      if (($n_sroa_0_0_extract_trunc | 0) == 0) {
        if (($rem | 0) != 0) {
          HEAP32[$rem >> 2] = 0;
          HEAP32[$rem + 4 >> 2] = ($n_sroa_1_4_extract_trunc >>> 0) % ($d_sroa_1_4_extract_trunc >>> 0);
        }
        $_0$1 = 0;
        $_0$0 = ($n_sroa_1_4_extract_trunc >>> 0) / ($d_sroa_1_4_extract_trunc >>> 0) >>> 0;
        return (tempRet0 = $_0$1, $_0$0) | 0;
      }
      $37 = $d_sroa_1_4_extract_trunc - 1 | 0;
      if (($37 & $d_sroa_1_4_extract_trunc | 0) == 0) {
        if (($rem | 0) != 0) {
          HEAP32[$rem >> 2] = 0 | $a$0 & -1;
          HEAP32[$rem + 4 >> 2] = $37 & $n_sroa_1_4_extract_trunc | $a$1 & 0;
        }
        $_0$1 = 0;
        $_0$0 = $n_sroa_1_4_extract_trunc >>> ((_llvm_cttz_i32($d_sroa_1_4_extract_trunc | 0) | 0) >>> 0);
        return (tempRet0 = $_0$1, $_0$0) | 0;
      }
      $49 = Math_clz32($d_sroa_1_4_extract_trunc | 0) | 0;
      $51 = $49 - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
      if ($51 >>> 0 <= 30) {
        $57 = $51 + 1 | 0;
        $58 = 31 - $51 | 0;
        $sr_1_ph = $57;
        $r_sroa_0_1_ph = $n_sroa_1_4_extract_trunc << $58 | $n_sroa_0_0_extract_trunc >>> ($57 >>> 0);
        $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ($57 >>> 0);
        $q_sroa_0_1_ph = 0;
        $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $58;
        break;
      }
      if (($rem | 0) == 0) {
        $_0$1 = 0;
        $_0$0 = 0;
        return (tempRet0 = $_0$1, $_0$0) | 0;
      }
      HEAP32[$rem >> 2] = 0 | $a$0 & -1;
      HEAP32[$rem + 4 >> 2] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
      $_0$1 = 0;
      $_0$0 = 0;
      return (tempRet0 = $_0$1, $_0$0) | 0;
    } else {
      if (!$17) {
        $117 = Math_clz32($d_sroa_1_4_extract_trunc | 0) | 0;
        $119 = $117 - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
        if ($119 >>> 0 <= 31) {
          $125 = $119 + 1 | 0;
          $126 = 31 - $119 | 0;
          $130 = $119 - 31 >> 31;
          $sr_1_ph = $125;
          $r_sroa_0_1_ph = $n_sroa_0_0_extract_trunc >>> ($125 >>> 0) & $130 | $n_sroa_1_4_extract_trunc << $126;
          $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ($125 >>> 0) & $130;
          $q_sroa_0_1_ph = 0;
          $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $126;
          break;
        }
        if (($rem | 0) == 0) {
          $_0$1 = 0;
          $_0$0 = 0;
          return (tempRet0 = $_0$1, $_0$0) | 0;
        }
        HEAP32[$rem >> 2] = 0 | $a$0 & -1;
        HEAP32[$rem + 4 >> 2] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
        $_0$1 = 0;
        $_0$0 = 0;
        return (tempRet0 = $_0$1, $_0$0) | 0;
      }
      $66 = $d_sroa_0_0_extract_trunc - 1 | 0;
      if (($66 & $d_sroa_0_0_extract_trunc | 0) != 0) {
        $86 = (Math_clz32($d_sroa_0_0_extract_trunc | 0) | 0) + 33 | 0;
        $88 = $86 - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
        $89 = 64 - $88 | 0;
        $91 = 32 - $88 | 0;
        $92 = $91 >> 31;
        $95 = $88 - 32 | 0;
        $105 = $95 >> 31;
        $sr_1_ph = $88;
        $r_sroa_0_1_ph = $91 - 1 >> 31 & $n_sroa_1_4_extract_trunc >>> ($95 >>> 0) | ($n_sroa_1_4_extract_trunc << $91 | $n_sroa_0_0_extract_trunc >>> ($88 >>> 0)) & $105;
        $r_sroa_1_1_ph = $105 & $n_sroa_1_4_extract_trunc >>> ($88 >>> 0);
        $q_sroa_0_1_ph = $n_sroa_0_0_extract_trunc << $89 & $92;
        $q_sroa_1_1_ph = ($n_sroa_1_4_extract_trunc << $89 | $n_sroa_0_0_extract_trunc >>> ($95 >>> 0)) & $92 | $n_sroa_0_0_extract_trunc << $91 & $88 - 33 >> 31;
        break;
      }
      if (($rem | 0) != 0) {
        HEAP32[$rem >> 2] = $66 & $n_sroa_0_0_extract_trunc;
        HEAP32[$rem + 4 >> 2] = 0;
      }
      if (($d_sroa_0_0_extract_trunc | 0) == 1) {
        $_0$1 = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
        $_0$0 = 0 | $a$0 & -1;
        return (tempRet0 = $_0$1, $_0$0) | 0;
      } else {
        $78 = _llvm_cttz_i32($d_sroa_0_0_extract_trunc | 0) | 0;
        $_0$1 = 0 | $n_sroa_1_4_extract_trunc >>> ($78 >>> 0);
        $_0$0 = $n_sroa_1_4_extract_trunc << 32 - $78 | $n_sroa_0_0_extract_trunc >>> ($78 >>> 0) | 0;
        return (tempRet0 = $_0$1, $_0$0) | 0;
      }
    }
  } while (0);
  if (($sr_1_ph | 0) == 0) {
    $q_sroa_1_1_lcssa = $q_sroa_1_1_ph;
    $q_sroa_0_1_lcssa = $q_sroa_0_1_ph;
    $r_sroa_1_1_lcssa = $r_sroa_1_1_ph;
    $r_sroa_0_1_lcssa = $r_sroa_0_1_ph;
    $carry_0_lcssa$1 = 0;
    $carry_0_lcssa$0 = 0;
  } else {
    $d_sroa_0_0_insert_insert99$0 = 0 | $b$0 & -1;
    $d_sroa_0_0_insert_insert99$1 = $d_sroa_1_4_extract_shift$0 | $b$1 & 0;
    $137$0 = _i64Add($d_sroa_0_0_insert_insert99$0 | 0, $d_sroa_0_0_insert_insert99$1 | 0, -1, -1) | 0;
    $137$1 = tempRet0;
    $q_sroa_1_1198 = $q_sroa_1_1_ph;
    $q_sroa_0_1199 = $q_sroa_0_1_ph;
    $r_sroa_1_1200 = $r_sroa_1_1_ph;
    $r_sroa_0_1201 = $r_sroa_0_1_ph;
    $sr_1202 = $sr_1_ph;
    $carry_0203 = 0;
    while (1) {
      $147 = $q_sroa_0_1199 >>> 31 | $q_sroa_1_1198 << 1;
      $149 = $carry_0203 | $q_sroa_0_1199 << 1;
      $r_sroa_0_0_insert_insert42$0 = 0 | ($r_sroa_0_1201 << 1 | $q_sroa_1_1198 >>> 31);
      $r_sroa_0_0_insert_insert42$1 = $r_sroa_0_1201 >>> 31 | $r_sroa_1_1200 << 1 | 0;
      _i64Subtract($137$0, $137$1, $r_sroa_0_0_insert_insert42$0, $r_sroa_0_0_insert_insert42$1) | 0;
      $150$1 = tempRet0;
      $151$0 = $150$1 >> 31 | (($150$1 | 0) < 0 ? -1 : 0) << 1;
      $152 = $151$0 & 1;
      $154$0 = _i64Subtract($r_sroa_0_0_insert_insert42$0, $r_sroa_0_0_insert_insert42$1, $151$0 & $d_sroa_0_0_insert_insert99$0, ((($150$1 | 0) < 0 ? -1 : 0) >> 31 | (($150$1 | 0) < 0 ? -1 : 0) << 1) & $d_sroa_0_0_insert_insert99$1) | 0;
      $r_sroa_0_0_extract_trunc = $154$0;
      $r_sroa_1_4_extract_trunc = tempRet0;
      $155 = $sr_1202 - 1 | 0;
      if (($155 | 0) == 0) {
        break;
      } else {
        $q_sroa_1_1198 = $147;
        $q_sroa_0_1199 = $149;
        $r_sroa_1_1200 = $r_sroa_1_4_extract_trunc;
        $r_sroa_0_1201 = $r_sroa_0_0_extract_trunc;
        $sr_1202 = $155;
        $carry_0203 = $152;
      }
    }
    $q_sroa_1_1_lcssa = $147;
    $q_sroa_0_1_lcssa = $149;
    $r_sroa_1_1_lcssa = $r_sroa_1_4_extract_trunc;
    $r_sroa_0_1_lcssa = $r_sroa_0_0_extract_trunc;
    $carry_0_lcssa$1 = 0;
    $carry_0_lcssa$0 = $152;
  }
  $q_sroa_0_0_insert_ext75$0 = $q_sroa_0_1_lcssa;
  $q_sroa_0_0_insert_ext75$1 = 0;
  $q_sroa_0_0_insert_insert77$1 = $q_sroa_1_1_lcssa | $q_sroa_0_0_insert_ext75$1;
  if (($rem | 0) != 0) {
    HEAP32[$rem >> 2] = 0 | $r_sroa_0_1_lcssa;
    HEAP32[$rem + 4 >> 2] = $r_sroa_1_1_lcssa | 0;
  }
  $_0$1 = (0 | $q_sroa_0_0_insert_ext75$0) >>> 31 | $q_sroa_0_0_insert_insert77$1 << 1 | ($q_sroa_0_0_insert_ext75$1 << 1 | $q_sroa_0_0_insert_ext75$0 >>> 31) & 0 | $carry_0_lcssa$1;
  $_0$0 = ($q_sroa_0_0_insert_ext75$0 << 1 | 0 >>> 31) & -2 | $carry_0_lcssa$0;
  return (tempRet0 = $_0$1, $_0$0) | 0;
}
// =======================================================================



  
function dynCall_iiii(index,a1,a2,a3) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0;
  return FUNCTION_TABLE_iiii[index&3](a1|0,a2|0,a3|0)|0;
}


function dynCall_iiiii(index,a1,a2,a3,a4) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  return FUNCTION_TABLE_iiiii[index&7](a1|0,a2|0,a3|0,a4|0)|0;
}


function dynCall_vii(index,a1,a2) {
  index = index|0;
  a1=a1|0; a2=a2|0;
  FUNCTION_TABLE_vii[index&3](a1|0,a2|0);
}


function dynCall_iii(index,a1,a2) {
  index = index|0;
  a1=a1|0; a2=a2|0;
  return FUNCTION_TABLE_iii[index&1](a1|0,a2|0)|0;
}


function dynCall_viiii(index,a1,a2,a3,a4) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  FUNCTION_TABLE_viiii[index&7](a1|0,a2|0,a3|0,a4|0);
}

function b0(p0,p1,p2) { p0 = p0|0;p1 = p1|0;p2 = p2|0; abort(0);return 0; }
function b1(p0,p1,p2,p3) { p0 = p0|0;p1 = p1|0;p2 = p2|0;p3 = p3|0; abort(1);return 0; }
function b2(p0,p1) { p0 = p0|0;p1 = p1|0; abort(2); }
function b3(p0,p1) { p0 = p0|0;p1 = p1|0; abort(3);return 0; }
function b4(p0,p1,p2,p3) { p0 = p0|0;p1 = p1|0;p2 = p2|0;p3 = p3|0; abort(4); }
function _init_xrpow_core_sse__wrapper(p0,p1,p2,p3) { p0 = p0|0;p1 = p1|0;p2 = p2|0;p3 = p3|0; _init_xrpow_core_sse(p0|0,p1|0,p2|0,p3|0); }

// EMSCRIPTEN_END_FUNCS
var FUNCTION_TABLE_iiii = [b0,_sn_write,_choose_table_nonMMX,b0];
var FUNCTION_TABLE_iiiii = [b1,_count_bit_null,_count_bit_noESC,_count_bit_noESC_from2,_count_bit_noESC_from3,b1,b1,b1];
var FUNCTION_TABLE_vii = [b2,_fht,_lame_report_def,b2];
var FUNCTION_TABLE_iii = [b3,_floatcompare];
var FUNCTION_TABLE_viiii = [b4,_VBR_new_iteration_loop,_VBR_old_iteration_loop,_CBR_iteration_loop,_ABR_iteration_loop,_init_xrpow_core_sse__wrapper,_init_xrpow_core_c,b4];

  return { _i64Subtract: _i64Subtract, _lame_set_brate: _lame_set_brate, _lame_encode_buffer_ieee_float: _lame_encode_buffer_ieee_float, _lame_close: _lame_close, _lame_set_in_samplerate: _lame_set_in_samplerate, _i64Add: _i64Add, _lame_set_num_channels: _lame_set_num_channels, _strlen: _strlen, _memset: _memset, _malloc: _malloc, _memcpy: _memcpy, _lame_init: _lame_init, _bitshift64Lshr: _bitshift64Lshr, _free: _free, _lame_init_params: _lame_init_params, _lame_encode_flush: _lame_encode_flush, _bitshift64Shl: _bitshift64Shl, _lame_set_mode: _lame_set_mode, runPostSets: runPostSets, stackAlloc: stackAlloc, stackSave: stackSave, stackRestore: stackRestore, establishStackSpace: establishStackSpace, setThrew: setThrew, setTempRet0: setTempRet0, getTempRet0: getTempRet0, dynCall_iiii: dynCall_iiii, dynCall_iiiii: dynCall_iiiii, dynCall_vii: dynCall_vii, dynCall_iii: dynCall_iii, dynCall_viiii: dynCall_viiii };
})
// EMSCRIPTEN_END_ASM
(Module.asmGlobalArg, Module.asmLibraryArg, buffer);
var _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"];
var _lame_set_brate = Module["_lame_set_brate"] = asm["_lame_set_brate"];
var _lame_encode_buffer_ieee_float = Module["_lame_encode_buffer_ieee_float"] = asm["_lame_encode_buffer_ieee_float"];
var runPostSets = Module["runPostSets"] = asm["runPostSets"];
var _lame_close = Module["_lame_close"] = asm["_lame_close"];
var _lame_set_in_samplerate = Module["_lame_set_in_samplerate"] = asm["_lame_set_in_samplerate"];
var _i64Add = Module["_i64Add"] = asm["_i64Add"];
var _lame_set_num_channels = Module["_lame_set_num_channels"] = asm["_lame_set_num_channels"];
var _strlen = Module["_strlen"] = asm["_strlen"];
var _memset = Module["_memset"] = asm["_memset"];
var _malloc = Module["_malloc"] = asm["_malloc"];
var _lame_set_mode = Module["_lame_set_mode"] = asm["_lame_set_mode"];
var _memcpy = Module["_memcpy"] = asm["_memcpy"];
var _lame_init = Module["_lame_init"] = asm["_lame_init"];
var _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
var _free = Module["_free"] = asm["_free"];
var _lame_init_params = Module["_lame_init_params"] = asm["_lame_init_params"];
var _lame_encode_flush = Module["_lame_encode_flush"] = asm["_lame_encode_flush"];
var _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"];
var dynCall_iiii = Module["dynCall_iiii"] = asm["dynCall_iiii"];
var dynCall_iiiii = Module["dynCall_iiiii"] = asm["dynCall_iiiii"];
var dynCall_vii = Module["dynCall_vii"] = asm["dynCall_vii"];
var dynCall_iii = Module["dynCall_iii"] = asm["dynCall_iii"];
var dynCall_viiii = Module["dynCall_viiii"] = asm["dynCall_viiii"];
;

Runtime.stackAlloc = asm['stackAlloc'];
Runtime.stackSave = asm['stackSave'];
Runtime.stackRestore = asm['stackRestore'];
Runtime.establishStackSpace = asm['establishStackSpace'];

Runtime.setTempRet0 = asm['setTempRet0'];
Runtime.getTempRet0 = asm['getTempRet0'];


// TODO: strip out parts of this we do not need

//======= begin closure i64 code =======

// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines a Long class for representing a 64-bit two's-complement
 * integer value, which faithfully simulates the behavior of a Java "long". This
 * implementation is derived from LongLib in GWT.
 *
 */

var i64Math = (function() { // Emscripten wrapper
  var goog = { math: {} };


  /**
   * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
   * values as *signed* integers.  See the from* functions below for more
   * convenient ways of constructing Longs.
   *
   * The internal representation of a long is the two given signed, 32-bit values.
   * We use 32-bit pieces because these are the size of integers on which
   * Javascript performs bit-operations.  For operations like addition and
   * multiplication, we split each number into 16-bit pieces, which can easily be
   * multiplied within Javascript's floating-point representation without overflow
   * or change in sign.
   *
   * In the algorithms below, we frequently reduce the negative case to the
   * positive case by negating the input(s) and then post-processing the result.
   * Note that we must ALWAYS check specially whether those values are MIN_VALUE
   * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
   * a positive number, it overflows back into a negative).  Not handling this
   * case would often result in infinite recursion.
   *
   * @param {number} low  The low (signed) 32 bits of the long.
   * @param {number} high  The high (signed) 32 bits of the long.
   * @constructor
   */
  goog.math.Long = function(low, high) {
    /**
     * @type {number}
     * @private
     */
    this.low_ = low | 0;  // force into 32 signed bits.

    /**
     * @type {number}
     * @private
     */
    this.high_ = high | 0;  // force into 32 signed bits.
  };


  // NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
  // from* methods on which they depend.


  /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @private
   */
  goog.math.Long.IntCache_ = {};


  /**
   * Returns a Long representing the given (32-bit) integer value.
   * @param {number} value The 32-bit integer in question.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromInt = function(value) {
    if (-128 <= value && value < 128) {
      var cachedObj = goog.math.Long.IntCache_[value];
      if (cachedObj) {
        return cachedObj;
      }
    }

    var obj = new goog.math.Long(value | 0, value < 0 ? -1 : 0);
    if (-128 <= value && value < 128) {
      goog.math.Long.IntCache_[value] = obj;
    }
    return obj;
  };


  /**
   * Returns a Long representing the given value, provided that it is a finite
   * number.  Otherwise, zero is returned.
   * @param {number} value The number in question.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromNumber = function(value) {
    if (isNaN(value) || !isFinite(value)) {
      return goog.math.Long.ZERO;
    } else if (value <= -goog.math.Long.TWO_PWR_63_DBL_) {
      return goog.math.Long.MIN_VALUE;
    } else if (value + 1 >= goog.math.Long.TWO_PWR_63_DBL_) {
      return goog.math.Long.MAX_VALUE;
    } else if (value < 0) {
      return goog.math.Long.fromNumber(-value).negate();
    } else {
      return new goog.math.Long(
          (value % goog.math.Long.TWO_PWR_32_DBL_) | 0,
          (value / goog.math.Long.TWO_PWR_32_DBL_) | 0);
    }
  };


  /**
   * Returns a Long representing the 64-bit integer that comes by concatenating
   * the given high and low bits.  Each is assumed to use 32 bits.
   * @param {number} lowBits The low 32-bits.
   * @param {number} highBits The high 32-bits.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromBits = function(lowBits, highBits) {
    return new goog.math.Long(lowBits, highBits);
  };


  /**
   * Returns a Long representation of the given string, written using the given
   * radix.
   * @param {string} str The textual representation of the Long.
   * @param {number=} opt_radix The radix in which the text is written.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromString = function(str, opt_radix) {
    if (str.length == 0) {
      throw Error('number format error: empty string');
    }

    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error('radix out of range: ' + radix);
    }

    if (str.charAt(0) == '-') {
      return goog.math.Long.fromString(str.substring(1), radix).negate();
    } else if (str.indexOf('-') >= 0) {
      throw Error('number format error: interior "-" character: ' + str);
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 8));

    var result = goog.math.Long.ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i);
      var value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = goog.math.Long.fromNumber(Math.pow(radix, size));
        result = result.multiply(power).add(goog.math.Long.fromNumber(value));
      } else {
        result = result.multiply(radixToPower);
        result = result.add(goog.math.Long.fromNumber(value));
      }
    }
    return result;
  };


  // NOTE: the compiler should inline these constant values below and then remove
  // these variables, so there should be no runtime penalty for these.


  /**
   * Number used repeated below in calculations.  This must appear before the
   * first call to any from* function below.
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_16_DBL_ = 1 << 16;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_24_DBL_ = 1 << 24;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_32_DBL_ =
      goog.math.Long.TWO_PWR_16_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_31_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ / 2;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_48_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_64_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_32_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_63_DBL_ =
      goog.math.Long.TWO_PWR_64_DBL_ / 2;


  /** @type {!goog.math.Long} */
  goog.math.Long.ZERO = goog.math.Long.fromInt(0);


  /** @type {!goog.math.Long} */
  goog.math.Long.ONE = goog.math.Long.fromInt(1);


  /** @type {!goog.math.Long} */
  goog.math.Long.NEG_ONE = goog.math.Long.fromInt(-1);


  /** @type {!goog.math.Long} */
  goog.math.Long.MAX_VALUE =
      goog.math.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);


  /** @type {!goog.math.Long} */
  goog.math.Long.MIN_VALUE = goog.math.Long.fromBits(0, 0x80000000 | 0);


  /**
   * @type {!goog.math.Long}
   * @private
   */
  goog.math.Long.TWO_PWR_24_ = goog.math.Long.fromInt(1 << 24);


  /** @return {number} The value, assuming it is a 32-bit integer. */
  goog.math.Long.prototype.toInt = function() {
    return this.low_;
  };


  /** @return {number} The closest floating-point representation to this value. */
  goog.math.Long.prototype.toNumber = function() {
    return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ +
           this.getLowBitsUnsigned();
  };


  /**
   * @param {number=} opt_radix The radix in which the text should be written.
   * @return {string} The textual representation of this value.
   */
  goog.math.Long.prototype.toString = function(opt_radix) {
    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error('radix out of range: ' + radix);
    }

    if (this.isZero()) {
      return '0';
    }

    if (this.isNegative()) {
      if (this.equals(goog.math.Long.MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = goog.math.Long.fromNumber(radix);
        var div = this.div(radixLong);
        var rem = div.multiply(radixLong).subtract(this);
        return div.toString(radix) + rem.toInt().toString(radix);
      } else {
        return '-' + this.negate().toString(radix);
      }
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 6));

    var rem = this;
    var result = '';
    while (true) {
      var remDiv = rem.div(radixToPower);
      var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
      var digits = intval.toString(radix);

      rem = remDiv;
      if (rem.isZero()) {
        return digits + result;
      } else {
        while (digits.length < 6) {
          digits = '0' + digits;
        }
        result = '' + digits + result;
      }
    }
  };


  /** @return {number} The high 32-bits as a signed value. */
  goog.math.Long.prototype.getHighBits = function() {
    return this.high_;
  };


  /** @return {number} The low 32-bits as a signed value. */
  goog.math.Long.prototype.getLowBits = function() {
    return this.low_;
  };


  /** @return {number} The low 32-bits as an unsigned value. */
  goog.math.Long.prototype.getLowBitsUnsigned = function() {
    return (this.low_ >= 0) ?
        this.low_ : goog.math.Long.TWO_PWR_32_DBL_ + this.low_;
  };


  /**
   * @return {number} Returns the number of bits needed to represent the absolute
   *     value of this Long.
   */
  goog.math.Long.prototype.getNumBitsAbs = function() {
    if (this.isNegative()) {
      if (this.equals(goog.math.Long.MIN_VALUE)) {
        return 64;
      } else {
        return this.negate().getNumBitsAbs();
      }
    } else {
      var val = this.high_ != 0 ? this.high_ : this.low_;
      for (var bit = 31; bit > 0; bit--) {
        if ((val & (1 << bit)) != 0) {
          break;
        }
      }
      return this.high_ != 0 ? bit + 33 : bit + 1;
    }
  };


  /** @return {boolean} Whether this value is zero. */
  goog.math.Long.prototype.isZero = function() {
    return this.high_ == 0 && this.low_ == 0;
  };


  /** @return {boolean} Whether this value is negative. */
  goog.math.Long.prototype.isNegative = function() {
    return this.high_ < 0;
  };


  /** @return {boolean} Whether this value is odd. */
  goog.math.Long.prototype.isOdd = function() {
    return (this.low_ & 1) == 1;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long equals the other.
   */
  goog.math.Long.prototype.equals = function(other) {
    return (this.high_ == other.high_) && (this.low_ == other.low_);
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long does not equal the other.
   */
  goog.math.Long.prototype.notEquals = function(other) {
    return (this.high_ != other.high_) || (this.low_ != other.low_);
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is less than the other.
   */
  goog.math.Long.prototype.lessThan = function(other) {
    return this.compare(other) < 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is less than or equal to the other.
   */
  goog.math.Long.prototype.lessThanOrEqual = function(other) {
    return this.compare(other) <= 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is greater than the other.
   */
  goog.math.Long.prototype.greaterThan = function(other) {
    return this.compare(other) > 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is greater than or equal to the other.
   */
  goog.math.Long.prototype.greaterThanOrEqual = function(other) {
    return this.compare(other) >= 0;
  };


  /**
   * Compares this Long with the given one.
   * @param {goog.math.Long} other Long to compare against.
   * @return {number} 0 if they are the same, 1 if the this is greater, and -1
   *     if the given one is greater.
   */
  goog.math.Long.prototype.compare = function(other) {
    if (this.equals(other)) {
      return 0;
    }

    var thisNeg = this.isNegative();
    var otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) {
      return -1;
    }
    if (!thisNeg && otherNeg) {
      return 1;
    }

    // at this point, the signs are the same, so subtraction will not overflow
    if (this.subtract(other).isNegative()) {
      return -1;
    } else {
      return 1;
    }
  };


  /** @return {!goog.math.Long} The negation of this value. */
  goog.math.Long.prototype.negate = function() {
    if (this.equals(goog.math.Long.MIN_VALUE)) {
      return goog.math.Long.MIN_VALUE;
    } else {
      return this.not().add(goog.math.Long.ONE);
    }
  };


  /**
   * Returns the sum of this and the given Long.
   * @param {goog.math.Long} other Long to add to this one.
   * @return {!goog.math.Long} The sum of this and the given Long.
   */
  goog.math.Long.prototype.add = function(other) {
    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 0xFFFF;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 0xFFFF;

    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 0xFFFF;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
  };


  /**
   * Returns the difference of this and the given Long.
   * @param {goog.math.Long} other Long to subtract from this.
   * @return {!goog.math.Long} The difference of this and the given Long.
   */
  goog.math.Long.prototype.subtract = function(other) {
    return this.add(other.negate());
  };


  /**
   * Returns the product of this and the given long.
   * @param {goog.math.Long} other Long to multiply with this.
   * @return {!goog.math.Long} The product of this and the other.
   */
  goog.math.Long.prototype.multiply = function(other) {
    if (this.isZero()) {
      return goog.math.Long.ZERO;
    } else if (other.isZero()) {
      return goog.math.Long.ZERO;
    }

    if (this.equals(goog.math.Long.MIN_VALUE)) {
      return other.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;
    } else if (other.equals(goog.math.Long.MIN_VALUE)) {
      return this.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;
    }

    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().multiply(other.negate());
      } else {
        return this.negate().multiply(other).negate();
      }
    } else if (other.isNegative()) {
      return this.multiply(other.negate()).negate();
    }

    // If both longs are small, use float multiplication
    if (this.lessThan(goog.math.Long.TWO_PWR_24_) &&
        other.lessThan(goog.math.Long.TWO_PWR_24_)) {
      return goog.math.Long.fromNumber(this.toNumber() * other.toNumber());
    }

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 0xFFFF;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 0xFFFF;

    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 0xFFFF;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
  };


  /**
   * Returns this Long divided by the given one.
   * @param {goog.math.Long} other Long by which to divide.
   * @return {!goog.math.Long} This Long divided by the given one.
   */
  goog.math.Long.prototype.div = function(other) {
    if (other.isZero()) {
      throw Error('division by zero');
    } else if (this.isZero()) {
      return goog.math.Long.ZERO;
    }

    if (this.equals(goog.math.Long.MIN_VALUE)) {
      if (other.equals(goog.math.Long.ONE) ||
          other.equals(goog.math.Long.NEG_ONE)) {
        return goog.math.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
      } else if (other.equals(goog.math.Long.MIN_VALUE)) {
        return goog.math.Long.ONE;
      } else {
        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
        var halfThis = this.shiftRight(1);
        var approx = halfThis.div(other).shiftLeft(1);
        if (approx.equals(goog.math.Long.ZERO)) {
          return other.isNegative() ? goog.math.Long.ONE : goog.math.Long.NEG_ONE;
        } else {
          var rem = this.subtract(other.multiply(approx));
          var result = approx.add(rem.div(other));
          return result;
        }
      }
    } else if (other.equals(goog.math.Long.MIN_VALUE)) {
      return goog.math.Long.ZERO;
    }

    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().div(other.negate());
      } else {
        return this.negate().div(other).negate();
      }
    } else if (other.isNegative()) {
      return this.div(other.negate()).negate();
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    var res = goog.math.Long.ZERO;
    var rem = this;
    while (rem.greaterThanOrEqual(other)) {
      // Approximate the result of division. This may be a little greater or
      // smaller than the actual value.
      var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

      // We will tweak the approximate result by changing it in the 48-th digit or
      // the smallest non-fractional digit, whichever is larger.
      var log2 = Math.ceil(Math.log(approx) / Math.LN2);
      var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

      // Decrease the approximation until it is smaller than the remainder.  Note
      // that if it is too large, the product overflows and is negative.
      var approxRes = goog.math.Long.fromNumber(approx);
      var approxRem = approxRes.multiply(other);
      while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
        approx -= delta;
        approxRes = goog.math.Long.fromNumber(approx);
        approxRem = approxRes.multiply(other);
      }

      // We know the answer can't be zero... and actually, zero would cause
      // infinite recursion since we would make no progress.
      if (approxRes.isZero()) {
        approxRes = goog.math.Long.ONE;
      }

      res = res.add(approxRes);
      rem = rem.subtract(approxRem);
    }
    return res;
  };


  /**
   * Returns this Long modulo the given one.
   * @param {goog.math.Long} other Long by which to mod.
   * @return {!goog.math.Long} This Long modulo the given one.
   */
  goog.math.Long.prototype.modulo = function(other) {
    return this.subtract(this.div(other).multiply(other));
  };


  /** @return {!goog.math.Long} The bitwise-NOT of this value. */
  goog.math.Long.prototype.not = function() {
    return goog.math.Long.fromBits(~this.low_, ~this.high_);
  };


  /**
   * Returns the bitwise-AND of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to AND.
   * @return {!goog.math.Long} The bitwise-AND of this and the other.
   */
  goog.math.Long.prototype.and = function(other) {
    return goog.math.Long.fromBits(this.low_ & other.low_,
                                   this.high_ & other.high_);
  };


  /**
   * Returns the bitwise-OR of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to OR.
   * @return {!goog.math.Long} The bitwise-OR of this and the other.
   */
  goog.math.Long.prototype.or = function(other) {
    return goog.math.Long.fromBits(this.low_ | other.low_,
                                   this.high_ | other.high_);
  };


  /**
   * Returns the bitwise-XOR of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to XOR.
   * @return {!goog.math.Long} The bitwise-XOR of this and the other.
   */
  goog.math.Long.prototype.xor = function(other) {
    return goog.math.Long.fromBits(this.low_ ^ other.low_,
                                   this.high_ ^ other.high_);
  };


  /**
   * Returns this Long with bits shifted to the left by the given amount.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the left by the given amount.
   */
  goog.math.Long.prototype.shiftLeft = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var low = this.low_;
      if (numBits < 32) {
        var high = this.high_;
        return goog.math.Long.fromBits(
            low << numBits,
            (high << numBits) | (low >>> (32 - numBits)));
      } else {
        return goog.math.Long.fromBits(0, low << (numBits - 32));
      }
    }
  };


  /**
   * Returns this Long with bits shifted to the right by the given amount.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the right by the given amount.
   */
  goog.math.Long.prototype.shiftRight = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return goog.math.Long.fromBits(
            (low >>> numBits) | (high << (32 - numBits)),
            high >> numBits);
      } else {
        return goog.math.Long.fromBits(
            high >> (numBits - 32),
            high >= 0 ? 0 : -1);
      }
    }
  };


  /**
   * Returns this Long with bits shifted to the right by the given amount, with
   * the new top bits matching the current sign bit.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the right by the given amount, with
   *     zeros placed into the new leading bits.
   */
  goog.math.Long.prototype.shiftRightUnsigned = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return goog.math.Long.fromBits(
            (low >>> numBits) | (high << (32 - numBits)),
            high >>> numBits);
      } else if (numBits == 32) {
        return goog.math.Long.fromBits(high, 0);
      } else {
        return goog.math.Long.fromBits(high >>> (numBits - 32), 0);
      }
    }
  };

  //======= begin jsbn =======

  var navigator = { appName: 'Modern Browser' }; // polyfill a little

  // Copyright (c) 2005  Tom Wu
  // All Rights Reserved.
  // http://www-cs-students.stanford.edu/~tjw/jsbn/

  /*
   * Copyright (c) 2003-2005  Tom Wu
   * All Rights Reserved.
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
   *
   * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
   * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
   * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
   * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
   * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
   * In addition, the following condition applies:
   *
   * All redistributions must retain an intact copy of this copyright notice
   * and disclaimer.
   */

  // Basic JavaScript BN library - subset useful for RSA encryption.

  // Bits per digit
  var dbits;

  // JavaScript engine analysis
  var canary = 0xdeadbeefcafe;
  var j_lm = ((canary&0xffffff)==0xefcafe);

  // (public) Constructor
  function BigInteger(a,b,c) {
    if(a != null)
      if("number" == typeof a) this.fromNumber(a,b,c);
      else if(b == null && "string" != typeof a) this.fromString(a,256);
      else this.fromString(a,b);
  }

  // return new, unset BigInteger
  function nbi() { return new BigInteger(null); }

  // am: Compute w_j += (x*this_i), propagate carries,
  // c is initial carry, returns final carry.
  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
  // We need to select the fastest one that works in this environment.

  // am1: use a single mult and divide to get the high bits,
  // max digit bits should be 26 because
  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
  function am1(i,x,w,j,c,n) {
    while(--n >= 0) {
      var v = x*this[i++]+w[j]+c;
      c = Math.floor(v/0x4000000);
      w[j++] = v&0x3ffffff;
    }
    return c;
  }
  // am2 avoids a big mult-and-extract completely.
  // Max digit bits should be <= 30 because we do bitwise ops
  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
  function am2(i,x,w,j,c,n) {
    var xl = x&0x7fff, xh = x>>15;
    while(--n >= 0) {
      var l = this[i]&0x7fff;
      var h = this[i++]>>15;
      var m = xh*l+h*xl;
      l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
      c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
      w[j++] = l&0x3fffffff;
    }
    return c;
  }
  // Alternately, set max digit bits to 28 since some
  // browsers slow down when dealing with 32-bit numbers.
  function am3(i,x,w,j,c,n) {
    var xl = x&0x3fff, xh = x>>14;
    while(--n >= 0) {
      var l = this[i]&0x3fff;
      var h = this[i++]>>14;
      var m = xh*l+h*xl;
      l = xl*l+((m&0x3fff)<<14)+w[j]+c;
      c = (l>>28)+(m>>14)+xh*h;
      w[j++] = l&0xfffffff;
    }
    return c;
  }
  if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
    BigInteger.prototype.am = am2;
    dbits = 30;
  }
  else if(j_lm && (navigator.appName != "Netscape")) {
    BigInteger.prototype.am = am1;
    dbits = 26;
  }
  else { // Mozilla/Netscape seems to prefer am3
    BigInteger.prototype.am = am3;
    dbits = 28;
  }

  BigInteger.prototype.DB = dbits;
  BigInteger.prototype.DM = ((1<<dbits)-1);
  BigInteger.prototype.DV = (1<<dbits);

  var BI_FP = 52;
  BigInteger.prototype.FV = Math.pow(2,BI_FP);
  BigInteger.prototype.F1 = BI_FP-dbits;
  BigInteger.prototype.F2 = 2*dbits-BI_FP;

  // Digit conversions
  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
  var BI_RC = new Array();
  var rr,vv;
  rr = "0".charCodeAt(0);
  for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
  rr = "a".charCodeAt(0);
  for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
  rr = "A".charCodeAt(0);
  for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

  function int2char(n) { return BI_RM.charAt(n); }
  function intAt(s,i) {
    var c = BI_RC[s.charCodeAt(i)];
    return (c==null)?-1:c;
  }

  // (protected) copy this to r
  function bnpCopyTo(r) {
    for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
    r.t = this.t;
    r.s = this.s;
  }

  // (protected) set from integer value x, -DV <= x < DV
  function bnpFromInt(x) {
    this.t = 1;
    this.s = (x<0)?-1:0;
    if(x > 0) this[0] = x;
    else if(x < -1) this[0] = x+DV;
    else this.t = 0;
  }

  // return bigint initialized to value
  function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

  // (protected) set from string and radix
  function bnpFromString(s,b) {
    var k;
    if(b == 16) k = 4;
    else if(b == 8) k = 3;
    else if(b == 256) k = 8; // byte array
    else if(b == 2) k = 1;
    else if(b == 32) k = 5;
    else if(b == 4) k = 2;
    else { this.fromRadix(s,b); return; }
    this.t = 0;
    this.s = 0;
    var i = s.length, mi = false, sh = 0;
    while(--i >= 0) {
      var x = (k==8)?s[i]&0xff:intAt(s,i);
      if(x < 0) {
        if(s.charAt(i) == "-") mi = true;
        continue;
      }
      mi = false;
      if(sh == 0)
        this[this.t++] = x;
      else if(sh+k > this.DB) {
        this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
        this[this.t++] = (x>>(this.DB-sh));
      }
      else
        this[this.t-1] |= x<<sh;
      sh += k;
      if(sh >= this.DB) sh -= this.DB;
    }
    if(k == 8 && (s[0]&0x80) != 0) {
      this.s = -1;
      if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
    }
    this.clamp();
    if(mi) BigInteger.ZERO.subTo(this,this);
  }

  // (protected) clamp off excess high words
  function bnpClamp() {
    var c = this.s&this.DM;
    while(this.t > 0 && this[this.t-1] == c) --this.t;
  }

  // (public) return string representation in given radix
  function bnToString(b) {
    if(this.s < 0) return "-"+this.negate().toString(b);
    var k;
    if(b == 16) k = 4;
    else if(b == 8) k = 3;
    else if(b == 2) k = 1;
    else if(b == 32) k = 5;
    else if(b == 4) k = 2;
    else return this.toRadix(b);
    var km = (1<<k)-1, d, m = false, r = "", i = this.t;
    var p = this.DB-(i*this.DB)%k;
    if(i-- > 0) {
      if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
      while(i >= 0) {
        if(p < k) {
          d = (this[i]&((1<<p)-1))<<(k-p);
          d |= this[--i]>>(p+=this.DB-k);
        }
        else {
          d = (this[i]>>(p-=k))&km;
          if(p <= 0) { p += this.DB; --i; }
        }
        if(d > 0) m = true;
        if(m) r += int2char(d);
      }
    }
    return m?r:"0";
  }

  // (public) -this
  function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

  // (public) |this|
  function bnAbs() { return (this.s<0)?this.negate():this; }

  // (public) return + if this > a, - if this < a, 0 if equal
  function bnCompareTo(a) {
    var r = this.s-a.s;
    if(r != 0) return r;
    var i = this.t;
    r = i-a.t;
    if(r != 0) return (this.s<0)?-r:r;
    while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
    return 0;
  }

  // returns bit length of the integer x
  function nbits(x) {
    var r = 1, t;
    if((t=x>>>16) != 0) { x = t; r += 16; }
    if((t=x>>8) != 0) { x = t; r += 8; }
    if((t=x>>4) != 0) { x = t; r += 4; }
    if((t=x>>2) != 0) { x = t; r += 2; }
    if((t=x>>1) != 0) { x = t; r += 1; }
    return r;
  }

  // (public) return the number of bits in "this"
  function bnBitLength() {
    if(this.t <= 0) return 0;
    return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
  }

  // (protected) r = this << n*DB
  function bnpDLShiftTo(n,r) {
    var i;
    for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
    for(i = n-1; i >= 0; --i) r[i] = 0;
    r.t = this.t+n;
    r.s = this.s;
  }

  // (protected) r = this >> n*DB
  function bnpDRShiftTo(n,r) {
    for(var i = n; i < this.t; ++i) r[i-n] = this[i];
    r.t = Math.max(this.t-n,0);
    r.s = this.s;
  }

  // (protected) r = this << n
  function bnpLShiftTo(n,r) {
    var bs = n%this.DB;
    var cbs = this.DB-bs;
    var bm = (1<<cbs)-1;
    var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
    for(i = this.t-1; i >= 0; --i) {
      r[i+ds+1] = (this[i]>>cbs)|c;
      c = (this[i]&bm)<<bs;
    }
    for(i = ds-1; i >= 0; --i) r[i] = 0;
    r[ds] = c;
    r.t = this.t+ds+1;
    r.s = this.s;
    r.clamp();
  }

  // (protected) r = this >> n
  function bnpRShiftTo(n,r) {
    r.s = this.s;
    var ds = Math.floor(n/this.DB);
    if(ds >= this.t) { r.t = 0; return; }
    var bs = n%this.DB;
    var cbs = this.DB-bs;
    var bm = (1<<bs)-1;
    r[0] = this[ds]>>bs;
    for(var i = ds+1; i < this.t; ++i) {
      r[i-ds-1] |= (this[i]&bm)<<cbs;
      r[i-ds] = this[i]>>bs;
    }
    if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
    r.t = this.t-ds;
    r.clamp();
  }

  // (protected) r = this - a
  function bnpSubTo(a,r) {
    var i = 0, c = 0, m = Math.min(a.t,this.t);
    while(i < m) {
      c += this[i]-a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    if(a.t < this.t) {
      c -= a.s;
      while(i < this.t) {
        c += this[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else {
      c += this.s;
      while(i < a.t) {
        c -= a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c -= a.s;
    }
    r.s = (c<0)?-1:0;
    if(c < -1) r[i++] = this.DV+c;
    else if(c > 0) r[i++] = c;
    r.t = i;
    r.clamp();
  }

  // (protected) r = this * a, r != this,a (HAC 14.12)
  // "this" should be the larger one if appropriate.
  function bnpMultiplyTo(a,r) {
    var x = this.abs(), y = a.abs();
    var i = x.t;
    r.t = i+y.t;
    while(--i >= 0) r[i] = 0;
    for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
    r.s = 0;
    r.clamp();
    if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
  }

  // (protected) r = this^2, r != this (HAC 14.16)
  function bnpSquareTo(r) {
    var x = this.abs();
    var i = r.t = 2*x.t;
    while(--i >= 0) r[i] = 0;
    for(i = 0; i < x.t-1; ++i) {
      var c = x.am(i,x[i],r,2*i,0,1);
      if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
        r[i+x.t] -= x.DV;
        r[i+x.t+1] = 1;
      }
    }
    if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
    r.s = 0;
    r.clamp();
  }

  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
  // r != q, this != m.  q or r may be null.
  function bnpDivRemTo(m,q,r) {
    var pm = m.abs();
    if(pm.t <= 0) return;
    var pt = this.abs();
    if(pt.t < pm.t) {
      if(q != null) q.fromInt(0);
      if(r != null) this.copyTo(r);
      return;
    }
    if(r == null) r = nbi();
    var y = nbi(), ts = this.s, ms = m.s;
    var nsh = this.DB-nbits(pm[pm.t-1]);	// normalize modulus
    if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
    else { pm.copyTo(y); pt.copyTo(r); }
    var ys = y.t;
    var y0 = y[ys-1];
    if(y0 == 0) return;
    var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
    var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
    var i = r.t, j = i-ys, t = (q==null)?nbi():q;
    y.dlShiftTo(j,t);
    if(r.compareTo(t) >= 0) {
      r[r.t++] = 1;
      r.subTo(t,r);
    }
    BigInteger.ONE.dlShiftTo(ys,t);
    t.subTo(y,y);	// "negative" y so we can replace sub with am later
    while(y.t < ys) y[y.t++] = 0;
    while(--j >= 0) {
      // Estimate quotient digit
      var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
      if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
        y.dlShiftTo(j,t);
        r.subTo(t,r);
        while(r[i] < --qd) r.subTo(t,r);
      }
    }
    if(q != null) {
      r.drShiftTo(ys,q);
      if(ts != ms) BigInteger.ZERO.subTo(q,q);
    }
    r.t = ys;
    r.clamp();
    if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
    if(ts < 0) BigInteger.ZERO.subTo(r,r);
  }

  // (public) this mod a
  function bnMod(a) {
    var r = nbi();
    this.abs().divRemTo(a,null,r);
    if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
    return r;
  }

  // Modular reduction using "classic" algorithm
  function Classic(m) { this.m = m; }
  function cConvert(x) {
    if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
    else return x;
  }
  function cRevert(x) { return x; }
  function cReduce(x) { x.divRemTo(this.m,null,x); }
  function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
  function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

  Classic.prototype.convert = cConvert;
  Classic.prototype.revert = cRevert;
  Classic.prototype.reduce = cReduce;
  Classic.prototype.mulTo = cMulTo;
  Classic.prototype.sqrTo = cSqrTo;

  // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
  // justification:
  //         xy == 1 (mod m)
  //         xy =  1+km
  //   xy(2-xy) = (1+km)(1-km)
  // x[y(2-xy)] = 1-k^2m^2
  // x[y(2-xy)] == 1 (mod m^2)
  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
  // JS multiply "overflows" differently from C/C++, so care is needed here.
  function bnpInvDigit() {
    if(this.t < 1) return 0;
    var x = this[0];
    if((x&1) == 0) return 0;
    var y = x&3;		// y == 1/x mod 2^2
    y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
    y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
    y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
    // last step - calculate inverse mod DV directly;
    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
    y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
    // we really want the negative inverse, and -DV < y < DV
    return (y>0)?this.DV-y:-y;
  }

  // Montgomery reduction
  function Montgomery(m) {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp&0x7fff;
    this.mph = this.mp>>15;
    this.um = (1<<(m.DB-15))-1;
    this.mt2 = 2*m.t;
  }

  // xR mod m
  function montConvert(x) {
    var r = nbi();
    x.abs().dlShiftTo(this.m.t,r);
    r.divRemTo(this.m,null,r);
    if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
    return r;
  }

  // x/R mod m
  function montRevert(x) {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }

  // x = x/R mod m (HAC 14.32)
  function montReduce(x) {
    while(x.t <= this.mt2)	// pad x so am has enough room later
      x[x.t++] = 0;
    for(var i = 0; i < this.m.t; ++i) {
      // faster way of calculating u0 = x[i]*mp mod DV
      var j = x[i]&0x7fff;
      var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
      // use am to combine the multiply-shift-add into one call
      j = i+this.m.t;
      x[j] += this.m.am(0,u0,x,i,0,this.m.t);
      // propagate carry
      while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
    }
    x.clamp();
    x.drShiftTo(this.m.t,x);
    if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
  }

  // r = "x^2/R mod m"; x != r
  function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

  // r = "xy/R mod m"; x,y != r
  function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

  Montgomery.prototype.convert = montConvert;
  Montgomery.prototype.revert = montRevert;
  Montgomery.prototype.reduce = montReduce;
  Montgomery.prototype.mulTo = montMulTo;
  Montgomery.prototype.sqrTo = montSqrTo;

  // (protected) true iff this is even
  function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

  // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
  function bnpExp(e,z) {
    if(e > 0xffffffff || e < 1) return BigInteger.ONE;
    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
    g.copyTo(r);
    while(--i >= 0) {
      z.sqrTo(r,r2);
      if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
      else { var t = r; r = r2; r2 = t; }
    }
    return z.revert(r);
  }

  // (public) this^e % m, 0 <= e < 2^32
  function bnModPowInt(e,m) {
    var z;
    if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
    return this.exp(e,z);
  }

  // protected
  BigInteger.prototype.copyTo = bnpCopyTo;
  BigInteger.prototype.fromInt = bnpFromInt;
  BigInteger.prototype.fromString = bnpFromString;
  BigInteger.prototype.clamp = bnpClamp;
  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
  BigInteger.prototype.drShiftTo = bnpDRShiftTo;
  BigInteger.prototype.lShiftTo = bnpLShiftTo;
  BigInteger.prototype.rShiftTo = bnpRShiftTo;
  BigInteger.prototype.subTo = bnpSubTo;
  BigInteger.prototype.multiplyTo = bnpMultiplyTo;
  BigInteger.prototype.squareTo = bnpSquareTo;
  BigInteger.prototype.divRemTo = bnpDivRemTo;
  BigInteger.prototype.invDigit = bnpInvDigit;
  BigInteger.prototype.isEven = bnpIsEven;
  BigInteger.prototype.exp = bnpExp;

  // public
  BigInteger.prototype.toString = bnToString;
  BigInteger.prototype.negate = bnNegate;
  BigInteger.prototype.abs = bnAbs;
  BigInteger.prototype.compareTo = bnCompareTo;
  BigInteger.prototype.bitLength = bnBitLength;
  BigInteger.prototype.mod = bnMod;
  BigInteger.prototype.modPowInt = bnModPowInt;

  // "constants"
  BigInteger.ZERO = nbv(0);
  BigInteger.ONE = nbv(1);

  // jsbn2 stuff

  // (protected) convert from radix string
  function bnpFromRadix(s,b) {
    this.fromInt(0);
    if(b == null) b = 10;
    var cs = this.chunkSize(b);
    var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
    for(var i = 0; i < s.length; ++i) {
      var x = intAt(s,i);
      if(x < 0) {
        if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
        continue;
      }
      w = b*w+x;
      if(++j >= cs) {
        this.dMultiply(d);
        this.dAddOffset(w,0);
        j = 0;
        w = 0;
      }
    }
    if(j > 0) {
      this.dMultiply(Math.pow(b,j));
      this.dAddOffset(w,0);
    }
    if(mi) BigInteger.ZERO.subTo(this,this);
  }

  // (protected) return x s.t. r^x < DV
  function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

  // (public) 0 if this == 0, 1 if this > 0
  function bnSigNum() {
    if(this.s < 0) return -1;
    else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
    else return 1;
  }

  // (protected) this *= n, this >= 0, 1 < n < DV
  function bnpDMultiply(n) {
    this[this.t] = this.am(0,n-1,this,0,0,this.t);
    ++this.t;
    this.clamp();
  }

  // (protected) this += n << w words, this >= 0
  function bnpDAddOffset(n,w) {
    if(n == 0) return;
    while(this.t <= w) this[this.t++] = 0;
    this[w] += n;
    while(this[w] >= this.DV) {
      this[w] -= this.DV;
      if(++w >= this.t) this[this.t++] = 0;
      ++this[w];
    }
  }

  // (protected) convert to radix string
  function bnpToRadix(b) {
    if(b == null) b = 10;
    if(this.signum() == 0 || b < 2 || b > 36) return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b,cs);
    var d = nbv(a), y = nbi(), z = nbi(), r = "";
    this.divRemTo(d,y,z);
    while(y.signum() > 0) {
      r = (a+z.intValue()).toString(b).substr(1) + r;
      y.divRemTo(d,y,z);
    }
    return z.intValue().toString(b) + r;
  }

  // (public) return value as integer
  function bnIntValue() {
    if(this.s < 0) {
      if(this.t == 1) return this[0]-this.DV;
      else if(this.t == 0) return -1;
    }
    else if(this.t == 1) return this[0];
    else if(this.t == 0) return 0;
    // assumes 16 < DB < 32
    return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
  }

  // (protected) r = this + a
  function bnpAddTo(a,r) {
    var i = 0, c = 0, m = Math.min(a.t,this.t);
    while(i < m) {
      c += this[i]+a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    if(a.t < this.t) {
      c += a.s;
      while(i < this.t) {
        c += this[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else {
      c += this.s;
      while(i < a.t) {
        c += a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += a.s;
    }
    r.s = (c<0)?-1:0;
    if(c > 0) r[i++] = c;
    else if(c < -1) r[i++] = this.DV+c;
    r.t = i;
    r.clamp();
  }

  BigInteger.prototype.fromRadix = bnpFromRadix;
  BigInteger.prototype.chunkSize = bnpChunkSize;
  BigInteger.prototype.signum = bnSigNum;
  BigInteger.prototype.dMultiply = bnpDMultiply;
  BigInteger.prototype.dAddOffset = bnpDAddOffset;
  BigInteger.prototype.toRadix = bnpToRadix;
  BigInteger.prototype.intValue = bnIntValue;
  BigInteger.prototype.addTo = bnpAddTo;

  //======= end jsbn =======

  // Emscripten wrapper
  var Wrapper = {
    abs: function(l, h) {
      var x = new goog.math.Long(l, h);
      var ret;
      if (x.isNegative()) {
        ret = x.negate();
      } else {
        ret = x;
      }
      HEAP32[tempDoublePtr>>2] = ret.low_;
      HEAP32[tempDoublePtr+4>>2] = ret.high_;
    },
    ensureTemps: function() {
      if (Wrapper.ensuredTemps) return;
      Wrapper.ensuredTemps = true;
      Wrapper.two32 = new BigInteger();
      Wrapper.two32.fromString('4294967296', 10);
      Wrapper.two64 = new BigInteger();
      Wrapper.two64.fromString('18446744073709551616', 10);
      Wrapper.temp1 = new BigInteger();
      Wrapper.temp2 = new BigInteger();
    },
    lh2bignum: function(l, h) {
      var a = new BigInteger();
      a.fromString(h.toString(), 10);
      var b = new BigInteger();
      a.multiplyTo(Wrapper.two32, b);
      var c = new BigInteger();
      c.fromString(l.toString(), 10);
      var d = new BigInteger();
      c.addTo(b, d);
      return d;
    },
    stringify: function(l, h, unsigned) {
      var ret = new goog.math.Long(l, h).toString();
      if (unsigned && ret[0] == '-') {
        // unsign slowly using jsbn bignums
        Wrapper.ensureTemps();
        var bignum = new BigInteger();
        bignum.fromString(ret, 10);
        ret = new BigInteger();
        Wrapper.two64.addTo(bignum, ret);
        ret = ret.toString(10);
      }
      return ret;
    },
    fromString: function(str, base, min, max, unsigned) {
      Wrapper.ensureTemps();
      var bignum = new BigInteger();
      bignum.fromString(str, base);
      var bigmin = new BigInteger();
      bigmin.fromString(min, 10);
      var bigmax = new BigInteger();
      bigmax.fromString(max, 10);
      if (unsigned && bignum.compareTo(BigInteger.ZERO) < 0) {
        var temp = new BigInteger();
        bignum.addTo(Wrapper.two64, temp);
        bignum = temp;
      }
      var error = false;
      if (bignum.compareTo(bigmin) < 0) {
        bignum = bigmin;
        error = true;
      } else if (bignum.compareTo(bigmax) > 0) {
        bignum = bigmax;
        error = true;
      }
      var ret = goog.math.Long.fromString(bignum.toString()); // min-max checks should have clamped this to a range goog.math.Long can handle well
      HEAP32[tempDoublePtr>>2] = ret.low_;
      HEAP32[tempDoublePtr+4>>2] = ret.high_;
      if (error) throw 'range error';
    }
  };
  return Wrapper;
})();

//======= end closure i64 code =======



// === Auto-generated postamble setup entry stuff ===


function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
};
ExitStatus.prototype = new Error();
ExitStatus.prototype.constructor = ExitStatus;

var initialStackTop;
var preloadStartTime = null;
var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!Module['calledRun']) run();
  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
}

Module['callMain'] = Module.callMain = function callMain(args) {
  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on __ATMAIN__)');
  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');

  args = args || [];

  ensureInitRuntime();

  var argc = args.length+1;
  function pad() {
    for (var i = 0; i < 4-1; i++) {
      argv.push(0);
    }
  }
  var argv = [allocate(intArrayFromString(Module['thisProgram']), 'i8', ALLOC_NORMAL) ];
  pad();
  for (var i = 0; i < argc-1; i = i + 1) {
    argv.push(allocate(intArrayFromString(args[i]), 'i8', ALLOC_NORMAL));
    pad();
  }
  argv.push(0);
  argv = allocate(argv, 'i32', ALLOC_NORMAL);

  initialStackTop = STACKTOP;

  try {

    var ret = Module['_main'](argc, argv, 0);


    // if we're not running an evented main loop, it's time to exit
    exit(ret, /* implicit = */ true);
  }
  catch(e) {
    if (e instanceof ExitStatus) {
      // exit() throws this once it's done to make sure execution
      // has been stopped completely
      return;
    } else if (e == 'SimulateInfiniteLoop') {
      // running an evented main loop, don't immediately exit
      Module['noExitRuntime'] = true;
      return;
    } else {
      if (e && typeof e === 'object' && e.stack) Module.printErr('exception thrown: ' + [e, e.stack]);
      throw e;
    }
  } finally {
    calledMain = true;
  }
}




function run(args) {
  args = args || Module['arguments'];

  if (preloadStartTime === null) preloadStartTime = Date.now();

  if (runDependencies > 0) {
    return;
  }

  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later
  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

  function doRun() {
    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening
    Module['calledRun'] = true;

    if (ABORT) return; 

    ensureInitRuntime();

    preMain();

    if (ENVIRONMENT_IS_WEB && preloadStartTime !== null) {
      Module.printErr('pre-main prep time: ' + (Date.now() - preloadStartTime) + ' ms');
    }

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    if (Module['_main'] && shouldRunNow) Module['callMain'](args);

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else {
    doRun();
  }
}
Module['run'] = Module.run = run;

function exit(status, implicit) {
  if (implicit && Module['noExitRuntime']) {
    return;
  }

  if (Module['noExitRuntime']) {
  } else {

    ABORT = true;
    EXITSTATUS = status;
    STACKTOP = initialStackTop;

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);
  }

  if (ENVIRONMENT_IS_NODE) {
    // Work around a node.js bug where stdout buffer is not flushed at process exit:
    // Instead of process.exit() directly, wait for stdout flush event.
    // See https://github.com/joyent/node/issues/1669 and https://github.com/kripken/emscripten/issues/2582
    // Workaround is based on https://github.com/RReverser/acorn/commit/50ab143cecc9ed71a2d66f78b4aec3bb2e9844f6
    process['stdout']['once']('drain', function () {
      process['exit'](status);
    });
    console.log(' '); // Make sure to print something to force the drain event to occur, in case the stdout buffer was empty.
    // Work around another node bug where sometimes 'drain' is never fired - make another effort
    // to emit the exit status, after a significant delay (if node hasn't fired drain by then, give up)
    setTimeout(function() {
      process['exit'](status);
    }, 500);
  } else
  if (ENVIRONMENT_IS_SHELL && typeof quit === 'function') {
    quit(status);
  }
  // if we reach here, we must throw an exception to halt the current execution
  throw new ExitStatus(status);
}
Module['exit'] = Module.exit = exit;

var abortDecorators = [];

function abort(what) {
  if (what !== undefined) {
    Module.print(what);
    Module.printErr(what);
    what = JSON.stringify(what)
  } else {
    what = '';
  }

  ABORT = true;
  EXITSTATUS = 1;

  var extra = '\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.';

  var output = 'abort(' + what + ') at ' + stackTrace() + extra;
  if (abortDecorators) {
    abortDecorators.forEach(function(decorator) {
      output = decorator(output, what);
    });
  }
  throw output;
}
Module['abort'] = Module.abort = abort;

// {{PRE_RUN_ADDITIONS}}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;
if (Module['noInitialRun']) {
  shouldRunNow = false;
}


run();

// {{POST_RUN_ADDITIONS}}






// {{MODULE_ADDITIONS}}



  var NUM_CH = 2,
      HEAPU8 = Module.HEAPU8,
      malloc = Module._malloc,
      free = Module._free,
      lame_init = Module._lame_init,
      lame_set_mode = Module._lame_set_mode,
      lame_set_num_channels = Module._lame_set_num_channels,
      lame_set_in_samplerate = Module._lame_set_in_samplerate,
      lame_set_brate = Module._lame_set_brate,
      lame_init_params = Module._lame_init_params,
      lame_encode_buffer_ieee_float = Module._lame_encode_buffer_ieee_float,
      lame_encode_flush = Module._lame_encode_flush,
      lame_close = Module._lame_close;

  var Encoder = function(sampleRate, bitRate) {
    this.gfp = lame_init();
    lame_set_mode(this.gfp, 1/*JOINT_STEREO*/);
    lame_set_num_channels(this.gfp, NUM_CH);
    lame_set_in_samplerate(this.gfp, sampleRate);
    lame_set_brate(this.gfp, bitRate);
    lame_init_params(this.gfp);
    this.allocBuffers(8192);
    this.mp3Buffers = [];
  };

  Encoder.prototype.encode = function(buffers) {
    var length = buffers[0].length;
    if (length > this.srcLen) {
      this.freeBuffers();
      this.allocBuffers(length);
    }
    for (var ch = 0; ch < NUM_CH; ++ch)
      this.srcBuf[ch].set(buffers[ch]);
    var nBytes = lame_encode_buffer_ieee_float(
      this.gfp, this.srcPtr[0], this.srcPtr[1], length,
      this.dstPtr, this.dstSz);
    this.mp3Buffers.push(new Uint8Array(this.dstBuf.subarray(0, nBytes)));
  };

  Encoder.prototype.finish = function(mimeType) {
    var nBytes = lame_encode_flush(this.gfp, this.dstPtr, this.dstSz);
    this.mp3Buffers.push(new Uint8Array(this.dstBuf.subarray(0, nBytes)));
    var blob = new Blob(this.mp3Buffers, {type: mimeType || 'audio/mpeg'});
    this.cleanup();
    return blob;
  };

  Encoder.prototype.cancel = Encoder.prototype.cleanup = function() {
    lame_close(this.gfp);
    delete this.gfp;
    delete this.mp3Buffers;
    this.freeBuffers();
  };

  Encoder.prototype.allocBuffers = function(srcLen) {
    this.srcLen = srcLen;
    this.srcPtr = [];
    this.srcBuf = [];
    for (var ch = 0; ch < NUM_CH; ++ch) {
      this.srcPtr[ch] = malloc(this.srcLen * 4);
      this.srcBuf[ch] = new Float32Array(HEAPU8.buffer,
                                         this.srcPtr[ch], this.srcLen);
    }
    this.dstSz = Math.ceil(1.25 * this.srcLen) + 7200;  // see lame.h
    this.dstPtr = malloc(this.dstSz);
    this.dstBuf = new Uint8Array(HEAPU8.buffer, this.dstPtr, this.dstSz);
  };

  Encoder.prototype.freeBuffers = function() {
    delete this.dstBuf;
    delete this.srcBuf;
    free(this.dstPtr);
    for (var ch = 0; ch < NUM_CH; ++ch)
      free(this.srcPtr[ch]);
    delete this.dstPtr;
    delete this.srcPtr;
  };

  self.Mp3LameEncoder = Encoder;
})(self);

;// (this comment fixes a grunt dist issue, do not remove, strix 2016-07-14)
/**
* Fine Uploader
*
* Copyright 2013-present, Widen Enterprises, Inc.
*
* Version: 5.10.0
*
* Homepage: http://fineuploader.com
*
* Repository: git://github.com/FineUploader/fine-uploader.git
*
* Licensed only under the MIT license (http://fineuploader.com/licensing).
*
* Note: this copy of Fine Uploader has been modified to work with DocCirrus GmbH REST API
*/

/*jshint latedef:false, unused:false */
/*global window */

"use strict";

(function(global) {
/*globals window, navigator, document, FormData, File, HTMLInputElement, XMLHttpRequest, Blob, Storage, ActiveXObject */
/* jshint -W079 */
var qq = function(element) {

    return {
        hide: function() {
            element.style.display = "none";
            return this;
        },

        /** Returns the function which detaches attached event */
        attach: function(type, fn) {
            if (element.addEventListener) {
                element.addEventListener(type, fn, false);
            } else if (element.attachEvent) {
                element.attachEvent("on" + type, fn);
            }
            return function() {
                qq(element).detach(type, fn);
            };
        },

        detach: function(type, fn) {
            if (element.removeEventListener) {
                element.removeEventListener(type, fn, false);
            } else if (element.attachEvent) {
                element.detachEvent("on" + type, fn);
            }
            return this;
        },

        contains: function(descendant) {
            // The [W3C spec](http://www.w3.org/TR/domcore/#dom-node-contains)
            // says a `null` (or ostensibly `undefined`) parameter
            // passed into `Node.contains` should result in a false return value.
            // IE7 throws an exception if the parameter is `undefined` though.
            if (!descendant) {
                return false;
            }

            // compareposition returns false in this case
            if (element === descendant) {
                return true;
            }

            if (element.contains) {
                return element.contains(descendant);
            } else {
                /*jslint bitwise: true*/
                return !!(descendant.compareDocumentPosition(element) & 8);
            }
        },

        /**
         * Insert this element before elementB.
         */
        insertBefore: function(elementB) {
            elementB.parentNode.insertBefore(element, elementB);
            return this;
        },

        remove: function() {
            element.parentNode.removeChild(element);
            return this;
        },

        /**
         * Sets styles for an element.
         * Fixes opacity in IE6-8.
         */
        css: function(styles) {
            /*jshint eqnull: true*/
            if (element.style == null) {
                throw new qq.Error("Can't apply style to node as it is not on the HTMLElement prototype chain!");
            }

            /*jshint -W116*/
            if (styles.opacity != null) {
                if (typeof element.style.opacity !== "string" && typeof (element.filters) !== "undefined") {
                    styles.filter = "alpha(opacity=" + Math.round(100 * styles.opacity) + ")";
                }
            }
            qq.extend(element.style, styles);

            return this;
        },

        hasClass: function(name, considerParent) {
            var re = new RegExp("(^| )" + name + "( |$)");
            return re.test(element.className) || !!(considerParent && re.test(element.parentNode.className));
        },

        addClass: function(name) {
            if (!qq(element).hasClass(name)) {
                element.className += " " + name;
            }
            return this;
        },

        removeClass: function(name) {
            var re = new RegExp("(^| )" + name + "( |$)");
            element.className = element.className.replace(re, " ").replace(/^\s+|\s+$/g, "");
            return this;
        },

        getByClass: function(className, first) {
            var candidates,
                result = [];

            if (first && element.querySelector) {
                return element.querySelector("." + className);
            }
            else if (element.querySelectorAll) {
                return element.querySelectorAll("." + className);
            }

            candidates = element.getElementsByTagName("*");

            qq.each(candidates, function(idx, val) {
                if (qq(val).hasClass(className)) {
                    result.push(val);
                }
            });
            return first ? result[0] : result;
        },

        getFirstByClass: function(className) {
            return qq(element).getByClass(className, true);
        },

        children: function() {
            var children = [],
                child = element.firstChild;

            while (child) {
                if (child.nodeType === 1) {
                    children.push(child);
                }
                child = child.nextSibling;
            }

            return children;
        },

        setText: function(text) {
            element.innerText = text;
            element.textContent = text;
            return this;
        },

        clearText: function() {
            return qq(element).setText("");
        },

        // Returns true if the attribute exists on the element
        // AND the value of the attribute is NOT "false" (case-insensitive)
        hasAttribute: function(attrName) {
            var attrVal;

            if (element.hasAttribute) {

                if (!element.hasAttribute(attrName)) {
                    return false;
                }

                /*jshint -W116*/
                return (/^false$/i).exec(element.getAttribute(attrName)) == null;
            }
            else {
                attrVal = element[attrName];

                if (attrVal === undefined) {
                    return false;
                }

                /*jshint -W116*/
                return (/^false$/i).exec(attrVal) == null;
            }
        }
    };
};

(function() {

    qq.canvasToBlob = function(canvas, mime, quality) {
        return qq.dataUriToBlob(canvas.toDataURL(mime, quality));
    };

    qq.dataUriToBlob = function(dataUri) {
        var arrayBuffer, byteString,
            createBlob = function(data, mime) {
                var BlobBuilder = window.BlobBuilder ||
                        window.WebKitBlobBuilder ||
                        window.MozBlobBuilder ||
                        window.MSBlobBuilder,
                    blobBuilder = BlobBuilder && new BlobBuilder();

                if (blobBuilder) {
                    blobBuilder.append(data);
                    return blobBuilder.getBlob(mime);
                }
                else {
                    return new Blob([data], {type: mime});
                }
            },
            intArray, mimeString;

        // convert base64 to raw binary data held in a string
        if (dataUri.split(",")[0].indexOf("base64") >= 0) {
            byteString = atob(dataUri.split(",")[1]);
        }
        else {
            byteString = decodeURI(dataUri.split(",")[1]);
        }

        // extract the MIME
        mimeString = dataUri.split(",")[0]
            .split(":")[1]
            .split(";")[0];

        // write the bytes of the binary string to an ArrayBuffer
        arrayBuffer = new ArrayBuffer(byteString.length);
        intArray = new Uint8Array(arrayBuffer);
        qq.each(byteString, function(idx, character) {
            intArray[idx] = character.charCodeAt(0);
        });

        return createBlob(arrayBuffer, mimeString);
    };

    qq.log = function(message, level) {
        if (window.console) {
            if (!level || level === "info") {
                window.console.log(message);        //jshint ignore:line
            }
            else
            {
                if (window.console[level]) {
                    window.console[level](message);
                }
                else {
                    window.console.log("<" + level + "> " + message);  //jshint ignore:line
                }
            }
        }
    };

    qq.isObject = function(variable) {
        return variable && !variable.nodeType && Object.prototype.toString.call(variable) === "[object Object]";
    };

    qq.isFunction = function(variable) {
        return typeof (variable) === "function";
    };

    /**
     * Check the type of a value.  Is it an "array"?
     *
     * @param value value to test.
     * @returns true if the value is an array or associated with an `ArrayBuffer`
     */
    qq.isArray = function(value) {
        return Object.prototype.toString.call(value) === "[object Array]" ||
            (value && window.ArrayBuffer && value.buffer && value.buffer.constructor === ArrayBuffer);
    };

    // Looks for an object on a `DataTransfer` object that is associated with drop events when utilizing the Filesystem API.
    qq.isItemList = function(maybeItemList) {
        return Object.prototype.toString.call(maybeItemList) === "[object DataTransferItemList]";
    };

    // Looks for an object on a `NodeList` or an `HTMLCollection`|`HTMLFormElement`|`HTMLSelectElement`
    // object that is associated with collections of Nodes.
    qq.isNodeList = function(maybeNodeList) {
        return Object.prototype.toString.call(maybeNodeList) === "[object NodeList]" ||
            // If `HTMLCollection` is the actual type of the object, we must determine this
            // by checking for expected properties/methods on the object
            (maybeNodeList.item && maybeNodeList.namedItem);
    };

    qq.isString = function(maybeString) {
        return Object.prototype.toString.call(maybeString) === "[object String]";
    };

    qq.trimStr = function(string) {
        if (String.prototype.trim) {
            return string.trim();
        }

        return string.replace(/^\s+|\s+$/g, "");
    };

    /**
     * @param str String to format.
     * @returns {string} A string, swapping argument values with the associated occurrence of {} in the passed string.
     */
    qq.format = function(str) {

        var args =  Array.prototype.slice.call(arguments, 1),
            newStr = str,
            nextIdxToReplace = newStr.indexOf("{}");

        qq.each(args, function(idx, val) {
            var strBefore = newStr.substring(0, nextIdxToReplace),
                strAfter = newStr.substring(nextIdxToReplace + 2);

            newStr = strBefore + val + strAfter;
            nextIdxToReplace = newStr.indexOf("{}", nextIdxToReplace + val.length);

            // End the loop if we have run out of tokens (when the arguments exceed the # of tokens)
            if (nextIdxToReplace < 0) {
                return false;
            }
        });

        return newStr;
    };

    qq.isFile = function(maybeFile) {
        return window.File && Object.prototype.toString.call(maybeFile) === "[object File]";
    };

    qq.isFileList = function(maybeFileList) {
        return window.FileList && Object.prototype.toString.call(maybeFileList) === "[object FileList]";
    };

    qq.isFileOrInput = function(maybeFileOrInput) {
        return qq.isFile(maybeFileOrInput) || qq.isInput(maybeFileOrInput);
    };

    qq.isInput = function(maybeInput, notFile) {
        var evaluateType = function(type) {
            var normalizedType = type.toLowerCase();

            if (notFile) {
                return normalizedType !== "file";
            }

            return normalizedType === "file";
        };

        if (window.HTMLInputElement) {
            if (Object.prototype.toString.call(maybeInput) === "[object HTMLInputElement]") {
                if (maybeInput.type && evaluateType(maybeInput.type)) {
                    return true;
                }
            }
        }
        if (maybeInput.tagName) {
            if (maybeInput.tagName.toLowerCase() === "input") {
                if (maybeInput.type && evaluateType(maybeInput.type)) {
                    return true;
                }
            }
        }

        return false;
    };

    qq.isBlob = function(maybeBlob) {
        if (window.Blob && Object.prototype.toString.call(maybeBlob) === "[object Blob]") {
            return true;
        }
    };

    qq.isXhrUploadSupported = function() {
        var input = document.createElement("input");
        input.type = "file";

        return (
            input.multiple !== undefined &&
                typeof File !== "undefined" &&
                typeof FormData !== "undefined" &&
                typeof (qq.createXhrInstance()).upload !== "undefined");
    };

    // Fall back to ActiveX is native XHR is disabled (possible in any version of IE).
    qq.createXhrInstance = function() {
        if (window.XMLHttpRequest) {
            return new XMLHttpRequest();
        }

        try {
            return new ActiveXObject("MSXML2.XMLHTTP.3.0");
        }
        catch (error) {
            qq.log("Neither XHR or ActiveX are supported!", "error");
            return null;
        }
    };

    qq.isFolderDropSupported = function(dataTransfer) {
        return dataTransfer.items &&
            dataTransfer.items.length > 0 &&
            dataTransfer.items[0].webkitGetAsEntry;
    };

    qq.isFileChunkingSupported = function() {
        return !qq.androidStock() && //Android's stock browser cannot upload Blobs correctly
            qq.isXhrUploadSupported() &&
            (File.prototype.slice !== undefined || File.prototype.webkitSlice !== undefined || File.prototype.mozSlice !== undefined);
    };

    qq.sliceBlob = function(fileOrBlob, start, end) {
        var slicer = fileOrBlob.slice || fileOrBlob.mozSlice || fileOrBlob.webkitSlice;

        return slicer.call(fileOrBlob, start, end);
    };

    qq.arrayBufferToHex = function(buffer) {
        var bytesAsHex = "",
            bytes = new Uint8Array(buffer);

        qq.each(bytes, function(idx, byt) {
            var byteAsHexStr = byt.toString(16);

            if (byteAsHexStr.length < 2) {
                byteAsHexStr = "0" + byteAsHexStr;
            }

            bytesAsHex += byteAsHexStr;
        });

        return bytesAsHex;
    };

    qq.readBlobToHex = function(blob, startOffset, length) {
        var initialBlob = qq.sliceBlob(blob, startOffset, startOffset + length),
            fileReader = new FileReader(),
            promise = new qq.Promise();

        fileReader.onload = function() {
            promise.success(qq.arrayBufferToHex(fileReader.result));
        };

        fileReader.onerror = promise.failure;

        fileReader.readAsArrayBuffer(initialBlob);

        return promise;
    };

    qq.extend = function(first, second, extendNested) {
        qq.each(second, function(prop, val) {
            if (extendNested && qq.isObject(val)) {
                if (first[prop] === undefined) {
                    first[prop] = {};
                }
                qq.extend(first[prop], val, true);
            }
            else {
                first[prop] = val;
            }
        });

        return first;
    };

    /**
     * Allow properties in one object to override properties in another,
     * keeping track of the original values from the target object.
     *
     * Note that the pre-overriden properties to be overriden by the source will be passed into the `sourceFn` when it is invoked.
     *
     * @param target Update properties in this object from some source
     * @param sourceFn A function that, when invoked, will return properties that will replace properties with the same name in the target.
     * @returns {object} The target object
     */
    qq.override = function(target, sourceFn) {
        var super_ = {},
            source = sourceFn(super_);

        qq.each(source, function(srcPropName, srcPropVal) {
            if (target[srcPropName] !== undefined) {
                super_[srcPropName] = target[srcPropName];
            }

            target[srcPropName] = srcPropVal;
        });

        return target;
    };

    /**
     * Searches for a given element (elt) in the array, returns -1 if it is not present.
     */
    qq.indexOf = function(arr, elt, from) {
        if (arr.indexOf) {
            return arr.indexOf(elt, from);
        }

        from = from || 0;
        var len = arr.length;

        if (from < 0) {
            from += len;
        }

        for (; from < len; from += 1) {
            if (arr.hasOwnProperty(from) && arr[from] === elt) {
                return from;
            }
        }
        return -1;
    };

    //this is a version 4 UUID
    qq.getUniqueId = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
            /*jslint eqeq: true, bitwise: true*/
            var r = Math.random() * 16 | 0, v = c == "x" ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    };

    //
    // Browsers and platforms detection
    qq.ie = function() {
        return navigator.userAgent.indexOf("MSIE") !== -1 ||
            navigator.userAgent.indexOf("Trident") !== -1;
    };

    qq.ie7 = function() {
        return navigator.userAgent.indexOf("MSIE 7") !== -1;
    };

    qq.ie8 = function() {
        return navigator.userAgent.indexOf("MSIE 8") !== -1;
    };

    qq.ie10 = function() {
        return navigator.userAgent.indexOf("MSIE 10") !== -1;
    };

    qq.ie11 = function() {
        return qq.ie() && navigator.userAgent.indexOf("rv:11") !== -1;
    };

    qq.edge = function() {
        return navigator.userAgent.indexOf("Edge") >= 0;
    };

    qq.safari = function() {
        return navigator.vendor !== undefined && navigator.vendor.indexOf("Apple") !== -1;
    };

    qq.chrome = function() {
        return navigator.vendor !== undefined && navigator.vendor.indexOf("Google") !== -1;
    };

    qq.opera = function() {
        return navigator.vendor !== undefined && navigator.vendor.indexOf("Opera") !== -1;
    };

    qq.firefox = function() {
        return (!qq.edge() && !qq.ie11() && navigator.userAgent.indexOf("Mozilla") !== -1 && navigator.vendor !== undefined && navigator.vendor === "");
    };

    qq.windows = function() {
        return navigator.platform === "Win32";
    };

    qq.android = function() {
        return navigator.userAgent.toLowerCase().indexOf("android") !== -1;
    };

    // We need to identify the Android stock browser via the UA string to work around various bugs in this browser,
    // such as the one that prevents a `Blob` from being uploaded.
    qq.androidStock = function() {
        return qq.android() && navigator.userAgent.toLowerCase().indexOf("chrome") < 0;
    };

    qq.ios6 = function() {
        return qq.ios() && navigator.userAgent.indexOf(" OS 6_") !== -1;
    };

    qq.ios7 = function() {
        return qq.ios() && navigator.userAgent.indexOf(" OS 7_") !== -1;
    };

    qq.ios8 = function() {
        return qq.ios() && navigator.userAgent.indexOf(" OS 8_") !== -1;
    };

    // iOS 8.0.0
    qq.ios800 = function() {
        return qq.ios() && navigator.userAgent.indexOf(" OS 8_0 ") !== -1;
    };

    qq.ios = function() {
        /*jshint -W014 */
        return navigator.userAgent.indexOf("iPad") !== -1
            || navigator.userAgent.indexOf("iPod") !== -1
            || navigator.userAgent.indexOf("iPhone") !== -1;
    };

    qq.iosChrome = function() {
        return qq.ios() && navigator.userAgent.indexOf("CriOS") !== -1;
    };

    qq.iosSafari = function() {
        return qq.ios() && !qq.iosChrome() && navigator.userAgent.indexOf("Safari") !== -1;
    };

    qq.iosSafariWebView = function() {
        return qq.ios() && !qq.iosChrome() && !qq.iosSafari();
    };

    //
    // Events

    qq.preventDefault = function(e) {
        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }
    };

    /**
     * Creates and returns element from html string
     * Uses innerHTML to create an element
     */
    qq.toElement = (function() {
        var div = document.createElement("div");
        return function(html) {
            div.innerHTML = html;
            var element = div.firstChild;
            div.removeChild(element);
            return element;
        };
    }());

    //key and value are passed to callback for each entry in the iterable item
    qq.each = function(iterableItem, callback) {
        var keyOrIndex, retVal;

        if (iterableItem) {
            // Iterate through [`Storage`](http://www.w3.org/TR/webstorage/#the-storage-interface) items
            if (window.Storage && iterableItem.constructor === window.Storage) {
                for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {
                    retVal = callback(iterableItem.key(keyOrIndex), iterableItem.getItem(iterableItem.key(keyOrIndex)));
                    if (retVal === false) {
                        break;
                    }
                }
            }
            // `DataTransferItemList` & `NodeList` objects are array-like and should be treated as arrays
            // when iterating over items inside the object.
            else if (qq.isArray(iterableItem) || qq.isItemList(iterableItem) || qq.isNodeList(iterableItem)) {
                for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {
                    retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);
                    if (retVal === false) {
                        break;
                    }
                }
            }
            else if (qq.isString(iterableItem)) {
                for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {
                    retVal = callback(keyOrIndex, iterableItem.charAt(keyOrIndex));
                    if (retVal === false) {
                        break;
                    }
                }
            }
            else {
                for (keyOrIndex in iterableItem) {
                    if (Object.prototype.hasOwnProperty.call(iterableItem, keyOrIndex)) {
                        retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);
                        if (retVal === false) {
                            break;
                        }
                    }
                }
            }
        }
    };

    //include any args that should be passed to the new function after the context arg
    qq.bind = function(oldFunc, context) {
        if (qq.isFunction(oldFunc)) {
            var args =  Array.prototype.slice.call(arguments, 2);

            return function() {
                var newArgs = qq.extend([], args);
                if (arguments.length) {
                    newArgs = newArgs.concat(Array.prototype.slice.call(arguments));
                }
                return oldFunc.apply(context, newArgs);
            };
        }

        throw new Error("first parameter must be a function!");
    };

    /**
     * obj2url() takes a json-object as argument and generates
     * a querystring. pretty much like jQuery.param()
     *
     * how to use:
     *
     *    `qq.obj2url({a:'b',c:'d'},'http://any.url/upload?otherParam=value');`
     *
     * will result in:
     *
     *    `http://any.url/upload?otherParam=value&a=b&c=d`
     *
     * @param  obj          {Object}    JSON-Object
     * @param  temp         {String}    current querystring-part
     * @param  prefixDone   {String}
     * @return              {String}    encoded querystring
     */
    qq.obj2url = function(obj, temp, prefixDone) {
        /*jshint laxbreak: true*/
        var uristrings = [],
            prefix = "&",
            add = function(nextObj, i) {
                var nextTemp = temp
                    ? (/\[\]$/.test(temp)) // prevent double-encoding
                    ? temp
                    : temp + "[" + i + "]"
                    : i;
                if ((nextTemp !== "undefined") && (i !== "undefined")) {
                    uristrings.push(
                        (typeof nextObj === "object")
                            ? qq.obj2url(nextObj, nextTemp, true)
                            : (Object.prototype.toString.call(nextObj) === "[object Function]")
                            ? encodeURIComponent(nextTemp) + "=" + encodeURIComponent(nextObj())
                            : encodeURIComponent(nextTemp) + "=" + encodeURIComponent(nextObj)
                    );
                }
            };

        if (!prefixDone && temp) {
            prefix = (/\?/.test(temp)) ? (/\?$/.test(temp)) ? "" : "&" : "?";
            uristrings.push(temp);
            uristrings.push(qq.obj2url(obj));
        } else if ((Object.prototype.toString.call(obj) === "[object Array]") && (typeof obj !== "undefined")) {
            qq.each(obj, function(idx, val) {
                add(val, idx);
            });
        } else if ((typeof obj !== "undefined") && (obj !== null) && (typeof obj === "object")) {
            qq.each(obj, function(prop, val) {
                add(val, prop);
            });
        } else {
            uristrings.push(encodeURIComponent(temp) + "=" + encodeURIComponent(obj));
        }

        if (temp) {
            return uristrings.join(prefix);
        } else {
            return uristrings.join(prefix)
                .replace(/^&/, "")
                .replace(/%20/g, "+");
        }
    };

    qq.obj2FormData = function(obj, formData, arrayKeyName) {
        if (!formData) {
            formData = new FormData();
        }

        qq.each(obj, function(key, val) {
            key = arrayKeyName ? arrayKeyName + "[" + key + "]" : key;

            if (qq.isObject(val)) {
                qq.obj2FormData(val, formData, key);
            }
            else if (qq.isFunction(val)) {
                formData.append(key, val());
            }
            else {
                formData.append(key, val);
            }
        });

        return formData;
    };

    qq.obj2Inputs = function(obj, form) {
        var input;

        if (!form) {
            form = document.createElement("form");
        }

        qq.obj2FormData(obj, {
            append: function(key, val) {
                input = document.createElement("input");
                input.setAttribute("name", key);
                input.setAttribute("value", val);
                form.appendChild(input);
            }
        });

        return form;
    };

    /**
     * Not recommended for use outside of Fine Uploader since this falls back to an unchecked eval if JSON.parse is not
     * implemented.  For a more secure JSON.parse polyfill, use Douglas Crockford's json2.js.
     */
    qq.parseJson = function(json) {
        /*jshint evil: true*/
        var intermediate = json;
        if (window.JSON && qq.isFunction(JSON.parse)) {
            intermediate = JSON.parse(json);
        } else {
            intermediate = eval("(" + json + ")");
        }

        //  Doc Cirrus /1/ REST response format places the resonse in .data
        intermediate = intermediate.data ? intermediate.data : intermediate;
        return intermediate;
    };

    /**
     * Retrieve the extension of a file, if it exists.
     *
     * @param filename
     * @returns {string || undefined}
     */
    qq.getExtension = function(filename) {
        var extIdx = filename.lastIndexOf(".") + 1;

        if (extIdx > 0) {
            return filename.substr(extIdx, filename.length - extIdx);
        }
    };

    qq.getFilename = function(blobOrFileInput) {
        /*jslint regexp: true*/

        if (qq.isInput(blobOrFileInput)) {
            // get input value and remove path to normalize
            return blobOrFileInput.value.replace(/.*(\/|\\)/, "");
        }
        else if (qq.isFile(blobOrFileInput)) {
            if (blobOrFileInput.fileName !== null && blobOrFileInput.fileName !== undefined) {
                return blobOrFileInput.fileName;
            }
        }

        return blobOrFileInput.name;
    };

    /**
     * A generic module which supports object disposing in dispose() method.
     * */
    qq.DisposeSupport = function() {
        var disposers = [];

        return {
            /** Run all registered disposers */
            dispose: function() {
                var disposer;
                do {
                    disposer = disposers.shift();
                    if (disposer) {
                        disposer();
                    }
                }
                while (disposer);
            },

            /** Attach event handler and register de-attacher as a disposer */
            attach: function() {
                var args = arguments;
                /*jslint undef:true*/
                this.addDisposer(qq(args[0]).attach.apply(this, Array.prototype.slice.call(arguments, 1)));
            },

            /** Add disposer to the collection */
            addDisposer: function(disposeFunction) {
                disposers.push(disposeFunction);
            }
        };
    };
}());

/* globals qq */
/**
 * Fine Uploader top-level Error container.  Inherits from `Error`.
 */
(function() {
    qq.Error = function(message) {
        this.message = "[Fine Uploader " + qq.version + "] " + message;
    };

    qq.Error.prototype = new Error();
}());

/*global qq */
qq.version = "5.10.0";

/* globals qq */
qq.supportedFeatures = (function() {
    var supportsUploading,
        supportsUploadingBlobs,
        supportsFileDrop,
        supportsAjaxFileUploading,
        supportsFolderDrop,
        supportsChunking,
        supportsResume,
        supportsUploadViaPaste,
        supportsUploadCors,
        supportsDeleteFileXdr,
        supportsDeleteFileCorsXhr,
        supportsDeleteFileCors,
        supportsFolderSelection,
        supportsImagePreviews,
        supportsUploadProgress;

    function testSupportsFileInputElement() {
        var supported = true,
            tempInput;

        try {
            tempInput = document.createElement("input");
            tempInput.type = "file";
            qq(tempInput).hide();

            if (tempInput.disabled) {
                supported = false;
            }
        }
        catch (ex) {
            supported = false;
        }

        return supported;
    }

    //only way to test for Filesystem API support since webkit does not expose the DataTransfer interface
    function isChrome21OrHigher() {
        return (qq.chrome() || qq.opera()) &&
            navigator.userAgent.match(/Chrome\/[2][1-9]|Chrome\/[3-9][0-9]/) !== undefined;
    }

    //only way to test for complete Clipboard API support at this time
    function isChrome14OrHigher() {
        return (qq.chrome() || qq.opera()) &&
            navigator.userAgent.match(/Chrome\/[1][4-9]|Chrome\/[2-9][0-9]/) !== undefined;
    }

    //Ensure we can send cross-origin `XMLHttpRequest`s
    function isCrossOriginXhrSupported() {
        if (window.XMLHttpRequest) {
            var xhr = qq.createXhrInstance();

            //Commonly accepted test for XHR CORS support.
            return xhr.withCredentials !== undefined;
        }

        return false;
    }

    //Test for (terrible) cross-origin ajax transport fallback for IE9 and IE8
    function isXdrSupported() {
        return window.XDomainRequest !== undefined;
    }

    // CORS Ajax requests are supported if it is either possible to send credentialed `XMLHttpRequest`s,
    // or if `XDomainRequest` is an available alternative.
    function isCrossOriginAjaxSupported() {
        if (isCrossOriginXhrSupported()) {
            return true;
        }

        return isXdrSupported();
    }

    function isFolderSelectionSupported() {
        // We know that folder selection is only supported in Chrome via this proprietary attribute for now
        return document.createElement("input").webkitdirectory !== undefined;
    }

    function isLocalStorageSupported() {
        try {
            return !!window.localStorage &&
                // unpatched versions of IE10/11 have buggy impls of localStorage where setItem is a string
                qq.isFunction(window.localStorage.setItem);
        }
        catch (error) {
            // probably caught a security exception, so no localStorage for you
            return false;
        }
    }

    function isDragAndDropSupported() {
        var span = document.createElement("span");

        return ("draggable" in span || ("ondragstart" in span && "ondrop" in span)) &&
            !qq.android() && !qq.ios();
    }

    supportsUploading = testSupportsFileInputElement();

    supportsAjaxFileUploading = supportsUploading && qq.isXhrUploadSupported();

    supportsUploadingBlobs = supportsAjaxFileUploading && !qq.androidStock();

    supportsFileDrop = supportsAjaxFileUploading && isDragAndDropSupported();

    supportsFolderDrop = supportsFileDrop && isChrome21OrHigher();

    supportsChunking = supportsAjaxFileUploading && qq.isFileChunkingSupported();

    supportsResume = supportsAjaxFileUploading && supportsChunking && isLocalStorageSupported();

    supportsUploadViaPaste = supportsAjaxFileUploading && isChrome14OrHigher();

    supportsUploadCors = supportsUploading && (window.postMessage !== undefined || supportsAjaxFileUploading);

    supportsDeleteFileCorsXhr = isCrossOriginXhrSupported();

    supportsDeleteFileXdr = isXdrSupported();

    supportsDeleteFileCors = isCrossOriginAjaxSupported();

    supportsFolderSelection = isFolderSelectionSupported();

    supportsImagePreviews = supportsAjaxFileUploading && window.FileReader !== undefined;

    supportsUploadProgress = (function() {
        if (supportsAjaxFileUploading) {
            return !qq.androidStock() && !qq.iosChrome();
        }
        return false;
    }());

    return {
        ajaxUploading: supportsAjaxFileUploading,
        blobUploading: supportsUploadingBlobs,
        canDetermineSize: supportsAjaxFileUploading,
        chunking: supportsChunking,
        deleteFileCors: supportsDeleteFileCors,
        deleteFileCorsXdr: supportsDeleteFileXdr, //NOTE: will also return true in IE10, where XDR is also supported
        deleteFileCorsXhr: supportsDeleteFileCorsXhr,
        dialogElement: !!window.HTMLDialogElement,
        fileDrop: supportsFileDrop,
        folderDrop: supportsFolderDrop,
        folderSelection: supportsFolderSelection,
        imagePreviews: supportsImagePreviews,
        imageValidation: supportsImagePreviews,
        itemSizeValidation: supportsAjaxFileUploading,
        pause: supportsChunking,
        progressBar: supportsUploadProgress,
        resume: supportsResume,
        scaling: supportsImagePreviews && supportsUploadingBlobs,
        tiffPreviews: qq.safari(), // Not the best solution, but simple and probably accurate enough (for now)
        unlimitedScaledImageSize: !qq.ios(), // false simply indicates that there is some known limit
        uploading: supportsUploading,
        uploadCors: supportsUploadCors,
        uploadCustomHeaders: supportsAjaxFileUploading,
        uploadNonMultipart: supportsAjaxFileUploading,
        uploadViaPaste: supportsUploadViaPaste
    };

}());

/*globals qq*/

// Is the passed object a promise instance?
qq.isGenericPromise = function(maybePromise) {
    return !!(maybePromise && maybePromise.then && qq.isFunction(maybePromise.then));
};

qq.Promise = function() {
    var successArgs, failureArgs,
        successCallbacks = [],
        failureCallbacks = [],
        doneCallbacks = [],
        state = 0;

    qq.extend(this, {
        then: function(onSuccess, onFailure) {
            if (state === 0) {
                if (onSuccess) {
                    successCallbacks.push(onSuccess);
                }
                if (onFailure) {
                    failureCallbacks.push(onFailure);
                }
            }
            else if (state === -1) {
                if ( onFailure ) { onFailure.apply(null, failureArgs); }
            }
            else if (onSuccess) {
                onSuccess.apply(null, successArgs);
            }

            return this;
        },

        done: function(callback) {
            if (state === 0) {
                doneCallbacks.push(callback);
            }
            else {
                callback.apply(null, failureArgs === undefined ? successArgs : failureArgs);
            }

            return this;
        },

        success: function() {
            state = 1;
            successArgs = arguments;

            if (successCallbacks.length) {
                qq.each(successCallbacks, function(idx, callback) {
                    callback.apply(null, successArgs);
                });
            }

            if (doneCallbacks.length) {
                qq.each(doneCallbacks, function(idx, callback) {
                    callback.apply(null, successArgs);
                });
            }

            return this;
        },

        failure: function() {
            state = -1;
            failureArgs = arguments;

            if (failureCallbacks.length) {
                qq.each(failureCallbacks, function(idx, callback) {
                    callback.apply(null, failureArgs);
                });
            }

            if (doneCallbacks.length) {
                qq.each(doneCallbacks, function(idx, callback) {
                    callback.apply(null, failureArgs);
                });
            }

            return this;
        }
    });
};

/* globals qq */
/**
 * Placeholder for a Blob that will be generated on-demand.
 *
 * @param referenceBlob Parent of the generated blob
 * @param onCreate Function to invoke when the blob must be created.  Must be promissory.
 * @constructor
 */
qq.BlobProxy = function(referenceBlob, onCreate) {
    qq.extend(this, {
        referenceBlob: referenceBlob,

        create: function() {
            return onCreate(referenceBlob);
        }
    });
};

/*globals qq*/

/**
 * This module represents an upload or "Select File(s)" button.  It's job is to embed an opaque `<input type="file">`
 * element as a child of a provided "container" element.  This "container" element (`options.element`) is used to provide
 * a custom style for the `<input type="file">` element.  The ability to change the style of the container element is also
 * provided here by adding CSS classes to the container on hover/focus.
 *
 * TODO Eliminate the mouseover and mouseout event handlers since the :hover CSS pseudo-class should now be
 * available on all supported browsers.
 *
 * @param o Options to override the default values
 */
qq.UploadButton = function(o) {
    var self = this,

        disposeSupport = new qq.DisposeSupport(),

        options = {
            // Corresponds to the `accept` attribute on the associated `<input type="file">`
            acceptFiles: null,

            // "Container" element
            element: null,

            focusClass: "qq-upload-button-focus",

            // A true value allows folders to be selected, if supported by the UA
            folders: false,

            // **This option will be removed** in the future as the :hover CSS pseudo-class is available on all supported browsers
            hoverClass: "qq-upload-button-hover",

            ios8BrowserCrashWorkaround: false,

            // If true adds `multiple` attribute to `<input type="file">`
            multiple: false,

            // `name` attribute of `<input type="file">`
            name: "qqfile",

            // Called when the browser invokes the onchange handler on the `<input type="file">`
            onChange: function( /*input */ ) {},

            title: null
        },
        input, buttonId;

    // Overrides any of the default option values with any option values passed in during construction.
    qq.extend(options, o);

    buttonId = qq.getUniqueId();

    // Embed an opaque `<input type="file">` element as a child of `options.element`.
    function createInput() {
        var input = document.createElement("input");

        input.setAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME, buttonId);
        input.setAttribute("title", options.title);

        self.setMultiple(options.multiple, input);

        if (options.folders && qq.supportedFeatures.folderSelection) {
            // selecting directories is only possible in Chrome now, via a vendor-specific prefixed attribute
            input.setAttribute("webkitdirectory", "");
        }

        if (options.acceptFiles) {
            input.setAttribute("accept", options.acceptFiles);
        }

        input.setAttribute("type", "file");
        input.setAttribute("name", options.name);

        qq(input).css({
            position: "absolute",
            // in Opera only 'browse' button
            // is clickable and it is located at
            // the right side of the input
            right: 0,
            top: 0,
            fontFamily: "Arial",
            // It's especially important to make this an arbitrarily large value
            // to ensure the rendered input button in IE takes up the entire
            // space of the container element.  Otherwise, the left side of the
            // button will require a double-click to invoke the file chooser.
            // In other browsers, this might cause other issues, so a large font-size
            // is only used in IE.  There is a bug in IE8 where the opacity style is  ignored
            // in some cases when the font-size is large.  So, this workaround is not applied
            // to IE8.
            fontSize: qq.ie() && !qq.ie8() ? "3500px" : "118px",
            margin: 0,
            padding: 0,
            cursor: "pointer",
            opacity: 0
        });

        // Setting the file input's height to 100% in IE7 causes
        // most of the visible button to be unclickable.
        if ( !qq.ie7() ) { qq(input).css({height: "100%"}); }

        options.element.appendChild(input);

        disposeSupport.attach(input, "change", function() {
            options.onChange(input);
        });

        // **These event handlers will be removed** in the future as the :hover CSS pseudo-class is available on all supported browsers
        disposeSupport.attach(input, "mouseover", function() {
            qq(options.element).addClass(options.hoverClass);
        });
        disposeSupport.attach(input, "mouseout", function() {
            qq(options.element).removeClass(options.hoverClass);
        });

        disposeSupport.attach(input, "focus", function() {
            qq(options.element).addClass(options.focusClass);
        });
        disposeSupport.attach(input, "blur", function() {
            qq(options.element).removeClass(options.focusClass);
        });

        return input;
    }

    // Make button suitable container for input
    qq(options.element).css({
        position: "relative",
        overflow: "hidden",
        // Make sure browse button is in the right side in Internet Explorer
        direction: "ltr"
    });

    // Exposed API
    qq.extend(this, {
        getInput: function() {
            return input;
        },

        getButtonId: function() {
            return buttonId;
        },

        setMultiple: function(isMultiple, optInput) {
            var input = optInput || this.getInput();

            // Temporary workaround for bug in in iOS8 UIWebView that causes the browser to crash
            // before the file chooser appears if the file input doesn't contain a multiple attribute.
            // See #1283.
            if (options.ios8BrowserCrashWorkaround && qq.ios8() && (qq.iosChrome() || qq.iosSafariWebView())) {
                input.setAttribute("multiple", "");
            }

            else {
                if (isMultiple) {
                    input.setAttribute("multiple", "");
                }
                else {
                    input.removeAttribute("multiple");
                }
            }
        },

        setAcceptFiles: function(acceptFiles) {
            if (acceptFiles !== options.acceptFiles) {
                input.setAttribute("accept", acceptFiles);
            }
        },

        reset: function() {
            if (input.parentNode) {
                qq(input).remove();
            }

            qq(options.element).removeClass(options.focusClass);
            input = null;
            input = createInput();
        }
    });

    input = createInput();
};

qq.UploadButton.BUTTON_ID_ATTR_NAME = "qq-button-id";

/*globals qq */
qq.UploadData = function(uploaderProxy) {

    var data = [],
        byUuid = {},
        byStatus = {},
        byProxyGroupId = {},
        byBatchId = {};

    function getDataByIds(idOrIds) {
        if (qq.isArray(idOrIds)) {
            var entries = [];

            qq.each(idOrIds, function(idx, id) {
                entries.push(data[id]);
            });

            return entries;
        }

        return data[idOrIds];
    }

    function getDataByUuids(uuids) {
        if (qq.isArray(uuids)) {
            var entries = [];

            qq.each(uuids, function(idx, uuid) {
                entries.push(data[byUuid[uuid]]);
            });

            return entries;
        }

        return data[byUuid[uuids]];
    }

    function getDataByStatus(status) {
        var statusResults = [],
            statuses = [].concat(status);

        qq.each(statuses, function(index, statusEnum) {
            var statusResultIndexes = byStatus[statusEnum];

            if (statusResultIndexes !== undefined) {
                qq.each(statusResultIndexes, function(i, dataIndex) {
                    statusResults.push(data[dataIndex]);
                });
            }
        });

        return statusResults;
    }

    qq.extend(this, {
        /**
         * Adds a new file to the data cache for tracking purposes.
         *
         * @param spec Data that describes this file.  Possible properties are:
         *
         * - uuid: Initial UUID for this file.
         * - name: Initial name of this file.
         * - size: Size of this file, omit if this cannot be determined
         * - status: Initial `qq.status` for this file.  Omit for `qq.status.SUBMITTING`.
         * - batchId: ID of the batch this file belongs to
         * - proxyGroupId: ID of the proxy group associated with this file
         *
         * @returns {number} Internal ID for this file.
         */
        addFile: function(spec) {
            var status = spec.status || qq.status.SUBMITTING,
                id = data.push({
                    name: spec.name,
                    originalName: spec.name,
                    uuid: spec.uuid,
                    size: ( spec.size === null ) ? -1 : spec.size,
                    status: status
                }) - 1;

            if (spec.batchId) {
                data[id].batchId = spec.batchId;

                if (byBatchId[spec.batchId] === undefined) {
                    byBatchId[spec.batchId] = [];
                }
                byBatchId[spec.batchId].push(id);
            }

            if (spec.proxyGroupId) {
                data[id].proxyGroupId = spec.proxyGroupId;

                if (byProxyGroupId[spec.proxyGroupId] === undefined) {
                    byProxyGroupId[spec.proxyGroupId] = [];
                }
                byProxyGroupId[spec.proxyGroupId].push(id);
            }

            data[id].id = id;
            byUuid[spec.uuid] = id;

            if (byStatus[status] === undefined) {
                byStatus[status] = [];
            }
            byStatus[status].push(id);

            uploaderProxy.onStatusChange(id, null, status);

            return id;
        },

        retrieve: function(optionalFilter) {
            if (qq.isObject(optionalFilter) && data.length)  {
                if (optionalFilter.id !== undefined) {
                    return getDataByIds(optionalFilter.id);
                }

                else if (optionalFilter.uuid !== undefined) {
                    return getDataByUuids(optionalFilter.uuid);
                }

                else if (optionalFilter.status) {
                    return getDataByStatus(optionalFilter.status);
                }
            }
            else {
                return qq.extend([], data, true);
            }
        },

        reset: function() {
            data = [];
            byUuid = {};
            byStatus = {};
            byBatchId = {};
        },

        setStatus: function(id, newStatus) {
            var oldStatus = data[id].status,
                byStatusOldStatusIndex = qq.indexOf(byStatus[oldStatus], id);

            byStatus[oldStatus].splice(byStatusOldStatusIndex, 1);

            data[id].status = newStatus;

            if (byStatus[newStatus] === undefined) {
                byStatus[newStatus] = [];
            }
            byStatus[newStatus].push(id);

            uploaderProxy.onStatusChange(id, oldStatus, newStatus);
        },

        uuidChanged: function(id, newUuid) {
            var oldUuid = data[id].uuid;

            data[id].uuid = newUuid;
            byUuid[newUuid] = id;
            delete byUuid[oldUuid];
        },

        updateName: function(id, newName) {
            data[id].name = newName;
        },

        updateSize: function(id, newSize) {
            data[id].size = newSize;
        },

        // Only applicable if this file has a parent that we may want to reference later.
        setParentId: function(targetId, parentId) {
            data[targetId].parentId = parentId;
        },

        getIdsInProxyGroup: function(id) {
            var proxyGroupId = data[id].proxyGroupId;

            if (proxyGroupId) {
                return byProxyGroupId[proxyGroupId];
            }
            return [];
        },

        getIdsInBatch: function(id) {
            var batchId = data[id].batchId;

            return byBatchId[batchId];
        }
    });
};

qq.status = {
    SUBMITTING: "submitting",
    SUBMITTED: "submitted",
    REJECTED: "rejected",
    QUEUED: "queued",
    CANCELED: "canceled",
    PAUSED: "paused",
    UPLOADING: "uploading",
    UPLOAD_RETRYING: "retrying upload",
    UPLOAD_SUCCESSFUL: "upload successful",
    UPLOAD_FAILED: "upload failed",
    DELETE_FAILED: "delete failed",
    DELETING: "deleting",
    DELETED: "deleted"
};

/*globals qq*/
/**
 * Defines the public API for FineUploaderBasic mode.
 */
(function() {

    qq.basePublicApi = {
        // DEPRECATED - TODO REMOVE IN NEXT MAJOR RELEASE (replaced by addFiles)
        addBlobs: function(blobDataOrArray, params, endpoint) {
            this.addFiles(blobDataOrArray, params, endpoint);
        },

        addInitialFiles: function(cannedFileList) {
            var self = this;

            qq.each(cannedFileList, function(index, cannedFile) {
                self._addCannedFile(cannedFile);
            });
        },

        addFiles: function(data, params, endpoint) {
            this._maybeHandleIos8SafariWorkaround();

            var batchId = this._storedIds.length === 0 ? qq.getUniqueId() : this._currentBatchId,

                processBlob = qq.bind(function(blob) {
                    this._handleNewFile({
                        blob: blob,
                        name: this._options.blobs.defaultName
                    }, batchId, verifiedFiles);
                }, this),

                processBlobData = qq.bind(function(blobData) {
                    this._handleNewFile(blobData, batchId, verifiedFiles);
                }, this),

                processCanvas = qq.bind(function(canvas) {
                    var blob = qq.canvasToBlob(canvas);

                    this._handleNewFile({
                        blob: blob,
                        name: this._options.blobs.defaultName + ".png"
                    }, batchId, verifiedFiles);
                }, this),

                processCanvasData = qq.bind(function(canvasData) {
                    var normalizedQuality = canvasData.quality && canvasData.quality / 100,
                        blob = qq.canvasToBlob(canvasData.canvas, canvasData.type, normalizedQuality);

                    this._handleNewFile({
                        blob: blob,
                        name: canvasData.name
                    }, batchId, verifiedFiles);
                }, this),

                processFileOrInput = qq.bind(function(fileOrInput) {
                    if (qq.isInput(fileOrInput) && qq.supportedFeatures.ajaxUploading) {
                        var files = Array.prototype.slice.call(fileOrInput.files),
                            self = this;

                        qq.each(files, function(idx, file) {
                            self._handleNewFile(file, batchId, verifiedFiles);
                        });
                    }
                    else {
                        this._handleNewFile(fileOrInput, batchId, verifiedFiles);
                    }
                }, this),

                normalizeData = function() {
                    if (qq.isFileList(data)) {
                        data = Array.prototype.slice.call(data);
                    }
                    data = [].concat(data);
                },

                self = this,
                verifiedFiles = [];

            this._currentBatchId = batchId;

            if (data) {
                normalizeData();

                qq.each(data, function(idx, fileContainer) {
                    if (qq.isFileOrInput(fileContainer)) {
                        processFileOrInput(fileContainer);
                    }
                    else if (qq.isBlob(fileContainer)) {
                        processBlob(fileContainer);
                    }
                    else if (qq.isObject(fileContainer)) {
                        if (fileContainer.blob && fileContainer.name) {
                            processBlobData(fileContainer);
                        }
                        else if (fileContainer.canvas && fileContainer.name) {
                            processCanvasData(fileContainer);
                        }
                    }
                    else if (fileContainer.tagName && fileContainer.tagName.toLowerCase() === "canvas") {
                        processCanvas(fileContainer);
                    }
                    else {
                        self.log(fileContainer + " is not a valid file container!  Ignoring!", "warn");
                    }
                });

                this.log("Received " + verifiedFiles.length + " files.");
                this._prepareItemsForUpload(verifiedFiles, params, endpoint);
            }
        },

        cancel: function(id) {
            this._handler.cancel(id);
        },

        cancelAll: function() {
            var storedIdsCopy = [],
                self = this;

            qq.extend(storedIdsCopy, this._storedIds);
            qq.each(storedIdsCopy, function(idx, storedFileId) {
                self.cancel(storedFileId);
            });

            this._handler.cancelAll();
        },

        clearStoredFiles: function() {
            this._storedIds = [];
        },

        continueUpload: function(id) {
            var uploadData = this._uploadData.retrieve({id: id});

            if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {
                return false;
            }

            if (uploadData.status === qq.status.PAUSED) {
                this.log(qq.format("Paused file ID {} ({}) will be continued.  Not paused.", id, this.getName(id)));
                this._uploadFile(id);
                return true;
            }
            else {
                this.log(qq.format("Ignoring continue for file ID {} ({}).  Not paused.", id, this.getName(id)), "error");
            }

            return false;
        },

        deleteFile: function(id) {
            return this._onSubmitDelete(id);
        },

        // TODO document?
        doesExist: function(fileOrBlobId) {
            return this._handler.isValid(fileOrBlobId);
        },

        // Generate a variable size thumbnail on an img or canvas,
        // returning a promise that is fulfilled when the attempt completes.
        // Thumbnail can either be based off of a URL for an image returned
        // by the server in the upload response, or the associated `Blob`.
        drawThumbnail: function(fileId, imgOrCanvas, maxSize, fromServer, customResizeFunction) {
            var promiseToReturn = new qq.Promise(),
                fileOrUrl, options;

            if (this._imageGenerator) {
                fileOrUrl = this._thumbnailUrls[fileId];
                options = {
                    customResizeFunction: customResizeFunction,
                    maxSize: maxSize > 0 ? maxSize : null,
                    scale: maxSize > 0
                };

                // If client-side preview generation is possible
                // and we are not specifically looking for the image URl returned by the server...
                if (!fromServer && qq.supportedFeatures.imagePreviews) {
                    fileOrUrl = this.getFile(fileId);
                }

                /* jshint eqeqeq:false,eqnull:true */
                if (fileOrUrl == null) {
                    promiseToReturn.failure({container: imgOrCanvas, error: "File or URL not found."});
                }
                else {
                    this._imageGenerator.generate(fileOrUrl, imgOrCanvas, options).then(
                        function success(modifiedContainer) {
                            promiseToReturn.success(modifiedContainer);
                        },

                        function failure(container, reason) {
                            promiseToReturn.failure({container: container, error: reason || "Problem generating thumbnail"});
                        }
                    );
                }
            }
            else {
                promiseToReturn.failure({container: imgOrCanvas, error: "Missing image generator module"});
            }

            return promiseToReturn;
        },

        getButton: function(fileId) {
            return this._getButton(this._buttonIdsForFileIds[fileId]);
        },

        getEndpoint: function(fileId) {
            return this._endpointStore.get(fileId);
        },

        getFile: function(fileOrBlobId) {
            return this._handler.getFile(fileOrBlobId) || null;
        },

        getInProgress: function() {
            return this._uploadData.retrieve({
                status: [
                    qq.status.UPLOADING,
                    qq.status.UPLOAD_RETRYING,
                    qq.status.QUEUED
                ]
            }).length;
        },

        getName: function(id) {
            return this._uploadData.retrieve({id: id}).name;
        },

                // Parent ID for a specific file, or null if this is the parent, or if it has no parent.
        getParentId: function(id) {
            var uploadDataEntry = this.getUploads({id: id}),
                parentId = null;

            if (uploadDataEntry) {
                if (uploadDataEntry.parentId !== undefined) {
                    parentId = uploadDataEntry.parentId;
                }
            }

            return parentId;
        },

        getResumableFilesData: function() {
            return this._handler.getResumableFilesData();
        },

        getSize: function(id) {
            return this._uploadData.retrieve({id: id}).size;
        },

        getNetUploads: function() {
            return this._netUploaded;
        },

        getRemainingAllowedItems: function() {
            var allowedItems = this._currentItemLimit;

            if (allowedItems > 0) {
                return allowedItems - this._netUploadedOrQueued;
            }

            return null;
        },

        getUploads: function(optionalFilter) {
            return this._uploadData.retrieve(optionalFilter);
        },

        getUuid: function(id) {
            return this._uploadData.retrieve({id: id}).uuid;
        },

        log: function(str, level) {
            if (this._options.debug && (!level || level === "info")) {
                qq.log("[Fine Uploader " + qq.version + "] " + str);
            }
            else if (level && level !== "info") {
                qq.log("[Fine Uploader " + qq.version + "] " + str, level);

            }
        },

        pauseUpload: function(id) {
            var uploadData = this._uploadData.retrieve({id: id});

            if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {
                return false;
            }

            // Pause only really makes sense if the file is uploading or retrying
            if (qq.indexOf([qq.status.UPLOADING, qq.status.UPLOAD_RETRYING], uploadData.status) >= 0) {
                if (this._handler.pause(id)) {
                    this._uploadData.setStatus(id, qq.status.PAUSED);
                    return true;
                }
                else {
                    this.log(qq.format("Unable to pause file ID {} ({}).", id, this.getName(id)), "error");
                }
            }
            else {
                this.log(qq.format("Ignoring pause for file ID {} ({}).  Not in progress.", id, this.getName(id)), "error");
            }

            return false;
        },

        reset: function() {
            this.log("Resetting uploader...");

            this._handler.reset();
            this._storedIds = [];
            this._autoRetries = [];
            this._retryTimeouts = [];
            this._preventRetries = [];
            this._thumbnailUrls = [];

            qq.each(this._buttons, function(idx, button) {
                button.reset();
            });

            this._paramsStore.reset();
            this._endpointStore.reset();
            this._netUploadedOrQueued = 0;
            this._netUploaded = 0;
            this._uploadData.reset();
            this._buttonIdsForFileIds = [];

            if ( this._pasteHandler ) { this._pasteHandler.reset(); }
            if ( this._options.session.refreshOnReset ) { this._refreshSessionData(); }

            this._succeededSinceLastAllComplete = [];
            this._failedSinceLastAllComplete = [];

            if ( this._totalProgress ) { this._totalProgress.reset(); }
        },

        retry: function(id) {
            return this._manualRetry(id);
        },

        scaleImage: function(id, specs) {
            var self = this;

            return qq.Scaler.prototype.scaleImage(id, specs, {
                log: qq.bind(self.log, self),
                getFile: qq.bind(self.getFile, self),
                uploadData: self._uploadData
            });
        },

        setCustomHeaders: function(headers, id) {
            this._customHeadersStore.set(headers, id);
        },

        setDeleteFileCustomHeaders: function(headers, id) {
            this._deleteFileCustomHeadersStore.set(headers, id);
        },

        setDeleteFileEndpoint: function(endpoint, id) {
            this._deleteFileEndpointStore.set(endpoint, id);
        },

        setDeleteFileParams: function(params, id) {
            this._deleteFileParamsStore.set(params, id);
        },

        // Re-sets the default endpoint, an endpoint for a specific file, or an endpoint for a specific button
        setEndpoint: function(endpoint, id) {
            this._endpointStore.set(endpoint, id);
        },

        setForm: function(elementOrId) {
            this._updateFormSupportAndParams(elementOrId);
        },

        setItemLimit: function(newItemLimit) {
            this._currentItemLimit = newItemLimit;
        },

        setName: function(id, newName) {
            this._uploadData.updateName(id, newName);
        },

        setParams: function(params, id) {
            this._paramsStore.set(params, id);
        },

        setUuid: function(id, newUuid) {
            return this._uploadData.uuidChanged(id, newUuid);
        },

        uploadStoredFiles: function() {
            if (this._storedIds.length === 0) {
                this._itemError("noFilesError");
            }
            else {
                this._uploadStoredFiles();
            }
        }
    };

    /**
     * Defines the private (internal) API for FineUploaderBasic mode.
     */
    qq.basePrivateApi = {
        // Updates internal state with a file record (not backed by a live file).  Returns the assigned ID.
        _addCannedFile: function(sessionData) {
            var id = this._uploadData.addFile({
                uuid: sessionData.uuid,
                name: sessionData.name,
                size: sessionData.size,
                status: qq.status.UPLOAD_SUCCESSFUL
            });

            if ( sessionData.deleteFileEndpoint ) { this.setDeleteFileEndpoint(sessionData.deleteFileEndpoint, id); }
            if ( sessionData.deleteFileParams ) { this.setDeleteFileParams(sessionData.deleteFileParams, id); }

            if (sessionData.thumbnailUrl) {
                this._thumbnailUrls[id] = sessionData.thumbnailUrl;
            }

            this._netUploaded++;
            this._netUploadedOrQueued++;

            return id;
        },

        _annotateWithButtonId: function(file, associatedInput) {
            if (qq.isFile(file)) {
                file.qqButtonId = this._getButtonId(associatedInput);
            }
        },

        _batchError: function(message) {
            this._options.callbacks.onError(null, null, message, undefined);
        },

        _createDeleteHandler: function() {
            var self = this;

            return new qq.DeleteFileAjaxRequester({
                method: this._options.deleteFile.method.toUpperCase(),
                maxConnections: this._options.maxConnections,
                uuidParamName: this._options.request.uuidName,
                customHeaders: this._deleteFileCustomHeadersStore,
                paramsStore: this._deleteFileParamsStore,
                endpointStore: this._deleteFileEndpointStore,
                cors: this._options.cors,
                log: qq.bind(self.log, self),
                onDelete: function(id) {
                    self._onDelete(id);
                    self._options.callbacks.onDelete(id);
                },
                onDeleteComplete: function(id, xhrOrXdr, isError) {
                    self._onDeleteComplete(id, xhrOrXdr, isError);
                    self._options.callbacks.onDeleteComplete(id, xhrOrXdr, isError);
                }

            });
        },

        _createPasteHandler: function() {
            var self = this;

            return new qq.PasteSupport({
                targetElement: this._options.paste.targetElement,
                callbacks: {
                    log: qq.bind(self.log, self),
                    pasteReceived: function(blob) {
                        self._handleCheckedCallback({
                            name: "onPasteReceived",
                            callback: qq.bind(self._options.callbacks.onPasteReceived, self, blob),
                            onSuccess: qq.bind(self._handlePasteSuccess, self, blob),
                            identifier: "pasted image"
                        });
                    }
                }
            });
        },

        _createStore: function(initialValue, _readOnlyValues_) {
            var store = {},
                catchall = initialValue,
                perIdReadOnlyValues = {},
                readOnlyValues = _readOnlyValues_,
                copy = function(orig) {
                    if (qq.isObject(orig)) {
                        return qq.extend({}, orig);
                    }
                    return orig;
                },
                getReadOnlyValues = function() {
                    if (qq.isFunction(readOnlyValues)) {
                        return readOnlyValues();
                    }
                    return readOnlyValues;
                },
                includeReadOnlyValues = function(id, existing) {
                    if (readOnlyValues && qq.isObject(existing)) {
                        qq.extend(existing, getReadOnlyValues());
                    }

                    if (perIdReadOnlyValues[id]) {
                        qq.extend(existing, perIdReadOnlyValues[id]);
                    }
                };

            return {
                set: function(val, id) {
                    /*jshint eqeqeq: true, eqnull: true*/
                    if (id == null) {
                        store = {};
                        catchall = copy(val);
                    }
                    else {
                        store[id] = copy(val);
                    }
                },

                get: function(id) {
                    var values;

                    /*jshint eqeqeq: true, eqnull: true*/
                    if (id != null && store[id]) {
                        values = store[id];
                    }
                    else {
                        values = copy(catchall);
                    }

                    includeReadOnlyValues(id, values);

                    return copy(values);
                },

                addReadOnly: function(id, values) {
                    // Only applicable to Object stores
                    if (qq.isObject(store)) {
                        // If null ID, apply readonly values to all files
                        if (id === null) {
                            if (qq.isFunction(values)) {
                                readOnlyValues = values;
                            }
                            else {
                                readOnlyValues = readOnlyValues || {};
                                qq.extend(readOnlyValues, values);
                            }
                        }
                        else {
                            perIdReadOnlyValues[id] = perIdReadOnlyValues[id] || {};
                            qq.extend(perIdReadOnlyValues[id], values);
                        }
                    }
                },

                remove: function(fileId) {
                    return delete store[fileId];
                },

                reset: function() {
                    store = {};
                    perIdReadOnlyValues = {};
                    catchall = initialValue;
                }
            };
        },

        _createUploadDataTracker: function() {
            var self = this;

            return new qq.UploadData({
                getName: function(id) {
                    return self.getName(id);
                },
                getUuid: function(id) {
                    return self.getUuid(id);
                },
                getSize: function(id) {
                    return self.getSize(id);
                },
                onStatusChange: function(id, oldStatus, newStatus) {
                    self._onUploadStatusChange(id, oldStatus, newStatus);
                    self._options.callbacks.onStatusChange(id, oldStatus, newStatus);
                    self._maybeAllComplete(id, newStatus);

                    if (self._totalProgress) {
                        setTimeout(function() {
                            self._totalProgress.onStatusChange(id, oldStatus, newStatus);
                        }, 0);
                    }
                }
            });
        },

        /**
         * Generate a tracked upload button.
         *
         * @param spec Object containing a required `element` property
         * along with optional `multiple`, `accept`, and `folders`.
         * @returns {qq.UploadButton}
         * @private
         */
        _createUploadButton: function(spec) {
            var self = this,
                acceptFiles = spec.accept || this._options.validation.acceptFiles,
                allowedExtensions = spec.allowedExtensions || this._options.validation.allowedExtensions,
                button;

            function allowMultiple() {
                if (qq.supportedFeatures.ajaxUploading) {
                    // Workaround for bug in iOS7+ (see #1039)
                    if (self._options.workarounds.iosEmptyVideos &&
                        qq.ios() &&
                        !qq.ios6() &&
                        self._isAllowedExtension(allowedExtensions, ".mov")) {

                        return false;
                    }

                    if (spec.multiple === undefined) {
                        return self._options.multiple;
                    }

                    return spec.multiple;
                }

                return false;
            }

            button = new qq.UploadButton({
                acceptFiles: acceptFiles,
                element: spec.element,
                focusClass: this._options.classes.buttonFocus,
                folders: spec.folders,
                hoverClass: this._options.classes.buttonHover,
                ios8BrowserCrashWorkaround: this._options.workarounds.ios8BrowserCrash,
                multiple: allowMultiple(),
                name: this._options.request.inputName,
                onChange: function(input) {
                    self._onInputChange(input);
                },
                title: !spec.title ? this._options.text.fileInputTitle : spec.title
            });

            this._disposeSupport.addDisposer(function() {
                button.dispose();
            });

            self._buttons.push(button);

            return button;
        },

        _createUploadHandler: function(additionalOptions, namespace) {
            var self = this,
                lastOnProgress = {},
                options = {
                    debug: this._options.debug,
                    maxConnections: this._options.maxConnections,
                    cors: this._options.cors,
                    paramsStore: this._paramsStore,
                    endpointStore: this._endpointStore,
                    chunking: this._options.chunking,
                    resume: this._options.resume,
                    blobs: this._options.blobs,
                    log: qq.bind(self.log, self),
                    preventRetryParam: this._options.retry.preventRetryResponseProperty,
                    onProgress: function(id, name, loaded, total) {
                        if (loaded < 0 || total < 0) {
                            return;
                        }

                        if (lastOnProgress[id]) {
                            if (lastOnProgress[id].loaded !== loaded || lastOnProgress[id].total !== total) {
                                self._onProgress(id, name, loaded, total);
                                self._options.callbacks.onProgress(id, name, loaded, total);
                            }
                        }
                        else {
                            self._onProgress(id, name, loaded, total);
                            self._options.callbacks.onProgress(id, name, loaded, total);
                        }

                        lastOnProgress[id] = {loaded: loaded, total: total};

                    },
                    onComplete: function(id, name, result, xhr) {
                        delete lastOnProgress[id];

                        var status = self.getUploads({id: id}).status,
                            retVal;

                        // This is to deal with some observed cases where the XHR readyStateChange handler is
                        // invoked by the browser multiple times for the same XHR instance with the same state
                        // readyState value.  Higher level: don't invoke complete-related code if we've already
                        // done this.
                        if (status === qq.status.UPLOAD_SUCCESSFUL || status === qq.status.UPLOAD_FAILED) {
                            return;
                        }

                        retVal = self._onComplete(id, name, result, xhr);

                        // If the internal `_onComplete` handler returns a promise, don't invoke the `onComplete` callback
                        // until the promise has been fulfilled.
                        if (retVal instanceof  qq.Promise) {
                            retVal.done(function() {
                                self._options.callbacks.onComplete(id, name, result, xhr);
                            });
                        }
                        else {
                            self._options.callbacks.onComplete(id, name, result, xhr);
                        }
                    },
                    onCancel: function(id, name, cancelFinalizationEffort) {
                        var promise = new qq.Promise();

                        self._handleCheckedCallback({
                            name: "onCancel",
                            callback: qq.bind(self._options.callbacks.onCancel, self, id, name),
                            onFailure: promise.failure,
                            onSuccess: function() {
                                cancelFinalizationEffort.then(function() {
                                    self._onCancel(id, name);
                                });

                                promise.success();
                            },
                            identifier: id
                        });

                        return promise;
                    },
                    onUploadPrep: qq.bind(this._onUploadPrep, this),
                    onUpload: function(id, name) {
                        self._onUpload(id, name);
                        self._options.callbacks.onUpload(id, name);
                    },
                    onUploadChunk: function(id, name, chunkData) {
                        self._onUploadChunk(id, chunkData);
                        self._options.callbacks.onUploadChunk(id, name, chunkData);
                    },
                    onUploadChunkSuccess: function(id, chunkData, result, xhr) {
                        self._options.callbacks.onUploadChunkSuccess.apply(self, arguments);
                    },
                    onResume: function(id, name, chunkData) {
                        return self._options.callbacks.onResume(id, name, chunkData);
                    },
                    onAutoRetry: function(id, name, responseJSON, xhr) {
                        return self._onAutoRetry.apply(self, arguments);
                    },
                    onUuidChanged: function(id, newUuid) {
                        self.log("Server requested UUID change from '" + self.getUuid(id) + "' to '" + newUuid + "'");
                        self.setUuid(id, newUuid);
                    },
                    getName: qq.bind(self.getName, self),
                    getUuid: qq.bind(self.getUuid, self),
                    getSize: qq.bind(self.getSize, self),
                    setSize: qq.bind(self._setSize, self),
                    getDataByUuid: function(uuid) {
                        return self.getUploads({uuid: uuid});
                    },
                    isQueued: function(id) {
                        var status = self.getUploads({id: id}).status;
                        return status === qq.status.QUEUED ||
                            status === qq.status.SUBMITTED ||
                            status === qq.status.UPLOAD_RETRYING ||
                            status === qq.status.PAUSED;
                    },
                    getIdsInProxyGroup: self._uploadData.getIdsInProxyGroup,
                    getIdsInBatch: self._uploadData.getIdsInBatch
                };

            qq.each(this._options.request, function(prop, val) {
                options[prop] = val;
            });

            options.customHeaders = this._customHeadersStore;

            if (additionalOptions) {
                qq.each(additionalOptions, function(key, val) {
                    options[key] = val;
                });
            }

            return new qq.UploadHandlerController(options, namespace);
        },

        _fileOrBlobRejected: function(id) {
            this._netUploadedOrQueued--;
            this._uploadData.setStatus(id, qq.status.REJECTED);
        },

        _formatSize: function(bytes) {
            var i = -1;
            do {
                bytes = bytes / 1000;
                i++;
            } while (bytes > 999);

            return Math.max(bytes, 0.1).toFixed(1) + this._options.text.sizeSymbols[i];
        },

        // Creates an internal object that tracks various properties of each extra button,
        // and then actually creates the extra button.
        _generateExtraButtonSpecs: function() {
            var self = this;

            this._extraButtonSpecs = {};

            qq.each(this._options.extraButtons, function(idx, extraButtonOptionEntry) {
                var multiple = extraButtonOptionEntry.multiple,
                    validation = qq.extend({}, self._options.validation, true),
                    extraButtonSpec = qq.extend({}, extraButtonOptionEntry);

                if (multiple === undefined) {
                    multiple = self._options.multiple;
                }

                if (extraButtonSpec.validation) {
                    qq.extend(validation, extraButtonOptionEntry.validation, true);
                }

                qq.extend(extraButtonSpec, {
                    multiple: multiple,
                    validation: validation
                }, true);

                self._initExtraButton(extraButtonSpec);
            });
        },

        _getButton: function(buttonId) {
            var extraButtonsSpec = this._extraButtonSpecs[buttonId];

            if (extraButtonsSpec) {
                return extraButtonsSpec.element;
            }
            else if (buttonId === this._defaultButtonId) {
                return this._options.button;
            }
        },

        /**
         * Gets the internally used tracking ID for a button.
         *
         * @param buttonOrFileInputOrFile `File`, `<input type="file">`, or a button container element
         * @returns {*} The button's ID, or undefined if no ID is recoverable
         * @private
         */
        _getButtonId: function(buttonOrFileInputOrFile) {
            var inputs, fileInput,
                fileBlobOrInput = buttonOrFileInputOrFile;

            // We want the reference file/blob here if this is a proxy (a file that will be generated on-demand later)
            if (fileBlobOrInput instanceof qq.BlobProxy) {
                fileBlobOrInput = fileBlobOrInput.referenceBlob;
            }

            // If the item is a `Blob` it will never be associated with a button or drop zone.
            if (fileBlobOrInput && !qq.isBlob(fileBlobOrInput)) {
                if (qq.isFile(fileBlobOrInput)) {
                    return fileBlobOrInput.qqButtonId;
                }
                else if (fileBlobOrInput.tagName.toLowerCase() === "input" &&
                    fileBlobOrInput.type.toLowerCase() === "file") {

                    return fileBlobOrInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);
                }

                inputs = fileBlobOrInput.getElementsByTagName("input");

                qq.each(inputs, function(idx, input) {
                    if (input.getAttribute("type") === "file") {
                        fileInput = input;
                        return false;
                    }
                });

                if (fileInput) {
                    return fileInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);
                }
            }
        },

        _getNotFinished: function() {
            return this._uploadData.retrieve({
                status: [
                    qq.status.UPLOADING,
                    qq.status.UPLOAD_RETRYING,
                    qq.status.QUEUED,
                    qq.status.SUBMITTING,
                    qq.status.SUBMITTED,
                    qq.status.PAUSED
                ]
            }).length;
        },

        // Get the validation options for this button.  Could be the default validation option
        // or a specific one assigned to this particular button.
        _getValidationBase: function(buttonId) {
            var extraButtonSpec = this._extraButtonSpecs[buttonId];

            return extraButtonSpec ? extraButtonSpec.validation : this._options.validation;
        },

        _getValidationDescriptor: function(fileWrapper) {
            if (fileWrapper.file instanceof qq.BlobProxy) {
                return {
                    name: qq.getFilename(fileWrapper.file.referenceBlob),
                    size: fileWrapper.file.referenceBlob.size
                };
            }

            return {
                name: this.getUploads({id: fileWrapper.id}).name,
                size: this.getUploads({id: fileWrapper.id}).size
            };
        },

        _getValidationDescriptors: function(fileWrappers) {
            var self = this,
                fileDescriptors = [];

            qq.each(fileWrappers, function(idx, fileWrapper) {
                fileDescriptors.push(self._getValidationDescriptor(fileWrapper));
            });

            return fileDescriptors;
        },

        // Allows camera access on either the default or an extra button for iOS devices.
        _handleCameraAccess: function() {
            if (this._options.camera.ios && qq.ios()) {
                var acceptIosCamera = "image/*;capture=camera",
                    button = this._options.camera.button,
                    buttonId = button ? this._getButtonId(button) : this._defaultButtonId,
                    optionRoot = this._options;

                // If we are not targeting the default button, it is an "extra" button
                if (buttonId && buttonId !== this._defaultButtonId) {
                    optionRoot = this._extraButtonSpecs[buttonId];
                }

                // Camera access won't work in iOS if the `multiple` attribute is present on the file input
                optionRoot.multiple = false;

                // update the options
                if (optionRoot.validation.acceptFiles === null) {
                    optionRoot.validation.acceptFiles = acceptIosCamera;
                }
                else {
                    optionRoot.validation.acceptFiles += "," + acceptIosCamera;
                }

                // update the already-created button
                qq.each(this._buttons, function(idx, button) {
                    if (button.getButtonId() === buttonId) {
                        button.setMultiple(optionRoot.multiple);
                        button.setAcceptFiles(optionRoot.acceptFiles);

                        return false;
                    }
                });
            }
        },

        _handleCheckedCallback: function(details) {
            var self = this,
                callbackRetVal = details.callback();

            if (qq.isGenericPromise(callbackRetVal)) {
                this.log(details.name + " - waiting for " + details.name + " promise to be fulfilled for " + details.identifier);
                return callbackRetVal.then(
                    function(successParam) {
                        self.log(details.name + " promise success for " + details.identifier);
                        details.onSuccess(successParam);
                    },
                    function() {
                        if (details.onFailure) {
                            self.log(details.name + " promise failure for " + details.identifier);
                            details.onFailure();
                        }
                        else {
                            self.log(details.name + " promise failure for " + details.identifier);
                        }
                    });
            }

            if (callbackRetVal !== false) {
                details.onSuccess(callbackRetVal);
            }
            else {
                if (details.onFailure) {
                    this.log(details.name + " - return value was 'false' for " + details.identifier + ".  Invoking failure callback.");
                    details.onFailure();
                }
                else {
                    this.log(details.name + " - return value was 'false' for " + details.identifier + ".  Will not proceed.");
                }
            }

            return callbackRetVal;
        },

        // Updates internal state when a new file has been received, and adds it along with its ID to a passed array.
        _handleNewFile: function(file, batchId, newFileWrapperList) {
            var self = this,
                uuid = qq.getUniqueId(),
                size = -1,
                name = qq.getFilename(file),
                actualFile = file.blob || file,
                handler = this._customNewFileHandler ?
                    this._customNewFileHandler :
                    qq.bind(self._handleNewFileGeneric, self);

            if (!qq.isInput(actualFile) && actualFile.size >= 0) {
                size = actualFile.size;
            }

            handler(actualFile, name, uuid, size, newFileWrapperList, batchId, this._options.request.uuidName, {
                uploadData: self._uploadData,
                paramsStore: self._paramsStore,
                addFileToHandler: function(id, file) {
                    self._handler.add(id, file);
                    self._netUploadedOrQueued++;
                    self._trackButton(id);
                }
            });
        },

        _handleNewFileGeneric: function(file, name, uuid, size, fileList, batchId) {
            var id = this._uploadData.addFile({uuid: uuid, name: name, size: size, batchId: batchId});

            this._handler.add(id, file);
            this._trackButton(id);

            this._netUploadedOrQueued++;

            fileList.push({id: id, file: file});
        },

        _handlePasteSuccess: function(blob, extSuppliedName) {
            var extension = blob.type.split("/")[1],
                name = extSuppliedName;

            /*jshint eqeqeq: true, eqnull: true*/
            if (name == null) {
                name = this._options.paste.defaultName;
            }

            name += "." + extension;

            this.addFiles({
                name: name,
                blob: blob
            });
        },

        // Creates an extra button element
        _initExtraButton: function(spec) {
            var button = this._createUploadButton({
                accept: spec.validation.acceptFiles,
                allowedExtensions: spec.validation.allowedExtensions,
                element: spec.element,
                folders: spec.folders,
                multiple: spec.multiple,
                title: spec.fileInputTitle
            });

            this._extraButtonSpecs[button.getButtonId()] = spec;
        },

        _initFormSupportAndParams: function() {
            this._formSupport = qq.FormSupport && new qq.FormSupport(
                this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this)
            );

            if (this._formSupport && this._formSupport.attachedToForm) {
                this._paramsStore = this._createStore(
                    this._options.request.params,  this._formSupport.getFormInputsAsObject
                );

                this._options.autoUpload = this._formSupport.newAutoUpload;
                if (this._formSupport.newEndpoint) {
                    this._options.request.endpoint = this._formSupport.newEndpoint;
                }
            }
            else {
                this._paramsStore = this._createStore(this._options.request.params);
            }
        },

        _isDeletePossible: function() {
            if (!qq.DeleteFileAjaxRequester || !this._options.deleteFile.enabled) {
                return false;
            }

            if (this._options.cors.expected) {
                if (qq.supportedFeatures.deleteFileCorsXhr) {
                    return true;
                }

                if (qq.supportedFeatures.deleteFileCorsXdr && this._options.cors.allowXdr) {
                    return true;
                }

                return false;
            }

            return true;
        },

        _isAllowedExtension: function(allowed, fileName) {
            var valid = false;

            if (!allowed.length) {
                return true;
            }

            qq.each(allowed, function(idx, allowedExt) {
                /**
                 * If an argument is not a string, ignore it.  Added when a possible issue with MooTools hijacking the
                 * `allowedExtensions` array was discovered.  See case #735 in the issue tracker for more details.
                 */
                if (qq.isString(allowedExt)) {
                    /*jshint eqeqeq: true, eqnull: true*/
                    var extRegex = new RegExp("\\." + allowedExt + "$", "i");

                    if (fileName.match(extRegex) != null) {
                        valid = true;
                        return false;
                    }
                }
            });

            return valid;
        },

        /**
         * Constructs and returns a message that describes an item/file error.  Also calls `onError` callback.
         *
         * @param code REQUIRED - a code that corresponds to a stock message describing this type of error
         * @param maybeNameOrNames names of the items that have failed, if applicable
         * @param item `File`, `Blob`, or `<input type="file">`
         * @private
         */
        _itemError: function(code, maybeNameOrNames, item) {
            var message = this._options.messages[code],
                allowedExtensions = [],
                names = [].concat(maybeNameOrNames),
                name = names[0],
                buttonId = this._getButtonId(item),
                validationBase = this._getValidationBase(buttonId),
                extensionsForMessage, placeholderMatch;

            function r(name, replacement) { message = message.replace(name, replacement); }

            qq.each(validationBase.allowedExtensions, function(idx, allowedExtension) {
                /**
                 * If an argument is not a string, ignore it.  Added when a possible issue with MooTools hijacking the
                 * `allowedExtensions` array was discovered.  See case #735 in the issue tracker for more details.
                 */
                if (qq.isString(allowedExtension)) {
                    allowedExtensions.push(allowedExtension);
                }
            });

            extensionsForMessage = allowedExtensions.join(", ").toLowerCase();

            r("{file}", this._options.formatFileName(name));
            r("{extensions}", extensionsForMessage);
            r("{sizeLimit}", this._formatSize(validationBase.sizeLimit));
            r("{minSizeLimit}", this._formatSize(validationBase.minSizeLimit));

            placeholderMatch = message.match(/(\{\w+\})/g);
            if (placeholderMatch !== null) {
                qq.each(placeholderMatch, function(idx, placeholder) {
                    r(placeholder, names[idx]);
                });
            }

            this._options.callbacks.onError(null, name, message, undefined);

            return message;
        },

        /**
         * Conditionally orders a manual retry of a failed upload.
         *
         * @param id File ID of the failed upload
         * @param callback Optional callback to invoke if a retry is prudent.
         * In lieu of asking the upload handler to retry.
         * @returns {boolean} true if a manual retry will occur
         * @private
         */
        _manualRetry: function(id, callback) {
            if (this._onBeforeManualRetry(id)) {
                this._netUploadedOrQueued++;
                this._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);

                if (callback) {
                    callback(id);
                }
                else {
                    this._handler.retry(id);
                }

                return true;
            }
        },

        _maybeAllComplete: function(id, status) {
            var self = this,
                notFinished = this._getNotFinished();

            if (status === qq.status.UPLOAD_SUCCESSFUL) {
                this._succeededSinceLastAllComplete.push(id);
            }
            else if (status === qq.status.UPLOAD_FAILED) {
                this._failedSinceLastAllComplete.push(id);
            }

            if (notFinished === 0 &&
                (this._succeededSinceLastAllComplete.length || this._failedSinceLastAllComplete.length)) {
                // Attempt to ensure onAllComplete is not invoked before other callbacks, such as onCancel & onComplete
                setTimeout(function() {
                    self._onAllComplete(self._succeededSinceLastAllComplete, self._failedSinceLastAllComplete);
                }, 0);
            }
        },

        _maybeHandleIos8SafariWorkaround: function() {
            var self = this;

            if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {
                setTimeout(function() {
                    window.alert(self._options.messages.unsupportedBrowserIos8Safari);
                }, 0);
                throw new qq.Error(this._options.messages.unsupportedBrowserIos8Safari);
            }
        },

        _maybeParseAndSendUploadError: function(id, name, response, xhr) {
            // Assuming no one will actually set the response code to something other than 200
            // and still set 'success' to true...

            //  Modified for Doc Cirrus REST response format

            var
                err = response.error || null,
                data = response.data || {};

            if ( err ) {
                var errorReason = err.error ? err.error : this._options.text.defaultResponseError;
                this._options.callbacks.onError(id, name, errorReason, xhr);
                return;
            }

            if (!data.success) {
                if (xhr && xhr.status !== 200 && !response.error) {
                    this._options.callbacks.onError(id, name, "XHR returned response code " + xhr.status, xhr);
                }
            }
        },

        _maybeProcessNextItemAfterOnValidateCallback: function(validItem, items, index, params, endpoint) {
            var self = this;

            if (items.length > index) {
                if (validItem || !this._options.validation.stopOnFirstInvalidFile) {
                    //use setTimeout to prevent a stack overflow with a large number of files in the batch & non-promissory callbacks
                    setTimeout(function() {
                        var validationDescriptor = self._getValidationDescriptor(items[index]),
                            buttonId = self._getButtonId(items[index].file),
                            button = self._getButton(buttonId);

                        self._handleCheckedCallback({
                            name: "onValidate",
                            callback: qq.bind(self._options.callbacks.onValidate, self, validationDescriptor, button),
                            onSuccess: qq.bind(self._onValidateCallbackSuccess, self, items, index, params, endpoint),
                            onFailure: qq.bind(self._onValidateCallbackFailure, self, items, index, params, endpoint),
                            identifier: "Item '" + validationDescriptor.name + "', size: " + validationDescriptor.size
                        });
                    }, 0);
                }
                else if (!validItem) {
                    for (; index < items.length; index++) {
                        self._fileOrBlobRejected(items[index].id);
                    }
                }
            }
        },

        _onAllComplete: function(successful, failed) {
            if ( this._totalProgress ) { this._totalProgress.onAllComplete(successful, failed, this._preventRetries); }

            this._options.callbacks.onAllComplete(qq.extend([], successful), qq.extend([], failed));

            this._succeededSinceLastAllComplete = [];
            this._failedSinceLastAllComplete = [];
        },

        /**
         * Attempt to automatically retry a failed upload.
         *
         * @param id The file ID of the failed upload
         * @param name The name of the file associated with the failed upload
         * @param responseJSON Response from the server, parsed into a javascript object
         * @param xhr Ajax transport used to send the failed request
         * @param callback Optional callback to be invoked if a retry is prudent.
         * Invoked in lieu of asking the upload handler to retry.
         * @returns {boolean} true if an auto-retry will occur
         * @private
         */
        _onAutoRetry: function(id, name, responseJSON, xhr, callback) {
            var self = this;

            self._preventRetries[id] = responseJSON[self._options.retry.preventRetryResponseProperty];

            if (self._shouldAutoRetry(id, name, responseJSON)) {
                self._maybeParseAndSendUploadError.apply(self, arguments);
                self._options.callbacks.onAutoRetry(id, name, self._autoRetries[id]);
                self._onBeforeAutoRetry(id, name);

                self._retryTimeouts[id] = setTimeout(function() {
                    self.log("Retrying " + name + "...");
                    self._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);

                    if (callback) {
                        callback(id);
                    }
                    else {
                        self._handler.retry(id);
                    }
                }, self._options.retry.autoAttemptDelay * 1000);

                return true;
            }
        },

        _onBeforeAutoRetry: function(id, name) {
            this.log("Waiting " + this._options.retry.autoAttemptDelay + " seconds before retrying " + name + "...");
        },

        //return false if we should not attempt the requested retry
        _onBeforeManualRetry: function(id) {
            var itemLimit = this._currentItemLimit,
                fileName;

            if (this._preventRetries[id]) {
                this.log("Retries are forbidden for id " + id, "warn");
                return false;
            }
            else if (this._handler.isValid(id)) {
                fileName = this.getName(id);

                if (this._options.callbacks.onManualRetry(id, fileName) === false) {
                    return false;
                }

                if (itemLimit > 0 && this._netUploadedOrQueued + 1 > itemLimit) {
                    this._itemError("retryFailTooManyItems");
                    return false;
                }

                this.log("Retrying upload for '" + fileName + "' (id: " + id + ")...");
                return true;
            }
            else {
                this.log("'" + id + "' is not a valid file ID", "error");
                return false;
            }
        },

        _onCancel: function(id, name) {
            this._netUploadedOrQueued--;

            clearTimeout(this._retryTimeouts[id]);

            var storedItemIndex = qq.indexOf(this._storedIds, id);
            if (!this._options.autoUpload && storedItemIndex >= 0) {
                this._storedIds.splice(storedItemIndex, 1);
            }

            this._uploadData.setStatus(id, qq.status.CANCELED);
        },

        _onComplete: function(id, name, result, xhr) {
            if (!result.success) {
                this._netUploadedOrQueued--;
                this._uploadData.setStatus(id, qq.status.UPLOAD_FAILED);

                if (result[this._options.retry.preventRetryResponseProperty] === true) {
                    this._preventRetries[id] = true;
                }
            }
            else {
                if (result.thumbnailUrl) {
                    this._thumbnailUrls[id] = result.thumbnailUrl;
                }

                this._netUploaded++;
                this._uploadData.setStatus(id, qq.status.UPLOAD_SUCCESSFUL);
            }

            this._maybeParseAndSendUploadError(id, name, result, xhr);

            return result.success ? true : false;
        },

        _onDelete: function(id) {
            this._uploadData.setStatus(id, qq.status.DELETING);
        },

        _onDeleteComplete: function(id, xhrOrXdr, isError) {
            var name = this.getName(id);

            if (isError) {
                this._uploadData.setStatus(id, qq.status.DELETE_FAILED);
                this.log("Delete request for '" + name + "' has failed.", "error");

                // For error reporting, we only have access to the response status if this is not
                // an `XDomainRequest`.
                if (xhrOrXdr.withCredentials === undefined) {
                    this._options.callbacks.onError(id, name, "Delete request failed", xhrOrXdr);
                }
                else {
                    this._options.callbacks.onError(id, name, "Delete request failed with response code " + xhrOrXdr.status, xhrOrXdr);
                }
            }
            else {
                this._netUploadedOrQueued--;
                this._netUploaded--;
                this._handler.expunge(id);
                this._uploadData.setStatus(id, qq.status.DELETED);
                this.log("Delete request for '" + name + "' has succeeded.");
            }
        },

        _onInputChange: function(input) {
            var fileIndex;

            if (qq.supportedFeatures.ajaxUploading) {
                for (fileIndex = 0; fileIndex < input.files.length; fileIndex++) {
                    this._annotateWithButtonId(input.files[fileIndex], input);
                }

                this.addFiles(input.files);
            }
            // Android 2.3.x will fire `onchange` even if no file has been selected
            else if (input.value.length > 0) {
                this.addFiles(input);
            }

            qq.each(this._buttons, function(idx, button) {
                button.reset();
            });
        },

        _onProgress: function(id, name, loaded, total) {
            if ( this._totalProgress ) { this._totalProgress.onIndividualProgress(id, loaded, total); }
        },

        _onSubmit: function(id, name) {
            //nothing to do yet in core uploader
        },

        _onSubmitCallbackSuccess: function(id, name) {
            this._onSubmit.apply(this, arguments);
            this._uploadData.setStatus(id, qq.status.SUBMITTED);
            this._onSubmitted.apply(this, arguments);

            if (this._options.autoUpload) {
                this._options.callbacks.onSubmitted.apply(this, arguments);
                this._uploadFile(id);
            }
            else {
                this._storeForLater(id);
                this._options.callbacks.onSubmitted.apply(this, arguments);
            }
        },

        _onSubmitDelete: function(id, onSuccessCallback, additionalMandatedParams) {
            var uuid = this.getUuid(id),
                adjustedOnSuccessCallback;

            if (onSuccessCallback) {
                adjustedOnSuccessCallback = qq.bind(onSuccessCallback, this, id, uuid, additionalMandatedParams);
            }

            if (this._isDeletePossible()) {
                this._handleCheckedCallback({
                    name: "onSubmitDelete",
                    callback: qq.bind(this._options.callbacks.onSubmitDelete, this, id),
                    onSuccess: adjustedOnSuccessCallback ||
                        qq.bind(this._deleteHandler.sendDelete, this, id, uuid, additionalMandatedParams),
                    identifier: id
                });
                return true;
            }
            else {
                this.log("Delete request ignored for ID " + id + ", delete feature is disabled or request not possible " +
                    "due to CORS on a user agent that does not support pre-flighting.", "warn");
                return false;
            }
        },

        log: function( msg ) {
            console.log( '[fine-uploader] ' + msg ); //jshint ignore:line
        },

        _onSubmitted: function(id) {
            //nothing to do in the base uploader
        },

        _onTotalProgress: function(loaded, total) {
            this._options.callbacks.onTotalProgress(loaded, total);
        },

        _onUploadPrep: function(id) {
            // nothing to do in the core uploader for now
        },

        _onUpload: function(id /*, name */) {
            this._uploadData.setStatus(id, qq.status.UPLOADING);
        },

        _onUploadChunk: function(id, chunkData) {
            //nothing to do in the base uploader
        },

        _onUploadStatusChange: function(id, oldStatus, newStatus) {
            // Make sure a "queued" retry attempt is canceled if the upload has been paused
            if (newStatus === qq.status.PAUSED) {
                clearTimeout(this._retryTimeouts[id]);
            }
        },

        _onValidateBatchCallbackFailure: function(fileWrappers) {
            var self = this;

            qq.each(fileWrappers, function(idx, fileWrapper) {
                self._fileOrBlobRejected(fileWrapper.id);
            });
        },

        _onValidateBatchCallbackSuccess: function(validationDescriptors, items, params, endpoint, button) {
            var errorMessage,
                itemLimit = this._currentItemLimit,
                proposedNetFilesUploadedOrQueued = this._netUploadedOrQueued;

            if (itemLimit === 0 || proposedNetFilesUploadedOrQueued <= itemLimit) {
                if (items.length > 0) {
                    this._handleCheckedCallback({
                        name: "onValidate",
                        callback: qq.bind(this._options.callbacks.onValidate, this, validationDescriptors[0], button),
                        onSuccess: qq.bind(this._onValidateCallbackSuccess, this, items, 0, params, endpoint),
                        onFailure: qq.bind(this._onValidateCallbackFailure, this, items, 0, params, endpoint),
                        identifier: "Item '" + items[0].file.name + "', size: " + items[0].file.size
                    });
                }
                else {
                    this._itemError("noFilesError");
                }
            }
            else {
                this._onValidateBatchCallbackFailure(items);
                errorMessage = this._options.messages.tooManyItemsError
                    .replace(/\{netItems\}/g, proposedNetFilesUploadedOrQueued)
                    .replace(/\{itemLimit\}/g, itemLimit);
                this._batchError(errorMessage);
            }
        },

        _onValidateCallbackFailure: function(items, index, params, endpoint) {
            var nextIndex = index + 1;

            this._fileOrBlobRejected(items[index].id, items[index].file.name);

            this._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);
        },

        _onValidateCallbackSuccess: function(items, index, params, endpoint) {
            var self = this,
                nextIndex = index + 1,
                validationDescriptor = this._getValidationDescriptor(items[index]);

            this._validateFileOrBlobData(items[index], validationDescriptor)
                .then(
                function() {
                    self._upload(items[index].id, params, endpoint);
                    self._maybeProcessNextItemAfterOnValidateCallback(true, items, nextIndex, params, endpoint);
                },
                function() {
                    self._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);
                }
            );
        },

        _prepareItemsForUpload: function(items, params, endpoint) {
            if (items.length === 0) {
                this._itemError("noFilesError");
                return;
            }

            var validationDescriptors = this._getValidationDescriptors(items),
                buttonId = this._getButtonId(items[0].file),
                button = this._getButton(buttonId);

            this._handleCheckedCallback({
                name: "onValidateBatch",
                callback: qq.bind(this._options.callbacks.onValidateBatch, this, validationDescriptors, button),
                onSuccess: qq.bind(this._onValidateBatchCallbackSuccess, this, validationDescriptors, items, params, endpoint, button),
                onFailure: qq.bind(this._onValidateBatchCallbackFailure, this, items),
                identifier: "batch validation"
            });
        },

        _preventLeaveInProgress: function() {
            var self = this;

            this._disposeSupport.attach(window, "beforeunload", function(e) {
                if (self.getInProgress()) {
                    e = e || window.event;
                    // for ie, ff
                    e.returnValue = self._options.messages.onLeave;
                    // for webkit
                    return self._options.messages.onLeave;
                }
            });
        },

        // Attempts to refresh session data only if the `qq.Session` module exists
        // and a session endpoint has been specified.  The `onSessionRequestComplete`
        // callback will be invoked once the refresh is complete.
        _refreshSessionData: function() {
            var self = this,
                options = this._options.session;

            /* jshint eqnull:true */
            if (qq.Session && this._options.session.endpoint != null) {
                if (!this._session) {
                    qq.extend(options, this._options.cors);

                    options.log = qq.bind(this.log, this);
                    options.addFileRecord = qq.bind(this._addCannedFile, this);

                    this._session = new qq.Session(options);
                }

                setTimeout(function() {
                    self._session.refresh().then(function(response, xhrOrXdr) {
                        self._sessionRequestComplete();
                        self._options.callbacks.onSessionRequestComplete(response, true, xhrOrXdr);

                    }, function(response, xhrOrXdr) {

                        self._options.callbacks.onSessionRequestComplete(response, false, xhrOrXdr);
                    });
                }, 0);
            }
        },

        _sessionRequestComplete: function() {},

        _setSize: function(id, newSize) {
            this._uploadData.updateSize(id, newSize);
            if ( this._totalProgress ) { this._totalProgress.onNewSize(id); }
        },

        _shouldAutoRetry: function(id, name, responseJSON) {
            var uploadData = this._uploadData.retrieve({id: id});

            /*jshint laxbreak: true */
            if (!this._preventRetries[id]
                && this._options.retry.enableAuto
                && uploadData.status !== qq.status.PAUSED) {

                if (this._autoRetries[id] === undefined) {
                    this._autoRetries[id] = 0;
                }

                if (this._autoRetries[id] < this._options.retry.maxAutoAttempts) {
                    this._autoRetries[id] += 1;
                    return true;
                }
            }

            return false;
        },

        _storeForLater: function(id) {
            this._storedIds.push(id);
        },

        // Maps a file with the button that was used to select it.
        _trackButton: function(id) {
            var buttonId;

            if (qq.supportedFeatures.ajaxUploading) {
                buttonId = this._handler.getFile(id).qqButtonId;
            }
            else {
                buttonId = this._getButtonId(this._handler.getInput(id));
            }

            if (buttonId) {
                this._buttonIdsForFileIds[id] = buttonId;
            }
        },

        _updateFormSupportAndParams: function(formElementOrId) {
            this._options.form.element = formElementOrId;

            this._formSupport = qq.FormSupport && new qq.FormSupport(
                    this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this)
                );

            if (this._formSupport && this._formSupport.attachedToForm) {
                this._paramsStore.addReadOnly(null, this._formSupport.getFormInputsAsObject);

                this._options.autoUpload = this._formSupport.newAutoUpload;
                if (this._formSupport.newEndpoint) {
                    this.setEndpoint(this._formSupport.newEndpoint);
                }
            }
        },

        _upload: function(id, params, endpoint) {
            var name = this.getName(id);

            if (params) {
                this.setParams(params, id);
            }

            if (endpoint) {
                this.setEndpoint(endpoint, id);
            }

            this._handleCheckedCallback({
                name: "onSubmit",
                callback: qq.bind(this._options.callbacks.onSubmit, this, id, name),
                onSuccess: qq.bind(this._onSubmitCallbackSuccess, this, id, name),
                onFailure: qq.bind(this._fileOrBlobRejected, this, id, name),
                identifier: id
            });
        },

        _uploadFile: function(id) {
            if (!this._handler.upload(id)) {
                this._uploadData.setStatus(id, qq.status.QUEUED);
            }
        },

        _uploadStoredFiles: function() {
            var idToUpload, stillSubmitting,
                self = this;

            while (this._storedIds.length) {
                idToUpload = this._storedIds.shift();
                this._uploadFile(idToUpload);
            }

            // If we are still waiting for some files to clear validation, attempt to upload these again in a bit
            stillSubmitting = this.getUploads({status: qq.status.SUBMITTING}).length;
            if (stillSubmitting) {
                qq.log("Still waiting for " + stillSubmitting + " files to clear submit queue. Will re-parse stored IDs array shortly.");
                setTimeout(function() {
                    self._uploadStoredFiles();
                }, 1000);
            }
        },

        /**
         * Performs some internal validation checks on an item, defined in the `validation` option.
         *
         * @param fileWrapper Wrapper containing a `file` along with an `id`
         * @param validationDescriptor Normalized information about the item (`size`, `name`).
         * @returns qq.Promise with appropriate callbacks invoked depending on the validity of the file
         * @private
         */
        _validateFileOrBlobData: function(fileWrapper, validationDescriptor) {
            var self = this,
                file = (function() {
                    if (fileWrapper.file instanceof qq.BlobProxy) {
                        return fileWrapper.file.referenceBlob;
                    }
                    return fileWrapper.file;
                }()),
                name = validationDescriptor.name,
                size = validationDescriptor.size,
                buttonId = this._getButtonId(fileWrapper.file),
                validationBase = this._getValidationBase(buttonId),
                validityChecker = new qq.Promise();

            validityChecker.then(
                function() {},
                function() {
                    self._fileOrBlobRejected(fileWrapper.id, name);
                });

            if (qq.isFileOrInput(file) && !this._isAllowedExtension(validationBase.allowedExtensions, name)) {
                this._itemError("typeError", name, file);
                return validityChecker.failure();
            }

            if (size === 0) {
                this._itemError("emptyError", name, file);
                return validityChecker.failure();
            }

            if (size > 0 && validationBase.sizeLimit && size > validationBase.sizeLimit) {
                this._itemError("sizeError", name, file);
                return validityChecker.failure();
            }

            if (size > 0 && size < validationBase.minSizeLimit) {
                this._itemError("minSizeError", name, file);
                return validityChecker.failure();
            }

            if (qq.ImageValidation && qq.supportedFeatures.imagePreviews && qq.isFile(file)) {
                new qq.ImageValidation(file, qq.bind(self.log, self)).validate(validationBase.image).then(
                    validityChecker.success,
                    function(errorCode) {
                        self._itemError(errorCode + "ImageError", name, file);
                        validityChecker.failure();
                    }
                );
            }
            else {
                validityChecker.success();
            }

            return validityChecker;
        },

        _wrapCallbacks: function() {
            var self, safeCallback, prop;

            self = this;

            safeCallback = function(name, callback, args) {
                var errorMsg;

                try {
                    return callback.apply(self, args);
                }
                catch (exception) {
                    errorMsg = exception.message || exception.toString();
                    self.log("Caught exception in '" + name + "' callback - " + errorMsg, "error");
                }
            };

            /* jshint forin: false, loopfunc: true */
            for (prop in this._options.callbacks) {
                (function() {
                    var callbackName, callbackFunc;
                    callbackName = prop;
                    callbackFunc = self._options.callbacks[callbackName];
                    self._options.callbacks[callbackName] = function() {
                        return safeCallback(callbackName, callbackFunc, arguments);
                    };
                }());
            }
        }
    };
}());

/*globals qq*/
(function() {

    qq.FineUploaderBasic = function(o) {
        var self = this;

        // These options define FineUploaderBasic mode.
        this._options = {
            debug: false,
            button: null,
            multiple: true,
            maxConnections: 3,
            disableCancelForFormUploads: false,
            autoUpload: true,

            request: {
                customHeaders: {},
                endpoint: "/server/upload",
                filenameParam: "qqfilename",
                forceMultipart: true,
                inputName: "qqfile",
                method: "POST",
                params: {},
                paramsInBody: true,
                totalFileSizeName: "qqtotalfilesize",
                uuidName: "qquuid"
            },

            validation: {
                allowedExtensions: [],
                sizeLimit: 0,
                minSizeLimit: 0,
                itemLimit: 0,
                stopOnFirstInvalidFile: true,
                acceptFiles: null,
                image: {
                    maxHeight: 0,
                    maxWidth: 0,
                    minHeight: 0,
                    minWidth: 0
                }
            },

            callbacks: {
                onSubmit: function(id, name) {},
                onSubmitted: function(id, name) {},
                onComplete: function(id, name, responseJSON, maybeXhr) {},
                onAllComplete: function(successful, failed) {},
                onCancel: function(id, name) {},
                onUpload: function(id, name) {},
                onUploadChunk: function(id, name, chunkData) {},
                onUploadChunkSuccess: function(id, chunkData, responseJSON, xhr) {},
                onResume: function(id, fileName, chunkData) {},
                onProgress: function(id, name, loaded, total) {},
                onTotalProgress: function(loaded, total) {},
                onError: function(id, name, reason, maybeXhrOrXdr) {},
                onAutoRetry: function(id, name, attemptNumber) {},
                onManualRetry: function(id, name) {},
                onValidateBatch: function(fileOrBlobData) {},
                onValidate: function(fileOrBlobData) {},
                onSubmitDelete: function(id) {},
                onDelete: function(id) {},
                onDeleteComplete: function(id, xhrOrXdr, isError) {},
                onPasteReceived: function(blob) {},
                onStatusChange: function(id, oldStatus, newStatus) {},
                onSessionRequestComplete: function(response, success, xhrOrXdr) {}
            },

            messages: {
                typeError: "Hochladen der Datei nicht mglich. Dateiformat wird nicht untersttzt! Gltige Dateitypen(s): {extensions}.<br/><br/>{file}",
                sizeError: "Die maximale Dateigre ist berschritten, die maximale Dateigre ist: {sizeLimit}.<br/><br/>{file}",
                minSizeError: "Die minimale Dateigre ist unterschritten, die minimale Dateigre ist: {minSizeLimit}<br/><br/>{file}",
                emptyError: "Keine Datei ausgewhlt! Bitte Dateie(n) neu Auswhlen!<br/><br/>{file}",
                noFilesError: "No files to upload.",
                tooManyItemsError: "Zu viele Dateien ausgewhlt! Die maximal auswhlbare Anzahl betrgt: {itemLimit}",
                maxHeightImageError: "Das Bild ist zu hoch! Hochladen nicht mglich!",
                maxWidthImageError: "Das Bild ist zu breit. Hochladen nicht mglich!",
                minHeightImageError: "Das Bild hat nicht die Mindesthhe! Hochladen nicht mglich!",
                minWidthImageError: "Das Bild hat nicht die Mindestbreite. Hochladen nicht mglich!",
                retryFailTooManyItems: "Wiederholen fehl geschlagen. Der maxinmal verfgbare Speicherplatz ist berschritten!",
                onLeave: "Dateien werden gerade hochgeladen. Wenn Sie den Vorgang abbrechen wird das Hochladen abgebrochen!",
                unsupportedBrowserIos8Safari: "Nicht behebbarer Fehler - dieser Browser untersttzt das Hochladen von Dateien jeglicher Art aufgrund schwerwiegender Fehler in iOS8 Safari nicht. Bitte verwenden Sie iOS8 Chrome bis Apple diese Probleme behebt."

                /*
                sizeError: "{file} is too large, maximum file size is {sizeLimit}.",
                minSizeError: "{file} is too small, minimum file size is {minSizeLimit}.",
                emptyError: "{file} is empty, please select files again without it.",
                noFilesError: "No files to upload.",
                tooManyItemsError: "Too many items ({netItems}) would be uploaded.  Item limit is {itemLimit}.",
                maxHeightImageError: "Image is too tall.",
                maxWidthImageError: "Image is too wide.",
                minHeightImageError: "Image is not tall enough.",
                minWidthImageError: "Image is not wide enough.",
                retryFailTooManyItems: "Retry failed - you have reached your file limit.",
                onLeave: "The files are being uploaded, if you leave now the upload will be canceled.",
                unsupportedBrowserIos8Safari: "Unrecoverable error - this browser does not permit file uploading of any kind due to serious bugs in iOS8 Safari.  Please use iOS8 Chrome until Apple fixes these issues."
                */
            },

            retry: {
                enableAuto: false,
                maxAutoAttempts: 3,
                autoAttemptDelay: 5,
                preventRetryResponseProperty: "preventRetry"
            },

            classes: {
                buttonHover: "qq-upload-button-hover",
                buttonFocus: "qq-upload-button-focus"
            },

            chunking: {
                enabled: false,
                concurrent: {
                    enabled: false
                },
                mandatory: false,
                paramNames: {
                    partIndex: "qqpartindex",
                    partByteOffset: "qqpartbyteoffset",
                    chunkSize: "qqchunksize",
                    totalFileSize: "qqtotalfilesize",
                    totalParts: "qqtotalparts"
                },
                partSize: 2000000,
                // only relevant for traditional endpoints, only required when concurrent.enabled === true
                success: {
                    endpoint: null
                }
            },

            resume: {
                enabled: false,
                recordsExpireIn: 7, //days
                paramNames: {
                    resuming: "qqresume"
                }
            },

            formatFileName: function(fileOrBlobName) {
                return fileOrBlobName;
            },

            text: {
                defaultResponseError: "Upload failure reason unknown",
                fileInputTitle: "file input",
                sizeSymbols: ["kB", "MB", "GB", "TB", "PB", "EB"]
            },

            deleteFile: {
                enabled: false,
                method: "DELETE",
                endpoint: "/server/upload",
                customHeaders: {},
                params: {}
            },

            cors: {
                expected: false,
                sendCredentials: false,
                allowXdr: false
            },

            blobs: {
                defaultName: "misc_data"
            },

            paste: {
                targetElement: null,
                defaultName: "pasted_image"
            },

            camera: {
                ios: false,

                // if ios is true: button is null means target the default button, otherwise target the button specified
                button: null
            },

            // This refers to additional upload buttons to be handled by Fine Uploader.
            // Each element is an object, containing `element` as the only required
            // property.  The `element` must be a container that will ultimately
            // contain an invisible `<input type="file">` created by Fine Uploader.
            // Optional properties of each object include `multiple`, `validation`,
            // and `folders`.
            extraButtons: [],

            // Depends on the session module.  Used to query the server for an initial file list
            // during initialization and optionally after a `reset`.
            session: {
                endpoint: null,
                params: {},
                customHeaders: {},
                refreshOnReset: true
            },

            // Send parameters associated with an existing form along with the files
            form: {
                // Element ID, HTMLElement, or null
                element: "qq-form",

                // Overrides the base `autoUpload`, unless `element` is null.
                autoUpload: false,

                // true = upload files on form submission (and squelch submit event)
                interceptSubmit: true
            },

            // scale images client side, upload a new file for each scaled version
            scaling: {
                customResizer: null,

                // send the original file as well
                sendOriginal: true,

                // fox orientation for scaled images
                orient: true,

                // If null, scaled image type will match reference image type.  This value will be referred to
                // for any size record that does not specific a type.
                defaultType: null,

                defaultQuality: 80,

                failureText: "Failed to scale",

                includeExif: false,

                // metadata about each requested scaled version
                sizes: []
            },

            workarounds: {
                iosEmptyVideos: true,
                ios8SafariUploads: true,
                ios8BrowserCrash: false
            }
        };

        // Replace any default options with user defined ones
        qq.extend(this._options, o, true);

        this._buttons = [];
        this._extraButtonSpecs = {};
        this._buttonIdsForFileIds = [];

        this._wrapCallbacks();
        this._disposeSupport =  new qq.DisposeSupport();

        this._storedIds = [];
        this._autoRetries = [];
        this._retryTimeouts = [];
        this._preventRetries = [];
        this._thumbnailUrls = [];

        this._netUploadedOrQueued = 0;
        this._netUploaded = 0;
        this._uploadData = this._createUploadDataTracker();

        this._initFormSupportAndParams();

        this._customHeadersStore = this._createStore(this._options.request.customHeaders);
        this._deleteFileCustomHeadersStore = this._createStore(this._options.deleteFile.customHeaders);

        this._deleteFileParamsStore = this._createStore(this._options.deleteFile.params);

        this._endpointStore = this._createStore(this._options.request.endpoint);
        this._deleteFileEndpointStore = this._createStore(this._options.deleteFile.endpoint);

        this._handler = this._createUploadHandler();

        this._deleteHandler = qq.DeleteFileAjaxRequester && this._createDeleteHandler();

        if (this._options.button) {
            this._defaultButtonId = this._createUploadButton({
                element: this._options.button,
                title: this._options.text.fileInputTitle
            }).getButtonId();
        }

        this._generateExtraButtonSpecs();

        this._handleCameraAccess();

        if (this._options.paste.targetElement) {
            if (qq.PasteSupport) {
                this._pasteHandler = this._createPasteHandler();
            }
            else {
                this.log("Paste support module not found", "error");
            }
        }

        this._preventLeaveInProgress();

        this._imageGenerator = qq.ImageGenerator && new qq.ImageGenerator(qq.bind(this.log, this));
        this._refreshSessionData();

        this._succeededSinceLastAllComplete = [];
        this._failedSinceLastAllComplete = [];

        this._scaler = (qq.Scaler && new qq.Scaler(this._options.scaling, qq.bind(this.log, this))) || {};
        if (this._scaler.enabled) {
            this._customNewFileHandler = qq.bind(this._scaler.handleNewFile, this._scaler);
        }

        if (qq.TotalProgress && qq.supportedFeatures.progressBar) {
            this._totalProgress = new qq.TotalProgress(
                qq.bind(this._onTotalProgress, this),

                function(id) {
                    var entry = self._uploadData.retrieve({id: id});
                    return (entry && entry.size) || 0;
                }
            );
        }

        this._currentItemLimit = this._options.validation.itemLimit;
    };

    // Define the private & public API methods.
    qq.FineUploaderBasic.prototype = qq.basePublicApi;
    qq.extend(qq.FineUploaderBasic.prototype, qq.basePrivateApi);
}());

/*globals qq, XDomainRequest*/
/** Generic class for sending non-upload ajax requests and handling the associated responses **/
qq.AjaxRequester = function(o) {

    var log, shouldParamsBeInQueryString,
        queue = [],
        requestData = {},
        options = {
            acceptHeader: null,
            validMethods: ["PATCH", "POST", "PUT"],
            method: "POST",
            contentType: "application/x-www-form-urlencoded",
            maxConnections: 3,
            customHeaders: {},
            endpointStore: {},
            paramsStore: {},
            mandatedParams: {},
            allowXRequestedWithAndCacheControl: true,
            successfulResponseCodes: {
                DELETE: [200, 202, 204],
                PATCH: [200, 201, 202, 203, 204],
                POST: [200, 201, 202, 203, 204],
                PUT: [200, 201, 202, 203, 204],
                GET: [200]
            },
            cors: {
                expected: false,
                sendCredentials: false
            },
            log: function(str, level) {},
            onSend: function(id) {},
            onComplete: function(id, xhrOrXdr, isError) {},
            onProgress: null
        };

    qq.extend(options, o);
    log = options.log;

    if (qq.indexOf(options.validMethods, options.method) < 0) {
        throw new Error("'" + options.method + "' is not a supported method for this type of request!");
    }

    // [Simple methods](http://www.w3.org/TR/cors/#simple-method)
    // are defined by the W3C in the CORS spec as a list of methods that, in part,
    // make a CORS request eligible to be exempt from preflighting.
    function isSimpleMethod() {
        return qq.indexOf(["GET", "POST", "HEAD"], options.method) >= 0;
    }

    // [Simple headers](http://www.w3.org/TR/cors/#simple-header)
    // are defined by the W3C in the CORS spec as a list of headers that, in part,
    // make a CORS request eligible to be exempt from preflighting.
    function containsNonSimpleHeaders(headers) {
        var containsNonSimple = false;

        qq.each(containsNonSimple, function(idx, header) {
            if (qq.indexOf(["Accept", "Accept-Language", "Content-Language", "Content-Type"], header) < 0) {
                containsNonSimple = true;
                return false;
            }
        });

        return containsNonSimple;
    }

    function isXdr(xhr) {
        //The `withCredentials` test is a commonly accepted way to determine if XHR supports CORS.
        return options.cors.expected && xhr.withCredentials === undefined;
    }

    // Returns either a new `XMLHttpRequest` or `XDomainRequest` instance.
    function getCorsAjaxTransport() {
        var xhrOrXdr;

        if (window.XMLHttpRequest || window.ActiveXObject) {
            xhrOrXdr = qq.createXhrInstance();

            if (xhrOrXdr.withCredentials === undefined) {
                xhrOrXdr = new XDomainRequest();
                // Workaround for XDR bug in IE9 - https://social.msdn.microsoft.com/Forums/ie/en-US/30ef3add-767c-4436-b8a9-f1ca19b4812e/ie9-rtm-xdomainrequest-issued-requests-may-abort-if-all-event-handlers-not-specified?forum=iewebdevelopment
                xhrOrXdr.onload = function() {};
                xhrOrXdr.onerror = function() {};
                xhrOrXdr.ontimeout = function() {};
                xhrOrXdr.onprogress = function() {};
            }
        }

        return xhrOrXdr;
    }

    // Returns either a new XHR/XDR instance, or an existing one for the associated `File` or `Blob`.
    function getXhrOrXdr(id, suppliedXhr) {
        var xhrOrXdr = requestData[id].xhr;

        if (!xhrOrXdr) {
            if (suppliedXhr) {
                xhrOrXdr = suppliedXhr;
            }
            else {
                if (options.cors.expected) {
                    xhrOrXdr = getCorsAjaxTransport();
                }
                else {
                    xhrOrXdr = qq.createXhrInstance();
                }
            }

            requestData[id].xhr = xhrOrXdr;
        }

        return xhrOrXdr;
    }

    // Removes element from queue, sends next request
    function dequeue(id) {
        var i = qq.indexOf(queue, id),
            max = options.maxConnections,
            nextId;

        delete requestData[id];
        queue.splice(i, 1);

        if (queue.length >= max && i < max) {
            nextId = queue[max - 1];
            sendRequest(nextId);
        }
    }

    function onComplete(id, xdrError) {
        var xhr = getXhrOrXdr(id),
            method = options.method,
            isError = xdrError === true;

        dequeue(id);

        if (isError) {
            log(method + " request for " + id + " has failed", "error");
        }
        else if (!isXdr(xhr) && !isResponseSuccessful(xhr.status)) {
            isError = true;
            log(method + " request for " + id + " has failed - response code " + xhr.status, "error");
        }

        options.onComplete(id, xhr, isError);
    }

    function getParams(id) {
        var onDemandParams = requestData[id].additionalParams,
            mandatedParams = options.mandatedParams,
            params;

        if (options.paramsStore.get) {
            params = options.paramsStore.get(id);
        }

        if (onDemandParams) {
            qq.each(onDemandParams, function(name, val) {
                params = params || {};
                params[name] = val;
            });
        }

        if (mandatedParams) {
            qq.each(mandatedParams, function(name, val) {
                params = params || {};
                params[name] = val;
            });
        }

        return params;
    }

    function sendRequest(id, optXhr) {
        var xhr = getXhrOrXdr(id, optXhr),
            method = options.method,
            params = getParams(id),
            payload = requestData[id].payload,
            url;

        options.onSend(id);

        url = createUrl(id, params, requestData[id].additionalQueryParams);

        // XDR and XHR status detection APIs differ a bit.
        if (isXdr(xhr)) {
            xhr.onload = getXdrLoadHandler(id);
            xhr.onerror = getXdrErrorHandler(id);
        }
        else {
            xhr.onreadystatechange = getXhrReadyStateChangeHandler(id);
        }

        registerForUploadProgress(id);

        // The last parameter is assumed to be ignored if we are actually using `XDomainRequest`.
        xhr.open(method, url, true);

        // Instruct the transport to send cookies along with the CORS request,
        // unless we are using `XDomainRequest`, which is not capable of this.
        if (options.cors.expected && options.cors.sendCredentials && !isXdr(xhr)) {
            xhr.withCredentials = true;
        }

        setHeaders(id);

        log("Sending " + method + " request for " + id);

        if (payload) {
            xhr.send(payload);
        }
        else if (shouldParamsBeInQueryString || !params) {
            xhr.send();
        }
        else if (params && options.contentType && options.contentType.toLowerCase().indexOf("application/x-www-form-urlencoded") >= 0) {
            xhr.send(qq.obj2url(params, ""));
        }
        else if (params && options.contentType && options.contentType.toLowerCase().indexOf("application/json") >= 0) {
            xhr.send(JSON.stringify(params));
        }
        else {
            xhr.send(params);
        }

        return xhr;
    }

    function createUrl(id, params, additionalQueryParams) {
        var endpoint = options.endpointStore.get(id),
            addToPath = requestData[id].addToPath;

        /*jshint -W116,-W041 */
        if (addToPath != undefined) {
            endpoint += "/" + addToPath;
        }

        if (shouldParamsBeInQueryString && params) {
            endpoint = qq.obj2url(params, endpoint);
        }

        if (additionalQueryParams) {
            endpoint = qq.obj2url(additionalQueryParams, endpoint);
        }

        return endpoint;
    }

    // Invoked by the UA to indicate a number of possible states that describe
    // a live `XMLHttpRequest` transport.
    function getXhrReadyStateChangeHandler(id) {
        return function() {
            if (getXhrOrXdr(id).readyState === 4) {
                onComplete(id);
            }
        };
    }

    function registerForUploadProgress(id) {
        var onProgress = options.onProgress;

        if (onProgress) {
            getXhrOrXdr(id).upload.onprogress = function(e) {
                if (e.lengthComputable) {
                    onProgress(id, e.loaded, e.total);
                }
            };
        }
    }

    // This will be called by IE to indicate **success** for an associated
    // `XDomainRequest` transported request.
    function getXdrLoadHandler(id) {
        return function() {
            onComplete(id);
        };
    }

    // This will be called by IE to indicate **failure** for an associated
    // `XDomainRequest` transported request.
    function getXdrErrorHandler(id) {
        return function() {
            onComplete(id, true);
        };
    }

    function setHeaders(id) {
        var xhr = getXhrOrXdr(id),
            customHeaders = options.customHeaders,
            onDemandHeaders = requestData[id].additionalHeaders || {},
            method = options.method,
            allHeaders = {};

        // If XDomainRequest is being used, we can't set headers, so just ignore this block.
        if (!isXdr(xhr)) {
            if ( options.acceptHeader ) { xhr.setRequestHeader("Accept", options.acceptHeader); }

            // Only attempt to add X-Requested-With & Cache-Control if permitted
            if (options.allowXRequestedWithAndCacheControl) {
                // Do not add X-Requested-With & Cache-Control if this is a cross-origin request
                // OR the cross-origin request contains a non-simple method or header.
                // This is done to ensure a preflight is not triggered exclusively based on the
                // addition of these 2 non-simple headers.
                if (!options.cors.expected || (!isSimpleMethod() || containsNonSimpleHeaders(customHeaders))) {
                    xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                    xhr.setRequestHeader("Cache-Control", "no-cache");
                }
            }

            if (options.contentType && (method === "POST" || method === "PUT")) {
                xhr.setRequestHeader("Content-Type", options.contentType);
            }

            qq.extend(allHeaders, qq.isFunction(customHeaders) ? customHeaders(id) : customHeaders);
            qq.extend(allHeaders, onDemandHeaders);

            qq.each(allHeaders, function(name, val) {
                xhr.setRequestHeader(name, val);
            });
        }
    }

    function isResponseSuccessful(responseCode) {
        return qq.indexOf(options.successfulResponseCodes[options.method], responseCode) >= 0;
    }

    function prepareToSend(id, optXhr, addToPath, additionalParams, additionalQueryParams, additionalHeaders, payload) {
        requestData[id] = {
            addToPath: addToPath,
            additionalParams: additionalParams,
            additionalQueryParams: additionalQueryParams,
            additionalHeaders: additionalHeaders,
            payload: payload
        };

        var len = queue.push(id);

        // if too many active connections, wait...
        if (len <= options.maxConnections) {
            return sendRequest(id, optXhr);
        }
    }

    shouldParamsBeInQueryString = options.method === "GET" || options.method === "DELETE";

    qq.extend(this, {
        // Start the process of sending the request.  The ID refers to the file associated with the request.
        initTransport: function(id) {
            var path, params, headers, payload, cacheBuster, additionalQueryParams;

            return {
                // Optionally specify the end of the endpoint path for the request.
                withPath: function(appendToPath) {
                    path = appendToPath;
                    return this;
                },

                // Optionally specify additional parameters to send along with the request.
                // These will be added to the query string for GET/DELETE requests or the payload
                // for POST/PUT requests.  The Content-Type of the request will be used to determine
                // how these parameters should be formatted as well.
                withParams: function(additionalParams) {
                    params = additionalParams;
                    return this;
                },

                withQueryParams: function(_additionalQueryParams_) {
                    additionalQueryParams = _additionalQueryParams_;
                    return this;
                },

                // Optionally specify additional headers to send along with the request.
                withHeaders: function(additionalHeaders) {
                    headers = additionalHeaders;
                    return this;
                },

                // Optionally specify a payload/body for the request.
                withPayload: function(thePayload) {
                    payload = thePayload;
                    return this;
                },

                // Appends a cache buster (timestamp) to the request URL as a query parameter (only if GET or DELETE)
                withCacheBuster: function() {
                    cacheBuster = true;
                    return this;
                },

                // Send the constructed request.
                send: function(optXhr) {
                    if (cacheBuster && qq.indexOf(["GET", "DELETE"], options.method) >= 0) {
                        params.qqtimestamp = new Date().getTime();
                    }

                    return prepareToSend(id, optXhr, path, params, additionalQueryParams, headers, payload);
                }
            };
        },

        canceled: function(id) {
            dequeue(id);
        }
    });
};

/* globals qq */
/**
 * Common upload handler functions.
 *
 * @constructor
 */
qq.UploadHandler = function(spec) {

    var proxy = spec.proxy,
        fileState = {},
        onCancel = proxy.onCancel,
        getName = proxy.getName;

    qq.extend(this, {
        add: function(id, fileItem) {
            fileState[id] = fileItem;
            fileState[id].temp = {};
        },

        cancel: function(id) {
            var self = this,
                cancelFinalizationEffort = new qq.Promise(),
                onCancelRetVal = onCancel(id, getName(id), cancelFinalizationEffort);

            onCancelRetVal.then(function() {
                if (self.isValid(id)) {
                    fileState[id].canceled = true;
                    self.expunge(id);
                }
                cancelFinalizationEffort.success();
            });
        },

        expunge: function(id) {
            delete fileState[id];
        },

        getThirdPartyFileId: function(id) {
            return fileState[id].key;
        },

        isValid: function(id) {
            return fileState[id] !== undefined;
        },

        reset: function() {
            fileState = {};
        },

        _getFileState: function(id) {
            return fileState[id];
        },

        _setThirdPartyFileId: function(id, thirdPartyFileId) {
            fileState[id].key = thirdPartyFileId;
        },

        _wasCanceled: function(id) {
            return !!fileState[id].canceled;
        }
    });
};

/*globals qq*/
/**
 * Base upload handler module.  Controls more specific handlers.
 *
 * @param o Options.  Passed along to the specific handler submodule as well.
 * @param namespace [optional] Namespace for the specific handler.
 */
qq.UploadHandlerController = function(o, namespace) {

    var controller = this,
        chunkingPossible = false,
        concurrentChunkingPossible = false,
        chunking, preventRetryResponse, log, handler,

    options = {
        paramsStore: {},
        maxConnections: 3, // maximum number of concurrent uploads
        chunking: {
            enabled: false,
            multiple: {
                enabled: false
            }
        },
        log: function(str, level) {},
        onProgress: function(id, fileName, loaded, total) {},
        onComplete: function(id, fileName, response, xhr) {},
        onCancel: function(id, fileName) {},
        onUploadPrep: function(id) {}, // Called if non-trivial operations will be performed before onUpload
        onUpload: function(id, fileName) {},
        onUploadChunk: function(id, fileName, chunkData) {},
        onUploadChunkSuccess: function(id, chunkData, response, xhr) {},
        onAutoRetry: function(id, fileName, response, xhr) {},
        onResume: function(id, fileName, chunkData) {},
        onUuidChanged: function(id, newUuid) {},
        getName: function(id) {},
        setSize: function(id, newSize) {},
        isQueued: function(id) {},
        getIdsInProxyGroup: function(id) {},
        getIdsInBatch: function(id) {}
    },

    chunked = {
        // Called when each chunk has uploaded successfully
        done: function(id, chunkIdx, response, xhr) {
            var chunkData = handler._getChunkData(id, chunkIdx);

            handler._getFileState(id).attemptingResume = false;

            delete handler._getFileState(id).temp.chunkProgress[chunkIdx];
            handler._getFileState(id).loaded += chunkData.size;

            options.onUploadChunkSuccess(id, handler._getChunkDataForCallback(chunkData), response, xhr);
        },

        // Called when all chunks have been successfully uploaded and we want to ask the handler to perform any
        // logic associated with closing out the file, such as combining the chunks.
        finalize: function(id) {
            var size = options.getSize(id),
                name = options.getName(id);

            log("All chunks have been uploaded for " + id + " - finalizing....");
            handler.finalizeChunks(id).then(
                function(response, xhr) {
                    log("Finalize successful for " + id);

                    var normaizedResponse = upload.normalizeResponse(response, true);

                    options.onProgress(id, name, size, size);
                    handler._maybeDeletePersistedChunkData(id);
                    upload.cleanup(id, normaizedResponse, xhr);
                },
                function(response, xhr) {
                    var normaizedResponse = upload.normalizeResponse(response, false);

                    log("Problem finalizing chunks for file ID " + id + " - " + normaizedResponse.error, "error");

                    if (normaizedResponse.reset) {
                        chunked.reset(id);
                    }

                    if (!options.onAutoRetry(id, name, normaizedResponse, xhr)) {
                        upload.cleanup(id, normaizedResponse, xhr);
                    }
                }
            );
        },

        hasMoreParts: function(id) {
            return !!handler._getFileState(id).chunking.remaining.length;
        },

        nextPart: function(id) {
            var nextIdx = handler._getFileState(id).chunking.remaining.shift();

            if (nextIdx >= handler._getTotalChunks(id)) {
                nextIdx = null;
            }

            return nextIdx;
        },

        reset: function(id) {
            log("Server or callback has ordered chunking effort to be restarted on next attempt for item ID " + id, "error");

            handler._maybeDeletePersistedChunkData(id);
            handler.reevaluateChunking(id);
            handler._getFileState(id).loaded = 0;
        },

        sendNext: function(id) {
            var size = options.getSize(id),
                name = options.getName(id),
                chunkIdx = chunked.nextPart(id),
                chunkData = handler._getChunkData(id, chunkIdx),
                resuming = handler._getFileState(id).attemptingResume,
                inProgressChunks = handler._getFileState(id).chunking.inProgress || [];

            if (undefined === handler._getFileState(id).loaded || handler._getFileState(id).loaded === null) {
                handler._getFileState(id).loaded = 0;
            }

            // Don't follow-through with the resume attempt if the integrator returns false from onResume
            if (resuming && options.onResume(id, name, chunkData) === false) {
                chunked.reset(id);
                chunkIdx = chunked.nextPart(id);
                chunkData = handler._getChunkData(id, chunkIdx);
                resuming = false;
            }

            // If all chunks have already uploaded successfully, we must be re-attempting the finalize step.
            if (chunkIdx === null && inProgressChunks.length === 0) {
                chunked.finalize(id);
            }

            // Send the next chunk
            else {
                log(qq.format("Sending chunked upload request for item {}.{}, bytes {}-{} of {}.", id, chunkIdx, chunkData.start + 1, chunkData.end, size));
                options.onUploadChunk(id, name, handler._getChunkDataForCallback(chunkData));
                inProgressChunks.push(chunkIdx);
                handler._getFileState(id).chunking.inProgress = inProgressChunks;

                if (concurrentChunkingPossible) {
                    connectionManager.open(id, chunkIdx);
                }

                if (concurrentChunkingPossible && connectionManager.available() && handler._getFileState(id).chunking.remaining.length) {
                    chunked.sendNext(id);
                }

                handler.uploadChunk(id, chunkIdx, resuming).then(
                    // upload chunk success
                    function success(response, xhr) {
                        log("Chunked upload request succeeded for " + id + ", chunk " + chunkIdx);

                        handler.clearCachedChunk(id, chunkIdx);

                        var inProgressChunks = handler._getFileState(id).chunking.inProgress || [],
                            responseToReport = upload.normalizeResponse(response, true),
                            inProgressChunkIdx = qq.indexOf(inProgressChunks, chunkIdx);

                        log(qq.format("Chunk {} for file {} uploaded successfully.", chunkIdx, id));

                        chunked.done(id, chunkIdx, responseToReport, xhr);

                        if (inProgressChunkIdx >= 0) {
                            inProgressChunks.splice(inProgressChunkIdx, 1);
                        }

                        handler._maybePersistChunkedState(id);

                        if (!chunked.hasMoreParts(id) && inProgressChunks.length === 0) {
                            chunked.finalize(id);
                        }
                        else if (chunked.hasMoreParts(id)) {
                            chunked.sendNext(id);
                        }
                        else {
                            log(qq.format("File ID {} has no more chunks to send and these chunk indexes are still marked as in-progress: {}", id, JSON.stringify(inProgressChunks)));
                        }
                    },

                    // upload chunk failure
                    function failure(response, xhr) {
                        log("Chunked upload request failed for " + id + ", chunk " + chunkIdx);

                        handler.clearCachedChunk(id, chunkIdx);

                        var responseToReport = upload.normalizeResponse(response, false),
                            inProgressIdx;

                        if (responseToReport.reset) {
                            chunked.reset(id);
                        }
                        else {
                            inProgressIdx = qq.indexOf(handler._getFileState(id).chunking.inProgress, chunkIdx);
                            if (inProgressIdx >= 0) {
                                handler._getFileState(id).chunking.inProgress.splice(inProgressIdx, 1);
                                handler._getFileState(id).chunking.remaining.unshift(chunkIdx);
                            }
                        }

                        // We may have aborted all other in-progress chunks for this file due to a failure.
                        // If so, ignore the failures associated with those aborts.
                        if (!handler._getFileState(id).temp.ignoreFailure) {
                            // If this chunk has failed, we want to ignore all other failures of currently in-progress
                            // chunks since they will be explicitly aborted
                            if (concurrentChunkingPossible) {
                                handler._getFileState(id).temp.ignoreFailure = true;

                                log(qq.format("Going to attempt to abort these chunks: {}. These are currently in-progress: {}.", JSON.stringify(Object.keys(handler._getXhrs(id))), JSON.stringify(handler._getFileState(id).chunking.inProgress)));
                                qq.each(handler._getXhrs(id), function(ckid, ckXhr) {
                                    log(qq.format("Attempting to abort file {}.{}. XHR readyState {}. ", id, ckid, ckXhr.readyState));
                                    ckXhr.abort();
                                    // Flag the transport, in case we are waiting for some other async operation
                                    // to complete before attempting to upload the chunk
                                    ckXhr._cancelled = true;
                                });

                                // We must indicate that all aborted chunks are no longer in progress
                                handler.moveInProgressToRemaining(id);

                                // Free up any connections used by these chunks, but don't allow any
                                // other files to take up the connections (until we have exhausted all auto-retries)
                                connectionManager.free(id, true);
                            }

                            if (!options.onAutoRetry(id, name, responseToReport, xhr)) {
                                // If one chunk fails, abort all of the others to avoid odd race conditions that occur
                                // if a chunk succeeds immediately after one fails before we have determined if the upload
                                // is a failure or not.
                                upload.cleanup(id, responseToReport, xhr);
                            }
                        }
                    }
                )
                    .done(function() {
                        handler.clearXhr(id, chunkIdx);
                    }) ;
            }
        }
    },

    connectionManager = {
        _open: [],
        _openChunks: {},
        _waiting: [],

        available: function() {
            var max = options.maxConnections,
                openChunkEntriesCount = 0,
                openChunksCount = 0;

            qq.each(connectionManager._openChunks, function(fileId, openChunkIndexes) {
                openChunkEntriesCount++;
                openChunksCount += openChunkIndexes.length;
            });

            return max - (connectionManager._open.length - openChunkEntriesCount + openChunksCount);
        },

        /**
         * Removes element from queue, starts upload of next
         */
        free: function(id, dontAllowNext) {
            var allowNext = !dontAllowNext,
                waitingIndex = qq.indexOf(connectionManager._waiting, id),
                connectionsIndex = qq.indexOf(connectionManager._open, id),
                nextId;

            delete connectionManager._openChunks[id];

            if (upload.getProxyOrBlob(id) instanceof qq.BlobProxy) {
                log("Generated blob upload has ended for " + id + ", disposing generated blob.");
                delete handler._getFileState(id).file;
            }

            // If this file was not consuming a connection, it was just waiting, so remove it from the waiting array
            if (waitingIndex >= 0) {
                connectionManager._waiting.splice(waitingIndex, 1);
            }
            // If this file was consuming a connection, allow the next file to be uploaded
            else if (allowNext && connectionsIndex >= 0) {
                connectionManager._open.splice(connectionsIndex, 1);

                nextId = connectionManager._waiting.shift();
                if (nextId >= 0) {
                    connectionManager._open.push(nextId);
                    upload.start(nextId);
                }
            }
        },

        getWaitingOrConnected: function() {
            var waitingOrConnected = [];

            // Chunked files may have multiple connections open per chunk (if concurrent chunking is enabled)
            // We need to grab the file ID of any file that has at least one chunk consuming a connection.
            qq.each(connectionManager._openChunks, function(fileId, chunks) {
                if (chunks && chunks.length) {
                    waitingOrConnected.push(parseInt(fileId));
                }
            });

            // For non-chunked files, only one connection will be consumed per file.
            // This is where we aggregate those file IDs.
            qq.each(connectionManager._open, function(idx, fileId) {
                if (!connectionManager._openChunks[fileId]) {
                    waitingOrConnected.push(parseInt(fileId));
                }
            });

            // There may be files waiting for a connection.
            waitingOrConnected = waitingOrConnected.concat(connectionManager._waiting);

            return waitingOrConnected;
        },

        isUsingConnection: function(id) {
            return qq.indexOf(connectionManager._open, id) >= 0;
        },

        open: function(id, chunkIdx) {
            if ( typeof chunkIdx === 'undefined' || chunkIdx === null) {
                connectionManager._waiting.push(id);
            }

            if (connectionManager.available()) {
                if ( typeof chunkIdx === 'undefined' || chunkIdx === null ) {
                    connectionManager._waiting.pop();
                    connectionManager._open.push(id);
                }
                else {
                    (function() {
                        var openChunksEntry = connectionManager._openChunks[id] || [];
                        openChunksEntry.push(chunkIdx);
                        connectionManager._openChunks[id] = openChunksEntry;
                    }());
                }

                return true;
            }

            return false;
        },

        reset: function() {
            connectionManager._waiting = [];
            connectionManager._open = [];
        }
    },

    simple = {
        send: function(id, name) {
            handler._getFileState(id).loaded = 0;

            log("Sending simple upload request for " + id);
            handler.uploadFile(id).then(
                function(response, optXhr) {
                    log("Simple upload request succeeded for " + id);

                    var responseToReport = upload.normalizeResponse(response, true),
                        size = options.getSize(id);

                    options.onProgress(id, name, size, size);
                    upload.maybeNewUuid(id, responseToReport);
                    upload.cleanup(id, responseToReport, optXhr);
                },

                function(response, optXhr) {
                    log("Simple upload request failed for " + id);

                    var responseToReport = upload.normalizeResponse(response, false);

                    if (!options.onAutoRetry(id, name, responseToReport, optXhr)) {
                        upload.cleanup(id, responseToReport, optXhr);
                    }
                }
            );
        }
    },

    upload = {
        cancel: function(id) {
            log("Cancelling " + id);
            options.paramsStore.remove(id);
            connectionManager.free(id);
        },

        cleanup: function(id, response, optXhr) {
            var name = options.getName(id);

            options.onComplete(id, name, response, optXhr);

            if (handler._getFileState(id)) {
                if ( handler._clearXhrs ) { handler._clearXhrs(id); }
            }

            connectionManager.free(id);
        },

        // Returns a qq.BlobProxy, or an actual File/Blob if no proxy is involved, or undefined
        // if none of these are available for the ID
        getProxyOrBlob: function(id) {
            return (handler.getProxy && handler.getProxy(id)) ||
                (handler.getFile && handler.getFile(id));
        },

        initHandler: function() {
            var handlerType = namespace ? qq[namespace] : qq.traditional,
                handlerModuleSubtype = qq.supportedFeatures.ajaxUploading ? "Xhr" : "Form";

            handler = new handlerType[handlerModuleSubtype + "UploadHandler"](
                options,
                {
                    getDataByUuid: options.getDataByUuid,
                    getName: options.getName,
                    getSize: options.getSize,
                    getUuid: options.getUuid,
                    log: log,
                    onCancel: options.onCancel,
                    onProgress: options.onProgress,
                    onUuidChanged: options.onUuidChanged
                }
            );

            if (handler._removeExpiredChunkingRecords) {
                handler._removeExpiredChunkingRecords();
            }
        },

        isDeferredEligibleForUpload: function(id) {
            return options.isQueued(id);
        },

        // For Blobs that are part of a group of generated images, along with a reference image,
        // this will ensure the blobs in the group are uploaded in the order they were triggered,
        // even if some async processing must be completed on one or more Blobs first.
        maybeDefer: function(id, blob) {
            // If we don't have a file/blob yet & no file/blob exists for this item, request it,
            // and then submit the upload to the specific handler once the blob is available.
            // ASSUMPTION: This condition will only ever be true if XHR uploading is supported.
            if (blob && !handler.getFile(id) && blob instanceof qq.BlobProxy) {

                // Blob creation may take some time, so the caller may want to update the
                // UI to indicate that an operation is in progress, even before the actual
                // upload begins and an onUpload callback is invoked.
                options.onUploadPrep(id);

                log("Attempting to generate a blob on-demand for " + id);
                blob.create().then(function(generatedBlob) {
                    log("Generated an on-demand blob for " + id);

                    // Update record associated with this file by providing the generated Blob
                    handler.updateBlob(id, generatedBlob);

                    // Propagate the size for this generated Blob
                    options.setSize(id, generatedBlob.size);

                    // Order handler to recalculate chunking possibility, if applicable
                    handler.reevaluateChunking(id);

                    upload.maybeSendDeferredFiles(id);
                },

                // Blob could not be generated.  Fail the upload & attempt to prevent retries.  Also bubble error message.
                function(errorMessage) {
                    var errorResponse = {};

                    if (errorMessage) {
                        errorResponse.error = errorMessage;
                    }

                    log(qq.format("Failed to generate blob for ID {}.  Error message: {}.", id, errorMessage), "error");

                    options.onComplete(id, options.getName(id), qq.extend(errorResponse, preventRetryResponse), null);
                    upload.maybeSendDeferredFiles(id);
                    connectionManager.free(id);
                });
            }
            else {
                return upload.maybeSendDeferredFiles(id);
            }

            return false;
        },

        // Upload any grouped blobs, in the proper order, that are ready to be uploaded
        maybeSendDeferredFiles: function(id) {
            var idsInGroup = options.getIdsInProxyGroup(id),
                uploadedThisId = false;

            if (idsInGroup && idsInGroup.length) {
                log("Maybe ready to upload proxy group file " + id);

                qq.each(idsInGroup, function(idx, idInGroup) {
                    if (upload.isDeferredEligibleForUpload(idInGroup) && !!handler.getFile(idInGroup)) {
                        uploadedThisId = idInGroup === id;
                        upload.now(idInGroup);
                    }
                    else if (upload.isDeferredEligibleForUpload(idInGroup)) {
                        return false;
                    }
                });
            }
            else {
                uploadedThisId = true;
                upload.now(id);
            }

            return uploadedThisId;
        },

        maybeNewUuid: function(id, response) {
            if (response.newUuid !== undefined) {
                options.onUuidChanged(id, response.newUuid);
            }
        },

        // The response coming from handler implementations may be in various formats.
        // Instead of hoping a promise nested 5 levels deep will always return an object
        // as its first param, let's just normalize the response here.
        normalizeResponse: function(originalResponse, successful) {
            var response = originalResponse;

            // The passed "response" param may not be a response at all.
            // It could be a string, detailing the error, for example.
            if (!qq.isObject(originalResponse)) {
                response = {};

                if (qq.isString(originalResponse) && !successful) {
                    response.error = originalResponse;
                }
            }

            response.success = successful;

            return response;
        },

        now: function(id) {
            var name = options.getName(id);

            if (!controller.isValid(id)) {
                throw new qq.Error(id + " is not a valid file ID to upload!");
            }

            options.onUpload(id, name);

            if (chunkingPossible && handler._shouldChunkThisFile(id)) {
                chunked.sendNext(id);
            }
            else {
                simple.send(id, name);
            }
        },

        start: function(id) {
            var blobToUpload = upload.getProxyOrBlob(id);

            if (blobToUpload) {
                return upload.maybeDefer(id, blobToUpload);
            }
            else {
                upload.now(id);
                return true;
            }
        }
    };

    qq.extend(this, {
        /**
         * Adds file or file input to the queue
         **/
        add: function(id, file) {
            handler.add.apply(this, arguments);
        },

        /**
         * Sends the file identified by id
         */
        upload: function(id) {
            if (connectionManager.open(id)) {
                return upload.start(id);
            }
            return false;
        },

        retry: function(id) {
            // On retry, if concurrent chunking has been enabled, we may have aborted all other in-progress chunks
            // for a file when encountering a failed chunk upload.  We then signaled the controller to ignore
            // all failures associated with these aborts.  We are now retrying, so we don't want to ignore
            // any more failures at this point.
            if (concurrentChunkingPossible) {
                handler._getFileState(id).temp.ignoreFailure = false;
            }

            // If we are attempting to retry a file that is already consuming a connection, this is likely an auto-retry.
            // Just go ahead and ask the handler to upload again.
            if (connectionManager.isUsingConnection(id)) {
                return upload.start(id);
            }

            // If we are attempting to retry a file that is not currently consuming a connection,
            // this is likely a manual retry attempt.  We will need to ensure a connection is available
            // before the retry commences.
            else {
                return controller.upload(id);
            }
        },

        /**
         * Cancels file upload by id
         */
        cancel: function(id) {
            var cancelRetVal = handler.cancel(id);

            if (qq.isGenericPromise(cancelRetVal)) {
                cancelRetVal.then(function() {
                    upload.cancel(id);
                });
            }
            else if (cancelRetVal !== false) {
                upload.cancel(id);
            }
        },

        /**
         * Cancels all queued or in-progress uploads
         */
        cancelAll: function() {
            var waitingOrConnected = connectionManager.getWaitingOrConnected(),
                i;

            // ensure files are cancelled in reverse order which they were added
            // to avoid a flash of time where a queued file begins to upload before it is canceled
            if (waitingOrConnected.length) {
                for (i = waitingOrConnected.length - 1; i >= 0; i--) {
                    controller.cancel(waitingOrConnected[i]);
                }
            }

            connectionManager.reset();
        },

        // Returns a File, Blob, or the Blob/File for the reference/parent file if the targeted blob is a proxy.
        // Undefined if no file record is available.
        getFile: function(id) {
            if (handler.getProxy && handler.getProxy(id)) {
                return handler.getProxy(id).referenceBlob;
            }

            return handler.getFile && handler.getFile(id);
        },

        // Returns true if the Blob associated with the ID is related to a proxy s
        isProxied: function(id) {
            return !!(handler.getProxy && handler.getProxy(id));
        },

        getInput: function(id) {
            if (handler.getInput) {
                return handler.getInput(id);
            }
        },

        reset: function() {
            log("Resetting upload handler");
            controller.cancelAll();
            connectionManager.reset();
            handler.reset();
        },

        expunge: function(id) {
            if (controller.isValid(id)) {
                return handler.expunge(id);
            }
        },

        /**
         * Determine if the file exists.
         */
        isValid: function(id) {
            return handler.isValid(id);
        },

        getResumableFilesData: function() {
            if (handler.getResumableFilesData) {
                return handler.getResumableFilesData();
            }
            return [];
        },

        /**
         * This may or may not be implemented, depending on the handler.  For handlers where a third-party ID is
         * available (such as the "key" for Amazon S3), this will return that value.  Otherwise, the return value
         * will be undefined.
         *
         * @param id Internal file ID
         * @returns {*} Some identifier used by a 3rd-party service involved in the upload process
         */
        getThirdPartyFileId: function(id) {
            if (controller.isValid(id)) {
                return handler.getThirdPartyFileId(id);
            }
        },

        /**
         * Attempts to pause the associated upload if the specific handler supports this and the file is "valid".
         * @param id ID of the upload/file to pause
         * @returns {boolean} true if the upload was paused
         */
        pause: function(id) {
            if (controller.isResumable(id) && handler.pause && controller.isValid(id) && handler.pause(id)) {
                connectionManager.free(id);
                handler.moveInProgressToRemaining(id);
                return true;
            }
            return false;
        },

        // True if the file is eligible for pause/resume.
        isResumable: function(id) {
            return !!handler.isResumable && handler.isResumable(id);
        }
    });

    qq.extend(options, o);
    log = options.log;
    chunkingPossible = options.chunking.enabled && qq.supportedFeatures.chunking;
    concurrentChunkingPossible = chunkingPossible && options.chunking.concurrent.enabled;

    preventRetryResponse = (function() {
        var response = {};

        response[options.preventRetryParam] = true;

        return response;
    }());

    upload.initHandler();
};

/* globals qq */
/**
 * Common APIs exposed to creators of upload via form/iframe handlers.  This is reused and possibly overridden
 * in some cases by specific form upload handlers.
 *
 * @constructor
 */
qq.FormUploadHandler = function(spec) {

    var options = spec.options,
        handler = this,
        proxy = spec.proxy,
        formHandlerInstanceId = qq.getUniqueId(),
        onloadCallbacks = {},
        detachLoadEvents = {},
        postMessageCallbackTimers = {},
        isCors = options.isCors,
        inputName = options.inputName,
        getUuid = proxy.getUuid,
        log = proxy.log,
        corsMessageReceiver = new qq.WindowReceiveMessage({log: log});

    /**
     * Remove any trace of the file from the handler.
     *
     * @param id ID of the associated file
     */
    function expungeFile(id) {
        delete detachLoadEvents[id];

        // If we are dealing with CORS, we might still be waiting for a response from a loaded iframe.
        // In that case, terminate the timer waiting for a message from the loaded iframe
        // and stop listening for any more messages coming from this iframe.
        if (isCors) {
            clearTimeout(postMessageCallbackTimers[id]);
            delete postMessageCallbackTimers[id];
            corsMessageReceiver.stopReceivingMessages(id);
        }

        var iframe = document.getElementById(handler._getIframeName(id));
        if (iframe) {
            // To cancel request set src to something else.  We use src="javascript:false;"
            // because it doesn't trigger ie6 prompt on https
            /* jshint scripturl:true */
            iframe.setAttribute("src", "javascript:false;");

            qq(iframe).remove();
        }
    }

    /**
     * @param iframeName `document`-unique Name of the associated iframe
     * @returns {*} ID of the associated file
     */
    function getFileIdForIframeName(iframeName) {
        return iframeName.split("_")[0];
    }

    /**
     * Generates an iframe to be used as a target for upload-related form submits.  This also adds the iframe
     * to the current `document`.  Note that the iframe is hidden from view.
     *
     * @param name Name of the iframe.
     * @returns {HTMLIFrameElement} The created iframe
     */
    function initIframeForUpload(name) {
        var iframe = qq.toElement("<iframe src='javascript:false;' name='" + name + "' />");

        iframe.setAttribute("id", name);

        iframe.style.display = "none";
        document.body.appendChild(iframe);

        return iframe;
    }

    /**
     * If we are in CORS mode, we must listen for messages (containing the server response) from the associated
     * iframe, since we cannot directly parse the content of the iframe due to cross-origin restrictions.
     *
     * @param iframe Listen for messages on this iframe.
     * @param callback Invoke this callback with the message from the iframe.
     */
    function registerPostMessageCallback(iframe, callback) {
        var iframeName = iframe.id,
            fileId = getFileIdForIframeName(iframeName),
            uuid = getUuid(fileId);

        onloadCallbacks[uuid] = callback;

        // When the iframe has loaded (after the server responds to an upload request)
        // declare the attempt a failure if we don't receive a valid message shortly after the response comes in.
        detachLoadEvents[fileId] = qq(iframe).attach("load", function() {
            if (handler.getInput(fileId)) {
                log("Received iframe load event for CORS upload request (iframe name " + iframeName + ")");

                postMessageCallbackTimers[iframeName] = setTimeout(function() {
                    var errorMessage = "No valid message received from loaded iframe for iframe name " + iframeName;
                    log(errorMessage, "error");
                    callback({
                        error: errorMessage
                    });
                }, 1000);
            }
        });

        // Listen for messages coming from this iframe.  When a message has been received, cancel the timer
        // that declares the upload a failure if a message is not received within a reasonable amount of time.
        corsMessageReceiver.receiveMessage(iframeName, function(message) {
            log("Received the following window message: '" + message + "'");
            var fileId = getFileIdForIframeName(iframeName),
                response = handler._parseJsonResponse(message),
                uuid = response.uuid,
                onloadCallback;

            if (uuid && onloadCallbacks[uuid]) {
                log("Handling response for iframe name " + iframeName);
                clearTimeout(postMessageCallbackTimers[iframeName]);
                delete postMessageCallbackTimers[iframeName];

                handler._detachLoadEvent(iframeName);

                onloadCallback = onloadCallbacks[uuid];

                delete onloadCallbacks[uuid];
                corsMessageReceiver.stopReceivingMessages(iframeName);
                onloadCallback(response);
            }
            else if (!uuid) {
                log("'" + message + "' does not contain a UUID - ignoring.");
            }
        });
    }

    qq.extend(this, new qq.UploadHandler(spec));

    qq.override(this, function(super_) {
        return {
            /**
             * Adds File or Blob to the queue
             **/
            add: function(id, fileInput) {
                super_.add(id, {input: fileInput});

                fileInput.setAttribute("name", inputName);

                // remove file input from DOM
                if (fileInput.parentNode) {
                    qq(fileInput).remove();
                }
            },

            expunge: function(id) {
                expungeFile(id);
                super_.expunge(id);
            },

            isValid: function(id) {
                return super_.isValid(id) &&
                    handler._getFileState(id).input !== undefined;
            }
        };
    });

    qq.extend(this, {
        getInput: function(id) {
            return handler._getFileState(id).input;
        },

        /**
         * This function either delegates to a more specific message handler if CORS is involved,
         * or simply registers a callback when the iframe has been loaded that invokes the passed callback
         * after determining if the content of the iframe is accessible.
         *
         * @param iframe Associated iframe
         * @param callback Callback to invoke after we have determined if the iframe content is accessible.
         */
        _attachLoadEvent: function(iframe, callback) {
            /*jslint eqeq: true*/
            var responseDescriptor;

            if (isCors) {
                registerPostMessageCallback(iframe, callback);
            }
            else {
                detachLoadEvents[iframe.id] = qq(iframe).attach("load", function() {
                    log("Received response for " + iframe.id);

                    // when we remove iframe from dom
                    // the request stops, but in IE load
                    // event fires
                    if (!iframe.parentNode) {
                        return;
                    }

                    try {
                        // fixing Opera 10.53
                        if (iframe.contentDocument &&
                            iframe.contentDocument.body &&
                            iframe.contentDocument.body.innerHTML == "false") {
                            // In Opera event is fired second time
                            // when body.innerHTML changed from false
                            // to server response approx. after 1 sec
                            // when we upload file with iframe
                            return;
                        }
                    }
                    catch (error) {
                        //IE may throw an "access is denied" error when attempting to access contentDocument on the iframe in some cases
                        log("Error when attempting to access iframe during handling of upload response (" + error.message + ")", "error");
                        responseDescriptor = {success: false};
                    }

                    callback(responseDescriptor);
                });
            }
        },

        /**
         * Creates an iframe with a specific document-unique name.
         *
         * @param id ID of the associated file
         * @returns {HTMLIFrameElement}
         */
        _createIframe: function(id) {
            var iframeName = handler._getIframeName(id);

            return initIframeForUpload(iframeName);
        },

        /**
         * Called when we are no longer interested in being notified when an iframe has loaded.
         *
         * @param id Associated file ID
         */
        _detachLoadEvent: function(id) {
            if (detachLoadEvents[id] !== undefined) {
                detachLoadEvents[id]();
                delete detachLoadEvents[id];
            }
        },

        /**
         * @param fileId ID of the associated file
         * @returns {string} The `document`-unique name of the iframe
         */
        _getIframeName: function(fileId) {
            return fileId + "_" + formHandlerInstanceId;
        },

        /**
         * Generates a form element and appends it to the `document`.  When the form is submitted, a specific iframe is targeted.
         * The name of the iframe is passed in as a property of the spec parameter, and must be unique in the `document`.  Note
         * that the form is hidden from view.
         *
         * @param spec An object containing various properties to be used when constructing the form.  Required properties are
         * currently: `method`, `endpoint`, `params`, `paramsInBody`, and `targetName`.
         * @returns {HTMLFormElement} The created form
         */
        _initFormForUpload: function(spec) {
            var method = spec.method,
                endpoint = spec.endpoint,
                params = spec.params,
                paramsInBody = spec.paramsInBody,
                targetName = spec.targetName,
                form = qq.toElement("<form method='" + method + "' enctype='multipart/form-data'></form>"),
                url = endpoint;

            if (paramsInBody) {
                qq.obj2Inputs(params, form);
            }
            else {
                url = qq.obj2url(params, endpoint);
            }

            form.setAttribute("action", url);
            form.setAttribute("target", targetName);
            form.style.display = "none";
            document.body.appendChild(form);

            return form;
        },

        /**
         * @param innerHtmlOrMessage JSON message
         * @returns {*} The parsed response, or an empty object if the response could not be parsed
         */
        _parseJsonResponse: function(innerHtmlOrMessage) {
            var response = {};

            try {
                response = qq.parseJson(innerHtmlOrMessage);
            }
            catch (error) {
                log("Error when attempting to parse iframe upload response (" + error.message + ")", "error");
            }

            return response;
        }
    });
};

/* globals qq */
/**
 * Common API exposed to creators of XHR handlers.  This is reused and possibly overriding in some cases by specific
 * XHR upload handlers.
 *
 * @constructor
 */
qq.XhrUploadHandler = function(spec) {

    var handler = this,
        namespace = spec.options.namespace,
        proxy = spec.proxy,
        chunking = spec.options.chunking,
        resume = spec.options.resume,
        chunkFiles = chunking && spec.options.chunking.enabled && qq.supportedFeatures.chunking,
        resumeEnabled = resume && spec.options.resume.enabled && chunkFiles && qq.supportedFeatures.resume,
        getName = proxy.getName,
        getSize = proxy.getSize,
        getUuid = proxy.getUuid,
        getEndpoint = proxy.getEndpoint,
        getDataByUuid = proxy.getDataByUuid,
        onUuidChanged = proxy.onUuidChanged,
        onProgress = proxy.onProgress,
        log = proxy.log;

    function abort(id) {
        qq.each(handler._getXhrs(id), function(xhrId, xhr) {
            var ajaxRequester = handler._getAjaxRequester(id, xhrId);

            xhr.onreadystatechange = null;
            xhr.upload.onprogress = null;
            xhr.abort();
            if ( ajaxRequester && ajaxRequester.canceled ) { ajaxRequester.canceled(id); }
        });
    }

    qq.extend(this, new qq.UploadHandler(spec));

    qq.override(this, function(super_) {
        return {
            /**
             * Adds File or Blob to the queue
             **/
            add: function(id, blobOrProxy) {
                if (qq.isFile(blobOrProxy) || qq.isBlob(blobOrProxy)) {
                    super_.add(id, {file: blobOrProxy});
                }
                else if (blobOrProxy instanceof qq.BlobProxy) {
                    super_.add(id, {proxy: blobOrProxy});
                }
                else {
                    throw new Error("Passed obj is not a File, Blob, or proxy");
                }

                handler._initTempState(id);
                if ( resumeEnabled ) { handler._maybePrepareForResume(id); }
            },

            expunge: function(id) {
                abort(id);
                handler._maybeDeletePersistedChunkData(id);
                handler._clearXhrs(id);
                super_.expunge(id);
            }
        };
    });

    qq.extend(this, {
        // Clear the cached chunk `Blob` after we are done with it, just in case the `Blob` bytes are stored in memory.
        clearCachedChunk: function(id, chunkIdx) {
            delete handler._getFileState(id).temp.cachedChunks[chunkIdx];
        },

        clearXhr: function(id, chunkIdx) {
            var tempState = handler._getFileState(id).temp;

            if (tempState.xhrs) {
                delete tempState.xhrs[chunkIdx];
            }
            if (tempState.ajaxRequesters) {
                delete tempState.ajaxRequesters[chunkIdx];
            }
        },

        // Called when all chunks have been successfully uploaded.  Expected promissory return type.
        // This defines the default behavior if nothing further is required when all chunks have been uploaded.
        finalizeChunks: function(id, responseParser) {
            var lastChunkIdx = handler._getTotalChunks(id) - 1,
                xhr = handler._getXhr(id, lastChunkIdx);

            if (responseParser) {
                return new qq.Promise().success(responseParser(xhr), xhr);
            }

            return new qq.Promise().success({}, xhr);
        },

        getFile: function(id) {
            return handler.isValid(id) && handler._getFileState(id).file;
        },

        getProxy: function(id) {
            return handler.isValid(id) && handler._getFileState(id).proxy;
        },

        /**
         * @returns {Array} Array of objects containing properties useful to integrators
         * when it is important to determine which files are potentially resumable.
         */
        getResumableFilesData: function() {
            var resumableFilesData = [];

            handler._iterateResumeRecords(function(key, uploadData) {
                handler.moveInProgressToRemaining(null, uploadData.chunking.inProgress,  uploadData.chunking.remaining);

                var data = {
                    name: uploadData.name,
                    remaining: uploadData.chunking.remaining,
                    size: uploadData.size,
                    uuid: uploadData.uuid
                };

                if (uploadData.key) {
                    data.key = uploadData.key;
                }

                resumableFilesData.push(data);
            });

            return resumableFilesData;
        },

        isResumable: function(id) {
            return !!chunking && handler.isValid(id) && !handler._getFileState(id).notResumable;
        },

        moveInProgressToRemaining: function(id, optInProgress, optRemaining) {
            var inProgress = optInProgress || handler._getFileState(id).chunking.inProgress,
                remaining = optRemaining || handler._getFileState(id).chunking.remaining;

            if (inProgress) {
                log(qq.format("Moving these chunks from in-progress {}, to remaining.", JSON.stringify(inProgress)));
                inProgress.reverse();
                qq.each(inProgress, function(idx, chunkIdx) {
                    remaining.unshift(chunkIdx);
                });
                inProgress.length = 0;
            }
        },

        pause: function(id) {
            if (handler.isValid(id)) {
                log(qq.format("Aborting XHR upload for {} '{}' due to pause instruction.", id, getName(id)));
                handler._getFileState(id).paused = true;
                abort(id);
                return true;
            }
        },

        reevaluateChunking: function(id) {
            if (chunking && handler.isValid(id)) {
                var state = handler._getFileState(id),
                    totalChunks,
                    i;

                delete state.chunking;

                state.chunking = {};
                totalChunks = handler._getTotalChunks(id);
                if (totalChunks > 1 || chunking.mandatory) {
                    state.chunking.enabled = true;
                    state.chunking.parts = totalChunks;
                    state.chunking.remaining = [];

                    for (i = 0; i < totalChunks; i++) {
                        state.chunking.remaining.push(i);
                    }

                    handler._initTempState(id);
                }
                else {
                    state.chunking.enabled = false;
                }
            }
        },

        updateBlob: function(id, newBlob) {
            if (handler.isValid(id)) {
                handler._getFileState(id).file = newBlob;
            }
        },

        _clearXhrs: function(id) {
            var tempState = handler._getFileState(id).temp;

            qq.each(tempState.ajaxRequesters, function(chunkId) {
                delete tempState.ajaxRequesters[chunkId];
            });

            qq.each(tempState.xhrs, function(chunkId) {
                delete tempState.xhrs[chunkId];
            });
        },

        /**
         * Creates an XHR instance for this file and stores it in the fileState.
         *
         * @param id File ID
         * @param optChunkIdx The chunk index associated with this XHR, if applicable
         * @returns {XMLHttpRequest}
         */
        _createXhr: function(id, optChunkIdx) {
            return handler._registerXhr(id, optChunkIdx, qq.createXhrInstance());
        },

        _getAjaxRequester: function(id, optChunkIdx) {
            var chunkIdx = ( undefined === optChunkIdx || optChunkIdx === null ) ? -1 : optChunkIdx;
            return handler._getFileState(id).temp.ajaxRequesters[chunkIdx];
        },

        _getChunkData: function(id, chunkIndex) {
            var chunkSize = chunking.partSize,
                fileSize = getSize(id),
                fileOrBlob = handler.getFile(id),
                startBytes = chunkSize * chunkIndex,
                endBytes = startBytes + chunkSize >= fileSize ? fileSize : startBytes + chunkSize,
                totalChunks = handler._getTotalChunks(id),
                cachedChunks = this._getFileState(id).temp.cachedChunks,

            // To work around a Webkit GC bug, we must keep each chunk `Blob` in scope until we are done with it.
            // See https://github.com/Widen/fine-uploader/issues/937#issuecomment-41418760
                blob = cachedChunks[chunkIndex] || qq.sliceBlob(fileOrBlob, startBytes, endBytes);

            cachedChunks[chunkIndex] = blob;

            return {
                part: chunkIndex,
                start: startBytes,
                end: endBytes,
                count: totalChunks,
                blob: blob,
                size: endBytes - startBytes
            };
        },

        _getChunkDataForCallback: function(chunkData) {
            return {
                partIndex: chunkData.part,
                startByte: chunkData.start + 1,
                endByte: chunkData.end,
                totalParts: chunkData.count
            };
        },

        /**
         * @param id File ID
         * @returns {string} Identifier for this item that may appear in the browser's local storage
         */
        _getLocalStorageId: function(id) {
            var formatVersion = "5.0",
                name = getName(id),
                size = getSize(id),
                chunkSize = chunking.partSize,
                endpoint = getEndpoint(id);

            return qq.format("qq{}resume{}-{}-{}-{}-{}", namespace, formatVersion, name, size, chunkSize, endpoint);
        },

        _getMimeType: function(id) {
            return handler.getFile(id).type;
        },

        _getPersistableData: function(id) {
            return handler._getFileState(id).chunking;
        },

        /**
         * @param id ID of the associated file
         * @returns {number} Number of parts this file can be divided into, or undefined if chunking is not supported in this UA
         */
        _getTotalChunks: function(id) {
            if (chunking) {
                var fileSize = getSize(id),
                    chunkSize = chunking.partSize;

                return Math.ceil(fileSize / chunkSize);
            }
        },

        _getXhr: function(id, optChunkIdx) {
            var chunkIdx = ( 'undefined' === typeof optChunkIdx || optChunkIdx === null ) ? -1 : optChunkIdx;
            return handler._getFileState(id).temp.xhrs[chunkIdx];
        },

        _getXhrs: function(id) {
            return handler._getFileState(id).temp.xhrs;
        },

        // Iterates through all XHR handler-created resume records (in local storage),
        // invoking the passed callback and passing in the key and value of each local storage record.
        _iterateResumeRecords: function(callback) {
            if (resumeEnabled) {
                qq.each(localStorage, function(key, item) {
                    if (key.indexOf(qq.format("qq{}resume", namespace)) === 0) {
                        var uploadData = JSON.parse(item);
                        callback(key, uploadData);
                    }
                });
            }
        },

        _initTempState: function(id) {
            handler._getFileState(id).temp = {
                ajaxRequesters: {},
                chunkProgress: {},
                xhrs: {},
                cachedChunks: {}
            };
        },

        _markNotResumable: function(id) {
            handler._getFileState(id).notResumable = true;
        },

        // Removes a chunked upload record from local storage, if possible.
        // Returns true if the item was removed, false otherwise.
        _maybeDeletePersistedChunkData: function(id) {
            var localStorageId;

            if (resumeEnabled && handler.isResumable(id)) {
                localStorageId = handler._getLocalStorageId(id);

                if (localStorageId && localStorage.getItem(localStorageId)) {
                    localStorage.removeItem(localStorageId);
                    return true;
                }
            }

            return false;
        },

        // If this is a resumable upload, grab the relevant data from storage and items in memory that track this upload
        // so we can pick up from where we left off.
        _maybePrepareForResume: function(id) {
            var state = handler._getFileState(id),
                localStorageId, persistedData;

            // Resume is enabled and possible and this is the first time we've tried to upload this file in this session,
            // so prepare for a resume attempt.
            if (resumeEnabled && state.key === undefined) {
                localStorageId = handler._getLocalStorageId(id);
                persistedData = localStorage.getItem(localStorageId);

                // If we found this item in local storage, maybe we should resume it.
                if (persistedData) {
                    persistedData = JSON.parse(persistedData);

                    // If we found a resume record but we have already handled this file in this session,
                    // don't try to resume it & ensure we don't persist future check data
                    if (getDataByUuid(persistedData.uuid)) {
                        handler._markNotResumable(id);
                    }
                    else {
                        log(qq.format("Identified file with ID {} and name of {} as resumable.", id, getName(id)));

                        onUuidChanged(id, persistedData.uuid);

                        state.key = persistedData.key;
                        state.chunking = persistedData.chunking;
                        state.loaded = persistedData.loaded;
                        state.attemptingResume = true;

                        handler.moveInProgressToRemaining(id);
                    }
                }
            }
        },

        // Persist any data needed to resume this upload in a new session.
        _maybePersistChunkedState: function(id) {
            var state = handler._getFileState(id),
                localStorageId, persistedData;

            // If local storage isn't supported by the browser, or if resume isn't enabled or possible, give up
            if (resumeEnabled && handler.isResumable(id)) {
                localStorageId = handler._getLocalStorageId(id);

                persistedData = {
                    name: getName(id),
                    size: getSize(id),
                    uuid: getUuid(id),
                    key: state.key,
                    chunking: state.chunking,
                    loaded: state.loaded,
                    lastUpdated: Date.now()
                };

                try {
                    localStorage.setItem(localStorageId, JSON.stringify(persistedData));
                }
                catch (error) {
                    log(qq.format("Unable to save resume data for '{}' due to error: '{}'.", id, error.toString()), "warn");
                }
            }
        },

        _registerProgressHandler: function(id, chunkIdx, chunkSize) {
            var xhr = handler._getXhr(id, chunkIdx),
                name = getName(id),
                progressCalculator = {
                    simple: function(loaded, total) {
                        var fileSize = getSize(id);

                        if (loaded === total) {
                            onProgress(id, name, fileSize, fileSize);
                        }
                        else {
                            onProgress(id, name, (loaded >= fileSize ? fileSize - 1 : loaded), fileSize);
                        }
                    },

                    chunked: function(loaded, total) {
                        var chunkProgress = handler._getFileState(id).temp.chunkProgress,
                            totalSuccessfullyLoadedForFile = handler._getFileState(id).loaded,
                            loadedForRequest = loaded,
                            totalForRequest = total,
                            totalFileSize = getSize(id),
                            estActualChunkLoaded = loadedForRequest - (totalForRequest - chunkSize),
                            totalLoadedForFile = totalSuccessfullyLoadedForFile;

                        chunkProgress[chunkIdx] = estActualChunkLoaded;

                        qq.each(chunkProgress, function(chunkIdx, chunkLoaded) {
                            totalLoadedForFile += chunkLoaded;
                        });

                        onProgress(id, name, totalLoadedForFile, totalFileSize);
                    }
                };

            xhr.upload.onprogress = function(e) {
                if (e.lengthComputable) {
                    /* jshint eqnull: true */
                    var type = ( 'undefined' === typeof chunkSize || chunkSize === null ) ? "simple" : "chunked";
                    progressCalculator[type](e.loaded, e.total);
                }
            };
        },

        /**
         * Registers an XHR transport instance created elsewhere.
         *
         * @param id ID of the associated file
         * @param optChunkIdx The chunk index associated with this XHR, if applicable
         * @param xhr XMLHttpRequest object instance
         * @param optAjaxRequester `qq.AjaxRequester` associated with this request, if applicable.
         * @returns {XMLHttpRequest}
         */
        _registerXhr: function(id, optChunkIdx, xhr, optAjaxRequester) {
            var xhrsId = ( 'undefined' === typeof optChunkIdx || optChunkIdx === null ) ? -1 : optChunkIdx,
                tempState = handler._getFileState(id).temp;

            tempState.xhrs = tempState.xhrs || {};
            tempState.ajaxRequesters = tempState.ajaxRequesters || {};

            tempState.xhrs[xhrsId] = xhr;

            if (optAjaxRequester) {
                tempState.ajaxRequesters[xhrsId] = optAjaxRequester;
            }

            return xhr;
        },

        // Deletes any local storage records that are "expired".
        _removeExpiredChunkingRecords: function() {
            var expirationDays = resume.recordsExpireIn;

            handler._iterateResumeRecords(function(key, uploadData) {
                var expirationDate = new Date(uploadData.lastUpdated);

                // transform updated date into expiration date
                expirationDate.setDate(expirationDate.getDate() + expirationDays);

                if (expirationDate.getTime() <= Date.now()) {
                    log("Removing expired resume record with key " + key);
                    localStorage.removeItem(key);
                }
            });
        },

        /**
         * Determine if the associated file should be chunked.
         *
         * @param id ID of the associated file
         * @returns {*} true if chunking is enabled, possible, and the file can be split into more than 1 part
         */
        _shouldChunkThisFile: function(id) {
            var state = handler._getFileState(id);

            if (!state.chunking) {
                handler.reevaluateChunking(id);
            }

            return state.chunking.enabled;
        }
    });
};

/*globals qq */
/*jshint -W117 */
qq.WindowReceiveMessage = function(o) {
    var options = {
            log: function(message, level) {}
        },
        callbackWrapperDetachers = {};

    qq.extend(options, o);

    qq.extend(this, {
        receiveMessage: function(id, callback) {
            var onMessageCallbackWrapper = function(event) {
                    callback(event.data);
                };

            if (window.postMessage) {
                callbackWrapperDetachers[id] = qq(window).attach("message", onMessageCallbackWrapper);
            }
            else {
                log("iframe message passing not supported in this browser!", "error");
            }
        },

        stopReceivingMessages: function(id) {
            if (window.postMessage) {
                var detacher = callbackWrapperDetachers[id];
                if (detacher) {
                    detacher();
                }
            }
        }
    });
};

/*globals qq */
/**
 * Defines the public API for FineUploader mode.
 */
(function() {
    qq.uiPublicApi = {
        addInitialFiles: function( cannedFileList ) {
            this._parent.prototype.addInitialFiles.apply(this, arguments);
            this._templating.addCacheToDom();
        },

        clearStoredFiles: function() {
            this._parent.prototype.clearStoredFiles.apply(this, arguments);
            this._templating.clearFiles();
        },

        addExtraDropzone: function( element ) {
            if ( this._dnd ) { this._dnd.setupExtraDropzone(element); }
        },

        removeExtraDropzone: function(element) {
            if (this._dnd) {
                return this._dnd.removeDropzone(element);
            }
        },

        getItemByFileId: function( id ) {
            if (!this._templating.isHiddenForever( id )) {
                return this._templating.getFileContainer( id );
            }
        },

        reset: function() {
            this._parent.prototype.reset.apply(this, arguments);
            this._templating.reset();

            if (!this._options.button && this._templating.getButton()) {
                this._defaultButtonId = this._createUploadButton({
                    element: this._templating.getButton(),
                    title: this._options.text.fileInputTitle
                }).getButtonId();
            }

            if (this._dnd) {
                this._dnd.dispose();
                this._dnd = this._setupDragAndDrop();
            }

            this._totalFilesInBatch = 0;
            this._filesInBatchAddedToUi = 0;

            this._setupClickAndEditEventHandlers();
        },

        setName: function(id, newName) {
            var formattedFilename = this._options.formatFileName(newName);
            this._parent.prototype.setName.apply(this, arguments);
            this._templating.updateFilename(id, formattedFilename);
        },

        pauseUpload: function(id) {
            var paused = this._parent.prototype.pauseUpload.apply(this, arguments);
            if ( paused ) { this._templating.uploadPaused(id); }
            return paused;
        },

        continueUpload: function(id) {
            var continued = this._parent.prototype.continueUpload.apply(this, arguments);
            if ( continued ) { this._templating.uploadContinued(id); }
            return continued;
        },

        getId: function(fileContainerOrChildEl) {
            return this._templating.getFileId(fileContainerOrChildEl);
        },

        getDropTarget: function(fileId) {
            var file = this.getFile(fileId);

            return file.qqDropTarget;
        }
    };

    /**
     * Defines the private (internal) API for FineUploader mode.
     */

    qq.uiPrivateApi = {
        _getButton: function(buttonId) {
            var button = this._parent.prototype._getButton.apply(this, arguments);

            if (!button) {
                if (buttonId === this._defaultButtonId) {
                    button = this._templating.getButton();
                }
            }

            return button;
        },

        _removeFileItem: function(fileId) {
            this._templating.removeFile(fileId);
        },

        _setupClickAndEditEventHandlers: function() {
            this._fileButtonsClickHandler = qq.FileButtonsClickHandler && this._bindFileButtonsClickEvent();

            // A better approach would be to check specifically for focusin event support by querying the DOM API,
            // but the DOMFocusIn event is not exposed as a property, so we have to resort to UA string sniffing.
            this._focusinEventSupported = !qq.firefox();

            if (this._isEditFilenameEnabled())
            {
                this._filenameClickHandler = this._bindFilenameClickEvent();
                this._filenameInputFocusInHandler = this._bindFilenameInputFocusInEvent();
                this._filenameInputFocusHandler = this._bindFilenameInputFocusEvent();
            }
        },

        _setupDragAndDrop: function() {
            var self = this,
                dropZoneElements = this._options.dragAndDrop.extraDropzones,
                templating = this._templating,
                defaultDropZone = templating.getDropZone();

            if ( defaultDropZone ) { dropZoneElements.push(defaultDropZone); }

            return new qq.DragAndDrop({
                dropZoneElements: dropZoneElements,
                allowMultipleItems: this._options.multiple,
                classes: {
                    dropActive: this._options.classes.dropActive
                },
                callbacks: {
                    processingDroppedFiles: function() {
                        templating.showDropProcessing();
                    },
                    processingDroppedFilesComplete: function(files, targetEl) {
                        templating.hideDropProcessing();

                        qq.each(files, function(idx, file) {
                            file.qqDropTarget = targetEl;
                        });

                        if (files.length) {
                            self.addFiles(files, null, null);
                        }
                    },
                    dropError: function(code, errorData) {
                        self._itemError(code, errorData);
                    },
                    dropLog: function(message, level) {
                        self.log(message, level);
                    }
                }
            });
        },

        _bindFileButtonsClickEvent: function() {
            var self = this;

            return new qq.FileButtonsClickHandler({
                templating: this._templating,

                log: function(message, lvl) {
                    self.log(message, lvl);
                },

                onDeleteFile: function(fileId) {
                    self.deleteFile(fileId);
                },

                onCancel: function(fileId) {
                    self.cancel(fileId);
                },

                onRetry: function(fileId) {
                    self.retry(fileId);
                },

                onPause: function(fileId) {
                    self.pauseUpload(fileId);
                },

                onContinue: function(fileId) {
                    self.continueUpload(fileId);
                },

                onGetName: function(fileId) {
                    return self.getName(fileId);
                }
            });
        },

        _isEditFilenameEnabled: function() {
            /*jshint -W014 */
            return this._templating.isEditFilenamePossible()
                && !this._options.autoUpload
                && qq.FilenameClickHandler
                && qq.FilenameInputFocusHandler
                && qq.FilenameInputFocusHandler;
        },

        _filenameEditHandler: function() {
            var self = this,
                templating = this._templating;

            return {
                templating: templating,
                log: function(message, lvl) {
                    self.log(message, lvl);
                },
                onGetUploadStatus: function(fileId) {
                    return self.getUploads({id: fileId}).status;
                },
                onGetName: function(fileId) {
                    return self.getName(fileId);
                },
                onSetName: function(id, newName) {
                    self.setName(id, newName);
                },
                onEditingStatusChange: function(id, isEditing) {
                    var qqInput = qq(templating.getEditInput(id)),
                        qqFileContainer = qq(templating.getFileContainer(id));

                    if (isEditing) {
                        qqInput.addClass("qq-editing");
                        templating.hideFilename(id);
                        templating.hideEditIcon(id);
                    }
                    else {
                        qqInput.removeClass("qq-editing");
                        templating.showFilename(id);
                        templating.showEditIcon(id);
                    }

                    // Force IE8 and older to repaint
                    qqFileContainer.addClass("qq-temp").removeClass("qq-temp");
                }
            };
        },

        _onUploadStatusChange: function(id, oldStatus, newStatus) {
            this._parent.prototype._onUploadStatusChange.apply(this, arguments);

            if (this._isEditFilenameEnabled()) {
                // Status for a file exists before it has been added to the DOM, so we must be careful here.
                if (this._templating.getFileContainer(id) && newStatus !== qq.status.SUBMITTED) {
                    this._templating.markFilenameEditable(id);
                    this._templating.hideEditIcon(id);
                }
            }

            if (newStatus === qq.status.UPLOAD_RETRYING) {
                this._templating.hideRetry(id);
                this._templating.setStatusText(id);
                qq(this._templating.getFileContainer(id)).removeClass(this._classes.retrying);
            }
            else if (newStatus === qq.status.UPLOAD_FAILED) {
                this._templating.hidePause(id);
            }
        },

        _bindFilenameInputFocusInEvent: function() {
            var spec = qq.extend({}, this._filenameEditHandler());

            return new qq.FilenameInputFocusInHandler(spec);
        },

        _bindFilenameInputFocusEvent: function() {
            var spec = qq.extend({}, this._filenameEditHandler());

            return new qq.FilenameInputFocusHandler(spec);
        },

        _bindFilenameClickEvent: function() {
            var spec = qq.extend({}, this._filenameEditHandler());

            return new qq.FilenameClickHandler(spec);
        },

        _storeForLater: function(id) {
            this._parent.prototype._storeForLater.apply(this, arguments);
            this._templating.hideSpinner(id);
        },

        _onAllComplete: function(successful, failed) {
            this._parent.prototype._onAllComplete.apply(this, arguments);
            this._templating.resetTotalProgress();
        },

        _onSubmit: function(id, name) {
            var file = this.getFile(id);

            if (file && file.qqPath && this._options.dragAndDrop.reportDirectoryPaths) {
                this._paramsStore.addReadOnly(id, {
                    qqpath: file.qqPath
                });
            }

            this._parent.prototype._onSubmit.apply(this, arguments);
            this._addToList(id, name);
        },

        // The file item has been added to the DOM.
        _onSubmitted: function(id) {
            // If the edit filename feature is enabled, mark the filename element as "editable" and the associated edit icon
            if (this._isEditFilenameEnabled()) {
                this._templating.markFilenameEditable(id);
                this._templating.showEditIcon(id);

                // If the focusin event is not supported, we must add a focus handler to the newly create edit filename text input
                if (!this._focusinEventSupported) {
                    this._filenameInputFocusHandler.addHandler(this._templating.getEditInput(id));
                }
            }
        },

        // Update the progress bar & percentage as the file is uploaded
        _onProgress: function(id, name, loaded, total) {
            this._parent.prototype._onProgress.apply(this, arguments);

            this._templating.updateProgress(id, loaded, total);

            if (Math.round(loaded / total * 100) === 100) {
                this._templating.hideCancel(id);
                this._templating.hidePause(id);
                this._templating.hideProgress(id);
                this._templating.setStatusText(id, this._options.text.waitingForResponse);

                // If ~last byte was sent, display total file size
                this._displayFileSize(id);
            }
            else {
                // If still uploading, display percentage - total size is actually the total request(s) size
                this._displayFileSize(id, loaded, total);
            }
        },

        _onTotalProgress: function(loaded, total) {
            this._parent.prototype._onTotalProgress.apply(this, arguments);
            this._templating.updateTotalProgress(loaded, total);
        },

        _onComplete: function(id, name, result, xhr) {
            var parentRetVal = this._parent.prototype._onComplete.apply(this, arguments),
                templating = this._templating,
                fileContainer = templating.getFileContainer(id),
                self = this;

            function completeUpload(result) {
                // If this file is not represented in the templating module, perhaps it was hidden intentionally.
                // If so, don't perform any UI-related tasks related to this file.
                if (!fileContainer) {
                    return;
                }

                templating.setStatusText(id);

                qq(fileContainer).removeClass(self._classes.retrying);
                templating.hideProgress(id);

                if (self.getUploads({id: id}).status !== qq.status.UPLOAD_FAILED) {
                    templating.hideCancel(id);
                }
                templating.hideSpinner(id);

                if (result.success) {
                    self._markFileAsSuccessful(id);
                }
                else {
                    qq(fileContainer).addClass(self._classes.fail);
                    templating.showCancel(id);

                    if (templating.isRetryPossible() && !self._preventRetries[id]) {
                        qq(fileContainer).addClass(self._classes.retryable);
                        templating.showRetry(id);
                    }
                    self._controlFailureTextDisplay(id, result);
                }
            }

            // The parent may need to perform some async operation before we can accurately determine the status of the upload.
            if (parentRetVal instanceof qq.Promise) {
                parentRetVal.done(function(newResult) {
                    completeUpload(newResult);
                });

            }
            else {
                completeUpload(result);
            }

            return parentRetVal;
        },

        _markFileAsSuccessful: function(id) {
            var templating = this._templating;

            if (this._isDeletePossible()) {
                templating.showDeleteButton(id);
            }

            qq(templating.getFileContainer(id)).addClass(this._classes.success);

            this._maybeUpdateThumbnail(id);
        },

        _onUploadPrep: function(id) {
            this._parent.prototype._onUploadPrep.apply(this, arguments);
            this._templating.showSpinner(id);
        },

        _onUpload: function(id, name) {
            var parentRetVal = this._parent.prototype._onUpload.apply(this, arguments);

            this._templating.showSpinner(id);

            return parentRetVal;
        },

        _onUploadChunk: function(id, chunkData) {
            this._parent.prototype._onUploadChunk.apply(this, arguments);

            // Only display the pause button if we have finished uploading at least one chunk
            // & this file can be resumed
            if (chunkData.partIndex > 0 && this._handler.isResumable(id)) {
                this._templating.allowPause(id);
            }
        },

        _onCancel: function(id, name) {
            this._parent.prototype._onCancel.apply(this, arguments);
            this._removeFileItem(id);

            if (this._getNotFinished() === 0) {
                this._templating.resetTotalProgress();
            }
        },

        _onBeforeAutoRetry: function(id) {
            var retryNumForDisplay, maxAuto, retryNote;

            this._parent.prototype._onBeforeAutoRetry.apply(this, arguments);

            this._showCancelLink(id);

            if (this._options.retry.showAutoRetryNote) {
                retryNumForDisplay = this._autoRetries[id];
                maxAuto = this._options.retry.maxAutoAttempts;

                retryNote = this._options.retry.autoRetryNote.replace(/\{retryNum\}/g, retryNumForDisplay);
                retryNote = retryNote.replace(/\{maxAuto\}/g, maxAuto);

                this._templating.setStatusText(id, retryNote);
                qq(this._templating.getFileContainer(id)).addClass(this._classes.retrying);
            }
        },

        //return false if we should not attempt the requested retry
        _onBeforeManualRetry: function(id) {
            if (this._parent.prototype._onBeforeManualRetry.apply(this, arguments)) {
                this._templating.resetProgress(id);
                qq(this._templating.getFileContainer(id)).removeClass(this._classes.fail);
                this._templating.setStatusText(id);
                this._templating.showSpinner(id);
                this._showCancelLink(id);
                return true;
            }
            else {
                qq(this._templating.getFileContainer(id)).addClass(this._classes.retryable);
                this._templating.showRetry(id);
                return false;
            }
        },

        _onSubmitDelete: function(id) {
            var onSuccessCallback = qq.bind(this._onSubmitDeleteSuccess, this);

            this._parent.prototype._onSubmitDelete.call(this, id, onSuccessCallback);
        },

        _onSubmitDeleteSuccess: function(id, uuid, additionalMandatedParams) {
            if (this._options.deleteFile.forceConfirm) {
                this._showDeleteConfirm.apply(this, arguments);
            }
            else {
                this._sendDeleteRequest.apply(this, arguments);
            }
        },

        _onDeleteComplete: function(id, xhr, isError) {
            this._parent.prototype._onDeleteComplete.apply(this, arguments);

            this._templating.hideSpinner(id);

            if (isError) {
                this._templating.setStatusText(id, this._options.deleteFile.deletingFailedText);
                this._templating.showDeleteButton(id);
            }
            else {
                this._removeFileItem(id);
            }
        },

        _sendDeleteRequest: function(id, uuid, additionalMandatedParams) {
            this._templating.hideDeleteButton(id);
            this._templating.showSpinner(id);
            this._templating.setStatusText(id, this._options.deleteFile.deletingStatusText);
            this._deleteHandler.sendDelete.apply(this, arguments);
        },

        _showDeleteConfirm: function(id, uuid, mandatedParams) {
            /*jshint -W004 */
            var fileName = this.getName(id),
                confirmMessage = this._options.deleteFile.confirmMessage.replace(/\{filename\}/g, fileName),
                uuid = this.getUuid(id),
                deleteRequestArgs = arguments,
                self = this,
                retVal;

            retVal = this._options.showConfirm(confirmMessage);

            if (qq.isGenericPromise(retVal)) {
                retVal.then(function() {
                    self._sendDeleteRequest.apply(self, deleteRequestArgs);
                });
            }
            else if (retVal !== false) {
                self._sendDeleteRequest.apply(self, deleteRequestArgs);
            }
        },

        _addToList: function(id, name, canned) {
            var prependData,
                prependIndex = 0,
                dontDisplay = this._handler.isProxied(id) && this._options.scaling.hideScaled,
                record;

            if (this._options.display.prependFiles) {
                if (this._totalFilesInBatch > 1 && this._filesInBatchAddedToUi > 0) {
                    prependIndex = this._filesInBatchAddedToUi - 1;
                }

                prependData = {
                    index: prependIndex
                };
            }

            if (!canned) {
                if (this._options.disableCancelForFormUploads && !qq.supportedFeatures.ajaxUploading) {
                    this._templating.disableCancel();
                }

                // Cancel all existing (previous) files and clear the list if this file is not part of
                // a scaled file group that has already been accepted, or if this file is not part of
                // a scaled file group at all.
                if (!this._options.multiple) {
                    record = this.getUploads({id: id});

                    this._handledProxyGroup = this._handledProxyGroup || record.proxyGroupId;

                    if (record.proxyGroupId !== this._handledProxyGroup || !record.proxyGroupId) {
                        this._handler.cancelAll();
                        this._clearList();
                        this._handledProxyGroup = null;
                    }
                }
            }

            if (canned) {
                this._templating.addFileToCache(id, this._options.formatFileName(name), prependData, dontDisplay);
                this._templating.updateThumbnail(id, this._thumbnailUrls[id], true, this._options.thumbnails.customResizer);
            }
            else {
                this._templating.addFile(id, this._options.formatFileName(name), prependData, dontDisplay);
                this._templating.generatePreview(id, this.getFile(id), this._options.thumbnails.customResizer);
            }

            this._filesInBatchAddedToUi += 1;

            if (canned ||
                (this._options.display.fileSizeOnSubmit && qq.supportedFeatures.ajaxUploading)) {

                this._displayFileSize(id);
            }
        },

        _clearList: function() {
            this._templating.clearFiles();
            this.clearStoredFiles();
        },

        _displayFileSize: function(id, loadedSize, totalSize) {
            var size = this.getSize(id),
                sizeForDisplay = this._formatSize(size);

            if (size >= 0) {
                if (loadedSize !== undefined && totalSize !== undefined) {
                    sizeForDisplay = this._formatProgress(loadedSize, totalSize);
                }

                this._templating.updateSize(id, sizeForDisplay);
            }
        },

        _formatProgress: function(uploadedSize, totalSize) {
            var message = this._options.text.formatProgress;
            function r(name, replacement) { message = message.replace(name, replacement); }

            r("{percent}", Math.round(uploadedSize / totalSize * 100));
            r("{total_size}", this._formatSize(totalSize));
            return message;
        },

        _controlFailureTextDisplay: function(id, response) {
            var mode, responseProperty, failureReason;

            mode = this._options.failedUploadTextDisplay.mode;
            responseProperty = this._options.failedUploadTextDisplay.responseProperty;

            if (mode === "custom") {
                failureReason = response[responseProperty];
                if (!failureReason) {
                    failureReason = this._options.text.failUpload;
                }

                this._templating.setStatusText(id, failureReason);

                if (this._options.failedUploadTextDisplay.enableTooltip) {
                    this._showTooltip(id, failureReason);
                }
            }
            else if (mode === "default") {
                this._templating.setStatusText(id, this._options.text.failUpload);
            }
            else if (mode !== "none") {
                this.log("failedUploadTextDisplay.mode value of '" + mode + "' is not valid", "warn");
            }
        },

        _showTooltip: function(id, text) {
            this._templating.getFileContainer(id).title = text;
        },

        _showCancelLink: function(id) {
            if (!this._options.disableCancelForFormUploads || qq.supportedFeatures.ajaxUploading) {
                this._templating.showCancel(id);
            }
        },

        _itemError: function(code, name, item) {
            var message = this._parent.prototype._itemError.apply(this, arguments);
            this._options.showMessage(message);
        },

        _batchError: function(message) {
            this._parent.prototype._batchError.apply(this, arguments);
            this._options.showMessage(message);
        },

        _setupPastePrompt: function() {
            var self = this;

            this._options.callbacks.onPasteReceived = function() {
                var message = self._options.paste.namePromptMessage,
                    defaultVal = self._options.paste.defaultName;

                return self._options.showPrompt(message, defaultVal);
            };
        },

        _fileOrBlobRejected: function(id, name) {
            this._totalFilesInBatch -= 1;
            this._parent.prototype._fileOrBlobRejected.apply(this, arguments);
        },

        _prepareItemsForUpload: function(items, params, endpoint) {
            this._totalFilesInBatch = items.length;
            this._filesInBatchAddedToUi = 0;
            this._parent.prototype._prepareItemsForUpload.apply(this, arguments);
        },

        _maybeUpdateThumbnail: function(fileId) {
            var thumbnailUrl = this._thumbnailUrls[fileId],
                fileStatus = this.getUploads({id: fileId}).status;

            if (fileStatus !== qq.status.DELETED &&
                (thumbnailUrl ||
                this._options.thumbnails.placeholders.waitUntilResponse ||
                !qq.supportedFeatures.imagePreviews)) {

                // This will replace the "waiting" placeholder with a "preview not available" placeholder
                // if called with a null thumbnailUrl.
                this._templating.updateThumbnail(fileId, thumbnailUrl, this._options.thumbnails.customResizer);
            }
        },

        _addCannedFile: function(sessionData) {
            var id = this._parent.prototype._addCannedFile.apply(this, arguments);

            this._addToList(id, this.getName(id), true);
            this._templating.hideSpinner(id);
            this._templating.hideCancel(id);
            this._markFileAsSuccessful(id);

            return id;
        },

        _setSize: function(id, newSize) {
            this._parent.prototype._setSize.apply(this, arguments);

            this._templating.updateSize(id, this._formatSize(newSize));
        },

        _sessionRequestComplete: function() {
            this._templating.addCacheToDom();
            this._parent.prototype._sessionRequestComplete.apply(this, arguments);
        }
    };
}());

/*globals qq */
/**
 * This defines FineUploader mode, which is a default UI w/ drag & drop uploading.
 */
qq.FineUploader = function(o, namespace) {

    var self = this;

    // By default this should inherit instance data from FineUploaderBasic, but this can be overridden
    // if the (internal) caller defines a different parent.  The parent is also used by
    // the private and public API functions that need to delegate to a parent function.
    this._parent = namespace ? qq[namespace].FineUploaderBasic : qq.FineUploaderBasic;
    this._parent.apply(this, arguments);

    // Options provided by FineUploader mode
    qq.extend(this._options, {
        element: null,

        button: null,

        listElement: null,

        dragAndDrop: {
            extraDropzones: [],
            reportDirectoryPaths: false
        },

        text: {
            formatProgress: "{percent}% von {total_size}",  //  "of"
            failUpload: "Upload fehlgeschlagen",            //  "upload failed"
            waitingForResponse: "Verarbeitung...",          //  "processing"
            paused: "Pause"                                 //  "paused"
        },

        template: "qq-template",

        classes: {
            retrying: "qq-upload-retrying",
            retryable: "qq-upload-retryable",
            success: "qq-upload-success",
            fail: "qq-upload-fail",
            editable: "qq-editable",
            hide: "qq-hide",
            dropActive: "qq-upload-drop-area-active"
        },

        failedUploadTextDisplay: {
            mode: "default", //default, custom, or none
            responseProperty: "error",
            enableTooltip: true
        },

        messages: {
            tooManyFilesError: "You may only drop one file",
            unsupportedBrowser: "Unrecoverable error - this browser does not permit file uploading of any kind."
        },

        retry: {
            showAutoRetryNote: true,
            autoRetryNote: "Retrying {retryNum}/{maxAuto}..."
        },

        deleteFile: {
            forceConfirm: false,
            confirmMessage: "Are you sure you want to delete {filename}?",
            deletingStatusText: "Deleting...",
            deletingFailedText: "Delete failed"

        },

        display: {
            fileSizeOnSubmit: false,
            prependFiles: false
        },

        paste: {
            promptForName: false,
            namePromptMessage: "Please name this image"
        },

        thumbnails: {
            customResizer: null,
            maxCount: 0,
            placeholders: {
                waitUntilResponse: false,
                notAvailablePath: null,
                waitingPath: null
            },
            timeBetweenThumbs: 750
        },

        scaling: {
            hideScaled: false
        },

        showMessage: function(message) {
            if (self._templating.hasDialog("alert")) {
                return self._templating.showDialog("alert", message);
            }

            //  Handled by KO FineViewModel.client.js

            //else {
            //    alert( 'browser message' );
            //    setTimeout(function() {
            //        window.alert(message);
            //    }, 0);
            //}
        },

        showConfirm: function(message) {
            if (self._templating.hasDialog("confirm")) {
                return self._templating.showDialog("confirm", message);
            }
            else {
                return window.confirm(message);
            }
        },

        showPrompt: function(message, defaultValue) {
            if (self._templating.hasDialog("prompt")) {
                return self._templating.showDialog("prompt", message, defaultValue);
            }
            else {
                return window.prompt(message, defaultValue);
            }
        }
    }, true);

    // Replace any default options with user defined ones
    qq.extend(this._options, o, true);

    this._templating = new qq.Templating({
        log: qq.bind(this.log, this),
        templateIdOrEl: this._options.template,
        containerEl: this._options.element,
        fileContainerEl: this._options.listElement,
        button: this._options.button,
        imageGenerator: this._imageGenerator,
        classes: {
            hide: this._options.classes.hide,
            editable: this._options.classes.editable
        },
        limits: {
            maxThumbs: this._options.thumbnails.maxCount,
            timeBetweenThumbs: this._options.thumbnails.timeBetweenThumbs
        },
        placeholders: {
            waitUntilUpdate: this._options.thumbnails.placeholders.waitUntilResponse,
            thumbnailNotAvailable: this._options.thumbnails.placeholders.notAvailablePath,
            waitingForThumbnail: this._options.thumbnails.placeholders.waitingPath
        },
        text: this._options.text
    });

    if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {
        this._templating.renderFailure(this._options.messages.unsupportedBrowserIos8Safari);
    }
    else if (!qq.supportedFeatures.uploading || (this._options.cors.expected && !qq.supportedFeatures.uploadCors)) {
        this._templating.renderFailure(this._options.messages.unsupportedBrowser);
    }
    else {
        this._wrapCallbacks();

        this._templating.render();

        this._classes = this._options.classes;

        if (!this._options.button && this._templating.getButton()) {
            this._defaultButtonId = this._createUploadButton({
                element: this._templating.getButton(),
                title: this._options.text.fileInputTitle
            }).getButtonId();
        }

        this._setupClickAndEditEventHandlers();

        if (qq.DragAndDrop && qq.supportedFeatures.fileDrop) {
            this._dnd = this._setupDragAndDrop();
        }

        if (this._options.paste.targetElement && this._options.paste.promptForName) {
            if (qq.PasteSupport) {
                this._setupPastePrompt();
            }
            else {
                this.log("Paste support module not found.", "error");
            }
        }

        this._totalFilesInBatch = 0;
        this._filesInBatchAddedToUi = 0;
    }
};

// Inherit the base public & private API methods
qq.extend(qq.FineUploader.prototype, qq.basePublicApi);
qq.extend(qq.FineUploader.prototype, qq.basePrivateApi);

// Add the FineUploader/default UI public & private UI methods, which may override some base methods.
qq.extend(qq.FineUploader.prototype, qq.uiPublicApi);
qq.extend(qq.FineUploader.prototype, qq.uiPrivateApi);

/* globals qq */
/* jshint -W065 */
/**
 * Module responsible for rendering all Fine Uploader UI templates.  This module also asserts at least
 * a limited amount of control over the template elements after they are added to the DOM.
 * Wherever possible, this module asserts total control over template elements present in the DOM.
 *
 * @param spec Specification object used to control various templating behaviors
 * @constructor
 */
qq.Templating = function(spec) {

    var FILE_ID_ATTR = "qq-file-id",
        FILE_CLASS_PREFIX = "qq-file-id-",
        THUMBNAIL_MAX_SIZE_ATTR = "qq-max-size",
        THUMBNAIL_SERVER_SCALE_ATTR = "qq-server-scale",
        // This variable is duplicated in the DnD module since it can function as a standalone as well
        HIDE_DROPZONE_ATTR = "qq-hide-dropzone",
        DROPZPONE_TEXT_ATTR = "qq-drop-area-text",
        IN_PROGRESS_CLASS = "qq-in-progress",
        HIDDEN_FOREVER_CLASS = "qq-hidden-forever",
        fileBatch = {
            content: document.createDocumentFragment(),
            map: {}
        },
        isCancelDisabled = false,
        generatedThumbnails = 0,
        thumbnailQueueMonitorRunning = false,
        thumbGenerationQueue = [],
        thumbnailMaxSize = -1,
        options = {
            log: null,
            limits: {
                maxThumbs: 0,
                timeBetweenThumbs: 750
            },
            templateIdOrEl: "qq-template",
            containerEl: null,
            fileContainerEl: null,
            button: null,
            imageGenerator: null,
            classes: {
                hide: "qq-hide",
                editable: "qq-editable"
            },
            placeholders: {
                waitUntilUpdate: false,
                thumbnailNotAvailable: null,
                waitingForThumbnail: null
            },
            text: {
                paused: "Paused"
            }
        },
        selectorClasses = {
            button: "qq-upload-button-selector",
            alertDialog: "qq-alert-dialog-selector",
            dialogCancelButton: "qq-cancel-button-selector",
            confirmDialog: "qq-confirm-dialog-selector",
            dialogMessage: "qq-dialog-message-selector",
            dialogOkButton: "qq-ok-button-selector",
            promptDialog: "qq-prompt-dialog-selector",
            uploader: "qq-uploader-selector",
            drop: "qq-upload-drop-area-selector",
            list: "qq-upload-list-selector",
            progressBarContainer: "qq-progress-bar-container-selector",
            progressBar: "qq-progress-bar-selector",
            totalProgressBarContainer: "qq-total-progress-bar-container-selector",
            totalProgressBar: "qq-total-progress-bar-selector",
            file: "qq-upload-file-selector",
            spinner: "qq-upload-spinner-selector",
            size: "qq-upload-size-selector",
            cancel: "qq-upload-cancel-selector",
            pause: "qq-upload-pause-selector",
            continueButton: "qq-upload-continue-selector",
            deleteButton: "qq-upload-delete-selector",
            retry: "qq-upload-retry-selector",
            statusText: "qq-upload-status-text-selector",
            editFilenameInput: "qq-edit-filename-selector",
            editNameIcon: "qq-edit-filename-icon-selector",
            dropText: "qq-upload-drop-area-text-selector",
            dropProcessing: "qq-drop-processing-selector",
            dropProcessingSpinner: "qq-drop-processing-spinner-selector",
            thumbnail: "qq-thumbnail-selector"
        },
        previewGeneration = {},
        cachedThumbnailNotAvailableImg = new qq.Promise(),
        cachedWaitingForThumbnailImg = new qq.Promise(),
        log,
        isEditElementsExist,
        isRetryElementExist,
        templateHtml,
        container,
        fileList,
        showThumbnails,
        serverScale,

        // During initialization of the templating module we should cache any
        // placeholder images so we can quickly swap them into the file list on demand.
        // Any placeholder images that cannot be loaded/found are simply ignored.
        cacheThumbnailPlaceholders = function() {
            var notAvailableUrl =  options.placeholders.thumbnailNotAvailable,
                waitingUrl = options.placeholders.waitingForThumbnail,
                spec = {
                    maxSize: thumbnailMaxSize,
                    scale: serverScale
                };

            if (showThumbnails) {
                if (notAvailableUrl) {
                    options.imageGenerator.generate(notAvailableUrl, new Image(), spec).then(
                        function(updatedImg) {
                            cachedThumbnailNotAvailableImg.success(updatedImg);
                        },
                        function() {
                            cachedThumbnailNotAvailableImg.failure();
                            log("Problem loading 'not available' placeholder image at " + notAvailableUrl, "error");
                        }
                    );
                }
                else {
                    cachedThumbnailNotAvailableImg.failure();
                }

                if (waitingUrl) {
                    options.imageGenerator.generate(waitingUrl, new Image(), spec).then(
                        function(updatedImg) {
                            cachedWaitingForThumbnailImg.success(updatedImg);
                        },
                        function() {
                            cachedWaitingForThumbnailImg.failure();
                            log("Problem loading 'waiting for thumbnail' placeholder image at " + waitingUrl, "error");
                        }
                    );
                }
                else {
                    cachedWaitingForThumbnailImg.failure();
                }
            }
        },

        // Displays a "waiting for thumbnail" type placeholder image
        // iff we were able to load it during initialization of the templating module.
        displayWaitingImg = function(thumbnail) {
            var waitingImgPlacement = new qq.Promise();

            cachedWaitingForThumbnailImg.then(function(img) {
                maybeScalePlaceholderViaCss(img, thumbnail);
                /* jshint eqnull:true */
                if (!thumbnail.src) {
                    thumbnail.src = img.src;
                    thumbnail.onload = function() {
                        thumbnail.onload = null;
                        show(thumbnail);
                        waitingImgPlacement.success();
                    };
                }
                else {
                    waitingImgPlacement.success();
                }
            }, function() {
                // In some browsers (such as IE9 and older) an img w/out a src attribute
                // are displayed as "broken" images, so we should just hide the img tag
                // if we aren't going to display the "waiting" placeholder.
                hide(thumbnail);
                waitingImgPlacement.success();
            });

            return waitingImgPlacement;
        },

        generateNewPreview = function(id, blob, spec) {
            var thumbnail = getThumbnail(id);

            log("Generating new thumbnail for " + id);
            blob.qqThumbnailId = id;

            return options.imageGenerator.generate(blob, thumbnail, spec).then(
                function() {
                    generatedThumbnails++;
                    show(thumbnail);
                    previewGeneration[id].success();
                },
                function() {
                    previewGeneration[id].failure();

                    // Display the "not available" placeholder img only if we are
                    // not expecting a thumbnail at a later point, such as in a server response.
                    if (!options.placeholders.waitUntilUpdate) {
                        maybeSetDisplayNotAvailableImg(id, thumbnail);
                    }
                });
        },

        generateNextQueuedPreview = function() {
            if (thumbGenerationQueue.length) {
                thumbnailQueueMonitorRunning = true;

                var queuedThumbRequest = thumbGenerationQueue.shift();

                if (queuedThumbRequest.update) {
                    processUpdateQueuedPreviewRequest(queuedThumbRequest);
                }
                else {
                    processNewQueuedPreviewRequest(queuedThumbRequest);
                }
            }
            else {
                thumbnailQueueMonitorRunning = false;
            }
        },

        getCancel = function(id) {
            return getTemplateEl(getFile(id), selectorClasses.cancel);
        },

        getContinue = function(id) {
            return getTemplateEl(getFile(id), selectorClasses.continueButton);
        },

        getDialog = function(type) {
            return getTemplateEl(container, selectorClasses[type + "Dialog"]);
        },

        getDelete = function(id) {
            return getTemplateEl(getFile(id), selectorClasses.deleteButton);
        },

        getDropProcessing = function() {
            return getTemplateEl(container, selectorClasses.dropProcessing);
        },

        getEditIcon = function(id) {
            return getTemplateEl(getFile(id), selectorClasses.editNameIcon);
        },

        getFile = function(id) {
            return fileBatch.map[id] || qq(fileList).getFirstByClass(FILE_CLASS_PREFIX + id);
        },

        getFilename = function(id) {
            return getTemplateEl(getFile(id), selectorClasses.file);
        },

        getPause = function(id) {
            return getTemplateEl(getFile(id), selectorClasses.pause);
        },

        getProgress = function(id) {
            /* jshint eqnull:true */
            // Total progress bar
            if ( 'undefined' === typeof id || id === null) {
                return getTemplateEl(container, selectorClasses.totalProgressBarContainer) ||
                    getTemplateEl(container, selectorClasses.totalProgressBar);
            }

            // Per-file progress bar
            return getTemplateEl(getFile(id), selectorClasses.progressBarContainer) ||
                getTemplateEl(getFile(id), selectorClasses.progressBar);
        },

        getRetry = function(id) {
            return getTemplateEl(getFile(id), selectorClasses.retry);
        },

        getSize = function(id) {
            return getTemplateEl(getFile(id), selectorClasses.size);
        },

        getSpinner = function(id) {
            return getTemplateEl(getFile(id), selectorClasses.spinner);
        },

        getTemplateEl = function(context, cssClass) {
            return context && qq(context).getFirstByClass(cssClass);
        },

        getThumbnail = function(id) {
            var templateElement = getTemplateEl(getFile(id), selectorClasses.thumbnail);
            return showThumbnails && templateElement;
        },

        hide = function(el) {
            if ( el ) { qq(el).addClass(options.classes.hide); }
        },

        // Ensures a placeholder image does not exceed any max size specified
        // via `style` attribute properties iff <canvas> was not used to scale
        // the placeholder AND the target <img> doesn't already have these `style` attribute properties set.
        maybeScalePlaceholderViaCss = function(placeholder, thumbnail) {
            var maxWidth = placeholder.style.maxWidth,
                maxHeight = placeholder.style.maxHeight;

            if (maxHeight && maxWidth && !thumbnail.style.maxWidth && !thumbnail.style.maxHeight) {
                qq(thumbnail).css({
                    maxWidth: maxWidth,
                    maxHeight: maxHeight
                });
            }
        },

        // Displays a "thumbnail not available" type placeholder image
        // iff we were able to load this placeholder during initialization
        // of the templating module or after preview generation has failed.
        maybeSetDisplayNotAvailableImg = function(id, thumbnail) {
            var previewing = previewGeneration[id] || new qq.Promise().failure(),
                notAvailableImgPlacement = new qq.Promise();

            cachedThumbnailNotAvailableImg.then(function(img) {
                previewing.then(
                    function() {
                        notAvailableImgPlacement.success();
                    },
                    function() {
                        maybeScalePlaceholderViaCss(img, thumbnail);

                        thumbnail.onload = function() {
                            thumbnail.onload = null;
                            notAvailableImgPlacement.success();
                        };

                        thumbnail.src = img.src;
                        show(thumbnail);
                    }
                );
            });

            return notAvailableImgPlacement;
        },

        /**
         * Grabs the HTML from the script tag holding the template markup.  This function will also adjust
         * some internally-tracked state variables based on the contents of the template.
         * The template is filtered so that irrelevant elements (such as the drop zone if DnD is not supported)
         * are omitted from the DOM.  Useful errors will be thrown if the template cannot be parsed.
         *
         * @returns {{template: *, fileTemplate: *}} HTML for the top-level file items templates
         */
        parseAndGetTemplate = function() {
            var scriptEl,
                scriptHtml,
                fileListNode,
                tempTemplateEl,
                fileListHtml,
                defaultButton,
                dropArea,
                thumbnail,
                dropProcessing,
                dropTextEl,
                uploaderEl;

            log("Parsing template");

            /*jshint -W116*/
            if ( !options.templateIdOrEl ) {
                throw new Error("You MUST specify either a template element or ID!");
            }

            // Grab the contents of the script tag holding the template.
            if (qq.isString(options.templateIdOrEl)) {
                scriptEl = document.getElementById(options.templateIdOrEl);

                if ( !scriptEl ) {
                    throw new Error(qq.format("Cannot find template script at ID '{}'!", options.templateIdOrEl));
                }

                scriptHtml = scriptEl.innerHTML;
            }
            else {
                if (options.templateIdOrEl.innerHTML === undefined) {
                    throw new Error("You have specified an invalid value for the template option!  " +
                        "It must be an ID or an Element.");
                }

                scriptHtml = options.templateIdOrEl.innerHTML;
            }

            scriptHtml = qq.trimStr(scriptHtml);
            tempTemplateEl = document.createElement("div");
            tempTemplateEl.appendChild(qq.toElement(scriptHtml));
            uploaderEl = qq(tempTemplateEl).getFirstByClass(selectorClasses.uploader);

            // Don't include the default template button in the DOM
            // if an alternate button container has been specified.
            if (options.button) {
                defaultButton = qq(tempTemplateEl).getFirstByClass(selectorClasses.button);
                if (defaultButton) {
                    qq(defaultButton).remove();
                }
            }

            // Omit the drop processing element from the DOM if DnD is not supported by the UA,
            // or the drag and drop module is not found.
            // NOTE: We are consciously not removing the drop zone if the UA doesn't support DnD
            // to support layouts where the drop zone is also a container for visible elements,
            // such as the file list.
            if (!qq.DragAndDrop || !qq.supportedFeatures.fileDrop) {
                dropProcessing = qq(tempTemplateEl).getFirstByClass(selectorClasses.dropProcessing);
                if (dropProcessing) {
                    qq(dropProcessing).remove();
                }
            }

            dropArea = qq(tempTemplateEl).getFirstByClass(selectorClasses.drop);

            // If DnD is not available then remove
            // it from the DOM as well.
            if (dropArea && !qq.DragAndDrop) {
                log("DnD module unavailable.", "info");
                qq(dropArea).remove();
            }

            if (!qq.supportedFeatures.fileDrop) {
                // don't display any "drop files to upload" background text
                uploaderEl.removeAttribute(DROPZPONE_TEXT_ATTR);

                if (dropArea && qq(dropArea).hasAttribute(HIDE_DROPZONE_ATTR)) {
                    // If there is a drop area defined in the template, and the current UA doesn't support DnD,
                    // and the drop area is marked as "hide before enter", ensure it is hidden as the DnD module
                    // will not do this (since we will not be loading the DnD module)
                    qq(dropArea).css({
                        display: "none"
                    });
                }
            }
            else if (qq(uploaderEl).hasAttribute(DROPZPONE_TEXT_ATTR) && dropArea) {
                dropTextEl = qq(dropArea).getFirstByClass(selectorClasses.dropText);
                if ( dropTextEl ) { qq(dropTextEl).remove(); }
            }

            // Ensure the `showThumbnails` flag is only set if the thumbnail element
            // is present in the template AND the current UA is capable of generating client-side previews.
            thumbnail = qq(tempTemplateEl).getFirstByClass(selectorClasses.thumbnail);
            if (!showThumbnails  && thumbnail) {
                qq(thumbnail).remove();
            }
            else if (thumbnail) {
                thumbnailMaxSize = parseInt(thumbnail.getAttribute(THUMBNAIL_MAX_SIZE_ATTR));
                // Only enforce max size if the attr value is non-zero
                thumbnailMaxSize = thumbnailMaxSize > 0 ? thumbnailMaxSize : null;

                serverScale = qq(thumbnail).hasAttribute(THUMBNAIL_SERVER_SCALE_ATTR);
            }
            showThumbnails = showThumbnails && thumbnail;

            isEditElementsExist = qq(tempTemplateEl).getByClass(selectorClasses.editFilenameInput).length > 0;
            isRetryElementExist = qq(tempTemplateEl).getByClass(selectorClasses.retry).length > 0;

            fileListNode = qq(tempTemplateEl).getFirstByClass(selectorClasses.list);
            /*jshint -W116*/
            if ( !fileListNode ) {
                throw new Error( "Could not find the file list container in the template!" );
            }

            fileListHtml = fileListNode.innerHTML;
            fileListNode.innerHTML = "";

            // We must call `createElement` in IE8 in order to target and hide any <dialog> via CSS
            if (tempTemplateEl.getElementsByTagName("DIALOG").length) {
                document.createElement("dialog");
            }

            log("Template parsing complete");

            return {
                template: qq.trimStr(tempTemplateEl.innerHTML),
                fileTemplate: qq.trimStr(fileListHtml)
            };
        },

        prependFile = function(el, index, fileList) {
            var parentEl = fileList,
                beforeEl = parentEl.firstChild;

            if (index > 0) {
                beforeEl = qq(parentEl).children()[index].nextSibling;

            }

            parentEl.insertBefore(el, beforeEl);
        },

        processNewQueuedPreviewRequest = function(queuedThumbRequest) {
            var id = queuedThumbRequest.id,
                optFileOrBlob = queuedThumbRequest.optFileOrBlob,
                relatedThumbnailId = optFileOrBlob && optFileOrBlob.qqThumbnailId,
                thumbnail = getThumbnail(id),
                spec = {
                    customResizeFunction: queuedThumbRequest.customResizeFunction,
                    maxSize: thumbnailMaxSize,
                    orient: true,
                    scale: true
                };

            if (qq.supportedFeatures.imagePreviews) {
                if (thumbnail) {
                    if (options.limits.maxThumbs && options.limits.maxThumbs <= generatedThumbnails) {
                        maybeSetDisplayNotAvailableImg(id, thumbnail);
                        generateNextQueuedPreview();
                    }
                    else {
                        displayWaitingImg(thumbnail).done(function() {
                            previewGeneration[id] = new qq.Promise();

                            previewGeneration[id].done(function() {
                                setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);
                            });

                            /* jshint eqnull: true */
                            // If we've already generated an <img> for this file, use the one that exists,
                            // don't waste resources generating a new one.
                            if (relatedThumbnailId != null) {
                                useCachedPreview(id, relatedThumbnailId);
                            }
                            else {
                                generateNewPreview(id, optFileOrBlob, spec);
                            }
                        });
                    }
                }
                // File element in template may have been removed, so move on to next item in queue
                else {
                    generateNextQueuedPreview();
                }
            }
            else if (thumbnail) {
                displayWaitingImg(thumbnail);
                generateNextQueuedPreview();
            }
        },

        processUpdateQueuedPreviewRequest = function(queuedThumbRequest) {
            var id = queuedThumbRequest.id,
                thumbnailUrl = queuedThumbRequest.thumbnailUrl,
                showWaitingImg = queuedThumbRequest.showWaitingImg,
                thumbnail = getThumbnail(id),
                spec = {
                    customResizeFunction: queuedThumbRequest.customResizeFunction,
                    scale: serverScale,
                    maxSize: thumbnailMaxSize
                };

            if (thumbnail) {
                if (thumbnailUrl) {
                    if (options.limits.maxThumbs && options.limits.maxThumbs <= generatedThumbnails) {
                        maybeSetDisplayNotAvailableImg(id, thumbnail);
                        generateNextQueuedPreview();
                    }
                    else {
                        if (showWaitingImg) {
                            displayWaitingImg(thumbnail);
                        }

                        return options.imageGenerator.generate(thumbnailUrl, thumbnail, spec).then(
                            function() {
                                show(thumbnail);
                                generatedThumbnails++;
                                setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);
                            },

                            function() {
                                maybeSetDisplayNotAvailableImg(id, thumbnail);
                                setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);
                            }
                        );
                    }
                }
                else {
                    maybeSetDisplayNotAvailableImg(id, thumbnail);
                    generateNextQueuedPreview();
                }
            }
        },

        setProgressBarWidth = function(id, percent) {
            var bar = getProgress(id),
                /* jshint eqnull:true */
                progressBarSelector = ( !id ) ? selectorClasses.totalProgressBar : selectorClasses.progressBar;

            if (bar && !qq(bar).hasClass(progressBarSelector)) {
                bar = qq(bar).getFirstByClass(progressBarSelector);
            }

            if (bar) {
                qq(bar).css({width: percent + "%"});
                bar.setAttribute("aria-valuenow", percent);
            }
        },

        show = function(el) {
            if ( el ) { qq(el).removeClass(options.classes.hide); }
        },

        useCachedPreview = function(targetThumbnailId, cachedThumbnailId) {
            var targetThumbnail = getThumbnail(targetThumbnailId),
                cachedThumbnail = getThumbnail(cachedThumbnailId);

            log(qq.format("ID {} is the same file as ID {}.  Will use generated thumbnail from ID {} instead.", targetThumbnailId, cachedThumbnailId, cachedThumbnailId));

            // Generation of the related thumbnail may still be in progress, so, wait until it is done.
            previewGeneration[cachedThumbnailId].then(function() {
                generatedThumbnails++;
                previewGeneration[targetThumbnailId].success();
                log(qq.format("Now using previously generated thumbnail created for ID {} on ID {}.", cachedThumbnailId, targetThumbnailId));
                targetThumbnail.src = cachedThumbnail.src;
                show(targetThumbnail);
            },
            function() {
                previewGeneration[targetThumbnailId].failure();
                if (!options.placeholders.waitUntilUpdate) {
                    maybeSetDisplayNotAvailableImg(targetThumbnailId, targetThumbnail);
                }
            });
        };

    qq.extend(options, spec);
    log = options.log;

    // No need to worry about conserving CPU or memory on older browsers,
    // since there is no ability to preview, and thumbnail display is primitive and quick.
    if (!qq.supportedFeatures.imagePreviews) {
        options.limits.timeBetweenThumbs = 0;
        options.limits.maxThumbs = 0;
    }

    container = options.containerEl;
    showThumbnails = options.imageGenerator !== undefined;
    templateHtml = parseAndGetTemplate();

    cacheThumbnailPlaceholders();

    qq.extend(this, {
        render: function() {
            log("Rendering template in DOM.");

            generatedThumbnails = 0;

            container.innerHTML = templateHtml.template;
            hide(getDropProcessing());
            this.hideTotalProgress();
            fileList = options.fileContainerEl || getTemplateEl(container, selectorClasses.list);

            log("Template rendering complete");
        },

        renderFailure: function(message) {
            var cantRenderEl = qq.toElement(message);
            container.innerHTML = "";
            container.appendChild(cantRenderEl);
        },

        reset: function() {
            this.render();
        },

        clearFiles: function() {
            fileList.innerHTML = "";
        },

        disableCancel: function() {
            isCancelDisabled = true;
        },

        addFile: function(id, name, prependInfo, hideForever, batch) {
            var fileEl = qq.toElement(templateHtml.fileTemplate),
                fileNameEl = getTemplateEl(fileEl, selectorClasses.file),
                uploaderEl = getTemplateEl(container, selectorClasses.uploader),
                fileContainer = batch ? fileBatch.content : fileList,
                thumb;

            if (batch) {
                fileBatch.map[id] = fileEl;
            }

            qq(fileEl).addClass(FILE_CLASS_PREFIX + id);
            uploaderEl.removeAttribute(DROPZPONE_TEXT_ATTR);

            if (fileNameEl) {
                qq(fileNameEl).setText(name);
                fileNameEl.setAttribute("title", name);
            }

            fileEl.setAttribute(FILE_ID_ATTR, id);

            if (prependInfo) {
                prependFile(fileEl, prependInfo.index, fileContainer);
            }
            else {
                fileContainer.appendChild(fileEl);
            }

            if (hideForever) {
                fileEl.style.display = "none";
                qq(fileEl).addClass(HIDDEN_FOREVER_CLASS);
            }
            else {
                hide(getProgress(id));
                hide(getSize(id));
                hide(getDelete(id));
                hide(getRetry(id));
                hide(getPause(id));
                hide(getContinue(id));

                if (isCancelDisabled) {
                    this.hideCancel(id);
                }

                thumb = getThumbnail(id);
                if (thumb && !thumb.src) {
                    cachedWaitingForThumbnailImg.then(function(waitingImg) {
                        thumb.src = waitingImg.src;
                        if (waitingImg.style.maxHeight && waitingImg.style.maxWidth) {
                            qq(thumb).css({
                                maxHeight: waitingImg.style.maxHeight,
                                maxWidth: waitingImg.style.maxWidth
                            });
                        }

                        show(thumb);
                    });
                }
            }
        },

        addFileToCache: function(id, name, prependInfo, hideForever) {
            this.addFile(id, name, prependInfo, hideForever, true);
        },

        addCacheToDom: function() {
            fileList.appendChild(fileBatch.content);
            fileBatch.content = document.createDocumentFragment();
            fileBatch.map = {};
        },

        removeFile: function(id) {
            qq(getFile(id)).remove();
        },

        getFileId: function(el) {
            var currentNode = el;

            if (currentNode) {
                /*jshint -W116*/
                while ( !currentNode.getAttribute(FILE_ID_ATTR) ) {
                    currentNode = currentNode.parentNode;
                }

                return parseInt(currentNode.getAttribute(FILE_ID_ATTR));
            }
        },

        getFileList: function() {
            return fileList;
        },

        markFilenameEditable: function(id) {
            var filename = getFilename(id);
            if ( filename ) { qq(filename).addClass(options.classes.editable); }
        },

        updateFilename: function(id, name) {
            var filenameEl = getFilename(id);

            if (filenameEl) {
                qq(filenameEl).setText(name);
                filenameEl.setAttribute("title", name);
            }
        },

        hideFilename: function(id) {
            hide(getFilename(id));
        },

        showFilename: function(id) {
            show(getFilename(id));
        },

        isFileName: function(el) {
            return qq(el).hasClass(selectorClasses.file);
        },

        getButton: function() {
            return options.button || getTemplateEl(container, selectorClasses.button);
        },

        hideDropProcessing: function() {
            hide(getDropProcessing());
        },

        showDropProcessing: function() {
            show(getDropProcessing());
        },

        getDropZone: function() {
            return getTemplateEl(container, selectorClasses.drop);
        },

        isEditFilenamePossible: function() {
            return isEditElementsExist;
        },

        hideRetry: function(id) {
            hide(getRetry(id));
        },

        isRetryPossible: function() {
            return isRetryElementExist;
        },

        showRetry: function(id) {
            show(getRetry(id));
        },

        getFileContainer: function(id) {
            return getFile(id);
        },

        showEditIcon: function(id) {
            var icon = getEditIcon(id);
            if ( icon ) { qq(icon).addClass(options.classes.editable); }
        },

        isHiddenForever: function(id) {
            return qq(getFile(id)).hasClass(HIDDEN_FOREVER_CLASS);
        },

        hideEditIcon: function(id) {
            var icon = getEditIcon(id);
            if ( icon ) { qq(icon).removeClass(options.classes.editable); }
        },

        isEditIcon: function(el) {
            return qq(el).hasClass(selectorClasses.editNameIcon, true);
        },

        getEditInput: function(id) {
            return getTemplateEl(getFile(id), selectorClasses.editFilenameInput);
        },

        isEditInput: function(el) {
            return qq(el).hasClass(selectorClasses.editFilenameInput, true);
        },

        updateProgress: function(id, loaded, total) {
            var bar = getProgress(id),
                percent;

            if (bar && total > 0) {
                percent = Math.round(loaded / total * 100);

                if (percent === 100) {
                    hide(bar);
                }
                else {
                    show(bar);
                }

                setProgressBarWidth(id, percent);
            }
        },

        updateTotalProgress: function(loaded, total) {
            this.updateProgress(null, loaded, total);
        },

        hideProgress: function(id) {
            var bar = getProgress(id);

            if ( bar ) { hide(bar); }
        },

        hideTotalProgress: function() {
            this.hideProgress();
        },

        resetProgress: function(id) {
            setProgressBarWidth(id, 0);
            this.hideTotalProgress(id);
        },

        resetTotalProgress: function() {
            this.resetProgress();
        },

        showCancel: function(id) {
            if (!isCancelDisabled) {
                var cancel = getCancel(id);
                if ( cancel ) { qq(cancel).removeClass(options.classes.hide); }
            }
        },

        hideCancel: function(id) {
            hide(getCancel(id));
        },

        isCancel: function(el)  {
            return qq(el).hasClass(selectorClasses.cancel, true);
        },

        allowPause: function(id) {
            show(getPause(id));
            hide(getContinue(id));
        },

        uploadPaused: function(id) {
            this.setStatusText(id, options.text.paused);
            this.allowContinueButton(id);
            hide(getSpinner(id));
        },

        hidePause: function(id) {
            hide(getPause(id));
        },

        isPause: function(el) {
            return qq(el).hasClass(selectorClasses.pause, true);
        },

        isContinueButton: function(el) {
            return qq(el).hasClass(selectorClasses.continueButton, true);
        },

        allowContinueButton: function(id) {
            show(getContinue(id));
            hide(getPause(id));
        },

        uploadContinued: function(id) {
            this.setStatusText(id, "");
            this.allowPause(id);
            show(getSpinner(id));
        },

        showDeleteButton: function(id) {
            show(getDelete(id));
        },

        hideDeleteButton: function(id) {
            hide(getDelete(id));
        },

        isDeleteButton: function(el) {
            return qq(el).hasClass(selectorClasses.deleteButton, true);
        },

        isRetry: function(el) {
            return qq(el).hasClass(selectorClasses.retry, true);
        },

        updateSize: function(id, text) {
            var size = getSize(id);

            if (size) {
                show(size);
                qq(size).setText(text);
            }
        },

        setStatusText: function(id, text) {
            var textEl = getTemplateEl(getFile(id), selectorClasses.statusText);

            if (textEl) {
                /*jshint -W116*/
                if ( !text ) {
                    qq(textEl).clearText();
                }
                else {
                    qq(textEl).setText(text);
                }
            }
        },

        hideSpinner: function(id) {
            qq(getFile(id)).removeClass(IN_PROGRESS_CLASS);
            hide(getSpinner(id));
        },

        showSpinner: function(id) {
            qq(getFile(id)).addClass(IN_PROGRESS_CLASS);
            show(getSpinner(id));
        },

        generatePreview: function(id, optFileOrBlob, customResizeFunction) {
            if (!this.isHiddenForever(id)) {
                thumbGenerationQueue.push({id: id, customResizeFunction: customResizeFunction, optFileOrBlob: optFileOrBlob});
                if ( !thumbnailQueueMonitorRunning ) { generateNextQueuedPreview(); }
            }
        },

        updateThumbnail: function(id, thumbnailUrl, showWaitingImg, customResizeFunction) {
            if (!this.isHiddenForever(id)) {
                thumbGenerationQueue.push({customResizeFunction: customResizeFunction, update: true, id: id, thumbnailUrl: thumbnailUrl, showWaitingImg: showWaitingImg});
                if ( !thumbnailQueueMonitorRunning ) { generateNextQueuedPreview(); }
            }
        },

        hasDialog: function(type) {
            return qq.supportedFeatures.dialogElement && !!getDialog(type);
        },

        showDialog: function(type, message, defaultValue) {
            var dialog = getDialog(type),
                messageEl = getTemplateEl(dialog, selectorClasses.dialogMessage),
                inputEl = dialog.getElementsByTagName("INPUT")[0],
                cancelBtn = getTemplateEl(dialog, selectorClasses.dialogCancelButton),
                okBtn = getTemplateEl(dialog, selectorClasses.dialogOkButton),
                promise = new qq.Promise(),

                closeHandler = function() {
                    cancelBtn.removeEventListener("click", cancelClickHandler);
                    if ( okBtn ) { okBtn.removeEventListener("click", okClickHandler); }
                    promise.failure();
                },

                cancelClickHandler = function() {
                    cancelBtn.removeEventListener("click", cancelClickHandler);
                    dialog.close();
                },

                okClickHandler = function() {
                    dialog.removeEventListener("close", closeHandler);
                    okBtn.removeEventListener("click", okClickHandler);
                    dialog.close();

                    promise.success(inputEl && inputEl.value);
                };

            dialog.addEventListener("close", closeHandler);
            cancelBtn.addEventListener("click", cancelClickHandler);
            if ( okBtn ) { okBtn.addEventListener("click", okClickHandler); }

            if (inputEl) {
                inputEl.value = defaultValue;
            }
            messageEl.textContent = message;

            dialog.showModal();

            return promise;
        }
    });
};

/*globals qq*/
/**
 * Upload handler used that assumes the current user agent does not have any support for the
 * File API, and, therefore, makes use of iframes and forms to submit the files directly to
 * a generic server.
 *
 * @param options Options passed from the base handler
 * @param proxy Callbacks & methods used to query for or push out data/changes
 */
qq.traditional = qq.traditional || {};
qq.traditional.FormUploadHandler = function(options, proxy) {

    var handler = this,
        getName = proxy.getName,
        getUuid = proxy.getUuid,
        log = proxy.log;

    /**
     * Returns json object received by iframe from server.
     */
    function getIframeContentJson(id, iframe) {
        /*jshint evil: true*/

        log( 'Getting iFrame JSON content from: ' + id );

        var response, doc, innerHtml;

        //IE may throw an "access is denied" error when attempting to access contentDocument on the iframe in some cases
        try {
            // iframe.contentWindow.document - for IE<7
            doc = iframe.contentDocument || iframe.contentWindow.document;
            innerHtml = doc.body.innerHTML;

            log("converting iframe's innerHTML to JSON");
            log("innerHTML = " + innerHtml);
            //plain text response may be wrapped in <pre> tag
            if (innerHtml && innerHtml.match(/^<pre/i)) {
                innerHtml = doc.body.firstChild.firstChild.nodeValue;
            }

            response = handler._parseJsonResponse(innerHtml);
        }
        catch (error) {
            log("Error when attempting to parse form upload response (" + error.message + ")", "error");
            response = {success: false};
        }

        return response;
    }

    /**
     * Creates form, that will be submitted to iframe
     */
    function createForm(id, iframe) {
        var params = options.paramsStore.get(id),
            method = options.method.toLowerCase() === "get" ? "GET" : "POST",
            endpoint = options.endpointStore.get(id),
            name = getName(id);

        params[options.uuidName] = getUuid(id);
        params[options.filenameParam] = name;

        return handler._initFormForUpload({
            method: method,
            endpoint: endpoint,
            params: params,
            paramsInBody: options.paramsInBody,
            targetName: iframe.name
        });
    }

    this.uploadFile = function(id) {
        var input = handler.getInput(id),
            iframe = handler._createIframe(id),
            promise = new qq.Promise(),
            form;

        form = createForm(id, iframe);
        form.appendChild(input);

        handler._attachLoadEvent(iframe, function(responseFromMessage) {
            log("iframe loaded");

            var response = responseFromMessage ? responseFromMessage : getIframeContentJson(id, iframe);

            //  Doc Cirrus REST API format
            response = response.data ? response.data : response;

            handler._detachLoadEvent(id);

            //we can't remove an iframe if the iframe doesn't belong to the same domain
            if (!options.cors.expected) {
                qq(iframe).remove();
            }

            if (response.success) {
                promise.success(response);
            }
            else {
                promise.failure(response);
            }
        });

        log("Sending upload request for " + id);
        form.submit();
        qq(form).remove();

        return promise;
    };

    qq.extend(this, new qq.FormUploadHandler({
        options: {
            isCors: options.cors.expected,
            inputName: options.inputName
        },

        proxy: {
            onCancel: options.onCancel,
            getName: getName,
            getUuid: getUuid,
            log: log
        }
    }));
};

/*globals qq*/
/**
 * Upload handler used to upload to traditional endpoints.  It depends on File API support, and, therefore,
 * makes use of `XMLHttpRequest` level 2 to upload `File`s and `Blob`s to a generic server.
 *
 * @param spec Options passed from the base handler
 * @param proxy Callbacks & methods used to query for or push out data/changes
 */
qq.traditional = qq.traditional || {};
qq.traditional.XhrUploadHandler = function(spec, proxy) {

    var handler = this,
        getName = proxy.getName,
        getSize = proxy.getSize,
        getUuid = proxy.getUuid,
        log = proxy.log,
        multipart = spec.forceMultipart || spec.paramsInBody,

        addChunkingSpecificParams = function(id, params, chunkData) {
            var size = getSize(id),
                name = getName(id);

            params[spec.chunking.paramNames.partIndex] = chunkData.part;
            params[spec.chunking.paramNames.partByteOffset] = chunkData.start;
            params[spec.chunking.paramNames.chunkSize] = chunkData.size;
            params[spec.chunking.paramNames.totalParts] = chunkData.count;
            params[spec.totalFileSizeName] = size;

            /**
             * When a Blob is sent in a multipart request, the filename value in the content-disposition header is either "blob"
             * or an empty string.  So, we will need to include the actual file name as a param in this case.
             */
            if (multipart) {
                params[spec.filenameParam] = name;
            }
        },

        allChunksDoneRequester = new qq.traditional.AllChunksDoneAjaxRequester({
            cors: spec.cors,
            endpoint: spec.chunking.success.endpoint,
            log: log
        }),

        createReadyStateChangedHandler = function(id, xhr) {
            var promise = new qq.Promise();

            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    var result = onUploadOrChunkComplete(id, xhr);

                    if (result.success) {
                        promise.success(result.response, xhr);
                    }
                    else {
                        promise.failure(result.response, xhr);
                    }
                }
            };

            return promise;
        },

        getChunksCompleteParams = function(id) {
            var params = spec.paramsStore.get(id),
                name = getName(id),
                size = getSize(id);

            params[spec.uuidName] = getUuid(id);
            params[spec.filenameParam] = name;
            params[spec.totalFileSizeName] = size;
            params[spec.chunking.paramNames.totalParts] = handler._getTotalChunks(id);

            return params;
        },

        isErrorUploadResponse = function(xhr, response) {
            return qq.indexOf([200, 201, 202, 203, 204], xhr.status) < 0 ||
                !response.success ||
                response.reset;
        },

        onUploadOrChunkComplete = function(id, xhr) {
            var response;

            response = parseResponse(true, xhr);

            return {
                success: !isErrorUploadResponse(xhr, response),
                response: response
            };
        },

        // If this is an upload response, we require a JSON payload, otherwise, it is optional.
        parseResponse = function(upload, xhr) {
            var response = {};

            try {
                log(qq.format("Received response status {} with body: {}", xhr.status, xhr.responseText));
                response = qq.parseJson(xhr.responseText);
            }
            catch (error) {
                if ( upload ) { log("Error when attempting to parse xhr response text (" + error.message + ")", "error"); }
            }

            return response;
        },

        sendChunksCompleteRequest = function(id) {
            var promise = new qq.Promise();

            allChunksDoneRequester.complete(
                    id,
                    handler._createXhr(id),
                    getChunksCompleteParams(id),
                    spec.customHeaders.get(id)
                )
                .then(function(xhr) {
                    promise.success(parseResponse(false, xhr), xhr);
                }, function(xhr) {
                    promise.failure(parseResponse(false, xhr), xhr);
                });

            return promise;
        },

        setParamsAndGetEntityToSend = function(params, xhr, fileOrBlob, id) {
            var formData = new FormData(),
                method = spec.method,
                endpoint = spec.endpointStore.get(id),
                name = getName(id),
                size = getSize(id);

            params[spec.uuidName] = getUuid(id);
            params[spec.filenameParam] = name;

            if (multipart) {
                params[spec.totalFileSizeName] = size;
            }

            //build query string
            if (!spec.paramsInBody) {
                if (!multipart) {
                    params[spec.inputName] = name;
                }
                endpoint = qq.obj2url(params, endpoint);
            }

            xhr.open(method, endpoint, true);

            if (spec.cors.expected && spec.cors.sendCredentials) {
                xhr.withCredentials = true;
            }

            if (multipart) {
                if (spec.paramsInBody) {
                    qq.obj2FormData(params, formData);
                }

                formData.append(spec.inputName, fileOrBlob);
                return formData;
            }

            return fileOrBlob;
        },

        setUploadHeaders = function(id, xhr) {
            var extraHeaders = spec.customHeaders.get(id),
                fileOrBlob = handler.getFile(id);

            xhr.setRequestHeader("Accept", "application/json");
            xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            xhr.setRequestHeader("Cache-Control", "no-cache");

            if (!multipart) {
                xhr.setRequestHeader("Content-Type", "application/octet-stream");
                //NOTE: return mime type in xhr works on chrome 16.0.9 firefox 11.0a2
                xhr.setRequestHeader("X-Mime-Type", fileOrBlob.type);
            }

            qq.each(extraHeaders, function(name, val) {
                xhr.setRequestHeader(name, val);
            });
        };

    qq.extend(this, {
        uploadChunk: function(id, chunkIdx, resuming) {
            var chunkData = handler._getChunkData(id, chunkIdx),
                xhr = handler._createXhr(id, chunkIdx),
                size = getSize(id),
                promise, toSend, params;

            promise = createReadyStateChangedHandler(id, xhr);
            handler._registerProgressHandler(id, chunkIdx, chunkData.size);
            params = spec.paramsStore.get(id);
            addChunkingSpecificParams(id, params, chunkData);

            if (resuming) {
                params[spec.resume.paramNames.resuming] = true;
            }

            toSend = setParamsAndGetEntityToSend(params, xhr, chunkData.blob, id);
            setUploadHeaders(id, xhr);
            xhr.send(toSend);

            return promise;
        },

        uploadFile: function(id) {
            var fileOrBlob = handler.getFile(id),
                promise, xhr, params, toSend;

            xhr = handler._createXhr(id);
            handler._registerProgressHandler(id);
            promise = createReadyStateChangedHandler(id, xhr);
            params = spec.paramsStore.get(id);
            toSend = setParamsAndGetEntityToSend(params, xhr, fileOrBlob, id);
            setUploadHeaders(id, xhr);
            xhr.send(toSend);

            return promise;
        }
    });

    qq.extend(this, new qq.XhrUploadHandler({
        options: qq.extend({namespace: "traditional"}, spec),
        proxy: qq.extend({getEndpoint: spec.endpointStore.get}, proxy)
    }));

    qq.override(this, function(super_) {
        return {
            finalizeChunks: function(id) {
                if (spec.chunking.success.endpoint) {
                    return sendChunksCompleteRequest(id);
                }
                else {
                    return super_.finalizeChunks(id, qq.bind(parseResponse, this, true));
                }
            }
        };
    });
};

/*globals qq*/
/**
 * Ajax requester used to send a POST to a traditional endpoint once all chunks for a specific file have uploaded
 * successfully.
 *
 * @param o Options from the caller - will override the defaults.
 * @constructor
 */
qq.traditional.AllChunksDoneAjaxRequester = function(o) {
    var requester,
        method = "POST",
        options = {
            cors: {
                allowXdr: false,
                expected: false,
                sendCredentials: false
            },
            endpoint: null,
            log: function(str, level) {}
        },
        promises = {},
        endpointHandler = {
            get: function(id) {
                return options.endpoint;
            }
        };

    qq.extend(options, o);

    requester = qq.extend(this, new qq.AjaxRequester({
        acceptHeader: "application/json",
        validMethods: [method],
        method: method,
        endpointStore: endpointHandler,
        allowXRequestedWithAndCacheControl: false,
        cors: options.cors,
        log: options.log,
        onComplete: function(id, xhr, isError) {
            var promise = promises[id];

            delete promises[id];

            if (isError) {
                promise.failure(xhr);
            }
            else {
                promise.success(xhr);
            }
        }
    }));

    qq.extend(this, {
        complete: function(id, xhr, params, headers) {
            var promise = new qq.Promise();

            options.log("Submitting All Chunks Done request for " + id);

            promises[id] = promise;

            requester.initTransport(id)
                .withParams(params)
                .withHeaders(headers)
                .send(xhr);

            return promise;
        }
    });
};

/*globals qq*/
qq.PasteSupport = function(o) {

    var options, detachPasteHandler;

    options = {
        targetElement: null,
        callbacks: {
            log: function(message, level) {},
            pasteReceived: function(blob) {}
        }
    };

    function isImage(item) {
        return item.type && ( item.type.indexOf("image/") === 0 );
    }

    function registerPasteHandler() {
        detachPasteHandler = qq(options.targetElement).attach("paste", function(event) {
            var clipboardData = event.clipboardData;

            if (clipboardData) {
                qq.each(clipboardData.items, function(idx, item) {
                    if (isImage(item)) {
                        var blob = item.getAsFile();
                        options.callbacks.pasteReceived(blob);
                    }
                });
            }
        });
    }

    function unregisterPasteHandler() {
        if (detachPasteHandler) {
            detachPasteHandler();
        }
    }

    qq.extend(options, o);
    registerPasteHandler();

    qq.extend(this, {
        reset: function() {
            unregisterPasteHandler();
        }
    });
};

/*globals qq, document, CustomEvent*/
qq.DragAndDrop = function(o) {

    var options,
        HIDE_ZONES_EVENT_NAME = "qq-hidezones",
        HIDE_BEFORE_ENTER_ATTR = "qq-hide-dropzone",
        uploadDropZones = [],
        droppedFiles = [],
        disposeSupport = new qq.DisposeSupport();

    options = {
        dropZoneElements: [],
        allowMultipleItems: true,
        classes: {
            dropActive: null
        },
        callbacks: new qq.DragAndDrop.callbacks()
    };

    qq.extend(options, o, true);

    function uploadDroppedFiles(files, uploadDropZone) {
        // We need to convert the `FileList` to an actual `Array` to avoid iteration issues
        var filesAsArray = Array.prototype.slice.call(files);

        options.callbacks.dropLog("Grabbed " + files.length + " dropped files.");
        uploadDropZone.dropDisabled(false);
        options.callbacks.processingDroppedFilesComplete(filesAsArray, uploadDropZone.getElement());
    }

    function traverseFileTree(entry) {
        var parseEntryPromise = new qq.Promise();

        if (entry.isFile) {
            entry.file(function(file) {
                var name = entry.name,
                    fullPath = entry.fullPath,
                    indexOfNameInFullPath = fullPath.indexOf(name);

                // remove file name from full path string
                fullPath = fullPath.substr(0, indexOfNameInFullPath);

                // remove leading slash in full path string
                if (fullPath.charAt(0) === "/") {
                    fullPath = fullPath.substr(1);
                }

                file.qqPath = fullPath;
                droppedFiles.push(file);
                parseEntryPromise.success();
            },
            function(fileError) {
                options.callbacks.dropLog("Problem parsing '" + entry.fullPath + "'.  FileError code " + fileError.code + ".", "error");
                parseEntryPromise.failure();
            });
        }
        else if (entry.isDirectory) {
            getFilesInDirectory(entry).then(
                function allEntriesRead(entries) {
                    var entriesLeft = entries.length;

                    qq.each(entries, function(idx, entry) {
                        traverseFileTree(entry).done(function() {
                            entriesLeft -= 1;

                            if (entriesLeft === 0) {
                                parseEntryPromise.success();
                            }
                        });
                    });

                    if (!entries.length) {
                        parseEntryPromise.success();
                    }
                },

                function readFailure(fileError) {
                    options.callbacks.dropLog("Problem parsing '" + entry.fullPath + "'.  FileError code " + fileError.code + ".", "error");
                    parseEntryPromise.failure();
                }
            );
        }

        return parseEntryPromise;
    }

    // Promissory.  Guaranteed to read all files in the root of the passed directory.
    function getFilesInDirectory(entry, reader, accumEntries, existingPromise) {
        var promise = existingPromise || new qq.Promise(),
            dirReader = reader || entry.createReader();

        dirReader.readEntries(
            function readSuccess(entries) {
                var newEntries = accumEntries ? accumEntries.concat(entries) : entries;

                if (entries.length) {
                    setTimeout(function() { // prevent stack overflow, however unlikely
                        getFilesInDirectory(entry, dirReader, newEntries, promise);
                    }, 0);
                }
                else {
                    promise.success(newEntries);
                }
            },

            promise.failure
        );

        return promise;
    }

    function handleDataTransfer(dataTransfer, uploadDropZone) {
        var pendingFolderPromises = [],
            handleDataTransferPromise = new qq.Promise();

        options.callbacks.processingDroppedFiles();
        uploadDropZone.dropDisabled(true);

        if (dataTransfer.files.length > 1 && !options.allowMultipleItems) {
            options.callbacks.processingDroppedFilesComplete([]);
            options.callbacks.dropError("tooManyFilesError", "");
            uploadDropZone.dropDisabled(false);
            handleDataTransferPromise.failure();
        }
        else {
            droppedFiles = [];

            if (qq.isFolderDropSupported(dataTransfer)) {
                qq.each(dataTransfer.items, function(idx, item) {
                    var entry = item.webkitGetAsEntry();

                    if (entry) {
                        //due to a bug in Chrome's File System API impl - #149735
                        if (entry.isFile) {
                            droppedFiles.push(item.getAsFile());
                        }

                        else {
                            pendingFolderPromises.push(traverseFileTree(entry).done(function() {
                                pendingFolderPromises.pop();
                                if (pendingFolderPromises.length === 0) {
                                    handleDataTransferPromise.success();
                                }
                            }));
                        }
                    }
                });
            }
            else {
                droppedFiles = dataTransfer.files;
            }

            if (pendingFolderPromises.length === 0) {
                handleDataTransferPromise.success();
            }
        }

        return handleDataTransferPromise;
    }

    function setupDropzone(dropArea) {
        var dropZone = new qq.UploadDropZone({
            HIDE_ZONES_EVENT_NAME: HIDE_ZONES_EVENT_NAME,
            element: dropArea,
            onEnter: function(e) {
                qq(dropArea).addClass(options.classes.dropActive);
                e.stopPropagation();
            },
            onLeaveNotDescendants: function(e) {
                qq(dropArea).removeClass(options.classes.dropActive);
            },
            onDrop: function(e) {
                handleDataTransfer(e.dataTransfer, dropZone).then(
                    function() {
                        uploadDroppedFiles(droppedFiles, dropZone);
                    },
                    function() {
                        options.callbacks.dropLog("Drop event DataTransfer parsing failed.  No files will be uploaded.", "error");
                    }
                );
            }
        });

        disposeSupport.addDisposer(function() {
            dropZone.dispose();
        });

        if ( qq(dropArea).hasAttribute(HIDE_BEFORE_ENTER_ATTR) ) { qq(dropArea).hide(); }

        uploadDropZones.push(dropZone);

        return dropZone;
    }

    function isFileDrag(dragEvent) {
        var fileDrag = false;

        qq.each(dragEvent.dataTransfer.types, function(key, val) {
            if (val === "Files") {
                fileDrag = true;
                return false;
            }
        });

        return fileDrag;
    }

    // Attempt to determine when the file has left the document.  It is not always possible to detect this
    // in all cases, but it is generally possible in all browsers, with a few exceptions.
    //
    // Exceptions:
    // * IE10+ & Safari: We can't detect a file leaving the document if the Explorer window housing the file
    //                   overlays the browser window.
    // * IE10+: If the file is dragged out of the window too quickly, IE does not set the expected values of the
    //          event's X & Y properties.
    function leavingDocumentOut(e) {
        if (qq.firefox()) {
            return !e.relatedTarget;
        }

        if (qq.safari()) {
            return e.x < 0 || e.y < 0;
        }

        return e.x === 0 && e.y === 0;
    }

    function setupDragDrop() {
        var dropZones = options.dropZoneElements,

            maybeHideDropZones = function() {
                setTimeout(function() {
                    qq.each(dropZones, function(idx, dropZone) {
                        if ( qq(dropZone).hasAttribute(HIDE_BEFORE_ENTER_ATTR) ) { qq(dropZone).hide(); }
                        qq(dropZone).removeClass(options.classes.dropActive);
                    });
                }, 10);
            };

        qq.each(dropZones, function(idx, dropZone) {
            var uploadDropZone = setupDropzone(dropZone);

            // IE <= 9 does not support the File API used for drag+drop uploads
            if (dropZones.length && qq.supportedFeatures.fileDrop) {
                disposeSupport.attach(document, "dragenter", function(e) {
                    if (!uploadDropZone.dropDisabled() && isFileDrag(e)) {
                        qq.each(dropZones, function(idx, dropZone) {
                            // We can't apply styles to non-HTMLElements, since they lack the `style` property.
                            // Also, if the drop zone isn't initially hidden, let's not mess with `style.display`.
                            if (dropZone instanceof HTMLElement && qq(dropZone).hasAttribute(HIDE_BEFORE_ENTER_ATTR)) {
                                qq(dropZone).css({display: "block"});
                            }
                        });
                    }
                });
            }
        });

        disposeSupport.attach(document, "dragleave", function(e) {
            if (leavingDocumentOut(e)) {
                maybeHideDropZones();
            }
        });

        // Just in case we were not able to detect when a dragged file has left the document,
        // hide all relevant drop zones the next time the mouse enters the document.
        // Note that mouse events such as this one are not fired during drag operations.
        disposeSupport.attach(qq(document).children()[0], "mouseenter", function(e) {
            maybeHideDropZones();
        });

        disposeSupport.attach(document, "drop", function(e) {
            e.preventDefault();
            maybeHideDropZones();
        });

        disposeSupport.attach(document, HIDE_ZONES_EVENT_NAME, maybeHideDropZones);
    }

    setupDragDrop();

    qq.extend(this, {
        setupExtraDropzone: function(element) {
            options.dropZoneElements.push(element);
            setupDropzone(element);
        },

        removeDropzone: function(element) {
            var i,
                dzs = options.dropZoneElements;

            for (i in dzs) {
                if (dzs[i] === element) {
                    return dzs.splice(i, 1);
                }
            }
        },

        dispose: function() {
            disposeSupport.dispose();
            qq.each(uploadDropZones, function(idx, dropZone) {
                dropZone.dispose();
            });
        }
    });
};

qq.DragAndDrop.callbacks = function() {

    return {
        processingDroppedFiles: function() {},
        processingDroppedFilesComplete: function(files, targetEl) {},
        dropError: function(code, errorSpecifics) {
            qq.log("Drag & drop error code '" + code + " with these specifics: '" + errorSpecifics + "'", "error");
        },
        dropLog: function(message, level) {
            qq.log(message, level);
        }
    };
};

qq.UploadDropZone = function(o) {

    var disposeSupport = new qq.DisposeSupport(),
        options, element, preventDrop, dropOutsideDisabled;

    options = {
        element: null,
        onEnter: function(e) {},
        onLeave: function(e) {},
        // is not fired when leaving element by hovering descendants
        onLeaveNotDescendants: function(e) {},
        onDrop: function(e) {}
    };

    qq.extend(options, o);
    element = options.element;

    function dragoverShouldBeCanceled() {
        return qq.safari() || (qq.firefox() && qq.windows());
    }

    function disableDropOutside(e) {
        // run only once for all instances
        if (!dropOutsideDisabled) {

            // for these cases we need to catch onDrop to reset dropArea
            if (dragoverShouldBeCanceled) {
                disposeSupport.attach(document, "dragover", function(e) {
                    e.preventDefault();
                });
            } else {
                disposeSupport.attach(document, "dragover", function(e) {
                    if (e.dataTransfer) {
                        e.dataTransfer.dropEffect = "none";
                        e.preventDefault();
                    }
                });
            }

            dropOutsideDisabled = true;
        }
    }

    function isValidFileDrag(e) {
        // e.dataTransfer currently causing IE errors
        // IE9 does NOT support file API, so drag-and-drop is not possible
        if (!qq.supportedFeatures.fileDrop) {
            return false;
        }

        var effectTest, dt = e.dataTransfer,
        // do not check dt.types.contains in webkit, because it crashes safari 4
        isSafari = qq.safari();

        // dt.effectAllowed is none in Safari 5
        // dt.types.contains check is for firefox

        // dt.effectAllowed crashes IE 11 & 10 when files have been dragged from
        // the filesystem
        effectTest = ( qq.ie() && qq.supportedFeatures.fileDrop ) ? true : dt.effectAllowed !== "none";
        return dt && effectTest && (dt.files || (!isSafari && dt.types.contains && dt.types.contains("Files")));
    }

    function isOrSetDropDisabled(isDisabled) {
        if (isDisabled !== undefined) {
            preventDrop = isDisabled;
        }
        return preventDrop;
    }

    function triggerHidezonesEvent() {
        var hideZonesEvent;

        function triggerUsingOldApi() {
            hideZonesEvent = document.createEvent("Event");
            hideZonesEvent.initEvent(options.HIDE_ZONES_EVENT_NAME, true, true);
        }

        if (window.CustomEvent) {
            try {
                hideZonesEvent = new CustomEvent(options.HIDE_ZONES_EVENT_NAME);
            }
            catch (err) {
                triggerUsingOldApi();
            }
        }
        else {
            triggerUsingOldApi();
        }

        document.dispatchEvent(hideZonesEvent);
    }

    function attachEvents() {
        disposeSupport.attach(element, "dragover", function(e) {
            if (!isValidFileDrag(e)) {
                return;
            }

            // dt.effectAllowed crashes IE 11 & 10 when files have been dragged from
            // the filesystem
            var effect = ( qq.ie() && qq.supportedFeatures.fileDrop ) ? null : e.dataTransfer.effectAllowed;
            if (effect === "move" || effect === "linkMove") {
                e.dataTransfer.dropEffect = "move"; // for FF (only move allowed)
            } else {
                e.dataTransfer.dropEffect = "copy"; // for Chrome
            }

            e.stopPropagation();
            e.preventDefault();
        });

        disposeSupport.attach(element, "dragenter", function(e) {
            if (!isOrSetDropDisabled()) {
                if (!isValidFileDrag(e)) {
                    return;
                }
                options.onEnter(e);
            }
        });

        disposeSupport.attach(element, "dragleave", function(e) {
            if (!isValidFileDrag(e)) {
                return;
            }

            options.onLeave(e);

            var relatedTarget = document.elementFromPoint(e.clientX, e.clientY);
            // do not fire when moving a mouse over a descendant
            if (qq(this).contains(relatedTarget)) {
                return;
            }

            options.onLeaveNotDescendants(e);
        });

        disposeSupport.attach(element, "drop", function(e) {
            if (!isOrSetDropDisabled()) {
                if (!isValidFileDrag(e)) {
                    return;
                }

                e.preventDefault();
                e.stopPropagation();
                options.onDrop(e);

                triggerHidezonesEvent();
            }
        });
    }

    disableDropOutside();
    attachEvents();

    qq.extend(this, {
        dropDisabled: function(isDisabled) {
            return isOrSetDropDisabled(isDisabled);
        },

        dispose: function() {
            disposeSupport.dispose();
        },

        getElement: function() {
            return element;
        }
    });
};

/*globals qq, XMLHttpRequest*/
qq.DeleteFileAjaxRequester = function(o) {

    var requester,
        options = {
            method: "DELETE",
            uuidParamName: "qquuid",
            endpointStore: {},
            maxConnections: 3,
            customHeaders: function(id) {return {};},
            paramsStore: {},
            cors: {
                expected: false,
                sendCredentials: false
            },
            log: function(str, level) {},
            onDelete: function(id) {},
            onDeleteComplete: function(id, xhrOrXdr, isError) {}
        };

    qq.extend(options, o);

    function getMandatedParams() {
        if (options.method.toUpperCase() === "POST") {
            return {
                _method: "DELETE"
            };
        }

        return {};
    }

    requester = qq.extend(this, new qq.AjaxRequester({
        acceptHeader: "application/json",
        validMethods: ["POST", "DELETE"],
        method: options.method,
        endpointStore: options.endpointStore,
        paramsStore: options.paramsStore,
        mandatedParams: getMandatedParams(),
        maxConnections: options.maxConnections,
        customHeaders: function(id) {
            return options.customHeaders.get(id);
        },
        log: options.log,
        onSend: options.onDelete,
        onComplete: options.onDeleteComplete,
        cors: options.cors
    }));

    qq.extend(this, {
        sendDelete: function(id, uuid, additionalMandatedParams) {
            var additionalOptions = additionalMandatedParams || {};

            options.log("Submitting delete file request for " + id);

            if (options.method === "DELETE") {
                requester.initTransport(id)
                    .withPath(uuid)
                    .withParams(additionalOptions)
                    .send();
            }
            else {
                additionalOptions[options.uuidParamName] = uuid;
                requester.initTransport(id)
                    .withParams(additionalOptions)
                    .send();
            }
        }
    });
};

/*global qq, define */
/*jshint strict:false,bitwise:false,nonew:false,asi:true,-W064,-W116,-W089 */
/**
 * Mega pixel image rendering library for iOS6+
 *
 * Fixes iOS6+'s image file rendering issue for large size image (over mega-pixel),
 * which causes unexpected subsampling when drawing it in canvas.
 * By using this library, you can safely render the image with proper stretching.
 *
 * Copyright (c) 2012 Shinichi Tomita <shinichi.tomita@gmail.com>
 * Released under the MIT license
 *
 * Heavily modified by Widen for Fine Uploader
 */
(function() {

    /**
     * Detect subsampling in loaded image.
     * In iOS, larger images than 2M pixels may be subsampled in rendering.
     */
    function detectSubsampling(img) {
        var iw = img.naturalWidth,
            ih = img.naturalHeight,
            canvas = document.createElement("canvas"),
            ctx;

        if (iw * ih > 1024 * 1024) { // subsampling may happen over megapixel image
            canvas.width = canvas.height = 1;
            ctx = canvas.getContext("2d");
            ctx.drawImage(img, -iw + 1, 0);
            // subsampled image becomes half smaller in rendering size.
            // check alpha channel value to confirm image is covering edge pixel or not.
            // if alpha value is 0 image is not covering, hence subsampled.
            return ctx.getImageData(0, 0, 1, 1).data[3] === 0;
        } else {
            return false;
        }
    }

    /**
     * Detecting vertical squash in loaded image.
     * Fixes a bug which squash image vertically while drawing into canvas for some images.
     */
    function detectVerticalSquash(img, iw, ih) {
        var canvas = document.createElement("canvas"),
            sy = 0,
            ey = ih,
            py = ih,
            ctx, data, alpha, ratio;

        canvas.width = 1;
        canvas.height = ih;
        ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        data = ctx.getImageData(0, 0, 1, ih).data;

        // search image edge pixel position in case it is squashed vertically.
        while (py > sy) {
            alpha = data[(py - 1) * 4 + 3];
            if (alpha === 0) {
                ey = py;
            } else {
                sy = py;
            }
            py = (ey + sy) >> 1;
        }

        ratio = (py / ih);
        return (ratio === 0) ? 1 : ratio;
    }

    /**
     * Rendering image element (with resizing) and get its data URL
     */
    function renderImageToDataURL(img, blob, options, doSquash) {
        var canvas = document.createElement("canvas"),
            mime = options.mime || "image/jpeg",
            promise = new qq.Promise();

        renderImageToCanvas(img, blob, canvas, options, doSquash)
            .then(function() {
                promise.success(
                    canvas.toDataURL(mime, options.quality || 0.8)
                );
            })

        return promise;
    }

    function maybeCalculateDownsampledDimensions(spec) {
        var maxPixels = 5241000; //iOS specific value

        if (!qq.ios()) {
            throw new qq.Error("Downsampled dimensions can only be reliably calculated for iOS!");
        }

        if (spec.origHeight * spec.origWidth > maxPixels) {
            return {
                newHeight: Math.round(Math.sqrt(maxPixels * (spec.origHeight / spec.origWidth))),
                newWidth: Math.round(Math.sqrt(maxPixels * (spec.origWidth / spec.origHeight)))
            }
        }
    }

    /**
     * Rendering image element (with resizing) into the canvas element
     */
    function renderImageToCanvas(img, blob, canvas, options, doSquash) {
        var iw = img.naturalWidth,
            ih = img.naturalHeight,
            width = options.width,
            height = options.height,
            ctx = canvas.getContext("2d"),
            promise = new qq.Promise(),
            modifiedDimensions;

        ctx.save();

        if (options.resize) {
            return renderImageToCanvasWithCustomResizer({
                blob: blob,
                canvas: canvas,
                image: img,
                imageHeight: ih,
                imageWidth: iw,
                orientation: options.orientation,
                resize: options.resize,
                targetHeight: height,
                targetWidth: width
            })
        }

        if (!qq.supportedFeatures.unlimitedScaledImageSize) {
            modifiedDimensions = maybeCalculateDownsampledDimensions({
                origWidth: width,
                origHeight: height
            });

            if (modifiedDimensions) {
                qq.log(qq.format("Had to reduce dimensions due to device limitations from {}w / {}h to {}w / {}h",
                    width, height, modifiedDimensions.newWidth, modifiedDimensions.newHeight),
                    "warn");

                width = modifiedDimensions.newWidth;
                height = modifiedDimensions.newHeight;
            }
        }

        transformCoordinate(canvas, width, height, options.orientation);

        // Fine Uploader specific: Save some CPU cycles if not using iOS
        // Assumption: This logic is only needed to overcome iOS image sampling issues
        if (qq.ios()) {
            (function() {
                if (detectSubsampling(img)) {
                    iw /= 2;
                    ih /= 2;
                }

                var d = 1024, // size of tiling canvas
                    tmpCanvas = document.createElement("canvas"),
                    vertSquashRatio = doSquash ? detectVerticalSquash(img, iw, ih) : 1,
                    dw = Math.ceil(d * width / iw),
                    dh = Math.ceil(d * height / ih / vertSquashRatio),
                    sy = 0,
                    dy = 0,
                    tmpCtx, sx, dx;

                tmpCanvas.width = tmpCanvas.height = d;
                tmpCtx = tmpCanvas.getContext("2d");

                while (sy < ih) {
                    sx = 0;
                    dx = 0;
                    while (sx < iw) {
                        tmpCtx.clearRect(0, 0, d, d);
                        tmpCtx.drawImage(img, -sx, -sy);
                        ctx.drawImage(tmpCanvas, 0, 0, d, d, dx, dy, dw, dh);
                        sx += d;
                        dx += dw;
                    }
                    sy += d;
                    dy += dh;
                }
                ctx.restore();
                tmpCanvas = tmpCtx = null;
            }())
        }
        else {
            ctx.drawImage(img, 0, 0, width, height);
        }

        if ( canvas.qqImageRendered ) { canvas.qqImageRendered(); }
        promise.success();

        return promise;
    }

    function renderImageToCanvasWithCustomResizer(resizeInfo) {
        var blob = resizeInfo.blob,
            image = resizeInfo.image,
            imageHeight = resizeInfo.imageHeight,
            imageWidth = resizeInfo.imageWidth,
            orientation = resizeInfo.orientation,
            promise = new qq.Promise(),
            resize = resizeInfo.resize,
            sourceCanvas = document.createElement("canvas"),
            sourceCanvasContext = sourceCanvas.getContext("2d"),
            targetCanvas = resizeInfo.canvas,
            targetHeight = resizeInfo.targetHeight,
            targetWidth = resizeInfo.targetWidth;

        transformCoordinate(sourceCanvas, imageWidth, imageHeight, orientation);

        targetCanvas.height = targetHeight;
        targetCanvas.width = targetWidth;

        sourceCanvasContext.drawImage(image, 0, 0);

        resize({
            blob: blob,
            height: targetHeight,
            image: image,
            sourceCanvas: sourceCanvas,
            targetCanvas: targetCanvas,
            width: targetWidth
        })
            .then(
                function success() {
                    if ( targetCanvas.qqImageRendered ) { targetCanvas.qqImageRendered(); }
                    promise.success();
                },
                promise.failure
            )

        return promise;
    }

    /**
     * Transform canvas coordination according to specified frame size and orientation
     * Orientation value is from EXIF tag
     */
    function transformCoordinate(canvas, width, height, orientation) {
        switch (orientation) {
            case 5:
            case 6:
            case 7:
            case 8:
                canvas.width = height;
                canvas.height = width;
                break;
            default:
                canvas.width = width;
                canvas.height = height;
        }
        var ctx = canvas.getContext("2d");
        switch (orientation) {
            case 2:
                // horizontal flip
                ctx.translate(width, 0);
                ctx.scale(-1, 1);
                break;
            case 3:
                // 180 rotate left
                ctx.translate(width, height);
                ctx.rotate(Math.PI);
                break;
            case 4:
                // vertical flip
                ctx.translate(0, height);
                ctx.scale(1, -1);
                break;
            case 5:
                // vertical flip + 90 rotate right
                ctx.rotate(0.5 * Math.PI);
                ctx.scale(1, -1);
                break;
            case 6:
                // 90 rotate right
                ctx.rotate(0.5 * Math.PI);
                ctx.translate(0, -height);
                break;
            case 7:
                // horizontal flip + 90 rotate right
                ctx.rotate(0.5 * Math.PI);
                ctx.translate(width, -height);
                ctx.scale(-1, 1);
                break;
            case 8:
                // 90 rotate left
                ctx.rotate(-0.5 * Math.PI);
                ctx.translate(-width, 0);
                break;
            default:
                break;
        }
    }

    /**
     * MegaPixImage class
     */
    function MegaPixImage(srcImage, errorCallback) {
        var self = this;

        if (window.Blob && srcImage instanceof Blob) {
            (function() {
                var img = new Image(),
                    URL = window.URL && window.URL.createObjectURL ? window.URL :
                        window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;
                if (!URL) { throw Error("No createObjectURL function found to create blob url"); }
                img.src = URL.createObjectURL(srcImage);
                self.blob = srcImage;
                srcImage = img;
            }());
        }
        if (!srcImage.naturalWidth && !srcImage.naturalHeight) {
            srcImage.onload = function() {
                var listeners = self.imageLoadListeners;
                if (listeners) {
                    self.imageLoadListeners = null;
                    // IE11 doesn't reliably report actual image dimensions immediately after onload for small files,
                    // so let's push this to the end of the UI thread queue.
                    setTimeout(function() {
                        for (var i = 0, len = listeners.length; i < len; i++) {
                            listeners[i]();
                        }
                    }, 0);
                }
            };
            srcImage.onerror = errorCallback;
            this.imageLoadListeners = [];
        }
        this.srcImage = srcImage;
    }

    /**
     * Rendering megapix image into specified target element
     */
    MegaPixImage.prototype.render = function(target, options) {
        options = options || {};

        var self = this,
            imgWidth = this.srcImage.naturalWidth,
            imgHeight = this.srcImage.naturalHeight,
            width = options.width,
            height = options.height,
            maxWidth = options.maxWidth,
            maxHeight = options.maxHeight,
            doSquash = !this.blob || this.blob.type === "image/jpeg",
            tagName = target.tagName.toLowerCase(),
            opt;

        if (this.imageLoadListeners) {
            this.imageLoadListeners.push(function() { self.render(target, options) });
            return;
        }

        if (width && !height) {
            height = (imgHeight * width / imgWidth) << 0;
        } else if (height && !width) {
            width = (imgWidth * height / imgHeight) << 0;
        } else {
            width = imgWidth;
            height = imgHeight;
        }
        if (maxWidth && width > maxWidth) {
            width = maxWidth;
            height = (imgHeight * width / imgWidth) << 0;
        }
        if (maxHeight && height > maxHeight) {
            height = maxHeight;
            width = (imgWidth * height / imgHeight) << 0;
        }

        opt = { width: width, height: height };
        qq.each(options, function(optionsKey, optionsValue) {
            opt[optionsKey] = optionsValue;
        });

        if (tagName === "img") {
            (function() {
                var oldTargetSrc = target.src;
                renderImageToDataURL(self.srcImage, self.blob, opt, doSquash)
                    .then(function(dataUri) {
                        target.src = dataUri;
                        if ( oldTargetSrc === target.src ) { target.onload(); }
                    });
            }())
        } else if (tagName === "canvas") {
            renderImageToCanvas(this.srcImage, this.blob, target, opt, doSquash);
        }
        if (typeof this.onrender === "function") {
            this.onrender(target);
        }
    };

    qq.MegaPixImage = MegaPixImage;
})();

/*globals qq */
/**
 * Draws a thumbnail of a Blob/File/URL onto an <img> or <canvas>.
 *
 * @constructor
 */
qq.ImageGenerator = function(log) {

    function isImg(el) {
        return el.tagName.toLowerCase() === "img";
    }

    function isCanvas(el) {
        return el.tagName.toLowerCase() === "canvas";
    }

    function isImgCorsSupported() {
        return new Image().crossOrigin !== undefined;
    }

    function isCanvasSupported() {
        var canvas = document.createElement("canvas");

        return canvas.getContext && canvas.getContext("2d");
    }

    // This is only meant to determine the MIME type of a renderable image file.
    // It is used to ensure images drawn from a URL that have transparent backgrounds
    // are rendered correctly, among other things.
    function determineMimeOfFileName(nameWithPath) {
        /*jshint -W015 */
        var pathSegments = nameWithPath.split("/"),
            name = pathSegments[pathSegments.length - 1],
            extension = qq.getExtension(name);

        extension = extension && extension.toLowerCase();

        switch (extension) {
            case "jpeg":
            case "jpg":
                return "image/jpeg";
            case "png":
                return "image/png";
            case "bmp":
                return "image/bmp";
            case "gif":
                return "image/gif";
            case "tiff":
            case "tif":
                return "image/tiff";
        }
    }

    // This will likely not work correctly in IE8 and older.
    // It's only used as part of a formula to determine
    // if a canvas can be used to scale a server-hosted thumbnail.
    // If canvas isn't supported by the UA (IE8 and older)
    // this method should not even be called.
    function isCrossOrigin(url) {
        var targetAnchor = document.createElement("a"),
            targetProtocol, targetHostname, targetPort;

        targetAnchor.href = url;

        targetProtocol = targetAnchor.protocol;
        targetPort = targetAnchor.port;
        targetHostname = targetAnchor.hostname;

        if (targetProtocol.toLowerCase() !== window.location.protocol.toLowerCase()) {
            return true;
        }

        if (targetHostname.toLowerCase() !== window.location.hostname.toLowerCase()) {
            return true;
        }

        // IE doesn't take ports into consideration when determining if two endpoints are same origin.
        if (targetPort !== window.location.port && !qq.ie()) {
            return true;
        }

        return false;
    }

    function registerImgLoadListeners(img, promise) {
        img.onload = function() {
            img.onload = null;
            img.onerror = null;
            promise.success(img);
        };

        img.onerror = function() {
            img.onload = null;
            img.onerror = null;
            log("Problem drawing thumbnail!", "error");
            promise.failure(img, "Problem drawing thumbnail!");
        };
    }

    function registerCanvasDrawImageListener(canvas, promise) {
        // The image is drawn on the canvas by a third-party library,
        // and we want to know when this is completed.  Since the library
        // may invoke drawImage many times in a loop, we need to be called
        // back when the image is fully rendered.  So, we are expecting the
        // code that draws this image to follow a convention that involves a
        // function attached to the canvas instance be invoked when it is done.
        canvas.qqImageRendered = function() {
            promise.success(canvas);
        };
    }

    // Fulfills a `qq.Promise` when an image has been drawn onto the target,
    // whether that is a <canvas> or an <img>.  The attempt is considered a
    // failure if the target is not an <img> or a <canvas>, or if the drawing
    // attempt was not successful.
    function registerThumbnailRenderedListener(imgOrCanvas, promise) {
        var registered = isImg(imgOrCanvas) || isCanvas(imgOrCanvas);

        if (isImg(imgOrCanvas)) {
            registerImgLoadListeners(imgOrCanvas, promise);
        }
        else if (isCanvas(imgOrCanvas)) {
            registerCanvasDrawImageListener(imgOrCanvas, promise);
        }
        else {
            promise.failure(imgOrCanvas);
            log(qq.format("Element container of type {} is not supported!", imgOrCanvas.tagName), "error");
        }

        return registered;
    }

    // Draw a preview iff the current UA can natively display it.
    // Also rotate the image if necessary.
    function draw(fileOrBlob, container, options) {
        var drawPreview = new qq.Promise(),
            identifier = new qq.Identify(fileOrBlob, log),
            maxSize = options.maxSize,
            // jshint eqnull:true
            orient = ( 'undefined' === typeof options.orient || options.orient === null ) ? true : options.orient,
            megapixErrorHandler = function() {
                container.onerror = null;
                container.onload = null;
                log("Could not render preview, file may be too large!", "error");
                drawPreview.failure(container, "Browser cannot render image!");
            };

        identifier.isPreviewable().then(
            function(mime) {
                // If options explicitly specify that Orientation is not desired,
                // replace the orient task with a dummy promise that "succeeds" immediately.
                var dummyExif = {
                        parse: function() {
                            return new qq.Promise().success();
                        }
                    },
                    exif = orient ? new qq.Exif(fileOrBlob, log) : dummyExif,
                    mpImg = new qq.MegaPixImage(fileOrBlob, megapixErrorHandler);

                if (registerThumbnailRenderedListener(container, drawPreview)) {
                    exif.parse().then(
                        function(exif) {
                            var orientation = exif && exif.Orientation;

                            mpImg.render(container, {
                                maxWidth: maxSize,
                                maxHeight: maxSize,
                                orientation: orientation,
                                mime: mime,
                                resize: options.customResizeFunction
                            });
                        },

                        function(failureMsg) {
                            log(qq.format("EXIF data could not be parsed ({}).  Assuming orientation = 1.", failureMsg));

                            mpImg.render(container, {
                                maxWidth: maxSize,
                                maxHeight: maxSize,
                                mime: mime,
                                resize: options.customResizeFunction
                            });
                        }
                    );
                }
            },

            function() {
                log("Not previewable");
                drawPreview.failure(container, "Not previewable");
            }
        );

        return drawPreview;
    }

    function drawOnCanvasOrImgFromUrl(url, canvasOrImg, draw, maxSize, customResizeFunction) {
        var tempImg = new Image(),
            tempImgRender = new qq.Promise();

        registerThumbnailRenderedListener(tempImg, tempImgRender);

        if (isCrossOrigin(url)) {
            tempImg.crossOrigin = "anonymous";
        }

        tempImg.src = url;

        tempImgRender.then(
            function rendered() {
                registerThumbnailRenderedListener(canvasOrImg, draw);

                var mpImg = new qq.MegaPixImage(tempImg);
                mpImg.render(canvasOrImg, {
                    maxWidth: maxSize,
                    maxHeight: maxSize,
                    mime: determineMimeOfFileName(url),
                    resize: customResizeFunction
                });
            },

            draw.failure
        );
    }

    function drawOnImgFromUrlWithCssScaling(url, img, draw, maxSize) {
        registerThumbnailRenderedListener(img, draw);
        // NOTE: The fact that maxWidth/height is set on the thumbnail for scaled images
        // that must drop back to CSS is known and exploited by the templating module.
        // In this module, we pre-render "waiting" thumbs for all files immediately after they
        // are submitted, and we must be sure to pass any style associated with the "waiting" preview.
        qq(img).css({
            maxWidth: maxSize + "px",
            maxHeight: maxSize + "px"
        });

        img.src = url;
    }

    // Draw a (server-hosted) thumbnail given a URL.
    // This will optionally scale the thumbnail as well.
    // It attempts to use <canvas> to scale, but will fall back
    // to max-width and max-height style properties if the UA
    // doesn't support canvas or if the images is cross-domain and
    // the UA doesn't support the crossorigin attribute on img tags,
    // which is required to scale a cross-origin image using <canvas> &
    // then export it back to an <img>.
    function drawFromUrl(url, container, options) {
        var draw = new qq.Promise(),
            scale = options.scale,
            maxSize = scale ? options.maxSize : null;

        // container is an img, scaling needed
        if (scale && isImg(container)) {
            // Iff canvas is available in this UA, try to use it for scaling.
            // Otherwise, fall back to CSS scaling
            if (isCanvasSupported()) {
                // Attempt to use <canvas> for image scaling,
                // but we must fall back to scaling via CSS/styles
                // if this is a cross-origin image and the UA doesn't support <img> CORS.
                if (isCrossOrigin(url) && !isImgCorsSupported()) {
                    drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);
                }
                else {
                    drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);
                }
            }
            else {
                drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);
            }
        }
        // container is a canvas, scaling optional
        else if (isCanvas(container)) {
            drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);
        }
        // container is an img & no scaling: just set the src attr to the passed url
        else if (registerThumbnailRenderedListener(container, draw)) {
            container.src = url;
        }

        return draw;
    }

    qq.extend(this, {
        /**
         * Generate a thumbnail.  Depending on the arguments, this may either result in
         * a client-side rendering of an image (if a `Blob` is supplied) or a server-generated
         * image that may optionally be scaled client-side using <canvas> or CSS/styles (as a fallback).
         *
         * @param fileBlobOrUrl a `File`, `Blob`, or a URL pointing to the image
         * @param container <img> or <canvas> to contain the preview
         * @param options possible properties include `maxSize` (int), `orient` (bool - default true), resize` (bool - default true), and `customResizeFunction`.
         * @returns qq.Promise fulfilled when the preview has been drawn, or the attempt has failed
         */
        generate: function(fileBlobOrUrl, container, options) {
            if (qq.isString(fileBlobOrUrl)) {
                log("Attempting to update thumbnail based on server response.");
                return drawFromUrl(fileBlobOrUrl, container, options || {});
            }
            else {
                log("Attempting to draw client-side image preview.");
                return draw(fileBlobOrUrl, container, options || {});
            }
        }
    });

};

/*globals qq */
/**
 * EXIF image data parser.  Currently only parses the Orientation tag value,
 * but this may be expanded to other tags in the future.
 *
 * @param fileOrBlob Attempt to parse EXIF data in this `Blob`
 * @constructor
 */
qq.Exif = function(fileOrBlob, log) {

    // Orientation is the only tag parsed here at this time.
    var TAG_IDS = [274],
        TAG_INFO = {
            274: {
                name: "Orientation",
                bytes: 2
            }
        };

    // Convert a little endian (hex string) to big endian (decimal).
    function parseLittleEndian(hex) {
        var result = 0,
            pow = 0;

        while (hex.length > 0) {
            result += parseInt(hex.substring(0, 2), 16) * Math.pow(2, pow);
            hex = hex.substring(2, hex.length);
            pow += 8;
        }

        return result;
    }

    // Find the byte offset, of Application Segment 1 (EXIF).
    // External callers need not supply any arguments.
    function seekToApp1(offset, promise) {
        var theOffset = offset,
            thePromise = promise;
        if (theOffset === undefined) {
            theOffset = 2;
            thePromise = new qq.Promise();
        }

        qq.readBlobToHex(fileOrBlob, theOffset, 4).then(function(hex) {
            var match = /^ffe([0-9])/.exec(hex),
                segmentLength;

            if (match) {
                if (match[1] !== "1") {
                    segmentLength = parseInt(hex.slice(4, 8), 16);
                    seekToApp1(theOffset + segmentLength + 2, thePromise);
                }
                else {
                    thePromise.success(theOffset);
                }
            }
            else {
                thePromise.failure("No EXIF header to be found!");
            }
        });

        return thePromise;
    }

    // Find the byte offset of Application Segment 1 (EXIF) for valid JPEGs only.
    function getApp1Offset() {
        var promise = new qq.Promise();

        qq.readBlobToHex(fileOrBlob, 0, 6).then(function(hex) {
            if (hex.indexOf("ffd8") !== 0) {
                promise.failure("Not a valid JPEG!");
            }
            else {
                seekToApp1().then(function(offset) {
                    promise.success(offset);
                },
                function(error) {
                    promise.failure(error);
                });
            }
        });

        return promise;
    }

    // Determine the byte ordering of the EXIF header.
    function isLittleEndian(app1Start) {
        var promise = new qq.Promise();

        qq.readBlobToHex(fileOrBlob, app1Start + 10, 2).then(function(hex) {
            promise.success(hex === "4949");
        });

        return promise;
    }

    // Determine the number of directory entries in the EXIF header.
    function getDirEntryCount(app1Start, littleEndian) {
        var promise = new qq.Promise();

        qq.readBlobToHex(fileOrBlob, app1Start + 18, 2).then(function(hex) {
            if (littleEndian) {
                return promise.success(parseLittleEndian(hex));
            }
            else {
                promise.success(parseInt(hex, 16));
            }
        });

        return promise;
    }

    // Get the IFD portion of the EXIF header as a hex string.
    function getIfd(app1Start, dirEntries) {
        var offset = app1Start + 20,
            bytes = dirEntries * 12;

        return qq.readBlobToHex(fileOrBlob, offset, bytes);
    }

    // Obtain an array of all directory entries (as hex strings) in the EXIF header.
    function getDirEntries(ifdHex) {
        var entries = [],
            offset = 0;

        while (offset + 24 <= ifdHex.length) {
            entries.push(ifdHex.slice(offset, offset + 24));
            offset += 24;
        }

        return entries;
    }

    // Obtain values for all relevant tags and return them.
    function getTagValues(littleEndian, dirEntries) {
        var TAG_VAL_OFFSET = 16,
            tagsToFind = qq.extend([], TAG_IDS),
            vals = {};

        qq.each(dirEntries, function(idx, entry) {
            var idHex = entry.slice(0, 4),
                id = littleEndian ? parseLittleEndian(idHex) : parseInt(idHex, 16),
                tagsToFindIdx = tagsToFind.indexOf(id),
                tagValHex, tagName, tagValLength;

            if (tagsToFindIdx >= 0) {
                tagName = TAG_INFO[id].name;
                tagValLength = TAG_INFO[id].bytes;
                tagValHex = entry.slice(TAG_VAL_OFFSET, TAG_VAL_OFFSET + (tagValLength * 2));
                vals[tagName] = littleEndian ? parseLittleEndian(tagValHex) : parseInt(tagValHex, 16);

                tagsToFind.splice(tagsToFindIdx, 1);
            }

            if (tagsToFind.length === 0) {
                return false;
            }
        });

        return vals;
    }

    qq.extend(this, {
        /**
         * Attempt to parse the EXIF header for the `Blob` associated with this instance.
         *
         * @returns {qq.Promise} To be fulfilled when the parsing is complete.
         * If successful, the parsed EXIF header as an object will be included.
         */
        parse: function() {
            var parser = new qq.Promise(),
                onParseFailure = function(message) {
                    log(qq.format("EXIF header parse failed: '{}' ", message));
                    parser.failure(message);
                };

            getApp1Offset().then(function(app1Offset) {
                log(qq.format("Moving forward with EXIF header parsing for '{}'", fileOrBlob.name === undefined ? "blob" : fileOrBlob.name));

                isLittleEndian(app1Offset).then(function(littleEndian) {

                    log(qq.format("EXIF Byte order is {} endian", littleEndian ? "little" : "big"));

                    getDirEntryCount(app1Offset, littleEndian).then(function(dirEntryCount) {

                        log(qq.format("Found {} APP1 directory entries", dirEntryCount));

                        getIfd(app1Offset, dirEntryCount).then(function(ifdHex) {
                            var dirEntries = getDirEntries(ifdHex),
                                tagValues = getTagValues(littleEndian, dirEntries);

                            log("Successfully parsed some EXIF tags");

                            parser.success(tagValues);
                        }, onParseFailure);
                    }, onParseFailure);
                }, onParseFailure);
            }, onParseFailure);

            return parser;
        }
    });

};

/*globals qq */
qq.Identify = function(fileOrBlob, log) {

    function isIdentifiable(magicBytes, questionableBytes) {
        var identifiable = false,
            magicBytesEntries = [].concat(magicBytes);

        qq.each(magicBytesEntries, function(idx, magicBytesArrayEntry) {
            if (questionableBytes.indexOf(magicBytesArrayEntry) === 0) {
                identifiable = true;
                return false;
            }
        });

        return identifiable;
    }

    qq.extend(this, {
        /**
         * Determines if a Blob can be displayed natively in the current browser.  This is done by reading magic
         * bytes in the beginning of the file, so this is an asynchronous operation.  Before we attempt to read the
         * file, we will examine the blob's type attribute to save CPU cycles.
         *
         * @returns {qq.Promise} Promise that is fulfilled when identification is complete.
         * If successful, the MIME string is passed to the success handler.
         */
        isPreviewable: function() {
            var self = this,
                identifier = new qq.Promise(),
                previewable = false,
                name = fileOrBlob.name === undefined ? "blob" : fileOrBlob.name;

            log(qq.format("Attempting to determine if {} can be rendered in this browser", name));

            log("First pass: check type attribute of blob object.");

            if (this.isPreviewableSync()) {
                log("Second pass: check for magic bytes in file header.");

                qq.readBlobToHex(fileOrBlob, 0, 4).then(function(hex) {
                    qq.each(self.PREVIEWABLE_MIME_TYPES, function(mime, bytes) {
                        if (isIdentifiable(bytes, hex)) {
                            // Safari is the only supported browser that can deal with TIFFs natively,
                            // so, if this is a TIFF and the UA isn't Safari, declare this file "non-previewable".
                            if (mime !== "image/tiff" || qq.supportedFeatures.tiffPreviews) {
                                previewable = true;
                                identifier.success(mime);
                            }

                            return false;
                        }
                    });

                    log(qq.format("'{}' is {} able to be rendered in this browser", name, previewable ? "" : "NOT"));

                    if (!previewable) {
                        identifier.failure();
                    }
                },
                function() {
                    log("Error reading file w/ name '" + name + "'.  Not able to be rendered in this browser.");
                    identifier.failure();
                });
            }
            else {
                identifier.failure();
            }

            return identifier;
        },

        /**
         * Determines if a Blob can be displayed natively in the current browser.  This is done by checking the
         * blob's type attribute.  This is a synchronous operation, useful for situations where an asynchronous operation
         * would be challenging to support.  Note that the blob's type property is not as accurate as reading the
         * file's magic bytes.
         *
         * @returns {Boolean} true if the blob can be rendered in the current browser
         */
        isPreviewableSync: function() {
            var fileMime = fileOrBlob.type,
                // Assumption: This will only ever be executed in browsers that support `Object.keys`.
                isRecognizedImage = qq.indexOf(Object.keys(this.PREVIEWABLE_MIME_TYPES), fileMime) >= 0,
                previewable = false,
                name = fileOrBlob.name === undefined ? "blob" : fileOrBlob.name;

            if (isRecognizedImage) {
                if (fileMime === "image/tiff") {
                    previewable = qq.supportedFeatures.tiffPreviews;
                }
                else {
                    previewable = true;
                }
            }

            if ( !previewable ) { log(name + " is not previewable in this browser per the blob's type attr"); }

            return previewable;
        }
    });
};

qq.Identify.prototype.PREVIEWABLE_MIME_TYPES = {
    "image/jpeg": "ffd8ff",
    "image/gif": "474946",
    "image/png": "89504e",
    "image/bmp": "424d",
    "image/tiff": ["49492a00", "4d4d002a"]
};

/*globals qq*/
/**
 * Attempts to validate an image, wherever possible.
 *
 * @param blob File or Blob representing a user-selecting image.
 * @param log Uses this to post log messages to the console.
 * @constructor
 */
qq.ImageValidation = function(blob, log) {

    /**
     * @param limits Object with possible image-related limits to enforce.
     * @returns {boolean} true if at least one of the limits has a non-zero value
     */
    function hasNonZeroLimits(limits) {
        var atLeastOne = false;

        qq.each(limits, function(limit, value) {
            if (value > 0) {
                atLeastOne = true;
                return false;
            }
        });

        return atLeastOne;
    }

    /**
     * @returns {qq.Promise} The promise is a failure if we can't obtain the width & height.
     * Otherwise, `success` is called on the returned promise with an object containing
     * `width` and `height` properties.
     */
    function getWidthHeight() {
        var sizeDetermination = new qq.Promise();

        new qq.Identify(blob, log).isPreviewable().then(function() {
            var image = new Image(),
                url = window.URL && window.URL.createObjectURL ? window.URL :
                      window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL :
                      null;

            if (url) {
                image.onerror = function() {
                    log("Cannot determine dimensions for image.  May be too large.", "error");
                    sizeDetermination.failure();
                };

                image.onload = function() {
                    sizeDetermination.success({
                        width: this.width,
                        height: this.height
                    });
                };

                image.src = url.createObjectURL(blob);
            }
            else {
                log("No createObjectURL function available to generate image URL!", "error");
                sizeDetermination.failure();
            }
        }, sizeDetermination.failure);

        return sizeDetermination;
    }

    /**
     *
     * @param limits Object with possible image-related limits to enforce.
     * @param dimensions Object containing `width` & `height` properties for the image to test.
     * @returns {String || undefined} The name of the failing limit.  Undefined if no failing limits.
     */
    function getFailingLimit(limits, dimensions) {
        var failingLimit;

        qq.each(limits, function(limitName, limitValue) {
            if (limitValue > 0) {
                var limitMatcher = /(max|min)(Width|Height)/.exec(limitName),
                    dimensionPropName = limitMatcher[2].charAt(0).toLowerCase() + limitMatcher[2].slice(1),
                    actualValue = dimensions[dimensionPropName];

                /*jshint -W015*/
                switch (limitMatcher[1]) {
                    case "min":
                        if (actualValue < limitValue) {
                            failingLimit = limitName;
                            return false;
                        }
                        break;
                    case "max":
                        if (actualValue > limitValue) {
                            failingLimit = limitName;
                            return false;
                        }
                        break;
                }
            }
        });

        return failingLimit;
    }

    /**
     * Validate the associated blob.
     *
     * @param limits
     * @returns {qq.Promise} `success` is called on the promise is the image is valid or
     * if the blob is not an image, or if the image is not verifiable.
     * Otherwise, `failure` with the name of the failing limit.
     */
    this.validate = function(limits) {
        var validationEffort = new qq.Promise();

        log("Attempting to validate image.");

        if (hasNonZeroLimits(limits)) {
            getWidthHeight().then(function(dimensions) {
                var failingLimit = getFailingLimit(limits, dimensions);

                if (failingLimit) {
                    validationEffort.failure(failingLimit);
                }
                else {
                    validationEffort.success();
                }
            }, validationEffort.success);
        }
        else {
            validationEffort.success();
        }

        return validationEffort;
    };
};

/* globals qq */
/**
 * Module used to control populating the initial list of files.
 *
 * @constructor
 */
qq.Session = function(spec) {

    var options = {
        endpoint: null,
        params: {},
        customHeaders: {},
        cors: {},
        addFileRecord: function(sessionData) {},
        log: function(message, level) {}
    };

    qq.extend(options, spec, true);

    function isJsonResponseValid(response) {
        if (qq.isArray(response)) {
            return true;
        }

        options.log("Session response is not an array.", "error");
    }

    function handleFileItems(fileItems, success, xhrOrXdr, promise) {
        var someItemsIgnored = false;

        success = success && isJsonResponseValid(fileItems);

        if (success) {
            qq.each(fileItems, function(idx, fileItem) {
                /* jshint eqnull:true */
                if (fileItem.uuid == null) {
                    someItemsIgnored = true;
                    options.log(qq.format("Session response item {} did not include a valid UUID - ignoring.", idx), "error");
                }
                else if (fileItem.name == null) {
                    someItemsIgnored = true;
                    options.log(qq.format("Session response item {} did not include a valid name - ignoring.", idx), "error");
                }
                else {
                    try {
                        options.addFileRecord(fileItem);
                        return true;
                    }
                    catch (err) {
                        someItemsIgnored = true;
                        options.log(err.message, "error");
                    }
                }

                return false;
            });
        }

        promise[success && !someItemsIgnored ? "success" : "failure"](fileItems, xhrOrXdr);
    }

    // Initiate a call to the server that will be used to populate the initial file list.
    // Returns a `qq.Promise`.
    this.refresh = function() {
        /*jshint indent:false */
        var refreshEffort = new qq.Promise(),
            refreshCompleteCallback = function(response, success, xhrOrXdr) {
                handleFileItems(response, success, xhrOrXdr, refreshEffort);
            },
            requesterOptions = qq.extend({}, options),
            requester = new qq.SessionAjaxRequester(
                qq.extend(requesterOptions, {onComplete: refreshCompleteCallback})
            );

        requester.queryServer();

        return refreshEffort;
    };
};

/*globals qq, XMLHttpRequest*/
/**
 * Thin module used to send GET requests to the server, expecting information about session
 * data used to initialize an uploader instance.
 *
 * @param spec Various options used to influence the associated request.
 * @constructor
 */
qq.SessionAjaxRequester = function(spec) {

    var requester,
        options = {
            endpoint: null,
            customHeaders: {},
            params: {},
            cors: {
                expected: false,
                sendCredentials: false
            },
            onComplete: function(response, success, xhrOrXdr) {},
            log: function(str, level) {}
        };

    qq.extend(options, spec);

    function onComplete(id, xhrOrXdr, isError) {
        var response = null;

        /* jshint eqnull:true */
        if (xhrOrXdr.responseText != null) {
            try {
                response = qq.parseJson(xhrOrXdr.responseText);
            }
            catch (err) {
                options.log("Problem parsing session response: " + err.message, "error");
                isError = true;
            }
        }

        options.onComplete(response, !isError, xhrOrXdr);
    }

    requester = qq.extend(this, new qq.AjaxRequester({
        acceptHeader: "application/json",
        validMethods: ["GET"],
        method: "GET",
        endpointStore: {
            get: function() {
                return options.endpoint;
            }
        },
        customHeaders: options.customHeaders,
        log: options.log,
        onComplete: onComplete,
        cors: options.cors
    }));

    qq.extend(this, {
        queryServer: function() {
            var params = qq.extend({}, options.params);

            options.log("Session query request.");

            requester.initTransport("sessionRefresh")
                .withParams(params)
                .withCacheBuster()
                .send();
        }
    });
};

/* globals qq */
/**
 * Module that handles support for existing forms.
 *
 * @param options Options passed from the integrator-supplied options related to form support.
 * @param startUpload Callback to invoke when files "stored" should be uploaded.
 * @param log Proxy for the logger
 * @constructor
 */
qq.FormSupport = function(options, startUpload, log) {
    var self  = this,
        interceptSubmit = options.interceptSubmit,
        formEl = options.element,
        autoUpload = options.autoUpload;

    // Available on the public API associated with this module.
    qq.extend(this, {
        // To be used by the caller to determine if the endpoint will be determined by some processing
        // that occurs in this module, such as if the form has an action attribute.
        // Ignore if `attachToForm === false`.
        newEndpoint: null,

        // To be used by the caller to determine if auto uploading should be allowed.
        // Ignore if `attachToForm === false`.
        newAutoUpload: autoUpload,

        // true if a form was detected and is being tracked by this module
        attachedToForm: false,

        // Returns an object with names and values for all valid form elements associated with the attached form.
        getFormInputsAsObject: function() {
            /* jshint eqnull:true */
            if (formEl == null) {
                return null;
            }

            return self._form2Obj(formEl);
        }
    });

    // If the form contains an action attribute, this should be the new upload endpoint.
    function determineNewEndpoint(formEl) {
        if (formEl.getAttribute("action")) {
            self.newEndpoint = formEl.getAttribute("action");
        }
    }

    // Return true only if the form is valid, or if we cannot make this determination.
    // If the form is invalid, ensure invalid field(s) are highlighted in the UI.
    function validateForm(formEl, nativeSubmit) {
        if (formEl.checkValidity && !formEl.checkValidity()) {
            log("Form did not pass validation checks - will not upload.", "error");
            nativeSubmit();
        }
        else {
            return true;
        }
    }

    // Intercept form submit attempts, unless the integrator has told us not to do this.
    function maybeUploadOnSubmit(formEl) {
        var nativeSubmit = formEl.submit;

        // Intercept and squelch submit events.
        qq(formEl).attach("submit", function(event) {
            event = event || window.event;

            if (event.preventDefault) {
                event.preventDefault();
            }
            else {
                event.returnValue = false;
            }

            if ( validateForm(formEl, nativeSubmit) ) { startUpload(); }
        });

        // The form's `submit()` function may be called instead (i.e. via jQuery.submit()).
        // Intercept that too.
        formEl.submit = function() {
            if ( validateForm(formEl, nativeSubmit)) { startUpload(); }
        };
    }

    // If the element value passed from the uploader is a string, assume it is an element ID - select it.
    // The rest of the code in this module depends on this being an HTMLElement.
    function determineFormEl(formEl) {
        if (formEl) {
            if (qq.isString(formEl)) {
                formEl = document.getElementById(formEl);
            }

            if (formEl) {
                log("Attaching to form element.");
                determineNewEndpoint(formEl);
                if ( interceptSubmit ) { maybeUploadOnSubmit(formEl); }
            }
        }

        return formEl;
    }

    formEl = determineFormEl(formEl);
    this.attachedToForm = !!formEl;
};

qq.extend(qq.FormSupport.prototype, {
    // Converts all relevant form fields to key/value pairs.  This is meant to mimic the data a browser will
    // construct from a given form when the form is submitted.
    _form2Obj: function(form) {
        var obj = {},
            notIrrelevantType = function(type) {
                var irrelevantTypes = [
                    "button",
                    "image",
                    "reset",
                    "submit"
                ];

                return qq.indexOf(irrelevantTypes, type.toLowerCase()) < 0;
            },
            radioOrCheckbox = function(type) {
                return qq.indexOf(["checkbox", "radio"], type.toLowerCase()) >= 0;
            },
            ignoreValue = function(el) {
                if (radioOrCheckbox(el.type) && !el.checked) {
                    return true;
                }

                return el.disabled && el.type.toLowerCase() !== "hidden";
            },
            selectValue = function(select) {
                var value = null;

                qq.each(qq(select).children(), function(idx, child) {
                    if (child.tagName.toLowerCase() === "option" && child.selected) {
                        value = child.value;
                        return false;
                    }
                });

                return value;
            };

        qq.each(form.elements, function(idx, el) {
            if ((qq.isInput(el, true) || el.tagName.toLowerCase() === "textarea") &&
                notIrrelevantType(el.type) &&
                !ignoreValue(el)) {

                obj[el.name] = el.value;
            }
            else if (el.tagName.toLowerCase() === "select" && !ignoreValue(el)) {
                var value = selectValue(el);

                if (value !== null) {
                    obj[el.name] = value;
                }
            }
        });

        return obj;
    }
});

/* globals qq, ExifRestorer */
/**
 * Controls generation of scaled images based on a reference image encapsulated in a `File` or `Blob`.
 * Scaled images are generated and converted to blobs on-demand.
 * Multiple scaled images per reference image with varying sizes and other properties are supported.
 *
 * @param spec Information about the scaled images to generate.
 * @param log Logger instance
 * @constructor
 */
qq.Scaler = function(spec, log) {

    var self = this,
        customResizeFunction = spec.customResizer,
        includeOriginal = spec.sendOriginal,
        orient = spec.orient,
        defaultType = spec.defaultType,
        defaultQuality = spec.defaultQuality / 100,
        failedToScaleText = spec.failureText,
        includeExif = spec.includeExif,
        sizes = this._getSortedSizes(spec.sizes);

    // Revealed API for instances of this module
    qq.extend(this, {
        // If no targeted sizes have been declared or if this browser doesn't support
        // client-side image preview generation, there is no scaling to do.
        enabled: qq.supportedFeatures.scaling && sizes.length > 0,

        getFileRecords: function(originalFileUuid, originalFileName, originalBlobOrBlobData) {
            var self = this,
                records = [],
                originalBlob = originalBlobOrBlobData.blob ? originalBlobOrBlobData.blob : originalBlobOrBlobData,
                identifier = new qq.Identify(originalBlob, log);

            // If the reference file cannot be rendered natively, we can't create scaled versions.
            if (identifier.isPreviewableSync()) {
                // Create records for each scaled version & add them to the records array, smallest first.
                qq.each(sizes, function(idx, sizeRecord) {
                    var outputType = self._determineOutputType({
                        defaultType: defaultType,
                        requestedType: sizeRecord.type,
                        refType: originalBlob.type
                    });

                    records.push({
                        uuid: qq.getUniqueId(),
                        name: self._getName(originalFileName, {
                            name: sizeRecord.name,
                            type: outputType,
                            refType: originalBlob.type
                        }),
                        blob: new qq.BlobProxy(originalBlob,
                        qq.bind(self._generateScaledImage, self, {
                            customResizeFunction: customResizeFunction,
                            maxSize: sizeRecord.maxSize,
                            orient: orient,
                            type: outputType,
                            quality: defaultQuality,
                            failedText: failedToScaleText,
                            includeExif: includeExif,
                            log: log
                        }))
                    });
                });

                records.push({
                    uuid: originalFileUuid,
                    name: originalFileName,
                    size: originalBlob.size,
                    blob: includeOriginal ? originalBlob : null
                });
            }
            else {
                records.push({
                    uuid: originalFileUuid,
                    name: originalFileName,
                    size: originalBlob.size,
                    blob: originalBlob
                });
            }

            return records;
        },

        handleNewFile: function(file, name, uuid, size, fileList, batchId, uuidParamName, api) {
            var self = this,
                buttonId = file.qqButtonId || (file.blob && file.blob.qqButtonId),
                scaledIds = [],
                originalId = null,
                addFileToHandler = api.addFileToHandler,
                uploadData = api.uploadData,
                paramsStore = api.paramsStore,
                proxyGroupId = qq.getUniqueId();

            qq.each(self.getFileRecords(uuid, name, file), function(idx, record) {
                var blobSize = record.size,
                    id;

                if (record.blob instanceof qq.BlobProxy) {
                    blobSize = -1;
                }

                id = uploadData.addFile({
                    uuid: record.uuid,
                    name: record.name,
                    size: blobSize,
                    batchId: batchId,
                    proxyGroupId: proxyGroupId
                });

                if (record.blob instanceof qq.BlobProxy) {
                    scaledIds.push(id);
                }
                else {
                    originalId = id;
                }

                if (record.blob) {
                    addFileToHandler(id, record.blob);
                    fileList.push({id: id, file: record.blob});
                }
                else {
                    uploadData.setStatus(id, qq.status.REJECTED);
                }
            });

            // If we are potentially uploading an original file and some scaled versions,
            // ensure the scaled versions include reference's to the parent's UUID and size
            // in their associated upload requests.
            if (originalId !== null) {
                qq.each(scaledIds, function(idx, scaledId) {
                    var params = {
                        qqparentuuid: uploadData.retrieve({id: originalId}).uuid,
                        qqparentsize: uploadData.retrieve({id: originalId}).size
                    };

                    // Make sure the UUID for each scaled image is sent with the upload request,
                    // to be consistent (since we may need to ensure it is sent for the original file as well).
                    params[uuidParamName] = uploadData.retrieve({id: scaledId}).uuid;

                    uploadData.setParentId(scaledId, originalId);
                    paramsStore.addReadOnly(scaledId, params);
                });

                // If any scaled images are tied to this parent image, be SURE we send its UUID as an upload request
                // parameter as well.
                if (scaledIds.length) {
                    (function() {
                        var param = {};
                        param[uuidParamName] = uploadData.retrieve({id: originalId}).uuid;
                        paramsStore.addReadOnly(originalId, param);
                    }());
                }
            }
        }
    });
};

qq.extend(qq.Scaler.prototype, {
    scaleImage: function(id, specs, api) {

        if (!qq.supportedFeatures.scaling) {
            throw new qq.Error("Scaling is not supported in this browser!");
        }

        var scalingEffort = new qq.Promise(),
            log = api.log,
            file = api.getFile(id),
            uploadData = api.uploadData.retrieve({id: id}),
            name = uploadData && uploadData.name,
            uuid = uploadData && uploadData.uuid,
            scalingOptions = {
                customResizer: specs.customResizer,
                sendOriginal: false,
                orient: specs.orient,
                defaultType: specs.type || null,
                defaultQuality: specs.quality,
                failedToScaleText: "Unable to scale",
                sizes: [{name: "", maxSize: specs.maxSize}]
            },
            scaler = new qq.Scaler(scalingOptions, log);

        if (!qq.Scaler || !qq.supportedFeatures.imagePreviews || !file) {
            scalingEffort.failure();

            log("Could not generate requested scaled image for " + id + ".  " +
                "Scaling is either not possible in this browser, or the file could not be located.", "error");
        }
        else {
            (qq.bind(function() {
                // Assumption: There will never be more than one record
                var record = scaler.getFileRecords(uuid, name, file)[0];

                if (record && record.blob instanceof qq.BlobProxy) {
                    record.blob.create().then(scalingEffort.success, scalingEffort.failure);
                }
                else {
                    log(id + " is not a scalable image!", "error");
                    scalingEffort.failure();
                }
            }, this)());
        }

        return scalingEffort;
    },

    // NOTE: We cannot reliably determine at this time if the UA supports a specific MIME type for the target format.
    // image/jpeg and image/png are the only safe choices at this time.
    _determineOutputType: function(spec) {

        var requestedType = spec.requestedType,
            defaultType = spec.defaultType,
            referenceType = spec.refType;

        // If a default type and requested type have not been specified, this should be a
        // JPEG if the original type is a JPEG, otherwise, a PNG.
        if (!defaultType && !requestedType) {
            if (referenceType !== "image/jpeg") {
                return "image/png";
            }
            return referenceType;
        }

        // A specified default type is used when a requested type is not specified.
        if (!requestedType) {
            return defaultType;
        }

        // If requested type is specified, use it, as long as this recognized type is supported by the current UA
        if (qq.indexOf(Object.keys(qq.Identify.prototype.PREVIEWABLE_MIME_TYPES), requestedType) >= 0) {
            if (requestedType === "image/tiff") {
                return qq.supportedFeatures.tiffPreviews ? requestedType : defaultType;
            }

            return requestedType;
        }

        return defaultType;
    },

    // Get a file name for a generated scaled file record, based on the provided scaled image description
    _getName: function(originalName, scaledVersionProperties) {

        var startOfExt = originalName.lastIndexOf("."),
            versionType = scaledVersionProperties.type || "image/png",
            referenceType = scaledVersionProperties.refType,
            scaledName = "",
            scaledExt = qq.getExtension(originalName),
            nameAppendage = "";

        if (scaledVersionProperties.name && scaledVersionProperties.name.trim().length) {
            nameAppendage = " (" + scaledVersionProperties.name + ")";
        }

        if (startOfExt >= 0) {
            scaledName = originalName.substr(0, startOfExt);

            if (referenceType !== versionType) {
                scaledExt = versionType.split("/")[1];
            }

            scaledName += nameAppendage + "." + scaledExt;
        }
        else {
            scaledName = originalName + nameAppendage;
        }

        return scaledName;
    },

    // We want the smallest scaled file to be uploaded first
    _getSortedSizes: function(sizes) {

        sizes = qq.extend([], sizes);

        return sizes.sort(function(a, b) {
            if (a.maxSize > b.maxSize) {
                return 1;
            }
            if (a.maxSize < b.maxSize) {
                return -1;
            }
            return 0;
        });
    },

    _generateScaledImage: function(spec, sourceFile) {

        var self = this,
            customResizeFunction = spec.customResizeFunction,
            log = spec.log,
            maxSize = spec.maxSize,
            orient = spec.orient,
            type = spec.type,
            quality = spec.quality,
            failedText = spec.failedText,
            includeExif = spec.includeExif && sourceFile.type === "image/jpeg" && type === "image/jpeg",
            scalingEffort = new qq.Promise(),
            imageGenerator = new qq.ImageGenerator(log),
            canvas = document.createElement("canvas");

        log("Attempting to generate scaled version for " + sourceFile.name);

        imageGenerator.generate(sourceFile, canvas, {maxSize: maxSize, orient: orient, customResizeFunction: customResizeFunction}).then(function() {
            var scaledImageDataUri = canvas.toDataURL(type, quality),
                signalSuccess = function() {
                    log("Success generating scaled version for " + sourceFile.name);
                    var blob = qq.dataUriToBlob(scaledImageDataUri);
                    scalingEffort.success(blob);
                };

            if (includeExif) {
                self._insertExifHeader(sourceFile, scaledImageDataUri, log).then(function(scaledImageDataUriWithExif) {
                    scaledImageDataUri = scaledImageDataUriWithExif;
                    signalSuccess();
                },
                function() {
                    log("Problem inserting EXIF header into scaled image.  Using scaled image w/out EXIF data.", "error");
                    signalSuccess();
                });
            }
            else {
                signalSuccess();
            }
        }, function() {
            log("Failed attempt to generate scaled version for " + sourceFile.name, "error");
            scalingEffort.failure(failedText);
        });

        return scalingEffort;
    },

    // Attempt to insert the original image's EXIF header into a scaled version.
    _insertExifHeader: function(originalImage, scaledImageDataUri, log) {

        var reader = new FileReader(),
            insertionEffort = new qq.Promise(),
            originalImageDataUri = "";

        reader.onload = function() {
            originalImageDataUri = reader.result;
            insertionEffort.success(qq.ExifRestorer.restore(originalImageDataUri, scaledImageDataUri));
        };

        reader.onerror = function() {
            log("Problem reading " + originalImage.name + " during attempt to transfer EXIF data to scaled version.", "error");
            insertionEffort.failure();
        };

        reader.readAsDataURL(originalImage);

        return insertionEffort;
    },

    _dataUriToBlob: function(dataUri) {

        var byteString, mimeString, arrayBuffer, intArray;

        // convert base64 to raw binary data held in a string
        if (dataUri.split(",")[0].indexOf("base64") >= 0) {
            byteString = atob(dataUri.split(",")[1]);
        }
        else {
            byteString = decodeURI(dataUri.split(",")[1]);
        }

        // extract the MIME
        mimeString = dataUri.split(",")[0]
            .split(":")[1]
            .split(";")[0];

        // write the bytes of the binary string to an ArrayBuffer
        arrayBuffer = new ArrayBuffer(byteString.length);
        intArray = new Uint8Array(arrayBuffer);
        qq.each(byteString, function(idx, character) {
            intArray[idx] = character.charCodeAt(0);
        });

        return this._createBlob(arrayBuffer, mimeString);
    },

    _createBlob: function(data, mime) {

        var BlobBuilder = window.BlobBuilder ||
                window.WebKitBlobBuilder ||
                window.MozBlobBuilder ||
                window.MSBlobBuilder,
            blobBuilder = BlobBuilder && new BlobBuilder();

        if (blobBuilder) {
            blobBuilder.append(data);
            return blobBuilder.getBlob(mime);
        }
        else {
            return new Blob([data], {type: mime});
        }
    }
});

//Based on MinifyJpeg
//http://elicon.blog57.fc2.com/blog-entry-206.html

qq.ExifRestorer = (function()
{
   
	var ExifRestorer = {};
	 
    ExifRestorer.KEY_STR = "ABCDEFGHIJKLMNOP" +
                         "QRSTUVWXYZabcdef" +
                         "ghijklmnopqrstuv" +
                         "wxyz0123456789+/" +
                         "=";

    ExifRestorer.encode64 = function(input)
    {
        var output = "",
            chr1, chr2, chr3 = "",
            enc1, enc2, enc3, enc4 = "",
            i = 0;

        do {
            chr1 = input[i++];
            chr2 = input[i++];
            chr3 = input[i++];

            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;

            if (isNaN(chr2)) {
               enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
               enc4 = 64;
            }

            output = output +
               this.KEY_STR.charAt(enc1) +
               this.KEY_STR.charAt(enc2) +
               this.KEY_STR.charAt(enc3) +
               this.KEY_STR.charAt(enc4);
            chr1 = chr2 = chr3 = "";
            enc1 = enc2 = enc3 = enc4 = "";
        } while (i < input.length);

        return output;
    };
    
    ExifRestorer.restore = function(origFileBase64, resizedFileBase64)
    {
        var expectedBase64Header = "data:image/jpeg;base64,";

        if (!origFileBase64.match(expectedBase64Header))
        {
        	return resizedFileBase64;
        }       
        
        var rawImage = this.decode64(origFileBase64.replace(expectedBase64Header, ""));
        var segments = this.slice2Segments(rawImage);
                
        var image = this.exifManipulation(resizedFileBase64, segments);
        
        return expectedBase64Header + this.encode64(image);
        
    };


    ExifRestorer.exifManipulation = function(resizedFileBase64, segments)
    {
            var exifArray = this.getExifArray(segments),
                newImageArray = this.insertExif(resizedFileBase64, exifArray),
                aBuffer = new Uint8Array(newImageArray);

            return aBuffer;
    };


    ExifRestorer.getExifArray = function(segments)
    {
            var seg;
            for (var x = 0; x < segments.length; x++)
            {
                seg = segments[x];
                if (seg[0] == 255 & seg[1] == 225) //(ff e1)
                {
                    return seg;
                }
            }
            return [];
    };


    ExifRestorer.insertExif = function(resizedFileBase64, exifArray)
    {
            var imageData = resizedFileBase64.replace("data:image/jpeg;base64,", ""),
                buf = this.decode64(imageData),
                separatePoint = buf.indexOf(255,3),
                mae = buf.slice(0, separatePoint),
                ato = buf.slice(separatePoint),
                array = mae;

            array = array.concat(exifArray);
            array = array.concat(ato);
           return array;
    };


    
    ExifRestorer.slice2Segments = function(rawImageArray)
    {
        var head = 0,
            segments = [];

        while (1)
        {
            if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 218){break;}
            if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 216)
            {
                head += 2;
            }
            else
            {
                var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3],
                    endPoint = head + length + 2,
                    seg = rawImageArray.slice(head, endPoint);
                segments.push(seg);
                head = endPoint;
            }
            if (head > rawImageArray.length){break;}
        }

        return segments;
    };


    
    ExifRestorer.decode64 = function(input) 
    {
        var output = "",
            chr1, chr2, chr3 = "",
            enc1, enc2, enc3, enc4 = "",
            i = 0,
            buf = [];

        // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
        var base64test = /[^A-Za-z0-9\+\/\=]/g;
        if (base64test.exec(input)) {
            throw new Error("There were invalid base64 characters in the input text.  " +
                "Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='");
        }
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        do {
            enc1 = this.KEY_STR.indexOf(input.charAt(i++));
            enc2 = this.KEY_STR.indexOf(input.charAt(i++));
            enc3 = this.KEY_STR.indexOf(input.charAt(i++));
            enc4 = this.KEY_STR.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            buf.push(chr1);

            if (enc3 != 64) {
               buf.push(chr2);
            }
            if (enc4 != 64) {
               buf.push(chr3);
            }

            chr1 = chr2 = chr3 = "";
            enc1 = enc2 = enc3 = enc4 = "";

        } while (i < input.length);

        return buf;
    };

    
    return ExifRestorer;
})();

/* globals qq */
/**
 * Keeps a running tally of total upload progress for a batch of files.
 *
 * @param callback Invoked when total progress changes, passing calculated total loaded & total size values.
 * @param getSize Function that returns the size of a file given its ID
 * @constructor
 */
qq.TotalProgress = function(callback, getSize) {

    var perFileProgress = {},
        totalLoaded = 0,
        totalSize = 0,

        lastLoadedSent = -1,
        lastTotalSent = -1,
        callbackProxy = function(loaded, total) {
            if (loaded !== lastLoadedSent || total !== lastTotalSent) {
                callback(loaded, total);
            }

            lastLoadedSent = loaded;
            lastTotalSent = total;
        },

        /**
         * @param failed Array of file IDs that have failed
         * @param retryable Array of file IDs that are retryable
         * @returns true if none of the failed files are eligible for retry
         */
        noRetryableFiles = function(failed, retryable) {
            var none = true;

            qq.each(failed, function(idx, failedId) {
                if (qq.indexOf(retryable, failedId) >= 0) {
                    none = false;
                    return false;
                }
            });

            return none;
        },

        onCancel = function(id) {
            updateTotalProgress(id, -1, -1);
            delete perFileProgress[id];
        },

        onAllComplete = function(successful, failed, retryable) {
            if (failed.length === 0 || noRetryableFiles(failed, retryable)) {
                callbackProxy(totalSize, totalSize);
                this.reset();
            }
        },

        onNew = function(id) {
            var size = getSize(id);

            // We might not know the size yet, such as for blob proxies
            if (size > 0) {
                updateTotalProgress(id, 0, size);
                perFileProgress[id] = {loaded: 0, total: size};
            }
        },

        /**
         * Invokes the callback with the current total progress of all files in the batch.  Called whenever it may
         * be appropriate to re-calculate and disseminate this data.
         *
         * @param id ID of a file that has changed in some important way
         * @param newLoaded New loaded value for this file.  -1 if this value should no longer be part of calculations
         * @param newTotal New total size of the file.  -1 if this value should no longer be part of calculations
         */
        updateTotalProgress = function(id, newLoaded, newTotal) {
            var oldLoaded = perFileProgress[id] ? perFileProgress[id].loaded : 0,
                oldTotal = perFileProgress[id] ? perFileProgress[id].total : 0;

            if (newLoaded === -1 && newTotal === -1) {
                totalLoaded -= oldLoaded;
                totalSize -= oldTotal;
            }
            else {
                if (newLoaded) {
                    totalLoaded += newLoaded - oldLoaded;
                }
                if (newTotal) {
                    totalSize += newTotal - oldTotal;
                }
            }

            callbackProxy(totalLoaded, totalSize);
        };

    qq.extend(this, {
        // Called when a batch of files has completed uploading.
        onAllComplete: onAllComplete,

        // Called when the status of a file has changed.
        onStatusChange: function(id, oldStatus, newStatus) {
            if (newStatus === qq.status.CANCELED || newStatus === qq.status.REJECTED) {
                onCancel(id);
            }
            else if (newStatus === qq.status.SUBMITTING) {
                onNew(id);
            }
        },

        // Called whenever the upload progress of an individual file has changed.
        onIndividualProgress: function(id, loaded, total) {
            updateTotalProgress(id, loaded, total);
            perFileProgress[id] = {loaded: loaded, total: total};
        },

        // Called whenever the total size of a file has changed, such as when the size of a generated blob is known.
        onNewSize: function(id) {
            onNew(id);
        },

        reset: function() {
            perFileProgress = {};
            totalLoaded = 0;
            totalSize = 0;
        }
    });
};

/*globals qq */
// Base handler for UI (FineUploader mode) events.
// Some more specific handlers inherit from this one.
qq.UiEventHandler = function(s, protectedApi) {

    var disposer = new qq.DisposeSupport(),
        spec = {
            eventType: "click",
            attachTo: null,
            onHandled: function(target, event) {}
        };

    // This makes up the "public" API methods that will be accessible
    // to instances constructing a base or child handler
    qq.extend(this, {
        addHandler: function(element) {
            addHandler(element);
        },

        dispose: function() {
            disposer.dispose();
        }
    });

    function addHandler(element) {
        disposer.attach(element, spec.eventType, function(event) {
            // Only in IE: the `event` is a property of the `window`.
            event = event || window.event;

            // On older browsers, we must check the `srcElement` instead of the `target`.
            var target = event.target || event.srcElement;

            spec.onHandled(target, event);
        });
    }

    // These make up the "protected" API methods that children of this base handler will utilize.
    qq.extend(protectedApi, {
        getFileIdFromItem: function(item) {
            return item.qqFileId;
        },

        getDisposeSupport: function() {
            return disposer;
        }
    });

    qq.extend(spec, s);

    if (spec.attachTo) {
        addHandler(spec.attachTo);
    }
};

/* global qq */
qq.FileButtonsClickHandler = function(s) {

    var inheritedInternalApi = {},
        spec = {
            templating: null,
            log: function(message, lvl) {},
            onDeleteFile: function(fileId) {},
            onCancel: function(fileId) {},
            onRetry: function(fileId) {},
            onPause: function(fileId) {},
            onContinue: function(fileId) {},
            onGetName: function(fileId) {}
        },
        buttonHandlers = {
            cancel: function(id) { spec.onCancel(id); },
            retry:  function(id) { spec.onRetry(id); },
            deleteButton: function(id) { spec.onDeleteFile(id); },
            pause: function(id) { spec.onPause(id); },
            continueButton: function(id) { spec.onContinue(id); }
        };

    function examineEvent(target, event) {
        qq.each(buttonHandlers, function(buttonType, handler) {
            var firstLetterCapButtonType = buttonType.charAt(0).toUpperCase() + buttonType.slice(1),
                fileId;

            if (spec.templating["is" + firstLetterCapButtonType](target)) {
                fileId = spec.templating.getFileId(target);
                qq.preventDefault(event);
                spec.log(qq.format("Detected valid file button click event on file '{}', ID: {}.", spec.onGetName(fileId), fileId));
                handler(fileId);
                return false;
            }
        });
    }

    qq.extend(spec, s);

    spec.eventType = "click";
    spec.onHandled = examineEvent;
    spec.attachTo = spec.templating.getFileList();

    qq.extend(this, new qq.UiEventHandler(spec, inheritedInternalApi));
};

/*globals qq */
// Child of FilenameEditHandler.  Used to detect click events on filename display elements.
qq.FilenameClickHandler = function(s) {

    var inheritedInternalApi = {},
        spec = {
            templating: null,
            log: function(message, lvl) {},
            classes: {
                file: "qq-upload-file",
                editNameIcon: "qq-edit-filename-icon"
            },
            onGetUploadStatus: function(fileId) {},
            onGetName: function(fileId) {}
        };

    qq.extend(spec, s);

    // This will be called by the parent handler when a `click` event is received on the list element.
    function examineEvent(target, event) {
        if (spec.templating.isFileName(target) || spec.templating.isEditIcon(target)) {
            var fileId = spec.templating.getFileId(target),
                status = spec.onGetUploadStatus(fileId);

            // We only allow users to change filenames of files that have been submitted but not yet uploaded.
            if (status === qq.status.SUBMITTED) {
                spec.log(qq.format("Detected valid filename click event on file '{}', ID: {}.", spec.onGetName(fileId), fileId));
                qq.preventDefault(event);

                inheritedInternalApi.handleFilenameEdit(fileId, target, true);
            }
        }
    }

    spec.eventType = "click";
    spec.onHandled = examineEvent;

    qq.extend(this, new qq.FilenameEditHandler(spec, inheritedInternalApi));
};

/*globals qq */
// Child of FilenameEditHandler.  Used to detect focusin events on file edit input elements.
qq.FilenameInputFocusInHandler = function(s, inheritedInternalApi) {

    var spec = {
            templating: null,
            onGetUploadStatus: function(fileId) {},
            log: function(message, lvl) {}
        };

    if (!inheritedInternalApi) {
        inheritedInternalApi = {};
    }

    // This will be called by the parent handler when a `focusin` event is received on the list element.
    function handleInputFocus(target, event) {
        if (spec.templating.isEditInput(target)) {
            var fileId = spec.templating.getFileId(target),
                status = spec.onGetUploadStatus(fileId);

            if (status === qq.status.SUBMITTED) {
                spec.log(qq.format("Detected valid filename input focus event on file '{}', ID: {}.", spec.onGetName(fileId), fileId));
                inheritedInternalApi.handleFilenameEdit(fileId, target);
            }
        }
    }

    spec.eventType = "focusin";
    spec.onHandled = handleInputFocus;

    qq.extend(spec, s);
    qq.extend(this, new qq.FilenameEditHandler(spec, inheritedInternalApi));
};

/*globals qq */
/**
 * Child of FilenameInputFocusInHandler.  Used to detect focus events on file edit input elements.  This child module is only
 * needed for UAs that do not support the focusin event.  Currently, only Firefox lacks this event.
 *
 * @param spec Overrides for default specifications
 */
qq.FilenameInputFocusHandler = function(spec) {

    spec.eventType = "focus";
    spec.attachTo = null;

    qq.extend(this, new qq.FilenameInputFocusInHandler(spec, {}));
};

/*globals qq */
// Handles edit-related events on a file item (FineUploader mode).  This is meant to be a parent handler.
// Children will delegate to this handler when specific edit-related actions are detected.
qq.FilenameEditHandler = function(s, inheritedInternalApi) {

    var spec = {
            templating: null,
            log: function(message, lvl) {},
            onGetUploadStatus: function(fileId) {},
            onGetName: function(fileId) {},
            onSetName: function(fileId, newName) {},
            onEditingStatusChange: function(fileId, isEditing) {}
        };

    function getFilenameSansExtension(fileId) {
        var filenameSansExt = spec.onGetName(fileId),
            extIdx = filenameSansExt.lastIndexOf(".");

        if (extIdx > 0) {
            filenameSansExt = filenameSansExt.substr(0, extIdx);
        }

        return filenameSansExt;
    }

    function getOriginalExtension(fileId) {
        var origName = spec.onGetName(fileId);
        return qq.getExtension(origName);
    }

    // Callback iff the name has been changed
    function handleNameUpdate(newFilenameInputEl, fileId) {
        var newName = newFilenameInputEl.value,
            origExtension;

        if (newName !== undefined && qq.trimStr(newName).length > 0) {
            origExtension = getOriginalExtension(fileId);

            if (origExtension !== undefined) {
                newName = newName + "." + origExtension;
            }

            spec.onSetName(fileId, newName);
        }

        spec.onEditingStatusChange(fileId, false);
    }

    // The name has been updated if the filename edit input loses focus.
    function registerInputBlurHandler(inputEl, fileId) {
        inheritedInternalApi.getDisposeSupport().attach(inputEl, "blur", function() {
            handleNameUpdate(inputEl, fileId);
        });
    }

    // The name has been updated if the user presses enter.
    function registerInputEnterKeyHandler(inputEl, fileId) {
        inheritedInternalApi.getDisposeSupport().attach(inputEl, "keyup", function(event) {

            var code = event.keyCode || event.which;

            if (code === 13) {
                handleNameUpdate(inputEl, fileId);
            }
        });
    }

    qq.extend(spec, s);

    spec.attachTo = spec.templating.getFileList();

    qq.extend(this, new qq.UiEventHandler(spec, inheritedInternalApi));

    qq.extend(inheritedInternalApi, {
        handleFilenameEdit: function(id, target, focusInput) {
            var newFilenameInputEl = spec.templating.getEditInput(id);

            spec.onEditingStatusChange(id, true);

            newFilenameInputEl.value = getFilenameSansExtension(id);

            if (focusInput) {
                newFilenameInputEl.focus();
            }

            registerInputBlurHandler(newFilenameInputEl, id);
            registerInputEnterKeyHandler(newFilenameInputEl, id);
        }
    });
};

/*globals jQuery, qq*/
(function($) {
    var $el,
        pluginOptions = ["uploaderType", "endpointType"];

    function init(options) {
        var xformedOpts = transformVariables(options || {}),
            newUploaderInstance = getNewUploaderInstance(xformedOpts);

        uploader(newUploaderInstance);
        addCallbacks(xformedOpts, newUploaderInstance);

        return $el;
    }

    function getNewUploaderInstance(params) {
        var uploaderType = pluginOption("uploaderType"),
            namespace = pluginOption("endpointType");

        // If the integrator has defined a specific type of uploader to load, use that, otherwise assume `qq.FineUploader`
        if (uploaderType) {
            // We can determine the correct constructor function to invoke by combining "FineUploader"
            // with the upper camel cased `uploaderType` value.
            uploaderType = uploaderType.charAt(0).toUpperCase() + uploaderType.slice(1).toLowerCase();

            if (namespace) {
                return new qq[namespace]["FineUploader" + uploaderType](params);
            }

            return new qq["FineUploader" + uploaderType](params);
        }
        else {
            if (namespace) {
                return new qq[namespace].FineUploader(params);
            }

            return new qq.FineUploader(params);
        }
    }

    function dataStore(key, val) {
        var data = $el.data("fineuploader");

        if (val) {
            if (data === undefined) {
                data = {};
            }
            data[key] = val;
            $el.data("fineuploader", data);
        }
        else {
            if (data === undefined) {
                return null;
            }
            return data[key];
        }
    }

    //the underlying Fine Uploader instance is stored in jQuery's data stored, associated with the element
    // tied to this instance of the plug-in
    function uploader(instanceToStore) {
        return dataStore("uploader", instanceToStore);
    }

    function pluginOption(option, optionVal) {
        return dataStore(option, optionVal);
    }

    // Implement all callbacks defined in Fine Uploader as functions that trigger appropriately names events and
    // return the result of executing the bound handler back to Fine Uploader
    function addCallbacks(transformedOpts, newUploaderInstance) {
        var callbacks = transformedOpts.callbacks = {};

        $.each(newUploaderInstance._options.callbacks, function(prop, nonJqueryCallback) {
            var name, callbackEventTarget;

            name = /^on(\w+)/.exec(prop)[1];
            name = name.substring(0, 1).toLowerCase() + name.substring(1);
            callbackEventTarget = $el;

            callbacks[prop] = function() {
                var originalArgs = Array.prototype.slice.call(arguments),
                    transformedArgs = [],
                    nonJqueryCallbackRetVal, jqueryEventCallbackRetVal;

                $.each(originalArgs, function(idx, arg) {
                    transformedArgs.push(maybeWrapInJquery(arg));
                });

                nonJqueryCallbackRetVal = nonJqueryCallback.apply(this, originalArgs);

                try {
                    jqueryEventCallbackRetVal = callbackEventTarget.triggerHandler(name, transformedArgs);
                }
                catch (error) {
                    qq.log("Caught error in Fine Uploader jQuery event handler: " + error.message, "error");
                }

                /*jshint -W116*/
                if (nonJqueryCallbackRetVal != null) {
                    return nonJqueryCallbackRetVal;
                }
                return jqueryEventCallbackRetVal;
            };
        });

        newUploaderInstance._options.callbacks = callbacks;
    }

    //transform jQuery objects into HTMLElements, and pass along all other option properties
    function transformVariables(source, dest) {
        var xformed, arrayVals;

        if (dest === undefined) {
            if (source.uploaderType !== "basic") {
                xformed = { element: $el[0] };
            }
            else {
                xformed = {};
            }
        }
        else {
            xformed = dest;
        }

        $.each(source, function(prop, val) {
            if ($.inArray(prop, pluginOptions) >= 0) {
                pluginOption(prop, val);
            }
            else if (val instanceof $) {
                xformed[prop] = val[0];
            }
            else if ($.isPlainObject(val)) {
                xformed[prop] = {};
                transformVariables(val, xformed[prop]);
            }
            else if ($.isArray(val)) {
                arrayVals = [];
                $.each(val, function(idx, arrayVal) {
                    var arrayObjDest = {};

                    if (arrayVal instanceof $) {
                        $.merge(arrayVals, arrayVal);
                    }
                    else if ($.isPlainObject(arrayVal)) {
                        transformVariables(arrayVal, arrayObjDest);
                        arrayVals.push(arrayObjDest);
                    }
                    else {
                        arrayVals.push(arrayVal);
                    }
                });
                xformed[prop] = arrayVals;
            }
            else {
                xformed[prop] = val;
            }
        });

        if (dest === undefined) {
            return xformed;
        }
    }

    function isValidCommand(command) {
        return $.type(command) === "string" &&
            !command.match(/^_/) && //enforce private methods convention
            uploader()[command] !== undefined;
    }

    // Assuming we have already verified that this is a valid command, call the associated function in the underlying
    // Fine Uploader instance (passing along the arguments from the caller) and return the result of the call back to the caller
    function delegateCommand(command) {
        var xformedArgs = [],
            origArgs = Array.prototype.slice.call(arguments, 1),
            retVal;

        transformVariables(origArgs, xformedArgs);

        retVal = uploader()[command].apply(uploader(), xformedArgs);

        return maybeWrapInJquery(retVal);
    }

    // If the value is an `HTMLElement` or `HTMLDocument`, wrap it in a `jQuery` object
    function maybeWrapInJquery(val) {
        var transformedVal = val;

        // If the command is returning an `HTMLElement` or `HTMLDocument`, wrap it in a `jQuery` object
        /*jshint -W116*/
        if (val != null && typeof val === "object" &&
           (val.nodeType === 1 || val.nodeType === 9) && val.cloneNode) {

            transformedVal = $(val);
        }

        return transformedVal;
    }

    $.fn.fineUploader = function(optionsOrCommand) {
        var self = this, selfArgs = arguments, retVals = [];

        this.each(function(index, el) {
            $el = $(el);

            if (uploader() && isValidCommand(optionsOrCommand)) {
                retVals.push(delegateCommand.apply(self, selfArgs));

                if (self.length === 1) {
                    return false;
                }
            }
            else if (typeof optionsOrCommand === "object" || !optionsOrCommand) {
                init.apply(self, selfArgs);
            }
            else {
                $.error("Method " +  optionsOrCommand + " does not exist on jQuery.fineUploader");
            }
        });

        if (retVals.length === 1) {
            return retVals[0];
        }
        else if (retVals.length > 1) {
            return retVals;
        }

        return this;
    };

}(jQuery));

/*globals jQuery, qq*/
(function($) {
    var rootDataKey = "fineUploaderDnd",
        $el;

    function init(options) {
        if (!options) {
            options = {};
        }

        options.dropZoneElements = [$el];
        var xformedOpts = transformVariables(options);
        addCallbacks(xformedOpts);
        dnd(new qq.DragAndDrop(xformedOpts));

        return $el;
    }

    function dataStore(key, val) {
        var data = $el.data(rootDataKey);

        if (val) {
            if (data === undefined) {
                data = {};
            }
            data[key] = val;
            $el.data(rootDataKey, data);
        }
        else {
            if (data === undefined) {
                return null;
            }
            return data[key];
        }
    }

    function dnd(instanceToStore) {
        return dataStore("dndInstance", instanceToStore);
    }

    function addCallbacks(transformedOpts) {
        var callbacks = transformedOpts.callbacks = {};

        $.each(new qq.DragAndDrop.callbacks(), function(prop, func) {
            var name = prop,
                $callbackEl;

            $callbackEl = $el;

            callbacks[prop] = function() {
                var args = Array.prototype.slice.call(arguments),
                    jqueryHandlerResult = $callbackEl.triggerHandler(name, args);

                return jqueryHandlerResult;
            };
        });
    }

    //transform jQuery objects into HTMLElements, and pass along all other option properties
    function transformVariables(source, dest) {
        var xformed, arrayVals;

        if (dest === undefined) {
            xformed = {};
        }
        else {
            xformed = dest;
        }

        $.each(source, function(prop, val) {
            if (val instanceof $) {
                xformed[prop] = val[0];
            }
            else if ($.isPlainObject(val)) {
                xformed[prop] = {};
                transformVariables(val, xformed[prop]);
            }
            else if ($.isArray(val)) {
                arrayVals = [];
                $.each(val, function(idx, arrayVal) {
                    if (arrayVal instanceof $) {
                        $.merge(arrayVals, arrayVal);
                    }
                    else {
                        arrayVals.push(arrayVal);
                    }
                });
                xformed[prop] = arrayVals;
            }
            else {
                xformed[prop] = val;
            }
        });

        if (dest === undefined) {
            return xformed;
        }
    }

    function isValidCommand(command) {
        return $.type(command) === "string" &&
            command === "dispose" &&
            dnd()[command] !== undefined;
    }

    function delegateCommand(command) {
        var xformedArgs = [], origArgs = Array.prototype.slice.call(arguments, 1);
        transformVariables(origArgs, xformedArgs);
        return dnd()[command].apply(dnd(), xformedArgs);
    }

    $.fn.fineUploaderDnd = function(optionsOrCommand) {
        var self = this, selfArgs = arguments, retVals = [];

        this.each(function(index, el) {
            $el = $(el);

            if (dnd() && isValidCommand(optionsOrCommand)) {
                retVals.push(delegateCommand.apply(self, selfArgs));

                if (self.length === 1) {
                    return false;
                }
            }
            else if (typeof optionsOrCommand === "object" || !optionsOrCommand) {
                init.apply(self, selfArgs);
            }
            else {
                $.error("Method " +  optionsOrCommand + " does not exist in Fine Uploader's DnD module.");
            }
        });

        if (retVals.length === 1) {
            return retVals[0];
        }
        else if (retVals.length > 1) {
            return retVals;
        }

        return this;
    };

}(jQuery));
if (typeof define === 'function' && define.amd) {
   define(function() {
       return qq;
   });
}
else if (typeof module !== 'undefined' && module.exports) {
   module.exports = qq;
}
else {
   global.qq = qq;
}
}(window));

/*! 2016-06-16 */
