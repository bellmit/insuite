/*global describe, before, after, it, Y, should */

const
    fs = require( 'fs' ),
    util = require( 'util' ),
    shellexec = require( 'child_process' ).exec,

    copyFileP = util.promisify( fs.copyFile ),
    unlinkP = util.promisify( fs.unlink ),

    {formatPromiseResult, promisifyArgsCallback} = require( 'dc-core' ).utils,

    CLEAN_SAMPLE_FILE = 'assets/img/doccirrus/cirrus_cloud.jpg',
    MALWARE_SAMPLE = 'mojits/TestingMojit/tests/fixtures/malware-sample/eicar_base_64.zip.jpg.txt',

    cleanTempFile = Y.doccirrus.media.getTempFileName( {mime: 'IMAGE_JPEG', transform: 'test'} ),
    malwareTempFile = Y.doccirrus.media.getTempFileName( {mime: 'APPLICATION_ZIP', transform: 'test'} ),
    user = Y.doccirrus.auth.getSUForLocal();

describe( 'Test clamdscan malware scanning of file uploads', function() {
    describe( '1. Test media store integration', function() {

        const
            importMediaFromFileP = util.promisify( Y.doccirrus.media.importMediaFromFile ),
            importGridFileP = util.promisify( Y.doccirrus.media.gridfs.importFile );

        let mediaId;

        //  setup here
        //  the malware sample is base64 encoded to cut down on complaints from AV when checking out the repo

        before( async function() {
            const [err, shellCmd] = await formatPromiseResult(
                Y.doccirrus.binutilsapi.constructShellCommand( {
                    bin: 'base64',
                    shellArgs: [
                        '-d',
                        `"${process.cwd()}/${MALWARE_SAMPLE}"`,
                        '>',
                        `"${malwareTempFile}"`
                    ]
                } )
            );
            should.not.exist( err );
            should.exist( shellCmd );

            await shellexec( shellCmd );
            await copyFileP( CLEAN_SAMPLE_FILE, cleanTempFile );

            await Y.doccirrus.mongodb.runDb( {
                user,
                model: 'settings',
                action: 'update',
                query: {_id: '000000000000000000000001'},
                data: {
                    $set: {blockMalware: true}
                }
            } );

        } );

        it( 'Test import of clean file', async function() {
            let err, result;

            [err, result] = await formatPromiseResult( importMediaFromFileP(
                user,
                cleanTempFile,
                'activity',
                '1234',
                CLEAN_SAMPLE_FILE,
                CLEAN_SAMPLE_FILE,
                'OTHER'
            ) );

            should.not.exist( err );
            should.exist( result );
            result.should.be.an( 'object' );
            result.should.have.property( 'ownerId' ).with.lengthOf( 4 );

            mediaId = result._id;

            //  add the malware same to the gridfs for later tests
            await importGridFileP( user, mediaId, malwareTempFile, false );

            //  utility to print the GridFS objects.  Used for making test data for checking DOQUVIDE and activity transfer

            //
        } );

        it( 'Test import of malware sample file', async function() {
            let err, result, hasMsg;

            [err, result] = await formatPromiseResult( importMediaFromFileP(
                user,
                malwareTempFile,
                'activity',
                '1234',
                MALWARE_SAMPLE,
                MALWARE_SAMPLE,
                'OTHER'
            ) );

            should.exist( err );
            should.not.exist( result );

            if( Y.doccirrus.media.virusScanEnabled() ) {

                err.should.have.property( 'msg' );
                hasMsg = (-1 !== err.msg.indexOf( 'Win.Test.EICAR_HDB-1' ));
                (hasMsg).should.equal( true );

            } else {

                hasMsg = (-1 !== err.data.indexOf( 'Document type not recognized: ' ));
                (hasMsg).should.equal( true );

            }

        } );

        it( 'Check testing of files in the database', async function() {
            const virusScanGridFSP = util.promisify( Y.doccirrus.media.virusScanGridFS );
            let
                err, hasMsg;

            [err] = await formatPromiseResult( virusScanGridFSP( user, mediaId ) );

            if( Y.doccirrus.media.virusScanEnabled() ) {
                should.exist( err );
                err.should.have.property( 'msg' );

                hasMsg = (-1 !== err.msg.indexOf( 'Win.Test.EICAR_HDB-1' ));
                (hasMsg).should.equal( true );
            }

        } );

        it( 'Test checking of files in GridFS after received from a peer datasafe', async function() {
            const
                receiveGridFileEndP = promisifyArgsCallback( Y.doccirrus.api.activityTransfer.receiveGridFileEnd ),
                loadFileMetaP = util.promisify( Y.doccirrus.media.gridfs.loadFileMeta ),
                args = {
                    user: user,
                    data: {mediaId: mediaId}
                };

            await receiveGridFileEndP( args );

            //  after this step the infected file should have been detected and deleted

            try {
                await formatPromiseResult( loadFileMetaP( user, mediaId, false ) );
            } catch( err ) {
                err.should.have.property( 'code' );
                (err.code).should.equal( 404 );
            }
        } );

        //  cleanup here
        after( async function() {
            await unlinkP( cleanTempFile );
            await unlinkP( malwareTempFile );
        } );
    } );

} );
