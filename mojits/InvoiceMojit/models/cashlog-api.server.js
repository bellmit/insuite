/**
 * User: md
 * Date: 23/11/18  17:10
 * (c) 2018, Doc Cirrus GmbH, Berlin
 */

/*global YUI*/


YUI.add('cashlog-api', function (Y, NAME) {
        const
            pvslog = Y.doccirrus.api.pvslog,
            {formatPromiseResult} = require( 'dc-core' ).utils,
            util = require('util'),
            getDefaultUserContent = util.promisify( Y.doccirrus.api.activitysettings.getDefaultUserContent ),
            getModel = util.promisify( Y.doccirrus.mongodb.getModel ),
            i18n = Y.doccirrus.i18n,
            CONFIRM_CANCEL = i18n( 'InvoiceMojit.gkv_browserJS.message.CONFIRM_CANCEL' ),
            CONFIRM_CANCEL_DELETE = i18n( 'InvoiceMojit.gkv_browserJS.message.CONFIRM_CANCEL_DELETE' ),
            CONFIRM_DELETE = i18n( 'InvoiceMojit.gkv_browserJS.message.CONFIRM_DELETE' ),
            lodash  = require('lodash');


        /**
         * @method invoiceBatchCreation
         * @public
         *
         * create invoice from already collected data in cashlog just like in pvslog
         *
         * @param {Object} user
         * @param {Object} originalParams
         * @param {String} originalParams.cashLogId
         * @param {String} originalParams.formId        canonical id of form that should be used for invoice
         * @param {Boolean} forPDF                      if true then create APPROVED invoices
         * @param {Function} onProgress                 function triggered on each patient processed
         * @param {Function} onInvoiceCreated           function triggered on creation of the invoice
         * @param {Function} onFormResolved             function triggered on founding latest version of the form
         * @param {Function} callback
         *
         * @returns {Function} callback
         */
        async function invoiceBatchCreation( {user, originalParams: {cashLogId, canonicalId: formId}, forPDF, onProgress, onInvoiceCreated, onFormResolved, callback} ) {
            Y.log('Entering Y.doccirrus.api.cashlog.invoiceBatchCreation', 'info', NAME);
            if (callback) {
                callback = require(`${ process.cwd() }/server/utils/logWrapping.js`)(Y, NAME)
                    .wrapAndLogExitAsync(callback, 'Exiting Y.doccirrus.api.cashlog.invoiceBatchCreation');
            }
            let
                formVersion;

            if( !cashLogId || !formId ) {
                return callback( new Error( 'insufficient arguments' ) );
            }

            async function createInvoice( {locationId, employeeId, timestamp, caseFolderId, insuranceName, patientId, activities, icds, continuousIcds, autoGeneratedDate, formId, formVersion, invoiceLogId, invoiceData} ) {
                let data = {
                    status: forPDF ? 'APPROVED' : 'VALID',
                    actType: 'INVOICE',
                    locationId,
                    employeeId,
                    userContent: 'Privatrechnung',
                    timestamp,
                    caseFolderId,
                    patientId,
                    insuranceName,
                    autoGenerated: autoGeneratedDate,
                    skipcheck_: true,
                    activities: activities,
                    icds: icds,
                    continuousIcds,
                    formId: formId,
                    formVersion: formVersion,
                    ruleStatus: forPDF ? 'VALID' : 'NOT_VALIDATED', // set valid to invoice after approve
                    invoiceLogId
                };

                let err;

                let defaultUserContent;
                [err, defaultUserContent] = await formatPromiseResult(
                    getDefaultUserContent( user, 'INVOICE' )
                );
                if( err ) {
                    Y.log( `cashlog.createInvoice: Error getting default User Content: ${err.stack || err}`, 'error', NAME );
                    throw err;
                }
                if( defaultUserContent ) {
                    data.userContent = defaultUserContent;
                }
                Object.assign( data, invoiceData );

                data.content = Y.doccirrus.schemas.activity.generateContent( data );

                Y.log( 'invoiceBatchCreation: auto-generate invoice with data ' + JSON.stringify( data ), 'info', NAME );

                let invoicesId;
                [err, invoicesId] = await formatPromiseResult(
                    Y.doccirrus.mongodb.runDb( {
                        user,
                        action: 'post',
                        model: 'activity',
                        data: data,
                        context: {
                            autoCreation: true
                        }
                    } )
                );
                if( err ) {
                    Y.log(`cashlog.createInvoice: Error posting Invoice: ${err.stack || err}`, 'error', NAME);
                    throw err;
                }

                if(!forPDF){
                    return invoicesId;
                }

                let invoices;
                [ err, invoices ] = await formatPromiseResult(
                    Y.doccirrus.mongodb.runDb( {
                        user,
                        action: 'get',
                        model: 'activity',
                        query: {_id: invoicesId[0]}
                    } )
                );
                if( err ) {
                    Y.log(`cashlog.createInvoice: Error getting Invoice: ${err.stack || err}`, 'error', NAME);
                    throw err;
                }

                [ err ] = await formatPromiseResult(
                    new Promise( (resolve, reject) => {
                        Y.doccirrus.invoiceserverutils.assignAndSaveInvoiceNumber( user, invoices[0], 'APPROVED', (err) => {
                            if( err ){
                                return reject(err);
                            }
                            resolve();
                        } );
                    } )
                );
                if( err ) {
                    Y.log(`cashlog.createInvoice: Error approving Invoice: ${err.stack || err}`, 'error', NAME);
                    throw err;
                }

                return invoicesId;
            }

            let err;
            [ err ] = await formatPromiseResult(
                Y.doccirrus.mongodb.runDb( {
                    user,
                    action: 'update',
                    model: 'cashlog',
                    query: {_id: cashLogId},
                    data: {$set: {status: "INVOICING"}}
                } )
            );
            if( err ) {
                Y.log(`cashlog.invoiceBatchCreation: Error updating status INVOICING in cashlog: ${err.stack || err}`, 'error', NAME);
                return callback(err);
            }

            //getInvoiceFormVersion
            [ err, formVersion ] = await formatPromiseResult(
                new Promise( ( resolve, reject ) => {
                    function onCanonicalLoad( err, formTemplate ) {
                        if( err ) {
                            Y.log( 'could not load canonical form ' + err, 'error', NAME );
                            return reject( err );
                        }

                        if( !formTemplate || !formTemplate.latestVersionId ) {
                            Y.log( 'could not find latest version of "casefile-invoice" form', 'debug', NAME );
                            //  not an error
                            return resolve( '' );
                        }

                        Y.log( 'Found form version: ' + formTemplate.latestVersionId, 'debug', NAME );
                        resolve( formTemplate.latestVersionId );
                    }

                    Y.log( 'Looking up latest version of invoice form: ' + formId, 'debug', NAME );
                    Y.dcforms.loadForm( user, formId, '', onCanonicalLoad );
                } )
            );
            if( err ) {
                Y.log(`cashlog.invoiceBatchCreation: Error getting form version: ${err.stack || err}`, 'error', NAME);
                return callback(err);
            }

            if(onFormResolved){
                onFormResolved(formId, formVersion);
            }

            //getCashlog
            let cashlogs, cashlog;
            [ err, cashlogs ] = await formatPromiseResult(
                Y.doccirrus.mongodb.runDb( {
                    user,
                    action: 'get',
                    model: 'cashlog',
                    query: {_id: cashLogId}
                } )
            );
            if( err ) {
                Y.log(`cashlog.invoiceBatchCreation: Error getting cashlog: ${err.stack || err}`, 'error', NAME);
                return callback(err);
            }
            cashlog = cashlogs && cashlogs[0];

            const populate = (ids, activities) => {
                ids.forEach( function( activity ) {
                    if( !activity._id || activity.__additional ) {
                        return;
                    }
                    activities.push( activity._id );
                } );
            };

            let toProcess = {}, autoGeneratedDate = new Date();

            await Y.doccirrus.invoiceprocess.forEachInvoiceEntry( {
                user,
                invoiceLogId: cashlog._id,
                excludedPatientIds: cashlog.excludedPatientIds,
                excludedScheinIds: cashlog.excludedScheinIds,
                unknownInsuranceScheinIds: cashlog.unknownInsuranceScheinIds,
                iterator: function( invoiceEntry ) {
                    let schein, treatmentsIds = [], diagnosisIds = [], continuousDiagnosisIds = [], insuranceStatuses, insuranceName;
                    if( 'schein' === invoiceEntry.type ) {
                        schein = invoiceEntry.data;
                        insuranceStatuses = schein.patient && schein.patient.insuranceStatus;

                        for( let insurance of insuranceStatuses ) {
                            if( insurance.type === schein.caseFolderTypeSingle ) {
                                if( insurance.insuranceName ) {
                                    insuranceName = insurance.insuranceName;
                                }
                                if( insurance.insurancePrintName ) {
                                    insuranceName = insurance.insurancePrintName;
                                }
                            }
                        }

                        populate( schein.treatments, treatmentsIds );
                        populate( schein.diagnoses, diagnosisIds );
                        populate( schein.continuousDiagnoses, continuousDiagnosisIds );

                        if(treatmentsIds.length || diagnosisIds.length){
                            let patientId = schein.patient._id;
                            if( !toProcess[patientId] ){ toProcess[patientId] = []; }
                            toProcess[patientId].push({
                                timestamp: autoGeneratedDate,
                                patientId,
                                insuranceName,
                                caseFolderId: schein.caseFolderId,
                                locationId: schein.locationId && schein.locationId.toString(),
                                employeeId: schein.employeeId,
                                icds: [ ...diagnosisIds ],
                                continuousIcds: [ ...continuousDiagnosisIds ],
                                activities: [ ...treatmentsIds ],
                                receipts: [],
                                autoGeneratedDate,
                                formId,
                                formVersion,
                                invoiceLogId: cashlog._id,
                                invoiceData: schein.invoiceData && schein.invoiceData[0]
                            });
                        }
                    }
                }
            } );

            let processed = 0, totalCount = Object.keys( toProcess ).length;
            const processIvoiceCreation = async ( toCreate ) => {
                let err, invoicesId;

                [ err, invoicesId ] = await formatPromiseResult( createInvoice( toCreate ) );

                //  Initialize the form for the new invoice, MOJ-11401
                const initializeFormForActivityP = util.promisify( Y.doccirrus.forms.mappinghelper.initializeFormForActivity );
                [ err ] = await formatPromiseResult( initializeFormForActivityP( user, `${invoicesId[0]}`, {}, null ) );

                if ( err ) {
                    Y.log( `Problem initializing form for this invoice ${invoicesId[0]}: ${err.stack||err}`, 'error', NAME );
                } else {
                    Y.log( `Initialized form for invoice ${invoicesId[0]}`, 'info', NAME );
                }

                return invoicesId;
            };

            for( let patientId in toProcess ){
                if(toProcess.hasOwnProperty(patientId)){
                    for( let toCreate of toProcess[patientId] ){
                        let cratedInvoices;
                        [ err, cratedInvoices ] = await formatPromiseResult(
                            processIvoiceCreation(toCreate)
                        );
                        if( err ) {
                            Y.log(`cashlog.invoiceBatchCreation: Error creating invoice: ${err.stack || err}`, 'error', NAME);
                            return callback(err);
                        }

                        if(onInvoiceCreated){
                            onInvoiceCreated( cratedInvoices );
                        }
                    }
                    ++processed;
                    if(onProgress){
                        onProgress( cashlog._id, {
                            total: totalCount,
                            current: processed,
                            percent: parseInt( 100 * ( processed / totalCount ), 10 ),
                            label: 'Rechnungen (' + processed + '/' + totalCount + ')'
                        } );
                    }
                }
            }

            [ err ] = await formatPromiseResult(
                Y.doccirrus.mongodb.runDb( {
                    user,
                    action: 'update',
                    model: 'cashlog',
                    query: {_id: cashLogId},
                    data: {$set: {status: forPDF ? 'INVOICED_APPROVED' : 'INVOICED'}}
                } )
            );
            if( err ) {
                Y.log(`cashlog.invoiceBatchCreation: Error updating status INVOICED in cashlog: ${err.stack || err}`, 'error', NAME);
                return callback(err);
            }

            return callback();
            //============================================
        }

        /***
         *  When an invoice is cancelled from the cashbook/casefile then it should also be removed from the cashlog
         *  and references cleaned up in linked activities
         *
         *  @param  {Object}    user
         *  @param  {Object}    activity        Should be an invoice
         */

        async function cancelSingleInvoice( user, activity ) {
            let err;

            //  For each linked treatment, remove the reference to the invoice log
            //  Until the reference is removed, treatments will no tbe collected into a new invoice

            let
                unsetParams = {
                    'user': user,
                    'model': 'activity',
                    'action': 'update',
                    'migrate': true,
                    'query': {
                        'actType': { '$in': [ 'TREATMENT', 'DIAGNOSIS', 'PKVSCHEIN' ] },
                        '_id': 'ITERATED'
                    },
                    'data': {
                        '$unset': {
                            'invoiceLogId': '',
                            'invoiceLogType': ''
                        }
                    }
                },
                linkedIds = [],
                i;

            if ( activity.activities ) {
                linkedIds = linkedIds.concat( activity.activities );
            }
            if ( activity.icds ) {
                linkedIds = linkedIds.concat( activity.icds );
            }

            //  Clear all references individually - number on invoice may exceed safety limit from db layer.

            for ( i = 0; i < linkedIds.length; i++ ) {
                unsetParams.query._id = linkedIds[i];

                Y.log( `Clearing invoiceLog references from treatment on cancelled invoice: ${unsetParams.query._id}`, 'debug', NAME );
                [ err ] = await formatPromiseResult( Y.doccirrus.mongodb.runDb( unsetParams ) );

                if ( err ) {
                    Y.log( `Error while clearing invoiceLogId on cancelled invoice: ${err.stack||err}`, 'error', NAME );
                    throw err;
                }
            }

            //  FUTURE: update display of these items in the cashlog
        }

        async  function getReplaceDialogContent( args  ) {
            let
                err, result, {callback} = args;

            [err, result] = await formatPromiseResult( Y.doccirrus.mongodb.runDb( {
                action: 'aggregate',
                model: 'activity',
                user: args.user,
                pipeline: [
                    {$match: args.query},
                    {
                        $project: {
                            _id: 1,
                            status: 1,
                            timestamp: 1,
                            price: 1,
                            invoiceNo: 1,
                            patientFirstName: 1,
                            patientLastName: 1,
                            ruleStatus: 1,
                            group_status: {
                                $cond: [
                                    {
                                        $eq: ["$status", 'VALID']
                                    }, 'VALID',
                                    {$cond: [{$eq: ["$status", 'APPROVED']}, 'APPROVED', 'OTHER']}]
                            }
                        }
                    },
                    {$sort: {timestamp: -1}},
                    {
                        $group: {
                            _id: "$group_status",
                            cnt: {$sum: 1},
                            docs: {
                                $push: {
                                    _id: "$_id",
                                    timestamp: "$timestamp",
                                    status: "$status",
                                    price: "$price",
                                    invoiceNo: "$invoiceNo",
                                    patientFirstName: "$patientFirstName",
                                    patientLastName: "$patientLastName",
                                    ruleStatus: "$ruleStatus"
                                }
                            }
                        }
                    },
                    {$project: {_id: 1, cnt: 1, docs: {$slice: ["$docs", 10]}}}
                ],
                options: args.options
            } ) );

            if( err ) {
                Y.log( `Error when getting ivoices: ${err.stack || err}`, 'error', NAME );
                return callback( err );
            }

            result = result.result ? result.result : result;
            let
                dialogFirstLine = "",
                invoices = {},
                groupIds = ["APPROVED", "OTHER", "VALID"];

            groupIds.forEach( ( groupId ) => {
                invoices[groupId] = lodash.find( result, {_id: groupId} ) || null;
            } );

            if( invoices.VALID && invoices.APPROVED ) {
                    dialogFirstLine = CONFIRM_CANCEL_DELETE;
            } else if( invoices.VALID ) {
                    dialogFirstLine = CONFIRM_DELETE;
                } else {
                    dialogFirstLine = CONFIRM_CANCEL;
                }

            callback( err, {
                canBeCanceled: ((invoices.VALID || {}).docs || []).concat( (invoices.APPROVED || {}).docs || [] ),
                canNotBeCanceled: (invoices.OTHER || {}).docs || [],
                dialogFirstLine,
                canBeCanceledTotal: ((invoices.VALID || {}).cnt || 0) + ((invoices.APPROVED || {}).cnt || 0 ),
                canNotBeCanceledTotal: (invoices.OTHER || {}).cnt || 0
            } );
        }

        Y.namespace('doccirrus.api').cashlog = {
            name: NAME,

            //most of functionality reuse pvslog api; main difference is from where receive data from pvslog or cashlog
            server: {
                isContentOutdated: pvslog.server.isContentOutdated
            },

            get: ( args ) => {
                args.originalParams = { ...args.originalParams, cashlog: true };
                pvslog.get( args );
            },
            createLogs: ( args ) => {
                args.originalParams = { ...args.originalParams, cashlog: true };
                pvslog.createLogs( args );
            },
            remove: ( args ) => {
                args.originalParams = { ...args.originalParams, cashlog: true };
                pvslog.remove( args );
            },
            validate: ( args ) => {
                args.originalParams = { ...args.originalParams, cashlog: true };
                pvslog.validate( args );
            },
            replace: async ( args ) => {
                Y.log('Entering Y.doccirrus.api.cashlog.replace', 'info', NAME);
                if (args.callback) {
                    args.callback = require(`${ process.cwd() }/server/utils/logWrapping.js`)(Y, NAME)
                        .wrapAndLogExitAsync(args.callback, 'Exiting Y.doccirrus.api.cashlog.replace');
                }

                //cancel only APPROVED and VALID invoices
                const
                    {user, originalParams: {id}, callback} = args,
                    DCError = Y.doccirrus.commonerrors.DCError,
                    ALLOWED_STATUSES = ['INVOICED', 'INVOICED_APPROVED', 'REPLACE_ERR'];

                let err, getLock;
                [ err, getLock] = await formatPromiseResult(
                    Y.doccirrus.cacheUtils.dataCache.acquireLock( {
                        key: 'invoicing',
                        data: `cashlog|replace|${user.U}|${(new Date()).getTime()}|0`
                    } )
                );
                if( err ){
                    Y.log(`cashlog.replace: Error acquiring lock: ${err.message || err}`, 'error', NAME);
                    return callback(err);
                }
                if( !getLock || !getLock.length || 1 !== getLock[0] ) {
                    return callback( Y.doccirrus.invoiceserverutils.getLockNotification( getLock ) );
                }

                let activityModel;
                [ err, activityModel ] = await formatPromiseResult(
                    getModel( user, 'activity', false )
                );
                if( err ) {
                    Y.log(`cashlog.replace: Error getting activity model: ${err.stack || err}`, 'error', NAME);
                    Y.doccirrus.invoiceserverutils.releaseLock( 'invoicing' );
                    return callback(err);
                }

                let stream;
                [ err ] = await formatPromiseResult(
                    new Promise( ( resolve, reject ) => {
                        stream = activityModel.mongoose.find( {
                            actType: 'INVOICE',
                            status: {$in: ['VALID', 'APPROVED']},
                            invoiceLogId: id
                        }, {}, { timeout: true } ).lean().stream();

                        stream.on( 'data', async (activity) => {
                            stream.pause();
                            const
                                fsmName = Y.doccirrus.schemas.activity.getFSMName( activity.actType ),
                                operation = 'VALID' === activity.status ? 'delete' : 'cancel';
                            [ err ] = await formatPromiseResult(
                                new Promise( (resolve, reject) => {
                                    Y.doccirrus.fsm[fsmName][operation]( user, {}, activity, false, ( err ) => {
                                        if( err ){
                                            return reject( err );
                                        }
                                        resolve();
                                    } );
                                })
                            );
                            if( err ) {
                                Y.log(`cashlog.replace: Error do ${operation} transition for invoice: ${err.stack || err}`, 'error', NAME);
                                return reject(err);
                            }
                            stream.resume();
                        } ).on( 'error',  err => {
                            Y.log( `cashlog.replace: stream activity error ${err.stack || err}`, 'error', NAME );
                            return reject( err );
                        } ).on( 'end', () => {
                            return resolve();
                        } );
                    } )
                );

                if( err ) {
                    Y.log(`cashlog.replace: Error canceling/deleting invoices: ${err.stack || err}`, 'error', NAME);
                    Y.doccirrus.invoiceserverutils.releaseLock( 'invoicing' );
                    return callback(err);
                }

                Y.doccirrus.invoiceserverutils.releaseLock( 'invoicing' );

                [err] = await formatPromiseResult( Y.doccirrus.api.invoicelog.server.replace( {
                    user,
                    invoiceLogId: id,
                    invoiceLogType: 'CASH',
                    onlyApproved: true,
                    preChecks: ( kbvLog ) => {
                        const statusTransitionAllowed = ALLOWED_STATUSES.includes( kbvLog.status );
                        if( !statusTransitionAllowed ) {
                            throw new DCError( 2037 );
                        }
                    },
                    createNewLog: async ( pvsLog ) => {
                        let result;
                        [err, result] = await formatPromiseResult( Y.doccirrus.api.pvslog.server.createPvsLog( user, pvsLog, true ) );

                        if( err ) {
                            Y.log( `createNewLog: could not create kbvlog: ${err.stack || err}`, 'warn', NAME );
                            throw err;
                        }

                        return result;
                    }
                } ) );

                if( err ) {
                    Y.log( `could not replace cashlog ${err.stack || err}`, 'warn', NAME );
                    callback( err );
                    return;
                }
                callback();
            },
            invoiceBatchCreation,
            cancelSingleInvoice,
            getReplaceDialogContent
        };
    },
    '0.0.1', {requires: ['pvslog-api', 'activity-api']}
);
